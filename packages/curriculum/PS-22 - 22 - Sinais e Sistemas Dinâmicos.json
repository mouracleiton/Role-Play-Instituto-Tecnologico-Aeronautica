{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T16:14:47.274Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - PS-22",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 320,
      "startDate": "2025-02-17",
      "duration": "5 anos",
      "dailyStudyHours": 8,
      "version": "PS-22",
      "institution": "Instituto Tecnológico de Aeronáutica (ITA)",
      "basedOn": "Catálogo dos Cursos de Graduação 2025 - PS-22"
    },
    "areas": [
      {
        "id": "10",
        "name": "Engenharia Aeronáutica",
        "description": "Curso de Graduação em Engenharia Aeronáutica do ITA",
        "disciplines": [
          {
            "id": "10.1",
            "name": "PS-22 - 22 - Sinais e Sistemas Dinâmicos",
            "description": "dinâmicos lineares. Sinais utilizados em análise e identificação de sistemas. Análise de sistemas lineares, contínuos no tempo: resposta ao impulso, integral de convolução, função de transferência e função de resposta em frequência – propriedades e determinação da solução de modelos. Diagrama de blocos. Linearização de modelos. Modelagem no espaço de estados. Análise de sinais contínuos e discretos no tempo: série e transformada de Fourier, janelamento, amostragem e transformada de Fourier discreta. Aplicações em sistemas mecânicos, eletromecânicos, térmicos e hidráulicos. Bibliografia: LATHI, B. P. Sinais e sistemas lineares. 2. ed. Porto Alegre: Bookman, 2007. OPPENHEIM, A. V.; WILLSKY, A. S., NAWAB, S. H. Sinais e sistemas. 2. ed. São Paulo: Prentice Hall, 2010. OGATA, K. Engenharia de controle moderno. 5. ed. São Paulo: Pearson Prentice Hall, 2010.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Sinais em Análise e Identificação de Sistemas",
                "description": "Apresenta sinais utilizados na análise e identificação de sistemas dinâmicos lineares.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Sinal Impulso Unitário",
                    "description": "Definição e propriedades do sinal δ(t), essencial para determinar a resposta ao impulso em sistemas dinâmicos lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição do Sinal Impulso Unitário δ(t)",
                        "description": "Compreender a definição formal e intuitiva do sinal impulso unitário δ(t), representado como uma distribuição de Dirac com área unitária concentrada em t=0.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Definir informalmente o sinal δ(t)",
                            "description": "Explicar o sinal impulso unitário como uma função que é nula para t ≠ 0, infinita em t=0, e cuja integral sobre todo o eixo real é igual a 1, destacando sua natureza idealizada para modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Contextualizar o sinal impulso em sistemas dinâmicos",
                                  "subSteps": [
                                    "Pesquise o conceito de 'impulso' em física, como uma força aplicada por tempo infinitesimal.",
                                    "Relacione com sinais em engenharia: impulses modelam entradas abruptas em sistemas lineares invariantes no tempo (LTI).",
                                    "Identifique exemplos em aeronáutica, como colisão ou ejeção de massa.",
                                    "Anote por que um sinal finito não captura um impulso 'puro'.",
                                    "Desenhe um gráfico conceitual de um impulso físico aproximado (pico estreito e alto)."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando um impulso físico vs. ideal e explique a transição para δ(t).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a recursos online sobre sinais LTI (ex: Khan Academy ou livro de Oppenheim)"
                                  ],
                                  "tips": [
                                    "Comece com analogias físicas para intuitar antes da matemática.",
                                    "Use vídeos curtos de simulações de impactos para visualização."
                                  ],
                                  "learningObjective": "Compreender o papel do sinal impulso como entrada idealizada em análise de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir impulso com degrau unitário.",
                                    "Ignorar o contexto de sistemas LTI."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o comportamento qualitativo do δ(t)",
                                  "subSteps": [
                                    "Defina δ(t) = 0 para todo t ≠ 0.",
                                    "Explique que δ(t) → ∞ em t = 0, mas de forma 'controlada'.",
                                    "Discuta que não é uma função convencional, mas uma distribuição ou 'função generalizada'.",
                                    "Esboce graficamente: eixo t com seta infinita em t=0 e zero elsewhere.",
                                    "Compare com funções normais: nenhuma função pontual comum satisfaz isso."
                                  ],
                                  "verification": "Escreva uma definição verbal precisa e desenhe o gráfico simbólico de δ(t).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos de referência de δ(t) em livros ou online"
                                  ],
                                  "tips": [
                                    "Pense em δ(t) como limite de pulsos cada vez mais estreitos e altos.",
                                    "Evite tentar plotar numericamente; foque no qualitativo."
                                  ],
                                  "learningObjective": "Descrever precisamente o comportamento do δ(t) para t≠0 e t=0.",
                                  "commonMistakes": [
                                    "Tratar δ(t) como função comum integrável ponto a ponto.",
                                    "Esquecer que é zero rigorosamente para t≠0."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a propriedade fundamental da integral unitária",
                                  "subSteps": [
                                    "Estabeleça ∫_{-∞}^{∞} δ(t) dt = 1.",
                                    "Demonstre intuitivamente: área sob a curva é sempre 1, independentemente da altura infinita.",
                                    "Use aproximações: considere retângulos de largura ε→0, altura 1/ε, área=1.",
                                    "Calcule simbolicamente para propriedade de sifting: ∫ f(t) δ(t) dt = f(0).",
                                    "Verifique com exemplo simples: f(t)=t, integral=0."
                                  ],
                                  "verification": "Resolva 2-3 integrais envolvendo δ(t) e confirme o resultado unitário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: Wolfram Alpha)",
                                    "Papel para esboços de limites"
                                  ],
                                  "tips": [
                                    "Visualize a área conservada no limite.",
                                    "Pratique a propriedade de sifting com funções teste."
                                  ],
                                  "learningObjective": "Dominar a propriedade de área unitária e seu papel na representação de energia.",
                                  "commonMistakes": [
                                    "Confundir integral com valor em t=0.",
                                    "Esquecer limites de -∞ a ∞."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar a natureza idealizada e aplicações em modelagem",
                                  "subSteps": [
                                    "Explique que δ(t) é idealizado: não existe fisicamente, mas aproxima eventos rápidos.",
                                    "Discuta aproximações reais: pulsos gaussianos estreitos ou funções porta.",
                                    "Relacione com identificação de sistemas: resposta ao impulso revela dinâmica.",
                                    "Anote limitações: em sistemas reais, largura finita devido a física.",
                                    "Crie uma tabela: Propriedades ideais vs. Aproximações práticas."
                                  ],
                                  "verification": "Redija um parágrafo resumindo por que δ(t) é útil apesar de idealizado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (ex: MATLAB, Python Matplotlib)",
                                    "Exemplos de livros de controle/sinais"
                                  ],
                                  "tips": [
                                    "Gere plots de aproximações δ_ε(t) para ver convergência.",
                                    "Ligue à resposta impulso h(t) em sistemas aeroespaciais."
                                  ],
                                  "learningObjective": "Reconhecer δ(t) como ferramenta de modelagem abstrata para eventos impulsivos.",
                                  "commonMistakes": [
                                    "Acreditar que δ(t) é 'real' e não uma abstração.",
                                    "Ignorar necessidade de regularização em simulações numéricas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de impacto de pássaro em aeronave, modele a força como δ(t) centrado no tempo de colisão para calcular deslocamento instantâneo via convolução com a função de resposta do sistema.",
                              "finalVerifications": [
                                "Descreve verbalmente δ(t)=0 para t≠0, ∞ em t=0.",
                                "Confirma ∫ δ(t) dt =1 sobre ℝ.",
                                "Explica propriedade de sifting com exemplo.",
                                "Identifica δ(t) como idealizado para modelagem de impulsos.",
                                "Diferencia de aproximações reais como pulsos estreitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição qualitativa (ausência/presença).",
                                "Correta interpretação da integral unitária.",
                                "Entendimento da natureza não-funcional/distribuição.",
                                "Aplicação contextual em sistemas dinâmicos.",
                                "Uso de analogias físicas adequadas.",
                                "Identificação de limitações idealizadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Impulso mecânico (F Δt = Δp).",
                                "Matemática: Distribuições de Dirac e teoria de medidas.",
                                "Processamento de Sinais: Resposta ao impulso em filtros.",
                                "Probabilidade: Densidade delta em variáveis aleatórias degeneradas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, δ(t) modela excitações impulsivas como ejeção de contramedidas ou impactos, permitindo identificação da função de transferência via resposta h(t) para análise de estabilidade e controle de voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Representar δ(t) como limite de sequências de funções",
                            "description": "Descrever δ(t) como o limite de uma sequência de pulsos retangulares ou triangulares de largura tendendo a zero e altura ajustada para manter área unitária, ilustrando graficamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades fundamentais da função delta de Dirac δ(t)",
                                  "subSteps": [
                                    "Estude a definição formal de δ(t) como uma distribuição que satisfaz ∫_{-∞}^{∞} δ(t) dt = 1 e δ(t) = 0 para t ≠ 0.",
                                    "Revise propriedades como linearidade, escalamento temporal e o teorema do sifting: ∫_{-∞}^{∞} f(t) δ(t - t0) dt = f(t0).",
                                    "Analise por que δ(t) não é uma função convencional, mas um limite de funções regulares.",
                                    "Esboce intuitivamente δ(t) como uma seta infinita em t=0 com área unitária.",
                                    "Discuta motivação em sistemas dinâmicos: resposta ao impulso unitário."
                                  ],
                                  "verification": "Resuma em 3 frases as propriedades chave e esboce δ(t) idealizado; confirme com auto-perguntas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas, caderno para anotações, calculadora.",
                                  "tips": "Use analogias como 'pico de tensão infinita em circuito' para fixar o conceito.",
                                  "learningObjective": "Compreender δ(t) como distribuição e sua relevância em análise de sistemas.",
                                  "commonMistakes": "Confundir δ(t) com uma função ordinária tratável por limites ponto a ponto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e analisar sequência de pulsos retangulares aproximando δ(t)",
                                  "subSteps": [
                                    "Defina o pulso retangular: π_ε(t) = (1/ε) para |t| < ε/2, 0 caso contrário, garantindo área = 1.",
                                    "Calcule explicitamente a integral ∫ π_ε(t) dt = 1 para diferentes ε > 0.",
                                    "Observe o comportamento à medida que ε → 0: altura → ∞, largura → 0.",
                                    "Plote π_ε(t) para ε = 1, 0.5, 0.1, 0.01 manualmente ou via software.",
                                    "Verifique propriedade do sifting: ∫ f(t) π_ε(t - t0) dt ≈ f(t0) para ε pequeno."
                                  ],
                                  "verification": "Gere plots para 3 valores de ε e confirme área unitária numericamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software como MATLAB/Octave/Python (Matplotlib/NumPy), papel milimetrado.",
                                  "tips": "Sempre normalize a altura como 1/ε para manter área constante.",
                                  "learningObjective": "Construir aproximação retangular e observar convergência para δ(t).",
                                  "commonMistakes": "Esquecer de ajustar altura proporcional a 1/ε, resultando em área variável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e analisar sequência de pulsos triangulares aproximando δ(t)",
                                  "subSteps": [
                                    "Defina o pulso triangular: τ_ε(t) = (1/ε) (1 - |t|/ε) para |t| < ε, 0 caso contrário.",
                                    "Confirme área unitária: ∫ τ_ε(t) dt = 1 via integração geométrica (área de triângulo base 2ε altura 1/ε).",
                                    "Compare suavidade com retangular: triangular é contínua, mas ainda converge para δ(t).",
                                    "Plote τ_ε(t) para mesmos ε do passo anterior e sobreponha com retangulares.",
                                    "Teste sifting para função teste f(t) = t^2, mostrando aproximação."
                                  ],
                                  "verification": "Plots sobrepostos mostram convergência; integral numérica ≈1 e sifting ≈ f(0).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Mesmo software do passo anterior, funções para plotar triângulos.",
                                  "tips": "Triangulares são úteis em simulações numéricas por serem diferenciáveis.",
                                  "learningObjective": "Dominar aproximação triangular e comparar com retangular.",
                                  "commonMistakes": "Erro na definição: base é 2ε, não ε, para simetria em torno de zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar graficamente o limite e sintetizar representações",
                                  "subSteps": [
                                    "Crie animação ou sequência de plots mostrando ε → 0 para ambas sequências.",
                                    "Discuta rigor: em sentido de distribuições, <π_ε, φ> → <δ, φ> para φ teste suave.",
                                    "Compare retangular vs. triangular: ambos convergem, mas triangular é 'mais suave'.",
                                    "Aplique a um exemplo: convolução com função de sistema h(t), mostrando resposta ao impulso.",
                                    "Documente em relatório: fórmulas, plots e conclusões."
                                  ],
                                  "verification": "Animação/plots finais mostram 'pico' concentrado em t=0; relatório completo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software com animação (MATLAB animatedline ou Python FuncAnimation).",
                                  "tips": "Use logscale no eixo y para visualizar alturas crescentes.",
                                  "learningObjective": "Visualizar e formalizar δ(t) como limite de sequências.",
                                  "commonMistakes": "Ignorar contexto de distribuições; achar que limite ponto a ponto existe."
                                }
                              ],
                              "practicalExample": "Em MATLAB, defina π_ε(t) para ε=0.01, convolvendo com h(t)=e^{-t}u(t) (resposta de sistema RC); plot mostre saída aproximando h(0)δ(t) + derivadas, ilustrando uso em identificação de sistemas aeronáuticos.",
                              "finalVerifications": [
                                "Plots de sequências retangulares e triangulares convergem visualmente para δ(t).",
                                "Cálculo de área para ε pequeno é numericamente 1 (±0.01).",
                                "Teste de sifting: ∫ f(t) approx_δ(t) dt ≈ f(0) com erro <1%.",
                                "Relatório descreve fórmulas e propriedades corretamente.",
                                "Animação demonstra limite ε→0.",
                                "Convolução exemplo reproduz resposta ao impulso."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de π_ε(t) e τ_ε(t), com área unitária comprovada.",
                                "Qualidade e legibilidade dos gráficos/plots (eixos rotulados, múltiplos ε).",
                                "Correta interpretação do limite em sentido de distribuições.",
                                "Análise comparativa entre retangular e triangular.",
                                "Aplicação prática via convolução ou sifting demonstrada.",
                                "Clareza no relatório, evitando erros comuns como normalização errada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de impulsos em dinâmica de fluidos aeronáuticos.",
                                "Programação: Implementação numérica em MATLAB/Python para visualização.",
                                "Matemática: Teoria de distribuições e análise funcional.",
                                "Engenharia de Controle: Resposta ao impulso em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, δ(t) modela excitações impulsivas como rajadas de vento ou falhas estruturais em testes de identificação de sistemas dinâmicos, permitindo simular respostas via convolução em softwares como Simulink para projeto de aeronaves estáveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Verificar a propriedade de área unitária",
                            "description": "Calcular e demonstrar que ∫_{-∞}^{∞} δ(t) dt = 1, usando representações aproximadas e justificando sua validade em contextos de integração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição teórica da função delta de Dirac δ(t)",
                                  "subSteps": [
                                    "Estude a definição formal: δ(t) é zero para t ≠ 0 e ∫_{-∞}^{∞} δ(t) dt = 1.",
                                    "Entenda as propriedades fundamentais: simetria, escalamento e sifting.",
                                    "Discuta o conceito de distribuição no sentido de Dirac para rigor matemático.",
                                    "Identifique limitações da delta como função clássica versus distribuição.",
                                    "Anote exemplos de uso em transformadas de Laplace e Fourier."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades chave e confirme que a área unitária é uma propriedade essencial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), notas de aula, calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Visualize δ(t) como uma seta infinita em t=0 com área 1 para intuição.",
                                  "learningObjective": "Compreender conceitualmente a propriedade de área unitária da δ(t).",
                                  "commonMistakes": "Confundir δ(t) com uma função comum em vez de distribuição; ignorar o limite implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e selecionar representações aproximadas de δ(t)",
                                  "subSteps": [
                                    "Escolha a aproximação retangular: δ_ε(t) = 1/ε para |t| < ε/2, 0 caso contrário.",
                                    "Apresente a aproximação gaussiana: δ_σ(t) = (1/(σ√(2π))) exp(-t²/(2σ²)).",
                                    "Discuta outras como triangular ou sinc, justificando escolhas por simplicidade.",
                                    "Calcule analiticamente a largura e altura para garantir área inicial próxima de 1.",
                                    "Compare graficamente as aproximações com δ(t) ideal usando software."
                                  ],
                                  "verification": "Desenhe ou plote pelo menos duas aproximações e verifique que sua integral é exatamente 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python com Matplotlib, Desmos), papel quadriculado"
                                  ],
                                  "tips": "Comece com ε pequeno (ex: 0.01) para melhor aproximação visual.",
                                  "learningObjective": "Selecionar e preparar sequências convergentes para δ(t).",
                                  "commonMistakes": "Esquecer de normalizar a altura para que a área seja 1; usar ε muito grande."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a integral da área para representações aproximadas",
                                  "subSteps": [
                                    "Para retangular: Compute ∫ δ_ε(t) dt = (1/ε)*ε = 1 exatamente.",
                                    "Para gaussiana: Use propriedade conhecida ∫ exp(-t²/(2σ²)) dt = σ√(2π), normalizando para 1.",
                                    "Varie parâmetros (ε → 0, σ → 0) e plote a integral numérica vs. analítica.",
                                    "Implemente integração numérica em código para validação.",
                                    "Registre resultados em tabela: parâmetro vs. área computada."
                                  ],
                                  "verification": "Mostre cálculos analíticos e numéricos onde |área - 1| < 0.01 para ε,σ < 0.001.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/MATLAB para integração (scipy.integrate.quad), calculadora"
                                  ],
                                  "tips": "Use simetria para integrar apenas de -∞ a 0 e dobrar.",
                                  "learningObjective": "Demonstrar numericamente e analiticamente que a área é 1.",
                                  "commonMistakes": "Erro em limites de integração; confusão entre altura e largura."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar validade no limite e em contextos de integração",
                                  "subSteps": [
                                    "Analise o limite ε→0 ou σ→0: altura → ∞, largura → 0, área = 1.",
                                    "Discuta convergência em distribuição: teste com funções de teste φ(t).",
                                    "Aplique em exemplo de convolução: y(t) = ∫ h(τ) δ(t-τ) dτ = h(t).",
                                    "Aborde rigor em Lebesgue vs. Riemann para integrações práticas.",
                                    "Conclua com aplicações em sistemas lineares invariantes no tempo (LTI)."
                                  ],
                                  "verification": "Escreva uma justificativa de 200 palavras provando a propriedade via limite.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referências teóricas (Livro de Lathi), editor de texto"
                                  ],
                                  "tips": "Use o lema do sifting para reforçar: ∫ δ(t) φ(t) dt = φ(0).",
                                  "learningObjective": "Justificar matematicamente a propriedade em contextos reais.",
                                  "commonMistakes": "Ignorar que δ(t) não é integrável no sentido clássico; superestimar convergência uniforme."
                                }
                              ],
                              "practicalExample": "Em simulação de resposta ao impulso de um estabilizador de aeronave, use δ(t) aproximada por gaussiana com σ=0.001s para injetar um pulso unitário no atuador; verifique que a energia total do sinal (integral) é 1, garantindo calibração correta do modelo dinâmico.",
                              "finalVerifications": [
                                "Integral analítica da aproximação retangular é exatamente 1.",
                                "Integral numérica da gaussiana difere de 1 por menos de 0.1%.",
                                "Limite ε→0 preserva área unitária em plots.",
                                "Propriedade de sifting testada com φ(t)=t²: resulta em 0.",
                                "Aplicação em convolução recupera sinal original.",
                                "Justificativa escrita cobre convergência em distribuições."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos analíticos (100% exato para retangular).",
                                "Qualidade dos plots e tabelas de convergência.",
                                "Profundidade da justificativa teórica (referências corretas).",
                                "Correção na implementação numérica (erro <1e-3).",
                                "Clareza na conexão com sistemas LTI.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de distribuições e integração imprópria.",
                                "Física: Modelagem de impulsos em dinâmica de fluidos aeronáuticos.",
                                "Programação: Simulação numérica com NumPy/SciPy.",
                                "Engenharia de Controle: Resposta ao degrau/impulso em sistemas de voo."
                              ],
                              "realWorldApplication": "Na identificação de sistemas de controle de aeronaves, a propriedade de área unitária da δ(t) garante que o sinal de teste injete exatamente unidade de energia, permitindo calibração precisa de modelos para estabilidade em manobras, como em testes de wind tunnel ou flight simulators."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Propriedades Matemáticas do δ(t)",
                        "description": "Dominar as principais propriedades algébricas e integrais do sinal impulso unitário, fundamentais para manipulações em análise de sinais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Aplicar a propriedade de sifting",
                            "description": "Utilizar ∫_{-∞}^{∞} f(t) δ(t - t_0) dt = f(t_0) para extrair o valor de uma função f(t) em um ponto específico, resolvendo exemplos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e propriedades básicas da função delta de Dirac δ(t)",
                                  "subSteps": [
                                    "Estude a definição informal da δ(t) como uma função que é zero em todo lugar exceto em t=0, onde é infinita, com integral unitária.",
                                    "Memorize as propriedades fundamentais: ∫_{-∞}^{∞} δ(t) dt = 1 e δ(t) = δ(-t).",
                                    "Visualize graficamente a δ(t) como uma seta em t=0 com área 1.",
                                    "Pratique shift: δ(t - t₀) 'picos' em t = t₀.",
                                    "Confirme simetria e escalonamento com exemplos simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e desenhe o gráfico da δ(t - t₀).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Gráfico da delta de Dirac (online ou livro-texto)"
                                  ],
                                  "tips": "Pense na delta como um 'pino' que 'perfura' o eixo t em um ponto específico.",
                                  "learningObjective": "Compreender intuitivamente a natureza da delta de Dirac como distribuidor.",
                                  "commonMistakes": [
                                    "Confundir δ(t) com uma função regular",
                                    "Esquecer que a integral é 1 independentemente da altura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir intuitivamente a propriedade de sifting",
                                  "subSteps": [
                                    "Imagine a delta como um 'filtro' que 'captura' o valor de f(t) exatamente onde ela 'pica'.",
                                    "Derive informalmente: a integral ∫ f(t) δ(t - t₀) dt 'pesa' f(t) só em t=t₀ devido à estreiteza da delta.",
                                    "Compare com limite de uma sequência de funções estreitas (Gaussiana ou retangular) multiplicada por f(t).",
                                    "Escreva a propriedade matemática: ∫_{-∞}^{∞} f(t) δ(t - t₀) dt = f(t₀), assumindo f contínua em t₀.",
                                    "Teste com f(t) = constante para verificar."
                                  ],
                                  "verification": "Descreva em palavras como a delta 'seleciona' f(t₀) e calcule para f(t)=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Use analogia de 'amostrador instantâneo' em sinais digitais.",
                                  "learningObjective": "Internalizar a propriedade de sifting como um mecanismo de extração pontual.",
                                  "commonMistakes": [
                                    "Aplicar sem assumir continuidade de f",
                                    "Ignorar limites de integração (-∞ a ∞)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar cálculo da propriedade em exemplos simples",
                                  "subSteps": [
                                    "Escolha f(t) = t e t₀=2: compute ∫ t δ(t-2) dt = 2.",
                                    "Para f(t) = sen(t), t₀=π/2: resultado sen(π/2)=1.",
                                    "Trate f piecewise: defina f(t) = {t para t<0, t² para t≥0}, extraia f(0)=0.",
                                    "Varie t₀ negativo ou fracionário, como t₀=-1 com f(t)=e^t.",
                                    "Registre resultados em tabela: função, t₀, valor extraído."
                                  ],
                                  "verification": "Resolva 3 exemplos independentes corretamente sem consultar notas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de funções teste"
                                  ],
                                  "tips": "Sempre substitua t=t₀ diretamente; a delta faz o resto.",
                                  "learningObjective": "Executar a propriedade mecanicamente em funções variadas.",
                                  "commonMistakes": [
                                    "Integrar como produto regular",
                                    "Esquecer fator de escala em δ(at)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em contextos de sistemas dinâmicos e verificar",
                                  "subSteps": [
                                    "Relacione com resposta ao impulso: h(t) 'extraída' em t=0 pela delta.",
                                    "Simule numericamente em software: aproxime δ por pulso estreito e integre.",
                                    "Resolva problema composto: encontre f(3) onde f(t)=resposta de sistema a u(t).",
                                    "Discuta generalizações: vetores δ para amostragem múltipla.",
                                    "Crie seu próprio exemplo e valide."
                                  ],
                                  "verification": "Crie e resolva um exemplo original, explicando cada passo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para simulação (opcional)",
                                    "Exemplos de livros de controle"
                                  ],
                                  "tips": "Ligue à convolução: y(t) = ∫ h(τ) x(t-τ) dτ, sifting quando x=δ.",
                                  "learningObjective": "Integrar a propriedade em aplicações de sinais e sistemas.",
                                  "commonMistakes": [
                                    "Não considerar causalidade em sistemas reais",
                                    "Confundir com propriedade de sampling periódico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aeronave, para extrair o deslocamento angular θ(t) em t=5s de um sinal contínuo θ(t) = sin(ωt) + ruído, aplique ∫ θ(t) δ(t-5) dt = θ(5) = sin(5ω), isolando o valor exato para calibração sem processamento numérico pesado.",
                              "finalVerifications": [
                                "Calcule corretamente ∫ f(t) δ(t-t₀) dt para 5 funções diferentes.",
                                "Explique a propriedade sem fórmulas, usando analogia física.",
                                "Identifique quando a propriedade falha (f descontínua).",
                                "Aplique em convolução com delta.",
                                "Simule numericamente e compare com resultado exato.",
                                "Crie exemplo em contexto aeronáutico."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: resultado exato = f(t₀).",
                                "Compreensão conceitual: explica mecanismo de sifting.",
                                "Variedade de exemplos: funções polinomiais, trigonométricas, exponenciais.",
                                "Aplicação contextual: liga a sistemas dinâmicos.",
                                "Correção de erros: evita pitfalls comuns.",
                                "Criatividade: gera exemplos originais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Momento impulsivo em mecânica (força delta extrai velocidade).",
                                "Programação: Operador Kronecker δ_{ij} para indexação matricial.",
                                "Processamento de Sinais: Sampling theorem e reconstrução.",
                                "Controle Automático: Resposta impulsional h(t).",
                                "Matemática Numérica: Quadratura de Gauss para aproximação."
                              ],
                              "realWorldApplication": "Na identificação de sistemas aeronáuticos, a propriedade de sifting permite extrair valores instantâneos de respostas transitórias a impulsos unitários, essencial para modelagem de flaps ou estabilizadores dinâmicos sem simulações completas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Utilizar a propriedade de escalonamento",
                            "description": "Demonstrar que δ(at) = (1/|a|) δ(t) para a ≠ 0, aplicando em transformações de escala temporal e verificando com integrais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e propriedades básicas do sinal impulso unitário δ(t)",
                                  "subSteps": [
                                    "Lembre-se que δ(t) é uma distribuição com ∫_{-∞}^{∞} δ(t) dt = 1 e δ(t) = 0 para t ≠ 0.",
                                    "Entenda o conceito de 'sifting property': ∫_{-∞}^{∞} f(t) δ(t) dt = f(0).",
                                    "Discuta informalmente o delta como limite de funções estreitas e altas.",
                                    "Esboce graficamente δ(t) e discuta sua não-diferenciabilidade.",
                                    "Verifique numericamente em software a área sob a curva aproximada."
                                  ],
                                  "verification": "Responda corretamente a 3 perguntas sobre propriedades básicas e esboce o gráfico corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, acesso a MATLAB ou Python (SymPy para delta simbólico)",
                                  "tips": "Pense no delta como uma 'flecha' infinita em t=0; foque na integral unitária.",
                                  "learningObjective": "Compreender a essência matemática do δ(t) como base para propriedades avançadas.",
                                  "commonMistakes": "Confundir δ(t) com uma função comum (ex: tratar como Heaviside); ignorar o fator 1 na integral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir transformações de escala temporal em sinais",
                                  "subSteps": [
                                    "Defina x(at) para um sinal x(t) com a > 0: compressão temporal se a > 1, expansão se 0 < a < 1.",
                                    "Calcule a energia ou integral de x(at): mostre que ∫ x(at) dt = (1/a) ∫ x(u) du com u = at.",
                                    "Aplique a uma função teste simples, como retangular ou gaussiana.",
                                    "Discuta impacto em frequência via Fourier (compressão temporal = expansão em frequência).",
                                    "Esboce exemplos gráficos de escalonamento."
                                  ],
                                  "verification": "Transforme corretamente 2 sinais de teste e calcule suas integrais transformadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software de plotagem (MATLAB plot ou Python Matplotlib)",
                                  "tips": "Use substituição u = at sempre; lembre du = a dt.",
                                  "learningObjective": "Dominar o efeito da escala na integral de sinais contínuos.",
                                  "commonMistakes": "Esquecer o Jacobiano (1/|a|) na mudança de variável; confundir escala temporal com amplitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a propriedade de escalonamento δ(at) = (1/|a|) δ(t)",
                                  "subSteps": [
                                    "Use a propriedade sifting: ∫ f(t) δ(at) dt = ? Substitua u = at, dt = du / |a|.",
                                    "Mostre que ∫ f(t) δ(at) dt = (1/|a|) f(0), implicando δ(at) = (1/|a|) δ(t).",
                                    "Prove para a > 0 e a < 0 separadamente, justificando |a|.",
                                    "Verifique limites: se a → ∞, δ(at) → 0 exceto em origem.",
                                    "Escreva a prova formal passo a passo."
                                  ],
                                  "verification": "Escreva a derivação completa e verifique com f(t) = 1 e f(t) = t.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de caderno para derivação, calculadora simbólica (Wolfram Alpha ou SymPy)",
                                  "tips": "Sempre inclua dt = du / |a|; teste com a = 2 e a = -1 numericamente.",
                                  "learningObjective": "Derivar rigorosamente a propriedade usando mudança de variável.",
                                  "commonMistakes": "Omitir o 1/|a|; falhar em considerar sinal de a (usar a em vez de |a|)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar a propriedade com integrais e exemplos",
                                  "subSteps": [
                                    "Compute ∫ δ(2t) dt e mostre = 1/2.",
                                    "Aplique em convolução: h(t) = ∫ δ(2(τ - t0)) x(τ) dτ = (1/2) x(t0).",
                                    "Simule numericamente em software aproximando δ por gaussiana estreita.",
                                    "Verifique em transformada de Fourier: F{δ(at)} = (1/|a|) F{δ(t)} ajustado.",
                                    "Resolva um problema: encontre resposta de sistema a impulso escalado."
                                  ],
                                  "verification": "Resolva 2 integrais envolvendo δ(at) e simule 1 exemplo com erro < 1%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB/Simulink ou Python (SciPy para convolução), exemplos de sistemas dinâmicos",
                                  "tips": "Aproxime δ(t) = exp(-t²/(2σ²))/ (σ √(2π)) com σ pequeno para simulações.",
                                  "learningObjective": "Aplicar a propriedade em contextos de sinais e sistemas.",
                                  "commonMistakes": "Ignorar fator 1/|a| em aplicações; erros em limites de integração após substituição."
                                }
                              ],
                              "practicalExample": "Em um sistema dinâmico aeronáutico, um impulso de falha estrutural δ(t) modela força instantânea. Se o tempo é escalado por fator a=2 (devido a mudança de escala de simulação), a resposta é convolução com δ(2t)/2, preservando a integral unitária para massa unitária.",
                              "finalVerifications": [
                                "Derive corretamente δ(at) = (1/|a|) δ(t) usando sifting property.",
                                "Calcule ∫_{-∞}^{∞} δ(3t) dt = 1/3.",
                                "Simule numericamente δ(0.5t) e verifique área ≈ 2.",
                                "Aplique em convolução simples e confira resultado.",
                                "Explique verbalmente o papel do |a| para a negativo.",
                                "Resolva problema de resposta ao impulso escalado em LTI."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fator 1/|a| correto).",
                                "Correta manipulação de integrais e substituições de variável.",
                                "Aplicação válida em exemplos de sinais e sistemas.",
                                "Interpretação física correta no contexto aeronáutico.",
                                "Simulações numéricas com erro relativo < 5%.",
                                "Clareza na explicação de verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Distribuições e Teoria de Medidas (rigor da delta).",
                                "Física: Mecânica (impulsos em vibrações estruturais aeronáuticas).",
                                "Programação: Simulação numérica em Python/MATLAB para aproximações.",
                                "Controle: Resposta de sistemas LTI a entradas escaladas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, modela respostas transitórias a falhas rápidas em sistemas de controle de voo; escalonamento temporal ajusta simulações de alta velocidade vs. tempo real, garantindo precisão em análises de estabilidade dinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Explorar a linearidade e derivadas do δ(t)",
                            "description": "Verificar a linearidade α δ(t) + β δ(t - t1) e introduzir a derivada δ'(t), com exemplos de uso em equações diferenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e propriedades básicas da função δ(t)",
                                  "subSteps": [
                                    "Recordar que δ(t) é a função delta de Dirac, com ∫δ(t)dt=1 e δ(t)=0 para t≠0.",
                                    "Entender a propriedade de sifting: ∫f(t)δ(t)dt = f(0).",
                                    "Explorar o deslocamento temporal: δ(t - t1) representa impulso em t=t1.",
                                    "Verificar normalização: área sob δ(t) é sempre 1.",
                                    "Praticar com gráficos qualitativos de δ(t) e δ(t - t1)."
                                  ],
                                  "verification": "Desenhar gráficos de δ(t) e δ(t-1), confirmando propriedades de sifting com integral simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Papel e lápis ou software como MATLAB/Octave",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Visualize δ(t) como uma seta infinita em t=0 para intuição.",
                                  "learningObjective": "Compreender as bases da δ(t) para propriedades avançadas.",
                                  "commonMistakes": [
                                    "Confundir δ(t) com uma função comum",
                                    "Ignorar que δ(t) não é uma função no sentido clássico",
                                    "Esquecer a propriedade de sifting"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a linearidade da δ(t): α δ(t) + β δ(t - t1)",
                                  "subSteps": [
                                    "Definir linearidade: L{αx + βy} = αL{x} + βL{y}.",
                                    "Aplicar a transformada de Laplace: L{δ(t)} = 1, L{δ(t-t1)} = e^{-s t1}.",
                                    "Verificar: L{α δ(t) + β δ(t-t1)} = α + β e^{-s t1}, que é linear.",
                                    "Testar no domínio do tempo com convolução: resposta linear a soma de impulsos.",
                                    "Simular numericamente soma de impulsos deslocados."
                                  ],
                                  "verification": "Calcular L{2δ(t) + 3δ(t-2)} e confirmar igualdade com 2*1 + 3*e^{-2s}.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SymPy)",
                                    "Tabelas de Laplace",
                                    "Exercícios de livro-texto"
                                  ],
                                  "tips": "Use Laplace para provar linearidade sem lidar com singularidades.",
                                  "learningObjective": "Demonstrar que δ(t) é linear sob combinações lineares.",
                                  "commonMistakes": [
                                    "Tratar δ(t) como função diferenciável comum",
                                    "Esquecer fator de escala na amplitude",
                                    "Confundir com não-linearidade em sistemas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a derivada δ'(t) e suas propriedades fundamentais",
                                  "subSteps": [
                                    "Definir δ'(t) via integração por partes: ∫f(t)δ'(t)dt = -f'(0).",
                                    "Verificar propriedade de sifting para derivada.",
                                    "Explorar linearidade de δ'(t): similar a δ(t).",
                                    "Relacionar com derivada de Heaviside: H'(t) = δ(t), estendendo para δ'(t).",
                                    "Plotar qualitativamente δ'(t) como um dipolo (positivo e negativo infinito)."
                                  ],
                                  "verification": "Aplicar propriedade de sifting: ∫t δ'(t) dt = -1, confirmando definição.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB stem ou Python Matplotlib)",
                                    "Referências teóricas (distribuições)"
                                  ],
                                  "tips": "Pense em δ'(t) como taxa de mudança instantânea do impulso.",
                                  "learningObjective": "Dominar definição e manipulação de δ'(t).",
                                  "commonMistakes": [
                                    "Assumir δ'(t) = d/dt δ(t) ponto a ponto",
                                    "Ignorar sinal negativo na sifting",
                                    "Confundir com segunda derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar δ(t) e δ'(t) em equações diferenciais",
                                  "subSteps": [
                                    "Resolver y'' + y = δ(t) via Laplace: Y(s) = 1/(s^2+1).",
                                    "Estender para y'' + y = δ'(t): Y(s) = s/(s^2+1).",
                                    "Interpretar soluções: δ(t) excita modo natural, δ'(t) modo derivativo.",
                                    "Simular resposta de sistema de segunda ordem a δ e δ'.",
                                    "Conectar a identificação de sistemas: estimar parâmetros via impulsos."
                                  ],
                                  "verification": "Resolver e plotar resposta a δ'(t) para oscilador harmônico, verificando fase inicial.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB Simulink ou Python (control library)",
                                    "Exemplos de EDOs em controle"
                                  ],
                                  "tips": "Sempre volte ao domínio Laplace para simplicidade.",
                                  "learningObjective": "Usar δ e δ' para modelar excitações em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Esquecer condições iniciais zero",
                                    "Não inverter Laplace corretamente",
                                    "Ignorar causalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flap de aeronave, use δ(t) para modelar pulso de comando unitário e δ'(t) para rampa instantânea, simulando resposta em MATLAB para identificar rigidez aerodinâmica.",
                              "finalVerifications": [
                                "Calcular corretamente L{α δ(t) + β δ'(t - t1)}.",
                                "Aplicar propriedade de sifting para δ'(t) em função teste.",
                                "Resolver EDO y' = δ'(t) e interpretar solução.",
                                "Simular e plotar resposta linear a combinação de impulsos.",
                                "Explicar diferença qualitativa entre resposta a δ(t) e δ'(t).",
                                "Verificar linearidade numericamente com soma de respostas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e propriedades de linearidade (30%)",
                                "Correta manipulação de δ'(t) via sifting e Laplace (25%)",
                                "Aplicação correta em EDOs com soluções explícitas (20%)",
                                "Uso de simulações para validação (15%)",
                                "Interpretação física em contexto aeronáutico (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Distribuições e transformadas integrais.",
                                "Física: Mecânica clássica e respostas impulsivas.",
                                "Engenharia de Controle: Identificação e modelagem de sistemas.",
                                "Processamento de Sinais: Filtros e excitações.",
                                "Computação: Simulações numéricas em MATLAB/Python."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, δ(t) modela impactos ou comandos impulsivos em testes de vibração de asas, enquanto δ'(t) simula acelerações abruptas em manobras, essencial para análise de estabilidade dinâmica e certificação FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Aplicação na Análise de Sistemas Dinâmicos Lineares",
                        "description": "Relacionar o sinal δ(t) com a resposta ao impulso de sistemas LTI, base para convolução e funções de transferência.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Definir a resposta ao impulso h(t)",
                            "description": "Explicar que a saída de um sistema linear invariante no tempo (LTI) contínuo a um δ(t) é a função h(t), que caracteriza completamente o sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Sinal Impulso Unitário δ(t)",
                                  "subSteps": [
                                    "Estude a definição matemática de δ(t) como uma distribuição de Dirac com ∫δ(t)dt = 1 e δ(t)=0 para t≠0.",
                                    "Analise as propriedades básicas: linearidade, deslocamento temporal δ(t-t0) e escalamento.",
                                    "Visualize δ(t) graficamente como uma seta infinita em t=0 com área unitária.",
                                    "Pratique representações em transformadas de Laplace e Fourier.",
                                    "Discuta limitações físicas e aproximações em sinais reais."
                                  ],
                                  "verification": "Desenhe o gráfico de δ(t) e calcule sua integral de -∞ a ∞, confirmando valor 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Software MATLAB ou Python (SciPy)"
                                  ],
                                  "tips": "Pense em δ(t) como um 'martelo' que testa o sistema instantaneamente.",
                                  "learningObjective": "Definir e representar matematicamente o sinal impulso unitário δ(t).",
                                  "commonMistakes": [
                                    "Confundir δ(t) com uma função comum (não é), tratar como pulso finito sem normalizar área."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Sistemas Lineares Invariantes no Tempo (LTI) Contínuos",
                                  "subSteps": [
                                    "Recapitule linearidade: superposição de respostas.",
                                    "Explique invariância no tempo: resposta a x(t-t0) é y(t-t0).",
                                    "Discuta causalidade e estabilidade em sistemas LTI.",
                                    "Introduza a equação diferencial linear com coeficientes constantes.",
                                    "Exemplifique com sistemas simples como integrador ou atraso."
                                  ],
                                  "verification": "Classifique um sistema dado (ex: y'(t) + y(t) = x(t)) como LTI e verifique propriedades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula de Sinais e Sistemas",
                                    "Exemplos online de Khan Academy"
                                  ],
                                  "tips": "Use setas para traçar entrada-saída em diagramas de bloco.",
                                  "learningObjective": "Identificar e listar propriedades fundamentais de sistemas LTI contínuos.",
                                  "commonMistakes": [
                                    "Ignorar invariância no tempo, confundir com sistemas não-lineares como y(t)=x(t)^2."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Resposta ao Impulso h(t)",
                                  "subSteps": [
                                    "Defina h(t) como a saída y(t) quando a entrada x(t) = δ(t), para t≥0 em sistemas causais.",
                                    "Derive que h(t) é a função de impulso ou resposta impulsiva.",
                                    "Mostre graficamente: entrada δ(t) → saída h(t).",
                                    "Explique representações em domínio do tempo e frequência (H(s), H(jω)).",
                                    "Pratique calculando h(t) para um sistema RC simples via Laplace."
                                  ],
                                  "verification": "Para um sistema dado, escreva h(t) = L^{-1}{1/(s+1)} e plote.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB para simulação impulsional",
                                    "Tabelas de transformadas de Laplace"
                                  ],
                                  "tips": "Sempre assuma condições iniciais zero para resposta ao impulso.",
                                  "learningObjective": "Estabelecer h(t) como saída exclusiva a δ(t) em sistemas LTI.",
                                  "commonMistakes": [
                                    "Incluir resposta homogênea em h(t), esquecer causalidade h(t)=0 para t<0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a Caracterização Completa do Sistema por h(t)",
                                  "subSteps": [
                                    "Introduza o teorema: qualquer saída y(t) = ∫ x(τ)h(t-τ)dτ (convolução).",
                                    "Prove usando linearidade e invariância no tempo.",
                                    "Simule convolução numericamente para validar.",
                                    "Discuta como h(t) captura toda dinâmica do sistema.",
                                    "Compare com outras representações (função de transferência)."
                                  ],
                                  "verification": "Calcule y(t) para x(t)=u(t) usando convolução com h(t) conhecida e verifique.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python (NumPy/SciPy para conv)",
                                    "Simulador online de convolução"
                                  ],
                                  "tips": "Visualize convolução como 'flip and slide' de h(τ).",
                                  "learningObjective": "Explicar por que h(t) caracteriza completamente sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir ordem de convolução x*h vs h*x, ignorar limites de integração."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave modelado como segundo ordem (mola-amortecedor), aplique δ(t) como entrada de torque impulsivo; h(t) será a resposta angular, simulada em MATLAB com impulse(tf([1],[1 2 1])) para analisar overshoot e tempo de assentamento.",
                              "finalVerifications": [
                                "Define corretamente h(t) como resposta a δ(t) em LTI.",
                                "Explica convolução y(t) = x(t) * h(t).",
                                "Plota h(t) para um sistema simples.",
                                "Identifica h(t) em função de transferência H(s).",
                                "Discute unicidade de h(t) para caracterização.",
                                "Simula resposta impulsional sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definição exata de h(t): 30%)",
                                "Compreensão de propriedades LTI (25%)",
                                "Habilidade em cálculos/simulações (20%)",
                                "Clareza na explicação de convolução (15%)",
                                "Aplicação contextual em aero (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integral de convolução e transformadas integrais.",
                                "Física: Dinâmica de sistemas massa-mola em vibrações aeronáuticas.",
                                "Computação: Simulação numérica em MATLAB/Python para identificação.",
                                "Controle Automático: Uso de h(t) em análise de estabilidade de voo."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, h(t) é usada para identificar modelos dinâmicos de aeronaves a partir de testes de voo com entradas impulsivas (ex: rajadas de vento), permitindo design de controladores de estabilidade em sistemas como fly-by-wire do F-16."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1",
                              "10.1.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Relacionar δ(t) com a integral de convolução",
                            "description": "Derivar a saída y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ usando a propriedade de sifting do δ(t), com exemplo numérico simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Propriedade de Sifting do Delta de Dirac δ(t)",
                                  "subSteps": [
                                    "Defina formalmente a função delta de Dirac δ(t) como uma distribuição que satisfaz ∫_{-∞}^{∞} δ(t) f(t) dt = f(0) para qualquer função contínua f(t).",
                                    "Explique intuitivamente o sifting como 'selecionar' o valor de uma função no ponto t=0.",
                                    "Derive a propriedade deslocada: ∫_{-∞}^{∞} δ(t - τ) f(t) dt = f(τ).",
                                    "Pratique com exemplos simples, como f(t) = t^2, calculando o integral.",
                                    "Visualize graficamente o delta como uma seta infinita em t=0 com área unitária."
                                  ],
                                  "verification": "Resolva 3 integrais de sifting com funções polinomiais e confirme que o resultado é o valor da função no ponto de sifting.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica (opcional: Wolfram Alpha)",
                                  "tips": "Lembre-se que δ(t) não é uma função comum; trate-a como uma ferramenta de distribuição.",
                                  "learningObjective": "Compreender e aplicar a propriedade de sifting para simplificar integrais envolvendo δ(t).",
                                  "commonMistakes": "Confundir δ(t) com uma função ordinária e tentar integrá-la diretamente sem sifting; ignorar limites de integração infinitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Resposta ao Impulso h(t) em Sistemas Lineares",
                                  "subSteps": [
                                    "Defina h(t) como a saída y(t) de um sistema LTI quando a entrada é δ(t).",
                                    "Explique que qualquer entrada x(t) pode ser decomposta em impulsos ponderados: x(t) = ∫_{-∞}^{∞} x(τ) δ(t - τ) dτ.",
                                    "Discuta a linearidade: a saída total é a soma das respostas a cada impulso infinitesimal.",
                                    "Esboce graficamente x(t) como uma 'trilha' de deltas e h(t-τ) como respostas deslocadas.",
                                    "Verifique com a propriedade de invariância no tempo."
                                  ],
                                  "verification": "Escreva a decomposição de x(t) usando deltas e identifique h(t) como resposta unitária.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado para gráficos, software de plotagem (MATLAB ou Python/Matplotlib)",
                                  "tips": "Pense em x(t) como uma 'chuva' de impulsos; cada gota produz uma resposta h deslocada.",
                                  "learningObjective": "Reconhecer h(t) como a 'assinatura' do sistema e base para superposição.",
                                  "commonMistakes": "Confundir h(t) com a função de transferência em domínio s; esquecer a causalidade em sistemas reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Integral de Convolução Usando Sifting",
                                  "subSteps": [
                                    "Comece com x(t) = ∫ x(τ) δ(t - τ) dτ e aplique linearidade: y(t) = ∫ x(τ) h(t - τ) dτ.",
                                    "Substitua na saída: y(t) = ∫ [x(τ) δ(σ)] * h(t - τ) dτ onde σ = t - τ, mas use sifting diretamente.",
                                    "Aplique sifting em h: considere ∫ x(τ) h(t - τ) dτ como sifting de h(t - τ) por x(τ).",
                                    "Mostre matematicamente: y(t) = ∫_{-∞}^{∞} x(τ) [∫_{-∞}^{∞} δ(σ) h(σ) dσ]_{σ=t-τ} dτ, simplificando para convolução.",
                                    "Confirme simetria: convolução é comutativa."
                                  ],
                                  "verification": "Derive passo a passo y(t) = (x * h)(t) a partir da decomposição em impulsos, sem lacunas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de derivadas, quadro branco ou tablet gráfico",
                                  "tips": "Mude variáveis: deixe σ = t - τ para alinhar o sifting em σ=0.",
                                  "learningObjective": "Derivar formalmente a convolução como consequência direta do sifting e linearidade.",
                                  "commonMistakes": "Errar o sinal no deslocamento (t-τ vs τ-t); omitir os limites de integração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a um Exemplo Numérico Simples",
                                  "subSteps": [
                                    "Escolha x(t) = u(t) - u(t-1) (pulso unitário de 1s) e h(t) = e^{-t} u(t).",
                                    "Calcule y(t) via convolução analítica: divida em regiões t<0, 0<t<1, t>1.",
                                    "Para t em [0,1]: y(t) = ∫_0^t e^{-(t-τ)} dτ = 1 - e^{-t}.",
                                    "Para t>1: y(t) = ∫_0^1 e^{-(t-τ)} dτ = e^{-t} (e - 1) + 1 - e^{-1}.",
                                    "Plote y(t) e verifique com simulação numérica (ex: trapézios)."
                                  ],
                                  "verification": "Compute y(t) em 3 pontos (t=0.5, 1.5, 3) e compare com gráfico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Calculadora científica, Python (NumPy/SciPy para conv) ou MATLAB",
                                  "tips": "Use integração por partes ou tabelas para integrais exponenciais.",
                                  "learningObjective": "Executar convolução prática e validar a relação com δ(t).",
                                  "commonMistakes": "Esquecer a função degrau u(t) nos limites; erros em substituição de variáveis."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aeronave, x(t) é um impulso de vento (δ(t)), h(t) = e^{-at} u(t) modela a resposta de estabilização. Convolução dá y(t) para rajadas prolongadas: y(t) = ∫ x(τ) e^{-a(t-τ)} u(t-τ) dτ, simulando trajetória corrigida.",
                              "finalVerifications": [
                                "Deriva corretamente y(t) = ∫ x(τ) h(t-τ) dτ usando sifting em 2 exemplos diferentes.",
                                "Explica verbalmente a decomposição de x(t) em impulsos.",
                                "Calcula convolução numérica para pulso e exponencial com erro <5%.",
                                "Identifica h(t) como resposta a δ(t) em diagrama de bloco.",
                                "Verifica simetria da convolução com troca de x e h."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Clareza na explicação da propriedade de sifting.",
                                "Correção nos cálculos numéricos e gráficos.",
                                "Profundidade nos subpassos (cobertura completa).",
                                "Aplicação contextual a sistemas dinâmicos.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de forças impulsivas em dinâmica de voo.",
                                "Programação: Implementação de convolução em Python/MATLAB para simulações.",
                                "Matemática: Integrais impróprias e distribuições.",
                                "Engenharia de Controle: Análise de estabilidade via resposta ao impulso."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, relacionar δ(t) à convolução permite simular respostas de aeronaves a perturbações impulsivas como turbulência ou ejeção de combustível, otimizando controladores PID para estabilidade em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.2.1",
                              "10.1.1.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Sinais Arbitrários e Integral de Convolução",
                    "description": "Representação da saída de sistemas LTI como convolução entre sinal de entrada arbitrário e resposta ao impulso.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Sistemas LTI e Resposta ao Impulso",
                        "description": "Compreensão dos sistemas lineares e invariantes no tempo (LTI) e sua representação fundamental pela resposta ao impulso h(t), que caracteriza completamente o comportamento do sistema para qualquer entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir sistemas LTI",
                            "description": "Explicar as propriedades de linearidade e invariância no tempo, com exemplos de sistemas contínuos como equações diferenciais lineares com coeficientes constantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a propriedade de linearidade em sistemas",
                                  "subSteps": [
                                    "Revise a definição formal de um sistema linear: se entradas x1 e x2 produzem saídas y1 e y2, então a combinação a*x1 + b*x2 produz a*y1 + b*y2.",
                                    "Estude o princípio de superposição para sistemas contínuos.",
                                    "Analise exemplos simples: somador (linear) vs. multiplicador (não-linear).",
                                    "Derive matematicamente por que equações diferenciais lineares com coeficientes constantes são lineares.",
                                    "Pratique identificando linearidade em 3 exemplos de sistemas físicos."
                                  ],
                                  "verification": "Resolva um exercício onde verifica se um sistema dado é linear, justificando com superposição.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Caderno para derivações",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Sempre teste com entradas zero e escalares para validar linearidade rapidamente.",
                                  "learningObjective": "O aluno será capaz de definir e verificar matematicamente a linearidade de um sistema.",
                                  "commonMistakes": [
                                    "Confundir linearidade com proporcionalidade simples.",
                                    "Ignorar o princípio de superposição em verificações.",
                                    "Aplicar incorretamente a homogeneidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a propriedade de invariância no tempo",
                                  "subSteps": [
                                    "Defina formalmente: se uma entrada x(t) produz y(t), então x(t - τ) produz y(t - τ) para qualquer τ.",
                                    "Diferencie de sistemas variantes no tempo, como y(t) = t * x(t).",
                                    "Explore a relação com a resposta ao impulso h(t).",
                                    "Analise exemplos contínuos: integrador vs. modulador temporal.",
                                    "Verifique invariância deslocando sinais em gráficos ou simulações."
                                  ],
                                  "verification": "Desloque uma entrada em um sistema dado e confirme se a saída desloca igualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy) para plotar sinais",
                                    "Folhas de papel milimetrado"
                                  ],
                                  "tips": "Use o teste do deslocamento unitário: aplique um delay e observe a saída.",
                                  "learningObjective": "O aluno identificará e provará invariância temporal em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir com periodicidade dos sinais.",
                                    "Não considerar coeficientes constantes nas EDOs.",
                                    "Testar apenas com impulsos sem delays gerais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir sistemas LTI combinando propriedades",
                                  "subSteps": [
                                    "Integre linearidade e invariância: um sistema é LTI se satisfaz ambas.",
                                    "Introduza a representação por convolução: y(t) = ∫ h(τ) x(t - τ) dτ.",
                                    "Discuta a importância da resposta ao impulso h(t) como caracterização completa.",
                                    "Classifique sistemas comuns como LTI (ex: RC circuit) ou não.",
                                    "Resuma as propriedades chave: convolução, decomposição em impulsos."
                                  ],
                                  "verification": "Classifique 5 sistemas como LTI ou não, justificando ambas propriedades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Apostila do curso Sinais e Sistemas",
                                    "Exemplos de circuitos RLC"
                                  ],
                                  "tips": "Lembre-se: LTI permite ferramentas poderosas como transformada de Laplace.",
                                  "learningObjective": "O aluno definirá sistemas LTI e explicará sua representação convolucional.",
                                  "commonMistakes": [
                                    "Achar que todo sistema linear é invariante no tempo.",
                                    "Esquecer que coeficientes variáveis violam invariância.",
                                    "Confundir LTI com estacionário em estatística."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a sistemas contínuos via equações diferenciais",
                                  "subSteps": [
                                    "Revise EDOs lineares de ordem n com coeficientes constantes: a_n y^{(n)} + ... + a_0 y = b_m x^{(m)} + ... + b_0 x.",
                                    "Mostre por que esses sistemas são LTI: linear por construção, invariantes por coeficientes constantes.",
                                    "Exemplo: resolva y'' + 2y' + y = x para h(t) via Laplace.",
                                    "Simule numericamente em software para visualizar convolução.",
                                    "Compare com EDOs não-lineares ou variantes no tempo."
                                  ],
                                  "verification": "Derive h(t) para uma EDO simples e convolua com uma entrada arbitrária.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Tabela de Laplace"
                                  ],
                                  "tips": "Use transformadas para encontrar h(t) rapidamente em vez de resolver EDOs diretamente.",
                                  "learningObjective": "O aluno associará EDOs lineares constantes a sistemas LTI com exemplos concretos.",
                                  "commonMistakes": [
                                    "Incluir termos não-lineares como y^2 inadvertidamente.",
                                    "Variar coeficientes com tempo em exemplos LTI.",
                                    "Não normalizar condições iniciais para zero em h(t)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o circuito RC série com equação y'(t) + (1/RC) y(t) = (1/RC) x(t). Verifique linearidade somando duas entradas senoidais e superpondo saídas. Para invariância, atrase x(t) por 1s e confirme y(t) atrasada igualmente. Simule em MATLAB para visualizar convolução com h(t) = (1/RC) e^{-t/RC} u(t).",
                              "finalVerifications": [
                                "Definição precisa de linearidade e invariância temporal.",
                                "Correta identificação de um sistema como LTI ou não.",
                                "Representação convolucional escrita corretamente.",
                                "Exemplo de EDO linear constante resolvido para h(t).",
                                "Simulação prática confirmando propriedades.",
                                "Diferenciação clara de sistemas não-LTI."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação das propriedades (superposição e deslocamento).",
                                "Precisão matemática em derivações e exemplos.",
                                "Uso correto de convolução e resposta ao impulso.",
                                "Relevância de exemplos contínuos em EDOs.",
                                "Capacidade de verificação prática via simulação.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e transformadas integrais (Laplace/Fourier).",
                                "Programação: Simulações em MATLAB/Python para sinais dinâmicos.",
                                "Engenharia de Controle: Modelagem de plantas LTI para aeroespaciais.",
                                "Física: Dinâmica de sistemas lineares em vibrações e ondas.",
                                "Processamento de Sinais: Filtros LTI em análise de dados de sensores."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, sistemas LTI modelam a dinâmica longitudinal de aeronaves via EDOs lineares (equações de movimento simplificadas), permitindo análise de estabilidade, design de autômatos de voo e simulações de resposta a perturbações como rajadas de vento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Determinar a resposta ao impulso h(t)",
                            "description": "Calcular a resposta ao impulso de um sistema LTI dado por uma equação diferencial linear, resolvendo-a com condições iniciais nulas e entrada δ(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas LTI e Resposta ao Impulso",
                                  "subSteps": [
                                    "Defina um sistema LTI e suas propriedades principais (linearidade, invariância temporal).",
                                    "Explique o que é a função de resposta ao impulso h(t) e sua importância na convolução.",
                                    "Discuta a delta de Dirac δ(t) como entrada unitária e condições iniciais nulas.",
                                    "Revise a representação de sistemas LTI por equações diferenciais lineares com coeficientes constantes.",
                                    "Identifique exemplos simples de EDOs de primeira e segunda ordem."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades de LTI e o papel de h(t); confirme com um diagrama conceitual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim), notas de aula, quadro branco"
                                  ],
                                  "tips": "Use analogias como 'h(t) é o DNA do sistema' para memorizar seu papel fundamental.",
                                  "learningObjective": "Compreender conceitualmente a resposta ao impulso como base para análise de sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir h(t) com resposta degrau",
                                    "Ignorar condições iniciais nulas",
                                    "Esquecer invariância temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Equação Diferencial para Resposta ao Impulso",
                                  "subSteps": [
                                    "Escreva a EDO geral de ordem n: a_n y^{(n)} + ... + a_0 y = b_m u^{(m)} + ... + b_0 u.",
                                    "Substitua u(t) = δ(t) como entrada.",
                                    "Especifique condições iniciais y(0^-) = 0, y'(0^-) = 0, etc.",
                                    "Transforme em domínio de Laplace: Y(s) = H(s) Δ(s), onde Δ(s)=1.",
                                    "Identifique H(s) = Y(s) como transformada de h(t)."
                                  ],
                                  "verification": "Escreva a EDO com δ(t) e suas CI; verifique se H(s) é polinomial próprio.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha), MATLAB para Laplace",
                                    "Folhas de exercícios de EDOs"
                                  ],
                                  "tips": "Sempre normalize a EDO dividindo pelo coeficiente líder para simplificar.",
                                  "learningObjective": "Configurar corretamente a EDO para entrada impulsiva com CI nulas.",
                                  "commonMistakes": [
                                    "Usar CI não nulas",
                                    "Confundir derivadas de δ(t)",
                                    "Esquecer fator de escala em H(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a EDO para Obter h(t)",
                                  "subSteps": [
                                    "Aplique transformada de Laplace à EDO com u(t)=δ(t).",
                                    "Calcule H(s) = numerador/denominador.",
                                    "Encontre inversa de Laplace de H(s) usando frações parciais.",
                                    "Para sistemas de 2ª ordem, use fórmula padrão: h(t) = (ω_n / √(1-ζ²)) e^{-ζω_n t} sin(ω_d t) u(t).",
                                    "Verifique causalidade: h(t)=0 para t<0."
                                  ],
                                  "verification": "Plote h(t) e confirme picos iniciais e decaimento; compare com simulação numérica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Tabelas de Laplace",
                                    "Software SymPy ou Mathematica"
                                  ],
                                  "tips": "Pratique frações parciais em polos complexos para oscilações.",
                                  "learningObjective": "Executar resolução analítica de h(t) via Laplace para EDOs lineares.",
                                  "commonMistakes": [
                                    "Erro em resíduos de frações parciais",
                                    "Esquecer Heaviside u(t)",
                                    "Polo no zero causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Interpretar a Resposta ao Impulso",
                                  "subSteps": [
                                    "Verifique propriedades: ∫h(t)dt = H(0), h(0+) = b_0 / a_n para ordem alta.",
                                    "Simule numericamente em MATLAB usando impulse() e compare.",
                                    "Analise qualidades: tempo de subida, overshoot, tempo de assentamento.",
                                    "Discuta estabilidade via polos de H(s).",
                                    "Conecte h(t) à convolução y(t) = ∫ h(τ) x(t-τ) dτ."
                                  ],
                                  "verification": "Coincidência entre solução analítica e simulação <1% erro; relatório de análise.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Control Systems Toolbox",
                                    "Gráficos de h(t) para diferentes ζ"
                                  ],
                                  "tips": "Use comando impulse(sys) no MATLAB para validação rápida.",
                                  "learningObjective": "Interpretar h(t) fisicamente e validar computacionalmente.",
                                  "commonMistakes": [
                                    "Ignorar atrasos de fase",
                                    "Confundir h(t) com função transferência",
                                    "Não checar unidade de tempo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de massa-mola-amortecedor: mÿ + cẏ + ky = δ(t), com m=1, c=0.5, k=1. Calcule H(s)=1/(s²+0.5s+1), h(t)=e^{-0.25t} sin(√0.9375 t)/√0.9375 u(t). Simule e plote.",
                              "finalVerifications": [
                                "h(t)=0 para t<0 (causalidade)",
                                "∫_{-∞}^∞ h(t) dt = H(0) (ganho DC correto)",
                                "h(0+) = lim_{s→∞} s H(s) (valor inicial)",
                                "Decaimento exponencial para sistemas estáveis",
                                "Ausência de δ(t) em h(t) para ordem >0",
                                "Coincide com simulação impulse() no MATLAB"
                              ],
                              "assessmentCriteria": [
                                "Precisão da H(s) derivada da EDO (100% coeficientes corretos)",
                                "Inversa de Laplace exata sem erros de frações parciais",
                                "Verificação numérica com erro <0.5%",
                                "Interpretação correta de parâmetros (ζ, ω_n)",
                                "Relatório inclui plot e análise qualitativa",
                                "Conexão explícita com convolução demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais: Base para filtros digitais",
                                "Controle Automático: Projeto de controladores via h(t)",
                                "Engenharia Aeronáutica: Modelagem de dinâmica de voo",
                                "Matemática Aplicada: Teoria de EDOs e Laplace"
                              ],
                              "realWorldApplication": "Em aeronáutica, h(t) modela a resposta impulsiva de sistemas de controle de voo, como flaps ou estabilizadores, essencial para simulações de turbulência e design de controladores PID estáveis em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Interpretar propriedades de h(t)",
                            "description": "Analisar propriedades como causalidade, estabilidade e duração finita da resposta ao impulso em sistemas reais, relacionando com aplicações em sistemas mecânicos e elétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades fundamentais de h(t)",
                                  "subSteps": [
                                    "Definir h(t) como a resposta ao impulso unitário δ(t) em sistemas LTI.",
                                    "Explicar a relação com a convolução: y(t) = ∫ x(τ) h(t - τ) dτ.",
                                    "Listar propriedades principais: causalidade (h(t)=0 para t<0), estabilidade BIBO (∫ |h(t)| dt < ∞) e duração finita (FIR).",
                                    "Visualizar graficamente exemplos de h(t) para cada propriedade.",
                                    "Discutir o papel de h(t) na caracterização completa do sistema."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as três propriedades principais e seu significado físico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas",
                                    "MATLAB ou Python para plotar funções",
                                    "Gráficos de referência de h(t)"
                                  ],
                                  "tips": "Sempre associe h(t) a um impulso físico, como uma pancada em uma estrutura mecânica.",
                                  "learningObjective": "Dominar o conceito de resposta ao impulso e suas propriedades chave em sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir h(t) com a função de transferência H(s)",
                                    "Ignorar a restrição de linearidade e invariância no tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar causalidade a partir de h(t)",
                                  "subSteps": [
                                    "Verificar graficamente se h(t) = 0 para todo t < 0.",
                                    "Analisar o suporte temporal de h(t) em plots ou expressões analíticas.",
                                    "Discutir implicações físicas: sistemas reais não antecipam entradas.",
                                    "Exemplo: em um circuito RC série, h(t) = (1/RC) e^{-t/RC} u(t), causal.",
                                    "Simular e plotar h(t) não causal para contraste."
                                  ],
                                  "verification": "Classificar corretamente um gráfico ou equação de h(t) como causal ou não causal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink)",
                                    "Exemplos de circuitos RC/RL",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Foque no eixo temporal negativo; qualquer pico antes de t=0 invalida causalidade.",
                                  "learningObjective": "Determinar e justificar causalidade com base em h(t).",
                                  "commonMistakes": [
                                    "Assumir causalidade por padrão sem inspeção visual completa",
                                    "Confundir com simetria da função."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar estabilidade BIBO utilizando h(t)",
                                  "subSteps": [
                                    "Recordar critério de estabilidade: ∫_{-∞}^{∞} |h(τ)| dτ < ∞.",
                                    "Calcular a integral absoluta para funções exponenciais, sinusoidais ou retangulares.",
                                    "Classificar exemplos: h(t) = e^{-t} u(t) (estável), h(t) = u(t) (instável).",
                                    "Simular respostas a entradas limitadas e observar acúmulo.",
                                    "Relacionar com polo no semiplano esquerdo em domínio Laplace."
                                  ],
                                  "verification": "Computar a integral corretamente e concluir sobre estabilidade para pelo menos dois exemplos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou MATLAB)",
                                    "Tabelas de integrais indefinidas",
                                    "Exemplos numéricos"
                                  ],
                                  "tips": "Para exponenciais decrescentes, confirme decaimento (|α| > 0 em e^{-α t}).",
                                  "learningObjective": "Aplicar o teste de estabilidade BIBO via h(t).",
                                  "commonMistakes": [
                                    "Esquecer o valor absoluto na integral",
                                    "Aplicar critério a sistemas não LTI."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar duração finita da resposta ao impulso e aplicações reais",
                                  "subSteps": [
                                    "Definir FIR: h(t) = 0 fora de um intervalo finito [t1, t2].",
                                    "Comparar FIR (resposta finita, sempre estável) vs IIR (infinita).",
                                    "Exemplo mecânico: amortecedor com resposta limitada em um trem de pouso.",
                                    "Exemplo elétrico: filtro digital FIR em processamento de sinais de radar aeronáutico.",
                                    "Discutir trade-offs: FIR linear fase vs IIR eficiente."
                                  ],
                                  "verification": "Classificar h(t) como FIR/IIR e relacionar a um sistema mecânico ou elétrico real.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Casos de estudo aeronáuticos",
                                    "Simulink para modelagem de sistemas",
                                    "Artigos sobre controle de voo"
                                  ],
                                  "tips": "FIR é ideal para evitar feedback infinito em controles embarcados.",
                                  "learningObjective": "Interpretar duração finita e conectar propriedades a contextos práticos.",
                                  "commonMistakes": [
                                    "Confundir duração finita com causalidade",
                                    "Ignorar vantagens de FIR em estabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de suspensão de trem de pouso de aeronave (sistema mecânico LTI), h(t) = 2 e^{-3t} sin(4t) u(t). Verifique: causal (u(t)), estável (integral converge), IIR (oscila infinitamente). Simule entrada de impacto e confirme resposta previsível sem divergência.",
                              "finalVerifications": [
                                "Identifica causalidade corretamente em 3 gráficos de h(t) diferentes.",
                                "Calcula ∫ |h(t)| dt e classifica estabilidade para 2 funções.",
                                "Distingue FIR de IIR em exemplos mecânicos/elétricos.",
                                "Relaciona todas propriedades a uma aplicação aeronáutica.",
                                "Explica limitações em sistemas reais (ruído, não-linearidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas análises (integral, verificações gráficas >95%).",
                                "Correta interpretação física e causal das propriedades.",
                                "Relevância e profundidade nas conexões com sistemas reais.",
                                "Uso eficaz de ferramentas de simulação e visualização.",
                                "Clareza e estrutura na explicação escrita ou oral.",
                                "Identificação de pelo menos 2 erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e análise funcional.",
                                "Física: Dinâmica linear e oscilações amortecidas.",
                                "Engenharia Mecânica: Vibrações em estruturas aeronáuticas.",
                                "Engenharia Elétrica: Circuitos e filtros analógicos/digitais.",
                                "Controle Automático: Estabilidade em laços de feedback."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, interpretar propriedades de h(t) assegura sistemas de controle de voo estáveis e causais, como em autômatos de estabilização que respondem a rajadas de vento sem oscilações persistentes, prevenindo fadiga estrutural e melhorando segurança em manobras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Sinais Arbitrários de Entrada",
                        "description": "Representação de sinais de entrada x(t) arbitrários como superposição de impulsos escalados, base para a análise de sistemas LTI com entradas gerais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Decompor sinal arbitrário em impulsos",
                            "description": "Expressar um sinal contínuo x(t) como integral de δ(t-τ) escalado por x(τ), justificando a abordagem para entradas não específicas como degrau ou rampa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Função Delta de Dirac e suas Propriedades",
                                  "subSteps": [
                                    "Estude a definição informal da δ(t) como uma função com área unitária concentrada em t=0.",
                                    "Aprenda a propriedade de sifting: ∫ f(τ) δ(t-τ) dτ = f(t).",
                                    "Revise propriedades de escalonamento: δ(at) = (1/|a|) δ(t).",
                                    "Visualize graficamente a delta como limite de pulsos retangulares estreitos.",
                                    "Pratique com exemplos simples de integração envolvendo δ(t)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a propriedade de sifting e dê um exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Notas de aula sobre funções generalizadas"
                                  ],
                                  "tips": "Pense na delta como uma 'pincelada' que 'seleciona' o valor de x(τ) em τ=t.",
                                  "learningObjective": "Dominar as propriedades fundamentais da delta de Dirac como base para decomposições.",
                                  "commonMistakes": [
                                    "Confundir δ(t) com uma função comum (não é); tratar como zero em t≠0 sem considerar a integral."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Representação de Sinal Arbitrário como Integral de Impulsos",
                                  "subSteps": [
                                    "Parta de uma aproximação discreta: x(t) ≈ Σ x(kΔt) δ(t - kΔt) Δt.",
                                    "Tome o limite quando Δt → 0, obtendo x(t) = ∫_{-∞}^∞ x(τ) δ(t - τ) dτ.",
                                    "Justifique heurísticamente: o sinal é 'soma infinita' de impulsos ponderados por sua amplitude.",
                                    "Escreva a fórmula geral e prove usando a propriedade de sifting.",
                                    "Discuta a validade para sinais contínuos e integráveis."
                                  ],
                                  "verification": "Derive a fórmula passo a passo em um papel e verifique se ∫ x(τ) δ(t-τ) dτ = x(t).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta para derivação",
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy)",
                                    "Vídeos tutoriais sobre delta de Dirac (Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Use a analogia de 'flechas' infinitesimais para construir o sinal contínuo.",
                                  "learningObjective": "Derivar e compreender a decomposição x(t) = ∫ x(τ) δ(t-τ) dτ.",
                                  "commonMistakes": [
                                    "Esquecer o dτ na soma discreta; inverter os limites de integração."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar e Justificar com Exemplos de Sinais Não-Específicos (Degrau e Rampa)",
                                  "subSteps": [
                                    "Aplique a fórmula ao sinal degrau u(t): verifique se recupera u(t).",
                                    "Para rampa r(t) = t u(t), compute a integral e confirme.",
                                    "Justifique por que funciona para arbitrários: linearidade e completude da base de deltas.",
                                    "Plote graficamente a decomposição para um sinal simples.",
                                    "Discuta limitações (ex: sinais não causais ou singulares)."
                                  ],
                                  "verification": "Calcule explicitamente para u(t) e r(t), mostrando igualdade com o sinal original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Python para plotar δ(t-τ) e integral",
                                    "Folha de exercícios com exemplos",
                                    "Tabela de transformadas de Laplace para verificação cruzada"
                                  ],
                                  "tips": "Integre por partes para rampa; use simetria para degrau.",
                                  "learningObjective": "Aplicar e validar a decomposição em sinais comuns, justificando generalidade.",
                                  "commonMistakes": [
                                    "Ignorar o suporte do sinal (u(t)=0 para t<0); erros em limites de integração."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações para Análise de Sistemas",
                                  "subSteps": [
                                    "Conecte à resposta impulso h(t): y(t) = ∫ x(τ) h(t-τ) dτ (convolução).",
                                    "Simule numericamente a decomposição em software.",
                                    "Analise estabilidade e causalidade na representação.",
                                    "Compare com séries de Fourier para sinais periódicos.",
                                    "Resolva um problema prático de sistema LTI com entrada arbitrária."
                                  ],
                                  "verification": "Simule em código e compare saída com sinal original; explique link com convolução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python (SciPy para convolução)",
                                    "Exemplos de sistemas aeronáuticos (ex: resposta a vento)"
                                  ],
                                  "tips": "Comece com Δt pequeno na soma discreta para aproximação visual.",
                                  "learningObjective": "Entender o papel na convolução e análise de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir decomposição com convolução; esquecer normalização na simulação discreta."
                                  ]
                                }
                              ],
                              "practicalExample": "Para x(t) = e^{-|t|}, a decomposição é x(t) = ∫_{-∞}^∞ e^{-|τ|} δ(t - τ) dτ. Simule em Python plotando soma de deltas escalados para Δt=0.01, aproximando a exponencial dupla.",
                              "finalVerifications": [
                                "Escrever corretamente x(t) = ∫ x(τ) δ(t-τ) dτ.",
                                "Verificar propriedade de sifting em exemplo.",
                                "Calcular decomposição para degrau u(t) e rampa t u(t).",
                                "Explicar intuitivamente por que vale para qualquer x(t) contínuo.",
                                "Simular numericamente e comparar gráficos.",
                                "Discutir transição para convolução em sistemas LTI."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da integral (100% correto).",
                                "Correção nos cálculos para exemplos específicos (degrau/rampa).",
                                "Clareza na justificativa heurística e intuitiva.",
                                "Qualidade dos gráficos/simulações numéricas.",
                                "Compreensão de limitações e conexões com convolução.",
                                "Criatividade em exemplo prático adicional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e funções generalizadas.",
                                "Física: Dinâmica de sistemas e modelagem de forças impulsivas.",
                                "Programação: Simulação numérica em Python/MATLAB (NumPy/SciPy).",
                                "Engenharia de Controle: Identificação de sistemas LTI.",
                                "Processamento de Sinais: Bases ortogonais e transformadas."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, permite analisar respostas de aeronaves a entradas arbitrárias como rajadas de vento ou comandos de piloto irregulares, via convolução com a função de impulso do sistema de controle, essencial para simulações de voo e certificação de estabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Classificar sinais arbitrários",
                            "description": "Identificar e exemplificar sinais arbitrários em contextos de análise de sistemas, como sinais periódicos, aperiódicos e ruído em identificação de sistemas dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de sinais periódicos, aperiódicos e arbitrários",
                                  "subSteps": [
                                    "Definir sinal periódico: sinal que se repete em intervalos regulares (ex: senoide).",
                                    "Definir sinal aperiódico: sinal que não se repete periodicamente (ex: degrau unitário).",
                                    "Introduzir sinal arbitrário: sinal não periódico nem aperiódico previsível, como ruído ou impulsos aleatórios.",
                                    "Explicar importância em identificação de sistemas dinâmicos: excitações que revelam resposta completa do sistema.",
                                    "Analisar exemplos gráficos de cada tipo."
                                  ],
                                  "verification": "Resumir definições em um quadro comparativo sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim), software MATLAB ou Python (SciPy) para plotar sinais"
                                  ],
                                  "tips": "Use gráficos para visualizar repetições e padrões; foque na ausência de periodicidade.",
                                  "learningObjective": "Diferenciar sinais por suas propriedades temporais básicas.",
                                  "commonMistakes": [
                                    "Confundir aperiódico com arbitrário (aperiódico pode ser determinístico), ignorar contexto de sistemas dinâmicos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar características específicas de sinais arbitrários",
                                  "subSteps": [
                                    "Estudar tipos: ruído branco gaussiano, ruído colorido, pseudo-ruído (PRBS).",
                                    "Analisar propriedades estatísticas: média, variância, autocorrelação.",
                                    "Comparar com sinais periódicos (espectro discreto) vs. arbitrários (espectro contínuo).",
                                    "Simular ruído em software para observar comportamento.",
                                    "Discutir por que arbitrários são ideais para identificação: espectro amplo."
                                  ],
                                  "verification": "Gerar e plotar um sinal arbitrário e listar 3 propriedades chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (NumPy, Matplotlib), exemplos de dados de ruído"
                                  ],
                                  "tips": "Sempre verifique o espectro de potência para confirmar largura de banda.",
                                  "learningObjective": "Reconhecer traços estatísticos e espectrais de sinais arbitrários.",
                                  "commonMistakes": [
                                    "Assumir todo ruído como arbitrário sem verificar periodicidade oculta, negligenciar normalização."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar classificação de sinais em contextos de análise de sistemas",
                                  "subSteps": [
                                    "Coletar amostras: sinais de teste (periódico, aperiódico, ruído).",
                                    "Aplicar critérios: verificar periodicidade via FFT, estacionariedade, previsibilidade.",
                                    "Classificar: rotular como arbitrário se espectro plano e não repetitivo.",
                                    "Aplicar convolução: simular resposta de sistema linear a sinal arbitrário.",
                                    "Documentar classificações com justificativas."
                                  ],
                                  "verification": "Classificar corretamente 5 sinais de um conjunto misto em relatório.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Banco de dados de sinais (ex: IEEE datasets), simulador de sistemas dinâmicos"
                                  ],
                                  "tips": "Use janela de análise longa para detectar periodicidades fracas.",
                                  "learningObjective": "Classificar sinais com precisão em cenários reais de identificação.",
                                  "commonMistakes": [
                                    "Classificar ruído periódico como arbitrário, ignorar aliasing em amostragem."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar classificação em identificação de sistemas dinâmicos",
                                  "subSteps": [
                                    "Modelar sistema aeronáutico simples (ex: flap de asa).",
                                    "Injetar sinal arbitrário como entrada e medir saída.",
                                    "Classificar entrada e estimar modelo via deconvolução.",
                                    "Validar: comparar resposta simulada com medida.",
                                    "Analisar erros de classificação e ajustes."
                                  ],
                                  "verification": "Produzir modelo identificado com erro <5% usando sinal arbitrário classificado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulink para modelagem aeronáutica, dados experimentais de vibração"
                                  ],
                                  "tips": "Escolha ruído com largura de banda adequada ao sistema.",
                                  "learningObjective": "Integrar classificação em pipeline de identificação de sistemas.",
                                  "commonMistakes": [
                                    "Usar sinal inadequado (baixa excitação), não filtrar pré-processamento."
                                  ]
                                }
                              ],
                              "practicalExample": "Em teste de vibração de asa de aeronave, classifique um sinal de entrada como ruído branco gaussiano (arbitrário) ao analisar FFT plana e autocorrelação em delta, diferenciando de vibração periódica do motor.",
                              "finalVerifications": [
                                "Define corretamente sinal arbitrário e contrasta com periódico/aperiódico.",
                                "Classifica 90% de sinais de teste como arbitrários com justificativa espectral.",
                                "Simula resposta de sistema a sinal arbitrário sem erros numéricos.",
                                "Explica uso em identificação dinâmica com exemplo aeronáutico.",
                                "Identifica propriedades estatísticas em dados reais.",
                                "Gera relatório com gráficos de classificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 30%)",
                                "Habilidade de classificação via análise espectral (25%)",
                                "Qualidade de simulações e exemplos práticos (20%)",
                                "Justificativas lógicas e contextualizadas (15%)",
                                "Integração com convolução e identificação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: análise de ruído gaussiano.",
                                "Processamento Digital de Sinais: FFT e autocorrelação.",
                                "Engenharia de Controle: identificação de modelos dinâmicos.",
                                "Física Aeronáutica: vibrações e testes estruturais."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, classificar sinais de excitação arbitrária (ruído ambiental) em testes de fadiga estrutural para identificar modos dinâmicos precisos, garantindo segurança de voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Aplicar linearidade a entradas arbitrárias",
                            "description": "Demonstrar como a propriedade de linearidade permite somar respostas a componentes individuais de um sinal arbitrário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as propriedades fundamentais de linearidade em sistemas",
                                  "subSteps": [
                                    "Defina linearidade: aditividade (resposta a soma de entradas é soma de respostas) e homogeneidade (resposta a k*x é k*resposta a x).",
                                    "Estude exemplos simples: sistema y(t) = 2x(t) e y(t) = x(t) + x(t-1).",
                                    "Derive matematicamente a propriedade para convolução: y(t) = ∫ x(τ)h(t-τ)dτ.",
                                    "Identifique quando um sistema não é linear (ex: y(t) = x(t)^2).",
                                    "Pratique com equações diferenciais lineares em sistemas dinâmicos."
                                  ],
                                  "verification": "Resolva 3 exercícios simples de linearidade e confira com soluções conhecidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Folha de exercícios sobre linearidade",
                                    "Calculadora simbólica (MATLAB ou Python SymPy)"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar soma de entradas e saídas.",
                                  "learningObjective": "Compreender matematicamente como linearidade permite decomposição de sinais.",
                                  "commonMistakes": [
                                    "Confundir linearidade com simetria",
                                    "Ignorar limites de validade (regime linear)",
                                    "Esquecer homogeneidade em escalares complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor um sinal arbitrário em componentes individuais",
                                  "subSteps": [
                                    "Escolha um sinal arbitrário x(t), como uma combinação de degrau, rampa e senoide.",
                                    "Expresse x(t) = ∑ x_i(t), onde cada x_i(t) é um componente simples (ex: x1(t)=u(t), x2(t)=t*u(t)).",
                                    "Verifique a decomposição somando graficamente ou analiticamente os componentes.",
                                    "Ajuste para contexto aeronáutico: modele entrada como perturbação de ângulo de ataque.",
                                    "Use Fourier ou Laplace se aplicável para decomposição em bases."
                                  ],
                                  "verification": "Plote x(t) e seus componentes; confirme que soma equals x(t) em pontos chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib)",
                                    "Exemplos de sinais aeronáuticos (flaps deflection)",
                                    "Papel milimetrado para esboços manuais"
                                  ],
                                  "tips": "Comece com 2-3 componentes para simplicidade antes de arbitrários.",
                                  "learningObjective": "Habilitar representação de sinais complexos como superposição linear.",
                                  "commonMistakes": [
                                    "Componentes não ortogonais levando a sobreposições erradas",
                                    "Escala temporal inconsistente",
                                    "Ignorar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a resposta do sistema a cada componente individual",
                                  "subSteps": [
                                    "Obtenha a resposta impulsiva h(t) do sistema (conhecida ou derivada).",
                                    "Para cada x_i(t), compute y_i(t) = x_i(t) * h(t) via integral de convolução.",
                                    "Use tabelas de Laplace para componentes comuns (degrau, rampa).",
                                    "Simule numericamente se analítico complexo.",
                                    "Valide com propriedades conhecidas (ex: resposta a degrau unitário)."
                                  ],
                                  "verification": "Compare y_i(t) computado com resposta esperada para componentes padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de transformadas de Laplace",
                                    "MATLAB Simulink para convolução",
                                    "Notebook para cálculos analíticos"
                                  ],
                                  "tips": "Priorize convolução gráfica para intuição antes de analítica.",
                                  "learningObjective": "Aplicar convolução individualmente explorando linearidade.",
                                  "commonMistakes": [
                                    "Limites errados na integral de convolução",
                                    "Confundir convolução com correlação",
                                    "Não normalizar impulsos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar as respostas individuais para obter a resposta total",
                                  "subSteps": [
                                    "Some y(t) = ∑ y_i(t) analiticamente ou numericamente.",
                                    "Plote y(t) total vs. soma das y_i(t) para visualização.",
                                    "Compare com convolução direta de x(t)*h(t) para validação.",
                                    "Analise erros numéricos em simulações.",
                                    "Discuta estabilidade e convergência da soma."
                                  ],
                                  "verification": "Erro entre método direto e decomposição < 1% em simulação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (MATLAB ou Python SciPy)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use vetores discretos para sinais digitais em prática.",
                                  "learningObjective": "Demonstrar empiricamente a propriedade de aditividade.",
                                  "commonMistakes": [
                                    "Fases desalinhadas em componentes senoidais",
                                    "Acúmulo de erros de arredondamento",
                                    "Esquecer escalas em soma"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flaps de aeronave, decomponha a entrada de comando x(t) = u(t) + 0.5*t*u(t) + sin(ωt)u(t). Calcule respostas individuais y1(t), y2(t), y3(t) à h(t) do atuador, então some para prever deflexão total y(t), validando contra simulação full-convolução.",
                              "finalVerifications": [
                                "Decompor corretamente um sinal arbitrário em 3+ componentes.",
                                "Computar convoluções individuais sem erros matemáticos.",
                                "Soma das respostas individuais matches resposta direta.",
                                "Interpretar graficamente superposição em contexto aeronáutico.",
                                "Identificar quando linearidade falha (ex: saturação).",
                                "Simular em software com erro <0.5%."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na decomposição e convolução (90%+ correto).",
                                "Qualidade de plots e visualizações (clareza, labels).",
                                "Explicação verbal da linearidade aplicada.",
                                "Validação cruzada (analítico vs numérico).",
                                "Relevância ao contexto de sistemas dinâmicos aeronáuticos.",
                                "Identificação de 2+ erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e superposição de vetores.",
                                "Física: Dinâmica linear de sistemas mecânicos (vibrações).",
                                "Programação: Implementação numérica de convolução em Python/MATLAB.",
                                "Controle Automático: Análise de sistemas LTI.",
                                "Processamento de Sinais: Decomposição Fourier."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, permite analisar respostas de aeronaves a perturbações complexas (turbulência + manobras) decompondo em componentes, otimizando controle de voo e reduzindo simulações computacionais caras em identificadores de sistemas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Integral de Convolução",
                        "description": "Fórmula matemática para a saída y(t) de um sistema LTI: y(t) = ∫_{-∞}^{∞} x(τ) h(t-τ) dτ, e suas propriedades e computação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Derivar a integral de convolução",
                            "description": "Deduzir a expressão da convolução a partir da superposição de impulsos, mostrando y(t) como integral contínua para sistemas contínuos no tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Resposta ao Impulso Unitário",
                                  "subSteps": [
                                    "Defina a função impulso δ(t) como uma distribuição que integra a 1 e é zero em todo lugar exceto em t=0.",
                                    "Explique que para um sistema LTI contínuo, a resposta ao impulso unitário é h(t), que descreve completamente o sistema.",
                                    "Discuta a propriedade de causalidade: h(t)=0 para t<0 em sistemas causais.",
                                    "Ilustre graficamente δ(t) e h(t) para um exemplo simples como h(t)=e^{-t}u(t).",
                                    "Revise a linearidade e invariância temporal que justificam o uso de h(t)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que é h(t) e desenhe seu gráfico para um sistema causal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), papel e lápis ou software de plotagem como MATLAB/Octave"
                                  ],
                                  "tips": "Sempre relacione h(t) à saída natural do sistema quando excitado por um 'pico' infinitesimal.",
                                  "learningObjective": "Dominar o papel fundamental da resposta ao impulso em sistemas LTI contínuos.",
                                  "commonMistakes": [
                                    "Confundir h(t) com a função de transferência H(s), que é no domínio de Laplace; lembrar que h(t) é no tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a Entrada x(t) como Superposição de Impulsos",
                                  "subSteps": [
                                    "Expresse x(t) como uma integral de impulsos escalados: x(t) = ∫_{-∞}^{∞} x(τ) δ(t - τ) dτ.",
                                    "Interprete x(τ) dτ como a 'força' ou amplitude do impulso infinitesimal em τ.",
                                    "Discuta o limite de soma de Riemann para funções contínuas aproximando com impulsos discretos.",
                                    "Verifique a propriedade da integral: ∫ x(τ) δ(t - τ) dτ = x(t).",
                                    "Desenhe graficamente x(t) como 'camadas' de impulsos δ(t-τ) ponderados por x(τ)."
                                  ],
                                  "verification": "Escreva e prove que ∫ x(τ) δ(t - τ) dτ = x(t) usando propriedades da delta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno de anotações, calculadora simbólica ou SymPy no Python"
                                  ],
                                  "tips": "Pense em x(t) como uma 'chuva' infinita de impulsos minúsculos sobrepostos.",
                                  "learningObjective": "Representar qualquer sinal arbitrário contínuo como integral de impulsos unitários escalados e deslocados.",
                                  "commonMistakes": [
                                    "Esquecer os limites de integração (-∞ a ∞); sempre inclua para generalidade, mesmo em sinais causais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Resposta do Sistema a Impulsos Deslocados",
                                  "subSteps": [
                                    "Pela invariância temporal, o impulso δ(t - τ) produz resposta h(t - τ).",
                                    "A contribuição infinitesimal para y(t) de x(τ) dτ é x(τ) h(t - τ) dτ.",
                                    "Some linearmente todas as contribuições de impulsos em diferentes τ.",
                                    "Escreva y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ.",
                                    "Confirme que isso satisfaz linearidade e invariância temporal."
                                  ],
                                  "verification": "Derive a expressão y(t) = ∫ x(τ) h(t - τ) dτ a partir da superposição e verifique para um caso causal.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Folha de derivadas, exemplos de h(t) tabulados"
                                  ],
                                  "tips": "Use a propriedade de escalamento da delta para justificar h(t - τ).",
                                  "learningObjective": "Construir a saída y(t) somando respostas a cada componente infinitesimal da entrada.",
                                  "commonMistakes": [
                                    "Invertar a ordem: é x(τ) h(t-τ), não h(τ) x(t-τ); teste com troca de variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar e Verificar a Integral de Convolução",
                                  "subSteps": [
                                    "Introduza a notação de convolução (x * h)(t) = ∫ x(τ) h(t - τ) dτ.",
                                    "Mostre equivalência com ∫ h(τ) x(t - τ) dτ via substituição u = t - τ.",
                                    "Discuta limites para causalidade: ∫_0^t se x(τ)=0 para τ<0 e h(τ)=0 para τ<0.",
                                    "Verifique com propriedades: convolução com δ(t) dá x(t) de volta.",
                                    "Plote y(t) para um exemplo simples para validar."
                                  ],
                                  "verification": "Escreva a integral de convolução em ambas as formas e prove sua simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Python), exemplos numéricos"
                                  ],
                                  "tips": "Memorize a 'seta do tempo' na convolução: h(t-τ) 'flipa e desliza' h(τ).",
                                  "learningObjective": "Derivar e formalizar completamente a integral de convolução como representação geral da saída de sistemas LTI.",
                                  "commonMistakes": [
                                    "Ignorar a flip em h(t-τ); sempre substitua para checar simetria."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema com h(t) = e^{-a t} u(t) e entrada x(t) = u(t) (degrau unitário), derive y(t) = ∫_0^t e^{-a (t-τ)} dτ = (1 - e^{-a t})/a, mostrando como a convolução suaviza o degrau em uma resposta em rampa exponencial.",
                              "finalVerifications": [
                                "Escreva corretamente y(t) = ∫_{-∞}^∞ x(τ) h(t-τ) dτ a partir de zero.",
                                "Explique intuitivamente por que usamos superposição de impulsos.",
                                "Prove que convolução com δ(t) recupera x(t).",
                                "Ajuste limites para sistemas causais e justifique.",
                                "Plote um exemplo gráfico de convolução simples.",
                                "Discuta o que acontece se o sistema não for LTI."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Clareza na explicação intuitiva da superposição.",
                                "Correta manipulação de propriedades da delta e limites de integração.",
                                "Uso apropriado de gráficos ou exemplos para ilustração.",
                                "Compreensão de causalidade e generalidade.",
                                "Capacidade de generalizar para formas simétricas da integral."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e distribuições (função delta).",
                                "Física: Modelagem de sistemas dinâmicos lineares como amortecedores em aeronaves.",
                                "Processamento de Sinais: Base para filtros digitais em controle de voo.",
                                "Probabilidade: Convolução como soma de variáveis aleatórias independentes.",
                                "Computação: Implementação numérica via FFT para simulações."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, a integral de convolução modela a resposta de sistemas de controle de voo a entradas arbitrárias, como turbulências, permitindo simular e prever o comportamento dinâmico de aeronaves em análise de estabilidade e identificação de sistemas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Calcular convolução analiticamente",
                            "description": "Resolver integrais de convolução para pares comuns como degrau com exponencial ou seno com exponencial, usando técnicas de integração por partes ou tabelas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Propriedades da Integral de Convolução",
                                  "subSteps": [
                                    "Leia a definição matemática da convolução contínua: (f * g)(t) = ∫_{-∞}^{∞} f(τ) g(t - τ) dτ.",
                                    "Estude propriedades chave: comutatividade (f*g = g*f), associatividade, distributividade sobre adição e estabilidade para LTI.",
                                    "Interprete graficamente: sobreposição e 'espelhamento' de sinais.",
                                    "Derive a convolução para funções com suporte finito.",
                                    "Pratique mudança de variável na integral para limites de 0 a t em sinais causais."
                                  ],
                                  "verification": "Explique em voz alta ou por escrito a definição e liste 3 propriedades com exemplos simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas (ex: Oppenheim), caderno, calculadora simbólica opcional (Wolfram Alpha para verificação).",
                                  "tips": "Sempre assuma causalidade (u(t)) para simplificar limites de integração de 0 a t.",
                                  "learningObjective": "Dominar a formulação matemática e interpretação física da convolução.",
                                  "commonMistakes": "Esquecer o espelhamento g(t - τ) ou usar limites errados (ex: -∞ a ∞ em vez de 0 a t para causais)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Técnicas de Integração por Partes e Tabelas de Integrais",
                                  "subSteps": [
                                    "Revise a fórmula de integração por partes: ∫ u dv = uv - ∫ v du.",
                                    "Pratique escolha de u e dv para funções como t e^{-at}, sen(ωt) e^{-at}.",
                                    "Memorize ou consulte tabela de integrais comuns: ∫ e^{at} sin(bt) dt, ∫ t^n e^{at} dt.",
                                    "Aplique em integrais indefinidas simples envolvendo exponenciais e polinômios.",
                                    "Resolva 3 integrais de prática sem consulta inicial."
                                  ],
                                  "verification": "Resolva ∫_0^t τ e^{-a(t-τ)} dτ corretamente e compare com tabela.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela de integrais (impressa ou online), caderno, software como Mathematica para checagem.",
                                  "tips": "Escolha u como a função que simplifica ao derivar (polinômio ou seno), dv como exponencial.",
                                  "learningObjective": "Aplicar integração por partes eficientemente em formas de convolução.",
                                  "commonMistakes": "Escolha errada de u/dv levando a integrais mais complexas; esquecer sinal negativo em partes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Convolução Analítica para Degrau Unitário com Exponencial",
                                  "subSteps": [
                                    "Escreva a integral: h(t) = ∫_0^t u(τ) e^{-a(t-τ)} dτ = ∫_0^t e^{-a(t-τ)} dτ.",
                                    "Faça substituição σ = t - τ, dσ = -dτ, limites de t a 0 → 0 a t.",
                                    "Integre: h(t) = (1/a) (1 - e^{-at}) u(t).",
                                    "Verifique por diferenciação: h'(t) = δ(t) * e^{-at} + ... (propriedade derivada).",
                                    "Generalize para e^{-bτ} * e^{-a(t-τ)}."
                                  ],
                                  "verification": "Derive o resultado exato e plote graficamente para a=1, compare com simulação numérica.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel milimetrado para gráficos, MATLAB/Python para plot de verificação.",
                                  "tips": "Sempre multiplique pelo u(t) final para causalidade.",
                                  "learningObjective": "Resolver convolução u(t) * e^{-at} u(t) analiticamente.",
                                  "commonMistakes": "Erro nos limites após substituição; esquecer fator u(t) no resultado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Convoluções com Seno e Verificar Resultados Gerais",
                                  "subSteps": [
                                    "Configure integral para sin(ωt) * e^{-at}: ∫_0^t sin(ωτ) e^{-a(t-τ)} dτ.",
                                    "Use integração por partes duas vezes (fórmula padrão para sin e exp).",
                                    "Resolva: h(t) = [e^{-at} (a sin(ωt) - ω cos(ωt)) + ω]/ (a^2 + ω^2) u(t).",
                                    "Verifique com transformada de Laplace inversa:  ω/(s(s+a)^2 + ω^2).",
                                    "Resolva 2 problemas adicionais e compare com software."
                                  ],
                                  "verification": "Calcule 3 convoluções diferentes e confirme resultados via Laplace ou numérico.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Tabelas Laplace, Python/MATLAB para simulação de convolução.",
                                  "tips": "Use fórmula fechada de tabelas para aceleração após prática inicial.",
                                  "learningObjective": "Mestre pares comuns como seno/exponencial usando partes ou tabelas.",
                                  "commonMistakes": "Perder fatores trigonométricos em partes múltiplas; erros aritméticos em denominadores."
                                }
                              ],
                              "practicalExample": "Calcule a convolução h(t) = u(t) * e^{-2t} u(t). Solução: Substitua na integral ∫_0^t e^{-2(t-τ)} dτ = (1/2)(1 - e^{-2t}) u(t). Verifique: Para t=1, h(1) ≈ 0.432.",
                              "finalVerifications": [
                                "Calcula corretamente u(t) * e^{-at} u(t) = (1/a)(1 - e^{-at}) u(t).",
                                "Resolve sin(ωt) u(t) * e^{-at} u(t) com fórmula exata.",
                                "Identifica limites corretos para sinais causais.",
                                "Verifica resultado via diferenciação ou Laplace.",
                                "Plota e interpreta graficamente pelo menos 2 convoluções.",
                                "Explica passos sem consulta em 5 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na solução final (sem erros algébricos).",
                                "Uso correto de técnicas de integração (partes ou tabelas).",
                                "Manipulação adequada de limites e causalidade.",
                                "Verificação independente do resultado (Laplace ou numérica).",
                                "Explicação clara dos passos intermediários.",
                                "Eficiência: resolve em tempo razoável sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo Integral Avançado (integração por partes, tabelas).",
                                "Física: Sistemas Lineares Invariantes no Tempo (resposta a impulsos).",
                                "Engenharia de Controle: Análise de Resposta Transitória em Aeronáutica.",
                                "Processamento de Sinais: Filtragem e Correlação.",
                                "Computação: Implementação Numérica de Convolução (MATLAB/Python)."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular a convolução analítica determina a resposta transitória de sistemas dinâmicos a entradas como degraus (manobras) ou senos (oscilações), essencial para modelagem de estabilidade de aeronaves em análise de identificação de sistemas via sinais de teste."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Explorar propriedades da convolução",
                            "description": "Verificar comutatividade, associatividade e distributividade da convolução, e simplificações para sistemas causais (limites de integração de 0 a t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar a Comutatividade da Convolução",
                                  "subSteps": [
                                    "Defina a convolução (f * g)(t) = ∫_{-∞}^{∞} f(τ) g(t - τ) dτ.",
                                    "Substitua as variáveis para (g * f)(t) = ∫_{-∞}^{∞} g(τ) f(t - τ) dτ.",
                                    "Faça a mudança de variável σ = t - τ na integral de (g * f), mostrando que dσ = -dτ e limites invertem mas cancelam.",
                                    "Conclua que (f * g)(t) = (g * f)(t)."
                                  ],
                                  "verification": "Prove algebraicamente que as integrais são iguais e teste numericamente com funções simples como retângulos em software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "MATLAB ou Python (SciPy.signal.convolve)",
                                    "Papel e lápis para derivação"
                                  ],
                                  "tips": "Use funções simétricas inicialmente para visualizar a propriedade.",
                                  "learningObjective": "Demonstrar matematicamente e numericamente que a convolução é comutativa.",
                                  "commonMistakes": [
                                    "Esquecer de ajustar os limites na mudança de variável",
                                    "Confundir com multiplicação ponto a ponto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a Associatividade da Convolução",
                                  "subSteps": [
                                    "Defina (f * (g * h))(t) expandindo a convolução interna primeiro.",
                                    "Expanda ((f * g) * h)(t) de forma similar.",
                                    "Mostre que ambas as expressões duplas resultam em ∫∫ f(σ) g(τ) h(t - σ - τ) dσ dτ.",
                                    "Conclua a igualdade pelas propriedades da integração múltipla."
                                  ],
                                  "verification": "Derive as expressões duplas e confirme com um exemplo numérico de três funções (ex: funções degrau).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB, Python)",
                                    "Folhas de cálculo para integrais"
                                  ],
                                  "tips": "Comece com funções de suporte finito para evitar divergências.",
                                  "learningObjective": "Provar que a convolução permite regrouping de funções sem alterar o resultado.",
                                  "commonMistakes": [
                                    "Erro na ordem das variáveis na expansão dupla",
                                    "Ignorar a independência das variáveis de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Distributividade da Convolução",
                                  "subSteps": [
                                    "Defina f * (g + h)(t) = ∫ f(τ) [g(t - τ) + h(t - τ)] dτ.",
                                    "Distribua a integral: ∫ f(τ) g(t - τ) dτ + ∫ f(τ) h(t - τ) dτ.",
                                    "Mostre que isso é (f * g)(t) + (f * h)(t).",
                                    "Repita para (f + g) * h."
                                  ],
                                  "verification": "Prove para ambos os casos e valide com sinal somado em simulação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas computacionais para soma de sinais",
                                    "Referência teórica de LTI systems"
                                  ],
                                  "tips": "Visualize graficamente a sobreposição das funções.",
                                  "learningObjective": "Entender como a convolução distribui sobre adição linear.",
                                  "commonMistakes": [
                                    "Confundir distributividade com comutatividade",
                                    "Esquecer o caso distributivo à esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificações para Sistemas Causais",
                                  "subSteps": [
                                    "Explique que para sistemas causais, h(τ) = 0 para τ < 0, então y(t) = ∫_{0}^{t} x(τ) h(t - τ) dτ.",
                                    "Derive os limites alterando variáveis para sistemas onde x também é causal.",
                                    "Teste com funções degrau unitário e impulsiva causal.",
                                    "Discuta implicações para computação numérica (limites finitos)."
                                  ],
                                  "verification": "Calcule convolução causal vs. geral e confirme igualdade para entradas causais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de respostas impulsivas causais",
                                    "Software para plotar respostas"
                                  ],
                                  "tips": "Sempre assuma causalidade em aplicações físicas para eficiência.",
                                  "learningObjective": "Aplicar limites de integração corretos em contextos reais de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Usar limites -∞ a ∞ em sistemas causais, levando a erros numéricos",
                                    "Confundir causalidade de x e h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração e Verificação Geral das Propriedades",
                                  "subSteps": [
                                    "Combine propriedades em uma expressão complexa (ex: (f * g) * h + f * (g + h)).",
                                    "Simule em software para validar todas.",
                                    "Analise impacto em sistemas LTI aeronáuticos.",
                                    "Documente achados em relatório."
                                  ],
                                  "verification": "Simulação reproduz teorema e relatório explica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink para sistemas dinâmicos",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use funções relevantes a aero (ex: aceleração como entrada).",
                                  "learningObjective": "Sintetizar propriedades em aplicações práticas.",
                                  "commonMistakes": [
                                    "Não normalizar sinais em simulações",
                                    "Ignorar unidades em exemplos reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aeronave, convolvendo a resposta impulsiva causal h(t) de um estabilizador de voo com uma entrada de turbulência x(t) (causal), verifique comutatividade trocando x e h (se possível), associatividade adicionando outro filtro, e limites de 0 a t para eficiência computacional.",
                              "finalVerifications": [
                                "Prova algébrica completa de comutatividade, associatividade e distributividade.",
                                "Cálculo correto de convolução causal com limites 0 a t.",
                                "Simulação numérica validando todas as propriedades.",
                                "Explicação de quando usar simplificações causais.",
                                "Identificação de erros comuns em derivações."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas provas (100% correto).",
                                "Qualidade e correção das simulações (plots e valores).",
                                "Profundidade na análise causal vs. geral.",
                                "Clareza na documentação de verificações.",
                                "Criatividade em exemplos aeronáuticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de integrais de Lebesgue e mudanças de variáveis.",
                                "Programação: Implementação eficiente de FFT para convolução rápida.",
                                "Física: Modelagem de sistemas LTI em dinâmica de voo.",
                                "Controle Automático: Análise de estabilidade via convolução.",
                                "Processamento de Sinais: Filtros digitais discretos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, propriedades da convolução permitem simular respostas de aeronaves a perturbações (turbulência, falhas), otimizando controladores em softwares como Simulink, reduzindo tempo de integração com causalidade e garantindo estabilidade via distributividade em bancos de filtros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Aplicar em exemplos práticos",
                            "description": "Computar saídas de sistemas LTI reais, como circuitos RLC ou massas-molas, usando convolução para entradas arbitrárias e validar com simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema LTI real e determinar sua resposta ao impulso",
                                  "subSteps": [
                                    "Escolha um sistema físico real, como um circuito RLC série ou um sistema massa-mola-amortecedor.",
                                    "Derive a equação diferencial do sistema e encontre a função de transferência H(s) ou a resposta ao impulso h(t).",
                                    "Converta para o domínio do tempo se necessário, usando transformadas de Laplace inversa.",
                                    "Verifique a causalidade e estabilidade do sistema.",
                                    "Documente os parâmetros físicos (R, L, C ou m, k, b)."
                                  ],
                                  "verification": "A resposta ao impulso h(t) ou H(s) está corretamente derivada e plotada, com unidades consistentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas",
                                    "Software de álgebra simbólica como MATLAB Symbolic ou SymPy",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Comece com valores numéricos realistas para facilitar simulações posteriores.",
                                  "learningObjective": "Compreender e modelar sistemas LTI físicos como convolução-ready.",
                                  "commonMistakes": [
                                    "Esquecer fatores de escala nas transformadas",
                                    "Ignorar condições iniciais zero para LTI"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e preparar a entrada arbitrária",
                                  "subSteps": [
                                    "Selecione uma entrada u(t) arbitrária relevante, como um pulso, sinal senoidal modulada ou ruído.",
                                    "Expresse u(t) em termos matemáticos ou gere dados numéricos discretos.",
                                    "Normalize ou escale a entrada para valores práticos (ex: volts ou Newtons).",
                                    "Plote u(t) para visualização.",
                                    "Discuta por que essa entrada é 'arbitrária' mas representativa de cenários reais."
                                  ],
                                  "verification": "Gráfico de u(t) gerado e expressão matemática documentada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB/Octave/Python (NumPy/Matplotlib)",
                                    "Tabelas de funções comuns"
                                  ],
                                  "tips": "Use entradas piecewise para praticar convolução por partes.",
                                  "learningObjective": "Preparar entradas complexas para convolução.",
                                  "commonMistakes": [
                                    "Não considerar o domínio de suporte da entrada",
                                    "Escala inadequada levando a overflow numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a saída y(t) via integral de convolução",
                                  "subSteps": [
                                    "Implemente a convolução y(t) = ∫ h(τ) u(t-τ) dτ analiticamente se possível, ou numericamente.",
                                    "Para casos analíticos, divida em intervalos e integre por partes.",
                                    "Para numérico, use soma discreta ou funções conv() em software.",
                                    "Plote y(t) e compare com resposta teórica esperada.",
                                    "Calcule métricas como energia ou pico da saída."
                                  ],
                                  "verification": "y(t) computada e plotada, com valores em t=0 e t=∞ verificados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB conv() ou scipy.signal.convolve",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Discretize com amostragem alta (dt < 0.01 * tempo característico) para precisão.",
                                  "learningObjective": "Executar convolução para entradas arbitrárias em sistemas reais.",
                                  "commonMistakes": [
                                    "Índices errados em convolução discreta",
                                    "Não inverter limites de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados com simulações numéricas",
                                  "subSteps": [
                                    "Simule o sistema via equação diferencial (lsim() no MATLAB ou odeint no Python).",
                                    "Compare y_convolucao(t) com y_simulacao(t) quantitativamente (erro RMS < 1%).",
                                    "Analise discrepâncias e ajuste parâmetros se necessário.",
                                    "Gere relatórios com gráficos sobrepostos.",
                                    "Teste sensibilidade a variações em parâmetros."
                                  ],
                                  "verification": "Gráficos sobrepostos mostram concordância, com tabela de erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Simulink ou Python (SciPy odeint/control)",
                                    "Templates de script"
                                  ],
                                  "tips": "Use solvers adaptativos para simulações precisas.",
                                  "learningObjective": "Validar convolução contra métodos alternativos.",
                                  "commonMistakes": [
                                    "Condições iniciais inconsistentes",
                                    "Passo de tempo inadequado na simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um circuito RLC série com R=1Ω, L=1H, C=1F e entrada u(t)=sen(πt) para 0<t<2, senão 0: derive h(t)=e^{-0.5t}sin(√(0.75)t), compute y(t) via conv, simule com lsim e valide erro <0.5%.",
                              "finalVerifications": [
                                "Convolução manual coincide com função conv() em pelo menos 3 pontos chave.",
                                "Simulação diferencial reproduz y(t) com RMSE <1%.",
                                "Efeitos físicos (ex: overshoot em RLC) observados e explicados.",
                                "Código reproduzível gera plots idênticos.",
                                "Análise de estabilidade confirmada para entrada arbitrária.",
                                "Relatório resume método, resultados e lições."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem LTI (equação diferencial correta: 100%)",
                                "Correção da convolução (erro numérico <2%)",
                                "Qualidade da validação (gráficos claros, métricas quantitativas)",
                                "Interpretação física dos resultados (explicação de picos/damping)",
                                "Eficiência do código/simulação (roda em <1min)",
                                "Documentação completa e organizada"
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de circuitos e vibrações mecânicas.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Controle Automático: Análise de resposta em malha aberta.",
                                "Processamento de Sinais: Aplicação em filtros digitais.",
                                "Engenharia Aeronáutica: Modelagem de flutter ou controle de atitude."
                              ],
                              "realWorldApplication": "Em aeronáutica, convolução modela resposta de estruturas a turbulências arbitrárias (sistemas massa-mola), prevendo vibrações em asas; validação com simulações garante segurança em design de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Sinais Senoidais e Função de Resposta em Frequência",
                    "description": "Uso de sinais sinusoidais para análise da função de transferência em frequência e propriedades espectrais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Sinais Senoidais",
                        "description": "Sinais senoidais como entradas fundamentais para a análise em frequência de sistemas lineares invariantes no tempo (LTI), destacando suas propriedades de amplitude, frequência e fase, e a resposta estacionária do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Representação matemática de sinais senoidais",
                            "description": "Expressar um sinal senoidal na forma x(t) = A cos(ωt + φ) ou equivalente, identificando amplitude A, frequência angular ω e fase φ, e converter entre formas seno e cosseno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais de um sinal senoidal",
                                  "subSteps": [
                                    "Defina amplitude A como o valor máximo de deslocamento do sinal em relação ao eixo zero.",
                                    "Explique frequência angular ω como ω = 2πf, onde f é a frequência em Hz, e calcule o período T = 2π/ω.",
                                    "Descreva a fase inicial φ como o deslocamento angular em radianos no tempo t=0.",
                                    "Visualize graficamente um sinal senoidal genérico, marcando A, ω e φ no gráfico.",
                                    "Discuta unidades típicas: A em volts ou metros, ω em rad/s, φ em radianos."
                                  ],
                                  "verification": "Desenhe um gráfico de sinal senoidal e rotule corretamente A, ω e φ com valores numéricos exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos impressos de senoides",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre comece visualizando o gráfico para intuitivamente entender os parâmetros.",
                                  "learningObjective": "Definir e diferenciar amplitude, frequência angular e fase de um sinal senoidal.",
                                  "commonMistakes": [
                                    "Confundir ω (rad/s) com f (Hz)",
                                    "Usar graus em vez de radianos para φ",
                                    "Ignorar o sinal de φ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar sinal senoidal na forma padrão x(t) = A cos(ωt + φ)",
                                  "subSteps": [
                                    "Escreva a forma geral x(t) = A cos(ωt + φ) e explique que cos é preferida por conveniência em sistemas.",
                                    "Dado um sinal descritivo como 'sinal de 3V, 10 Hz, fase 30°', converta para a forma matemática.",
                                    "Calcule ω = 2π*10 = 20π rad/s e φ = π/6 rad.",
                                    "Escreva x(t) = 3 cos(20π t + π/6).",
                                    "Verifique plotando mentalmente ou esboçando o sinal nos primeiros ciclos."
                                  ],
                                  "verification": "Construa a equação x(t) a partir de valores dados de A, f e φ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de exercícios com exemplos",
                                    "Software de plotagem como Desmos (opcional)"
                                  ],
                                  "tips": "Lembre-se: φ positivo desloca para esquerda no gráfico de cosseno.",
                                  "learningObjective": "Construir a representação matemática na forma cosseno a partir de parâmetros descritivos.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2π ao converter f para ω",
                                    "Não converter graus para radianos",
                                    "Usar sen em vez de cos na forma padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar parâmetros A, ω e φ de uma equação senoidal dada",
                                  "subSteps": [
                                    "Dado x(t) = 4 cos(5t - π/3), identifique A=4, ω=5 rad/s, φ=-π/3.",
                                    "Extraia ω do coeficiente de t, A do multiplicador externo, φ do termo constante.",
                                    "Calcule f = ω/(2π) e verifique consistência.",
                                    "Repita com variações como x(t) = -2 sin(ωt + φ), notando que A pode ser negativa.",
                                    "Pratique com 3 equações diferentes, anotando os parâmetros."
                                  ],
                                  "verification": "Liste A, ω, φ e f para 3 equações fornecidas sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de 5 equações de exemplo",
                                    "Papel para anotações"
                                  ],
                                  "tips": "φ é o termo após ωt; sinal negativo indica defasagem.",
                                  "learningObjective": "Extrair precisamente os três parâmetros de uma equação dada.",
                                  "commonMistakes": [
                                    "Confundir φ com o argumento completo",
                                    "Não reconhecer A negativa",
                                    "Erro em extração de ω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter entre formas seno e cosseno",
                                  "subSteps": [
                                    "Lembre a identidade: sin(θ) = cos(θ - π/2), então x(t) = A sin(ωt + ψ) = A cos(ωt + ψ - π/2).",
                                    "Dado x(t) = 5 sin(3t + π/4), converta: φ_cosseno = π/4 - π/2 = -π/4, x(t) = 5 cos(3t - π/4).",
                                    "Inverso: de cos para sin adicionando π/2 ao fase.",
                                    "Verifique equivalência plotando ou avaliando em t=0.",
                                    "Pratique conversões bidirecionais em 4 exemplos."
                                  ],
                                  "verification": "Converta 2 senos para cos e 2 cos para sen corretamente, confirmando valores em t=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de identidades trigonométricas",
                                    "Calculadora",
                                    "Gráficos para verificação"
                                  ],
                                  "tips": "Sempre ajuste φ por ±π/2 e verifique x(0).",
                                  "learningObjective": "Realizar conversões precisas entre representações seno e cosseno.",
                                  "commonMistakes": [
                                    "Erro no sinal do deslocamento π/2",
                                    "Não ajustar A se necessário",
                                    "Confundir direção da conversão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma asa de aeronave, dado um sinal medido x(t) = 2.5 sin(100π t + π/6) V (amplitude 2.5V, f=50Hz, fase 30°), converta para forma cosseno: x(t) = 2.5 cos(100π t - π/3), identifique A=2.5, ω=100π rad/s, φ=-π/3, e use para modelar resposta em frequência.",
                              "finalVerifications": [
                                "Construir equação cosseno a partir de A, f, φ descritivos sem erros.",
                                "Extrair corretamente A, ω, φ de qualquer forma senoidal dada.",
                                "Converter bidirecionalmente seno ↔ cosseno com fase ajustada precisamente.",
                                "Calcular f e T a partir de ω corretamente.",
                                "Verificar equivalência avaliando x(0) e plotando esboço.",
                                "Explicar significado físico de cada parâmetro em contexto de sistemas dinâmicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de A (100% correto em 5 exemplos).",
                                "Correta conversão ω = 2πf e vice-versa (erro <1%).",
                                "Domínio de fase φ em radianos, com conversões exatas.",
                                "Habilidade em conversões seno-cosseno sem erros de sinal.",
                                "Capacidade de visualizar e esboçar gráfico com parâmetros rotulados.",
                                "Explicação clara do significado em aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Trigonometria avançada e identidades angulares.",
                                "Física: Ondas mecânicas, vibrações e análise harmônica.",
                                "Programação: Simulação de senoides em MATLAB/Python para plotagem.",
                                "Engenharia de Controle: Entradas senoidais em sistemas lineares.",
                                "Estatística: Análise espectral e transformada de Fourier básica."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, representa vibrações senoidais em estruturas de aeronaves para análise de fadiga, identificação de modos naturais via testes de frequência, e design de sistemas de controle ativo de flutter, garantindo segurança estrutural em voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Resposta estacionária de sistemas LTI a senoides",
                            "description": "Demonstrar que, para um sistema LTI estável, a resposta em regime permanente a uma entrada senoidal é uma senoide da mesma frequência, com amplitude e fase alteradas pela função de resposta em frequência H(jω).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas LTI e Estabilidade",
                                  "subSteps": [
                                    "Defina um sistema LTI e liste suas propriedades principais (linearidade, invariância temporal).",
                                    "Explique o conceito de estabilidade (BIBO) e como verificá-la usando polos da função de transferência.",
                                    "Identifique condições para que um sistema LTI seja estável e responda a entradas senoidais em regime permanente.",
                                    "Revise a convolução para resposta a entradas arbitrárias, preparando para o caso senoidal.",
                                    "Estude o teorema da convolução em frequência para ligar tempo e frequência."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades de LTI e estabilidade, com um exemplo simples de sistema instável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Oppenheim 'Sinais e Sistemas'",
                                    "Notas de aula sobre LTI",
                                    "Software MATLAB para plotar polos"
                                  ],
                                  "tips": "Use diagramas de polos e zeros para visualizar estabilidade; foque em sistemas com polos no semiplano esquerdo.",
                                  "learningObjective": "Compreender as bases teóricas necessárias para respostas estacionárias em LTI estáveis.",
                                  "commonMistakes": [
                                    "Confundir estabilidade assintótica com BIBO",
                                    "Ignorar a necessidade de estabilidade para regime permanente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Entradas Senoidais Usando Fórmula de Euler",
                                  "subSteps": [
                                    "Expresse uma senoide real como soma de exponenciais complexas: cos(ωt) = [e^{jωt} + e^{-jωt}]/2.",
                                    "Analise a resposta de um LTI a exponenciais complexas: y(t) = H(jω) e^{jωt} para entrada e^{jωt}.",
                                    "Derive a resposta para senoides reais combinando respostas complexas conjugadas.",
                                    "Identifique que componentes transitórias decaem em sistemas estáveis, deixando apenas regime permanente.",
                                    "Calcule manualmente para um sistema simples como y'(t) + y(t) = cos(ωt)."
                                  ],
                                  "verification": "Derive a resposta complexa para uma entrada e^{jωt} e converta para forma real.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de identidades de Euler",
                                    "Calculadora simbólica como SymPy ou MATLAB",
                                    "Exemplos resolvidos de livros de sinais"
                                  ],
                                  "tips": "Sempre trabalhe com complexos primeiro; a imaginação ajuda a visualizar rotações de fase.",
                                  "learningObjective": "Dominar a representação frequência que permite usar H(jω) diretamente.",
                                  "commonMistakes": [
                                    "Esquecer o conjugado para a parte negativa",
                                    "Não descartar termos transitórios em LTI estáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Amplitude e Fase via Função de Resposta em Frequência H(jω)",
                                  "subSteps": [
                                    "Compute H(jω) = |H(jω)| e^{jφ(ω)} em magnitude e fase para um sistema dado.",
                                    "Determine a amplitude da saída: A_out = |H(jω)| * A_in.",
                                    "Calcule a fase da saída: φ_out = φ(ω) + φ_in (geralmente 0 para cos(ωt)).",
                                    "Esboce o diagrama de Bode para visualizar |H(jω)| e φ(ω).",
                                    "Aplique a um exemplo: sistema de segunda ordem com ω_n e ζ."
                                  ],
                                  "verification": "Para H(s) = 1/(s+1), calcule H(jω) para ω=1 e encontre amplitude/fase.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (control library)",
                                    "Papel milimetrado para Bode manual",
                                    "Tabelas de Bode para polos/zeros"
                                  ],
                                  "tips": "Use log-log para magnitude; memorize assíntotas para rapidez.",
                                  "learningObjective": "Aplicar H(jω) para prever mudanças em amplitude e fase.",
                                  "commonMistakes": [
                                    "Confundir H(jω) com H(s)",
                                    "Erro de sinal na fase"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Verificar Resposta Estacionária",
                                  "subSteps": [
                                    "Implemente o sistema em simulação (ex: ODE45 no MATLAB para diferencial).",
                                    "Aplique entrada senoidal e plote resposta total, destacando regime permanente.",
                                    "Meça amplitude e fase da estacionária via FFT ou ajuste visual.",
                                    "Compare com predições analíticas de H(jω).",
                                    "Teste com diferentes frequências para validar o conceito geral."
                                  ],
                                  "verification": "Gere plots mostrando convergência para senoide alterada; calcule erro <5%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (scipy.signal)",
                                    "Templates de simulação LTI"
                                  ],
                                  "tips": "Use tempo de simulação longo para capturar regime permanente; zoom na estacionária.",
                                  "learningObjective": "Validar teoricamente através de simulações práticas.",
                                  "commonMistakes": [
                                    "Simulação curta sem atingir estacionária",
                                    "Escala errada nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Generalizar o Conceito",
                                  "subSteps": [
                                    "Explique por que a frequência permanece igual (propriedade de LTI).",
                                    "Discuta limitações: só para estáveis e regime permanente.",
                                    "Estenda para múltiplas senoides via superposição.",
                                    "Relacione com diagramas de Nyquist para estabilidade.",
                                    "Resolva um problema completo de identificação via senoides."
                                  ],
                                  "verification": "Responda a 3 perguntas teóricas e resolva 1 exercício numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exercícios de livro-texto",
                                    "Quiz online sobre FRF"
                                  ],
                                  "tips": "Pense em harmônicos: LTI não gera novas frequências.",
                                  "learningObjective": "Generalizar o teorema para aplicações amplas.",
                                  "commonMistakes": [
                                    "Acreditar que aplica a não-lineares",
                                    "Ignorar superposição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um amortecedor de aeronave modelado como H(s) = ω_n² / (s² + 2ζω_n s + ω_n²), aplique entrada vibracional senoidal de 10 Hz (ω=62.8 rad/s). Calcule H(jω): amplitude reduzida em 0.5 e fase -30°, simulando atenuação de vibrações de motor.",
                              "finalVerifications": [
                                "Explicar verbalmente por que a saída estacionária tem mesma frequência da entrada.",
                                "Calcular corretamente |H(jω)| e φ(ω) para um sistema dado.",
                                "Identificar regime permanente em um plot de simulação.",
                                "Prever saída para entrada cos(ωt + θ).",
                                "Discutir falha em sistemas instáveis.",
                                "Aplicar superposição a sinal com duas frequências."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de H(jω) (erro <1%).",
                                "Correta identificação de amplitude, fase e frequência na saída.",
                                "Qualidade dos plots de simulação com legendas claras.",
                                "Explicação teórica coerente sem erros conceituais.",
                                "Generalização correta para casos múltiplos.",
                                "Tempo de conclusão dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Análise de servomecanismos via FRF.",
                                "Processamento de Sinais: Filtros digitais em DSP.",
                                "Dinâmica de Aeronaves: Análise de flutter e vibrações.",
                                "Eletrônica: Projeto de amplificadores de áudio.",
                                "Física: Ondas e ressonância em estruturas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, usado para analisar respostas de fuselagem a vibrações senoidais de turbinas, prevendo fadiga estrutural via testes de solo com shakers senoidais e ajustando amortecedores baseados em H(jω) medida."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Propriedades de ortogonalidade e decomposição",
                            "description": "Explicar a ortogonalidade de senoides de frequências diferentes e sua utilidade na análise harmônica para decompor sinais complexos em componentes senoidais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de ortogonalidade em funções",
                                  "subSteps": [
                                    "Defina ortogonalidade matemática: duas funções f(t) e g(t) são ortogonais em um intervalo [a,b] se a integral de f(t)*g(t) dt de a a b é zero.",
                                    "Explore o produto interno em espaços vetoriais funcionais e sua analogia com vetores ortogonais.",
                                    "Discuta a base ortonormal e sua importância para representações únicas de funções.",
                                    "Calcule exemplos simples com funções como senos e cossenos no intervalo [-π, π].",
                                    "Visualize graficamente o conceito usando plots de funções sobrepostas."
                                  ],
                                  "verification": "Resolva exercícios onde calcula integrais de produtos de funções e confirma ortogonalidade; resultado deve ser zero para pares ortogonais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise de Sinais (ex: Oppenheim), calculadora gráfica ou software como MATLAB/Octave",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Sempre normalize o intervalo de integração para evitar erros de escala; use simetria das funções para simplificar cálculos.",
                                  "learningObjective": "Dominar a definição e propriedades básicas de ortogonalidade funcional.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com perpendicularidade geométrica sem contexto funcional.",
                                    "Esquecer de dividir pela norma ao normalizar funções.",
                                    "Ignorar o intervalo específico de integração."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar ortogonalidade de senoides de frequências diferentes",
                                  "subSteps": [
                                    "Derive a integral do produto sin(ω1 t) * sin(ω2 t) para ω1 ≠ ω2 sobre um período comum.",
                                    "Prove usando identidades trigonométricas: produto de senos vira soma de cossenos.",
                                    "Estenda para cos(ω1 t) * cos(ω2 t), sin(ω1 t) * cos(ω2 t) e mostre que todas são zero se frequências distintas.",
                                    "Calcule numericamente em software para frequências como 1 Hz e 2 Hz sobre [0, 2π].",
                                    "Discuta o papel do período comum (mínimo múltiplo comum das frequências)."
                                  ],
                                  "verification": "Compute pelo menos 3 pares de senoides diferentes e verifique que a integral é zero (tolerância < 1e-6).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python (SciPy para integrais numéricas)",
                                    "Tabelas de integrais trigonométricas"
                                  ],
                                  "tips": "Use a identidade prod-to-sum para evitar integrais complicadas; plot os produtos para ver 'cancelamentos'.",
                                  "learningObjective": "Provar matematicamente a ortogonalidade de senoides harmônicas distintas.",
                                  "commonMistakes": [
                                    "Usar frequências não inteiras múltiplas sem ajustar o intervalo.",
                                    "Confundir senoides de mesma frequência (ortogonais apenas com fase 90°).",
                                    "Erros em limites de integração finitos vs. infinitos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a análise harmônica e decomposição de sinais",
                                  "subSteps": [
                                    "Introduza a série de Fourier: decomposição de sinal periódico x(t) em soma de senoides ortogonais.",
                                    "Derive os coeficientes de Fourier usando ortogonalidade: a_k = (2/T) ∫ x(t) cos(kω0 t) dt.",
                                    "Explique como ortogonalidade garante unicidade e simplicidade na extração de componentes.",
                                    "Aplique a um sinal simples como onda quadrada: calcule primeiros harmônicos.",
                                    "Simule reconstrução parcial e total do sinal com 5-10 termos."
                                  ],
                                  "verification": "Decomponha uma onda quadrada em Fourier e reconstrua com erro < 5% usando primeiros 10 termos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para FFT e plots",
                                    "Exemplos de sinais periódicos de livros texto"
                                  ],
                                  "tips": "Comece com sinais pares/ímpares para simplificar (só cossenos ou senos); use FFT para validação rápida.",
                                  "learningObjective": "Entender como ortogonalidade habilita a análise harmônica para decomposição.",
                                  "commonMistakes": [
                                    "Esquecer fator de normalização nos coeficientes.",
                                    "Usar período errado levando a aliasing.",
                                    "Ignorar convergência lenta para sinais descontínuos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos na análise de sinais complexos",
                                  "subSteps": [
                                    "Analise um sinal real como vibração de asas aeronáuticas: identifique componentes harmônicos.",
                                    "Use DFT/FFT para decompor sinal ruidoso e isolar frequências dominantes.",
                                    "Discuta utilidade: detecção de falhas, filtragem, resposta em frequência.",
                                    "Compare sinal original vs. reconstruído para validar decomposição.",
                                    "Explore limitações: vazamento espectral e janelas."
                                  ],
                                  "verification": "Gere relatório com espectro de um sinal simulado, destacando 3 componentes principais e sua contribuição.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python (NumPy/SciPy/Matplotlib)",
                                    "Dados de vibração aeronáutica sample (online)"
                                  ],
                                  "tips": "Aplique janelas Hann para reduzir vazamento; foque em frequências físicas relevantes (ex: flutter).",
                                  "learningObjective": "Aplicar decomposição harmônica a sinais reais em contextos de engenharia.",
                                  "commonMistakes": [
                                    "Interpretar picos espúrios como harmônicos reais.",
                                    "Escala errada no eixo de frequência.",
                                    "Subestimar efeitos de ruído não estacionário."
                                  ]
                                }
                              ],
                              "practicalExample": "Decompor uma onda quadrada de período 1s (amplitude 1) em série de Fourier: calcule a0=0, an=0 (par), bn=4/(nπ) para n ímpares. Reconstrua com 5 termos e plote, mostrando convergência a overshoot de Gibbs.",
                              "finalVerifications": [
                                "Explicar verbalmente por que senoides de nf0 e mf0 (n≠m) são ortogonais.",
                                "Calcular corretamente coeficientes de Fourier para sinal dado.",
                                "Reconstruir sinal com <10% erro usando 10 harmônicos.",
                                "Identificar utilidade em análise de vibrações aeronáuticas.",
                                "Discutir limitações da decomposição (ex: não periódico).",
                                "Aplicar FFT a dados reais e interpretar espectro."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas provas de ortogonalidade (integral zero).",
                                "Correção nos cálculos de coeficientes Fourier.",
                                "Qualidade da reconstrução gráfica (visualmente fiel).",
                                "Explicação clara da utilidade em análise harmônica.",
                                "Identificação de erros comuns e limitações.",
                                "Aplicação contextual a engenharia aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e séries de Fourier.",
                                "Física: Ondas e vibrações harmônicas.",
                                "Processamento de Sinais: FFT e análise espectral.",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Computação: Algoritmos numéricos e programação científica."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, usada para decompor sinais de vibração de asas ou fuselagem em harmônicos, detectando modos de flutter ou fadiga, permitindo previsão de falhas e otimização de design via resposta em frequência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Função de Resposta em Frequência (FRF)",
                        "description": "Função H(jω) que caracteriza completamente o comportamento em frequência de sistemas lineares contínuos, obtida da função de transferência H(s) avaliada em s = jω, com ênfase em magnitude e fase.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Definição e obtenção da FRF",
                            "description": "Derivar H(jω) = H(s)|_{s=jω} a partir da função de transferência H(s), relacionando-a à transformada de Fourier da resposta ao impulso h(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Função de Transferência e Resposta ao Impulso",
                                  "subSteps": [
                                    "Defina função de transferência H(s) como a transformada de Laplace da resposta ao impulso h(t).",
                                    "Explique que H(s) = ∫ h(t) e^{-st} dt de 0 a ∞.",
                                    "Discuta propriedades de H(s) em sistemas lineares invariantes no tempo (LTI).",
                                    "Identifique h(t) como a saída para entrada δ(t).",
                                    "Esboce um diagrama de bloco simples de um sistema LTI."
                                  ],
                                  "verification": "Escreva definições precisas e esboce um diagrama correto sem erros.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Caderno para anotações",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre relacione H(s) com a resposta temporal h(t) para fixar o conceito.",
                                  "learningObjective": "Compreender a base conceitual de H(s) e h(t) em sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir H(s) com a resposta em frequência diretamente",
                                    "Ignorar condições iniciais nulas",
                                    "Esquecer que h(t) é causal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Transformada de Fourier e Substituição s = jω",
                                  "subSteps": [
                                    "Revise a transformada de Fourier de h(t): H(jω) = ∫ h(t) e^{-jωt} dt.",
                                    "Mostre que para sinais causais com h(t)=0 para t<0, H(jω) = H(s)|_{s=jω}.",
                                    "Explique o contorno de integração no plano s para justificar a substituição.",
                                    "Discuta convergência: região de convergência deve incluir o eixo imaginário.",
                                    "Calcule H(jω) para um exemplo simples como h(t) = e^{-at} u(t)."
                                  ],
                                  "verification": "Derive corretamente H(jω) para h(t) = e^{-at} u(t) e compare com H(s)|_{s=jω}.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Tabela de transformadas de Laplace/Fourier",
                                    "Software MATLAB ou Python (SymPy)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Visualize o plano complexo s: eixo real σ, imaginário ω; s=jω está na borda imaginária.",
                                  "learningObjective": "Estabelecer a equivalência matemática entre Laplace em jω e Fourier.",
                                  "commonMistakes": [
                                    "Aplicar Fourier sem verificar causalidade",
                                    "Confundir H(jω) com H(ω)",
                                    "Esquecer o fator u(t) para causalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar H(jω) a partir de H(s) para Sistemas Típicos",
                                  "subSteps": [
                                    "Dado H(s) = 1/(s + a), substitua s = jω para obter H(jω) = 1/(jω + a).",
                                    "Calcule magnitude |H(jω)| = 1/√(ω² + a²) e fase arg(H(jω)) = -atan(ω/a).",
                                    "Repita para H(s) = ω_n² / (s² + 2ζω_n s + ω_n²) (oscilador amortecido).",
                                    "Plote |H(jω)| e arg(H(jω)) vs. ω em escala log-log.",
                                    "Verifique simetria: H(-jω) = H*(jω) para sistemas reais."
                                  ],
                                  "verification": "Produza plots corretos de magnitude e fase para pelo menos dois sistemas.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "MATLAB ou Python (matplotlib, control library)",
                                    "Exemplos de H(s) impressos",
                                    "Gráficos semi-log pré-formatados"
                                  ],
                                  "tips": "Use jω = 0 + jω; rationalize o denominador para magnitude: |H(jω)| = num/|denom|.",
                                  "learningObjective": "Executar derivação analítica e computacional de FRF.",
                                  "commonMistakes": [
                                    "Erro em racionalização complexa",
                                    "Plotar fase sem unwrap",
                                    "Confundir ω_n com ω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar FRF com Análise Prática e Verificações",
                                  "subSteps": [
                                    "Simule resposta a senóide: y(t) ≈ |H(jω)| cos(ωt + φ) para entrada cos(ωt).",
                                    "Compare FRF obtida via substituição com FFT de h(t) simulada.",
                                    "Analise efeitos de polos/zeros no diagrama de Bode da FRF.",
                                    "Discuta limitações: validade para ω onde sistema é estável.",
                                    "Aplique a um caso aeronáutico simples, como flutter."
                                  ],
                                  "verification": "Simulação numérica coincide com analítica dentro de 5% de erro.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "MATLAB Simulink ou Python (scipy.signal)",
                                    "Dados de exemplo de sistemas aeronáuticos"
                                  ],
                                  "tips": "Para FFT, use jω correspondente a bins de frequência discretos.",
                                  "learningObjective": "Integrar teoria com prática numérica para validação de FRF.",
                                  "commonMistakes": [
                                    "Não normalizar FFT corretamente",
                                    "Ignorar aliasing em simulações",
                                    "Aplicar FRF fora da faixa linear"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um modelo de ala de aeronave simplificado com H(s) = 10 / (s² + 0.2s + 10), derive H(jω): H(jω) = 10 / (-ω² + 0.2jω + 10). Calcule |H(jω)| em ω=1 rad/s (≈1.41) e fase (≈ -5.7°). Simule h(t) via ifft(fft) e verifique via substituição.",
                              "finalVerifications": [
                                "Deriva H(jω) corretamente para 3 H(s) dados sem erros algébricos.",
                                "Plota Bode correto com magnitude em dB e fase em graus.",
                                "Relaciona H(jω) = Fourier{h(t)} numericamente com erro <2%.",
                                "Explica impacto de um polo no eixo imaginário na FRF.",
                                "Identifica faixa de ω válida para análise linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correto).",
                                "Qualidade dos plots (escalas adequadas, legendas).",
                                "Compreensão conceitual via explicação oral/escrita.",
                                "Validação numérica consistente com teoria.",
                                "Aplicação contextual a engenharia aeronáutica.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e integrais de contorno.",
                                "Física: Dinâmica de vibrações e osciladores harmônicos.",
                                "Computação: Processamento de sinais digitais (FFT).",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Controle: Diagrama de Bode para estabilidade."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a FRF é essencial para análise de flutter e fadiga em asas, onde se mede vibrações senoidais em túneis de vento para derivar H(jω) e prever ressonâncias críticas que poderiam causar falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Análise de magnitude e fase da FRF",
                            "description": "Calcular e interpretar |H(jω)| (ganho em dB) e arg{H(jω)} (fase em graus), identificando ressonâncias, atenuações e atrasos de fase em sistemas dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de magnitude e fase da FRF",
                                  "subSteps": [
                                    "Definir a Função de Resposta em Frequência (FRF) como H(jω) para sistemas lineares invariantes no tempo",
                                    "Explicar a magnitude |H(jω)| e sua representação em dB usando a fórmula 20 log₁₀(|H(jω)|)",
                                    "Descrever a fase arg{H(jω)} em graus e seu significado como atraso de fase",
                                    "Discutir a importância para identificação de ressonâncias, atenuações e estabilidade",
                                    "Revisar propriedades básicas como simetria e comportamento em baixas/altas frequências"
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando os conceitos e fórmulas principais",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Aulas gravadas sobre FRF",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre associe magnitude em dB a 'ganho' e fase a 'atraso temporal'; pratique conversões lineares para dB",
                                  "learningObjective": "Dominar definições, fórmulas e unidades de magnitude e fase da FRF",
                                  "commonMistakes": [
                                    "Confundir magnitude linear com dB",
                                    "Esquecer o fator 20 em dB para tensão",
                                    "Ignorar o sinal jω na notação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular magnitude e fase para funções de transferência simples",
                                  "subSteps": [
                                    "Escrever funções de transferência de 1ª ordem: H(s) = 1/(τs + 1)",
                                    "Calcular |H(jω)| = 1/√(1 + (ωτ)²) e arg = -atan(ωτ)",
                                    "Converter magnitude para dB e fase para graus",
                                    "Repetir para 2ª ordem: H(s) = ωₙ²/(s² + 2ζωₙ s + ωₙ²)",
                                    "Calcular para frequências específicas (ex: ω = 0, ωₙ, ∞)"
                                  ],
                                  "verification": "Resolver 5 exercícios numéricos e comparar resultados com software (MATLAB/Python)",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de exercícios resolvidos",
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Use aproximações para baixas/altas frequências: |H| ≈1 (baixa), 1/ω (alta); fase de 0° a -90° para 1ª ordem",
                                  "learningObjective": "Realizar cálculos analíticos precisos de |H(jω)| e arg{H(jω)}",
                                  "commonMistakes": [
                                    "Erro no módulo complexo √(a² + b²)",
                                    "Confundir ζ com ωₙ nos cálculos",
                                    "Esquecer conversão radianos-graus"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e interpretar diagramas de Bode (magnitude e fase)",
                                  "subSteps": [
                                    "Plotar gráfico de magnitude em dB vs log(ω)",
                                    "Plotar gráfico de fase em graus vs log(ω)",
                                    "Identificar cortes de -3dB, -40dB/década e picos de ressonância",
                                    "Analisar largura de banda e frequência de ressonância",
                                    "Usar software para gerar Bode de sistemas conhecidos"
                                  ],
                                  "verification": "Gerar e rotular diagramas de Bode para 3 sistemas diferentes",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB (bode()) ou Python (control library)",
                                    "Templates de gráficos",
                                    "Exemplos de sistemas aeronáuticos"
                                  ],
                                  "tips": "Assintotas: retas com inclinação -20dB/déc por polo; verifique interseções em ω_c",
                                  "learningObjective": "Visualizar e gerar representações gráficas da FRF",
                                  "commonMistakes": [
                                    "Escala errada (log vs linear)",
                                    "Ignorar fase contínua em 360°",
                                    "Confundir ressonância com corte"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar características da FRF em sistemas dinâmicos",
                                  "subSteps": [
                                    "Identificar ressonância: pico em |H| próximo a ωₙ para ζ < 0.707",
                                    "Detectar atenuações: quedas acentuadas em altas frequências",
                                    "Analisar atrasos de fase: cruzamento de -180° indicando instabilidade potencial",
                                    "Relacionar com resposta temporal (ex: overshoot via ζ)",
                                    "Aplicar a um caso real: FRF de estrutura aeronáutica"
                                  ],
                                  "verification": "Analisar FRF dada e listar 5 características chave com justificativa",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados experimentais de FRF (simulados)",
                                    "Referências de vibrações em aeronaves",
                                    "Ferramenta de plotagem"
                                  ],
                                  "tips": "Ressonância perigosa se Q = 1/(2ζ) > 10; verifique Nyquist para estabilidade",
                                  "learningObjective": "Interpretar FRF para diagnóstico de sistemas dinâmicos",
                                  "commonMistakes": [
                                    "Atribuir pico a ruído em vez de ressonância",
                                    "Ignorar efeitos não-lineares",
                                    "Confundir fase lead com lag"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um amortecedor de vibrações em hélice de aeronave modelado como H(s) = 100 / (s² + 10s + 1000). Calcule e plote Bode para ω de 1 a 100 rad/s. Identifique ressonância em ≈31.6 rad/s (≈5 Hz), atenuação -40dB/déc acima e fase atraso de 180° em altas frequências, prevendo risco de flutter.",
                              "finalVerifications": [
                                "Calcular corretamente |H(jω)| em dB e arg em graus para ω arbitrária",
                                "Plotar diagramas de Bode precisos com labels",
                                "Identificar frequência de ressonância e largura de banda",
                                "Explicar impacto de atraso de fase na estabilidade",
                                "Analisar FRF real e propor ajustes no sistema",
                                "Comparar resultados analíticos vs numéricos com erro <5%"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (>95% correto)",
                                "Qualidade dos gráficos (assintotas, labels, escalas)",
                                "Profundidade na interpretação (ressonância, atenuação, fase)",
                                "Uso correto de unidades e convenções (dB, graus, log ω)",
                                "Aplicação contextual a engenharia aeronáutica",
                                "Identificação de erros comuns e correções"
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Estabilidade via Nyquist/Bode",
                                "Vibrações e Aeroelasticidade: Análise de flutter",
                                "Processamento de Sinais: Filtragem e FFT experimental",
                                "Mecânica dos Fluidos: FRF em aerodinâmica",
                                "Programação: Simulações em MATLAB/Python"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a análise de magnitude e fase da FRF é essencial para testes de vibração em estruturas como asas e fuselagens, identificando ressonâncias que podem levar a fadiga ou flutter catastrófico, permitindo otimização de amortecedores e certificação de aeronaves (ex: FAA regulations)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Propriedades espectrais da FRF",
                            "description": "Relacionar a FRF com o espectro de frequência do sistema, incluindo simetria para sistemas reais (H(-jω) = H*(jω)) e estabilidade via localização de polos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender FRF e espectro de frequência",
                                  "subSteps": [
                                    "Definir FRF como H(jω) = Y(jω)/X(jω), onde Y e X são espectros de saída e entrada.",
                                    "Explicar o espectro de frequência como a representação do sinal no domínio angular jω.",
                                    "Relacionar FRF à transformada de Fourier da resposta ao impulso h(t).",
                                    "Discutir magnitude |H(jω)| e fase ∠H(jω) como componentes espectrais.",
                                    "Visualizar FRF em gráficos de Bode (magnitude e fase vs. ω)."
                                  ],
                                  "verification": "Desenhar e rotular um gráfico de Bode simples para um sistema massa-mola-amortecedor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas",
                                    "Software MATLAB ou Python com SciPy/NumPy"
                                  ],
                                  "tips": [
                                    "Use exemplos físicos simples para intuitar o conceito.",
                                    "Comece plotando funções conhecidas como 1/(jω)."
                                  ],
                                  "learningObjective": "Entender a relação fundamental entre FRF e o espectro de frequência de sistemas lineares invariantes no tempo.",
                                  "commonMistakes": [
                                    "Confundir FRF com função de transferência em s.",
                                    "Ignorar a dependência em ω."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar simetria espectral para sistemas reais",
                                  "subSteps": [
                                    "Derivar a propriedade H(-jω) = H*(jω) assumindo h(t) real.",
                                    "Demonstrar que |H(jω)| é função par e ∠H(jω) é ímpar.",
                                    "Verificar numericamente em um exemplo com função de transferência conhecida.",
                                    "Plotar FRF para ω positivo e negativo, confirmando simetria.",
                                    "Discutir implicações para medições experimentais (apenas ω > 0)."
                                  ],
                                  "verification": "Calcular e plotar H(jω) e H(-jω) para um filtro passa-baixa, confirmando conjugação complexa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou MATLAB Symbolic)",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": [
                                    "Lembre-se: coeficientes reais implicam simetria.",
                                    "Teste com ω = 0 e ω → ∞."
                                  ],
                                  "learningObjective": "Dominar a simetria da FRF para sistemas reais e suas consequências em magnitude e fase.",
                                  "commonMistakes": [
                                    "Esquecer o conjugado complexo (*).",
                                    "Aplicar simetria a sistemas não reais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar estabilidade com localização de polos",
                                  "subSteps": [
                                    "Revisar polos como raízes do denominador da função de transferência H(s).",
                                    "Avaliar FRF como H(s) com s = jω na contorno imaginário.",
                                    "Explicar estabilidade: todos polos no semiplano esquerdo (Re(p) < 0).",
                                    "Analisar picos na magnitude |H(jω)| perto de polos imaginários (ressonância).",
                                    "Usar diagrama de polo-zero para prever comportamento da FRF."
                                  ],
                                  "verification": "Identificar polos de H(s) = 1/(s² + 2s + 1) e confirmar estabilidade via FRF.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de controle (MATLAB Control System Toolbox)",
                                    "Tabelas de funções de transferência padrão"
                                  ],
                                  "tips": [
                                    "Plote o plano s junto com Bode para correlação visual.",
                                    "Considere amortecimento baixo para ressonâncias evidentes."
                                  ],
                                  "learningObjective": "Conectar localização de polos à estabilidade e características espectrais da FRF.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros.",
                                    "Ignorar multiplicidade de polos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar propriedades em análise completa",
                                  "subSteps": [
                                    "Combinar simetria e polos em um sistema aeronaútico exemplo.",
                                    "Simular FRF experimentalmente com sinal senoidal swept-sine.",
                                    "Interpretar assimetrias potenciais como indício de não-linearidades.",
                                    "Avaliar estabilidade via contorno de Nyquist derivado da FRF.",
                                    "Documentar relatório com plots e conclusões."
                                  ],
                                  "verification": "Gerar relatório resumindo simetria, polos e estabilidade para um caso simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador vibracional (ex: ANSYS ou Simulink)",
                                    "Templates de relatório LaTeX ou Word"
                                  ],
                                  "tips": [
                                    "Use dados reais de vibrações se disponível.",
                                    "Valide simetria em dados ruidosos com médias."
                                  ],
                                  "learningObjective": "Aplicar integralmente as propriedades espectrais da FRF em contextos reais.",
                                  "commonMistakes": [
                                    "Sobrepor ruído a efeitos físicos.",
                                    "Negligenciar faixa de frequência relevante."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de vibração de uma asa de aeronave, meça a FRF entre excitação no bordo de ataque e aceleração na ponta da asa. Verifique simetria nos dados coletados, localize polos próximos ao eixo imaginário indicando modos flutter potenciais, e confirme estabilidade estrutural antes da certificação de voo.",
                              "finalVerifications": [
                                "Explicar verbalmente H(-jω) = H*(jω) e suas implicações.",
                                "Plotar FRF simétrica corretamente para sistema real.",
                                "Identificar polos e classificar estabilidade de um H(s) dado.",
                                "Relacionar picos de ressonância a polos no plano s.",
                                "Simular e interpretar FRF em software para exemplo prático.",
                                "Discutir limitações da FRF em sistemas não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de simetria e polos.",
                                "Qualidade e correção dos gráficos de Bode e plano polo-zero.",
                                "Profundidade na interpretação de estabilidade e ressonâncias.",
                                "Uso eficaz de ferramentas computacionais.",
                                "Capacidade de conectar teoria a aplicações aeronáuticas.",
                                "Clareza no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa, transformadas de Fourier e funções analíticas.",
                                "Física: Dinâmica vibracional e teoria de controle.",
                                "Engenharia Mecânica: Análise modal e identificação de sistemas.",
                                "Processamento de Sinais: Espectro análise e filtros digitais.",
                                "Ciência de Computação: Simulações numéricas em MATLAB/Python."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, as propriedades espectrais da FRF são usadas em ground vibration tests (GVT) para detectar modos instáveis em asas e fuselagem, prevenindo flutter catastrófico e garantindo segurança em velocidades supersônicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Uso de Sinais Senoidais na Análise e Identificação",
                        "description": "Aplicação prática de excitações senoidais para medir e analisar a FRF experimentalmente, incluindo varredura de frequências e interpretação de diagramas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Procedimento de identificação via excitação senoidal",
                            "description": "Descrever o método de varredura sinusoidal (sine sweep) para aplicar entradas senoidais em diferentes frequências e medir entrada/saída para estimar H(jω).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação do setup experimental",
                                  "subSteps": [
                                    "Identificar o sistema a ser testado e seus pontos de entrada e saída.",
                                    "Conectar atuadores e sensores ao sistema dinâmico.",
                                    "Configurar o software de aquisição de dados (ex: LabVIEW ou MATLAB).",
                                    "Calibrar sensores e atuadores para garantir precisão.",
                                    "Definir faixa de frequências de interesse baseada no conhecimento prévio do sistema."
                                  ],
                                  "verification": "Verificar se todos os componentes estão conectados corretamente e respondem a comandos básicos sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Sistema dinâmico (ex: modelo de asa flexível)",
                                    "Atuador (shaker ou servo)",
                                    "Sensores (acelerômetros ou strain gauges)",
                                    "Computador com DAQ",
                                    "Cabos e interfaces"
                                  ],
                                  "tips": [
                                    "Teste conexões com sinal DC antes do sweep.",
                                    "Registre condições ambientais (temperatura, umidade)."
                                  ],
                                  "learningObjective": "Compreender a importância da preparação precisa para evitar ruídos e erros na identificação.",
                                  "commonMistakes": [
                                    "Conexões soltas causando ruído.",
                                    "Faixa de frequência inadequada.",
                                    "Falta de calibração de sensores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Geração do sinal de excitação senoidal (sine sweep)",
                                  "subSteps": [
                                    "Definir parâmetros do sweep: frequência inicial, final, taxa de varredura (ex: logarítmica).",
                                    "Gerar o sinal chirp senoidal no software (amplitude constante ou crescente).",
                                    "Ajustar amplitude para evitar saturação ou danos ao sistema.",
                                    "Pré-visualizar o sinal gerado em tempo real.",
                                    "Salvar o sinal de referência para processamento posterior."
                                  ],
                                  "verification": "Reproduzir o sinal em um osciloscópio e confirmar varredura suave sem distorções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de geração de sinais (MATLAB Signal Processing Toolbox)",
                                    "Interface DAQ (ex: NI USB-6001)"
                                  ],
                                  "tips": [
                                    "Use sweep logarítmico para sistemas com ressonâncias.",
                                    "Comece com baixa amplitude para testes iniciais."
                                  ],
                                  "learningObjective": "Dominar a criação de sinais senoidais varridos para excitação eficiente em banda larga.",
                                  "commonMistakes": [
                                    "Taxa de sweep muito rápida causando não-estacionariedade.",
                                    "Amplitude excessiva danificando o atuador.",
                                    "Sweep linear em vez de logarítmico para faixas amplas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação do sinal e aquisição de dados",
                                  "subSteps": [
                                    "Aplicar o sinal de excitação na entrada do sistema.",
                                    "Registrar simultaneamente sinais de entrada u(t) e saída y(t) em alta taxa de amostragem.",
                                    "Executar múltiplas repetições para média e redução de ruído.",
                                    "Monitorar em tempo real para detectar anomalias (ex: saturação).",
                                    "Salvar dados brutos em formato acessível (ex: .mat ou .csv)."
                                  ],
                                  "verification": "Plotar u(t) e y(t) e confirmar que y(t) apresenta transientes decaindo e regime permanente senoidal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "DAQ configurado",
                                    "Sistema preparado",
                                    "Software de aquisição"
                                  ],
                                  "tips": [
                                    "Use anti-aliasing filters na amostragem.",
                                    "Repita sweeps em direções opostas para cancelar não-linearidades."
                                  ],
                                  "learningObjective": "Executar experimentos controlados garantindo dados de qualidade para análise.",
                                  "commonMistakes": [
                                    "Taxa de amostragem insuficiente (Nyquist violado).",
                                    "Ruído não filtrado.",
                                    "Dados não sincronizados entre entrada e saída."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processamento dos sinais para estimar H(jω)",
                                  "subSteps": [
                                    "Aplicar janelas (ex: Hanning) nos sinais para reduzir vazamento espectral.",
                                    "Computar FFT de u(t) e y(t) para obter U(jω) e Y(jω).",
                                    "Calcular H(jω) = Y(jω)/U(jω) ponto a ponto.",
                                    "Calcular magnitude |H(jω)| e fase arg(H(jω)).",
                                    "Aplicar coerência γ²(ω) para validar qualidade da estimativa."
                                  ],
                                  "verification": "Plotar |H(jω)|, fase e coerência; coerência > 0.8 na faixa de interesse.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy/NumPy)",
                                    "Scripts de processamento FFT"
                                  ],
                                  "tips": [
                                    "Média de múltiplos sweeps melhora SNR.",
                                    "Remova transientes iniciais antes da FFT."
                                  ],
                                  "learningObjective": "Aplicar transformada de Fourier para extrair função de transferência a partir de dados experimentais.",
                                  "commonMistakes": [
                                    "Divisão por U(jω)≈0 perto de zeros.",
                                    "Falta de janelamento causando vazamento.",
                                    "Ignorar baixa coerência em regiões ruidosas."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e análise dos resultados",
                                  "subSteps": [
                                    "Comparar H(jω) estimada com modelo teórico ou simulação.",
                                    "Identificar picos ressonantes e estimar amortecimento.",
                                    "Realizar teste de simulação: aplicar H(jω) a u(t) e comparar com y(t) medida.",
                                    "Documentar relatório com gráficos e conclusões.",
                                    "Discutir limitações e melhorias futuras."
                                  ],
                                  "verification": "Erro de predição < 10% em simulação de validação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem e modelagem (MATLAB Simulink)"
                                  ],
                                  "tips": [
                                    "Use Nyquist plot para visualização alternativa.",
                                    "Compare com métodos alternativos como step response."
                                  ],
                                  "learningObjective": "Validar identificação e interpretar resultados fisicamente.",
                                  "commonMistakes": [
                                    "Sobreajuste a ruído.",
                                    "Ignorar faixa de validade da linearidade.",
                                    "Falta de comparação com benchmarks."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório de engenharia aeronáutica, aplique um sine sweep de 1 Hz a 500 Hz em um modelo de asa cantilever para identificar frequências de flexão e torção, medindo aceleração na ponta da asa como saída.",
                              "finalVerifications": [
                                "Bode plot de H(jω) mostra picos coerentes com modos conhecidos do sistema.",
                                "Coerência γ²(ω) > 0.9 na maior parte da faixa.",
                                "Simulação com H(jω) reproduz y(t) medida com erro RMS < 5%.",
                                "Fase unwrap correto sem saltos de 360°.",
                                "Identificação de pelo menos 2-3 polos dominantes.",
                                "Ausência de artefatos como harmônicos não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração do sweep e aquisição de dados limpos.",
                                "Correta implementação do processamento FFT e cálculo de H(jω).",
                                "Análise de coerência e rejeição de regiões inválidas.",
                                "Validação quantitativa e qualitativa dos resultados.",
                                "Relatório claro com interpretação física.",
                                "Eficiência temporal e ausência de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Processamento Digital de Sinais (FFT e janelamento).",
                                "Controle Automático (análise de estabilidade via FRF).",
                                "Dinâmica de Estruturas (modos e amortecimento).",
                                "Instrumentação e Medição (calibração de sensores).",
                                "Programação Numérica (MATLAB/Python para análise)."
                              ],
                              "realWorldApplication": "Testes de vibração em aeronaves durante certificação (ex: Boeing usa sine sweeps para detectar flutter em protótipos, evitando falhas catastróficas em voo)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2",
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Construção e interpretação de diagramas de Bode",
                            "description": "Gerar diagramas de Bode (magnitude e fase vs. log ω) a partir de medições senoidais e analisar estabilidade, largura de banda e picos de ressonância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados Senoidais",
                                  "subSteps": [
                                    "Selecionar o sistema físico ou simulado para análise (ex: circuito RLC ou modelo de controle).",
                                    "Aplicar sinais senoidais com frequências variando de 0.1ω_n a 10ω_n, registrando amplitude de saída e defasagem.",
                                    "Medir pelo menos 15-20 pontos de frequência em escala logarítmica para boa resolução.",
                                    "Registrar dados em tabela: frequência ω (rad/s), amplitude de entrada/saída (V_in, V_out), fase φ (graus).",
                                    "Normalizar amplitudes para ganho unitário em baixa frequência se aplicável."
                                  ],
                                  "verification": "Tabela de dados completa com pelo menos 15 pontos, sem valores ausentes ou inconsistentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Osciloscópio ou software de simulação (MATLAB/Simulink/Python), gerador de sinais senoidais, sistema físico ou modelo simulado."
                                  ],
                                  "tips": "Use frequências decimais (ex: 0.1, 0.2, 0.5, 1, 2, 5, 10 vezes ω_n) para capturar transições.",
                                  "learningObjective": "Compreender como sinais senoidais revelam a resposta em frequência do sistema.",
                                  "commonMistakes": [
                                    "Medir frequências lineares em vez de logarítmicas.",
                                    "Ignorar ruído nas medições de fase.",
                                    "Não registrar condições de entrada estável."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo de Magnitude e Fase Normalizadas",
                                  "subSteps": [
                                    "Calcular ganho de magnitude: |G(jω)| = V_out / V_in para cada ω.",
                                    "Converter para dB: 20 * log10(|G(jω)|).",
                                    "Calcular fase: φ(ω) = atan2(Im, Re) ou diretamente da defasagem medida, em graus.",
                                    "Preparar eixos logarítmicos: log10(ω) para abscissa.",
                                    "Verificar consistência: ganho ~0 dB em ω baixa para sistemas próprios."
                                  ],
                                  "verification": "Planilhas ou código com cálculos validados contra valores conhecidos (ex: filtro RC).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel, MATLAB, Python (NumPy/Matplotlib)."
                                  ],
                                  "tips": "Use funções log10 prontas para evitar erros de arredondamento.",
                                  "learningObjective": "Dominar fórmulas de conversão para representação logarítmica de Bode.",
                                  "commonMistakes": [
                                    "Confundir log10 com ln.",
                                    "Esquecer o fator 20 para dB.",
                                    "Não converter fase para graus corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção dos Diagramas de Bode",
                                  "subSteps": [
                                    "Plotar diagrama de magnitude: 20*log10(|G|) vs log10(ω), com escala semilogarítmica.",
                                    "Plotar diagrama de fase: φ(ω) vs log10(ω), mesma escala.",
                                    "Adicionar aproximações assintóticas: linhas de inclinação -20dB/década para polos, etc.",
                                    "Rotular eixos, gride, título e legenda claramente.",
                                    "Usar software para suavização se necessário, mas manter fidelidade aos dados."
                                  ],
                                  "verification": "Gráficos gerados com curvas suaves, assintóticas alinhadas e escalas log corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (bodeplot), Python (matplotlib.semilogx), ou papel milimetrado."
                                  ],
                                  "tips": "Inicie com plot manual para intuição antes de software.",
                                  "learningObjective": "Criar visualizações precisas de respostas em frequência.",
                                  "commonMistakes": [
                                    "Plotar em escala linear.",
                                    "Invertar eixos.",
                                    "Ignorar wrap-around na fase (adicionar 360° se necessário)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação e Análise dos Diagramas",
                                  "subSteps": [
                                    "Identificar largura de banda (BW): frequência onde |G| = -3dB.",
                                    "Localizar picos de ressonância: máximo local em magnitude e frequência correspondente.",
                                    "Avaliar estabilidade: margem de ganho (distância ao 0dB na freq de fase -180°), margem de fase.",
                                    "Comparar com modelo teórico (função de transferência aproximada).",
                                    "Documentar insights: ex: 'Sistema com Q=5, instável se ganho >1.2'."
                                  ],
                                  "verification": "Relatório escrito com valores numéricos extraídos (BW, Q, margins) e conclusões justificadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Gráficos de Bode gerados, régua/cursor digital para leituras precisas."
                                  ],
                                  "tips": "Use zoom em regiões críticas como cruzamento de -3dB ou -180°.",
                                  "learningObjective": "Extrair métricas chave de performance e estabilidade de diagramas de Bode.",
                                  "commonMistakes": [
                                    "Confundir BW com frequência de pico.",
                                    "Ignorar efeitos não-lineares.",
                                    "Margens calculadas incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Relatório Final",
                                  "subSteps": [
                                    "Simular diagrama teórico e comparar com experimental (erro <10%).",
                                    "Testar estabilidade com step response correlacionado.",
                                    "Preparar relatório: dados, gráficos, análises e recomendações.",
                                    "Apresentar oralmente ou em peer-review.",
                                    "Arquivar para uso futuro em projetos."
                                  ],
                                  "verification": "Relatório aprovado por professor/parceiro com discrepâncias <5%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação, template de relatório."
                                  ],
                                  "tips": "Inclua fotos de setup experimental para credibilidade.",
                                  "learningObjective": "Integrar análise de Bode em workflow de engenharia completo.",
                                  "commonMistakes": [
                                    "Não validar contra teoria.",
                                    "Relatório sem quantificação.",
                                    "Omitir limitações das medições."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flaps de aeronave, colete respostas senoidais em frequências de 0.1 a 10 rad/s. Construa Bode: magnitude cai -40dB/déc em alta freq (dois polos), pico ressonante a 2 rad/s indica Q=4. Margem de fase 60° confirma estabilidade; BW=1.5 rad/s define limite de comando.",
                              "finalVerifications": [
                                "Diagrama de magnitude com queda correta e -3dB point identificado.",
                                "Diagrama de fase contínuo, cruzando -180° após BW.",
                                "Largura de banda e pico de ressonância quantificados numericamente.",
                                "Margens de ganho e fase calculadas com precisão.",
                                "Comparação com modelo teórico mostra coerência.",
                                "Relatório resume insights acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos dados coletados e cálculos (erro <5%).",
                                "Qualidade visual e legibilidade dos diagramas.",
                                "Correção na identificação de BW, ressonância e estabilidade.",
                                "Profundidade da interpretação e conexões teóricas.",
                                "Clareza e completude do relatório.",
                                "Criatividade em validações adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos, funções complexas e transformadas de Fourier.",
                                "Programação: Scripts em Python/MATLAB para automação de plots.",
                                "Física: Dinâmica oscilatória e amortecimento em sistemas mecânicos.",
                                "Engenharia de Controle: Integração com Nyquist e root locus.",
                                "Estatística: Análise de incerteza em medições experimentais."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, diagramas de Bode são usados para tunar controladores de flight stability em aviões, garantindo resposta rápida sem oscilações (ex: autopilot da Boeing 787), identificando BW para manobras seguras e evitando ressonâncias em estruturas de asas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.2",
                              "10.1.1.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Sinais Periódicos e Séries de Fourier",
                    "description": "Análise de sinais contínuos periódicos por meio de séries de Fourier na identificação de sistemas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Sinais Periódicos Contínuos",
                        "description": "Definição formal de sinais contínuos periódicos, suas propriedades fundamentais como período, frequência fundamental e exemplos típicos utilizados em análise de sistemas dinâmicos lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar sinais periódicos contínuos",
                            "description": "Dado um sinal contínuo no tempo, determinar se é periódico, calcular o período fundamental T e a frequência fundamental ω₀ = 2π/T, considerando sinais como senoide pura, dente de serra e quadrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades de sinais periódicos contínuos",
                                  "subSteps": [
                                    "Estude a definição formal: um sinal x(t) é periódico se existe T > 0 tal que x(t + T) = x(t) para todo t.",
                                    "Aprenda que T é o período fundamental se nenhum menor T satisfaz a condição.",
                                    "Revise propriedades: soma de periódicos com T comum é periódico; frequência fundamental f₀ = 1/T, ω₀ = 2π/T.",
                                    "Diferencie de aperiódicos: exemplo, sinal exponencial crescente não repete.",
                                    "Pratique identificando se uma função genérica como x(t) = sin(ωt) + cos(2ωt) é periódica."
                                  ],
                                  "verification": "Escreva a definição de sinal periódico e dê um exemplo de sinal aperiódico, explicando por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas",
                                    "Papel e caneta",
                                    "Gráficos de exemplo online"
                                  ],
                                  "tips": "Sempre verifique a menor T positiva; visualize o gráfico para intuição.",
                                  "learningObjective": "Definir precisamente sinal periódico contínuo e suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir com quasi-periódico",
                                    "Ignorar que T deve ser o menor possível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar periodicidade visualmente e analiticamente em sinais contínuos",
                                  "subSteps": [
                                    "Plote o sinal no tempo e observe repetições visuais do padrão.",
                                    "Para senoides puras x(t) = A sin(ωt + φ), confirme x(t + T) = x(t) com T = 2π/ω.",
                                    "Analise dente de serra: rampa linear que reseta, meça distância entre resets.",
                                    "Para onda quadrada: meça tempo de um ciclo completo (alta + baixa).",
                                    "Teste analiticamente: substitua t + T na equação e resolva para T."
                                  ],
                                  "verification": "Dado um gráfico de sinal desconhecido, marque o período T visualmente e justifique.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB/Octave ou Desmos",
                                    "Exemplos de gráficos impressos"
                                  ],
                                  "tips": "Use zoom no gráfico para precisão; conte zeros ou picos para estimar T.",
                                  "learningObjective": "Reconhecer padrões periódicos em representações gráficas e equações.",
                                  "commonMistakes": [
                                    "Confundir harmônicos com período fundamental",
                                    "Medir apenas meia-onda em senoides"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o período fundamental T para sinais específicos",
                                  "subSteps": [
                                    "Para senoide pura: T = 2π / |ω| a partir da forma x(t) = sin(ωt).",
                                    "Dente de serra x(t) = {t - floor(t/T)*T}: T é o parâmetro dado ou medido entre resets.",
                                    "Onda quadrada: T = tempo de ciclo, frequentemente T = 2π / ω para fundamental.",
                                    "Sinais compostos: encontre T comum, o mínimo múltiplo comum dos Ts individuais.",
                                    "Verifique calculando x(t + T) == x(t) numericamente em pontos chave."
                                  ],
                                  "verification": "Calcule T para x(t) = sawtooth(2π t / 4) e confirme com plotagem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Python/MATLAB para simulação",
                                    "Tabelas de formas de onda"
                                  ],
                                  "tips": "Para compostos, liste Ts de cada componente e ache MMC.",
                                  "learningObjective": "Determinar T fundamental com precisão para senoides, dente de serra e quadrada.",
                                  "commonMistakes": [
                                    "Usar ω em vez de 2π/ω",
                                    "Não reduzir a fração para menor T"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a frequência fundamental ω₀ e validar a identificação",
                                  "subSteps": [
                                    "Calcule ω₀ = 2π / T uma vez T determinado.",
                                    "Para validação, expresse o sinal em termos de ω₀: senoides harmônicos são k ω₀.",
                                    "Simule ou plote para T calculado e confirme repetição exata.",
                                    "Compare com aperiódicos: ex. x(t) = t sin(t), T não existe finito.",
                                    "Documente processo: gráfico, equação, cálculos e conclusão."
                                  ],
                                  "verification": "Dado x(t), calcule T e ω₀, plote 3 períodos e anote valores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação",
                                    "Folha de verificação",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Sempre una decimal para T e ω₀; verifique unidades (T em segundos).",
                                  "learningObjective": "Computar ω₀ corretamente e validar periodicidade completa.",
                                  "commonMistakes": [
                                    "Esquecer o 2π em ω₀",
                                    "Confundir f₀ (Hz) com ω₀ (rad/s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sinal dente de serra x(t) = t - 2 floor((t+1)/2) para -1 < t ≤ 1, repetido. Visualmente, repete a cada 2s (T=2s). Analiticamente, reseta a cada 2 unidades. ω₀ = 2π/2 = π rad/s. Plote em [0,6]s para confirmar 3 ciclos exatos.",
                              "finalVerifications": [
                                "Define corretamente sinal periódico e distingue de aperiódico.",
                                "Identifica T visualmente em gráficos de senoide, dente de serra e quadrada.",
                                "Calcula T fundamental para sinal composto com harmônicos.",
                                "Computa ω₀ = 2π/T com precisão numérica.",
                                "Valida com plotagem ou substituição equacional.",
                                "Explica processo em relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de T (erro <1%).",
                                "Correta identificação visual e analítica de periodicidade.",
                                "Uso apropriado de ω₀ em contexto angular.",
                                "Validação robusta com múltiplos métodos.",
                                "Clareza na documentação e explicação.",
                                "Tratamento correto de casos edge (ex. T não óbvio)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas e análise periódica.",
                                "Física: Ondas e vibrações em sistemas mecânicos.",
                                "Engenharia de Controle: Análise de sistemas dinâmicos em aeronáutica.",
                                "Processamento de Sinais: Pré-processamento para Fourier.",
                                "Informática: Simulação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, identificar periodicidade em sinais de vibração de asas ou motores permite análise de Fourier para detecção de falhas, balanceamento dinâmico e controle de estabilidade em voo, prevenindo ressonâncias catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Classificar propriedades de periodicidade",
                            "description": "Analisar propriedades como simetria par/ímpar, meia-onda e quarto de onda em sinais periódicos, e verificar se um sinal composto de harmônicos é periódico com período fundamental comum.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Sinais Periódicos",
                                  "subSteps": [
                                    "Defina sinal periódico e período fundamental T.",
                                    "Identifique exemplos clássicos: seno, cosseno, onda quadrada.",
                                    "Calcule o período para funções dadas como x(t) = sin(2πt/T).",
                                    "Diferencie sinais periódicos de aperiódicos.",
                                    "Grafique um sinal periódico simples usando software."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o período fundamental em um gráfico de sinal periódico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas, MATLAB ou Python (Matplotlib), papel e lápis.",
                                  "tips": "Sempre normalize o tempo pelo período para simplificar análise.",
                                  "learningObjective": "Compreender a definição e representação gráfica de sinais periódicos.",
                                  "commonMistakes": "Confundir período com frequência angular ω = 2π/T."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Simetria Par e Ímpar",
                                  "subSteps": [
                                    "Defina simetria par: x(-t) = x(t), exemplo cosseno.",
                                    "Defina simetria ímpar: x(-t) = -x(t), exemplo seno.",
                                    "Verifique simetria deslocando o sinal para t=0.",
                                    "Classifique sinais mistos decompondo em componentes par/ímpar.",
                                    "Use integral para confirmar: ∫x(t)dt de -T/2 a T/2 = 0 para ímpar."
                                  ],
                                  "verification": "Classifique corretamente x(t) = sin(t) + cos(t) como misto e justifique.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (MATLAB/Octave), exemplos de sinais impressos.",
                                  "tips": "Plote x(t) e x(-t) no mesmo gráfico para visualização rápida.",
                                  "learningObjective": "Identificar e classificar simetria par/ímpar em sinais periódicos.",
                                  "commonMistakes": "Esquecer de centralizar o sinal em t=0 antes da verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Simetria Meia-Onda e Quarto de Onda",
                                  "subSteps": [
                                    "Defina meia-onda: x(t + T/2) = -x(t), comum em ondas quadradas.",
                                    "Defina quarto de onda: x(t + T/4) = -x(t), para certas simetrias.",
                                    "Verifique graficamente sobrepondo x(t) e x(t + T/2).",
                                    "Calcule coeficientes de Fourier para validar propriedades.",
                                    "Exercite com exemplos: onda triangular e dente de serra."
                                  ],
                                  "verification": "Demonstre que uma onda quadrada tem simetria meia-onda via gráfico ou equação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de simulação (Scilab ou Python), tabelas de Fourier.",
                                  "tips": "Use transformada de Fourier para confirmar: só harmônicos ímpares em meia-onda.",
                                  "learningObjective": "Aplicar testes de simetria meia e quarto de onda.",
                                  "commonMistakes": "Confundir com simetria par/ímpar sem verificar deslocamento específico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Periodicidade em Sinais Compostos de Harmônicos",
                                  "subSteps": [
                                    "Lembre que sinal x(t) = Σ a_k cos(2π k f0 t + φ_k) é periódico com T=1/f0 se f0 comum.",
                                    "Identifique período fundamental como mínimo T tal que todos harmônicos compartilhem.",
                                    "Teste se razões de frequências são racionais: f_k = k f0.",
                                    "Para sinal arbitrário, encontre T como MMC dos períodos individuais.",
                                    "Simule e plote sinal composto para validar periodicidade."
                                  ],
                                  "verification": "Para x(t) = sin(2π t) + sin(4π t/3), determine se é periódico e ache T.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "MATLAB/Python para síntese de sinais, calculadora para MMC.",
                                  "tips": "Verifique se todas frequências são múltiplos inteiros de uma fundamental.",
                                  "learningObjective": "Determinar periodicidade e período fundamental em somas de harmônicos.",
                                  "commonMistakes": "Assumir periodicidade sem verificar razões racionais de frequências."
                                }
                              ],
                              "practicalExample": "Analise o sinal x(t) = cos(2π t) + 0.5 sin(4π t). Classifique: par dominante (cosseno par, seno ímpar mas múltiplo), sem meia-onda (x(t+T/2) ≠ -x(t)), periódico com T=1 pois harmônicos 1 e 2 de f0=1 Hz.",
                              "finalVerifications": [
                                "Classifique corretamente simetria par/ímpar em 3 sinais dados.",
                                "Identifique meia-onda em onda quadrada via gráfico.",
                                "Determine período fundamental de soma de 4 harmônicos.",
                                "Explique por que sin(2π t) + sin(√2 π t) é aperiódico.",
                                "Calcule e plote um sinal com quarto de onda simetria.",
                                "Verifique propriedades usando coeficientes de Fourier."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de simetrias (par/ímpar, meia/quarto onda).",
                                "Correta identificação de período fundamental em compostos.",
                                "Justificativa matemática ou gráfica clara.",
                                "Uso adequado de ferramentas de plotagem/simulação.",
                                "Detecção de erros em casos limite (aperiódicos).",
                                "Aplicação consistente das definições teóricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e análise harmônica.",
                                "Física: Ondas e vibrações em estruturas aeronáuticas.",
                                "Engenharia de Controle: Análise de sistemas dinâmicos.",
                                "Processamento de Sinais: Filtros e detecção de periodicidade."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, classificar periodicidade de sinais de vibração em asas ou fuselagem permite detectar falhas estruturais via análise de harmônicos em séries de Fourier, otimizando manutenção preditiva em aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Gerar exemplos de sinais periódicos",
                            "description": "Construir e plotar sinais periódicos contínuos comuns em sistemas dinâmicos, como ondas quadradas, triangulares e impulsos periódicos, usando expressões matemáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de sinais periódicos contínuos",
                                  "subSteps": [
                                    "Defina sinal periódico: função x(t) tal que x(t + T) = x(t) para todo t, onde T é o período fundamental.",
                                    "Identifique propriedades chave: frequência fundamental f = 1/T, período angular ω = 2π/T.",
                                    "Classifique sinais comuns: onda quadrada (discontinuidade em transições), triangular (linear entre picos), impulso periódico (trens de Dirac).",
                                    "Revise expressões básicas: para senoide x(t) = A sin(ωt + φ).",
                                    "Calcule manualmente um período de cada sinal em papel."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e propriedades, com exemplos numéricos para T=2π.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim)"
                                  ],
                                  "tips": "Use diagramas para visualizar a repetição periódica; foque em simetria par/ímpar.",
                                  "learningObjective": "Dominar definições e propriedades matemáticas de sinais periódicos contínuos.",
                                  "commonMistakes": [
                                    "Confundir período com frequência",
                                    "Ignorar fase inicial φ nas expressões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar expressões matemáticas para sinais específicos",
                                  "subSteps": [
                                    "Onda quadrada: x(t) = A * sgn(sin(ωt)) para amplitude A e ω=2π/T.",
                                    "Onda triangular: x(t) = (2A/π) * asin(sin(ωt)) ou peça-wise linear: suba de -A a A em T/4, desça em T/4, etc.",
                                    "Impulso periódico: soma de deltas δ(t - nT), aproximado por funções estreitas como exp(-t²/(2σ²)) em nT.",
                                    "Escreva as três expressões explicitamente para T=1s, A=1.",
                                    "Verifique periodicidade calculando x(t+T) = x(t) analiticamente."
                                  ],
                                  "verification": "Escreva as fórmulas corretas em um documento e comprove periodicidade para t=0 e t=T/2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha)",
                                    "Folha de fórmulas de referência"
                                  ],
                                  "tips": "Comece com senoide e modifique; use gráficos mentais para validar.",
                                  "learningObjective": "Construir expressões precisas para ondas quadrada, triangular e impulsos periódicos.",
                                  "commonMistakes": [
                                    "Fórmulas erradas para triangular (não usar seno simples)",
                                    "Esquecer normalização de amplitude"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar geração dos sinais em software de plotagem",
                                  "subSteps": [
                                    "Configure ambiente: Python com NumPy e Matplotlib, ou MATLAB.",
                                    "Gere tempo t = linspace(0, 4*T, 1000) para múltiplos períodos.",
                                    "Code para quadrada: x_sq = A * np.sign(np.sin(2*np.pi*t/T)).",
                                    "Code para triangular: usar np.abs(((t % T)/T - 0.5)*4 -1)*A ajustado.",
                                    "Code para impulso: soma de Gaussians centradas em nT com σ pequeno.",
                                    "Salve scripts em arquivos .py ou .m."
                                  ],
                                  "verification": "Execute código e confirme ausência de erros de sintaxe; visualize preview rápido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook ou MATLAB",
                                    "Bibliotecas: numpy, matplotlib"
                                  ],
                                  "tips": "Use %T para wrap-around no tempo; teste com T=1, A=1 primeiro.",
                                  "learningObjective": "Programar funções matemáticas para gerar sinais periódicos numericamente.",
                                  "commonMistakes": [
                                    "Resolução baixa causando aliasing",
                                    "np.sign em zeros dando NaN sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar, analisar e validar os sinais gerados",
                                  "subSteps": [
                                    "Plote cada sinal: plt.plot(t, x); xlabel('Tempo (s)'); title('Onda Quadrada').",
                                    "Adicione grid, limites de eixo para 3-4 períodos, legenda.",
                                    "Meça período visualmente e numericamente (pico a pico).",
                                    "Compare com expressões teóricas: zoom em uma transição.",
                                    "Exporte plots como PNG e anote propriedades observadas."
                                  ],
                                  "verification": "Plots mostram repetição exata a cada T, com formas corretas; inclua captura de tela com medições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo ambiente de programação",
                                    "Visualizador de imagens"
                                  ],
                                  "tips": "Use subplot(3,1,n) para comparar os três sinais lado a lado.",
                                  "learningObjective": "Visualizar e validar sinais periódicos via plotagem computacional.",
                                  "commonMistakes": [
                                    "Escala errada ocultando discontinuidades",
                                    "Não plotar tempo suficiente para periodicidade clara"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere uma onda quadrada com T=2s, A=5V usando Python: t = np.linspace(0, 8, 2000); x = 5 * np.sign(np.sin(2*np.pi*t/2)); plote de 0 a 8s mostrando 4 períodos perfeitamente repetidos, com transições nítidas em 0,1,2,...s.",
                              "finalVerifications": [
                                "Todos os plots exibem periodicidade exata com período T especificado.",
                                "Formas dos sinais (quadrada: ±A alternado; triangular: rampa linear; impulso: picos estreitos) são precisas.",
                                "Código roda sem erros e é reproduzível por outros.",
                                "Medições manuais de período/frequência batem com parâmetros.",
                                "Análise inclui pelo menos uma propriedade (ex: duty cycle 50% na quadrada)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expressões matemáticas (100% corretas).",
                                "Qualidade dos plots: resolução alta, labels completos, múltiplos períodos visíveis (nota 1-5).",
                                "Funcionalidade do código: executável, eficiente, comentado.",
                                "Validação: verificações numéricas e visuais coerentes.",
                                "Criatividade: inclusão de variações como mudança de fase ou duty cycle.",
                                "Documentação: relatório com fórmulas, código e plots explicados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier para decomposição harmônica destes sinais.",
                                "Física: Vibrações em estruturas aeronáuticas (ex: asas oscilantes como triangulares).",
                                "Programação: NumPy/MATLAB para processamento numérico em engenharia.",
                                "Controle de Sistemas: Entradas periódicas em laços de feedback.",
                                "Estatística: Análise espectral via FFT destes sinais."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, gerar impulsos periódicos simula excitações de turbulência para testes de fadiga em asas; ondas quadradas modelam comandos de controle digital em atuadores de flaps; triangulares aproximam perfis de aceleração em manobras, permitindo identificação de sistemas dinâmicos via análise de resposta."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Expansão em Série de Fourier",
                        "description": "Representação de sinais periódicos contínuos como soma infinita de componentes harmônicos via série trigonométrica e exponencial de Fourier, incluindo cálculo de coeficientes.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Calcular coeficientes da série trigonométrica",
                            "description": "Computar os coeficientes a₀, aₙ e bₙ para um sinal periódico f(t) dado no intervalo [-T/2, T/2], aplicando integrais definidas ∫ f(t) cos(nω₀t) dt e ∫ f(t) sin(nω₀t) dt.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar parâmetros do sinal periódico",
                                  "subSteps": [
                                    "Determine o período T do sinal f(t).",
                                    "Calcule a frequência fundamental ω₀ = 2π/T.",
                                    "Confirme o intervalo de integração [-T/2, T/2].",
                                    "Esboce ou descreva graficamente f(t) no intervalo para visualização.",
                                    "Verifique se f(t) é par, ímpar ou geral para simplificações futuras."
                                  ],
                                  "verification": "Lista de parâmetros (T, ω₀, intervalo) anotada corretamente e gráfico esboçado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Sempre normalize o intervalo para evitar erros de limites nas integrais.",
                                  "learningObjective": "Compreender e extrair corretamente os parâmetros fundamentais do sinal periódico.",
                                  "commonMistakes": [
                                    "Confundir T com o intervalo total (deve ser o período completo)",
                                    "Erro no cálculo de ω₀ (lembre: 2π/T, não π/T)",
                                    "Ignorar simetrias par/ímpar que simplificam cálculos posteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o coeficiente a₀ (termo constante)",
                                  "subSteps": [
                                    "Escreva a fórmula: a₀ = (1/T) ∫_{-T/2}^{T/2} f(t) dt.",
                                    "Identifique f(t) e substitua na integral.",
                                    "Resolva a integral definida passo a passo.",
                                    "Divida pelo T e simplifique o resultado.",
                                    "Interprete: a₀ representa a média do sinal ao longo de um período."
                                  ],
                                  "verification": "Valor de a₀ calculado numericamente ou analiticamente e comparado com a média gráfica de f(t).",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Tabelas de integrais",
                                    "Software simbólico como Wolfram Alpha (opcional)"
                                  ],
                                  "tips": "Para funções pares/ímpares, verifique se a integral é zero ou simplificada.",
                                  "learningObjective": "Dominar o cálculo do termo DC (corrente contínua) da série de Fourier.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/T",
                                    "Limites incorretos na integral",
                                    "Não simplificar frações ou expressões trigonométricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os coeficientes aₙ (componentes cosseno)",
                                  "subSteps": [
                                    "Escreva a fórmula para n=1,2,...: aₙ = (2/T) ∫_{-T/2}^{T/2} f(t) cos(n ω₀ t) dt.",
                                    "Escolha valores específicos de n (ex: 1,2,3) e substitua.",
                                    "Compute a integral produto f(t) * cos(n ω₀ t).",
                                    "Aplique o fator 2/T e simplifique.",
                                    "Calcule para pelo menos 3 valores de n e tabule os resultados."
                                  ],
                                  "verification": "Tabela com a₁, a₂, a₃ corretos, verificados por substituição numérica em pontos conhecidos.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabelas de integrais indefinidas",
                                    "Python/MATLAB para verificação numérica (opcional)"
                                  ],
                                  "tips": "Use propriedades de ortogonalidade: para funções ímpares, aₙ=0.",
                                  "learningObjective": "Aplicar integrais com funções cosseno para extrair amplitudes harmônicas pares.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2/T (diferente de a₀)",
                                    "Erro no argumento do cosseno (n ω₀ t)",
                                    "Não expandir produtos trigonométricos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os coeficientes bₙ (componentes seno)",
                                  "subSteps": [
                                    "Escreva a fórmula para n=1,2,...: bₙ = (2/T) ∫_{-T/2}^{T/2} f(t) sin(n ω₀ t) dt.",
                                    "Substitua f(t) e escolha n=1,2,3.",
                                    "Resolva a integral do produto f(t) * sin(n ω₀ t).",
                                    "Multiplique por 2/T e simplifique.",
                                    "Tabule b₁, b₂, b₃ e compare com simetrias (bₙ=0 para funções pares)."
                                  ],
                                  "verification": "Tabela de bₙ correta, com soma de série parcial aproximando f(t) em t=0 ou outro ponto.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folhas de rascunho",
                                    "Software de plotagem para verificação (opcional)"
                                  ],
                                  "tips": "Seno é ímpar, então integra bem com funções pares em alguns casos.",
                                  "learningObjective": "Extrair componentes seno da decomposição harmônica.",
                                  "commonMistakes": [
                                    "Confundir sinal com cosseno (fases erradas)",
                                    "Fator 2/T omitido",
                                    "Erros em integrais por partes para polinômios * seno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e montar a série trigonométrica",
                                  "subSteps": [
                                    "Escreva a série: f(t) ≈ a₀/2 + Σ [aₙ cos(n ω₀ t) + bₙ sin(n ω₀ t)].",
                                    "Calcule aproximações parciais (N=1, N=3) em pontos chave de f(t).",
                                    "Compare com f(t) original (erro <5% em pontos testados).",
                                    "Plote ou esboce as aproximações parciais.",
                                    "Discuta convergência e truncamento."
                                  ],
                                  "verification": "Gráficos ou tabela mostrando convergência da série para f(t).",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Gráficos manuais ou software como Desmos/Python",
                                    "Tabela de valores"
                                  ],
                                  "tips": "Comece com poucos harmônicos para ver Gibbs phenomenon.",
                                  "learningObjective": "Verificar a precisão da expansão de Fourier e interpretar resultados.",
                                  "commonMistakes": [
                                    "Esquecer /2 no a₀",
                                    "Índices errados na soma",
                                    "Não testar em múltiplos pontos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(t) = t no intervalo [-π, π] (T=2π, ω₀=1): a₀=0 (ímpar), aₙ=0 (ímpar), bₙ = (2(-1)^{n+1})/n. Ex: b₁=2, b₂=-1, b₃=2/3. Série: 2(sin t - sin(2t)/2 + sin(3t)/3 - ...). Verifique em t=π/2: soma parcial ≈1.57.",
                              "finalVerifications": [
                                "a₀ correto como média de f(t).",
                                "aₙ e bₙ corretos para n=1 a 3, com erro <1% em cálculo numérico.",
                                "Série parcial reconstrói f(t) com erro médio <5% em 5 pontos.",
                                "Simetrias par/ímpar aplicadas corretamente (zeros onde aplicável).",
                                "Unidades consistentes e ω₀ preciso.",
                                "Gráfico da aproximação vs. original converge."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais (sem erros algébricos).",
                                "Correta aplicação de fatores normalizadores (1/T, 2/T).",
                                "Uso apropriado de simetrias para simplificação.",
                                "Validação quantitativa da série (erros calculados).",
                                "Interpretação física dos coeficientes (amplitudes harmônicas).",
                                "Clareza na documentação e tabulação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decomposição de vibrações em modos normais em estruturas aeronáuticas.",
                                "Programação: Implementação numérica via FFT em Python/MATLAB para sinais reais.",
                                "Engenharia de Controle: Análise de resposta em frequência de sistemas dinâmicos.",
                                "Processamento de Sinais: Filtragem harmônica em dados de sensores.",
                                "Cálculo Avançado: Prática de integrais definidas e séries infinitas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, calcular coeficientes de Fourier permite decompor sinais de vibração de asas ou fuselagem em harmônicos, identificando frequências ressonantes para prevenir fadiga estrutural e otimizar design de sistemas de controle ativo de vibrações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Aplicar série exponencial de Fourier",
                            "description": "Determinar os coeficientes complexos cₙ = (1/T) ∫ f(t) e^{-jnω₀t} dt e reconstruir o sinal como f(t) = Σ cₙ e^{jnω₀t}, relacionando com a forma trigonométrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar parâmetros fundamentais do sinal periódico",
                                  "subSteps": [
                                    "Determinar o período fundamental T do sinal f(t).",
                                    "Calcular a frequência angular fundamental ω₀ = 2π/T.",
                                    "Verificar se o sinal é periódico e definir o intervalo de integração [0, T] ou [-T/2, T/2].",
                                    "Esboçar o sinal para visualizar harmônicos.",
                                    "Identificar simetrias (par, ímpar) que simplificam cálculos."
                                  ],
                                  "verification": "Lista de parâmetros (T, ω₀) anotada corretamente e esboço do sinal desenhado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/Octave",
                                    "Exemplo de sinal periódico (onda quadrada ou dente de serra)"
                                  ],
                                  "tips": "Sempre normalize o intervalo de integração para evitar erros de escala.",
                                  "learningObjective": "Compreender os parâmetros básicos necessários para a expansão de Fourier.",
                                  "commonMistakes": [
                                    "Confundir T com o período de um harmônico",
                                    "Esquecer de verificar periodicidade",
                                    "Usar intervalo errado de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os coeficientes complexos cₙ",
                                  "subSteps": [
                                    "Escrever a fórmula cₙ = (1/T) ∫_{-T/2}^{T/2} f(t) e^{-j n ω₀ t} dt para cada n ∈ ℤ.",
                                    "Calcular c₀ (componente DC) separadamente.",
                                    "Computar cₙ para n = ±1, ±2, etc., usando integração analítica ou numérica.",
                                    "Verificar propriedades: c_{-n} = conj(c_n) para sinais reais.",
                                    "Listar os primeiros 5-10 coeficientes e plotar módulo e fase."
                                  ],
                                  "verification": "Tabela de cₙ calculados com valores numéricos precisos e plot de espectro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy)",
                                    "Software de plotagem (MATLAB, Python com NumPy/Matplotlib)"
                                  ],
                                  "tips": "Use simetrias: para sinal par, cₙ reais; ímpar, imaginários puros.",
                                  "learningObjective": "Dominar o cálculo integral para obtenção de coeficientes exponenciais.",
                                  "commonMistakes": [
                                    "Erro no sinal do expoente (-j vs +j)",
                                    "Fator 1/T esquecido",
                                    "Integração fora do período fundamental"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir o sinal f(t) ≈ Σ cₙ e^{j n ω₀ t}",
                                  "subSteps": [
                                    "Escrever a soma parcial S_N(t) = Σ_{n=-N}^N cₙ e^{j n ω₀ t}.",
                                    "Calcular S_N(t) analiticamente para pequenos N.",
                                    "Plotar S_1(t), S_3(t), S_5(t) e comparar com f(t) original.",
                                    "Analisar convergência (Gibbs phenomenon em descontinuidades).",
                                    "Implementar numericamente em código para visualização."
                                  ],
                                  "verification": "Gráficos de aproximações parciais sobrepostos ao sinal original mostrando convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB para simulação",
                                    "Ferramenta de plotagem interativa"
                                  ],
                                  "tips": "Comece com N pequeno para entender e aumente gradualmente.",
                                  "learningObjective": "Aplicar a síntese do sinal a partir de seus coeficientes de Fourier.",
                                  "commonMistakes": [
                                    "Sinal errado no expoente de reconstrução",
                                    "Incluir n=0 incorretamente",
                                    "Não truncar a soma infinita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com a forma trigonométrica e validar",
                                  "subSteps": [
                                    "Converter cₙ para a₀, aₙ, bₙ usando a₀/2 = c₀, aₙ = 2 Re(cₙ), bₙ = -2 Im(cₙ).",
                                    "Escrever f(t) ≈ a₀/2 + Σ (aₙ cos(n ω₀ t) + bₙ sin(n ω₀ t)).",
                                    "Comparar coeficientes trigonométricos calculados diretamente.",
                                    "Verificar equivalência numérica entre formas exponencial e trigonométrica.",
                                    "Analisar energia total (Parseval: (1/T)∫|f|^2 = Σ |cₙ|^2)."
                                  ],
                                  "verification": "Tabelas comparativas de coeficientes e verificação de Parseval com erro <1%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas de coeficientes",
                                    "Código para teorema de Parseval"
                                  ],
                                  "tips": "Lembre: forma exponencial é mais compacta para processamento digital.",
                                  "learningObjective": "Estabelecer conexão entre representações exponencial e trigonométrica de Fourier.",
                                  "commonMistakes": [
                                    "Fator 2 errado em aₙ/bₙ",
                                    "Confundir Re/Im",
                                    "Ignorar c₀ em Parseval"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sinal quadrado f(t) = 1 (0<t<T/2), -1 (T/2<t<T), T=2π: c₀=0, cₙ = (2j/(nπ)) (1-(-1)^n) para n≠0. Reconstrua S_5(t) e plote, convertendo para forma seno/cosseno.",
                              "finalVerifications": [
                                "Coeficientes cₙ calculados corretamente para pelo menos 5 harmônicos.",
                                "Gráficos de reconstrução mostram convergência ao sinal original.",
                                "Conversão para forma trigonométrica coincide com cálculo direto.",
                                "Teorema de Parseval verificado com erro mínimo.",
                                "Simetrias do sinal exploradas para simplificação.",
                                "Aplicação numérica em software reproduz resultados analíticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos integrais (erro <0.01).",
                                "Qualidade dos gráficos de convergência e espectro.",
                                "Correta relação entre formas exponencial e trigonométrica.",
                                "Uso adequado de simetrias e propriedades.",
                                "Explicação clara da convergência e fenômenos como Gibbs.",
                                "Implementação computacional funcional e comentada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Complexa e Integração em Contorno.",
                                "Física: Teoria de Ondas e Vibrações Harmônicas.",
                                "Processamento de Sinais: Transformada Discreta de Fourier (DFT/FFT).",
                                "Engenharia de Controle: Análise de Sistemas Lineares Invariantes no Tempo.",
                                "Computação: Algoritmos Numéricos e Simulação."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, aplica-se para decompor sinais de acelerômetros em asas de aeronaves, identificando frequências de vibração ressonante, prevendo fadiga estrutural e otimizando controle ativo de flutter em sistemas dinâmicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2",
                              "10.1.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Sintetizar sinal a partir da série de Fourier",
                            "description": "Aproximar um sinal periódico truncando a série de Fourier em N harmônicos e analisar o erro de truncamento, plotando aproximações parciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular os coeficientes da série de Fourier para um sinal periódico",
                                  "subSteps": [
                                    "Escolha um sinal periódico conhecido, como uma onda quadrada ou dente de serra, definindo período T e função f(t).",
                                    "Calcule o coeficiente a0 usando a integral (1/T) ∫ f(t) dt de 0 a T.",
                                    "Calcule os coeficientes an = (2/T) ∫ f(t) cos(2π n t / T) dt para n=1 a N.",
                                    "Calcule os coeficientes bn = (2/T) ∫ f(t) sen(2π n t / T) dt para n=1 a N.",
                                    "Verifique simetria par/ímpar para simplificar cálculos (ex: só bn para ímpar)."
                                  ],
                                  "verification": "Comparar coeficientes calculados com valores analíticos conhecidos ou tabelas padrão para o sinal escolhido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e calculadora para cálculos manuais",
                                    "Software como MATLAB, Python (SymPy ou SciPy) ou Wolfram Alpha para integrais numéricas"
                                  ],
                                  "tips": "Explore simetrias (par, ímpar, meia-onda) para reduzir o número de integrais necessárias.",
                                  "learningObjective": "Dominar o cálculo analítico e numérico dos coeficientes Fourier, entendendo sua interpretação física como amplitudes de harmônicos.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 em an e bn",
                                    "Erros nos limites de integração (deve ser um período completo)",
                                    "Confundir sen e cos nas fórmulas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a síntese do sinal truncado em N harmônicos",
                                  "subSteps": [
                                    "Defina uma função que some os termos da série: s_N(t) = a0/2 + Σ [an cos(ωn t) + bn sen(ωn t)] para n=1 a N.",
                                    "Escreva código em Python/MATLAB para gerar s_N(t) em uma grade de tempo t de 0 a vários períodos.",
                                    "Teste para N=1, 5, 10 e 20, salvando cada aproximação em arrays separados.",
                                    "Garanta que ωn = 2π n / T esteja correto.",
                                    "Normaliza o sinal se necessário para amplitude unitária."
                                  ],
                                  "verification": "Executar o código e verificar se para N grande o sinal se aproxima do original visualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e Matplotlib ou MATLAB",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": "Vetorize as somas usando loops ou broadcasting para eficiência computacional.",
                                  "learningObjective": "Implementar numericamente a soma finita da série de Fourier, compreendendo o impacto da truncagem.",
                                  "commonMistakes": [
                                    "Índices errados no loop (começar n de 0)",
                                    "Não dividir a0 por 2",
                                    "Frequências erradas (ωn incorreta)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar as aproximações parciais e o sinal original",
                                  "subSteps": [
                                    "Gere o sinal original f(t) analiticamente ou por definição piecewise.",
                                    "Crie subplots com o sinal original e s_N(t) para N=1,5,10,20 no mesmo eixo temporal.",
                                    "Adicione legendas, títulos e rótulos claros (tempo em ms, amplitude).",
                                    "Use escalas adequadas para visualizar overshoots (Gibbs phenomenon).",
                                    "Salve a figura em alta resolução."
                                  ],
                                  "verification": "Os plots mostram convergência progressiva e overshoots perto de descontinuidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Bibliotecas de plotagem: Matplotlib (Python) ou plot() (MATLAB)"
                                  ],
                                  "tips": "Use múltiplos períodos no plot para observar periodicidade clara.",
                                  "learningObjective": "Visualizar graficamente a convergência da série de Fourier e fenômenos associados.",
                                  "commonMistakes": [
                                    "Plots sobrepostos ilegíveis (use transparência ou subplots)",
                                    "Escala y inadequada escondendo detalhes",
                                    "Falta de legenda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o erro de truncamento",
                                  "subSteps": [
                                    "Calcule o erro médio quadrático (MSE) = (1/T) ∫ [f(t) - s_N(t)]² dt ou versão discreta Σ [f(t_i) - s_N(t_i)]² / M.",
                                    "Plote MSE vs N em log-escala para observar decaimento.",
                                    "Calcule o erro máximo (L∞) e sua posição (próximo a descontinuidades?).",
                                    "Discuta taxa de convergência e fenômeno de Gibbs.",
                                    "Compare com teoria: erro ~ 1/N para sinais suaves."
                                  ],
                                  "verification": "Gráfico de erro mostra diminuição monotônica com N, com valores quantitativos reportados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmo software de programação",
                                    "Funções de integração numérica (quad no SciPy)"
                                  ],
                                  "tips": "Use trapz ou simps para integração numérica precisa do erro.",
                                  "learningObjective": "Quantificar e interpretar o erro de truncagem, relacionando com propriedades do sinal.",
                                  "commonMistakes": [
                                    "Erro calculado sem normalizar pelo comprimento",
                                    "Confundir erro absoluto com relativo",
                                    "Ignorar overshoots no erro máximo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma onda quadrada f(t) = 1 para 0 < t < π, -1 para π < t < 2π (T=2π), calcule bn = 4/(nπ) para n ímpar, an=0. Sintetize s_N(t) para N=1,3,5,10; plote e analise MSE, observando Gibbs ~9% próximo às bordas.",
                              "finalVerifications": [
                                "Coeficientes coincidem com soluções analíticas dentro de 1%.",
                                "Plots mostram convergência clara e overshoots de Gibbs.",
                                "MSE diminui com N, plotado corretamente em log-escala.",
                                "Análise discute limitações da truncagem e fenômeno de Gibbs.",
                                "Código executável e reproduzível fornecido.",
                                "Relatório resume achados com interpretações físicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes calculados (erro <1%).",
                                "Qualidade e clareza dos plots (legendas, escalas adequadas).",
                                "Correção no cálculo de erros (MSE e L∞).",
                                "Profundidade da análise de convergência e limitações.",
                                "Eficiência e legibilidade do código implementado.",
                                "Conexão com contexto de sistemas dinâmicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Harmônica e Integração Numérica.",
                                "Programação: Manipulação de arrays e visualização em Python/MATLAB.",
                                "Física: Ondas, Vibrações e Fenômenos de Difração.",
                                "Engenharia de Controle: Modelagem de Sinais em Sistemas Dinâmicos.",
                                "Processamento de Sinais: Bases para Transformada Rápida de Fourier (FFT)."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, sintetizar séries de Fourier permite modelar vibrações harmônicas em estruturas de aeronaves a partir de dados de sensores, analisando erros para validação de modelos dinâmicos e previsão de fadiga em asas ou hélices."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.4",
                            "name": "Usar simplificações para sinais simétricos",
                            "description": "Aplicar propriedades de simetria (par, ímpar, meia-onda) para simplificar cálculos de coeficientes, zerando termos desnecessários como aₙ para sinais ímpares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos de simetria em sinais periódicos",
                                  "subSteps": [
                                    "Estude a definição de função par: f(-t) = f(t).",
                                    "Estude a definição de função ímpar: f(-t) = -f(t).",
                                    "Aprenda simetria de meia-onda: f(t + T/2) = -f(t), onde T é o período.",
                                    "Revise as propriedades básicas de séries de Fourier para cada tipo.",
                                    "Anote exemplos visuais de cada simetria."
                                  ],
                                  "verification": "Liste corretamente as três simetrias e dê um exemplo gráfico para cada uma.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhos",
                                    "Livro de Sinais e Sistemas ou notas de aula",
                                    "Gráficos de referência online"
                                  ],
                                  "tips": "Desenhe os sinais no eixo t para visualizar a simetria facilmente.",
                                  "learningObjective": "Identificar e diferenciar simetrias par, ímpar e meia-onda em sinais periódicos.",
                                  "commonMistakes": "Confundir simetria par com simetria de meia-onda; sempre verificar f(-t) e f(t + T/2)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar simetria em um sinal dado",
                                  "subSteps": [
                                    "Desenhe o sinal periódico fornecido sobre um período completo.",
                                    "Verifique simetria par testando pontos simétricos em torno de t=0.",
                                    "Verifique simetria ímpar comparando f(t) e -f(-t).",
                                    "Teste simetria de meia-onda deslocando T/2 e comparando com o negativo.",
                                    "Classifique o sinal e justifique com cálculos em pontos chave."
                                  ],
                                  "verification": "Produza um diagrama anotado mostrando a simetria identificada corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Calculadora",
                                    "Exemplos de sinais de um livro-texto"
                                  ],
                                  "tips": "Use o eixo de simetria (geralmente t=0) como referência visual.",
                                  "learningObjective": "Classificar com precisão a simetria de qualquer sinal periódico.",
                                  "commonMistakes": "Ignorar o período completo; sempre analisar pelo menos um ciclo inteiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar simplificações aos coeficientes de Fourier",
                                  "subSteps": [
                                    "Lembre as fórmulas integrais para a0, an e bn.",
                                    "Para sinal par: bn = 0, calcular apenas a0 e an.",
                                    "Para sinal ímpar: an = 0 (incluindo a0), calcular apenas bn.",
                                    "Para meia-onda: an = 0, calcular apenas bn com integral ajustada.",
                                    "Escreva as expressões simplificadas para os coeficientes não-nulos."
                                  ],
                                  "verification": "Escreva as fórmulas simplificadas corretas para um tipo de simetria dado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Folha de fórmulas de Fourier",
                                    "Calculadora simbólica ou software como Mathematica"
                                  ],
                                  "tips": "Memorize: par → cossenos (an), ímpar → senos (bn), meia-onda → senos ajustados.",
                                  "learningObjective": "Derivar e aplicar regras de simplificação baseadas na simetria.",
                                  "commonMistakes": "Esquecer que a0 é par e some para ímpar; sempre verificar paridade de constantes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e verificar a expansão simplificada",
                                  "subSteps": [
                                    "Escolha um sinal simétrico e compute os coeficientes não-nulos.",
                                    "Integre analiticamente ou numericamente os termos relevantes.",
                                    "Escreva a série de Fourier simplificada.",
                                    "Plote ou compare a soma parcial com o sinal original.",
                                    "Confirme que termos zerados são desnecessários."
                                  ],
                                  "verification": "A expansão reconstrói o sinal original com erro mínimo (<5%) em pontos testados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (numpy/scipy)",
                                    "Exemplo de sinal impresso"
                                  ],
                                  "tips": "Comece com poucos harmônicos para verificação rápida.",
                                  "learningObjective": "Executar cálculo completo de série de Fourier usando simplificações.",
                                  "commonMistakes": "Erros em limites de integração; sempre de -T/2 a T/2 para simetria."
                                }
                              ],
                              "practicalExample": "Para uma onda quadrada ímpar f(t) = 1 (0 < t < T/2), -1 (T/2 < t < T), an = 0 e a0 = 0, bn = (4/ (nπ)) para n ímpar, simplificando o cálculo e zerando termos desnecessários.",
                              "finalVerifications": [
                                "Todos os coeficientes zerados pela simetria estão corretamente identificados como zero.",
                                "Os coeficientes não-nulos coincidem com valores tabelados ou computados independentemente.",
                                "A soma de 5 harmônicos reconstrói o sinal com precisão visual.",
                                "Nenhuma integral desnecessária foi computada.",
                                "A classificação de simetria é justificada com testes numéricos.",
                                "O período T está corretamente usado em todas as fórmulas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de simetria (30%)",
                                "Correção das fórmulas simplificadas (25%)",
                                "Exatidão nos cálculos de coeficientes (20%)",
                                "Verificação e reconstrução do sinal (15%)",
                                "Clareza na justificativa e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de vibrações harmônicas em estruturas aeronáuticas.",
                                "Programação: Implementação numérica de FFT em Python/MATLAB para validação.",
                                "Matemática: Aplicação de integrais definidas e propriedades de funções pares/ímpares.",
                                "Engenharia de Controle: Simplificação em modelagem de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, simplifica a análise de sinais de vibração em asas ou fuselagem, reduzindo tempo computacional em identificação de modos de flutter via séries de Fourier, otimizando detecção de falhas em testes de solo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2",
                              "10.1.1.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Aplicações na Identificação de Sistemas",
                        "description": "Uso das séries de Fourier para análise espectral de sinais periódicos na determinação da resposta em frequência de sistemas lineares invariantes no tempo (LTI) contínuos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Analisar espectro de linha de sinais periódicos",
                            "description": "Representar o espectro de Fourier de um sinal periódico como linhas discretas nos harmônicos nω₀, identificando amplitudes e fases dos componentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e caracterizar o sinal periódico",
                                  "subSteps": [
                                    "Defina o período T e a frequência fundamental ω₀ = 2π/T do sinal.",
                                    "Represente o sinal x(t) matematicamente no intervalo [-T/2, T/2].",
                                    "Verifique se o sinal é par, ímpar ou geral para simplificar cálculos.",
                                    "Calcule manualmente alguns valores de x(t) em pontos chave.",
                                    "Desenhe o sinal no domínio do tempo para visualização."
                                  ],
                                  "verification": "Confirme ω₀ correta e esboço do sinal batendo com a descrição original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Sempre normalize o intervalo para facilitar integrais de Fourier.",
                                  "learningObjective": "Compreender as propriedades fundamentais do sinal periódico.",
                                  "commonMistakes": [
                                    "Confundir período com frequência",
                                    "Ignorar simetrias par/ímpar",
                                    "Escala errada no eixo tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os coeficientes de Fourier",
                                  "subSteps": [
                                    "Calcule o coeficiente a₀ (componente DC) como (1/T) ∫ x(t) dt.",
                                    "Compute aₙ = (2/T) ∫ x(t) cos(nω₀ t) dt para n=1,2,... até N suficiente.",
                                    "Compute bₙ = (2/T) ∫ x(t) sin(nω₀ t) dt para n=1,2,...",
                                    "Calcule a amplitude cₙ = √(aₙ² + bₙ²) e fase φₙ = atan2(bₙ, aₙ).",
                                    "Use software para validar cálculos analíticos (ex: sympy ou numerical integration)."
                                  ],
                                  "verification": "Coeficientes para harmônicos baixos coincidem com valores conhecidos ou simulação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de fórmulas de Fourier",
                                    "Python com scipy.integrate ou MATLAB",
                                    "Tabela de integrais"
                                  ],
                                  "tips": "Para sinais simétricos, alguns coeficientes são zero; explore isso.",
                                  "learningObjective": "Dominar o cálculo preciso de amplitudes e fases harmônicas.",
                                  "commonMistakes": [
                                    "Fator 2/T errado",
                                    "Limites de integração incorretos",
                                    "Esquecer normalização da fase"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a representação do espectro de linha",
                                  "subSteps": [
                                    "Liste as frequências discretas: nω₀ para n=0,1,2,...",
                                    "Plote as linhas verticais para |cₙ| em cada nω₀ (espectro de magnitude).",
                                    "Plote separadamente o espectro de fase φₙ vs nω₀.",
                                    "Inclua linhas simétricas para n negativo se usando forma complexa.",
                                    "Use stem plot em software para visualização clara."
                                  ],
                                  "verification": "Gráfico mostra picos discretos apenas em múltiplos de ω₀, sem continuum.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python (numpy, matplotlib.pyplot.stem)",
                                    "MATLAB (stem function)",
                                    "Excel para plot simples"
                                  ],
                                  "tips": "Escolha escala logarítmica para magnitude se amplitudes variam muito.",
                                  "learningObjective": "Visualizar o espectro de Fourier como linhas discretas.",
                                  "commonMistakes": [
                                    "Plotar como espectro contínuo",
                                    "Ignorar n=0",
                                    "Fases em graus vs radianos inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar o espectro",
                                  "subSteps": [
                                    "Identifique harmônicos dominantes (maiores |cₙ|).",
                                    "Compare fases para detectar padrões (ex: atrasos).",
                                    "Reconstrua sinal aproximado somando primeiros N termos.",
                                    "Avalie convergência: erro entre original e reconstrução.",
                                    "Discuta implicações para identificação de sistemas (ex: ressonâncias)."
                                  ],
                                  "verification": "Reconstrução visualmente similar ao sinal original com poucos harmônicos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de síntese: ifft ou soma manual",
                                    "Gráficos lado a lado"
                                  ],
                                  "tips": "Limite N a 10-20 para análise prática; mais causa ruído numérico.",
                                  "learningObjective": "Extrair insights acionáveis do espectro para aplicações.",
                                  "commonMistakes": [
                                    "Sobrestimar harmônicos fracos",
                                    "Ignorar aliasing em reconstrução",
                                    "Não validar com sinal original"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma onda quadrada x(t) = 1 para |t| < T/4, -1 para T/4 < |t| < T/2, periódica com T=1s (ω₀=2π rad/s), simulando vibrações alternadas em uma hélice aeronáutica. Calcule coeficientes (aₙ=0 para ímpar, 4/(nπ) para ímpar n; bₙ=0), plote espectro com picos em harmônicos ímpares, e identifique 3º harmônico como potencial ressonância.",
                              "finalVerifications": [
                                "Espectro mostra apenas linhas discretas em nω₀.",
                                "Amplitudes e fases calculadas coincidem com software em 5% de erro.",
                                "Reconstrução com 5 harmônicos reproduz >90% da forma do sinal.",
                                "Identificados pelo menos 3 componentes dominantes corretamente.",
                                "Fases interpretadas corretamente (ex: 0 ou π/2)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos coeficientes de Fourier (erro <5%).",
                                "Correta representação gráfica de espectro de linha.",
                                "Interpretação qualitativa e quantitativa das componentes.",
                                "Uso apropriado de simetrias para simplificação.",
                                "Validação via reconstrução do sinal.",
                                "Clareza na documentação de cálculos e plots."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries trigonométricas e integrais definidas.",
                                "Física: Análise de ondas e vibrações mecânicas.",
                                "Processamento de Sinais: FFT para dados reais.",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Controle de Sistemas: Identificação de modelos dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, analisar o espectro de vibrações medidas em sensores de hélices ou flaps para detectar harmônicos que causam fadiga estrutural, permitindo ajustes em RPM para evitar ressonâncias e melhorar segurança de voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Calcular resposta de sistemas LTI a sinais periódicos",
                            "description": "Dado um sistema LTI com função de transferência H(jω), calcular a resposta y(t) a um sinal periódico x(t) somando as respostas aos harmônicos individuais Y(jnω₀) = H(jnω₀) X(jnω₀).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o sinal periódico x(t) pela série de Fourier",
                                  "subSteps": [
                                    "Identifique o período T e a frequência fundamental ω₀ = 2π/T do sinal x(t).",
                                    "Expresse x(t) como soma de harmônicos: x(t) = Σ [aₙ cos(nω₀ t) + bₙ sin(nω₀ t)] ou forma complexa Σ cₙ e^{jnω₀ t}.",
                                    "Determine os primeiros 5-10 harmônicos relevantes com base na largura de banda esperada.",
                                    "Plote x(t) no tempo e seu espectro de Fourier para visualização.",
                                    "Confirme que a representação satisfaz a propriedade de Parseval para energia."
                                  ],
                                  "verification": "O sinal reconstruído a partir dos harmônicos coincide visualmente com x(t) original em pelo menos 95% dos pontos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora gráfica ou software como MATLAB/Octave",
                                    "Tabelas de séries de Fourier padrão",
                                    "Papel quadriculado para esboços manuais"
                                  ],
                                  "tips": "Comece com sinais comuns como senoide, quadrado ou dente de serra para prática rápida.",
                                  "learningObjective": "Dominar a decomposição de sinais periódicos em componentes harmônicas via séries de Fourier.",
                                  "commonMistakes": [
                                    "Confundir ω₀ com ω",
                                    "Esquecer o termo DC (n=0)",
                                    "Usar amplitude em vez de coeficientes complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os coeficientes de Fourier X(jnω₀)",
                                  "subSteps": [
                                    "Calcule os coeficientes cₙ = (1/T) ∫ x(t) e^{-jnω₀ t} dt sobre um período.",
                                    "Para sinais pares/ímpares, simplifique usando aₙ e bₙ.",
                                    "Liste X(jnω₀) = cₙ para n = -N a N, onde N é o número de harmônicos.",
                                    "Verifique simetria: cₙ = c_{-n}^* para sinais reais.",
                                    "Normalise os coeficientes se necessário para consistência."
                                  ],
                                  "verification": "Coeficientes calculados manualmente coincidem com output de software FFT em erro <1%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Octave para fft()",
                                    "Tabelas analíticas de Fourier para sinais padrão",
                                    "Folha de cálculo Excel para somas numéricas"
                                  ],
                                  "tips": "Use integração por partes para integrais analíticas; discretize para numéricas.",
                                  "learningObjective": "Computar precisamente os coeficientes espectrais de um sinal periódico.",
                                  "commonMistakes": [
                                    "Limites de integração errados (deve ser um período exato)",
                                    "Fator 1/T esquecido",
                                    "Não considerar sinal real vs. complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função de transferência H(jω) aos harmônicos",
                                  "subSteps": [
                                    "Avalie H(jnω₀) para cada n, usando H(s) substituindo s = jnω₀.",
                                    "Calcule Y(jnω₀) = H(jnω₀) * X(jnω₀) para cada harmônico.",
                                    "Plote o espectro |H(jω)| e |Y(jω)| para visualizar atenuação/amplificação.",
                                    "Identifique harmônicos dominantes pós-filtro.",
                                    "Verifique estabilidade: |H(jnω₀)| finito para todos n relevantes."
                                  ],
                                  "verification": "Magnitude e fase de Y(jnω₀) correspondem à multiplicação vetorial de X e H.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou MATLAB Symbolic",
                                    "Gráficos de Bode pré-computados do sistema",
                                    "Calculadora complexa"
                                  ],
                                  "tips": "Represente H(jω) em forma polar para multiplicação fácil: |H|∠φ * |X|∠θ.",
                                  "learningObjective": "Aplicar resposta em frequência de LTI a componentes espectrais individuais.",
                                  "commonMistakes": [
                                    "Substituir s = jω em vez de jnω₀",
                                    "Ignorar fase de H",
                                    "Sobrecarregar com harmônicos irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a resposta y(t) somando harmônicos",
                                  "subSteps": [
                                    "Reconstrua y(t) = Σ Re{ Y(jnω₀) e^{jnω₀ t} } para n=-N a N.",
                                    "Some numericamente ou analiticamente os termos truncados.",
                                    "Plote y(t) e compare com simulação temporal direta do sistema.",
                                    "Ajuste número de harmônicos até convergência (erro <1%).",
                                    "Analise transientes iniciais se aplicável."
                                  ],
                                  "verification": "y(t) calculada via harmônicos coincide com solução numérica de y'(t) = Ax + Bu em erro RMS <0.5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Octave para soma e plot",
                                    "Simulador ODE como ode45",
                                    "Python com NumPy/SciPy"
                                  ],
                                  "tips": "Use truncamento Gibbs-aware: inclua mais harmônicos perto de descontinuidades.",
                                  "learningObjective": "Sintetizar resposta temporal a partir de espectro filtrado.",
                                  "commonMistakes": [
                                    "Esquecer parte imaginária ou conjugada",
                                    "Soma infinita sem truncamento",
                                    "Fase errada levando a cancelamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar a resposta",
                                  "subSteps": [
                                    "Compare y(t) com resposta esperada (ex: filtro low-pass suaviza quadrado).",
                                    "Calcule métricas: THD, erro RMS, espectro filtrado.",
                                    "Simule em software para confirmação.",
                                    "Discuta limitações (ex: linearidade assumida).",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Todas métricas de validação dentro de tolerâncias pré-definidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de plot como MATLAB plot()",
                                    "Referências teóricas de Oppenheim"
                                  ],
                                  "tips": "Sempre valide com caso simples primeiro (senoide pura).",
                                  "learningObjective": "Avaliar precisão e robustez do método de resposta harmônica.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades reais",
                                    "Falta de truncamento causando oscilações",
                                    "Comparação sem normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema LTI com H(s) = 1/(s+1), low-pass, e x(t) sinal quadrado de período 2π (ω₀=1). Calcule cₙ = (2/π)(1-(-1)^n)/(jn) para n≠0. Então Y(jn) = cₙ / (jn +1), some para y(t) ≈ senoide suavizada.",
                              "finalVerifications": [
                                "Resposta y(t) converge com truncamento N>10 harmônicos.",
                                "Espectro Y(jω) mostra atenuação progressiva |H(jnω₀)|.",
                                "Energia de y(t) < energia de x(t) para sistemas passivos.",
                                "Fase shift consistente com arg(H(jω)).",
                                "Simulação temporal matches síntese harmônica em 98%+.",
                                "Nenhum polo instável ativado pelos harmônicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes de Fourier (erro <0.1%).",
                                "Correta avaliação de H(jnω₀) para todos harmônicos.",
                                "Convergência adequada da soma com justificativa de N.",
                                "Análise qualitativa do efeito do filtro (suavização, etc.).",
                                "Documentação clara com plots tempo/frequência.",
                                "Tratamento correto de casos DC e simetria."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Vibrações (Aero): Resposta de estruturas a excitações periódicas.",
                                "Controle Automático: Análise de entrada periódica em laços de feedback.",
                                "Processamento de Sinais Digitais: FFT para identificação via excitação periódica.",
                                "Eletrônica: Resposta de filtros analógicos a ondas periódicas.",
                                "Modelagem Computacional: Simulações em Python/MATLAB para validação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, usado para prever resposta de sistemas dinâmicos (ex: flaps ou hélices) a vibrações periódicas de motores, permitindo identificação de frequências ressonantes e design de amortecedores via análise harmônica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.2",
                              "10.1.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Identificar sistemas via excitação periódica",
                            "description": "Usar séries de Fourier de entrada e saída periódicas para estimar a função de resposta em frequência H(jω) nos harmônicos, aplicando em exemplos de sistemas mecânicos ou elétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e caracterizar os sinais periódicos de entrada e saída",
                                  "subSteps": [
                                    "Selecione um sinal periódico de entrada u(t), como uma onda quadrada ou dente de serra, com período T conhecido.",
                                    "Defina o sinal de saída y(t) do sistema sob excitação periódica no estado estacionário.",
                                    "Registre ou simule os sinais u(t) e y(t) para um número suficiente de períodos para minimizar transientes.",
                                    "Identifique os harmônicos fundamentais e superiores presentes nos sinais.",
                                    "Plote os sinais no domínio do tempo para visualização inicial."
                                  ],
                                  "verification": "Sinais u(t) e y(t) plotados corretamente com período T identificado e harmônicos visíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (MATLAB, Python com SciPy/NumPy)",
                                    "Papel e lápis para esboços manuais"
                                  ],
                                  "tips": "Garanta que os sinais estejam no estado estacionário; ignore os primeiros ciclos se houver transientes.",
                                  "learningObjective": "Compreender a natureza periódica dos sinais e preparar dados para análise de Fourier.",
                                  "commonMistakes": [
                                    "Incluir transientes nos sinais",
                                    "Escolher período T incorreto",
                                    "Não plotar múltiplos períodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar as séries de Fourier dos sinais de entrada e saída",
                                  "subSteps": [
                                    "Calcule os coeficientes de Fourier c_k para u(t) usando a fórmula integral ou método numérico FFT.",
                                    "Repita o cálculo para os coeficientes d_k de y(t).",
                                    "Extraia as componentes nos harmônicos k=1,2,3,... até onde a energia for significativa.",
                                    "Converta para representação complexa U(jω_k) = c_k * T e Y(jω_k) = d_k * T.",
                                    "Valide a reconstrução dos sinais originais somando os primeiros harmônicos."
                                  ],
                                  "verification": "Coeficientes c_k e d_k calculados e sinais reconstruídos com erro <5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Python para FFT",
                                    "Tabelas de coeficientes analíticos para ondas comuns"
                                  ],
                                  "tips": "Use FFT para eficiência computacional; normalize corretamente pela duração da janela.",
                                  "learningObjective": "Dominar o cálculo e interpretação das séries de Fourier para sinais periódicos.",
                                  "commonMistakes": [
                                    "Erro na normalização dos coeficientes",
                                    "Não considerar harmônicos pares/impares adequadamente",
                                    "Usar janela inadequada no FFT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar a função de resposta em frequência H(jω) nos harmônicos",
                                  "subSteps": [
                                    "Calcule H(jω_k) = Y(jω_k) / U(jω_k) para cada harmônico k onde |U(jω_k)| > threshold.",
                                    "Plote o diagrama de Bode de magnitude e fase de H(jω) usando os pontos estimados.",
                                    "Interpule os pontos para obter uma estimativa contínua de H(jω).",
                                    "Compare com o modelo teórico conhecido do sistema, se disponível.",
                                    "Analise discrepâncias devido a ruído ou harmônicos não capturados."
                                  ],
                                  "verification": "Gráfico de Bode plotado com H(jω_k) calculados para pelo menos 5 harmônicos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (MATLAB bode() ou Python matplotlib)",
                                    "Modelo teórico do sistema para comparação"
                                  ],
                                  "tips": "Evite divisão por zero filtrando harmônicos com U(jω_k) pequeno; use magnitude mínima.",
                                  "learningObjective": "Aplicar a relação H(jω) = Y/U na identificação de sistemas lineares invariantes no tempo.",
                                  "commonMistakes": [
                                    "Dividir por zeros ou valores muito pequenos",
                                    "Ignorar fase ao plotar Bode",
                                    "Não interpolar pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar em um exemplo de sistema mecânico ou elétrico",
                                  "subSteps": [
                                    "Escolha um sistema exemplo, como um circuito RLC série ou oscilador massa-mola-amortecedor.",
                                    "Simule ou experimente com excitação periódica e colete u(t)/y(t).",
                                    "Execute os passos anteriores para estimar H(jω).",
                                    "Compare a H estimada com a H teórica (ex: 1/(R + jωL + 1/(jωC))).",
                                    "Discuta limitações e melhorias, como mais harmônicos ou excitação não periódica."
                                  ],
                                  "verification": "H estimada sobreposta à H teórica com concordância em pelo menos 80% dos harmônicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink/MATLAB para simulação",
                                    "Kit experimental opcional (osciloscópio, gerador de sinais)"
                                  ],
                                  "tips": "Comece com sistema de baixa ordem para validação rápida.",
                                  "learningObjective": "Integrar o método em contextos reais de engenharia aeronáutica.",
                                  "commonMistakes": [
                                    "Não linearizar o sistema",
                                    "Escala errada nos eixos do Bode",
                                    "Ignorar ruído na saída"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema massa-mola-amortecedor (M=1kg, k=100N/m, c=2Ns/m), aplique u(t) onda quadrada de amplitude 1N e T=1s. Colete y(t) deslocamento, compute Fourier, estime H(jω) e compare com H(s)=1/(Ms^2 + cs + k).",
                              "finalVerifications": [
                                "Capacidade de decompor sinais periódicos corretamente via Fourier.",
                                "Cálculo preciso de H(jω_k) sem divisões inválidas.",
                                "Plot de Bode coerente com comportamento físico do sistema.",
                                "Reconstrução de y(t) a partir de H estimada e u(t).",
                                "Identificação de pelo menos 3 características do sistema (ex: frequência natural, amortecimento).",
                                "Discussão de erros e limitações do método."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes de Fourier (erro <10%).",
                                "Correção na estimativa de H(jω) nos harmônicos.",
                                "Qualidade do diagrama de Bode e interpretação.",
                                "Aplicação bem-sucedida no exemplo prático.",
                                "Análise de erros comuns e validação.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e análise complexa.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Controle Automático: Identificação para síntese de controladores.",
                                "Processamento de Sinais: FFT e análise espectral."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, identifica parâmetros de estruturas de asas sob vibrações periódicas (ex: turbulência), permitindo modelagem precisa para controle de flutter e fadiga."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.3",
                              "10.1.1.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Sinais Discretos: Amostragem e Transformada Discreta de Fourier",
                    "description": "Janelamento, amostragem de sinais contínuos e aplicação da DFT em análise e identificação discreta.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Amostragem de Sinais Contínuos",
                        "description": "Processo de conversão de sinais contínuos no tempo para sinais discretos, incluindo os princípios fundamentais para evitar distorções espectrais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Compreender o Teorema de Nyquist-Shannon",
                            "description": "Explicar a taxa de amostragem mínima necessária para reconstruir um sinal contínuo sem perda de informação, calculando a frequência de Nyquist para sinais bandlimitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Sinais Contínuos e Discretos",
                                  "subSteps": [
                                    "Defina sinal contínuo (x(t)) e sinal discreto (x[n]).",
                                    "Explique o processo de amostragem como conversão de contínuo para discreto.",
                                    "Identifique o papel do período de amostragem (T) e frequência de amostragem (fs = 1/T).",
                                    "Discuta exemplos iniciais em engenharia aeronáutica, como sensores de aceleração.",
                                    "Introduza o conceito preliminar de aliasing."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre sinais contínuo e discreto, com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim)",
                                    "Vídeo introdutório sobre amostragem (YouTube ou Khan Academy)",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": [
                                    "Use analogia de um filme contínuo vs. sequência de fotos para visualizar amostragem.",
                                    "Desenhe gráficos de x(t) e x[n] lado a lado."
                                  ],
                                  "learningObjective": "Compreender a transição fundamental de domínio contínuo para discreto via amostragem.",
                                  "commonMistakes": [
                                    "Confundir amostragem com quantização de amplitude.",
                                    "Ignorar que amostragem afeta apenas o domínio do tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Frequência, Espectro e Sinais Bandlimitados",
                                  "subSteps": [
                                    "Defina frequência angular (ω) e frequência (f) em Hz.",
                                    "Explique o espectro de frequência de um sinal usando Transformada de Fourier.",
                                    "Defina sinal bandlimitado: energia concentrada abaixo de f_max.",
                                    "Calcule a largura de banda B = f_max para um sinal dado.",
                                    "Identifique f_max em espectros de sinais reais de vibração aeronáutica."
                                  ],
                                  "verification": "Desenhe e rotule o espectro de frequência de um sinal senoidal bandlimitado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy) para plotar espectros",
                                    "Exemplos de sinais de sensores aeronáuticos",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Comece com sinais simples como senoide pura.",
                                    "Lembre-se: banda limitada significa zero energia acima de f_max."
                                  ],
                                  "learningObjective": "Identificar e quantificar componentes de frequência em sinais bandlimitados.",
                                  "commonMistakes": [
                                    "Confundir frequência fundamental com frequência máxima.",
                                    "Assumir todos os sinais reais são bandlimitados sem filtro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar e Compreender o Teorema de Nyquist-Shannon",
                                  "subSteps": [
                                    "Enuncie o teorema: fs > 2*f_max para reconstrução perfeita.",
                                    "Explique a frequência de Nyquist: f_N = 2*f_max.",
                                    "Discuta condição de taxa de amostragem mínima sem aliasing.",
                                    "Descreva reconstrução via interpolação com função sinc.",
                                    "Analise o que acontece se fs ≤ 2*f_max (aliasing)."
                                  ],
                                  "verification": "Reescreva o teorema em suas palavras e explique por que 2*f_max é necessário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo original de Shannon ou resumo (Wikipedia para visão geral)",
                                    "Animações interativas de aliasing (ex: site da DSP Guide)",
                                    "Gráficos de sinc function"
                                  ],
                                  "tips": [
                                    "Visualize aliasing com rodas de carro em filmes.",
                                    "Memorize: Nyquist captura ciclo completo (subida e descida)."
                                  ],
                                  "learningObjective": "Explicar teoricamente a relação entre amostragem e fidelidade do sinal.",
                                  "commonMistakes": [
                                    "Usar fs = f_max em vez de 2*f_max.",
                                    "Confundir frequência de Nyquist com taxa de Nyquist."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Cálculos e Verificar o Teorema",
                                  "subSteps": [
                                    "Dado f_max, calcule f_N e fs_min recomendada (tipicamente 2.5*f_N).",
                                    "Resolva problemas numéricos: ex. f_max=5kHz, fs=?",
                                    "Simule amostragem em software e observe aliasing.",
                                    "Compare reconstrução com fs adequada vs. inadequada.",
                                    "Aplique a um caso aeronáutico: sinal de vibração em turbina."
                                  ],
                                  "verification": "Calcule fs para um sinal dado e demonstre sem aliasing em simulação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/MATLAB com bibliotecas signal processing",
                                    "Exercícios impressos ou Jupyter notebook",
                                    "Dados reais de sensores (ex: dataset de vibração de aeronaves)"
                                  ],
                                  "tips": [
                                    "Sempre filtre o sinal antes de amostrar para garantir bandlimitado.",
                                    "Use fs = 2.2-2.5*f_max na prática para margem."
                                  ],
                                  "learningObjective": "Calcular e validar taxas de amostragem para sinais específicos.",
                                  "commonMistakes": [
                                    "Esquecer de dobrar f_max.",
                                    "Não considerar ruído que estende o espectro."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de monitoramento de vibrações em uma asa de aeronave, um sinal de aceleração tem f_max = 500 Hz. Calcule a fs mínima (f_N = 1000 Hz) e simule amostragem com fs=1200 Hz vs. fs=800 Hz para demonstrar reconstrução perfeita vs. aliasing distorcendo detecção de falhas estruturais.",
                              "finalVerifications": [
                                "Explicar o teorema sem consultar notas.",
                                "Calcular corretamente f_N para 3 exemplos variados.",
                                "Identificar aliasing em um gráfico de espectro simulado.",
                                "Descrever como evitar aliasing em um sistema real.",
                                "Reconstruir um sinal simples via interpolação manual.",
                                "Discutir limitações do teorema em sinais não ideais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: enunciado correto do teorema (30%).",
                                "Habilidade de cálculo: fs correta sem erros (25%).",
                                "Análise visual: identificação de aliasing em plots (20%).",
                                "Aplicação prática: ligação com contexto aeronáutico (15%).",
                                "Profundidade: menção a sinc e reconstrução (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas e vibrações em estruturas aeronáuticas.",
                                "Processamento Digital de Sinais: Filtros anti-aliasing em controle de voo.",
                                "Comunicações: Modulação e transmissão de dados de telemetria.",
                                "Controle Automático: Amostragem em laços de feedback de sistemas dinâmicos.",
                                "Informática: Algoritmos de DSP em software embarcado."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, o teorema garante que dados de sensores (vibração, pressão, aceleração) em testes de voo sejam amostrados sem perda, permitindo análise precisa de fadiga estrutural, detecção de falhas em turbinas e otimização de sistemas de controle de estabilidade, evitando acidentes por distorções como aliasing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Identificar e Mitigar Aliasing",
                            "description": "Reconhecer o fenômeno de aliasing em amostragem subamostrada, aplicando filtros anti-aliasing e calculando exemplos numéricos de frequências espúrias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Amostragem e Teorema de Nyquist",
                                  "subSteps": [
                                    "Revise o teorema de amostragem de Nyquist-Shannon: frequência de amostragem deve ser pelo menos 2x a frequência máxima do sinal.",
                                    "Estude a relação entre sinal contínuo x(t) e discreto x[n] = x(nTs), onde Ts é o período de amostragem.",
                                    "Analise o espectro de frequência e como a subamostragem causa sobreposição espectral.",
                                    "Derive a fórmula para frequência de Nyquist: f_N = fs/2.",
                                    "Discuta condições para amostragem sem distorção."
                                  ],
                                  "verification": "Resuma em 3 frases o teorema de Nyquist e dê um exemplo numérico de fs inadequada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim), vídeo Khan Academy sobre Nyquist",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Visualize espectros com gráficos para intuitivamente entender a sobreposição.",
                                  "learningObjective": "Compreender as bases teóricas que levam ao aliasing em amostragem subamostrada.",
                                  "commonMistakes": [
                                    "Confundir frequência de amostragem com Nyquist",
                                    "Ignorar componentes de alta frequência em sinais reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer o Fenômeno de Aliasing em Sinais Subamostrados",
                                  "subSteps": [
                                    "Gere sinais senoidais com frequências variadas (ex: 10 Hz, 50 Hz, 120 Hz).",
                                    "Amostre com fs < 2*f_max e plote o sinal discreto.",
                                    "Identifique distorções visuais onde alta frequência 'finge' ser baixa.",
                                    "Use FFT para visualizar espectro e detectar picos espúrios.",
                                    "Compare amostragem adequada vs. subamostrada lado a lado."
                                  ],
                                  "verification": "Identifique aliasing em um gráfico fornecido de sinal amostrado e explique o fenômeno observado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python (SciPy, NumPy)",
                                    "Exemplos de sinais de vibração aeronáutica"
                                  ],
                                  "tips": "Sempre normalize frequências pela fs para análise relativa (f/fs).",
                                  "learningObjective": "Visual e analiticamente reconhecer aliasing em dados amostrados.",
                                  "commonMistakes": [
                                    "Atribuir aliasing a ruído em vez de subamostragem",
                                    "Não plotar espectro de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Frequências Espúrias (Aliases)",
                                  "subSteps": [
                                    "Aprenda a fórmula de aliasing: f_alias = |f - k*fs| para k inteiro mais próximo onde f_alias < fs/2.",
                                    "Calcule manualmente para f=120 Hz, fs=100 Hz (alias em 20 Hz).",
                                    "Implemente função em código para múltiplos k e encontre o alias principal.",
                                    "Teste com sinal composto (múltiplas senoides) e isole aliases.",
                                    "Valide cálculos com simulação e FFT."
                                  ],
                                  "verification": "Calcule e justifique o alias principal para f=250 Hz, fs=300 Hz.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Python script",
                                    "Tabela de frequências de teste"
                                  ],
                                  "tips": "Comece com k=0,1,2; o alias é o menor valor absoluto abaixo de fs/2.",
                                  "learningObjective": "Dominar cálculos numéricos precisos de frequências espúrias.",
                                  "commonMistakes": [
                                    "Escolher k errado, levando a alias incorreto",
                                    "Esquecer módulo absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Filtros Anti-Aliasing para Mitigação",
                                  "subSteps": [
                                    "Estude filtros low-pass: atenuam f > fs/2.",
                                    "Projete filtro simples (Butterworth ordem 4, fc=fs/2).",
                                    "Aplique filtro ao sinal contínuo antes da amostragem simulada.",
                                    "Compare espectros antes/depois para verificar remoção de aliases.",
                                    "Discuta trade-offs: distorção de fase vs. atenuação."
                                  ],
                                  "verification": "Desenhe diagrama de fluxo: sinal -> filtro -> amostrador, e simule redução de aliasing.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB Signal Processing Toolbox ou Python SciPy.signal",
                                    "Documentação de filtros digitais"
                                  ],
                                  "tips": "Use fc = 0.45*fs para margem de segurança contra roll-off.",
                                  "learningObjective": "Implementar soluções práticas para prevenir aliasing em sistemas reais.",
                                  "commonMistakes": [
                                    "Filtro com fc > fs/2, ineficaz",
                                    "Aplicar filtro após amostragem"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sensor de vibração de asa de aeronave medindo frequências até 200 Hz, use fs=300 Hz sem filtro: sinal de 250 Hz aliás para 50 Hz, confundindo com modo estrutural real. Aplique filtro low-pass fc=140 Hz antes da amostragem; simule em Python: gere x(t)=sin(2*pi*250*t), filtre, amostre e confirme ausência de pico espúrio em FFT.",
                              "finalVerifications": [
                                "Explicar corretamente o teorema de Nyquist com exemplo numérico.",
                                "Identificar aliasing em gráfico de sinal amostrado subamostrado.",
                                "Calcular alias principal para 3 cenários dados (ex: f=180 Hz, fs=200 Hz).",
                                "Simular e plotar espectro pós-filtro anti-aliasing mostrando mitigação.",
                                "Discutir limitações de filtros em sinais não estacionários.",
                                "Projetar fs e fc mínimos para sinal de banda 0-500 Hz."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição e causas de aliasing (30%)",
                                "Habilidade numérica: cálculos de aliases corretos (25%)",
                                "Implementação prática: simulações funcionais sem erros (20%)",
                                "Análise espectral: interpretação correta de FFT (15%)",
                                "Criatividade em mitigação: propostas viáveis além do básico (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e séries trigonométricas para espectros.",
                                "Programação: Simulações em Python/MATLAB para processamento de sinais.",
                                "Física: Ondas mecânicas e vibrações em estruturas aeronáuticas.",
                                "Engenharia de Controle: Prevenção de erros em laços de feedback.",
                                "Estatística: Análise de ruído e filtros em dados experimentais."
                              ],
                              "realWorldApplication": "Em telemetria de voo, sensores de aceleração em aeronaves capturam vibrações; aliasing pode mascarar falhas estruturais como flutter, levando a decisões erradas em controle de voo. Filtros anti-aliasing garantem dados fiéis, essenciais para certificação FAA e segurança operacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Realizar Amostragem Prática",
                            "description": "Implementar o processo de amostragem em software como MATLAB ou Python, gerando sequências discretas a partir de sinais contínuos como senoide ou ruído.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Definir Parâmetros de Amostragem",
                                  "subSteps": [
                                    "Instalar ou abrir MATLAB/Python com bibliotecas necessárias (numpy, matplotlib para Python; Signal Processing Toolbox para MATLAB).",
                                    "Definir parâmetros do sinal contínuo: frequência fundamental f (ex: 5 Hz), amplitude (ex: 1), duração T (ex: 2s).",
                                    "Escolher frequência de amostragem fs (ex: 20 Hz > 2f para satisfazer Nyquist; outra fs < 2f para demonstrar aliasing).",
                                    "Definir vetor tempo contínuo t = linspace(0, T, num_pontos_altos).",
                                    "Calcular taxa de amostragem Ts = 1/fs e vetor tempo discreto."
                                  ],
                                  "verification": "Ambiente pronto, parâmetros impressos no console sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB ou Python (Anaconda/Jupyter), bibliotecas numpy, scipy, matplotlib"
                                  ],
                                  "tips": "Use fs pelo menos 2.5x f para amostragem sem aliasing inicialmente.",
                                  "learningObjective": "Entender e configurar parâmetros fundamentais para amostragem.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas",
                                    "Escolher fs muito baixa sem intenção de demonstrar aliasing",
                                    "Usar tempo discreto incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Sinal Contínuo (Senoide ou Ruído)",
                                  "subSteps": [
                                    "Gerar sinal senoide: x(t) = A * sin(2*pi*f*t).",
                                    "Adicionar ruído se desejado: x(t) += 0.1 * randn(size(t)).",
                                    "Plotar sinal contínuo vs tempo para visualização inicial.",
                                    "Salvar sinal em variável para uso posterior.",
                                    "Verificar amplitude e frequência no gráfico."
                                  ],
                                  "verification": "Gráfico do sinal contínuo exibe oscilações corretas com período 1/f.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Funções sin() em MATLAB/Python"
                                  ],
                                  "tips": "Normalize amplitude para 1 para facilitar análise.",
                                  "learningObjective": "Sintetizar sinais contínuos representativos.",
                                  "commonMistakes": [
                                    "Erro em 2*pi*f (usar pi ao invés de 2*pi)",
                                    "Gráfico sem labels de eixos",
                                    "Duração T muito curta para múltiplos ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Amostragem e Gerar Sequência Discreta",
                                  "subSteps": [
                                    "Criar vetor tempo discreto: td = 0:Ts:T-Ts.",
                                    "Amostrar sinal: xd[n] = x(td).",
                                    "Interpolação zero-order hold ou nearest se necessário para visualização.",
                                    "Plotar sinal contínuo e pontos discretos no mesmo gráfico (stem para xd).",
                                    "Comparar com fs diferente para observar aliasing."
                                  ],
                                  "verification": "Sequência discreta xd tem comprimento N = T/Ts +1 e valores coincidem com x nos pontos td.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções linspace(), interp1() em MATLAB; np.linspace(), np.interp() em Python"
                                  ],
                                  "tips": "Use hold on para sobrepor plots; markers 'o' para pontos discretos.",
                                  "learningObjective": "Executar amostragem prática gerando xd[n] de x(t).",
                                  "commonMistakes": [
                                    "Índices errados em td (off-by-one)",
                                    "Não escalar eixos corretamente",
                                    "Confundir fs com Ts"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Verificar Resultados da Amostragem",
                                  "subSteps": [
                                    "Calcular FFT de xd e plotar espectro para verificar frequência.",
                                    "Comparar espectros com fs >2f e fs<2f mostrando aliasing.",
                                    "Medir erro de amostragem (MSE entre original interpolado e xd).",
                                    "Exportar gráficos e dados para relatório.",
                                    "Documentar observações sobre Nyquist."
                                  ],
                                  "verification": "Gráficos mostram ausência de aliasing quando fs>2f; relatório salvo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "fft() em MATLAB/Python, funções de plot espectral"
                                  ],
                                  "tips": "Use windowing (hanning) para FFT mais limpa.",
                                  "learningObjective": "Avaliar qualidade da amostragem via visualização e métricas.",
                                  "commonMistakes": [
                                    "FFT sem normalização",
                                    "Ignorar aliasing em fs baixa",
                                    "Plots sem legendas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: Gere x(t) = sin(2*pi*5*t) por 2s, amostre com fs=20Hz (sem aliasing) e fs=8Hz (com aliasing). Plote ambos e observe frequência aparente dobrada em fs baixa.",
                              "finalVerifications": [
                                "Código executa sem erros e gera xd corretamente.",
                                "Gráficos mostram sinal contínuo e discreto sobrepostos.",
                                "Aliasing demonstrado com fs < 2f.",
                                "Espectro FFT confirma preservação de frequência.",
                                "Relatório com prints e análises salvo.",
                                "Parâmetros atendem teorema de Nyquist-Shannon."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de xd[n] (erro <1%).",
                                "Visualizações claras com labels, legends e escalas adequadas.",
                                "Demonstração correta de aliasing.",
                                "Uso eficiente de código (vetorizado, sem loops desnecessários).",
                                "Análise quantitativa (MSE, FFT peaks).",
                                "Documentação de código com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teorema de Nyquist e séries de Fourier.",
                                "Programação: Manipulação de arrays e plotting.",
                                "Física: Ondas e sinais em dinâmica de sistemas.",
                                "Engenharia de Controle: Aquisição de dados em aeronaves.",
                                "Processamento de Sinais: Pré-processamento para DFT."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, amostragem de sinais de sensores (acelerômetros, giroscópios) em flight data recorders para análise de vibrações e identificação de sistemas dinâmicos, evitando aliasing em controle de voo autônomo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Janelamento de Sinais Discretos",
                        "description": "Técnica de multiplicação de sinais por funções janela para reduzir vazamento espectral na análise de Fourier.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Entender o Efeito de Vazamento Espectral",
                            "description": "Descrever como sinais finitos causam vazamento na DFT e a necessidade de janelamento para melhorar a resolução espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da DFT e Sinais Finitos",
                                  "subSteps": [
                                    "Estudar a definição da Transformada Discreta de Fourier (DFT) como soma de exponenciais complexas.",
                                    "Analisar como sinais reais são infinitos no tempo, mas truncados para N amostras na prática.",
                                    "Explorar a relação entre duração finita do sinal e resolução espectral (Δf = fs/N).",
                                    "Visualizar graficamente um sinal senoidal infinito vs. truncado.",
                                    "Calcular manualmente a DFT de um sinal senoidal simples com N=8."
                                  ],
                                  "verification": "Resolver um exercício simples de DFT manual e comparar com software.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro-texto de Sinais e Sistemas, MATLAB ou Python (numpy.fft), calculadora.",
                                  "tips": "Comece com sinais periódicos para facilitar a compreensão inicial.",
                                  "learningObjective": "Explicar como a truncagem de sinais afeta a representação espectral.",
                                  "commonMistakes": "Confundir DFT com FFT ou ignorar o impacto da periodicidade assumida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Efeito de Vazamento Espectral",
                                  "subSteps": [
                                    "Definir vazamento espectral como a dispersão de energia espectral para bins adjacentes devido à truncagem.",
                                    "Estudar a convolução da espectro verdadeiro com o núcleo de Dirichlet (sinc).",
                                    "Gerar um sinal senoidal com frequência não múltipla de Δf e computar sua DFT.",
                                    "Observar os lóbulos laterais no espectro e medir a atenuação.",
                                    "Comparar com sinal perfeitamente periódico (frequência exata em bin)."
                                  ],
                                  "verification": "Plotar espectros e identificar picos espúrios em pelo menos dois exemplos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python (matplotlib, scipy.signal), exemplos de código prontos para DFT.",
                                  "tips": "Use frequências como 1.3 * Δf para exagerar o vazamento.",
                                  "learningObjective": "Reconhecer visual e matematicamente o vazamento em espectros DFT.",
                                  "commonMistakes": "Atribuir vazamento apenas a ruído, ignorando a causa principal (truncagem)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar o Impacto na Resolução Espectral",
                                  "subSteps": [
                                    "Simular dois tons próximos (ex: 10 Hz e 11 Hz) com N baixo para mostrar sobreposição.",
                                    "Aumentar N e observar melhoria parcial, mas persistência do vazamento.",
                                    "Quantificar resolução efetiva usando métricas como largura de meia potência.",
                                    "Analisar SNR degradado devido a vazamento em sinais com ruído.",
                                    "Discutir limitações inerentes da DFT para sinais não-periódicos."
                                  ],
                                  "verification": "Gerar plots comparativos e anotar diferenças qualitativas/quantitativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Jupyter Notebook com scripts de simulação, osciloscópio virtual (opcional).",
                                  "tips": "Fixe fs=1000 Hz e varie N de 64 a 1024 para visualização clara.",
                                  "learningObjective": "Avaliar como vazamento mascara resolução em análises reais.",
                                  "commonMistakes": "Acreditar que mais amostras eliminam completamente o vazamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir Janelamento como Solução",
                                  "subSteps": [
                                    "Explicar janelamento como multiplicação por função taper (ex: Hamming, Hanning).",
                                    "Derivar matematicamente o efeito: convolução com núcleo da janela.",
                                    "Aplicar janelas em simulações anteriores e comparar espectros.",
                                    "Estudar trade-offs: redução de vazamento vs. alargamento do lóbulo principal.",
                                    "Escolher e justificar janela baseada em aplicação (ex: Hamming para boa atenuação)."
                                  ],
                                  "verification": "Recomputar DFTs com janelas e demonstrar melhoria em resolução.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Funções window() no scipy.signal ou MATLAB window(), planilhas comparativas.",
                                  "tips": "Teste múltiplas janelas (retangular, Hamming, Blackman) no mesmo sinal.",
                                  "learningObjective": "Aplicar janelamento para mitigar vazamento e analisar seus efeitos.",
                                  "commonMistakes": "Aplicar janela sem normalizar ou confundir com filtragem."
                                }
                              ],
                              "practicalExample": "Em um teste de vibração de uma hélice de aeronave, amostre o sinal de aceleração por 1 segundo (N=1024, fs=1024 Hz). Sem janelamento, o pico em 50 Hz vaza para bins vizinhos, mascarando uma falha em 51 Hz. Aplicando Hamming, o vazamento reduz, permitindo detectar ambas as frequências e diagnosticar desbalanceamento.",
                              "finalVerifications": [
                                "Explicar verbalmente a causa do vazamento espectral em DFT.",
                                "Gerar e interpretar espectro de sinal finito sem/com janelamento.",
                                "Identificar em plot quando janelamento melhora a análise.",
                                "Calcular resolução espectral e impacto do vazamento.",
                                "Discutir limitações do janelamento em cenários reais.",
                                "Comparar diferentes janelas em um exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática do vazamento (convolução sinc).",
                                "Qualidade dos plots gerados (rótulos, escalas corretas).",
                                "Correta identificação de trade-offs do janelamento.",
                                "Aplicação prática em exemplo aeronáutico.",
                                "Profundidade na análise de erros comuns evitados.",
                                "Capacidade de justificar escolha de janela."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e funções janela (sinc, taper).",
                                "Processamento de Sinais: Aplicações em áudio e radar.",
                                "Engenharia Mecânica: Análise de vibrações em estruturas.",
                                "Física: Ondas e interferência espectral.",
                                "Computação: Implementação eficiente de FFT e janelas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, entender vazamento espectral é crucial para análise de dados de testes de fadiga em asas ou fuselagens, onde janelamento permite detectar modos de vibração precisos, evitando falsos positivos em certificações de segurança (ex: FAA requirements para monitoramento espectral em voo)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Aplicar Janelas Comuns",
                            "description": "Comparar e aplicar janelas retangular, Hamming, Hanning e Blackman em sinais discretos, analisando seus impactos na largura de lóbulo principal e atenuação lateral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Teóricos das Janelas Comuns",
                                  "subSteps": [
                                    "Estude a definição e fórmula da janela retangular: w[n] = 1 para 0 ≤ n ≤ N-1.",
                                    "Analise as fórmulas das janelas Hamming: w[n] = 0.54 - 0.46*cos(2πn/(N-1)), Hanning: w[n] = 0.5*(1 - cos(2πn/(N-1))) e Blackman: w[n] = 0.42 - 0.5*cos(2πn/(N-1)) + 0.08*cos(4πn/(N-1)).",
                                    "Compreenda os trade-offs: janela retangular tem lóbulo principal estreito mas altos sidelobes; outras reduzem sidelobes ao custo de alargamento do mainlobe.",
                                    "Identifique métricas chave: largura do lóbulo principal (em bins de frequência) e atenuação dos primeiros sidelobes (em dB).",
                                    "Compare graficamente as formas das janelas para N=64 pontos."
                                  ],
                                  "verification": "Crie gráficos das quatro janelas e anote as características principais em um relatório curto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de processamento de sinais, MATLAB/Python com bibliotecas numpy/scipy/signal, papel e caneta para anotações.",
                                  "tips": "Use log scale para visualizar sidelobes melhor.",
                                  "learningObjective": "Entender as diferenças matemáticas e espectrais entre janelas comuns.",
                                  "commonMistakes": "Confundir fórmulas de Hanning e Hamming; ignorar normalização das janelas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Funções de Janelamento em Software",
                                  "subSteps": [
                                    "Escreva funções personalizadas em Python/MATLAB para gerar cada janela (retangular, Hamming, Hanning, Blackman) dado N.",
                                    "Teste as funções com N=64 e plote as janelas resultantes.",
                                    "Verifique a soma das amostras da janela (energia) e normalize se necessário para comparação justa.",
                                    "Implemente uma função genérica que aplique qualquer janela a um sinal discreto x[n].",
                                    "Salve as funções em um script reutilizável."
                                  ],
                                  "verification": "Execute o script e confirme que os gráficos das janelas coincidem com referências padrão (ex: scipy.signal.windows).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ambiente Python (Jupyter Notebook) ou MATLAB, documentação de signal processing.",
                                  "tips": "Use vetores numpy eficientes; evite loops desnecessários.",
                                  "learningObjective": "Desenvolver código para geração e aplicação de janelas.",
                                  "commonMistakes": "Índices errados em loops (off-by-one); não normalizar janelas antes de comparação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Janelas a um Sinal Discreto e Computar DFT",
                                  "subSteps": [
                                    "Gere um sinal discreto de teste: senoide de 100 Hz + ruído, amostrado a 1000 Hz por 0.1s (N=100 pontos).",
                                    "Aplique cada uma das quatro janelas ao sinal e compute a DFT (FFT) para cada caso.",
                                    "Plote os espectros de magnitude em dB vs. frequência normalizada.",
                                    "Identifique picos principais e sidelobes em cada espectro.",
                                    "Documente os resultados em uma tabela com largura do mainlobe e atenuação do primeiro sidelobe."
                                  ],
                                  "verification": "Confirme que o pico principal está na frequência correta (0.1 ciclos/amostra) em todos os casos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Mesmo ambiente de programação, sinal de teste gerado via código.",
                                  "tips": "Use fftshift para centralizar o espectro DC em zero.",
                                  "learningObjective": "Executar janelamento prático e visualização espectral.",
                                  "commonMistakes": "Não zerar-padded o sinal; plotar magnitude linear em vez de dB."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Impactos das Janelas",
                                  "subSteps": [
                                    "Meça quantitativamente: largura do lóbulo principal (FWHM em bins) e atenuação do primeiro sidelobe (dB abaixo do pico).",
                                    "Crie uma tabela comparativa para as quatro janelas.",
                                    "Discuta trade-offs: ex. retangular: mainlobe estreito (~2 bins), sidelobe -13 dB; Blackman: mainlobe largo (~4 bins), sidelobe -58 dB.",
                                    "Teste com sinal realista (ex: vibração com harmônicos) e reavalie.",
                                    "Conclua recomendações baseadas em cenários (ex: Blackman para baixa sidelobe)."
                                  ],
                                  "verification": "Relatório com tabela, gráficos sobrepostos e conclusões validadas contra literatura.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou LaTeX para tabela, referências bibliográficas.",
                                  "tips": "Automatize medições com detecção de picos via scipy.find_peaks.",
                                  "learningObjective": "Interpretar e quantificar efeitos espectrais das janelas.",
                                  "commonMistakes": "Medir largura incorretamente (não usar -3dB); ignorar vazamento espectral sem janela."
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma hélice de aeronave, aplique janelas a dados amostrados de acelerômetros para isolar frequências de rotação (ex: 50 Hz) sem interferência de sidelobes em harmônicos estruturais.",
                              "finalVerifications": [
                                "Gráficos corretos das formas das janelas e espectros janelados.",
                                "Tabela comparativa precisa de mainlobe width e sidelobe attenuation.",
                                "Código funcional e comentado para reprodução.",
                                "Recomendações contextualizadas para sinais de engenharia aeronáutica.",
                                "Análise de trade-offs demonstrada em sinal com ruído.",
                                "Verificação contra funções built-in (ex: scipy.signal.get_window)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas e implementações (100% match com padrões).",
                                "Qualidade dos gráficos e medições quantitativas (erro <5%).",
                                "Profundidade da análise de trade-offs.",
                                "Clareza e completude do relatório.",
                                "Criatividade no exemplo prático aeronáutico.",
                                "Eficiência do código (tempo de execução <1s para N=1024)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e funções trigonométricas.",
                                "Programação: NumPy/SciPy para computação científica.",
                                "Física: Análise de vibrações e ondas em sistemas dinâmicos.",
                                "Estatística: Redução de leakage em estimação espectral."
                              ],
                              "realWorldApplication": "Na manutenção preditiva de aeronaves, janelas como Blackman são usadas em FFT de dados de sensores para detectar falhas em rotores com alta atenuação de sidelobes, evitando falsos alarmes em frequências próximas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Avaliar Trade-offs de Janelas",
                            "description": "Selecionar a janela apropriada para cenários específicos, como detecção de frequência ou medição de amplitude, com cálculos de resolução e distorção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Janelamento em DFT",
                                  "subSteps": [
                                    "Explicar o problema de leakage espectral na DFT sem janelamento.",
                                    "Descrever como funções de janela multiplicam o sinal no domínio do tempo para reduzir leakage.",
                                    "Identificar trade-offs principais: resolução de frequência vs. distorção espectral.",
                                    "Revisar a convolução no domínio da frequência causada pelo janelamento.",
                                    "Listar janelas comuns: Rectangular, Hann, Hamming, Blackman."
                                  ],
                                  "verification": "Resumir em um diagrama os efeitos de uma janela Rectangular vs. Hann em um sinal senoidal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de texto sobre processamento de sinais, software MATLAB ou Python (SciPy/NumPy).",
                                  "tips": "Visualize sempre no domínio da frequência para entender impactos.",
                                  "learningObjective": "Compreender por que janelas são necessárias e seus trade-offs básicos.",
                                  "commonMistakes": "Confundir janelamento com filtragem; ignorar que toda janela causa algum alargamento do lóbulo principal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedades das Janelas Comuns",
                                  "subSteps": [
                                    "Calcular e plotar as respostas em frequência de janelas: Rectangular (alta resolução, alto leakage), Hann (bom equilíbrio).",
                                    "Medir largura do lóbulo principal em bins de frequência (ex: 3 dB bandwidth).",
                                    "Determinar pico do primeiro lóbulo lateral em dB para cada janela.",
                                    "Comparar tabelas de propriedades: resolução, atenuação lateral, processamento equivalente.",
                                    "Simular aplicação em sinal com múltiplas frequências próximas."
                                  ],
                                  "verification": "Criar tabela comparativa com métricas para 4 janelas em um sinal teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python com bibliotecas signal/fft, planilha Excel para tabelas.",
                                  "tips": "Use log scale (dB) para visualizar lóbulos laterais claramente.",
                                  "learningObjective": "Identificar propriedades quantitativas de janelas comuns.",
                                  "commonMistakes": "Usar escala linear em magnitude espectral, mascarando leakage."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Métricas de Trade-off",
                                  "subSteps": [
                                    "Definir fórmulas: resolução Δf = largura lóbulo principal / N (N= comprimento sinal).",
                                    "Calcular distorção como atenuação máxima dos lóbulos laterais em dB.",
                                    "Quantificar scalloping loss e picket fence effect para cenários discretos.",
                                    "Avaliar processamento equivalente (ruído equivalente bandwidth).",
                                    "Implementar script para computar essas métricas automaticamente."
                                  ],
                                  "verification": "Executar script em sinal sintético e validar cálculos contra valores teóricos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python/MATLAB template para DFT e janelas, calculadora científica.",
                                  "tips": "Normalize janelas para soma unitária ao comparar amplitudes.",
                                  "learningObjective": "Dominar cálculos precisos de resolução e distorção.",
                                  "commonMistakes": "Esquecer normalização da janela, levando a erros em amplitude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Janelas para Cenários Específicos",
                                  "subSteps": [
                                    "Para detecção de frequência: priorizar alta resolução (Rectangular/Hann).",
                                    "Para medição de amplitude precisa: baixa distorção (Blackman).",
                                    "Avaliar trade-offs em cenários: sinais tonais isolados vs. multifrequência.",
                                    "Criar fluxograma de decisão baseado em requisitos (resolução > X Hz, leakage < Y dB).",
                                    "Testar seleções em simulações variadas."
                                  ],
                                  "verification": "Justificar escolha de janela para 3 cenários hipotéticos com cálculos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Fluxogramas em papel ou Draw.io, simulações prévias.",
                                  "tips": "Considere custo computacional para janelas complexas em tempo real.",
                                  "learningObjective": "Aplicar trade-offs para seleção otimizada.",
                                  "commonMistakes": "Ignorar contexto do sinal (ex: usar Hann para sinal DC)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Análise Prática",
                                  "subSteps": [
                                    "Gerar sinal realista (ex: vibração com ruído).",
                                    "Aplicar múltiplas janelas e comparar espectros.",
                                    "Medir erros em frequência estimada e amplitude.",
                                    "Otimizar janela iterativamente baseado em métricas.",
                                    "Documentar conclusões em relatório curto."
                                  ],
                                  "verification": "Relatório com plots e tabela de performance para diferentes janelas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de simulação, dados de vibração aeronáutica sample.",
                                  "tips": "Use overlap em STFT para validação robusta.",
                                  "learningObjective": "Integrar todos conceitos em prática hands-on.",
                                  "commonMistakes": "Não incluir ruído realista, subestimando leakage."
                                }
                              ],
                              "practicalExample": "Em teste de vibração de asa de aeronave, sinal de aceleração com frequências próximas (modo 1: 50 Hz, modo 2: 55 Hz). Use Rectangular para alta resolução e separar modos; Hann para reduzir leakage de harmônicos altos sem sacrificar muito resolução.",
                              "finalVerifications": [
                                "Plotar espectro com/ sem janela mostrando redução de leakage.",
                                "Calcular erro de frequência < 0.1 bin para sinal isolado.",
                                "Verificar amplitude precisa dentro de 1 dB para pico principal.",
                                "Tabela de trade-offs preenchida corretamente para 4 janelas.",
                                "Fluxograma de decisão funcional para 3 cenários.",
                                "Relatório prático com simulação validada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de resolução e distorção (erro <5%).",
                                "Correta identificação de trade-offs para cenários dados.",
                                "Qualidade dos plots e tabelas (legendas, escalas adequadas).",
                                "Justificativa lógica na seleção de janelas.",
                                "Integração de substeps em análise coesa.",
                                "Ausência de erros comuns como normalização incorreta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e convolução.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Modelagem de vibrações em estruturas aeronáuticas.",
                                "Estatística: Análise de ruído e processamento equivalente."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, avaliar trade-offs de janelas é crucial para análise de telemetria de voo, detecção de flutter em asas (alta resolução para modos próximos) e monitoramento de fadiga estrutural (baixa distorção para amplitudes precisas), otimizando sistemas de controle dinâmico em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Transformada Discreta de Fourier (DFT)",
                        "description": "Representação espectral de sequências discretas finitas, suas propriedades e métodos de computação eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Definir e Calcular a DFT",
                            "description": "Formular a equação da DFT e IDFT, computando manualmente para sequências curtas e interpretando o espectro de magnitude e fase.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular as Equações da DFT e IDFT",
                                  "subSteps": [
                                    "Revise a definição matemática da Transformada Discreta de Fourier (DFT) para uma sequência x[n] de comprimento N: X[k] = ∑_{n=0}^{N-1} x[n] * e^{-j*2π*k*n/N}, para k=0 a N-1.",
                                    "Derive ou memorize a equação da Transformada Inversa Discreta de Fourier (IDFT): x[n] = (1/N) * ∑_{k=0}^{N-1} X[k] * e^{j*2π*k*n/N}, para n=0 a N-1.",
                                    "Identifique os componentes: soma, exponencial complexa, fatores de normalização e índices.",
                                    "Escreva as equações em um papel ou editor, destacando diferenças entre DFT e IDFT.",
                                    "Explique verbalmente ou por escrito o papel de cada termo na equação."
                                  ],
                                  "verification": "Escreva as equações completas sem consultar materiais e confira com uma referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use notação Euler para exponenciais complexas: e^{jθ} = cosθ + j sinθ, para visualizar melhor.",
                                  "learningObjective": "Compreender e reproduzir precisamente as fórmulas matemáticas da DFT e IDFT.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/N na IDFT",
                                    "Confundir o sinal do expoente (-j vs +j)",
                                    "Índices errados (k e n de 0 a N-1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar DFT Manualmente para Sequência Curta (N=4)",
                                  "subSteps": [
                                    "Escolha uma sequência simples: x[n] = [1, 0, -1, 0] para n=0 a 3.",
                                    "Calcule X[0]: soma de todos x[n] (componente DC).",
                                    "Calcule X[1]: ∑ x[n] * e^{-j*2π*1*n/4} = ∑ x[n] * (-j)^n.",
                                    "Calcule X[2] e X[3] seguindo a fórmula, usando ângulos: para k=2, e^{-j*π*n} = (-1)^n.",
                                    "Registre todos os valores complexos X[k] em forma retangular (real + imag j)."
                                  ],
                                  "verification": "Compare resultados com cálculo via software (ex: MATLAB fft(x)) para exatidão numérica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de valores de e^{jθ} para θ comuns",
                                    "Calculadora com funções trigonométricas"
                                  ],
                                  "tips": "Precalcule os twiddle factors W_N^{kn} = e^{-j*2π*kn/N} para N=4: 1, -j, -1, j.",
                                  "learningObjective": "Executar cálculo manual da DFT para sequências de 4 pontos com precisão.",
                                  "commonMistakes": [
                                    "Erros em cálculos trigonométricos (ex: cos(π/2)=0, não 1)",
                                    "Soma incorreta de componentes reais/imaginários",
                                    "Esquecer de normalizar ângulos em radianos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar com Cálculo da IDFT",
                                  "subSteps": [
                                    "Usando os X[k] do passo anterior, aplique a IDFT para recuperar x[n].",
                                    "Para cada n=0 a 3, compute (1/4) * ∑ X[k] * e^{j*2π*k*n/4}.",
                                    "Some componentes reais e imaginários, verificando que partes imaginárias sejam ~0 e reais iguais a x[n] original.",
                                    "Analise discrepâncias devidas a arredondamentos e ajuste precisão.",
                                    "Repita para uma segunda sequência, ex: x[n]=[1,1,1,1], para validar."
                                  ],
                                  "verification": "Os valores recuperados de x[n] devem coincidir com o original dentro de 0.01 de erro.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Resultados do passo 2",
                                    "Mesma calculadora e tabelas"
                                  ],
                                  "tips": "A IDFT é quase simétrica à DFT; inverta o sinal do expoente e divida por N.",
                                  "learningObjective": "Demonstrar a invertibilidade da DFT via IDFT manual.",
                                  "commonMistakes": [
                                    "Esquecer o 1/N",
                                    "Usar expoente errado (+j vs -j)",
                                    "Não zerar parte imaginária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Espectro de Magnitude e Fase",
                                  "subSteps": [
                                    "Para os X[k] calculados, compute magnitude |X[k]| = sqrt(Re^2 + Im^2).",
                                    "Compute fase arg(X[k]) = atan2(Im, Re) em graus ou radianos.",
                                    "Plote |X[k]| vs k (espectro de magnitude) e arg(X[k]) vs k (espectro de fase).",
                                    "Interprete: magnitude indica amplitude de frequência k/N*fs; fase indica deslocamento.",
                                    "Relacione com o sinal original: ex: para x=[1,0,-1,0], picos em DC e Nyquist."
                                  ],
                                  "verification": "Descreva em 3-5 frases o que o espectro revela sobre o sinal temporal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráficos em papel",
                                    "Software como Python/MATLAB para plot opcional"
                                  ],
                                  "tips": "Use |X[k]| para energia por bin de frequência; ignore fase para sinais reais simétricos.",
                                  "learningObjective": "Extrair e interpretar informações físicas do espectro de frequência.",
                                  "commonMistakes": [
                                    "Confundir magnitude com potência (use |X[k]|^2 para PSD)",
                                    "Fase em intervalos errados (-π a π)",
                                    "Não normalizar frequência (k/N)"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a DFT de um sinal de vibração simulada em uma asa de aeronave: x[n] = [1, 0.5, 0, -0.5] representando deslocamentos em 4 amostras. Interprete picos de magnitude como modos de flutter críticos.",
                              "finalVerifications": [
                                "Formulação correta de DFT/IDFT sem erros.",
                                "Cálculo manual exato para N=4 com verificação via IDFT.",
                                "Interpretação precisa de magnitude (amplitudes) e fase (deslocamentos).",
                                "Explicação verbal do processo para um par.",
                                "Aplicação a um exemplo novo sem assistência.",
                                "Gráficos de espectro com legendas corretas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: 100% nos cálculos manuais.",
                                "Compreensão conceitual: explicação clara de twiddle factors e periodicidade.",
                                "Profundidade de interpretação: ligação entre domínio tempo e frequência.",
                                "Eficiência: conclusão dentro de tempo estimado com verificações.",
                                "Criatividade: extensão a sinal real de engenharia aeronáutica.",
                                "Clareza na documentação: passos numerados e anotações."
                              ],
                              "crossCurricularConnections": [
                                "Processamento Digital de Sinais: base para filtros e análise espectral em sistemas de controle.",
                                "Matemática: análise complexa e séries de Fourier.",
                                "Programação: implementação em Python (numpy.fft) para automação.",
                                "Física: ondas e vibrações em estruturas aeronáuticas.",
                                "Engenharia de Controle: identificação de sistemas via espectro."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a DFT é usada para analisar dados de acelerômetros em testes de vibração, detectando frequências ressonantes que podem causar fadiga estrutural ou flutter em asas, permitindo otimização de design antes de voos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Explorar Propriedades da DFT",
                            "description": "Aplicar propriedades como linearidade, simetria, shift circular e convolução, demonstrando com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Demonstrar a Propriedade de Linearidade da DFT",
                                  "subSteps": [
                                    "Revise a definição matemática da DFT: X[k] = sum_{n=0}^{N-1} x[n] e^{-j2πkn/N}.",
                                    "Escolha dois sinais discretos simples, como x1[n] = [1, 0, 0, 0] e x2[n] = [0, 1, 0, 0], e compute suas DFTs individualmente.",
                                    "Calcule a DFT de a*x1[n] + b*x2[n] para coeficientes a=2, b=3.",
                                    "Verifique se DFT(a*x1 + b*x2) = a*DFT(x1) + b*DFT(x2) numericamente.",
                                    "Implemente em Python usando NumPy para automatizar os cálculos."
                                  ],
                                  "verification": "Compare os resultados numéricos das DFTs somadas versus a soma das DFTs; erro deve ser < 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter",
                                    "Documentação DFT NumPy"
                                  ],
                                  "tips": "Use vetores pequenos (N=4 ou 8) para cálculos manuais iniciais antes de programar.",
                                  "learningObjective": "Compreender e verificar matematicamente a linearidade da DFT com exemplos numéricos.",
                                  "commonMistakes": [
                                    "Confundir índices circulares",
                                    "Esquecer normalização na DFT inversa",
                                    "Erros de fase nos expoentes complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Propriedade de Simetria da DFT",
                                  "subSteps": [
                                    "Estude simetria para sinais reais: X[k] = conj(X[N-k]) para k=1 a N/2-1.",
                                    "Gere um sinal real aleatório de comprimento N=8 e compute sua DFT.",
                                    "Plote o módulo e fase, verificando simetria conjugada.",
                                    "Teste com sinal par e ímpar para observar diferenças no espectro.",
                                    "Confirme com código: assert np.allclose(X, np.conj(np.roll(X[::-1],1))) para sinais reais."
                                  ],
                                  "verification": "O espectro deve exibir simetria conjugada; fase antisimétrica e módulo simétrico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python NumPy/Matplotlib",
                                    "Sinais de teste gerados por np.random"
                                  ],
                                  "tips": "Sempre verifique se o sinal é real com np.isreal(x).all().",
                                  "learningObjective": "Identificar e demonstrar simetria no domínio da frequência para otimização computacional.",
                                  "commonMistakes": [
                                    "Ignorar wrap-around em roll",
                                    "Confundir simetria temporal com frequência",
                                    "Não usar precisão complexa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Propriedade de Shift Circular",
                                  "subSteps": [
                                    "Lembre: DFT(x[n - m mod N]) = X[k] * e^{-j2πkm/N}.",
                                    "Crie sinal x[n] = [1,2,3,4], compute DFT(X).",
                                    "Aplique shift circular de m=1 e m=2, compute DFTs e multiplique X[k] pelo fator de fase.",
                                    "Compare resultados diretos versus via multiplicação de fase.",
                                    "Visualize no tempo e frequência para entender o efeito de delay."
                                  ],
                                  "verification": "DFTs via shift devem coincidir com multiplicação de fase; erro absoluto < 1e-12.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com np.fft.fft e np.roll",
                                    "Gráficos de magnitude/fase"
                                  ],
                                  "tips": "Use np.angle() para inspecionar fases; shifts mod N evitam erros de índice.",
                                  "learningObjective": "Dominar shifts circulares para modelagem de delays em sistemas discretos.",
                                  "commonMistakes": [
                                    "Não modular shift por N",
                                    "Confundir shift left/right",
                                    "Esquecer fator de fase negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a Propriedade de Convolução via DFT",
                                  "subSteps": [
                                    "Revise: convolução circular x * h ↔ X[k] .* H[k].",
                                    "Gere dois sinais: impulse response h[n] e input x[n], ambos N=8, zero-pad se necessário.",
                                    "Compute convolução direta via np.convolve com mode='same'.",
                                    "Compute via DFT: ifft(fft(x) * fft(h)), compare.",
                                    "Analise erro e plote resultados no tempo para validação."
                                  ],
                                  "verification": "Erro RMS da convolução direta vs. DFT < 1e-10; formas coincidem.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy fft/ifft/convolve",
                                    "Exemplos de filtros FIR simples"
                                  ],
                                  "tips": "Zero-pad para N=2*len(x)-1 se convolução linear desejada, mas foque circular aqui.",
                                  "learningObjective": "Usar DFT para convolução eficiente, base para FFT rápida.",
                                  "commonMistakes": [
                                    "Não alinhar comprimentos",
                                    "Confundir circular com linear",
                                    "Ignorar scaling na IDFT"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de hélices aeronáuticas, aplique DFT linearidade para superpor sinais de sensores múltiplos; use shift circular para alinhar delays de propagação; convolução para modelar resposta ao filtro de ruído ambiental.",
                              "finalVerifications": [
                                "Implementar script Python que verifica todas propriedades com sinais aleatórios (sucesso 100%).",
                                "Explicar verbalmente como cada propriedade reduz complexidade computacional.",
                                "Resolver problema: dado X[k], recupere x[n] shifted e convoluído corretamente.",
                                "Gerar relatório com plots comparativos de todos exemplos.",
                                "Testar com N=16 sinal real de vibração simulada (ex: senoide amortecida)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todas verificações (<1e-10 erro).",
                                "Código limpo, comentado e reproduzível.",
                                "Explicações claras ligando matemática a implementações.",
                                "Uso correto de propriedades em exemplos compostos.",
                                "Identificação e correção de erros comuns demonstrados.",
                                "Plots informativos destacando propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais em Comunicações: Filtros digitais via convolução DFT.",
                                "Controle Automático: Identificação de sistemas via DFT de respostas impulsivas.",
                                "Processamento de Imagens: 2D DFT para shifts e simetria em visão computacional.",
                                "Física Computacional: Análise espectral de ondas em estruturas aeronáuticas.",
                                "Machine Learning: Feature extraction via DFT em séries temporais."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, propriedades DFT são usadas para análise de vibrações em testes de fadiga de asas, filtragem de ruído em telemetria de voo e identificação de modos dinâmicos em sistemas de controle de voo, acelerando simulações e reduzindo hardware via FFT eficiente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Implementar FFT para DFT Eficiente",
                            "description": "Utilizar o algoritmo Fast Fourier Transform (FFT) em ferramentas computacionais para analisar sinais longos, comparando tempo de execução com DFT direta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos de DFT e FFT",
                                  "subSteps": [
                                    "Estude a definição matemática da DFT e sua complexidade computacional O(N²).",
                                    "Analise o princípio do algoritmo FFT, baseado na decomposição em Cooley-Tukey, com complexidade O(N log N).",
                                    "Compare as diferenças em termos de eficiência para sinais longos (N > 1024).",
                                    "Revise propriedades da transformada de Fourier para sinais discretos.",
                                    "Identifique cenários onde FFT é essencial, como análise de sinais em tempo real."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras comparando DFT e FFT, incluindo fórmulas e complexidades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Documentação oficial SciPy FFT",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use diagramas de árvore para visualizar a decomposição FFT.",
                                  "learningObjective": "Compreender as bases matemáticas e a superioridade computacional da FFT sobre DFT direta.",
                                  "commonMistakes": [
                                    "Confundir DFT com DTFT",
                                    "Ignorar o requisito de N ser potência de 2 na FFT básica",
                                    "Subestimar impacto da complexidade para N grande"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Gerar Sinal de Teste",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: NumPy, SciPy e Matplotlib via pip.",
                                    "Gere um sinal discreto longo (N=2^16 pontos) simulando vibração aeronáutica: senoide com ruído gaussiano.",
                                    "Defina parâmetros: frequência de amostragem fs=1000 Hz, duração 65s.",
                                    "Salve o sinal em array NumPy e plote no tempo para visualização inicial.",
                                    "Teste reprodutibilidade do sinal com seed randômico."
                                  ],
                                  "verification": "Execute código e confirme gráfico do sinal com amplitude e ruído visíveis; N exato exibido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.8+",
                                    "Jupyter Notebook",
                                    "Bibliotecas: numpy, scipy, matplotlib"
                                  ],
                                  "tips": "Use N como potência de 2 para compatibilidade ótima com FFT.",
                                  "learningObjective": "Preparar dados realistas e ambiente computacional estável para experimentos.",
                                  "commonMistakes": [
                                    "Escolher N pequeno (não demonstra eficiência)",
                                    "Não normalizar sinal",
                                    "Omitir seed para reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar DFT Direta e Medir Tempo de Execução",
                                  "subSteps": [
                                    "Implemente DFT manual usando loops duplos: soma de x[n] * exp(-j*2*pi*k*n/N).",
                                    "Use timeit ou %timeit no Jupyter para medir tempo médio de 10 execuções.",
                                    "Registre tempo para diferentes N (2^10 a 2^16).",
                                    "Plote magnitude do espectro |DFT| vs frequência.",
                                    "Salve resultados em variáveis para comparação posterior."
                                  ],
                                  "verification": "Tempo medido >1s para N=2^16; espectro mostra picos na frequência do sinal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python customizado",
                                    "Funções timeit",
                                    "Gráficos Matplotlib"
                                  ],
                                  "tips": "Vetorize onde possível, mas mantenha O(N²) explícito para demonstração.",
                                  "learningObjective": "Implementar e quantificar ineficiência da DFT direta em sinais longos.",
                                  "commonMistakes": [
                                    "Usar np.fft.fft acidentalmente",
                                    "Não isolar tempo de computação",
                                    "Ignorar overhead de plotting"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar FFT, Comparar e Analisar Resultados",
                                  "subSteps": [
                                    "Aplique scipy.fft.fft() no mesmo sinal e meça tempo de execução similarmente.",
                                    "Compare espectros: erro relativo entre DFT e FFT <1e-10.",
                                    "Gere gráfico log-log de tempo vs N para ambos algoritmos.",
                                    "Calcule speedup (tempo_DFT / tempo_FFT) e discuta para N grande.",
                                    "Documente insights em relatório curto com conclusões."
                                  ],
                                  "verification": "Gráfico mostra speedup >100x para N=2^16; espectros sobrepostos perfeitamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy fft module",
                                    "Matplotlib para plots comparativos",
                                    "Pandas para tabela de tempos"
                                  ],
                                  "tips": "Use fftshift para centralizar espectro DC em 0.",
                                  "learningObjective": "Demonstrar eficiência prática da FFT e validar correção numérica.",
                                  "commonMistakes": [
                                    "Comparar apples-to-oranges (diferentes N)",
                                    "Não verificar normalização",
                                    "Omitir análise qualitativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere um sinal de vibração de motor aeronáutico (senoide 50Hz + harmônicos + ruído) com 65536 amostras. Compute DFT direta (lento, ~10s) vs FFT (instantâneo, <0.01s). Compare espectros para detectar picos de falha e confirme speedup de 1000x, simulando análise em tempo real de telemetria de voo.",
                              "finalVerifications": [
                                "Tempo de execução da FFT é pelo menos 100x menor que DFT para N=65536.",
                                "Espectros DFT e FFT coincidem com erro <1e-12 em norma L2.",
                                "Gráficos de tempo vs N mostram inclinação log-log confirmando complexidades O(N²) e O(N log N).",
                                "Código é modular, comentado e executável em Jupyter.",
                                "Relatório inclui speedup quantificado e discussão de limitações.",
                                "Sinal gerado reproduz vibração realista com fs=1000Hz."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da implementação DFT (teste unitário com sinal conhecido).",
                                "Correção e eficiência da medição temporal (média de múltiplas runs).",
                                "Qualidade visual dos gráficos (escalas log, legendas, sobreposições).",
                                "Análise quantitativa do speedup e interpretação física.",
                                "Documentação clara do código e relatório conclusivo.",
                                "Escalabilidade demonstrada variando N."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de NumPy/SciPy para computação científica.",
                                "Matemática Computacional: Análise de complexidade algorítmica.",
                                "Engenharia de Controle: Análise espectral para identificação de sistemas dinâmicos.",
                                "Física Aplicada: Processamento de sinais vibracionais em estruturas aeronáuticas.",
                                "Otimização: Trade-offs computacionais em aplicações em tempo real."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, FFT permite análise eficiente de sinais longos de acelerômetros em testes de fadiga estrutural ou monitoramento de vibrações em motores durante voo, detectando falhas precocemente sem sobrecarregar processadores embarcados, ao contrário da DFT direta que seria impraticável para dados de alta resolução."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.4",
                        "name": "Aplicação da DFT em Análise e Identificação Discreta",
                        "description": "Uso da DFT para análise espectral e identificação de sistemas dinâmicos discretos em contextos como engenharia de controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.4.1",
                            "name": "Realizar Análise Espectral de Sinais",
                            "description": "Extrair componentes de frequência de sinais discretos reais usando DFT com janelamento, plotando espectros de potência para sistemas mecânicos ou eletromecânicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Pré-processamento do Sinal Discreto",
                                  "subSteps": [
                                    "Colete ou simule um sinal discreto real de um sistema mecânico ou eletromecânico (ex.: vibrações de uma hélice).",
                                    "Determine a taxa de amostragem (Fs) adequada pelo teorema de Nyquist-Shannon para evitar aliasing.",
                                    "Remova ruídos iniciais aplicando filtros passa-baixa ou normalização do sinal.",
                                    "Segmente o sinal em janelas finitas de comprimento N (ex.: 1024 pontos).",
                                    "Verifique a estacionariedade do sinal usando testes estatísticos básicos."
                                  ],
                                  "verification": "Sinal pré-processado salvo em array NumPy/MATLAB sem artefatos visíveis no plot temporal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software: MATLAB ou Python (SciPy/NumPy)",
                                    "Dados de sinal: arquivo .csv ou simulação gerada"
                                  ],
                                  "tips": "Escolha N como potência de 2 para eficiência computacional da FFT.",
                                  "learningObjective": "Compreender os impactos da amostragem inadequada na análise espectral.",
                                  "commonMistakes": [
                                    "Ignorar aliasing levando a frequências espúrias",
                                    "Não normalizar o sinal causando escalas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e Aplicação de Janela",
                                  "subSteps": [
                                    "Escolha o tipo de janela baseado no sinal: Hanning para vazamento reduzido em sinais mecânicos.",
                                    "Calcule os coeficientes da janela usando funções built-in (window() no MATLAB ou scipy.signal.get_window()).",
                                    "Multiplique o sinal segmentado pela função janela elemento a elemento.",
                                    "Compare espectros com e sem janelamento para visualizar redução de vazamento espectral.",
                                    "Ajuste o overlap (ex.: 50%) entre janelas para análise de sinais não-estacionários."
                                  ],
                                  "verification": "Plot do sinal janelado mostra atenuação suave nas bordas sem distorções centrais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções de janelamento em MATLAB/Python",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use Hanning para a maioria dos sinais vibracionais em aeronáutica por bom compromisso mainlobe/sidelobe.",
                                  "learningObjective": "Dominar o trade-off entre resolução espectral e vazamento.",
                                  "commonMistakes": [
                                    "Aplicar janela retangular causando sidelobes altos",
                                    "Não compensar a energia da janela no espectro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computação da Transformada Discreta de Fourier (DFT/FFT)",
                                  "subSteps": [
                                    "Aplique a FFT ao sinal janelado usando fft() no MATLAB ou numpy.fft.fft().",
                                    "Calcule as frequências correspondentes: f = (0:N-1)*(Fs/N).",
                                    "Considere apenas a metade positiva do espectro para sinais reais (até Fs/2).",
                                    "Verifique normalização da DFT para consistência de amplitude.",
                                    "Repita para múltiplas janelas e faça média para reduzir variância (Welch's method)."
                                  ],
                                  "verification": "Magnitude da FFT plotada mostra picos coerentes com frequências conhecidas do sinal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bibliotecas FFT: numpy.fft ou MATLAB signal processing toolbox"
                                  ],
                                  "tips": "Use rfft() para sinais reais para eficiência computacional.",
                                  "learningObjective": "Executar DFT eficientemente e interpretar componentes frecuenciais.",
                                  "commonMistakes": [
                                    "Não descartar componente DC (f=0) se irrelevante",
                                    "Confundir índices de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo e Plotagem do Espectro de Potência",
                                  "subSteps": [
                                    "Calcule o espectro de potência: PSD = (1/N) * |DFT|^2 * correção de janela.",
                                    "Aplique método de Welch para PSD médio: welch() no SciPy ou pwelch() no MATLAB.",
                                    "Plote PSD em escala logarítmica (dB) vs. frequência linear.",
                                    "Identifique picos dominantes e harmônicos relevantes ao sistema.",
                                    "Anote resolução espectral: Δf = Fs/N."
                                  ],
                                  "verification": "Gráfico de PSD exibe picos nítidos sem vazamento excessivo e eixo y em dB/Hz.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções PSD: scipy.signal.welch ou pwelch(MATLAB)"
                                  ],
                                  "tips": "Escala logarítmica realça componentes fracos em sinais com dinâmica alta.",
                                  "learningObjective": "Gerar e interpretar espectros de potência para identificação de modos.",
                                  "commonMistakes": [
                                    "Esquecer fator de escala da janela",
                                    "Plotar frequência circular em vez de linear"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise e Interpretação dos Resultados",
                                  "subSteps": [
                                    "Compare picos observados com modelo teórico do sistema (ex.: frequências naturais).",
                                    "Quantifique amplitudes e identifique modos dominantes ou falhas.",
                                    "Realize testes de significância para picos (ex.: threshold de ruído).",
                                    "Documente relatório com plots, tabelas de frequências e conclusões.",
                                    "Valide com sinal sintético conhecido para calibração."
                                  ],
                                  "verification": "Relatório escrito identifica corretamente pelo menos 3 componentes frecuenciais principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas de plot: matplotlib ou MATLAB figures",
                                    "Template de relatório"
                                  ],
                                  "tips": "Sempre valide com sinal sintético antes de dados reais.",
                                  "learningObjective": "Interpretar espectros no contexto de sistemas aeronáuticos.",
                                  "commonMistakes": [
                                    "Atribuir picos a modos errados sem validação",
                                    "Ignorar efeitos de aliasing"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise vibrações de uma hélice de aeronave amostradas a 10 kHz. Aplique janelamento Hanning, DFT e PSD para identificar frequências de rotação fundamental (50 Hz) e harmônicos, detectando desbalanceamento se pico em 100 Hz exceder threshold.",
                              "finalVerifications": [
                                "Espectro de potência plotado corretamente com resolução Δf < 1 Hz.",
                                "Picos identificados coincidem com frequências esperadas (±5%).",
                                "Efeito do janelamento demonstrado via comparação de plots.",
                                "PSD médio via Welch mostra variância reduzida.",
                                "Relatório inclui interpretação física dos modos.",
                                "Validação com sinal sintético confirma precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação da DFT e janelamento (30%).",
                                "Qualidade dos plots e visualizações espectrais (20%).",
                                "Correção no cálculo de PSD e normalização (20%).",
                                "Profundidade da interpretação e identificação de componentes (20%).",
                                "Documentação clara e relatório completo (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Fourier e séries trigonométricas.",
                                "Programação: Algoritmos numéricos em Python/MATLAB.",
                                "Física: Dinâmica de vibrações e ressonância em estruturas.",
                                "Engenharia Mecânica: Análise modal de componentes aeronáuticos."
                              ],
                              "realWorldApplication": "Em manutenção preditiva de aeronaves, análise espectral de vibrações detecta falhas em rotores ou asas antes de falhas catastróficas, otimizando segurança e reduzindo downtime em frotas comerciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.4.2",
                            "name": "Identificar Sistemas via Resposta em Frequência",
                            "description": "Estimar funções de transferência discretas a partir de respostas em frequência obtidas por DFT de entrada e saída, aplicando métodos como razão H1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados de Entrada e Saída",
                                  "subSteps": [
                                    "Adquira sinais discretos de entrada u[n] e saída y[n] de um experimento ou simulação de sistema dinâmico.",
                                    "Verifique a sincronização temporal e remova offsets ou tendências lineares dos sinais.",
                                    "Aplique janelas (ex: Hanning) para reduzir vazamento espectral e divida em ensembles sobrepostos se necessário.",
                                    "Garanta que a taxa de amostragem atenda ao teorema de Nyquist para capturar dinâmica relevante.",
                                    "Salve os dados em formato compatível (ex: MATLAB .mat ou NumPy arrays)."
                                  ],
                                  "verification": "Sinais processados mostram ausência de offsets e janelamento aplicado corretamente em plots temporais e espectrais iniciais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software: MATLAB ou Python (SciPy/NumPy)",
                                    "Dados experimentais ou simulados de u[n] e y[n]"
                                  ],
                                  "tips": "Use ensembles múltiplos para melhorar a relação sinal-ruído; sobreponha 50% para eficiência.",
                                  "learningObjective": "Preparar dados de qualidade para análise em frequência sem artefatos.",
                                  "commonMistakes": [
                                    "Ignorar vazamento espectral sem janelamento",
                                    "Não verificar sincronização temporal",
                                    "Amostragem inadequada levando a aliasing"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo da Resposta em Frequência via DFT e Método H1",
                                  "subSteps": [
                                    "Compute DFT de cada ensemble: U_k(f) = DFT(u[n]), Y_k(f) = DFT(y[n]) para k=1 a K ensembles.",
                                    "Calcule H1(f) = (1/K) * sum [ Y_k(f) / U_k(f) ] para evitar divisão por zero (use máscara onde |U_k| > threshold).",
                                    "Estime a função de coerência γ²(f) = |sum Y_k U_k^*|² / [sum |U_k|² * sum |Y_k|²] para validar qualidade.",
                                    "Plote magnitude |H1(f)| em dB, fase arg(H1(f)) e coerência vs. frequência.",
                                    "Identifique faixa de frequências confiável (γ² > 0.8)."
                                  ],
                                  "verification": "Plots de |H1|, fase e coerência exibem curvas suaves na faixa dinâmica relevante sem picos espúrios.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções FFT em MATLAB (fft()) ou Python (numpy.fft)",
                                    "Script para médias e coerência"
                                  ],
                                  "tips": "Threshold de 1% do máximo |U| para evitar bias em baixos SNR; normalize frequências por fs.",
                                  "learningObjective": "Aplicar método H1 para estimar resposta em frequência robusta a ruído.",
                                  "commonMistakes": [
                                    "Dividir por U_k zero sem máscara",
                                    "Omitir coerência levando a interpretação errada",
                                    "Não converter para dB para visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimação da Função de Transferência Discreta",
                                  "subSteps": [
                                    "Escolha ordem do modelo (ex: ARX ou pole-zero) baseada em poles/zeros esperados do sistema físico.",
                                    "Ajuste parâmetros via mínimos quadrados ou otimização (ex: invfreqz no MATLAB) para matching com H1(f).",
                                    "Converta H1(f) para z-domínio via interpolação ou modelo paramétrico.",
                                    "Plote Bode do modelo estimado sobreposto a H1 para comparação visual.",
                                    "Refine ordem se resíduos espectrais forem altos."
                                  ],
                                  "verification": "Bode plots do modelo e H1 coincidem em magnitude e fase na faixa de interesse (erro < 5 dB).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Toolbox System Identification (MATLAB) ou Python control/scipy.signal",
                                    "Dados H1(f) do step anterior"
                                  ],
                                  "tips": "Comece com ordem baixa e aumente iterativamente; use validação cruzada com subconjunto de dados.",
                                  "learningObjective": "Modelar sistemas discretos paramétricos a partir de dados não-paramétricos em frequência.",
                                  "commonMistakes": [
                                    "Sobreamostragem de ordem levando a overfitting",
                                    "Ignorar fase na validação",
                                    "Não estabilizar modelo (poles fora da unidade)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação e Refinamento do Modelo",
                                  "subSteps": [
                                    "Simule saída ŷ[n] com modelo e entrada u[n]; compute erro RMS e FIT = 100*(1 - norm(y-ŷ)/norm(y-mean(y))).",
                                    "Verifique resíduos: auto-correlação e espectro plano indicam modelo adequado.",
                                    "Teste em conjunto de validação separado se disponível.",
                                    "Analise sensibilidade a ruído variando SNR.",
                                    "Documente limitações (ex: faixa de frequência válida)."
                                  ],
                                  "verification": "FIT > 80%, resíduos brancos e estáveis em simulações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções de simulação e FIT (compare() no MATLAB)"
                                  ],
                                  "tips": "FIT > 70% é aceitável para sistemas ruidosos; priorize faixa dinâmica operacional.",
                                  "learningObjective": "Validar robustez do modelo identificado contra overfitting e ruído.",
                                  "commonMistakes": [
                                    "Validar só em dados de estimação",
                                    "Aceitar FIT baixo sem análise de resíduos",
                                    "Omitir testes de estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de vibração de asa de aeronave, use martelo de impacto como entrada u[n] (aceleração) e acelerômetro na ponta como saída y[n]. Compute H1(f) para identificar modos de flexão natural (ex: 5 Hz e 20 Hz) e estime G(z) = num(z)/den(z) para modelo de controle ativo de flutter.",
                              "finalVerifications": [
                                "H1(f) calculado com coerência > 0.8 na faixa 0.1-0.5 fs.",
                                "Modelo G(z) estável com poles dentro do círculo unitário.",
                                "Bode plots coincidem com erro médio < 3 dB em magnitude.",
                                "Simulação FIT > 75% em dados de validação.",
                                "Resíduos têm espectro plano e auto-correlação insignificante.",
                                "Documentação inclui faixa de validade e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (sem artefatos em DFTs iniciais): 20%",
                                "Correta implementação de H1 e coerência (plots limpos): 25%",
                                "Qualidade do ajuste paramétrico (matching Bode): 25%",
                                "Validação quantitativa (FIT, resíduos): 20%",
                                "Interpretação física e documentação: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais: Aplicação avançada de DFT e janelamento.",
                                "Controle Automático: Uso de modelos identificados para síntese de controladores.",
                                "Engenharia Aeronáutica: Análise modal em estruturas aeroelásticas.",
                                "Estatística: Tratamento de ruído via ensembles e coerência.",
                                "Programação Numérica: Otimização e simulação em MATLAB/Python."
                              ],
                              "realWorldApplication": "Identificação de dinâmica de aeronaves em testes de solo/voo para certificação FAA/EASA, monitoramento de fadiga estrutural em frotas comerciais via análise de vibrações, e desenvolvimento de sistemas de controle ativo de flutter em asas de alta performance."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.4.3",
                            "name": "Aplicar em Exemplos Práticos",
                            "description": "Analisar dados de sistemas térmicos ou hidráulicos amostrados, usando DFT para validar modelos lineares e detectar modos dominantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Pré-processamento de Dados Amostrados",
                                  "subSteps": [
                                    "Selecione um conjunto de dados reais ou simulados de um sistema térmico (ex: variação de temperatura em um trocador de calor) ou hidráulico (ex: pressão em uma linha hidráulica de aeronave).",
                                    "Verifique a taxa de amostragem (fs) e aplique filtros anti-aliasing se necessário.",
                                    "Remova tendências (detrending) e normalize os dados para média zero.",
                                    "Divida os dados em janelas de comprimento adequado (ex: N=1024 pontos) com sobreposição de 50%.",
                                    "Calcule a duração total e resolva discrepâncias de amostragem."
                                  ],
                                  "verification": "Dados pré-processados exibem média próxima de zero, variância estável e sem artefatos visíveis em plot de tempo vs. amplitude.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (SciPy/NumPy), conjunto de dados de exemplo (ex: arquivos .csv de simulações térmicas).",
                                  "tips": "Use janelas Hann para reduzir vazamento espectral desde o início.",
                                  "learningObjective": "Preparar dados amostrados adequadamente para análise espectral via DFT.",
                                  "commonMistakes": "Ignorar vazamento espectral por falta de janelamento; não remover DC offset levando a picos falsos em DC."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computação da Transformada Discreta de Fourier (DFT)",
                                  "subSteps": [
                                    "Implemente ou use função fft() para calcular DFT em cada janela de dados.",
                                    "Calcule o espectro de magnitude |X(k)| e fase arg(X(k)).",
                                    "Gere vetor de frequências f = (0:N-1)*(fs/N).",
                                    "Aplique janelamento (Hann/Blackman) e normalize pela soma da janela.",
                                    "Plote o espectro de potência (PSD) unilateral (f de 0 a fs/2)."
                                  ],
                                  "verification": "Espetro simétrico para sinais reais, com energia concentrada em bandas esperadas; soma das magnitudes ao quadrado igual à energia do sinal no tempo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliotecas NumPy/SciPy (fft), MATLAB Signal Processing Toolbox.",
                                  "tips": "Verifique se N é potência de 2 para FFT eficiente.",
                                  "learningObjective": "Executar DFT corretamente em sinais discretos amostrados.",
                                  "commonMistakes": "Esquecer de dividir por N na normalização; plotar espectro bilateral sem foldar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção de Modos Dominantes no Espectro",
                                  "subSteps": [
                                    "Identifique picos no espectro de magnitude acima de um limiar (ex: 10% do máximo).",
                                    "Use peak finding (scipy.find_peaks) para localizar frequências dominantes.",
                                    "Associe picos a modos físicos do sistema (ex: frequência natural em ressonância hidráulica).",
                                    "Calcule largura de banda e fator de qualidade (Q) para cada modo.",
                                    "Compare com frequências esperadas de modelos teóricos."
                                  ],
                                  "verification": "Lista de 2-4 modos dominantes com frequências precisas (±1% erro) e Q-factor realista (>5 para amortecidos).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Funções de detecção de picos (SciPy), plotters (Matplotlib).",
                                  "tips": "Aplique suavização (média móvel) no espectro para reduzir ruído antes de peak finding.",
                                  "learningObjective": "Extrair modos dominantes de análise espectral para caracterização dinâmica.",
                                  "commonMistakes": "Confundir harmônicos com modos fundamentais; limiar muito baixo gerando falsos positivos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação de Modelos Lineares",
                                  "subSteps": [
                                    "Estime resposta em frequência do modelo linear (ex: função de transferência H(s) via polos/zeros).",
                                    "Converta H(s) para H(e^{jω}) e compare magnitude/fase com DFT.",
                                    "Calcule erro médio quadrático (MSE) entre espectros medido e modelado.",
                                    "Ajuste parâmetros do modelo (ex: otimização least-squares) para minimizar discrepâncias.",
                                    "Avalie resíduos para linearidade (branco em frequências altas)."
                                  ],
                                  "verification": "MSE < 5% em bandas de interesse; resíduos sem correlação significativa (teste Ljung-Box p>0.05).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de identificação (MATLAB System ID Toolbox, Python control library).",
                                  "learningObjective": "Validar modelos lineares contra dados reais usando análise em frequência.",
                                  "commonMistakes": "Não considerar aliasing na validação; overfitting ignorando ruído de medição.",
                                  "tips": [
                                    "Use escala logarítmica para magnitude e linear para fase nos gráficos de Bode.",
                                    "Normalize espectros por potência do sinal de entrada para comparação justa.",
                                    "Aplique filtro anti-aliasing na aquisição de dados para evitar distorções.",
                                    "Inspecione visualmente resíduos em domínio do tempo e frequência antes de testes estatísticos.",
                                    "Itere ajustes com validação cruzada para evitar overfitting ao ruído."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretação, Relatório e Conclusões",
                                  "subSteps": [
                                    "Resuma modos detectados, validação e discrepâncias.",
                                    "Discuta implicações para o sistema (ex: instabilidade em aeronáutica).",
                                    "Gere relatório com plots (tempo, espectro, comparação modelo/dados).",
                                    "Proponha melhorias (ex: aumentar taxa de amostragem).",
                                    "Arquive código e dados para reprodutibilidade."
                                  ],
                                  "verification": "Relatório completo com plots legíveis, conclusões quantitativas e sugestões acionáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de relatório (Jupyter Notebook, LaTeX).",
                                  "tips": "Use legendas claras e unidades consistentes em todos os plots.",
                                  "learningObjective": "Comunicar resultados de análise DFT de forma profissional.",
                                  "commonMistakes": "Omitir unidades de frequência (Hz vs. rad/s); conclusões sem base quantitativa."
                                }
                              ],
                              "practicalExample": "Analise dados amostrados de pressão em um atuador hidráulico de flap de aeronave (fs=1000 Hz, 10s de sinal). Use DFT para detectar modo de ressonância em 50 Hz, valide modelo linear de 2ª ordem (ωn=50 Hz, ζ=0.1) com MSE<3%, confirmando adequação para controle.",
                              "finalVerifications": [
                                "Espetro DFT corretamente computado e plotado com resolução adequada.",
                                "Modos dominantes identificados com frequências e Q-fatores precisos.",
                                "Modelo linear validado com MSE quantitativo e resíduos aleatórios.",
                                "Relatório inclui todos os plots e interpretações físicas.",
                                "Código reproduzível gera resultados idênticos.",
                                "Discrepâncias explicadas (ex: não-linearidades detectadas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de modos (erro <5% em frequência dominante).",
                                "Qualidade do pré-processamento (sem artefatos no espectro).",
                                "Correção na validação (MSE e análise de resíduos).",
                                "Profundidade da interpretação física e conexões ao contexto aeronáutico.",
                                "Clareza e completude do relatório (plots, conclusões acionáveis).",
                                "Eficiência computacional (tempo de execução razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Uso de DFT para síntese de controladores baseados em frequência.",
                                "Mecânica dos Fluidos: Interpretação de modos em sistemas hidráulicos.",
                                "Processamento de Sinais: Fundamentos de filtragem e análise espectral.",
                                "Otimização e Identificação de Sistemas: Ajuste de parâmetros via least-squares."
                              ],
                              "realWorldApplication": "Em manutenção preditiva de sistemas hidráulicos de aeronaves, DFT em dados de vibração/pressão detecta modos de falha precoce (ex: fadiga em tubulações), validando modelos para certificação FAA, reduzindo downtimes em 20-30%."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Análise de Sistemas Lineares Contínuos no Tempo",
                "description": "Estuda resposta ao impulso, integral de convolução e determinação de soluções de modelos lineares contínuos.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Resposta ao Impulso",
                    "description": "Definição e propriedades da resposta ao impulso h(t) para sistemas lineares invariantes no tempo contínuos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1.1",
                        "name": "Definição da Resposta ao Impulso h(t)",
                        "description": "Conceito fundamental que define a resposta ao impulso como a saída de um sistema linear invariante no tempo (LTI) contínuo quando a entrada é a função delta de Dirac δ(t), representando completamente o comportamento do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1.1",
                            "name": "Identificar a função delta de Dirac δ(t)",
                            "description": "Reconhecer e descrever as propriedades matemáticas da função delta de Dirac δ(t), incluindo sua natureza como distribuição generalizada, integral unitária ∫δ(t)dt=1 e comportamento como limitar de funções de pulso estreito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito intuitivo da função delta de Dirac",
                                  "subSteps": [
                                    "Leia a definição formal: δ(t) é zero para t ≠ 0, 'infinito' em t=0, com ∫_{-∞}^{∞} δ(t) dt = 1",
                                    "Visualize como um 'pico infinito estreito' que concentra toda a 'área' unitária em t=0",
                                    "Compare com uma seta apontando para t=0, representando um impulso instantâneo",
                                    "Discuta por que não é uma função clássica, mas uma distribuição generalizada",
                                    "Esboce um gráfico qualitativo à mão, mostrando o spike em t=0"
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o conceito em 3 frases concisas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim)",
                                    "Papel e lápis para esboço",
                                    "Vídeo introdutório no YouTube sobre delta de Dirac"
                                  ],
                                  "tips": "Pense na delta como 'toda a massa concentrada em um ponto' para intuição física",
                                  "learningObjective": "Reconhecer a delta de Dirac como distribuição que modela impulsos ideais",
                                  "commonMistakes": [
                                    "Confundir com a função degrau (Heaviside)",
                                    "Ignorar que a integral é sempre 1 independentemente da altura do pico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as propriedades matemáticas fundamentais",
                                  "subSteps": [
                                    "Estude a propriedade de peneiramento: ∫_{-∞}^{∞} f(t) δ(t) dt = f(0) para f contínua",
                                    "Verifique a integral unitária: ∫_{-∞}^{∞} δ(t) dt = 1 e ∫_{-∞}^{∞} δ(t - t_0) dt = 1",
                                    "Analise a simetria: δ(t) = δ(-t) e propriedade de escalonamento: δ(at) = (1/|a|) δ(t)",
                                    "Discuta o comportamento em derivadas: δ'(t) e sua ação em testes",
                                    "Resolva 2-3 exemplos simples de integração com delta deslocada"
                                  ],
                                  "verification": "Resolva um integral de teste como ∫ t δ(t-1) dt e confirme o resultado",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios com integrais envolvendo delta",
                                    "Calculadora simbólica (ex: Wolfram Alpha)",
                                    "Notas de aula sobre distribuições"
                                  ],
                                  "tips": "Sempre teste com funções teste simples como f(t)=1, t, e^t para validar propriedades",
                                  "learningObjective": "Descrever e aplicar as propriedades chave da delta de Dirac",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/|a| no escalonamento",
                                    "Aplicar delta como função ponto a ponto sem integração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar a delta como limite de funções regulares",
                                  "subSteps": [
                                    "Estude a sequência de funções retangulares: δ_n(t) = n/2 para |t|<1/(2n), 0 caso contrário",
                                    "Analise funções gaussianas: δ_σ(t) = (1/(σ√(2π))) exp(-t²/(2σ²)) com σ→0",
                                    "Plote 3-4 aproximações com diferentes larguras em software gráfico",
                                    "Compute numericamente a integral de cada aproximação e observe convergência para 1",
                                    "Discuta rigorosamente como limite em sentido de distribuições"
                                  ],
                                  "verification": "Gere plots mostrando convergência e confirme integral ≈1 para n grande",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (ex: plot delta approx)",
                                    "Tutoriais Jupyter notebook para delta approximations"
                                  ],
                                  "tips": "Use log-scale no eixo y para visualizar picos altos sem distorção",
                                  "learningObjective": "Entender a delta como limite de pulsos estreitos",
                                  "commonMistakes": [
                                    "Achar que delta é exatamente uma função limite pontual",
                                    "Não normalizar a área para 1 nas aproximações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em contexto de resposta ao impulso",
                                  "subSteps": [
                                    "Revise h(t) = resposta a δ(t) em sistemas LTI contínuos",
                                    "Simule convolução y(t) = ∫ h(τ) δ(t-τ) dτ = h(t)",
                                    "Identifique δ(t) em diagramas de bloco de sistemas dinâmicos",
                                    "Resolva um problema: dada h(t), encontre saída para entrada δ(t)",
                                    "Crie um fluxograma resumindo identificação da delta"
                                  ],
                                  "verification": "Explique como δ(t) 'testa' o sistema para obter h(t)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas de Sinais e Sistemas",
                                    "Simulador online como LTSpice ou Python Control"
                                  ],
                                  "tips": "Lembre: delta 'ativa' instantaneamente todo o sistema",
                                  "learningObjective": "Conectar delta de Dirac à identificação de resposta ao impulso h(t)",
                                  "commonMistakes": [
                                    "Confundir δ(t) com entrada degrau",
                                    "Ignorar causalidade em sistemas reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em MATLAB, defina uma aproximação δ_n(t) com n=1000 (pulso retangular de largura 1/n e altura n), plote-a, compute trapz(δ_n,t) para verificar ≈1, e convolua com uma h(t)=exp(-t)u(t) para obter y(t)=h(t), demonstrando a propriedade de impulso.",
                              "finalVerifications": [
                                "Esboce corretamente o gráfico qualitativo de δ(t)",
                                "Calcule ∫ f(t) δ(t-a) dt = f(a) para f dada",
                                "Explique por que δ(t) não é função clássica mas distribuição",
                                "Gere e valide uma aproximação numérica com integral=1",
                                "Identifique δ(t) em um diagrama de resposta ao impulso",
                                "Descreva 3 propriedades principais sem erros"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das propriedades (integral unitária, sifting)",
                                "Correta representação como limite com plots normalizados",
                                "Compreensão conceitual (distribuição vs. função)",
                                "Aplicação correta em exemplos de sistemas LTI",
                                "Identificação visual e contextual em problemas",
                                "Ausência de confusões comuns (ex: com Heaviside)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das distribuições e análise funcional",
                                "Física: Modelagem de forças impulsivas em dinâmica aeronáutica",
                                "Processamento de Sinais: Filtros e transformadas de Fourier",
                                "Computação: Simulações numéricas em Python/MATLAB"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, δ(t) modela impactos instantâneos como colisões ou explosões em testes de estruturas, permitindo calcular respostas dinâmicas h(t) para análise de vibrações e fadiga em aeronaves via simulações de sistemas LTI."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.1.2",
                            "name": "Definir a resposta ao impulso h(t)",
                            "description": "Explicar que h(t) é a resposta de um sistema LTI contínuo à entrada δ(t), com h(t) = y(t) onde y(t) é a saída para x(t)=δ(t), e ilustrar com exemplos simples como sistemas de primeira ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas Lineares e Invariantes no Tempo (LTI)",
                                  "subSteps": [
                                    "Explique o que significa linearidade: superposição de respostas.",
                                    "Descreva invariância no tempo: resposta a x(t - t0) é y(t - t0).",
                                    "Identifique exemplos de sistemas LTI contínuos, como equações diferenciais lineares com coeficientes constantes.",
                                    "Diferencie de sistemas não-lineares ou variantes no tempo.",
                                    "Resuma propriedades chave: convolução para resposta geral."
                                  ],
                                  "verification": "Escreva uma definição concisa de LTI e dê um exemplo de sistema não-LTI.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (Capítulo LTI)",
                                    "Slides de aula sobre sistemas lineares"
                                  ],
                                  "tips": [
                                    "Use analogias como 'receita de bolo' para linearidade: dobrar ingredientes dobra o resultado."
                                  ],
                                  "learningObjective": "Compreender as propriedades essenciais de sistemas LTI contínuos.",
                                  "commonMistakes": [
                                    "Confundir linearidade com simetria.",
                                    "Ignorar invariância no tempo ao considerar atrasos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Função Impulso δ(t)",
                                  "subSteps": [
                                    "Defina δ(t) como uma distribuição que integra a 1 e é zero para t ≠ 0.",
                                    "Descreva propriedades: ∫_{-∞}^∞ δ(t) dt = 1, δ(t - t0) desloca o impulso.",
                                    "Explique representação prática: limite de uma pulsão estreita de área unitária.",
                                    "Discuta como δ(t) 'testa' o sistema com energia mínima.",
                                    "Verifique graficamente: pico infinito em t=0."
                                  ],
                                  "verification": "Desenhe δ(t) e calcule sua integral de -1 a 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos de δ(t) em software como MATLAB ou Python (SciPy)",
                                    "Video explicativo sobre Dirac Delta"
                                  ],
                                  "tips": [
                                    "Pense em δ(t) como um 'martelo' que bate no sistema para revelar sua resposta natural."
                                  ],
                                  "learningObjective": "Dominar a definição e propriedades da função delta de Dirac.",
                                  "commonMistakes": [
                                    "Tratar δ(t) como uma função comum (não é).",
                                    "Esquecer que a área é 1, não a altura."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Resposta ao Impulso h(t)",
                                  "subSteps": [
                                    "Estabeleça h(t) = y(t) onde x(t) = δ(t) para sistema LTI.",
                                    "Explique que h(t) é a 'assinatura' do sistema, usada em convolução: y(t) = ∫ h(τ) x(t - τ) dτ.",
                                    "Discuta causalidade: h(t) = 0 para t < 0 em sistemas causais.",
                                    "Relacione com função de transferência H(s) via transformada de Laplace.",
                                    "Escreva formalmente: para LTI, resposta geral é convolução com h(t)."
                                  ],
                                  "verification": "Escreva a equação definindo h(t) e explique seu papel na convolução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre convolução",
                                    "Tabela de transformadas de Laplace"
                                  ],
                                  "tips": [
                                    "Lembre: h(t) é o que o sistema 'lembra' de um impulso instantâneo."
                                  ],
                                  "learningObjective": "Definir precisamente h(t) e seu significado em sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir h(t) com resposta degrau.",
                                    "Esquecer causalidade em definições."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplo de Sistema de Primeira Ordem",
                                  "subSteps": [
                                    "Considere sistema dy/dt + a y = x(t), com x(t)=δ(t), solução h(t) = e^{-a t} u(t).",
                                    "Derive h(t) resolvendo a EDO com condições iniciais y(0^-)=0.",
                                    "Plote h(t) para a=1: decai exponencialmente.",
                                    "Simule em software e compare com teoria.",
                                    "Discuta interpretação: tempo constante 1/a."
                                  ],
                                  "verification": "Derive e plote h(t) para um sistema RC com τ=1s.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Python para simulação (ode45 ou lsim)",
                                    "Papel e lápis para derivação manual"
                                  ],
                                  "tips": [
                                    "Use Laplace: H(s) = 1/(s + a), h(t) = L^{-1}{H(s)}."
                                  ],
                                  "learningObjective": "Aplicar definição de h(t) a um exemplo concreto de primeira ordem.",
                                  "commonMistakes": [
                                    "Erro em condições iniciais (impulso adiciona 1 em y(0^+)).",
                                    "Plotar sem degrau unitário u(t)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um circuito RC série (R=1Ω, C=1F), a tensão no capacitor y(t) para corrente de impulso δ(t) é h(t) = e^{-t} u(t), representando a resposta transitória natural do sistema.",
                              "finalVerifications": [
                                "Define corretamente h(t) como y(t) para x(t)=δ(t).",
                                "Explica o papel de h(t) na convolução para y(t) geral.",
                                "Deriva h(t) para sistema de primeira ordem dy/dt + y = x(t).",
                                "Identifica h(t)=0 para t<0 em sistemas causais.",
                                "Desenha graficamente h(t) para exemplo simples.",
                                "Relaciona h(t) com H(s) via Laplace."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de h(t) (90% correto).",
                                "Correta derivação para sistema de 1ª ordem (sem erros algébricos).",
                                "Compreensão conceitual via explicação da convolução.",
                                "Qualidade do gráfico de h(t) (eixos, rótulos, causalidade).",
                                "Identificação de propriedades chave (causalidade, unidade).",
                                "Aplicação correta em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e convolução integral.",
                                "Física: Dinâmica de sistemas massa-mola ou fluidos.",
                                "Engenharia de Controle: Modelagem de plantas em malha aberta.",
                                "Programação: Simulação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, h(t) modela a resposta impulsiva de sistemas de controle de voo, como estabilizadores de atitude, permitindo prever oscilações e projetar controladores para estabilidade em manobras abruptas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.1.3",
                            "name": "Determinar h(t) para sistemas diferenciais lineares",
                            "description": "Resolver equações diferenciais lineares com coeficientes constantes para encontrar h(t), resolvendo y'' + a y' + b y = δ(t) com condições iniciais nulas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades da resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Revise a definição de h(t) como a saída y(t) quando a entrada é δ(t) com condições iniciais nulas.",
                                    "Identifique propriedades chave: causalidade (h(t)=0 para t<0), integral de h(t) dt de 0 a ∞ = 1 para sistemas com ganho DC unitário.",
                                    "Relacione h(t) à função de transferência H(s) via transformada de Laplace.",
                                    "Estude exemplos simples de sistemas de primeira e segunda ordem.",
                                    "Anote as condições iniciais y(0-)=0 e y'(0-)=0 para o impulso."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades de h(t) e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas, notas de aula, tabela de propriedades de Laplace",
                                  "tips": "Sempre lembre que δ(t) é uma entrada impulsiva infinita em t=0, mas com área unitária.",
                                  "learningObjective": "Entender conceitualmente h(t) como resposta unitária ao impulso em sistemas LTI.",
                                  "commonMistakes": "Confundir h(t) com a resposta degrau ou ignorar condições iniciais nulas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação diferencial e aplicar Transformada de Laplace",
                                  "subSteps": [
                                    "Escreva a EDO geral: y'' + a y' + b y = δ(t), com y(0-)=0, y'(0-)=0.",
                                    "Aplique Laplace bilateral: L{y''} = s² Y(s) - s y(0-) - y'(0-) = s² Y(s).",
                                    "L{y'} = s Y(s) - y(0-) = s Y(s).",
                                    "L{δ(t)} = 1.",
                                    "Obtenha a equação no domínio s: (s² + a s + b) Y(s) = 1."
                                  ],
                                  "verification": "Derive corretamente a equação transformada Y(s) = 1 / (s² + a s + b).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica ou software como MATLAB/SymPy, tabela de Laplace",
                                  "tips": "Use Laplace unilateral para causalidade; verifique termos iniciais zerados.",
                                  "learningObjective": "Dominar a aplicação de Laplace a EDOs com entrada impulsiva.",
                                  "commonMistakes": "Esquecer os termos de inicialização ou usar Laplace bilateral incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a função de transferência H(s) e analisar raízes",
                                  "subSteps": [
                                    "Identifique H(s) = Y(s)/U(s) = 1 / (s² + a s + b), onde U(s)=1 para δ(t).",
                                    "Calcule as raízes do denominador: polinômio característico s² + a s + b = 0.",
                                    "Classifique o sistema: subamortecido (ω_n > ζ ω_n), crítico ou superamortecido.",
                                    "Expresse H(s) em forma parcial ou canônica para inversão.",
                                    "Verifique estabilidade (raízes com parte real negativa)."
                                  ],
                                  "verification": "Esboce o polo-zero de H(s) e classifique o amortecimento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica, software de simbólico (Mathematica/MATLAB), gráficos de polo-zero",
                                  "tips": "Fatore o denominador: raízes = [-a ± sqrt(a² - 4b)] / 2.",
                                  "learningObjective": "Analisar H(s) para prever comportamento temporal de h(t).",
                                  "commonMistakes": "Erro no cálculo de raízes ou confundir numerador com denominador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a transformada inversa para obter h(t)",
                                  "subSteps": [
                                    "Use frações parciais: H(s) = A/(s - p1) + B/(s - p2) para raízes reais/distintas.",
                                    "Para raízes complexas: H(s) = (ω_d / (2 ζ ω_n)) e^{-ζ ω_n t} sen(ω_d t) u(t).",
                                    "Aplique tabelas de Laplace inversa para cada termo.",
                                    "Escreva h(t) explícita para t ≥ 0, multiplicando por u(t).",
                                    "Plote h(t) para visualizar o comportamento."
                                  ],
                                  "verification": "Confira que lim t→∞ h(t)=0 e ∫ h(t) dt = H(0) se aplicável.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela de transformadas inversas, software de plotagem (MATLAB/Python), papel para esboço",
                                  "tips": "Para segunda ordem subamortecida: h(t) = (1/ω_d) e^{-ζ ω_n t} sen(ω_d t) u(t).",
                                  "learningObjective": "Resolver analiticamente h(t) para EDOs lineares de segunda ordem.",
                                  "commonMistakes": "Esquecer o degrau unitário u(t) ou erro em coeficientes de frações parciais."
                                }
                              ],
                              "practicalExample": "Para o sistema y'' + 3y' + 2y = δ(t), y(0-)=y'(0-)=0: H(s) = 1/(s² + 3s + 2) = 1/((s+1)(s+2)). Frações parciais: 1/(s+1) - 1/(s+2). Assim, h(t) = [e^{-t} - e^{-2t}] u(t). Verifique: h(0+)=0, h'(0+)=1.",
                              "finalVerifications": [
                                "h(t) = 0 para t < 0 (causalidade).",
                                "h'(0+) = 1 para sistemas de segunda ordem normalizados.",
                                "∫_{-∞}^∞ h(t) dt = 1.",
                                "Raízes do denominador têm parte real negativa (estável).",
                                "Comportamento assintótico: decai exponencialmente.",
                                "Corresponde à convolução com δ(t)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de H(s) a partir da EDO.",
                                "Correção no cálculo de raízes e frações parciais.",
                                "Expressão analítica completa de h(t) com u(t).",
                                "Verificação de pelo menos 3 propriedades de h(t).",
                                "Interpretação física correta (ex.: overshoot, tempo de assentamento).",
                                "Clareza no esboço ou plot de h(t)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Osciladores harmônicos forçados (equações de movimento).",
                                "Controle Automático: Projeto de controladores baseados em H(s).",
                                "Processamento de Sinais: Filtragem linear e convolução.",
                                "Matemática Aplicada: Análise de valores próprios em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, h(t) modela a resposta impulsiva de sistemas como atuadores de flaps ou hélices a distúrbios aerodinâmicos repentinos (ex.: rajadas de vento), essencial para análise de estabilidade e vibrações em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.1.2",
                        "name": "Propriedades da Resposta ao Impulso",
                        "description": "Propriedades essenciais de h(t) em sistemas LTI contínuos, como causalidade, estabilidade e simetria temporal, que derivam da linearidade e invariância no tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.2.1",
                            "name": "Verificar causalidade em h(t)",
                            "description": "Demonstrar que para sistemas causais, h(t) = 0 para t < 0, e relacionar isso com a propriedade de causalidade do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de sistema causal",
                                  "subSteps": [
                                    "Defina um sistema causal: saída depende apenas de entradas atuais e passadas, não futuras.",
                                    "Explique a implicação temporal: para entrada em t=0 (impulso), saída só pode começar em t≥0.",
                                    "Discuta exemplos não causais, como sistemas com previsão futura.",
                                    "Relacione com representações matemáticas: y(t) = ∫_{-∞}^t h(τ) x(t-τ) dτ.",
                                    "Anote a condição chave: h(t) = 0 para t < 0 em sistemas LTI causais."
                                  ],
                                  "verification": "Escreva uma definição precisa e liste 2 exemplos causais/não causais corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas (ex: Oppenheim), caderno de anotações.",
                                  "tips": "Use analogias como 'não pode reagir antes do estímulo' para fixar o conceito.",
                                  "learningObjective": "Compreender o conceito fundamental de causalidade em sistemas dinâmicos.",
                                  "commonMistakes": "Confundir causalidade com estabilidade; causalidade é sobre tempo, não magnitude."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Defina h(t) como a saída de um sistema LTI para δ(t), o impulso unitário em t=0.",
                                    "Derive a relação convolução: y(t) = h(t) * x(t).",
                                    "Discuta propriedades de h(t) para sistemas LTI: linearidade e invariância temporal implicam causalidade via h(t).",
                                    "Plote um exemplo genérico de h(t) causal (ex: exponencial decrescente para t≥0).",
                                    "Compare com h(t) não causal (suporte em t<0)."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um gráfico de h(t) causal vs. não causal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel milimetrado, software de plotagem (MATLAB/Octave/Python), exemplos de h(t) do curso.",
                                  "tips": "Lembre: h(t) é a 'assinatura temporal' do sistema.",
                                  "learningObjective": "Dominar o papel da resposta ao impulso como indicador de propriedades do sistema.",
                                  "commonMistakes": "Assumir h(t)=0 para t>0 (isso é FIR, não causalidade)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar h(t) para t < 0",
                                  "subSteps": [
                                    "Obtenha ou simule h(t) para um sistema dado (ex: via equação diferencial).",
                                    "Avalie lim_{t→0^-} h(t) e integre ou plote para t<0.",
                                    "Verifique matematicamente: resolva se h(t) satisfaz h(t)=0 ∀ t<0.",
                                    "Use propriedades: para causal, suporte de h(t) em [0,∞).",
                                    "Teste com contraexemplo: modifique h(t) para t<0 ≠0 e veja violação."
                                  ],
                                  "verification": "Calcule e mostre h(t)=0 para pelo menos 3 pontos t<0 em um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simbólica (SymPy/MATLAB), equações do sistema (ex: mÿ + bẏ + ky = x).",
                                  "tips": "Comece com sistemas simples como integrador (h(t)=u(t)).",
                                  "learningObjective": "Aplicar análise matemática para inspecionar causalidade via h(t).",
                                  "commonMistakes": "Ignorar condições iniciais em zero estado; assumir y(0^-)=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar verificação à causalidade do sistema",
                                  "subSteps": [
                                    "Conclua: se h(t)=0 para t<0, sistema é causal (para LTI).",
                                    "Discuta implicações: real-time processing, estabilidade física.",
                                    "Verifique com simulação: convolve x(t) causal com h(t) e cheque y(t).",
                                    "Estenda a sistemas discretos: h[n]=0 para n<0.",
                                    "Resuma em relatório: 'Verificação confirma causalidade pois...'"
                                  ],
                                  "verification": "Escreva uma conclusão lógica ligando h(t) à causalidade com evidência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de simulação (Scilab/Python), template de relatório.",
                                  "tips": "Use setas no gráfico h(t) para destacar suporte [0,∞).",
                                  "learningObjective": "Integrar verificação prática ao conceito teórico de causalidade.",
                                  "commonMistakes": "Concluir causalidade sem checar todo t<0; usar apenas gráfico qualitativo."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de flap de asa em aeronave modelado por ẏ + 2y = x(t), resolva h(t) = e^{-2t} u(t). Plote e confirme h(t)=0 para t<0, provando causalidade (flap não se move antes do comando).",
                              "finalVerifications": [
                                "h(t) explicitamente =0 para múltiplos t<0.",
                                "Gráfico de h(t) mostra suporte apenas em t≥0.",
                                "Convolução com x(t) causal produz y(t) causal.",
                                "Equação diferencial resolvida com condições iniciais zero.",
                                "Contraexemplo não causal corretamente identificado.",
                                "Relatório resume ligação h(t)-causalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de h(t) (90%+ correto).",
                                "Análise completa de t<0 com evidências quantitativas.",
                                "Clareza na relação causalidade-sistema (lógica irrefutável).",
                                "Uso correto de ferramentas/simulações sem erros.",
                                "Explicação de implicações práticas.",
                                "Ausência de erros comuns como confusão com estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Causalidade em dinâmica newtoniana (forças causam acelerações futuras).",
                                "Controle Aeronáutico: Verificação em auto-pilotos para latência real.",
                                "Programação: Simulações em Python (SciPy) para plotar h(t).",
                                "Matemática: Análise de Laplace (ROC inclui eixo jω para causais)."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, verificar causalidade em h(t) garante que sistemas de controle de voo (ex: estabilizadores) não 'preveem' turbulências, evitando instabilidades catastróficas em simuladores de voo ou aviônicos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2.2",
                            "name": "Analisar estabilidade via h(t)",
                            "description": "Verificar estabilidade BIBO (Bounded-Input Bounded-Output) determinando se ∫|h(t)| dt < ∞ para sistemas contínuos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estabilidade BIBO e o critério via h(t)",
                                  "subSteps": [
                                    "Estudar a definição de estabilidade BIBO: saída limitada para entrada limitada.",
                                    "Revisar que h(t) é a resposta ao impulso do sistema LTI contínuo.",
                                    "Memorizar o critério: o sistema é BIBO estável se e somente se ∫_{-∞}^{∞} |h(t)| dt < ∞.",
                                    "Diferenciar de outros tipos de estabilidade (ex.: assintótica via polos).",
                                    "Analisar exemplos qualitativos de h(t) estável (decaimento exponencial) vs. instável (crescimento)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o critério e dar um exemplo simples de h(t) estável e instável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas (ex.: Oppenheim), notas de aula, vídeo introdutório sobre estabilidade BIBO.",
                                  "tips": "Visualize h(t) graficamente: se a área sob |h(t)| for finita, é estável.",
                                  "learningObjective": "Entender e enunciar precisamente o critério de estabilidade BIBO usando h(t).",
                                  "commonMistakes": "Confundir estabilidade BIBO com estabilidade em malha fechada ou ignorar o valor absoluto em |h(t)|."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter ou derivar a resposta ao impulso h(t) do sistema",
                                  "subSteps": [
                                    "Identificar a função de transferência H(s) do sistema dado.",
                                    "Realizar a transformada inversa de Laplace: h(t) = L^{-1}{H(s)}.",
                                    "Aplicar a função degrau unitário u(t) se necessário para causalidade.",
                                    "Verificar propriedades de h(t): real, causal (h(t)=0 para t<0 em sistemas causais).",
                                    "Plotar h(t) para inspeção visual inicial da decaimento."
                                  ],
                                  "verification": "Derivar h(t) corretamente para um sistema dado e plotá-lo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de cálculo simbólico (MATLAB, SymPy, Mathematica), papel e lápis para esboços.",
                                  "tips": "Use tabelas de transformadas de Laplace para agilizar a inversa.",
                                  "learningObjective": "Calcular h(t) a partir de H(s) com precisão.",
                                  "commonMistakes": "Esquecer o fator de escala ou não considerar a causalidade, levando a h(t) não zero para t<0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a integral ∫_{-∞}^{∞} |h(t)| dt",
                                  "subSteps": [
                                    "Escrever |h(t)| explicitamente, considerando o sinal de h(t).",
                                    "Avaliar a integral imprópria: lim_{T→∞} ∫_{-T}^{T} |h(t)| dt.",
                                    "Separar em intervalos onde h(t) >0 e <0, ou usar simetria.",
                                    "Resolver analiticamente se possível (ex.: integrais exponenciais).",
                                    "Usar simulação numérica se analítica complexa (ex.: integral numérica no MATLAB)."
                                  ],
                                  "verification": "Obter um valor numérico ou simbólico finito/infinito para a integral.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora gráfica ou software (MATLAB para quad), tabelas de integrais.",
                                  "tips": "Para sistemas com polos no semiplano direito, a integral diverge rapidamente.",
                                  "learningObjective": "Dominar o cálculo de integrais impróprias absolutas para funções de decaimento.",
                                  "commonMistakes": "Integrar h(t) sem valor absoluto, subestimando oscilações, ou limites errados de integração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o resultado e concluir sobre a estabilidade",
                                  "subSteps": [
                                    "Comparar o valor da integral com ∞: <∞ → estável; =∞ → instável.",
                                    "Discutir implicações: entrada limitada produz saída limitada.",
                                    "Verificar com contraexemplo: aplicar degrau e observar saída.",
                                    "Documentar o processo em relatório curto.",
                                    "Comparar com critério de polos (Re(polos)<0 para causal)."
                                  ],
                                  "verification": "Concluir corretamente a estabilidade e justificar com o valor da integral.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou documento para relatório, simulador de sistemas (Simulink).",
                                  "tips": "Sempre relacione com o gráfico de h(t): decaimento rápido garante integral finita.",
                                  "learningObjective": "Aplicar o critério para tomada de decisão sobre estabilidade.",
                                  "commonMistakes": "Ignorar sistemas marginais (integral converge condicionalmente) ou confundir com estabilidade L2."
                                }
                              ],
                              "practicalExample": "Considere um sistema RC de primeiro ordem com H(s) = 1/(s+1). Derive h(t) = e^{-t} u(t). Calcule ∫_0^∞ |e^{-t}| dt = ∫_0^∞ e^{-t} dt = 1 < ∞, logo estável BIBO. Simule no MATLAB: impz para h(t) e trapz para integral.",
                              "finalVerifications": [
                                "Calcula corretamente h(t) para sistemas de 1ª e 2ª ordem.",
                                "Avalia ∫|h(t)| dt < ∞ para pelo menos 3 exemplos variados.",
                                "Identifica instabilidade quando h(t) tem polos no semiplano direito.",
                                "Explica a relação com convolução y(t) = ∫ h(τ) x(t-τ) dτ.",
                                "Aplica o critério em um sistema não causal hipotético."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de h(t) e da integral (erro <1%).",
                                "Justificativa clara do critério BIBO com referências matemáticas.",
                                "Uso correto de ferramentas computacionais sem erros de sintaxe.",
                                "Análise qualitativa via gráficos de h(t).",
                                "Conclusão consistente com o teorema, sem contradições.",
                                "Relatório estruturado com passos reproduzíveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integrais impróprias e convergência absoluta (Cálculo III).",
                                "Física: Dinâmica de sistemas dissipativos em aeronáutica.",
                                "Engenharia de Controle: Projeto de controladores estáveis.",
                                "Programação: Simulação numérica em MATLAB/Python para integrais."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, analisar a estabilidade BIBO da resposta ao impulso de sistemas de controle de atitude em aeronaves, garantindo que perturbações limitadas (ex.: rajadas de vento) não causem desvios ilimitados no ângulo de ataque, prevenindo perda de controle."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2.3",
                            "name": "Identificar propriedades de simetria e escalamento",
                            "description": "Explicar propriedades como h(at) relacionado a escalonamento temporal e simetria para sistemas reais h(-t)=h(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e propriedades básicas da resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Defina resposta ao impulso como a saída de um sistema LTI contínuo ao estímulo δ(t).",
                                    "Explique que h(t) caracteriza completamente o sistema LTI.",
                                    "Liste propriedades fundamentais: linearidade, causalidade (h(t)=0 para t<0 em sistemas causais) e real-valued para sistemas reais.",
                                    "Discuta representação em domínio do tempo e frequência.",
                                    "Identifique suporte de h(t) (duração finita ou infinita)."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades básicas e forneça um diagrama simples de h(t) para um sistema RC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Sinais e Sistemas (Oppenheim), MATLAB ou Python para plotar exemplos.",
                                  "tips": "Use animações online para visualizar convolução com δ(t).",
                                  "learningObjective": "Compreender o papel fundamental de h(t) em sistemas lineares contínuos.",
                                  "commonMistakes": "Confundir h(t) com resposta degrau ou função de transferência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar propriedade de simetria: h(-t) = h(t)",
                                  "subSteps": [
                                    "Defina simetria par: h(-t) = h(t), indicando simetria temporal em torno de t=0.",
                                    "Explique implicações: sistema não causal ou simétrico, comum em filtros passa-faixa ou modelagem de vibrações simétricas.",
                                    "Derive matematicamente usando propriedades de LTI: verifique se preserva energia ou fase zero.",
                                    "Compare com simetria ímpar: h(-t) = -h(t).",
                                    "Analise espectro de frequência: simetria par implica magnitude par e fase ímpar."
                                  ],
                                  "verification": "Plotar h(t) simétrico e verificar h(-t) == h(t) numericamente em software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (MATLAB/Simulink), exemplos de h(t) como gaussiana.",
                                  "tips": "Teste com funções conhecidas como sinc(t) que é par.",
                                  "learningObjective": "Identificar e justificar quando h(t) exibe simetria par em sistemas reais.",
                                  "commonMistakes": "Assumir todos os sistemas causais têm simetria; causalidade implica h(t)=0 para t<0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar propriedade de escalonamento temporal: h(at)",
                                  "subSteps": [
                                    "Defina escalonamento: para input δ(at), saída é (1/|a|) h(t/a), preservando norma L2.",
                                    "Derive a fórmula usando propriedades de delta: ∫ h(t) δ(at) dt = (1/|a|) h(0/a).",
                                    "Analise efeitos: a>1 comprime no tempo e amplifica amplitude; a<1 expande.",
                                    "Discuta aplicações em mudança de escala de tempo em simulações.",
                                    "Verifique numericamente com exemplos escalados."
                                  ],
                                  "verification": "Implementar em código e comparar h(at) com (1/|a|) h(t/a) para a=2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (SciPy/NumPy), notebook Jupyter com plots.",
                                  "tips": "Sempre normalize pela |a| para preservar energia.",
                                  "learningObjective": "Dominar a relação matemática do escalonamento na resposta ao impulso.",
                                  "commonMistakes": "Esquecer o fator 1/|a|, levando a erros de amplitude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e aplicar propriedades em exemplos de sistemas aeronáuticos",
                                  "subSteps": [
                                    "Selecione exemplo: resposta ao impulso de um oscilador massa-mola-amortecedor em ala de aeronave.",
                                    "Identifique simetria: verifique se h(t) é par para modos simétricos.",
                                    "Aplique escalonamento: simule aceleração de escala temporal para voo supersônico.",
                                    "Combine propriedades: analise h(at) e verifique simetria.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Gerar plots e relatório confirmando propriedades para um caso real.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulink ou Python com ODE solvers, dados de sistemas aeronáuticos.",
                                  "tips": "Use dados reais de flutter em asas para relevância.",
                                  "learningObjective": "Aplicar identificação de simetria e escalamento em contextos práticos.",
                                  "commonMistakes": "Ignorar condições de contorno como causalidade em aplicações reais."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de vibração de asa de aeronave modelado como oscilador harmônico amortecido, h(t) = (1/√(1-ζ²)) e^{-ζωt} sin(ω√(1-ζ²)t) para t≥0. Verifique simetria estendendo para não-causal: h(-t)=h(t) em modelagem simétrica. Aplique escalonamento a=2 para simular resposta em regime supersônico, obtendo h(2t) = (1/2) h(t/2).",
                              "finalVerifications": [
                                "Plot de h(t) e h(-t) sobrepostos confirmam simetria par.",
                                "Cálculo numérico: erro <1% entre h(at) e (1/|a|) h(t/a).",
                                "Análise espectral: magnitude par para simetria.",
                                "Relatório identifica corretamente 2+ exemplos aeronáuticos.",
                                "Simulação em software reproduz propriedades.",
                                "Explicação verbal correta sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das derivações (90%+ correto).",
                                "Qualidade dos plots e verificações numéricas.",
                                "Profundidade na ligação com sistemas aeronáuticos.",
                                "Identificação correta de simetria e escalamento em exemplos.",
                                "Clareza no relatório e avoidance de erros comuns.",
                                "Criatividade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Fourier para análise espectral.",
                                "Física: Dinâmica de vibrações e osciladores em engenharia.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Controle Automático: Modelagem de sistemas LTI."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, identificar simetria em h(t) otimiza filtros para análise de flutter em asas, enquanto escalonamento temporal simula respostas em diferentes velocidades de voo, essencial para certificação de aeronaves pela ANAC/FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.1.3",
                        "name": "Relação com a Integral de Convolução",
                        "description": "Como h(t) permite representar qualquer resposta y(t) de um sistema LTI via convolução y(t) = x(t) * h(t), conectando a análise temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.3.1",
                            "name": "Derivar a integral de convolução a partir de h(t)",
                            "description": "Provar que para sistemas LTI, y(t) = ∫_{-∞}^∞ h(τ) x(t - τ) dτ, usando superposição e invariância no tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades fundamentais de sistemas LTI",
                                  "subSteps": [
                                    "Defina linearidade: superposição de respostas a entradas escaladas e somadas.",
                                    "Defina invariância temporal: resposta a x(t - t0) é y(t - t0).",
                                    "Explique resposta ao impulso h(t) como saída para δ(t).",
                                    "Discuta causalidade e estabilidade se aplicável ao contexto.",
                                    "Esboce um diagrama de bloco de um sistema LTI."
                                  ],
                                  "verification": "Escreva definições precisas das propriedades LTI e dê um exemplo simples.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), caderno e lápis"
                                  ],
                                  "tips": "Use analogias como 'receita de bolo' para linearidade (ingredientes dobrados dobram o bolo).",
                                  "learningObjective": "Compreender as bases teóricas que permitem a derivação da convolução.",
                                  "commonMistakes": [
                                    "Confundir linearidade com não-linearidade aditiva apenas.",
                                    "Ignorar limites de integração para sinais causais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a entrada x(t) como superposição de impulsos",
                                  "subSteps": [
                                    "Lembre a propriedade sifting do delta: ∫ x(τ) δ(t - τ) dτ = x(t).",
                                    "Escreva x(t) = ∫_{-∞}^∞ x(τ) δ(t - τ) dτ.",
                                    "Interprete como x(t) sendo soma infinita de impulsos δ(t - τ) escalados por x(τ).",
                                    "Verifique para uma x(t) discreta aproximada.",
                                    "Desenhe graficamente x(t) e deltas sobrepostos."
                                  ],
                                  "verification": "Derive e simplifique a integral de x(t) com delta para obter x(t).",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Calculadora gráfica ou software como MATLAB para plotar deltas",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Pense no delta como uma 'flecha' infinita fina que 'pica' o valor de x(τ).",
                                  "learningObjective": "Expressar qualquer sinal como combinação linear de impulsos unitários.",
                                  "commonMistakes": [
                                    "Esquecer os limites de -∞ a ∞.",
                                    "Confundir δ(t - τ) com δ(τ - t)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar linearidade para obter a resposta y(t)",
                                  "subSteps": [
                                    "Para entrada δ(t - τ), a saída é h(t - τ) pela invariância temporal.",
                                    "Pela linearidade, y(t) = ∫_{-∞}^∞ x(τ) h(t - τ) dτ.",
                                    "Substitua a expressão de x(t) na equação do sistema.",
                                    "Justifique a troca de limites de integração.",
                                    "Simplifique notação inicial."
                                  ],
                                  "verification": "Escreva y(t) explicitamente como integral envolvendo x(τ) e h(t - τ).",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Folha de derivadas e integrais",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "A linearidade permite 'puxar' x(τ) para fora da resposta ao impulso.",
                                  "learningObjective": "Derivar a forma inicial da convolução usando apenas superposição.",
                                  "commonMistakes": [
                                    "Aplicar invariância prematuramente.",
                                    "Inverter os argumentos de h."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar invariância temporal e reescrever a integral",
                                  "subSteps": [
                                    "Introduza mudança de variável: deixe σ = t - τ, então τ = t - σ, dτ = -dσ.",
                                    "Ajuste limites: quando τ=-∞, σ=∞; τ=∞, σ=-∞; inverta para manter ordem.",
                                    "Substitua: y(t) = ∫_{-∞}^∞ h(σ) x(t - σ) (-dσ) → ∫ h(σ) x(t - σ) dσ.",
                                    "Verifique simetria da convolução.",
                                    "Compare com definição padrão."
                                  ],
                                  "verification": "Mostre que a integral se torna ∫ h(τ) x(t - τ) dτ após mudança.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Tabela de substituições integrais",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Sempre verifique limites após mudança de variável para evitar sinal errado.",
                                  "learningObjective": "Transformar a expressão em h * x usando invariância no tempo.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na jacobiana dτ = -dσ.",
                                    "Não inverter limites corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar a integral de convolução",
                                  "subSteps": [
                                    "Confirme que y(t) = (h * x)(t) = ∫_{-∞}^∞ h(τ) x(t - τ) dτ.",
                                    "Discuta propriedades: comutatividade h*x = x*h.",
                                    "Aplique a casos especiais: x(t)=δ(t) → y(t)=h(t).",
                                    "Estenda para sistemas discretos brevemente.",
                                    "Resolva um exemplo numérico simples."
                                  ],
                                  "verification": "Derive completamente y(t) e teste com entrada delta.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Exemplos de circuitos RC como filtro",
                                    "MATLAB para simulação"
                                  ],
                                  "tips": "Use u(t) e exponenciais para testar causalidade.",
                                  "learningObjective": "Consolidar a prova e entender implicações práticas.",
                                  "commonMistakes": [
                                    "Assumir causalidade sem h(t)=0 para t<0.",
                                    "Ignorar normalização da integral."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um circuito RC com h(t) = (1/RC) e^{-t/RC} u(t) e entrada x(t) = u(t), derive y(t) = ∫_0^t (1/RC) e^{-τ/RC} dτ = 1 - e^{-t/RC}, verificando com solução diferencial.",
                              "finalVerifications": [
                                "Escreva y(t) = ∫_{-∞}^∞ h(τ) x(t - τ) dτ corretamente.",
                                "Prove usando apenas linearidade e invariância, sem Laplace.",
                                "Aplique a um exemplo simples e compare com simulação.",
                                "Identifique erros comuns na mudança de variável.",
                                "Explique verbalmente o processo em 2 minutos.",
                                "Verifique comutatividade da convolução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação passo a passo (sem erros algébricos).",
                                "Correta aplicação de propriedades LTI.",
                                "Uso apropriado de mudança de variável e limites.",
                                "Interpretação física da convolução.",
                                "Capacidade de generalizar para outros sistemas.",
                                "Clareza na escrita e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de integrais e funções de Dirac.",
                                "Física: Dinâmica de sistemas lineares em aeronáutica.",
                                "Computação: Algoritmos FFT para convolução eficiente.",
                                "Engenharia de Controle: Modelagem de plantas aeronáuticas.",
                                "Processamento de Sinais: Filtragem em telemetria de voo."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, a convolução modela a resposta de sistemas de controle de voo (como estabilizadores) a perturbações turbulentas, permitindo simulações precisas de manobras e previsão de estabilidade dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3.2",
                            "name": "Calcular respostas via convolução",
                            "description": "Computar y(t) para entradas específicas como degrau unitário ou exponencial, usando h(t) conhecida e integral de convolução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar as funções de entrada x(t) e resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Analise a função de entrada x(t), como degrau unitário u(t) ou exponencial e^{-at}u(t), definindo seu domínio e expressão matemática.",
                                    "Identifique a resposta ao impulso h(t) fornecida, notando seu domínio (geralmente t >= 0) e qualquer multiplicador como u(t).",
                                    "Esboce graficamente x(t) e h(t) para visualizar o suporte temporal e formas.",
                                    "Verifique unidades e consistência dimensional entre x(t) e h(t).",
                                    "Anote os limites de integração iniciais baseados nos suportes (tipicamente de 0 a t para sistemas causais)."
                                  ],
                                  "verification": "Confirme que x(t) e h(t) estão corretamente expressas e graficadas, com suportes identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Calculadora gráfica ou software como MATLAB/Octave para plots iniciais",
                                    "Tabela de funções comuns de sinais"
                                  ],
                                  "tips": "Sempre inclua o degrau unitário u(t) explicitamente para evitar erros em funções causais.",
                                  "learningObjective": "Compreender as funções envolvidas na convolução e preparar dados para integração.",
                                  "commonMistakes": [
                                    "Esquecer o u(t) nas funções",
                                    "Confundir domínio de x(τ) vs h(t-τ)",
                                    "Ignorar causalidade do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a integral de convolução y(t) = ∫ x(τ) h(t-τ) dτ",
                                  "subSteps": [
                                    "Escreva a fórmula geral: y(t) = ∫_{-∞}^{∞} x(τ) h(t-τ) dτ.",
                                    "Ajuste os limites para causalidade: y(t) = ∫_{0}^{t} x(τ) h(t-τ) dτ se ambos forem causais.",
                                    "Substitua as expressões específicas de x(τ) e h(t-τ) na integral.",
                                    "Simplifique h(t-τ) expandindo, por exemplo, se h(t) = e^{-at}u(t), então h(t-τ) = e^{-a(t-τ)}u(t-τ).",
                                    "Identifique regiões onde a integranda é não-nula (suporte sobreposto)."
                                  ],
                                  "verification": "A integral está escrita corretamente com limites e funções substituídas?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de fórmula de convolução",
                                    "Software simbólico como SymPy ou Mathematica para verificação inicial"
                                  ],
                                  "tips": "Use a propriedade de troca: convolução é comutativa, mas mantenha x(τ)h(t-τ) padrão.",
                                  "learningObjective": "Dominar a formulação precisa da integral de convolução para sistemas LTI contínuos.",
                                  "commonMistakes": [
                                    "Limites errados (ex: -∞ a ∞ em vez de 0 a t)",
                                    "Não expandir h(t-τ) corretamente",
                                    "Confundir variáveis de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar a integral analiticamente",
                                  "subSteps": [
                                    "Divida a integral em intervalos se necessário (baseado em pontos de mudança nas funções).",
                                    "Compute a antiderivada da integranda x(τ)h(t-τ).",
                                    "Avalie nos limites superior (τ=t) e inferior (τ=0), aplicando condições de continuidade.",
                                    "Simplifique o resultado algébricamente, coletando termos e exponenciais.",
                                    "Expresse y(t) em forma fechada, incluindo u(t) se aplicável."
                                  ],
                                  "verification": "Resultado da integração coincide com soluções conhecidas para casos padrão (ex: degrau com exponencial)?",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabelas de integrais indefinidas",
                                    "Calculadora simbólica",
                                    "Exemplos resolvidos de livros como Oppenheim"
                                  ],
                                  "tips": "Para exponenciais, use propriedades de integrais como ∫ e^{bτ} dτ = (1/b)e^{bτ}.",
                                  "learningObjective": "Executar cálculo integral preciso para convolução.",
                                  "commonMistakes": [
                                    "Erros em avaliação de limites",
                                    "Fatorar incorretamente e^{-a t}",
                                    "Esquecer fator t em rampas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, interpretar e visualizar o resultado",
                                  "subSteps": [
                                    "Verifique propriedades: y(t)=0 para t<0, continuidade em t=0, limite para t→∞.",
                                    "Compare com resposta ao degrau se h(t) conhecido.",
                                    "Plote y(t), x(t) e h(t) para inspeção visual.",
                                    "Discuta estabilidade e comportamento transitório/permanente.",
                                    "Teste numericamente em pontos específicos."
                                  ],
                                  "verification": "Gráficos e valores numéricos confirmam o resultado analítico?",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB, Python (Matplotlib/Scipy.signal.convolve)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use scipy.signal.convolve para validação numérica rápida.",
                                  "learningObjective": "Validar e interpretar a resposta convolucionada.",
                                  "commonMistakes": [
                                    "Não verificar causalidade",
                                    "Ignorar plotagem para detecção visual de erros",
                                    "Confundir steady-state"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado x(t) = u(t) (degrau unitário) e h(t) = e^{-2t} u(t), compute y(t) = ∫_0^t e^{-2(t-τ)} dτ = (1/2)(1 - e^{-2t}) u(t). Verifique plotando e comparando com simulação numérica.",
                              "finalVerifications": [
                                "y(t) = 0 para t < 0 (causalidade)?",
                                "Limite t→∞ de y(t) correto para ganho DC do sistema?",
                                "Derivada em t=0+ equals h(0)?",
                                "Integral numérica em pontos discretos coincide com analítica?",
                                "Gráfico de y(t) mostra comportamento esperado (ex: ascendente para degrau)?",
                                "Unidades consistentes em y(t)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da integral (100% correta)",
                                "Cálculo integral sem erros algébricos",
                                "Verificações finais completas e corretas",
                                "Interpretação física adequada do resultado",
                                "Visualizações claras e informativas",
                                "Eficiência no tempo estimado (±20%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral avançado e funções especiais",
                                "Física: Dinâmica de sistemas lineares (ex: circuitos RLC)",
                                "Programação: Simulação numérica com NumPy/SciPy",
                                "Engenharia de Controle: Análise de resposta em malhas fechadas",
                                "Processamento de Sinais: Filtros convolucionais em DSP"
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, calcular a resposta de um sistema de controle de voo (ex: estabilizador) a uma entrada de turbulência modelada como exponencial, usando convolução para prever deslocamentos angulares e otimizar atuadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3.3",
                            "name": "Interpretar h(t) como caracterização completa do sistema",
                            "description": "Explicar que h(t) determina unicamente o sistema LTI, permitindo síntese de respostas arbitrárias via convolução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas LTI e Resposta ao Impulso",
                                  "subSteps": [
                                    "Defina um sistema LTI contínuo no tempo e liste suas propriedades principais (linearidade, invariância temporal).",
                                    "Explique o conceito de resposta ao impulso h(t) como a saída para δ(t).",
                                    "Derive a expressão geral da saída y(t) para uma entrada arbitrária x(t) usando superposição.",
                                    "Discuta como h(t) captura toda a dinâmica do sistema em sistemas LTI.",
                                    "Identifique condições para causalidade e estabilidade baseadas em h(t)."
                                  ],
                                  "verification": "Resuma em um parágrafo como h(t) surge da propriedade de superposição em LTI.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Folha de derivadas de Dirac",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Comece com exemplos simples como integrador ou atraso para visualizar h(t).",
                                  "learningObjective": "Compreender a origem e significado básico de h(t) em LTI.",
                                  "commonMistakes": [
                                    "Confundir h(t) com a função de transferência H(s)",
                                    "Ignorar a necessidade de LTI para validade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Unicidade da Caracterização por h(t)",
                                  "subSteps": [
                                    "Prove que dois sistemas LTI com o mesmo h(t) produzem a mesma y(t) para qualquer x(t).",
                                    "Mostre que h(t) pode ser obtido experimentalmente aplicando δ(t) idealizado.",
                                    "Discuta completude: h(t) determina todas as respostas lineares possíveis.",
                                    "Compare com outras representações (diferenças, estados).",
                                    "Analise se h(t) zero implica sistema trivial."
                                  ],
                                  "verification": "Escreva uma prova curta da unicidade usando propriedades LTI.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para provas",
                                    "Exemplos de sistemas RC/RL",
                                    "Software MATLAB para simulação de impulsos"
                                  ],
                                  "tips": "Use analogia: h(t) é como o 'DNA' do sistema LTI.",
                                  "learningObjective": "Estabelecer que h(t) é uma caracterização única e completa.",
                                  "commonMistakes": [
                                    "Assumir aplicável a não-LTI",
                                    "Confundir com resposta degrau"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar h(t) com a Integral de Convolução",
                                  "subSteps": [
                                    "Derive a fórmula y(t) = ∫ x(τ) h(t-τ) dτ passo a passo.",
                                    "Interprete geometricamente a convolução como 'deslizamento' de h(t).",
                                    "Calcule exemplos numéricos para entradas como degrau e rampa.",
                                    "Verifique propriedades: comutatividade, associatividade.",
                                    "Implemente convolução discretizada em código para visualização."
                                  ],
                                  "verification": "Compute y(t) via convolução para x(t)=u(t) e um h(t) dado, graficando.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy.signal)",
                                    "Tabelas de integrais",
                                    "Gráficos de h(t) exemplos"
                                  ],
                                  "tips": "Mude variáveis para τ para evitar confusão com t.",
                                  "learningObjective": "Dominar síntese de respostas arbitrárias via h(t).",
                                  "commonMistakes": [
                                    "Erros nos limites de integração",
                                    "Confundir convolução com multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Interpretar h(t) em Contextos Práticos",
                                  "subSteps": [
                                    "Analise h(t) de um sistema aeronáutico simples (ex: filtro em controle de voo).",
                                    "Discuta implicações para simulação e identificação de sistemas.",
                                    "Explore decomposição em modos (polos) via h(t).",
                                    "Crie um diagrama conceitual ligando h(t), convolução e y(t).",
                                    "Resolva um problema: dado h(t), encontre y(t) para sinal periódico."
                                  ],
                                  "verification": "Desenhe fluxograma de como h(t) caracteriza completamente o sistema.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de sistemas dinâmicos aeronáuticos",
                                    "Simulink ou MATLAB",
                                    "Artigos sobre identificação de sistemas"
                                  ],
                                  "tips": "Pense em black-box: só h(t) basta para prever qualquer saída.",
                                  "learningObjective": "Interpretar h(t) como ferramenta completa para análise e síntese.",
                                  "commonMistakes": [
                                    "Subestimar importância da causalidade",
                                    "Ignorar normalização de δ(t)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave, h(t) = e^{-t} u(t) modela um amortecedor. Para uma entrada de distúrbio x(t) = sen(ωt), compute y(t) via convolução para prever oscilações de estabilização.",
                              "finalVerifications": [
                                "Explique verbalmente por que h(t) determina unicamente todas as respostas LTI.",
                                "Derive y(t) = x(t) * h(t) sem consultar notas.",
                                "Identifique h(t) a partir de y(t) para δ(t) em um gráfico.",
                                "Aplique convolução corretamente para duas entradas diferentes.",
                                "Discuta limitações se o sistema não for LTI.",
                                "Crie um exemplo próprio de sistema com h(t) característico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da unicidade de h(t) (90% correto).",
                                "Correção matemática na integral de convolução (sem erros de limites).",
                                "Profundidade na interpretação: ligar a aplicações práticas.",
                                "Criatividade em exemplos e verificações personalizadas.",
                                "Clareza em diagramas e explicações verbais.",
                                "Domínio de propriedades LTI subjacentes."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Identificação de plantas via resposta ao impulso.",
                                "Processamento de Sinais: Filtros LTI em radar aeronáutico.",
                                "Física: Modelagem de osciladores harmônicos com h(t).",
                                "Matemática: Análise de integrais improprias e distribuições.",
                                "Computação: Implementação eficiente de FFT para convolução."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, h(t) permite caracterizar completamente o sistema de controle de voo de uma aeronave a partir de testes de impulso, prevendo respostas a turbulências arbitrárias via convolução, essencial para certificação de segurança pela ANAC/FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Integral de Convolução",
                    "description": "Fórmula da convolução para calcular a resposta de sistemas lineares contínuos a entradas arbitrárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Resposta ao Impulso em Sistemas LTI Contínuos",
                        "description": "A resposta ao impulso h(t) é a saída de um sistema linear e invariante no tempo (LTI) contínuo quando a entrada é a função delta de Dirac δ(t), servindo como base para representar qualquer resposta a entradas arbitrárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir a resposta ao impulso h(t)",
                            "description": "Explicar o conceito de resposta ao impulso como a saída y(t) = h(t) para x(t) = δ(t), destacando sua unicidade para sistemas LTI e sua representação no diagrama de blocos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o sinal impulso de Dirac δ(t)",
                                  "subSteps": [
                                    "Estudar a definição matemática do δ(t) como uma distribuição com ∫_{-∞}^{∞} δ(t) dt = 1 e δ(t) = 0 para t ≠ 0.",
                                    "Analisar as propriedades sift (peneira): ∫_{-∞}^{∞} f(t) δ(t - t_0) dt = f(t_0).",
                                    "Explorar representações aproximadas, como limite de pulsos retangulares estreitos.",
                                    "Verificar simetricidade e derivadas do δ(t).",
                                    "Discutir o papel do δ(t) como entrada idealizada para testar sistemas."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as três principais propriedades do δ(t) e resolver um integral simples envolvendo δ(t).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), papel e caneta, software MATLAB para plotar aproximações"
                                  ],
                                  "tips": "Visualize δ(t) como uma seta infinita em t=0 com área unitária para intuitividade.",
                                  "learningObjective": "Dominar a definição e propriedades fundamentais do impulso unitário δ(t).",
                                  "commonMistakes": "Tratar δ(t) como uma função convencional em vez de distribuição; esquecer que sua amplitude é infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Estabelecer que para qualquer sistema, a resposta à entrada x(t) = δ(t) é y(t) = h(t).",
                                    "Derivar conceitualmente y(t) = ∫_{-∞}^{∞} h(τ) δ(t - τ) dτ = h(t).",
                                    "Diferenciar h(t) de outras respostas (ex: degrau).",
                                    "Explorar causalidade: h(t) = 0 para t < 0 em sistemas causais.",
                                    "Esboçar um diagrama temporal de entrada δ(t) e saída h(t)."
                                  ],
                                  "verification": "Escrever a equação y(t) = h(t) para x(t) = δ(t) e justificar usando propriedades do δ(t).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou software de desenho (ex: Draw.io), exemplos de sistemas lineares"
                                  ],
                                  "tips": "Sempre associe h(t) à 'assinatura' única do sistema para entradas impulsivas.",
                                  "learningObjective": "Definir precisamente h(t) como saída ao impulso unitário.",
                                  "commonMistakes": "Confundir h(t) com a função de transferência H(s); ignorar a dependência em sistemas não lineares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Destacar a unicidade em sistemas LTI",
                                  "subSteps": [
                                    "Explicar por que h(t) é única em LTI: decomposição qualquer entrada em impulsos via convolução.",
                                    "Derivar y(t) = ∫_{-∞}^{∞} h(τ) x(t - τ) dτ a partir de superposição.",
                                    "Comparar com sistemas não lineares, onde h(t) não caracteriza completamente.",
                                    "Discutir estabilidade e invertibilidade baseadas em h(t).",
                                    "Resolver um exemplo simples de convolução com h(t) conhecida."
                                  ],
                                  "verification": "Provar que para LTI, qualquer resposta é convolução com h(t), usando superposição de impulsos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: Mathematica ou SymPy), tabelas de Laplace para verificação"
                                  ],
                                  "tips": "Lembre-se: LTI garante que h(t) + convolução = tudo; teste com x(t) = u(t).",
                                  "learningObjective": "Compreender a unicidade e centralidade de h(t) em sistemas LTI contínuos.",
                                  "commonMistakes": "Aplicar unicidade a sistemas não LTI; confundir com resposta em frequência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representar h(t) no diagrama de blocos",
                                  "subSteps": [
                                    "Desenhar diagrama de blocos padrão: entrada x(t) → convolução com h(t) → saída y(t).",
                                    "Simbolizar a convolução como ∫ h(τ) x(t - τ) dτ no bloco.",
                                    "Incluir blocos para δ(t) → h(t) como ramificação de caracterização.",
                                    "Estender para domínio da frequência: H(ω) como transformada de Fourier de h(t).",
                                    "Implementar numericamente em software para visualização."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama de blocos mostrando h(t) e convolução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software Simulink ou MATLAB, templates de diagramas de blocos"
                                  ],
                                  "tips": "Use setas duplas para convolução para enfatizar operação bilateral.",
                                  "learningObjective": "Visualizar graficamente o papel de h(t) em análise de sistemas LTI.",
                                  "commonMistakes": "Desenhar convolução como multiplicação simples; omitir limites de integração."
                                }
                              ],
                              "practicalExample": "Considere um circuito RC série com R=1kΩ, C=1μF. A resposta ao impulso é h(t) = 1000 e^{-1000 t} u(t). Simule em MATLAB: plotar δ(t) aproximado → convolução → h(t), verificando y(t) = h(t) para x(t)=δ(t).",
                              "finalVerifications": [
                                "Definir corretamente h(t) = y(t)|_{x(t)=δ(t)}.",
                                "Explicar unicidade via convolução em LTI.",
                                "Desenhar diagrama de blocos com convolução.",
                                "Calcular h(t) para um sistema RC simples.",
                                "Diferenciar h(t) de respostas a degrau ou rampa.",
                                "Verificar propriedades causais de h(t)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de h(t) (30%).",
                                "Compreensão da unicidade em LTI vs. não-LTI (25%).",
                                "Qualidade do diagrama de blocos e derivação de convolução (20%).",
                                "Exemplos práticos corretos e verificações (15%).",
                                "Identificação de erros comuns e propriedades (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de distribuições e integrais de convolução.",
                                "Engenharia de Controle: Função de transferência H(s) como Laplace de h(t).",
                                "Física: Respostas transitórias em sistemas dinâmicos.",
                                "Processamento de Sinais: Filtros LTI e análise espectral."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, h(t) modela a resposta impulsiva de sistemas de controle de voo a perturbações como rajadas de vento, permitindo simulações de estabilidade em aeronaves via convolução com perfis de entrada reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Identificar a importância da h(t) para análise de sistemas",
                            "description": "Descrever como h(t) permite decompor qualquer entrada arbitrária em impulsos elementares, fundamentando a superposição em sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Defina h(t) como a saída de um sistema LTI contínuo quando a entrada é um impulso unitário δ(t).",
                                    "Revise propriedades do impulso unitário δ(t): integral unitária, simetria e comportamento como 'sonda' do sistema.",
                                    "Estude exemplos simples: h(t) para integrador (rampa) e diferenciador.",
                                    "Analise graficamente h(t) para sistemas de primeira e segunda ordem.",
                                    "Discuta causalidade: h(t) = 0 para t < 0 em sistemas causais."
                                  ],
                                  "verification": "Desenhe e rotule h(t) para um sistema RC de primeira ordem e explique sua interpretação física.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim), simulador MATLAB/Octave, papel e lápis para gráficos"
                                  ],
                                  "tips": "Visualize h(t) como a 'assinatura' única do sistema, revelando dinâmicas internas.",
                                  "learningObjective": "Identificar h(t) como a resposta elementar que caracteriza completamente sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir h(t) com resposta ao degrau u(t)",
                                    "Ignorar propriedades de linearidade e invariância no tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor uma entrada arbitrária x(t) em impulsos elementares",
                                  "subSteps": [
                                    "Represente x(t) como integral de impulsos: x(t) = ∫ x(τ) δ(t - τ) dτ.",
                                    "Interprete fisicamente: cada instante τ contribui um impulso escalado x(τ) δ(t - τ).",
                                    "Pratique com sinais simples: degrau, rampa e senoide.",
                                    "Desenhe diagramas ilustrando a 'densidade' de impulsos ao longo do tempo.",
                                    "Calcule numericamente a decomposição para um sinal discreto aproximado."
                                  ],
                                  "verification": "Escreva a expressão matemática de x(t) como superposição de impulsos e grafique para x(t) = u(t).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python com Matplotlib), exemplos de sinais do capítulo de convolução"
                                  ],
                                  "tips": "Pense na entrada como uma 'chuva' contínua de impulsos ponderados pela amplitude x(τ).",
                                  "learningObjective": "Dominar a representação de qualquer sinal como combinação linear de impulsos unitários.",
                                  "commonMistakes": [
                                    "Esquecer o fator de escala x(τ)",
                                    "Confundir com amostragem discreta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o princípio de superposição linear para obter a saída y(t)",
                                  "subSteps": [
                                    "Para cada impulso de entrada x(τ) δ(t - τ), a saída é x(τ) h(t - τ).",
                                    "Some todas as respostas via integral: y(t) = ∫ x(τ) h(t - τ) dτ.",
                                    "Verifique linearidade: propriedade de adição e homogeneidade preserva superposição.",
                                    "Compare com métodos alternativos (Laplace) para validar.",
                                    "Simule convolução para um exemplo numérico simples."
                                  ],
                                  "verification": "Derive a integral de convolução a partir da superposição e compute y(t) para x(t)=δ(t), confirmando y(t)=h(t).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou MATLAB Symbolic), tabelas de convolução"
                                  ],
                                  "tips": "Mude variáveis para t - τ para visualizar o 'espelhamento e deslize' de h(t).",
                                  "learningObjective": "Explicar como h(t) habilita a análise de qualquer entrada via superposição.",
                                  "commonMistakes": [
                                    "Inverter a ordem na convolução (x*h ≠ h*x em geral)",
                                    "Negligenciar limites de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a importância de h(t) na análise de sistemas LTI",
                                  "subSteps": [
                                    "Resuma: h(t) é suficiente para prever qualquer resposta y(t) via convolução.",
                                    "Discuta vantagens: generalidade para entradas arbitrárias, insight em dinâmicas transitórias.",
                                    "Compare com frequência: h(t) ↔ H(jω), dualidade tempo-frequência.",
                                    "Aplique a sistemas aeronáuticos: modelagem de flaps ou sensores.",
                                    "Reflita sobre extensões: discretos, não-lineares."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que h(t) é central para análise de sistemas lineares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos sobre controle de aeronaves, resumo pessoal"
                                  ],
                                  "tips": "Enfatize: sem h(t), análise de entradas complexas seria intratável.",
                                  "learningObjective": "Articular o papel fundamental de h(t) na decomposição e superposição.",
                                  "commonMistakes": [
                                    "Subestimar aplicabilidade apenas a impulsos",
                                    "Confundir com resposta em frequência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de atitude em aeronave modelado como um oscilador amortecido (segunda ordem). Dê uma entrada de comando de leme x(t) = rampa unitária. Decomponha x(t) em impulsos, convolve com h(t) obtida da equação diferencial, e plote y(t) mostrando sobressinal e estabilização, validando estabilidade via h(t).",
                              "finalVerifications": [
                                "Explicar verbalmente como h(t) permite análise de qualquer x(t).",
                                "Derivar y(t) = x(t) * h(t) a partir de superposição.",
                                "Identificar h(t) em um diagrama de sistema LTI.",
                                "Comparar respostas para diferentes x(t) usando a mesma h(t).",
                                "Discutir limitações para sistemas não-lineares.",
                                "Simular convolução em software e interpretar resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta definição e derivação de h(t) e convolução (30%).",
                                "Clareza explicativa: Uso de analogias e gráficos eficazes (25%).",
                                "Profundidade de análise: Conexão explícita com superposição linear (20%).",
                                "Exemplos práticos: Aplicação coerente a cenários reais (15%).",
                                "Verificações: Evidência de compreensão via simulações ou derivações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de sistemas massa-mola-amortecedor em vibrações aeronáuticas.",
                                "Matemática: Integrais improprios e transformadas (Laplace/Fourier).",
                                "Engenharia de Controle: Projeto de compensadores baseados em h(t).",
                                "Processamento de Sinais: Filtros em telemetria de voo."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, h(t) é crucial para simular respostas de aeronaves a perturbações (turbulência), projetando sistemas de controle autônomo que preveem e estabilizam atitudes via convolução em tempo real, como no autopilot do Boeing 787."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Relacionar h(t) com propriedades causais e estáveis",
                            "description": "Analisar condições como h(t) = 0 para t < 0 (causalidade) e ∫|h(t)|dt < ∞ (estabilidade BIBO) em contextos de sistemas dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Sistemas LTI e Resposta ao Impulso",
                                  "subSteps": [
                                    "Defina sistema LTI contínuo e explique o papel da resposta ao impulso h(t).",
                                    "Recapitule a integral de convolução y(t) = ∫ x(τ) h(t-τ) dτ.",
                                    "Discuta propriedades ideais de sistemas: causalidade e estabilidade BIBO.",
                                    "Identifique como h(t) encapsula essas propriedades.",
                                    "Esboce gráficos qualitativos de h(t) causais vs. não causais."
                                  ],
                                  "verification": "Resuma em um parágrafo as relações entre h(t), causalidade e estabilidade; verifique com fórmulas chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas (ex: Oppenheim), caderno, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Use analogias físicas: h(t) como 'impressão digital' do sistema.",
                                  "learningObjective": "Compreender o significado físico e matemático de h(t) em sistemas dinâmicos.",
                                  "commonMistakes": "Confundir h(t) com resposta ao degrau; ignorar domínio do tempo contínuo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Condição de Causalidade via h(t)",
                                  "subSteps": [
                                    "Estude a definição: sistema causal se saída depende só de entradas passadas/presentes.",
                                    "Derive que para LTI, causalidade implica h(t) = 0 para t < 0.",
                                    "Prove o converse: se h(t) = 0 para t < 0, sistema é causal.",
                                    "Analise exemplos: h(t) = e^{-t} u(t) (causal) vs. h(t) = e^{t} para t < 0 (não causal).",
                                    "Plote h(t) e verifique suporte temporal."
                                  ],
                                  "verification": "Classifique 3 funções h(t) como causais ou não, justificando graficamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (MATLAB/Octave/Python Matplotlib), exemplos de h(t) impressos.",
                                  "tips": "Lembre: u(t) é a função degrau unitária; foque no eixo t=0.",
                                  "learningObjective": "Dominar a relação matemática entre suporte de h(t) e causalidade.",
                                  "commonMistakes": "Esquecer que causalidade é para t<0 estritamente; confundir com real-causalidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Estabilidade BIBO via Integral de h(t)",
                                  "subSteps": [
                                    "Recapitule BIBO: entrada limitada implica saída limitada.",
                                    "Derive critério: ∫_{-∞}^∞ |h(t)| dt < ∞ para estabilidade absoluta.",
                                    "Calcule a integral para exemplos: RC low-pass (estável), integrador (instável).",
                                    "Compare com polos no semiplano esquerdo (domínio Laplace).",
                                    "Avalie convergência: decaimento exponencial vs. oscilatório."
                                  ],
                                  "verification": "Compute ∫|h(t)|dt para 2 funções e classifique estabilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Tabelas de integrais, simulador (Scilab), papel milimetrado.",
                                  "tips": "Use |h(t)| para absoluta; teste com entradas como u(t).",
                                  "learningObjective": "Aplicar teste de integral para verificar estabilidade BIBO.",
                                  "commonMistakes": "Usar ∫ h(t) dt em vez de |h(t)|; ignorar limites infinitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Análise de Causalidade e Estabilidade em Contextos Aeronáuticos",
                                  "subSteps": [
                                    "Analise h(t) de um sistema de controle de aeronave (ex: filtro de atitude).",
                                    "Verifique ambas propriedades simultaneamente.",
                                    "Simule resposta a impulso em software.",
                                    "Discuta implicações: não-causal inviável em voo real; instável perigoso.",
                                    "Crie tabela comparativa de sistemas estáveis/causais."
                                  ],
                                  "verification": "Produza relatório de 1 página analisando h(t) específico de um sistema LTI aeronáutico.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Exemplos de sistemas aeronáuticos (notas de aula), MATLAB/Simulink trial.",
                                  "tips": "Contextualize com flight dynamics: h(t) modela flaps ou autopilot.",
                                  "learningObjective": "Relacionar propriedades de h(t) a aplicações práticas em engenharia.",
                                  "commonMistakes": "Ignorar contexto real; superestimar simulações sem validação."
                                }
                              ],
                              "practicalExample": "Considere um circuito RC série como modelo simplificado de sensor de atitude em aeronave: h(t) = (1/RC) e^{-t/RC} u(t). Verifique causalidade (suporte t≥0) e estabilidade (∫|h(t)|dt = 1 < ∞). Simule em Python: plote h(t), compute integral e teste BIBO com x(t)=1.",
                              "finalVerifications": [
                                "h(t) satisfaz h(t)=0 para t<0 em todos exemplos analisados.",
                                "Integral ∫|h(t)|dt converge para <∞ em sistemas estáveis.",
                                "Classificação correta de 5 funções h(t) testadas.",
                                "Relatório integra causalidade e estabilidade com contexto aeronáutico.",
                                "Simulação reproduz propriedades teóricas.",
                                "Tabela comparativa completa e precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (30%)",
                                "Correta aplicação de testes causal/estável (25%)",
                                "Qualidade de exemplos e simulações (20%)",
                                "Integração contextual em aeronáutica (15%)",
                                "Clareza em verificações e relatórios (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Polos de h(s) relacionam estabilidade.",
                                "Processamento de Sinais: Filtros digitais discretos análogos.",
                                "Física Aeronáutica: Modelos dinâmicos de voo LTI.",
                                "Matemática Avançada: Análise de Fourier/Laplace de h(t)."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, projetar autopilotos requer h(t) causal e estável para garantir respostas seguras a perturbações como turbulência, evitando oscilações perigosas ou delays em estabilização de atitude."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Fórmula da Integral de Convolução",
                        "description": "A integral de convolução expressa a resposta y(t) de um sistema LTI contínuo a uma entrada arbitrária x(t) como y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ, representando a superposição de respostas escaladas e deslocadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Escrever e interpretar a fórmula da convolução",
                            "description": "Derivar e explicar a fórmula y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ ou equivalentemente ∫_{-∞}^{∞} h(τ) x(t - τ) dτ, incluindo limites para sistemas causais (0 a t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Convolução",
                                  "subSteps": [
                                    "Revise os conceitos de sinal de entrada x(t), resposta ao impulso h(t) e saída y(t) em sistemas LTI contínuos.",
                                    "Entenda que a convolução representa a sobreposição de efeitos escalados e deslocados da resposta ao impulso.",
                                    "Identifique os limites de integração (-∞ a ∞) para sistemas não causais.",
                                    "Discuta a propriedade de comutatividade da convolução.",
                                    "Visualize graficamente como h(t - τ) é o impulso deslocado e escalado por x(τ)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel de cada componente na convolução e desenhe um diagrama ilustrativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), papel e caneta para diagramas, vídeo tutorial sobre LTI systems"
                                  ],
                                  "tips": "Use animações online para visualizar o 'flip and slide' da convolução.",
                                  "learningObjective": "Dominar os conceitos básicos que justificam a fórmula da convolução.",
                                  "commonMistakes": [
                                    "Confundir h(t) com h(t - τ), ignorar a integração sobre τ como variável dummy."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Escrever a Fórmula Geral da Convolução",
                                  "subSteps": [
                                    "Parta da superposição linear: y(t) = ∫ x(τ) δ(t - τ) dτ para entrada delta, generalize para x(t).",
                                    "Derive y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ mostrando o escalamento por x(τ) e deslocamento.",
                                    "Escreva a fórmula explicitamente com limites de -∞ a ∞.",
                                    "Verifique dimensionalmente: x(τ) h(t - τ) dτ tem unidades de y(t).",
                                    "Pratique escrevendo a fórmula 5 vezes de memória."
                                  ],
                                  "verification": "Derive a fórmula do zero em uma folha e confira com a referência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Quadro branco ou papel sulfite, calculadora simbólica (Wolfram Alpha para verificação), notas de aula"
                                  ],
                                  "tips": "Pense na integral como 'soma ponderada' de contribuições em diferentes τ.",
                                  "learningObjective": "Capacidade de derivar e escrever corretamente a fórmula y(t) = ∫ x(τ) h(t - τ) dτ.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em (t - τ), usar limites errados como 0 a ∞ prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Forma Equivalente e Simetria",
                                  "subSteps": [
                                    "Mostre a comutatividade: substitua τ' = t - τ para obter ∫ h(τ) x(t - τ) dτ.",
                                    "Escreva ambas as formas lado a lado e compare.",
                                    "Explique por que são equivalentes (mudança de variável).",
                                    "Discuta quando usar cada uma (ex: h(τ) para sistemas causais).",
                                    "Teste com funções simples como retângulos para verificar igualdade numérica."
                                  ],
                                  "verification": "Compute ambas as formas para x(t) = u(t), h(t) = e^{-t} u(t) e confirme y(t) igual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy para integrais simbólicas), exemplos impressos"
                                  ],
                                  "tips": "Use a propriedade de comutatividade para simplificar cálculos assimétricos.",
                                  "learningObjective": "Entender e demonstrar as duas formas equivalentes da fórmula.",
                                  "commonMistakes": [
                                    "Não inverter corretamente na mudança de variável, confundir x e h nas formas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adaptar para Sistemas Causais e Interpretar Fisicamente",
                                  "subSteps": [
                                    "Para sistemas causais (h(t)=0 para t<0), mude limites para ∫_0^t x(τ) h(t - τ) dτ.",
                                    "Justifique: contribuições futuras não afetam saída presente.",
                                    "Interprete: para cada τ passado, h(t - τ) é a resposta decorrente do input em τ.",
                                    "Aplique em contexto aeronáutico: convolução para resposta de asa a rajada de vento.",
                                    "Resuma interpretação: 'memória' do sistema sobre inputs passados."
                                  ],
                                  "verification": "Escreva a fórmula causal e explique sua interpretação em um parágrafo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de sistemas aeronáuticos, simulador online de convolução"
                                  ],
                                  "tips": "Lembre: causalidade corta o integral no futuro (τ > t).",
                                  "learningObjective": "Aplicar e interpretar a fórmula para casos causais reais.",
                                  "commonMistakes": [
                                    "Usar limites 0 a ∞ em vez de 0 a t, ignorar que t-τ >=0 implica τ <=t."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aeronave, a entrada x(t) é uma rajada de vento modelada como pulso retangular unitário de duração 1s. A resposta ao impulso h(t) = e^{-2t} u(t) (amortecimento rápido). Compute y(t) via convolução para t=0.5s (causal: ∫_0^{0.5} 1 * e^{-2(0.5 - τ)} dτ = (1 - e^{-1})/2 ≈ 0.432, interpretando a saída como deflexão angular acumulada.",
                              "finalVerifications": [
                                "Escreve corretamente ambas as formas gerais da fórmula de memória.",
                                "Deriva a versão causal com limites 0 a t.",
                                "Explica fisicamente o significado de τ como 'tempo de contribuição passada'.",
                                "Verifica comutatividade com um exemplo numérico simples.",
                                "Identifica quando usar limites causais vs. gerais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e escrita das fórmulas (100% correto).",
                                "Profundidade na interpretação física (inclui sobreposição e causalidade).",
                                "Correção nos limites de integração para casos causais.",
                                "Uso apropriado de notação matemática (τ dummy, dτ).",
                                "Capacidade de relacionar a exemplos reais em aeronáutica.",
                                "Clareza na explicação da equivalência das formas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e mudança de variáveis.",
                                "Física: Dinâmica de sistemas lineares e causalidade.",
                                "Programação: Implementação numérica em MATLAB/Python para simulações.",
                                "Engenharia de Controle: Aplicação em filtros e respostas transitórias."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a convolução modela a resposta de estruturas de aeronaves (asas, fuselagem) a cargas dinâmicas como turbulência ou manobras, permitindo simular deflexões e cargas em software de análise dinâmica para design seguro e eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Explicar a interpretação física da convolução",
                            "description": "Interpretar a integral como soma de respostas a impulsos infinitesimalmente deslocados e escalados pela entrada x(τ), com gráficos de x(τ), h(t-τ) e produto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Resposta ao Impulso Unitário h(t)",
                                  "subSteps": [
                                    "Definir o impulso unitário δ(t) como uma função que concentra toda a energia em t=0.",
                                    "Explicar que h(t) é a saída do sistema LTI para a entrada δ(t), capturando a dinâmica completa do sistema.",
                                    "Discutir propriedades de sistemas lineares e invariantes no tempo (LTI) que justificam a convolução.",
                                    "Identificar exemplos de h(t), como exponenciais decrescentes em circuitos RC.",
                                    "Verificar linearidade somando duas respostas a impulsos escalados."
                                  ],
                                  "verification": "Desenhar e rotular corretamente o gráfico de h(t) para um sistema dado e explicar seu significado físico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim)",
                                    "Papel gráfico ou software como MATLAB/Octave para plotar h(t)",
                                    "Exemplos de funções h(t) impressas"
                                  ],
                                  "tips": [
                                    "Visualize h(t) como o 'DNA' do sistema: ela dita como o sistema responde a qualquer entrada."
                                  ],
                                  "learningObjective": "Entender h(t) como a resposta fundamental que permite decompor qualquer entrada em impulsos.",
                                  "commonMistakes": [
                                    "Confundir h(t) com a função de transferência H(s)",
                                    "Ignorar que h(t) é zero para t<0 em sistemas causais",
                                    "Esquecer a invariância no tempo no deslocamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor a Entrada x(t) em Impulsos Infinitesimais",
                                  "subSteps": [
                                    "Representar x(t) como integral de x(τ) δ(t-τ) dτ, uma soma infinita de impulsos deslocados.",
                                    "Explicar que cada x(τ) dτ é um impulso infinitesimal de amplitude x(τ) na posição τ.",
                                    "Desenhar graficamente x(τ) e sobrepor impulsos δ(t-τ) escalados por x(τ) dτ.",
                                    "Calcular a resposta a um único impulso deslocado: x(τ) dτ * h(t-τ).",
                                    "Verificar a decomposição aproximando x(t) por uma soma finita de impulsos (staircase approximation)."
                                  ],
                                  "verification": "Esboçar x(τ) e mostrar 3-5 impulsos infinitesimais escalados e deslocados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de funções x(t) exemplo (ex: degrau unitário)",
                                    "Ferramenta de desenho vetorial ou papel milimetrado",
                                    "Vídeo tutorial sobre decomposição em impulsos"
                                  ],
                                  "tips": [
                                    "Pense em x(τ) dτ como 'pedacinhos' da entrada, cada um excitando o sistema independentemente."
                                  ],
                                  "learningObjective": "Dominar a representação da entrada arbitrária como superposição de impulsos δ(t-τ).",
                                  "commonMistakes": [
                                    "Usar h(τ) em vez de h(t-τ)",
                                    "Esquecer o escalonamento por x(τ)",
                                    "Confundir o deslocamento τ com t"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Contribuição de Cada Impulso e a Soma (Integral)",
                                  "subSteps": [
                                    "Derivar a contribuição de cada impulso: y_τ(t) = x(τ) h(t-τ) dτ.",
                                    "Explicar o produto x(τ) h(t-τ) como sobreposição temporal para tempo fixo t.",
                                    "Visualizar a integral ∫ x(τ) h(t-τ) dτ como área sob a curva do produto para t fixo.",
                                    "Animar mentalmente como o gráfico de h(t-τ) 'varre' x(τ) à medida que τ varia.",
                                    "Comparar com soma discreta para validar a interpretação contínua."
                                  ],
                                  "verification": "Para t fixo, plotar x(τ), h(t-τ) e seu produto, sombreando a área da integral.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib)",
                                    "Exemplos numéricos de convolução passo-a-passo",
                                    "Tabela de valores para x(τ) e h(t-τ)"
                                  ],
                                  "tips": [
                                    "Fixe t e veja h(t-τ) como h invertida e deslocada; o produto destaca onde contribuem."
                                  ],
                                  "learningObjective": "Conectar a fórmula matemática à soma física de respostas escaladas e deslocadas.",
                                  "commonMistakes": [
                                    "Plotar h(τ) em vez de h(t-τ)",
                                    "Integrar sobre t em vez de τ",
                                    "Ignorar que dτ é infinitesimal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Sintetizar a Interpretação Física Completa",
                                  "subSteps": [
                                    "Montar os gráficos completos: x(τ), h(t-τ) para vários t, produtos e y(t).",
                                    "Explicar fisicamente: 'a saída é a soma ponderada das respostas do sistema a fatias da entrada'.",
                                    "Discutir causalidade: y(t) depende só de x(τ) para τ ≤ t.",
                                    "Aplicar a um exemplo numérico simples, computando y(t) manualmente.",
                                    "Resumir em diagrama de blocos: entrada → impulsos → respostas → soma."
                                  ],
                                  "verification": "Criar um diagrama completo explicando a convolução e apresentá-lo oralmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios com gráficos vazios para preencher",
                                    "Vídeos animados de convolução (ex: YouTube 3Blue1Brown)",
                                    "Calculadora para integrais numéricas"
                                  ],
                                  "tips": [
                                    "Use animações para ver o 'varrimento' em ação; ajuda a fixar a intuição."
                                  ],
                                  "learningObjective": "Sintetizar a visão física da convolução como superposição de respostas a impulsos.",
                                  "commonMistakes": [
                                    "Não fixar t ao plotar",
                                    "Confundir convolução com correlação",
                                    "Esquecer o papel da linearidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de aeronave com h(t) = 2 e^{-t} u(t) (resposta ao impulso de aceleração). Para entrada x(t) = u(t) (comando degrau), a convolução y(t) = ∫_0^t 2 e^{-(t-τ)} dτ = 2(1 - e^{-t}) u(t). Graficamente, para t=1, plote x(τ) de 0 a 1, h(1-τ) decrescendo de 2 a 1, produto e área ≈1.26, matching y(1).",
                              "finalVerifications": [
                                "Explica verbalmente a convolução como soma de respostas a impulsos deslocados sem consultar notas.",
                                "Desenha corretamente os três gráficos (x(τ), h(t-τ), produto) para t fixo.",
                                "Computa numericamente y(t) para um exemplo simples e interpreta fisicamente.",
                                "Identifica corretamente contribuições para τ > t (zero em sistemas causais).",
                                "Distingue interpretação física de derivação matemática.",
                                "Aplica a ideia a um novo h(t) e x(t) simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da decomposição em impulsos (escalados por x(τ) dτ).",
                                "Correção gráfica: alinhamento de eixos, deslocamentos e sombreamento da integral.",
                                "Profundidade da intuição física: uso de termos como 'superposição', 'resposta deslocada'.",
                                "Habilidade em visualizar para t fixo vs. evolução em t.",
                                "Identificação de erros comuns e causalidade.",
                                "Criatividade em ligar a exemplos reais de sistemas dinâmicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aproximação de Riemann e interpretação geométrica de integrais.",
                                "Física: Princípio de superposição em ondas e mecânica (ex: resposta a forças impulsivas).",
                                "Computação: Implementação numérica de convolução em Python/MATLAB para simulações.",
                                "Engenharia de Controle: Modelagem de sistemas aeronáuticos LTI."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a convolução modela a resposta de uma aeronave a comandos de piloto (x(t)), onde h(t) é a resposta ao impulso derivada de testes de voo. Permite prever trajetória, estabilidade e simular manobras sem voos reais, essencial em design de flight controllers e análise de fadiga estrutural por vibrações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Cálculo e Propriedades da Convolução",
                        "description": "Propriedades como comutatividade, associatividade e distributividade facilitam o cálculo da convolução, aplicado em exemplos de sistemas mecânicos, térmicos e hidráulicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Listar e demonstrar propriedades da convolução",
                            "description": "Demonstrar propriedades: x(t)*h(t) = h(t)*x(t) (comutatividade), (x*h1)*h2 = x*(h1*h2) (associatividade), x*(h1 + h2) = x*h1 + x*h2 (distributividade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição de convolução e listar propriedades principais",
                                  "subSteps": [
                                    "Relembrar a definição da integral de convolução: (x * h)(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ",
                                    "Listar as três propriedades: comutatividade x(t)*h(t) = h(t)*x(t), associatividade (x*h1)*h2 = x*(h1*h2), distributividade x*(h1 + h2) = x*h1 + x*h2",
                                    "Escrever as equações matemáticas para cada propriedade em um caderno",
                                    "Explicar verbalmente o significado físico de cada propriedade em sistemas lineares",
                                    "Criar um quadro-resumo com as propriedades e exemplos simbólicos"
                                  ],
                                  "verification": "Recitar as três propriedades com equações corretas sem consultar notas",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Sinais e Sistemas, caderno, calculadora simbólica (ex: MATLAB ou papel)",
                                  "tips": "Use cores diferentes para cada propriedade no quadro-resumo para facilitar memorização",
                                  "learningObjective": "Identificar e enunciar precisamente as propriedades algébricas da convolução",
                                  "commonMistakes": "Esquecer os limites de integração ou confundir comutatividade com simetria de funções"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar propriedade de comutatividade",
                                  "subSteps": [
                                    "Partir da definição: calcular (x * h)(t) = ∫ x(τ) h(t - τ) dτ",
                                    "Fazer substituição de variável: deixar σ = t - τ, então dσ = -dτ, τ = t - σ",
                                    "Reescrever a integral: ∫ h(σ) x(t - σ) (-dσ) = ∫ h(σ) x(t - σ) dσ (invertendo limites)",
                                    "Concluir que (x * h)(t) = (h * x)(t)",
                                    "Verificar com funções simples, como exponenciais decrescentes"
                                  ],
                                  "verification": "Derivar a prova em papel e confirmar igualdade para um exemplo numérico",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, software de plotagem (ex: MATLAB para gráficos)",
                                  "tips": "Sempre inverta os limites de integração ao substituir variáveis para evitar erros de sinal",
                                  "learningObjective": "Provar matematicamente a comutatividade da convolução",
                                  "commonMistakes": "Ignorar a inversão dos limites de integração, levando a sinal negativo incorreto"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar propriedade de associatividade",
                                  "subSteps": [
                                    "Definir ((x * h1) * h2)(t) usando definição dupla de convolução",
                                    "Expandir a integral externa: ∫ [∫ x(τ) h1(σ - τ) dτ] h2(t - σ) dσ",
                                    "Trocar ordem de integração (Fubini para funções integráveis): ∫∫ x(τ) h1(σ - τ) h2(t - σ) dτ dσ",
                                    "Reagrupar para forma x * (h1 * h2): mostrar igualdade com ∫ x(τ) [∫ h1(σ - τ) h2(t - σ) dσ] dτ",
                                    "Testar com funções retangulares para validação gráfica"
                                  ],
                                  "verification": "Escrever a prova completa e computar numericamente ambos os lados para t=0",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Caderno de integrais, MATLAB ou Python (SciPy para convolução)",
                                  "tips": "Use teorema de Fubini justificadamente; pratique com regiões finitas primeiro",
                                  "learningObjective": "Provar que a convolução é associativa, permitindo cascata de sistemas",
                                  "commonMistakes": "Trocar incorretamente ordem de integração sem justificar convergência"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar propriedade de distributividade e sintetizar",
                                  "subSteps": [
                                    "Provar x*(h1 + h2)(t) = ∫ x(τ) [h1(t-τ) + h2(t-τ)] dτ = ∫ x(τ)h1(t-τ)dτ + ∫ x(τ)h2(t-τ)dτ",
                                    "Verificar lineariedade diretamente da definição da convolução",
                                    "Sintetizar todas propriedades: discutir implicações em decomposição de sistemas LTI",
                                    "Aplicar propriedades em um exemplo composto: somar dois impulsos de resposta",
                                    "Criar fluxograma de como usar propriedades para simplificar cálculos"
                                  ],
                                  "verification": "Resolver um problema onde propriedades reduzem cálculo complexo",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de livro-texto, simulador de sinais (ex: Octave)",
                                  "tips": "Distributividade é a mais simples; use-a para validar implementações numéricas",
                                  "learningObjective": "Provar distributividade e integrar todas propriedades em análise de sistemas",
                                  "commonMistakes": "Confundir distributividade com propriedades de Fourier ou Laplace"
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aeronave, considere a resposta ao impulso h(t) como soma de dois filtros h1(t) (baixa frequência) e h2(t) (alta frequência). Use distributividade para calcular resposta a entrada x(t): x*(h1+h2) = x*h1 + x*h2, plotando saídas separadas e somando para verificar.",
                              "finalVerifications": [
                                "Listar corretamente as três propriedades com equações exatas",
                                "Derivar prova de comutatividade sem erros de integração",
                                "Mostrar associatividade via troca de ordem de integração",
                                "Provar distributividade em menos de 5 linhas",
                                "Aplicar propriedades para simplificar um cálculo de convolução dupla",
                                "Explicar verbalmente implicações em sistemas em cascata"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas provas (sem erros algébricos)",
                                "Clareza na derivação de integrais e substituições",
                                "Uso correto de teoremas (ex: Fubini para associatividade)",
                                "Validação numérica ou gráfica de pelo menos uma propriedade",
                                "Síntese coerente de todas propriedades em contexto de sistemas LTI",
                                "Identificação de aplicações práticas em engenharia"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de integrais múltiplas e teorema de Fubini",
                                "Controle Automático: Decomposição de sistemas em cascata via associatividade",
                                "Processamento de Sinais: Filtros lineares e propriedades em domínio do tempo",
                                "Física: Modelagem de respostas dinâmicas em vibrações aeronáuticas"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, propriedades da convolução permitem modelar respostas de sistemas de controle de voo a entradas complexas, como turbulência: associatividade facilita simular subsistemas em série (ex: atuadores + estabilizadores), reduzindo tempo computacional em simuladores de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Calcular convolução para entradas comuns",
                            "description": "Realizar cálculos passo a passo para pares como degrau unitário u(t) com h(t), expoencial e^(−at)u(t), usando técnicas de mudança de variável e tabelas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e setup da integral de convolução",
                                  "subSteps": [
                                    "Escreva a fórmula geral da convolução contínua: y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ",
                                    "Identifique as funções de entrada comuns: u(t) (degrau unitário) e e^{-a t} u(t) (exponencial decaindo)",
                                    "Defina os limites de integração considerando as funções causais (u(t))",
                                    "Prepare uma tabela de propriedades básicas da convolução (comutatividade, associatividade)",
                                    "Esboce gráficos qualitativos de x(t) e h(t) para visualização"
                                  ],
                                  "verification": "Confirme que a fórmula está corretamente escrita e limites ajustados para causalidade; gráfico esboçado matches funções conhecidas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Sinais e Sistemas ou tabela de Laplace",
                                    "Gráficos de funções básicas impressos"
                                  ],
                                  "tips": [
                                    "Sempre assuma causalidade para sistemas reais em engenharia; use τ como variável dummy"
                                  ],
                                  "learningObjective": "Compreender a estrutura matemática da convolução para entradas comuns",
                                  "commonMistakes": [
                                    "Esquecer o u(t) nas funções",
                                    "Ignorar limites de integração de 0 a t",
                                    "Confundir x(τ) com h(τ)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular convolução com degrau unitário u(t)",
                                  "subSteps": [
                                    "Defina h(t) como resposta ao impulso do sistema (ex: h(t) = e^{-b t} u(t))",
                                    "Substitua na integral: y(t) = ∫_{0}^{t} u(τ) h(t - τ) dτ = ∫_{0}^{t} h(t - τ) dτ",
                                    "Realize a integração passo a passo para h(t) específica",
                                    "Simplifique o resultado obtendo y(t) = [1 - e^{-b t}] / b * u(t) para exemplo comum",
                                    "Verifique por diferenciação: dy/dt deve igualar δ(t) * h(t) + convolução derivada"
                                  ],
                                  "verification": "Resultado final matches fórmula conhecida de tabela; gráfico de y(t) mostra resposta em degrau",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como Mathematica",
                                    "Tabela de integrais indefinidas",
                                    "Exemplos resolvidos de livro-texto"
                                  ],
                                  "tips": [
                                    "Mude variável σ = t - τ para simplificar; integre por partes se necessário"
                                  ],
                                  "learningObjective": "Executar cálculo exato de convolução u(t) ⊗ h(t)",
                                  "commonMistakes": [
                                    "Limites errados (usar -∞ a ∞ em vez de 0 a t)",
                                    "Não multiplicar pelo u(t) final",
                                    "Erro em simplificação algébrica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular convolução com exponencial e^{-a t} u(t)",
                                  "subSteps": [
                                    "Configure x(t) = e^{-a t} u(t) e h(t) = e^{-b t} u(t)",
                                    "Escreva y(t) = ∫_{0}^{t} e^{-a τ} e^{-b (t - τ)} dτ",
                                    "Fatore e^{-b t}: y(t) = e^{-b t} ∫_{0}^{t} e^{(b - a) τ} dτ",
                                    "Integre: [e^{(b - a) τ} / (b - a)] de 0 a t, simplifique para casos a ≠ b",
                                    "Caso especial a = b: limite ou integração direta para t e^{-a t}"
                                  ],
                                  "verification": "Fórmula final: y(t) = [e^{-a t} - e^{-b t}] / (b - a) u(t); teste numérico para valores específicos",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de convoluções exponenciais",
                                    "Software como MATLAB para plotagem"
                                  ],
                                  "tips": [
                                    "Use propriedade de Laplace para verificação rápida: Y(s) = X(s) H(s)",
                                    "Lide com a = b separadamente"
                                  ],
                                  "learningObjective": "Dominar cálculo analítico para entradas exponenciais comuns",
                                  "commonMistakes": [
                                    "Confundir coeficientes a e b",
                                    "Esquecer fator e^{-b t}",
                                    "Erro no denominador (b - a vs a - b)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar mudança de variável e tabelas para eficiência",
                                  "subSteps": [
                                    "Revise tabela padrão de convoluções (u(t) ⊗ t u(t) = t u(t)/2, etc.)",
                                    "Para entradas comuns, identifique padrões e aplique diretamente",
                                    "Use mudança de variável para generalizar: deixe α = t - τ",
                                    "Resolva 2 exemplos adicionais de tabela (rampa, seno)",
                                    "Compare resultados manuais com tabela para validação"
                                  ],
                                  "verification": "Resultados batem com tabela em pelo menos 3 casos; tempo de resolução < 5 min por exemplo",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de convoluções impressa",
                                    "Exercícios de prática",
                                    "Aplicativo de gráficos online"
                                  ],
                                  "tips": [
                                    "Memorize top 5 pares comuns; pratique mudança de variável em todos os passos"
                                  ],
                                  "learningObjective": "Otimizar cálculos usando ferramentas e técnicas avançadas",
                                  "commonMistakes": [
                                    "Aplicar tabela sem verificar causalidade",
                                    "Erro na mudança de escala de tempo",
                                    "Ignorar propriedades como escalamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a convolução y(t) = u(t) ⊗ e^{-2t} u(t). Resultado esperado: y(t) = (1 - e^{-2t}) u(t). Verifique graficamente e por Laplace: Y(s) = 1/s * 1/(s+2) = (1/s - 1/(s+2)).",
                              "finalVerifications": [
                                "Resolve corretamente u(t) ⊗ h(t) para h(t) = e^{-bt} u(t)",
                                "Deriva fórmula para e^{-at} u(t) ⊗ e^{-bt} u(t) sem erros algébricos",
                                "Aplica mudança de variável corretamente em integral genérica",
                                "Usa tabela para pelo menos 3 pares comuns com precisão",
                                "Verifica resultados por diferenciação ou transformada de Laplace",
                                "Identifica e corrige erros comuns em limites de integração"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos integrais (100% correto)",
                                "Uso apropriado de limites e causalidade (sem erros de sinal)",
                                "Eficiência: aplicação de tabelas e mudanças de variável",
                                "Clareza na apresentação passo a passo",
                                "Validação cruzada com métodos alternativos (Laplace, gráficos)",
                                "Tratamento de casos especiais (a = b)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral avançado e transformadas",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo",
                                "Computação: Implementação numérica em MATLAB/Simulink para simulações",
                                "Engenharia de Controle: Resposta a entradas em sistemas de voo",
                                "Processamento de Sinais: Filtros convolucionais em telemetria aeronáutica"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular a convolução determina a resposta transitória de um sistema de controle de voo (ex: elevador) a comandos de degrau ou exponenciais, essencial para estabilidade e simulações de manobras em aeronaves como o F-35, onde h(t) modela a dinâmica aerodinâmica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Aplicar convolução em exemplos de sistemas reais",
                            "description": "Aplicar a integral de convolução para determinar respostas em sistemas mecânicos (amortecedor massa-mola) ou térmicos, comparando com simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema físico e determinar a resposta ao impulso",
                                  "subSteps": [
                                    "Identifique o sistema (ex: massa-mola-amortecedor ou sistema térmico).",
                                    "Escreva a equação diferencial que governa o sistema.",
                                    "Resolva para a resposta ao impulso h(t) usando transformadas de Laplace ou métodos analíticos.",
                                    "Verifique as propriedades da resposta ao impulso (causalidade, estabilidade).",
                                    "Plote h(t) para visualização."
                                  ],
                                  "verification": "A resposta ao impulso h(t) satisfaz a equação diferencial com entrada delta(t) e condição inicial zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, software de álgebra simbólica (MATLAB Symbolic ou Mathematica), equação do sistema.",
                                  "tips": "Comece com sistemas de segunda ordem simples para familiarizar.",
                                  "learningObjective": "Compreender como obter h(t) a partir do modelo físico.",
                                  "commonMistakes": "Esquecer fatores de escala na transformada de Laplace ou ignorar condições iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função de entrada arbitrária u(t)",
                                  "subSteps": [
                                    "Escolha uma entrada realista (ex: degrau, rampa, sinusoidal ou pulso).",
                                    "Expresse u(t) matematicamente, considerando seu domínio.",
                                    "Verifique se u(t) é causal (u(t)=0 para t<0).",
                                    "Plote u(t) para entender seu comportamento.",
                                    "Discuta o impacto físico da entrada no sistema."
                                  ],
                                  "verification": "u(t) está corretamente definida e plotada, com suporte em t>=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos em MATLAB ou Python (Matplotlib), tabela de funções comuns.",
                                  "tips": "Use entradas padrão como degrau unitário para testes iniciais.",
                                  "learningObjective": "Selecionar entradas representativas de cenários reais.",
                                  "commonMistakes": "Definir u(t) não causal ou com unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a integral de convolução y(t) = h(t) * u(t)",
                                  "subSteps": [
                                    "Escreva a fórmula da convolução: y(t) = ∫ h(τ) u(t-τ) dτ de 0 a t.",
                                    "Avalie a integral analiticamente para entradas simples.",
                                    "Simplifique usando propriedades da convolução (comutatividade, distributividade).",
                                    "Plote y(t) e interprete o resultado físico.",
                                    "Verifique limites (t→0 e t→∞)."
                                  ],
                                  "verification": "y(t) coincide com solução direta da EDO para entradas conhecidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica, tabelas de integrais, software como MATLAB.",
                                  "tips": "Use mudança de variável τ para simplificar integrais.",
                                  "learningObjective": "Dominar o cálculo da convolução para sistemas LTI.",
                                  "commonMistakes": "Inverter os argumentos na convolução ou limites de integração errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar simulação numérica da resposta do sistema",
                                  "subSteps": [
                                    "Configure o modelo numérico no Simulink ou ODE solver (ex: ode45 no MATLAB).",
                                    "Inclua a equação diferencial com entrada u(t).",
                                    "Execute a simulação com condições iniciais zero.",
                                    "Plote a resposta simulada y_sim(t).",
                                    "Ajuste parâmetros de simulação para precisão (passo de tempo pequeno)."
                                  ],
                                  "verification": "A simulação converge e reproduz comportamento esperado para resposta ao impulso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Simulink ou Python (SciPy odeint), computador.",
                                  "tips": "Use solvers adaptativos para entradas irregulares.",
                                  "learningObjective": "Validar análises analíticas via simulação.",
                                  "commonMistakes": "Condições iniciais não zero ou passo de tempo muito grande causando erros numéricos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar resultados analíticos e simulados e analisar",
                                  "subSteps": [
                                    "Sobreponha gráficos de y(t) analítica e y_sim(t).",
                                    "Calcule métricas de erro (ex: RMSE).",
                                    "Interprete discrepâncias (numéricas vs. analíticas).",
                                    "Discuta implicações para sistemas reais.",
                                    "Gere relatório com conclusões."
                                  ],
                                  "verification": "Erro entre analítico e simulação < 1% em pontos chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos comparativos em MATLAB/Python, calculadora.",
                                  "tips": "Foquem em regimes transitório e estacionário separadamente.",
                                  "learningObjective": "Avaliar validade da convolução em contextos práticos.",
                                  "commonMistakes": "Ignorar efeitos numéricos ou escalas diferentes nos gráficos."
                                }
                              ],
                              "practicalExample": "Sistema massa-mola-amortecedor: m=1 kg, c=0.5 Ns/m, k=1 N/m. Entrada u(t) = degrau unitário em t=0. Calcule y(t) via convolução com h(t) = (1/ω_d) e^{-ζω_n t} sin(ω_d t), onde ζ=0.25, ω_n=1, ω_d=√(1-ζ²). Simule no MATLAB e compare.",
                              "finalVerifications": [
                                "Resposta ao impulso h(t) está correta e plotada.",
                                "Integral de convolução y(t) calculada analiticamente sem erros.",
                                "Simulação numérica converge ao resultado analítico (erro <5%).",
                                "Gráficos comparativos mostram concordância.",
                                "Análise inclui interpretação física dos resultados.",
                                "Relatório resume discrepâncias e lições aprendidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo da convolução (80% peso).",
                                "Qualidade da simulação e comparação (15% peso).",
                                "Interpretação física e análise de erros (5% peso).",
                                "Clareza de gráficos e relatório.",
                                "Uso correto de propriedades da convolução.",
                                "Aplicação a sistemas reais demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e transformadas de Laplace.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Mecânica dos Sólidos: Modelagem de vibrações.",
                                "Controle Automático: Resposta de sistemas LTI.",
                                "Engenharia Computacional: Validação de modelos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, aplica-se para prever respostas de estruturas de aeronaves (ex: asas) a cargas dinâmicas como turbulência ou manobras, permitindo design de amortecedores e controle de flutter via simulações validadas por convolução."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Função de Transferência",
                    "description": "Representação em domínio de Laplace H(s) e suas propriedades para análise de sistemas lineares contínuos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Definição da Função de Transferência H(s)",
                        "description": "Compreensão da função de transferência como representação no domínio de Laplace de sistemas lineares invariantes no tempo (LTI) contínuos, definida como a razão entre as transformadas de Laplace da saída e da entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Definir H(s) para sistemas LTI",
                            "description": "Definir precisamente a função de transferência H(s) = Y(s)/X(s), onde Y(s) é a transformada de Laplace da saída y(t) e X(s) da entrada x(t), assumindo condições iniciais nulas, e explicar sua validade para sistemas lineares contínuos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Transformada de Laplace",
                                  "subSteps": [
                                    "Estude a definição da transformada de Laplace: X(s) = ∫_{-∞}^∞ x(t) e^{-st} dt.",
                                    "Identifique propriedades chave: linearidade e uso para condições iniciais nulas.",
                                    "Pratique transformadas de funções comuns como degrau unitário e impulso.",
                                    "Entenda o domínio s: plano complexo e região de convergência.",
                                    "Resolva exercícios simples de Laplace inversa para reforçar."
                                  ],
                                  "verification": "Resolva 3 transformadas de Laplace corretamente e explique a região de convergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora simbólica (ex: MATLAB ou Wolfram Alpha)",
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)"
                                  ],
                                  "tips": "Sempre verifique unidades e causalidade das funções.",
                                  "learningObjective": "Compreender a transformada de Laplace como ferramenta para análise em domínio s.",
                                  "commonMistakes": [
                                    "Esquecer o fator e^{-st}",
                                    "Ignorar condições de convergência",
                                    "Confundir Laplace unilateral com bilateral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Representação de Sistemas LTI no Domínio do Tempo",
                                  "subSteps": [
                                    "Defina sistemas LTI: lineares e invariantes no tempo.",
                                    "Represente um sistema LTI pela convolução: y(t) = h(t) * x(t).",
                                    "Discuta equações diferenciais lineares com coeficientes constantes.",
                                    "Introduza condições iniciais nulas: y(0^-) = 0 para todos os estados.",
                                    "Derive a relação entre entrada x(t) e saída y(t) assumindo relaxado."
                                  ],
                                  "verification": "Escreva a equação de convolução para um sistema LTI e identifique premissas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre LTI",
                                    "Exemplos de sistemas mecânicos/elétricos"
                                  ],
                                  "tips": "Lembre-se: LTI permite superposição e resposta impulsional.",
                                  "learningObjective": "Dominar a caracterização de sistemas LTI no domínio do tempo.",
                                  "commonMistakes": [
                                    "Confundir linearidade com tempo-invariância",
                                    "Esquecer impacto de condições iniciais não nulas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Função de Transferência H(s)",
                                  "subSteps": [
                                    "Aplique Laplace em ambos os lados da equação de convolução: Y(s) = H(s) X(s).",
                                    "Defina formalmente H(s) = Y(s) / X(s) para X(s) ≠ 0.",
                                    "Mostre que H(s) = L{h(t)}, a transformada da resposta impulsional.",
                                    "Resolva uma equação diferencial simples para obter H(s).",
                                    "Verifique dimensionalidade: H(s) deve ser adimensional ou consistente."
                                  ],
                                  "verification": "Derive H(s) para um sistema RC simples e confira com tabela.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Software Simulink ou Python (control library)"
                                  ],
                                  "tips": "Use divisão polinomial para equações de alta ordem.",
                                  "learningObjective": "Construir a definição precisa de H(s) a partir de entrada/saída.",
                                  "commonMistakes": [
                                    "Dividir por X(s) sem assumir X(s)≠0",
                                    "Incluir condições iniciais em H(s)",
                                    "Confundir H(s) com resposta em frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Validade e Limitações de H(s)",
                                  "subSteps": [
                                    "Liste premissas: linearidade, tempo-contínuo, invariância no tempo, condições iniciais nulas.",
                                    "Discuta quando H(s) falha: sistemas não lineares, discretos ou com iniciais não nulas.",
                                    "Compare com função de transferência em sistemas discretos Z.",
                                    "Analise estabilidade via polos de H(s).",
                                    "Aplique em exemplo aeronáutico: modelo de atitude de aeronave."
                                  ],
                                  "verification": "Explique em 3 frases por que H(s) não se aplica a sistemas não lineares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos sobre controle de aeronaves",
                                    "Exemplos de MATLAB para LTI"
                                  ],
                                  "tips": "Sempre pergunte: 'O sistema é relaxado?' antes de usar H(s).",
                                  "learningObjective": "Reconhecer escopo e restrições da função de transferência.",
                                  "commonMistakes": [
                                    "Aplicar H(s) a sistemas com memória inicial",
                                    "Ignorar causalidade estrita"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um circuito RC série com entrada de tensão x(t) e saída y(t) na capacitor: equação dy/dt + (1/RC)y = (1/RC)x. Assumindo y(0)=0, Laplace dá H(s) = 1/(RC s + 1). Simule no MATLAB para verificar y(t) = h(t)*x(t) com x(t)=degrau unitário.",
                              "finalVerifications": [
                                "Escreve corretamente H(s) = Y(s)/X(s) com condições iniciais nulas.",
                                "Deriva H(s) de uma equação diferencial de 2ª ordem.",
                                "Explica por que H(s) = L{h(t)}.",
                                "Identifica 3 premissas para validade de H(s).",
                                "Aplica H(s) em um exemplo real e verifica saída.",
                                "Discute limitação para sistemas não LTI."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de H(s).",
                                "Correta derivação de Y(s) e X(s) via Laplace.",
                                "Compreensão de condições iniciais nulas.",
                                "Identificação clara de sistemas LTI contínuos.",
                                "Explicação coerente de validade e limitações.",
                                "Uso correto de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e transformadas integrais.",
                                "Eletrônica: Análise de circuitos no domínio s.",
                                "Controle Automático: Projeto de controladores via H(s).",
                                "Mecânica: Modelagem de sistemas vibratórios.",
                                "Física: Dinâmica linear de fluidos em aeronáutica."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, H(s) modela a dinâmica longitudinal de uma aeronave (ex: elevador para pitch), permitindo análise de estabilidade e design de sistemas de controle fly-by-wire, como no Boeing 787."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Relacionar H(s) com resposta ao impulso",
                            "description": "Estabelecer a relação H(s) = ℒ{h(t)}, onde h(t) é a resposta ao impulso do sistema, e demonstrar como a transformada inversa de Laplace recupera h(t) a partir de H(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar a resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Defina o impulso unitário δ(t) como entrada de teste para sistemas LTI contínuos.",
                                    "Explique que h(t) é a saída do sistema quando a entrada é δ(t), assumindo condições iniciais zero.",
                                    "Discuta propriedades de h(t): causalidade (h(t)=0 para t<0) e sua relação com convolução y(t) = h(t) * x(t).",
                                    "Ilustre graficamente h(t) para um sistema simples, como um integrador.",
                                    "Relacione h(t) com a representação em domínio do tempo do comportamento do sistema."
                                  ],
                                  "verification": "Desenhe o gráfico de h(t) para um sistema conhecido e explique sua significância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Papel e lápis para esboços",
                                    "Software MATLAB ou Python (SymPy) para visualização"
                                  ],
                                  "tips": "Sempre normalize o impulso como δ(t) com integral 1 para consistência.",
                                  "learningObjective": "Compreender h(t) como a resposta natural do sistema a um impulso instantâneo.",
                                  "commonMistakes": [
                                    "Confundir h(t) com resposta degrau",
                                    "Ignorar causalidade",
                                    "Esquecer condições iniciais zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer H(s) = ℒ{h(t)}",
                                  "subSteps": [
                                    "Revise a transformada de Laplace unilateral: ℒ{f(t)} = ∫_{0-}^∞ f(t) e^{-st} dt.",
                                    "Aplique diretamente à h(t): H(s) = ℒ{h(t)}, justificando convergência no semiplano Re(s) > σ.",
                                    "Mostre que para sistemas LTI estáveis, H(s) existe e é racional.",
                                    "Derive H(s) para exemplos simples: ex. h(t)=e^{-at}u(t) → H(s)=1/(s+a).",
                                    "Explique que H(s) é a função de transferência do sistema."
                                  ],
                                  "verification": "Calcule ℒ{h(t)} para h(t)=e^{-2t}u(t) e verifique H(s)=1/(s+2).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabelas de transformadas de Laplace",
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy)",
                                    "Apostila de Laplace"
                                  ],
                                  "tips": "Use a propriedade da transformada para funções com u(t) (step Heaviside).",
                                  "learningObjective": "Dominar a definição formal de H(s) via Laplace de h(t).",
                                  "commonMistakes": [
                                    "Usar Laplace bilateral em vez de unilateral",
                                    "Esquecer o fator u(t)",
                                    "Não verificar região de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a relação entre H(s), h(t) e o sistema",
                                  "subSteps": [
                                    "Relacione H(s) = Y(s)/X(s) com X(s)=1 (Laplace de δ(t)), logo Y(s)=H(s).",
                                    "Discuta polos e zeros de H(s) e seu impacto em h(t) (ex: polos reais → exponenciais decrescentes).",
                                    "Mostre equivalência: qualquer entrada x(t) → Y(s)=H(s)X(s) → y(t)=h(t)*x(t).",
                                    "Analise estabilidade via polos de H(s) refletidos em h(t).",
                                    "Compare domínios: tempo vs. frequência via H(s)."
                                  ],
                                  "verification": "Para H(s)=1/(s^2 + 2s + 1), identifique que h(t)=(t+1)e^{-t}u(t).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulador MATLAB Simulink para sistemas LTI",
                                    "Gráficos de Bode/Polo-zero"
                                  ],
                                  "tips": "Visualize polos no plano s para prever decaimento em h(t).",
                                  "learningObjective": "Entender H(s) como representação frequência da resposta temporal h(t).",
                                  "commonMistakes": [
                                    "Confundir H(s) com função de transferência de estado-espaco",
                                    "Ignorar multiplicatividade em domínio s"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar transformada inversa para recuperar h(t)",
                                  "subSteps": [
                                    "Revise ℒ^{-1}{H(s)} = h(t), usando frações parciais para H(s) racional.",
                                    "Aplique a inversa: ex. H(s)=ω/(s^2 + ω^2) → h(t)=sin(ωt)u(t).",
                                    "Use tabelas ou resíduos para casos complexos.",
                                    "Verifique numericamente: simule impulso e compare com inversa analítica.",
                                    "Discuta unicidade sob condições de causalidade."
                                  ],
                                  "verification": "Compute ℒ^{-1}{1/(s+1)(s+2)} e confirme h(t)=e^{-t} - e^{-2t} para t≥0.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Tabelas de Laplace inversa",
                                    "MATLAB (ilaplace) ou Python (sympy.inverse_laplace_transform)"
                                  ],
                                  "tips": "Decomponha em frações parciais antes de inverter.",
                                  "learningObjective": "Executar e validar a recuperação de h(t) via ℒ^{-1}{H(s)}.",
                                  "commonMistakes": [
                                    "Erros em decomposição parcial",
                                    "Esquecer u(t)",
                                    "Inverter funções bilaterais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave modelado como oscilador amortecido de 2ª ordem H(s) = ω_n^2 / (s^2 + 2ζω_n s + ω_n^2), com ζ=0.5, ω_n=1 rad/s. Aplique impulso δ(t) (torque instantâneo), calcule h(t) via inversa Laplace: h(t) = (1/√(1-ζ^2)) e^{-ζω_n t} sin(ω_d t + φ) u(t), onde ω_d=ω_n√(1-ζ^2), simulando oscilação amortecida da taxa de rolamento.",
                              "finalVerifications": [
                                "Defina corretamente H(s) = ℒ{h(t)} e justifique.",
                                "Calcule H(s) a partir de h(t) dado e vice-versa para 2 exemplos.",
                                "Explique por que ℒ{δ(t)} = 1 leva a Y(s) = H(s).",
                                "Identifique polos de H(s) e descreva comportamento de h(t).",
                                "Simule em software e compare analítico vs. numérico.",
                                "Discuta estabilidade via h(t) e H(s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática H(s) = ℒ{h(t)} (20%)",
                                "Correção em cálculos de Laplace direta/inversa (30%)",
                                "Interpretação física da relação impulso-transferência (20%)",
                                "Uso correto de ferramentas/simulações (15%)",
                                "Clareza em exemplos e verificações (10%)",
                                "Identificação de erros comuns e prevenções (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas integrais e análise complexa (resíduos).",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor em aeroelasticidade.",
                                "Programação: Simulações em MATLAB/Python para controle numérico.",
                                "Engenharia de Controle: Projeto de compensadores baseados em H(s)."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, relacionar H(s) com h(t) é essencial para analisar a resposta transitória de sistemas de controle de voo a distúrbios impulsivos, como rajadas de vento, permitindo otimizar estabilidade e manobrabilidade em aviões comerciais ou drones, via simulações em Simulink para certificação FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Interpretar H(s) via convolução",
                            "description": "Explicar como y(t) = h(t) * x(t) no domínio do tempo corresponde a Y(s) = H(s) X(s) no domínio de Laplace, destacando a propriedade da multiplicação algébrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Convolução no Domínio do Tempo",
                                  "subSteps": [
                                    "Defina a integral de convolução: y(t) = ∫_{-∞}^{∞} h(τ) x(t - τ) dτ",
                                    "Explique o significado físico: resposta h(t) ao impulso convolvida com entrada x(t)",
                                    "Calcule um exemplo simples, como convolução de duas funções retangulares",
                                    "Discuta propriedades da convolução: comutatividade, associatividade",
                                    "Verifique simetria e causalidade em sistemas LTI"
                                  ],
                                  "verification": "Resolva um problema de convolução manualmente e compare com resultado conhecido",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Calculadora simbólica (Mathematica ou MATLAB)",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Sempre normalize limites de integração para causalidade (t ≥ 0)",
                                  "learningObjective": "Compreender a convolução como operação fundamental em sistemas LTI no tempo",
                                  "commonMistakes": [
                                    "Esquecer o fator de mudança de variável dτ",
                                    "Ignorar limites de integração para sinais causais",
                                    "Confundir ordem dos operandos (não comutativa em implementação numérica)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Transformada de Laplace e sua Propriedade de Convolução",
                                  "subSteps": [
                                    "Revise a definição da Transformada de Laplace: X(s) = ∫_{0}^{∞} x(t) e^{-st} dt",
                                    "Enuncie a propriedade: ℒ{y(t)} = ℒ{h(t) * x(t)} = H(s) X(s)",
                                    "Derive a propriedade usando a definição da transformada e integral de convolução",
                                    "Prove a multiplicação algébrica no domínio s a partir da convolução no tempo",
                                    "Discuta condições de convergência (Região de Convergência - ROC)"
                                  ],
                                  "verification": "Derive a propriedade em uma tabela e aplique a um par de funções simples",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabelas de Transformadas de Laplace",
                                    "Software de álgebra simbólica (SymPy ou Maple)",
                                    "Aulas gravadas sobre Laplace"
                                  ],
                                  "tips": "Use a propriedade da exponencial para simplificar a derivacão dupla",
                                  "learningObjective": "Dominar a transformação da convolução em multiplicação no domínio de Laplace",
                                  "commonMistakes": [
                                    "Confundir Laplace bilateral com unilateral",
                                    "Esquecer o ROC na multiplicação H(s)X(s)",
                                    "Aplicar propriedade sem verificar convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Interpretar a Função de Transferência H(s)",
                                  "subSteps": [
                                    "Defina H(s) = Y(s)/X(s) para sistemas LTI estáveis",
                                    "Conecte H(s) à resposta ao impulso: H(s) = ℒ{h(t)}",
                                    "Mostre que Y(s) = H(s) X(s) implica y(t) = h(t) * x(t)",
                                    "Analise polos e zeros de H(s) e sua relação com o comportamento temporal",
                                    "Calcule H(s) para um sistema simples (ex: integrador)"
                                  ],
                                  "verification": "Dado um h(t), compute H(s) e verifique Y(s) para uma X(s) conhecida",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para plotar respostas",
                                    "Folhas de exercícios de funções de transferência"
                                  ],
                                  "tips": "Sempre fatorize H(s) para visualizar dinâmica",
                                  "learningObjective": "Interpretar H(s) como operador multiplicativo equivalente à convolução",
                                  "commonMistakes": [
                                    "Assumir H(s) sem ROC adequada",
                                    "Confundir H(s) com função de transmissão em frequência",
                                    "Ignorar efeitos de polos no tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar a Interpretação via Exemplos",
                                  "subSteps": [
                                    "Escolha um sistema aeronáutico simples (ex: filtro de atitude)",
                                    "Compute y(t) via convolução e via H(s)X(s), compare",
                                    "Analise vantagens: multiplicação algébrica facilita análise de estabilidade",
                                    "Discuta simulações numéricas (FFT vs Laplace para verificação)",
                                    "Resolva um problema completo: derive comportamento assintótico"
                                  ],
                                  "verification": "Simule em software e valide correspondência tempo-frequência",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB com toolbox de controle",
                                    "Dados de sistemas reais de aeronáutica"
                                  ],
                                  "tips": "Use partial fractions para inverter Y(s) e comparar com convolução numérica",
                                  "learningObjective": "Sintetizar a dualidade convolução-multiplicação para análise prática",
                                  "commonMistakes": [
                                    "Usar aproximações lineares sem validar LTI",
                                    "Erro numérico em inversão de Laplace",
                                    "Não considerar delays em sistemas reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de voo, a resposta impulsional h(t) = e^{-t} u(t) (amortecedor) convolvida com entrada de turbulência x(t) = δ(t) dá y(t) = h(t). No domínio Laplace, H(s) = 1/(s+1), Y(s) = H(s) X(s), permitindo análise rápida de estabilidade via polos.",
                              "finalVerifications": [
                                "Derivar corretamente Y(s) = H(s) X(s) a partir de y(t) = h(t) * x(t)",
                                "Explicar verbalmente a vantagem algébrica da multiplicação sobre integral",
                                "Resolver um problema completo: convolução → Laplace → verificação",
                                "Identificar quando usar cada domínio (tempo para não-lineares, s para lineares)",
                                "Simular e plotar respostas coincidentes em MATLAB",
                                "Discutir limitações (ex: não-LTI)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivacão da propriedade de convolução (100% correta)",
                                "Capacidade de aplicar a exemplos concretos sem erros de cálculo",
                                "Profundidade na interpretação física (causalidade, estabilidade)",
                                "Criatividade em conexões com aplicações aeronáuticas",
                                "Clareza em explicações escritas/orais",
                                "Eficiência em simulações e verificações numéricas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Complexa (polos/zeros, contorno integrals)",
                                "Física: Dinâmica de Sistemas (equações diferenciais lineares)",
                                "Computação: Processamento Numérico de Sinais (implementação em Python/MATLAB)",
                                "Engenharia de Controle: Projeto de Controladores via H(s)",
                                "Estatística: Análise de Ruído e Filtragem em Sinais"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, interpretar H(s) via convolução permite modelar sistemas de controle de voo, como estabilizadores automáticos, onde entradas de turbulência são convolvidas com respostas impulsais para prever desvios de atitude, facilitando design de aviônicos robustos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Propriedades da Função de Transferência",
                        "description": "Estudo das propriedades algébricas e físicas da H(s), incluindo forma racional, polos, zeros e implicações para o comportamento do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Identificar polos e zeros de H(s)",
                            "description": "Localizar polos (raízes do denominador) e zeros (raízes do numerador) em H(s) = N(s)/D(s), e interpretar seu impacto na resposta temporal e em frequência do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de polos e zeros",
                                  "subSteps": [
                                    "Defina função de transferência H(s) = N(s)/D(s), onde N(s) é o numerador e D(s) o denominador.",
                                    "Explique que zeros são as raízes de N(s) = 0 (valores de s onde H(s)=0).",
                                    "Explique que polos são as raízes de D(s) = 0 (valores de s onde H(s) tende ao infinito).",
                                    "Discuta o impacto: zeros afetam a forma da resposta, polos determinam estabilidade e transitórios.",
                                    "Revise o plano complexo s = σ + jω."
                                  ],
                                  "verification": "Resuma em suas palavras as definições e impactos, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas",
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre plano s"
                                  ],
                                  "tips": "Use analogias: polos como 'imãs' que puxam a resposta, zeros como 'bloqueios'.",
                                  "learningObjective": "Dominar definições e papéis de polos e zeros na análise de sistemas.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar multiplicidade das raízes",
                                    "Esquecer o contexto do plano s"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair numerador e denominador de H(s)",
                                  "subSteps": [
                                    "Escreva H(s) na forma padrão racional N(s)/D(s), expandindo se necessário.",
                                    "Identifique os polinômios N(s) e D(s), garantindo grau de D(s) >= N(s).",
                                    "Normalize os coeficientes principais para 1, se aplicável.",
                                    "Verifique se H(s) está em forma mínima (sem fatores comuns).",
                                    "Anote os graus de N(s) e D(s)."
                                  ],
                                  "verification": "Apresente N(s) e D(s) corretamente para um H(s) dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou simbólica",
                                    "Software como MATLAB/SymPy"
                                  ],
                                  "tips": "Sempre fatorize para simplificar antes de prosseguir.",
                                  "learningObjective": "Preparar H(s) adequadamente para extração de raízes.",
                                  "commonMistakes": [
                                    "Deixar fatores comuns não cancelados",
                                    "Erro na expansão polinomial",
                                    "Confundir numerador com denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular zeros e polos",
                                  "subSteps": [
                                    "Resolva N(s) = 0 para encontrar zeros (use fórmula quadrática ou numérica para altos graus).",
                                    "Resolva D(s) = 0 para encontrar polos, anotando multiplicidades.",
                                    "Liste zeros e polos com precisão (real e imaginária).",
                                    "Plote-os no plano s (eixo real σ horizontal, imaginário ω vertical).",
                                    "Confirme cálculos com software ou verificação manual."
                                  ],
                                  "verification": "Liste zeros e polos corretos e mostre o plot no plano s.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "MATLAB ou Python (numpy.roots)",
                                    "Calculadora"
                                  ],
                                  "tips": "Para polinômios de grau >4, use métodos numéricos; memorize quadrática.",
                                  "learningObjective": "Executar cálculos precisos de raízes polinomiais.",
                                  "commonMistakes": [
                                    "Erro aritmético em raízes",
                                    "Esquecer raízes complexas conjugadas",
                                    "Não plotar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar impactos na resposta temporal e em frequência",
                                  "subSteps": [
                                    "Analise localização: polos reais negativos = decay exponencial estável.",
                                    "Discuta polos imaginários: oscilações (frequência natural ω_n = |Im(polo)|).",
                                    "Explique zeros: alteram overshoot e settling time.",
                                    "Relacione com diagrama de Bode: polos/zeros afetam magnitude e fase.",
                                    "Avalie estabilidade: todos polos no semiplano esquerdo (Re < 0)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando impactos para o exemplo usado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabelas de resposta temporal",
                                    "Gráficos de Bode exemplo"
                                  ],
                                  "tips": "Lembre: polos dominam o comportamento; zeros refinam.",
                                  "learningObjective": "Conectar polos/zeros a comportamentos dinâmicos do sistema.",
                                  "commonMistakes": [
                                    "Ignorar multiplicidade (polos múltiplos = respostas mais lentas)",
                                    "Confundir impacto temporal com freqüencial",
                                    "Errar critério de estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = (s + 2) / (s² + 4s + 3) = (s + 2) / ((s + 1)(s + 3)). Zeros: s = -2. Polos: s = -1, s = -3. Interpretação: Sistema estável (polos reais negativos), resposta sobredampada com zero próximo ao polo em -1 reduzindo overshoot.",
                              "finalVerifications": [
                                "Todos zeros e polos calculados corretamente com multiplicidades.",
                                "Plot correto no plano s.",
                                "Interpretação precisa de estabilidade e tipo de resposta temporal.",
                                "Identificação correta de impactos em diagrama de Bode.",
                                "Sem fatores comuns não cancelados em H(s).",
                                "Explicação coerente dos efeitos de cada polo/zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de raízes (100% correto).",
                                "Qualidade do plot no plano s (localizações exatas).",
                                "Profundidade da interpretação (temporal e freqüencial).",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de generalizar para H(s) diferentes.",
                                "Identificação de erros potenciais no processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações polinomiais e números complexos.",
                                "Física: Dinâmica linear e osciladores harmônicos.",
                                "Engenharia de Controle: Análise de estabilidade em malhas de feedback.",
                                "Processamento de Sinais: Filtros analógicos e design.",
                                "Engenharia Aeronáutica: Modelagem de dinâmica de voo."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, identificar polos e zeros em funções de transferência de sistemas de controle de voo permite avaliar estabilidade (ex: polos no semiplano direito indicam instabilidade, como em flutter de asas), otimizar resposta de atitude e prevenir oscilações perigosas durante manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Analisar causalidade e ordem do sistema",
                            "description": "Verificar propriedades como causalidade (grau do denominador ≥ grau do numerador), ordem do sistema (grau do denominador) e estabilidade (todos os polos no semiplano esquerdo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Causalidade, Ordem e Estabilidade",
                                  "subSteps": [
                                    "Defina causalidade: propriedade que garante resposta finita a entrada finita, requerendo grau do denominador ≥ grau do numerador.",
                                    "Explique ordem do sistema: grau do polinômio do denominador da função de transferência.",
                                    "Descreva estabilidade: todos os polos (raízes do denominador) devem ter parte real negativa (semiplano esquerdo do plano s).",
                                    "Identifique polos como raízes do denominador após fatoração ou método de Routh-Hurwitz.",
                                    "Diferencie propriedades para sistemas próprios e impróprios."
                                  ],
                                  "verification": "Escreva definições curtas e exemplos simples para cada conceito em um resumo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre funções de transferência",
                                    "Livro de Sinais e Sistemas Dinâmicos",
                                    "Calculadora simbólica (ex: MATLAB ou Python SymPy)"
                                  ],
                                  "tips": "Visualize o plano s para estabilidade: eixo real negativo é chave para retornos oscilatórios.",
                                  "learningObjective": "Dominar definições precisas e condições matemáticas das propriedades.",
                                  "commonMistakes": [
                                    "Confundir causalidade com estabilidade",
                                    "Esquecer que ordem é apenas grau do denominador",
                                    "Ignorar multiplicidade de polos na estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Graus do Numerador e Denominador na Função de Transferência",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) = N(s)/D(s) em forma polinomial.",
                                    "Conte o maior expoente de s no numerador (grau N) e denominador (grau D).",
                                    "Classifique como própria (grau N < grau D), imprópria (grau N > grau D) ou adequada (igual).",
                                    "Simplifique polinômios cancelando fatores comuns, mas anote impactos na causalidade.",
                                    "Verifique se D(s) tem raízes no zero (afeta ordem)."
                                  ],
                                  "verification": "Para uma G(s) dada, liste graus exatos e classifique o sistema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para expansão polinomial",
                                    "Software como MATLAB para plotar polinômios"
                                  ],
                                  "tips": "Sempre expanda completamente: grau é o termo de maior potência com coeficiente não zero.",
                                  "learningObjective": "Extrair com precisão graus para análise subsequente.",
                                  "commonMistakes": [
                                    "Contar zeros como graus",
                                    "Não simplificar antes de contar",
                                    "Confundir com ordem relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Causalidade e Ordem do Sistema",
                                  "subSteps": [
                                    "Aplique teste de causalidade: se grau D ≥ grau N, causal; senão, não causal (divida para forma própria).",
                                    "Calcule ordem: grau D após simplificação.",
                                    "Confirme com exemplo numérico: compute graus para G(s) = (s+2)/(s^3 + 3s^2 + 2s).",
                                    "Discuta implicações: sistemas não causais não realizáveis fisicamente.",
                                    "Registre resultados em tabela: causal (sim/não), ordem (número)."
                                  ],
                                  "verification": "Crie tabela de análise para 2 funções de transferência exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de funções de transferência de notas",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Para impróprias, realize divisão polinomial primeiro para causalidade efetiva.",
                                  "learningObjective": "Aplicar testes diretamente para causalidade e ordem.",
                                  "commonMistakes": [
                                    "Esquecer simplificação cancela termos",
                                    "Aplicar causalidade sem comparar graus corretos",
                                    "Confundir ordem com grau N"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade via Polos",
                                  "subSteps": [
                                    "Fatore D(s) ou use Routh-Hurwitz para localizar polos.",
                                    "Verifique parte real de cada polo: todos Re(p) < 0 para estável.",
                                    "Identifique casos: estável, instável (qualquer Re(p) > 0), marginal (Re(p)=0).",
                                    "Para múltiplos polos, confirme todos satisfazem condição.",
                                    "Plote polos no plano s para visualização."
                                  ],
                                  "verification": "Liste polos e classifique estabilidade para uma G(s) complexa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela Routh-Hurwitz impressa",
                                    "Software MATLAB/Simulink para root locus"
                                  ],
                                  "tips": "Routh-Hurwitz é rápido para ordem alta sem fatorar.",
                                  "learningObjective": "Avaliar estabilidade completa via localização de polos.",
                                  "commonMistakes": [
                                    "Ignorar polos complexos conjugados",
                                    "Confundir polo zero com instabilidade",
                                    "Não checar todos os polos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = (s + 1) / (s^2 + 3s + 2): grau N=1, D=2 → causal (sim), ordem=2, polos s=-1 e s=-2 (ambos Re<0) → estável. Simule resposta a degrau no MATLAB para verificar oscilação nula.",
                              "finalVerifications": [
                                "Classifique causalidade, ordem e estabilidade para 3 funções de transferência dadas corretamente.",
                                "Explique por que um sistema com polo em s=1 é instável.",
                                "Identifique ordem em G(s) = 1/(s^3 + s) após simplificação.",
                                "Desenhe plano s com polos de exemplo estável e instável.",
                                "Resolva problema: G(s) = s / (s^2 + s + 1) → causal? ordem? estável?",
                                "Compare propriedades antes/depois de cancelamento de polo-zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de graus (100% correto).",
                                "Correta aplicação de condição causal (grau D ≥ N).",
                                "Localização precisa de polos e verificação de Re(p)<0.",
                                "Explicação clara de implicações físicas (ex: não causal não realizável).",
                                "Uso adequado de ferramentas como Routh para ordens altas.",
                                "Análise completa incluindo simplificações e casos marginais.",
                                "Apresentação lógica em tabela ou relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e raízes complexas.",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor modelados por FT.",
                                "Engenharia de Controle: Projeto de controladores para estabilizar aeronaves.",
                                "Processamento de Sinais: Análise de filtros lineares.",
                                "Engenharia Mecânica: Vibrações e estabilidade estrutural em asas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, analisar causalidade garante atuadores realizáveis; ordem define complexidade do modelo de voo; estabilidade verifica se sistemas de controle de atitude (ex: autopilot) mantêm o avião estável após turbulência, evitando perda de controle."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Determinar ganho estático",
                            "description": "Calcular o ganho em regime permanente lim s→0 H(s) para entradas degrau, interpretando-o como o valor final da resposta a um degrau unitário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de ganho estático e regime permanente",
                                  "subSteps": [
                                    "Defina regime permanente como o comportamento assintótico da resposta quando os transientes decaem.",
                                    "Explique que para entrada degrau unitário u(t), a resposta y(t) tende a um valor constante y(∞).",
                                    "Relacione o ganho estático K_p como y(∞) = K_p * 1 para degrau unitário.",
                                    "Discuta a importância em sistemas de controle para prever erro steady-state."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é ganho estático e sua relação com degrau unitário.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Caneta",
                                    "Livro de Sinais e Sistemas ou notas de aula"
                                  ],
                                  "tips": "Visualize o gráfico da resposta a degrau: o valor final horizontal é o ganho estático.",
                                  "learningObjective": "Entender conceitualmente o ganho estático como limite da resposta em regime permanente.",
                                  "commonMistakes": "Confundir ganho estático com ganho em frequência DC ou valor inicial da resposta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a função de transferência H(s) e sua avaliação em s=0",
                                  "subSteps": [
                                    "Lembre que H(s) = Y(s)/U(s) para sistemas lineares invariantes no tempo.",
                                    "Identifique numerador N(s) e denominador D(s) em H(s) = N(s)/D(s).",
                                    "Note que lim_{t→∞} y(t) = lim_{s→0} s Y(s) pelo teorema do valor final.",
                                    "Para U(s)=1/s (degrau unitário), y(∞) = lim_{s→0} s * H(s) * (1/s) = H(0).",
                                    "Confirme que ganho estático K_p = H(0) = lim_{s→0} H(s)."
                                  ],
                                  "verification": "Derive em papel que para degrau unitário, y(∞) = H(0).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplos de funções de transferência de aulas anteriores"
                                  ],
                                  "tips": "Sempre substitua s=0 diretamente se H(s) for própria (grau den > num).",
                                  "learningObjective": "Derivar matematicamente a relação entre ganho estático e H(0).",
                                  "commonMistakes": "Esquecer o teorema do valor final ou aplicar incorretamente para rampas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o ganho estático para uma função de transferência dada",
                                  "subSteps": [
                                    "Escreva H(s) explicitamente, separando numerador e denominador.",
                                    "Substitua s=0 no numerador e denominador separadamente.",
                                    "Calcule H(0) = N(0)/D(0), simplificando frações se necessário.",
                                    "Verifique se o sistema é tipo 0 (D(0) ≠ 0); caso contrário, ganho é infinito.",
                                    "Registre o valor numérico ou simbólico do ganho."
                                  ],
                                  "verification": "Resolva 2-3 funções de transferência exemplo e confira com solução conhecida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou simbólica",
                                    "Software como MATLAB/SymPy para verificação opcional"
                                  ],
                                  "tips": "Fatore polinômios se D(0)=0 para identificar integradores (tipo >0).",
                                  "learningObjective": "Executar o cálculo de lim_{s→0} H(s) com precisão.",
                                  "commonMistakes": "Dividir por zero sem notar polos em s=0 ou erros algébricos em polinômios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e verificar o ganho estático na resposta temporal",
                                  "subSteps": [
                                    "Simule ou esboce a resposta a degrau unitário usando H(s).",
                                    "Identifique o valor final no gráfico ou simulação como H(0).",
                                    "Calcule erro steady-state e_ss = 1 - K_p para sistemas tipo 0.",
                                    "Compare cálculo analítico com simulação numérica.",
                                    "Discuta implicações: K_p alto significa tracking bom para degraus."
                                  ],
                                  "verification": "Gere gráfico de resposta a degrau e marque y(∞) = K_p.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink, Python com control library)",
                                    "Gráficos manuais"
                                  ],
                                  "tips": "Use step response plot para visualização intuitiva.",
                                  "learningObjective": "Interpretar ganho estático no contexto de performance do sistema.",
                                  "commonMistakes": "Ignorar efeitos de zeros/polos que alteram o regime permanente."
                                }
                              ],
                              "practicalExample": "Dada H(s) = 5 / (s² + 3s + 5), calcule ganho estático: H(0) = 5/5 = 1. Para degrau unitário, y(∞) = 1, significando que o sistema segue o degrau com erro zero em steady-state.",
                              "finalVerifications": [
                                "Calculou corretamente lim_{s→0} H(s) para funções de transferência dadas.",
                                "Interpretou H(0) como valor final da resposta a degrau unitário.",
                                "Identificou casos especiais (ex: integradores com K_p infinito).",
                                "Verificou resultado via simulação ou teorema do valor final.",
                                "Explicou implicações para erro steady-state em controle.",
                                "Aplicou a 3 exemplos variados sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de H(0) (100% correto em testes).",
                                "Correta derivação teórica usando teorema do valor final.",
                                "Interpretação qualitativa precisa (ex: tracking de referências).",
                                "Identificação de sistemas tipo 0 vs. tipo >0.",
                                "Verificação prática via gráficos/simulações.",
                                "Explicação clara sem confusão com outros ganhos (velocidade, fase)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e análise de funções racionais.",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor modelados por H(s).",
                                "Engenharia de Controle: Projeto de controladores para minimizar 1/(1+K_p).",
                                "Processamento de Sinais: Ganho DC em filtros analógicos.",
                                "Engenharia Aeronáutica: Estabilidade em malha fechada de atitude de aeronaves."
                              ],
                              "realWorldApplication": "Em aviões, o ganho estático de um controlador de atitude determina quão precisamente a aeronave mantém altitude ou heading em regime permanente após comando degrau, minimizando deriva e melhorando eficiência de combustível em cruzeiro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.4",
                            "name": "Verificar realizabilidade física",
                            "description": "Aplicar critérios como mínimo de fase e propriedades de Bode para validar se H(s) representa um sistema físico realista.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e decompor a função de transferência H(s)",
                                  "subSteps": [
                                    "Escreva a função de transferência H(s) no domínio de Laplace.",
                                    "Decomponha H(s) em fatores de pólos e zeros usando fatoração parcial.",
                                    "Identifique o grau do numerador e denominador.",
                                    "Liste todos os pólos e zeros com suas multiplicidades.",
                                    "Normalize H(s) para ganho DC unitário se aplicável."
                                  ],
                                  "verification": "Confirme que H(s) está corretamente decomposta e todos os pólos/zeros estão listados em uma tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software como MATLAB/Simulink para fatoração.",
                                  "tips": "Use syms no MATLAB para fatoração simbólica para evitar erros de cálculo.",
                                  "learningObjective": "Compreender a estrutura algébrica de H(s) para análise subsequente.",
                                  "commonMistakes": "Esquecer multiplicidades de pólos/zeros ou normalizar incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar propriedades básicas de causalidade e estabilidade",
                                  "subSteps": [
                                    "Verifique se grau(numerador) ≤ grau(denominador) para causalidade.",
                                    "Localize pólos: todos devem estar no semiplano esquerdo (Re(p) < 0) para estabilidade.",
                                    "Calcule o ganho em frequência zero (lim s->0 H(s)) e verifique se é finito e positivo.",
                                    "Confirme ausência de pólos no semiplano direito ou imaginário puro.",
                                    "Avalie o número relativo de pólos e zeros."
                                  ],
                                  "verification": "Crie um checklist marcado confirmando causalidade e estabilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora gráfica ou MATLAB (pzmap para pólos/zeros).",
                                  "tips": "Plote o mapa de pólos-zeros para visualização intuitiva.",
                                  "learningObjective": "Aplicar critérios fundamentais de realizabilidade algébrica.",
                                  "commonMistakes": "Confundir pólos com zeros ou ignorar pólos no eixo imaginário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e analisar diagramas de Bode",
                                  "subSteps": [
                                    "Gere o diagrama de Bode de magnitude e fase usando log(ω).",
                                    "Verifique inclinação inicial: -20*(Np - Nz) dB/década, onde Np e Nz são números de pólos/zeros.",
                                    "Analise assíntotas e desvios em cantos de frequência (1/|polo/zero|).",
                                    "Confirme que magnitude diminui monotonicamente em altas frequências.",
                                    "Examine fase: deve começar em 0° ou -180° e aproximar -90°*(Np - Nz)."
                                  ],
                                  "verification": "Compare diagrama gerado com assíntotas manuais; erro < 5 dB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "MATLAB (bodeplot) ou Python (control library).",
                                  "tips": "Use escalas logarítmicas para precisão em frequências amplas.",
                                  "learningObjective": "Interpretar propriedades de Bode para viabilidade física.",
                                  "commonMistakes": "Erro na contagem de cantos ou ignorar desvios de fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar critério de mínimo de fase",
                                  "subSteps": [
                                    "Confirme que todos zeros estão no semiplano esquerdo (Re(z) < 0).",
                                    "Para sistemas mínimos de fase, fase φ(ω) ≥ φ_min(ω) para todo ω.",
                                    "Compare com versão não mínima: adicione zero no semiplano direito e veja aumento de fase.",
                                    "Calcule integral de Bode para validar minimalidade.",
                                    "Verifique se H(s) é invertível com estabilidade."
                                  ],
                                  "verification": "Plote fase vs. frequência mínima teórica; fase real acima ou igual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB para plot de fase e comparação.",
                                  "tips": "Lembre: sistemas mínimos de fase têm menor fase negativa para dada magnitude.",
                                  "learningObjective": "Distinguir sistemas mínimos de fase para realizabilidade.",
                                  "commonMistakes": "Assumir minimalidade sem verificar zeros no semiplano direito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir avaliação de realizabilidade física geral",
                                  "subSteps": [
                                    "Integre todos os critérios: causalidade, estabilidade, Bode consistente, mínimo de fase.",
                                    "Verifique simetria positiva-real: H(s*) = H*(s).",
                                    "Avalie resposta impulsional: deve ser causal e decair.",
                                    "Compare com sistemas físicos conhecidos (ex: massa-mola).",
                                    "Documente conclusão: realizável ou não, com justificativas."
                                  ],
                                  "verification": "Relatório escrito com checklist completo e conclusão clara.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para relatório final.",
                                  "tips": "Use exemplos de sistemas aeronáuticos para benchmark.",
                                  "learningObjective": "Sintetizar análise para decisão final de viabilidade.",
                                  "commonMistakes": "Ignorar simetria ou inconsistências menores."
                                }
                              ],
                              "practicalExample": "Para H(s) = 1 / (s^2 + 2s + 1), verifique: causal (grau ok), estável (pólos em -1), Bode com slope -40 dB/dec, mínimo de fase (sem zeros RHP), confirmando modelo de oscilador amortecido realista para controle de flap em aeronave.",
                              "finalVerifications": [
                                "Todos pólos no semiplano esquerdo.",
                                "Grau numerador ≤ denominador.",
                                "Diagrama de Bode com inclinação inicial correta.",
                                "Fase mínima para dada magnitude.",
                                "Resposta impulsional causal e finita.",
                                "Simetria positiva-real satisfeita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição de H(s) (100% pólos/zeros corretos).",
                                "Correta interpretação de Bode (erro < 3 dB em assíntotas).",
                                "Aplicação válida do critério mínimo de fase.",
                                "Checklist completo sem omissões.",
                                "Conclusão justificada com evidências.",
                                "Tempo total dentro de 1.5 horas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e integrais de contorno.",
                                "Física: Dinâmica de sistemas mecânicos e elétricos.",
                                "Engenharia de Controle: Projeto de controladores PID.",
                                "Processamento de Sinais: Análise em frequência digital."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, validar modelos de função de transferência para sistemas de controle de voo, como estabilizadores automáticos, garantindo que simulações reflitam física real e evitem instabilidades catastróficas em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Derivação e Aplicação de H(s) em Análise",
                        "description": "Processo de obtenção de H(s) a partir de modelos diferenciais e seu uso em diagramas de blocos e solução de respostas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Derivar H(s) de equações diferenciais",
                            "description": "Aplicar transformada de Laplace a equações diferenciais lineares com coeficientes constantes, assumindo condições iniciais nulas, para obter H(s) = Y(s)/X(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular a equação diferencial do sistema",
                                  "subSteps": [
                                    "Ler o problema e identificar a variável de saída y(t) e a entrada x(t)",
                                    "Escrever a equação diferencial ordinária (EDO) linear com coeficientes constantes em forma padrão",
                                    "Confirmar que as condições iniciais são nulas (y(0) = 0, y'(0) = 0, etc.)",
                                    "Verificar se a EDO está na forma adequada para Laplace: sem termos não lineares ou variáveis coeficientes",
                                    "Anotar os graus da derivada mais alta para prever o denominador de H(s)"
                                  ],
                                  "verification": "A equação está escrita corretamente, com y(t) e derivadas à esquerda e x(t) à direita, sem erros de notação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Folha de propriedades da transformada de Laplace"
                                  ],
                                  "tips": "Use notação consistente: y para saída, x para entrada, e apóstrofos ou pontos para derivadas.",
                                  "learningObjective": "Formular precisamente a EDO governante de um sistema linear contínuo.",
                                  "commonMistakes": [
                                    "Confundir entrada x(t) com saída y(t)",
                                    "Esquecer termos de derivadas intermediárias",
                                    "Ignorar a ordem da EDO"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a transformada de Laplace à equação diferencial",
                                  "subSteps": [
                                    "Aplicar Laplace ao lado esquerdo: L{y''} = s²Y(s), L{y'} = sY(s), L{y} = Y(s), assumindo condições iniciais nulas",
                                    "Aplicar Laplace ao lado direito: L{x(t)} = X(s)",
                                    "Substituir todos os termos, expandindo multiplicadores como (as² + bs + c)Y(s)",
                                    "Igualar ambos os lados da equação transformada",
                                    "Verificar se todas as propriedades de derivadas foram aplicadas corretamente"
                                  ],
                                  "verification": "Equação no domínio s está balanceada, com Y(s) e X(s) isolados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora para álgebra simbólica opcional"
                                  ],
                                  "tips": "Lembre-se: para condições iniciais nulas, ignore os termos y(0) e y'(0).",
                                  "learningObjective": "Dominar a aplicação da transformada de Laplace a EDOs lineares.",
                                  "commonMistakes": [
                                    "Esquecer o fator s nas derivadas",
                                    "Incluir incorretamente condições iniciais não nulas",
                                    "Erro em propriedades lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar e derivar a função de transferência H(s) = Y(s)/X(s)",
                                  "subSteps": [
                                    "Mover todos os termos com Y(s) para o lado esquerdo e X(s) para o direito",
                                    "Dividir ambos os lados por X(s) para obter Y(s)/X(s) = H(s)",
                                    "Escrever H(s) como fração racional: numerador / denominador",
                                    "Identificar coeficientes do polinômio denominador da EDO original",
                                    "Confirmar que H(s) é próprio (grau numerador < grau denominador)"
                                  ],
                                  "verification": "H(s) expressa explicitamente como Y(s)/X(s), com fração simplificada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para álgebra",
                                    "Software simbólico como SymPy ou MATLAB opcional"
                                  ],
                                  "tips": "Fatore o denominador se possível para análise posterior.",
                                  "learningObjective": "Extrair corretamente a função de transferência de uma equação transformada.",
                                  "commonMistakes": [
                                    "Dividir pelo termo errado",
                                    "Esquecer de isolar Y(s) completamente",
                                    "Inverter numerador e denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificar H(s) e realizar verificações preliminares",
                                  "subSteps": [
                                    "Simplificar a fração racional, cancelando fatores comuns",
                                    "Verificar o ganho em DC (lim s->0 H(s)) se aplicável",
                                    "Identificar polos e zeros iniciais",
                                    "Comparar com a EDO original para consistência",
                                    "Testar com uma entrada unitária simples (ex: degrau) para validar"
                                  ],
                                  "verification": "H(s) simplificada coincide com soluções conhecidas ou simulações.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de funções de transferência padrão"
                                  ],
                                  "tips": "Use fatoração para polinômios familiares como (s² + 2ζωs + ω²).",
                                  "learningObjective": "Simplificar e validar a função de transferência derivada.",
                                  "commonMistakes": [
                                    "Cancelar termos incorretamente",
                                    "Ignorar simplificações óbvias",
                                    "Erro em limites para ganho estático"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y''(t) + 3y'(t) + 2y(t) = x(t), com y(0)=y'(0)=0: Aplicar Laplace dá (s² + 3s + 2)Y(s) = X(s), logo H(s) = 1/(s² + 3s + 2) = 1/((s+1)(s+2)).",
                              "finalVerifications": [
                                "Derivar H(s) corretamente para pelo menos 3 EDOs de ordens 1 e 2 fornecidas",
                                "Identificar polos e zeros de H(s) sem erros",
                                "Verificar ganho em frequência zero (DC gain) matches com EDO",
                                "Simular resposta a degrau unitário usando H(s) e comparar com solução analítica",
                                "Explicar verbalmente os passos sem consultar notas",
                                "Aplicar a uma EDO real de engenharia aeronáutica"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de propriedades de Laplace (90% correto)",
                                "Correta isolamento e simplificação de H(s) (sem erros algébricos)",
                                "Identificação adequada de ordem e estrutura da EDO",
                                "Validação consistente com verificações preliminares",
                                "Eficiência temporal: completar em <60 minutos",
                                "Clareza na documentação dos passos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Avançada: Solução de EDOs via Laplace",
                                "Física: Modelagem de sistemas massa-mola-amortecedor",
                                "Engenharia de Controle: Análise de estabilidade via polos",
                                "Programação: Implementação em MATLAB/Simulink para simulação",
                                "Processamento de Sinais: Extensão a sistemas discretos"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, derivar H(s) modela a dinâmica de aeronaves, como resposta longitudinal a comandos de elevador, permitindo design de sistemas de controle de voo autônomos e análise de estabilidade em manobras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Construir diagrama de blocos com H(s)",
                            "description": "Representar sistemas em cascata ou paralelo usando funções de transferência, calculando H(s) equivalente via regras de simplificação de blocos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Diagramas de Blocos e Funções de Transferência",
                                  "subSteps": [
                                    "Defina diagrama de blocos como representação gráfica de sistemas dinâmicos com entradas, saídas e blocos H(s).",
                                    "Explique funções de transferência H(s) como razão de polinômios Laplace de saída sobre entrada.",
                                    "Identifique símbolos básicos: soma (+), ramificação, realimentação e blocos em série/paralelo.",
                                    "Liste regras de simplificação: multiplicação para cascata, soma ponderada para paralelo.",
                                    "Desenhe um diagrama simples de um bloco único para fixar."
                                  ],
                                  "verification": "Crie um diagrama básico de um bloco único e explique verbalmente as regras de cascata e paralelo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Sistemas Dinâmicos, quadro branco, lápis e papel.",
                                  "tips": "Use cores diferentes para entradas, saídas e blocos para visualização clara.",
                                  "learningObjective": "Compreender os elementos básicos e regras de manipulação de diagramas de blocos.",
                                  "commonMistakes": "Confundir soma com multiplicação em cascata; ignorar ramificações em paralelo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Diagrama de Blocos para Sistemas em Cascata",
                                  "subSteps": [
                                    "Dado um sistema com H1(s) seguido de H2(s), desenhe blocos em série com seta de saída de H1 para entrada de H2.",
                                    "Adicione ponto de entrada inicial e saída final.",
                                    "Rotule todas as funções de transferência nos blocos.",
                                    "Verifique conectividade: saída de um bloco é entrada do próximo.",
                                    "Anote H_eq(s) = H1(s) * H2(s) ao lado do diagrama."
                                  ],
                                  "verification": "Desenhe o diagrama e calcule H_eq(s) manualmente para dois blocos dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, software como MATLAB/Simulink (opcional), exemplos de problemas.",
                                  "tips": "Comece com setas de sinal antes de adicionar blocos para mapear fluxo.",
                                  "learningObjective": "Representar e simplificar sistemas em cascata visual e algebricamente.",
                                  "commonMistakes": "Esquecer de multiplicar H(s) na simplificação; inverter ordem dos blocos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Diagrama de Blocos para Sistemas em Paralelo",
                                  "subSteps": [
                                    "Dado H1(s) e H2(s) em paralelo, desenhe soma (+) com entradas comuns e saídas somadas.",
                                    "Conecte entrada ao soma inicial, saídas de H1 e H2 ao soma final.",
                                    "Rotule ramificações e soma com sinais (+ ou - se aplicável).",
                                    "Calcule H_eq(s) = H1(s) + H2(s) ou variações ponderadas.",
                                    "Adicione realimentação simples se especificado no problema."
                                  ],
                                  "verification": "Construa diagrama paralelo e derive H_eq(s), comparando com fórmula esperada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmos do step anterior, mais exemplos com coeficientes.",
                                  "tips": "Use setas paralelas idênticas para entradas comuns para evitar confusão.",
                                  "learningObjective": "Modelar e simplificar configurações paralelas de sistemas lineares.",
                                  "commonMistakes": "Esquecer ramificação na entrada; somar incorretamente em vez de multiplicar em cascata."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificar Diagramas Complexos e Calcular H(s) Equivalente",
                                  "subSteps": [
                                    "Combine cascata e paralelo em um diagrama misto dado.",
                                    "Aplique regras sequencialmente: primeiro cascata, depois paralelo.",
                                    "Reduza blocos passo a passo, movendo somas se necessário.",
                                    "Derive expressão algébrica final de H_eq(s).",
                                    "Teste com valores numéricos simples (ex: s=0)."
                                  ],
                                  "verification": "Simplifique um diagrama completo e verifique H_eq(s) via substituição Laplace.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora científica, software de simbólico como Mathematica, problemas avançados.",
                                  "tips": "Numere cada redução intermediária para rastrear erros.",
                                  "learningObjective": "Manipular diagramas híbridos para obter H(s) equivalente eficiente.",
                                  "commonMistakes": "Aplicar regra errada (multiplicar em paralelo); erros algébricos em polinômios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Documentar o Diagrama Final",
                                  "subSteps": [
                                    "Compare diagrama simplificado com original via simulação ou cálculo.",
                                    "Documente todas as simplificações em um relatório curto.",
                                    "Identifique possíveis realimentações ou não-linearidades ausentes.",
                                    "Crie variação com ruído ou perturbação.",
                                    "Autoavalie usando critérios de verificação."
                                  ],
                                  "verification": "Apresente diagrama final e relatório, respondendo perguntas sobre simplificações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Template de relatório, simulador online de sistemas (ex: Control Tutorials).",
                                  "tips": "Sempre teste com entrada unitária passo para validar resposta.",
                                  "learningObjective": "Garantir precisão e documentação profissional de análises de sistemas.",
                                  "commonMistakes": "Ignorar unidades ou escalas; não validar numericamente."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave, construa diagrama com H1(s) = 1/(s+1) (sensores) em cascata com H2(s) = 10/(s^2 + 2s + 5) (atuadores), e H3(s) paralelo para correção. Simplifique para H_eq(s) = [1/(s+1)] * [10/(s^2 + 2s + 5) + H3(s)].",
                              "finalVerifications": [
                                "Diagrama possui todos blocos rotulados com H(s) corretos.",
                                "H_eq(s) derivado matches regras de cascata/paralelo.",
                                "Fluxo de sinal é contínuo sem loops não intencionais.",
                                "Simplificação reduz a um único bloco equivalente.",
                                "Teste numérico: resposta a entrada degrau coincide.",
                                "Documentação inclui passos intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação gráfica (30%)",
                                "Correção algébrica de H_eq(s) (30%)",
                                "Aplicação correta de regras de simplificação (20%)",
                                "Clareza e legibilidade do diagrama (10%)",
                                "Validação e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e álgebra de polinômios.",
                                "Programação: Simulação em MATLAB/Simulink para verificação.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos.",
                                "Engenharia de Controle: Aplicação em estabilidade de voo."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, diagramas de blocos com H(s) são usados para projetar sistemas de controle de voo autônomo, como estabilização de pitch em drones ou aviões comerciais, permitindo análise de estabilidade e resposta transitória antes de testes reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Calcular resposta via H(s)",
                            "description": "Determinar Y(s) = H(s) X(s) para entradas específicas como degrau ou seno, e obter y(t) via inversa de Laplace ou resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar H(s) e X(s)",
                                  "subSteps": [
                                    "Analise o sistema para obter ou confirmar a função de transferência H(s).",
                                    "Identifique o tipo de entrada (ex: degrau unitário X(s)=1/s, seno X(s)=ω/(s²+ω²)).",
                                    "Escreva explicitamente H(s) e X(s) em forma polinomial ou fatorada.",
                                    "Verifique o domínio de convergência se aplicável.",
                                    "Simplifique expressões iniciais usando propriedades de Laplace."
                                  ],
                                  "verification": "H(s) e X(s) estão corretamente escritas e combinam com o problema dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Papel e lápis ou software como MATLAB/SymPy"
                                  ],
                                  "tips": "Sempre normalize a entrada para unitária primeiro para facilitar comparações.",
                                  "learningObjective": "Preparar corretamente as funções no domínio s para multiplicação.",
                                  "commonMistakes": [
                                    "Confundir H(s) com a função de estado",
                                    "Esquecer fatores de escala na entrada seno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Y(s) = H(s) * X(s)",
                                  "subSteps": [
                                    "Multiplique os numeradores e denominadores de H(s) e X(s).",
                                    "Simplifique a fração Y(s) cancelando termos comuns.",
                                    "Expanda Y(s) em frações parciais se necessário para inversa posterior.",
                                    "Verifique o grau do numerador < grau do denominador para estabilidade.",
                                    "Anote polos e zeros de Y(s)."
                                  ],
                                  "verification": "Y(s) é uma fração própria e simplificada sem erros algébricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software (ex: Mathematica)",
                                    "Folha de exercícios com exemplos"
                                  ],
                                  "tips": "Use fatoração para cancelamentos fáceis; evite expansão desnecessária agora.",
                                  "learningObjective": "Executar multiplicação precisa no domínio da Laplace.",
                                  "commonMistakes": [
                                    "Erros em multiplicação polinomial",
                                    "Não cancelar fatores comuns levando a Y(s) complexa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter y(t) via transformada inversa de Laplace",
                                  "subSteps": [
                                    "Aplique decomposição em frações parciais a Y(s).",
                                    "Identifique resíduos nos polos ou use tabelas de Laplace para inversa.",
                                    "Para entradas seno, use propriedades de convolução se complexo.",
                                    "Integre o Heaviside para respostas causais.",
                                    "Escreva y(t) em forma fechada com exponenciais e senos/cossenos."
                                  ],
                                  "verification": "y(t) converge para t≥0 e matches simulações numéricas básicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela completa de pares Laplace",
                                    "Software de cálculo simbólico (SymPy/MATLAB)"
                                  ],
                                  "tips": "Pratique resíduos para polos múltiplos; tabelas aceleram casos simples.",
                                  "learningObjective": "Dominar métodos de inversa (frações parciais, resíduos) para respostas transitórias.",
                                  "commonMistakes": [
                                    "Esquecer termo Heaviside u(t)",
                                    "Erro nos resíduos de polos complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a resposta y(t)",
                                  "subSteps": [
                                    "Compare y(t→∞) com ganho estático H(0).",
                                    "Plote y(t) vs tempo para visualizar overshoot e settling.",
                                    "Verifique limites iniciais: y(0+) e y'(0+).",
                                    "Simule numericamente para validação.",
                                    "Discuta comportamento físico (ex: oscilações em sistemas subamortecidos)."
                                  ],
                                  "verification": "Condições iniciais e limites finais atendidos; gráfico coerente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Python Matplotlib)",
                                    "Simulador como Simulink"
                                  ],
                                  "tips": "Use teorema do valor final para checagem rápida.",
                                  "learningObjective": "Validar soluções analíticas com princípios físicos e numéricos.",
                                  "commonMistakes": [
                                    "Ignorar condições iniciais",
                                    "Interpretação errada de polos imaginários"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = 1/(s² + 2s + 2), entrada degrau unitário X(s)=1/s: Y(s) = 1/[s(s² + 2s + 2)], frações parciais levam a y(t) = 1 - e^{-t}(cos(t) + sin(t)) u(t). Verifique y(∞)=1 e oscilações.",
                              "finalVerifications": [
                                "Y(s) simplificado corretamente sem cancelamentos perdidos.",
                                "y(t) possui u(t) e converge corretamente.",
                                "Limites iniciais y(0+)=0 e finais atendem ganho DC.",
                                "Gráfico de y(t) mostra resposta física esperada.",
                                "Resíduos ou frações parciais sem erros aritméticos.",
                                "Solução matches simulação numérica em pelo menos 3 pontos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na multiplicação e inversa (100% correto).",
                                "Uso adequado de métodos (frações parciais >3 polos; resíduos para múltiplos).",
                                "Verificações completas incluindo limites e estabilidade.",
                                "Interpretação qualitativa do comportamento transitório.",
                                "Eficiência: tempo dentro do estimado sem erros graves.",
                                "Clareza na documentação de passos e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa (resíduos, contorno de Bromwich).",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor modelados por H(s).",
                                "Controle Automático: Resposta a comandos em malha aberta.",
                                "Programação: Implementação em Python (control library) para simulação.",
                                "Engenharia Mecânica: Vibrações em estruturas aeronáuticas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular a resposta de altitude de uma aeronave a um comando de degrau em elevador usando H(s) do modelo longitudinal, prevendo overshoot e tempo de estabilização para certificação de voo seguro."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1",
                              "10.1.2.3.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Determinação de Soluções de Modelos Lineares",
                    "description": "Métodos para resolver equações diferenciais lineares contínuas e obter respostas em regime permanente e transitório.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Solução Analítica Direta de Equações Diferenciais Lineares",
                        "description": "Método clássico para resolver equações diferenciais lineares de coeficientes constantes, incluindo solução homogênea, particular e aplicação de condições iniciais para obter respostas transitórias.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Determinar a solução homogênea",
                            "description": "Calcular as raízes da equação característica e expressar a solução homogênea para equações diferenciais lineares de ordem n com coeficientes constantes reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e reescrever a equação diferencial na forma padrão",
                                  "subSteps": [
                                    "Leia a equação diferencial linear de ordem n com coeficientes constantes reais.",
                                    "Confirme que é homogênea (lado direito igual a zero).",
                                    "Reescreva na forma y^(n) + a_{n-1} y^(n-1) + ... + a_0 y = 0.",
                                    "Identifique os coeficientes a_0, a_1, ..., a_{n-1}.",
                                    "Verifique se todos coeficientes são reais e constantes."
                                  ],
                                  "verification": "A equação está na forma padrão com o termo de maior derivada com coeficiente 1 e igual a zero no lado direito.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora básica"
                                  ],
                                  "tips": [
                                    "Padronize sempre dividindo pela coeficiente líder se necessário.",
                                    "Anote os coeficientes claramente para evitar erros de transcrição."
                                  ],
                                  "learningObjective": "Reconhecer e preparar corretamente uma equação diferencial linear homogênea para análise.",
                                  "commonMistakes": [
                                    "Esquecer de dividir pelo coeficiente líder.",
                                    "Confundir termos não homogêneos com homogêneos.",
                                    "Ignorar se coeficientes não são constantes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação característica",
                                  "subSteps": [
                                    "Escreva a equação característica: r^n + a_{n-1} r^{n-1} + ... + a_1 r + a_0 = 0.",
                                    "Copie os coeficientes da equação diferencial diretamente.",
                                    "Para ordem n, certifique-se de que o polinômio é de grau n.",
                                    "Teste com um exemplo simples para validar a formulação.",
                                    "Anote a equação em forma expandida ou fatorada inicial."
                                  ],
                                  "verification": "Substitua r=0 na equação característica; deve resultar em a_0 = 0 se correto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": [
                                    "Lembre-se: coeficientes da equação característica são os mesmos da ED, em ordem decrescente de potências.",
                                    "Use notação clara para r^k."
                                  ],
                                  "learningObjective": "Construir precisamente a equação característica associada à ED linear.",
                                  "commonMistakes": [
                                    "Inverter a ordem dos coeficientes.",
                                    "Esquecer o termo r^n com coeficiente 1.",
                                    "Confundir com equação da ED original."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as raízes da equação característica",
                                  "subSteps": [
                                    "Resolva o polinômio característico para encontrar todas as raízes r_1, r_2, ..., r_n.",
                                    "Classifique as raízes: reais distintas, reais múltiplas ou complexas conjugadas.",
                                    "Para raízes reais múltiplas de multiplicidade m, note todas m raízes iguais.",
                                    "Para raízes complexas α ± βi, identifique parte real e imaginária.",
                                    "Use métodos como fatoração, fórmula quadrática ou numéricos se necessário."
                                  ],
                                  "verification": "Verifique somando as raízes (deve igualar -a_{n-1}) e produto (a_0) pelo teorema de Vieta.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como Wolfram Alpha",
                                    "Tabelas de raízes quadráticas"
                                  ],
                                  "tips": [
                                    "Fatore sempre em binômios lineares ou quadráticos.",
                                    "Para ordem alta, procure raízes racionais primeiro com teorema das raízes racionais."
                                  ],
                                  "learningObjective": "Resolver com precisão a equação característica e classificar suas raízes.",
                                  "commonMistakes": [
                                    "Erros aritméticos em fatoração.",
                                    "Não reconhecer multiplicidades.",
                                    "Confundir raízes complexas com reais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar a solução homogênea geral",
                                  "subSteps": [
                                    "Para raízes reais distintas r_i: y_h = c_1 e^{r_1 t} + ... + c_n e^{r_n t}.",
                                    "Para raiz real múltipla r (m vezes): incluir t^k e^{r t} para k=0 a m-1.",
                                    "Para pares complexos α ± βi: e^{α t} (c_1 cos(β t) + c_2 sin(β t)).",
                                    "Combine todas as formas para a solução completa.",
                                    "Escreva com variáveis arbitrárias c_i."
                                  ],
                                  "verification": "Diferencie y_h n vezes e substitua na ED original; deve satisfazer.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de soluções padrão"
                                  ],
                                  "tips": [
                                    "Memorize as formas para cada caso de raízes.",
                                    "Use sin e cos para partes reais de complexas."
                                  ],
                                  "learningObjective": "Construir a solução geral homogênea correta baseada nas raízes.",
                                  "commonMistakes": [
                                    "Esquecer fatores t^k para multiplicidades.",
                                    "Usar exp em vez de sin/cos para complexas.",
                                    "Errar os coeficientes arbitrários."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação y'' - 5y' + 6y = 0: Equação característica r² - 5r + 6 = 0 → raízes r=2,3 → y_h = c1 e^{2t} + c2 e^{3t}. Verifique diferenciando: y_h' = 2c1 e^{2t} + 3c2 e^{3t}, y_h'' = 4c1 e^{2t} + 9c2 e^{3t}, e y_h'' - 5y_h' + 6y_h = 0.",
                              "finalVerifications": [
                                "Equação característica formada corretamente com todos coeficientes.",
                                "Raízes calculadas sem erros aritméticos e classificadas adequadamente.",
                                "Solução homogênea inclui todas as funções base corretas para as raízes.",
                                "Verificação por substituição na ED original resulta em identidade.",
                                "Forma geral com constantes arbitrárias c_i.",
                                "Tratamento correto de multiplicidades e raízes complexas, se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da equação característica (100% dos coeficientes corretos).",
                                "Correção no cálculo das raízes (verificação por Vieta).",
                                "Adequação da forma da solução às raízes (sem omissões ou extras).",
                                "Clareza na expressão matemática da solução homogênea.",
                                "Capacidade de verificar a solução por diferenciação.",
                                "Tratamento completo de casos especiais (múltiplas/complexas)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas massa-mola com amortecimento.",
                                "Engenharia de Controle: Análise de estabilidade de sistemas lineares.",
                                "Matemática Computacional: Implementação numérica em MATLAB/Simulink.",
                                "Engenharia Aeronáutica: Vibrações em estruturas de aeronaves."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, determinar a solução homogênea modela o decaimento livre de oscilações em sistemas dinâmicos como flaps de asas ou amortecedores de fuselagem, permitindo prever comportamentos transitórios sem forçantes externas para design seguro e eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Encontrar a solução particular",
                            "description": "Aplicar métodos como coeficientes indeterminados ou variação dos parâmetros para determinar a solução particular de equações diferenciais lineares forçadas por entradas como degrau, rampa ou senoide.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o tipo de forçamento e selecionar o método apropriado",
                                  "subSteps": [
                                    "Analise a equação diferencial linear: y'' + a y' + b y = g(t), onde g(t) é o termo forçante.",
                                    "Classifique g(t): degrau (constante), rampa (t), ou senoide (A sin(ωt) ou A cos(ωt)).",
                                    "Escolha o método: coeficientes indeterminados para polinomiais, exponenciais ou sinusoides não ressonantes; variação de parâmetros para casos gerais ou ressonantes.",
                                    "Verifique se g(t) é da forma assumida para coeficientes indeterminados (modificar se ressonância).",
                                    "Anote a solução homogênea yh conhecida."
                                  ],
                                  "verification": "Confirme que o tipo de g(t) foi corretamente classificado e o método selecionado justificado por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Equação diferencial dada",
                                    "Tabela de formas para coeficientes indeterminados",
                                    "Solucionador simbólico como Mathematica ou SymPy (opcional)"
                                  ],
                                  "tips": [
                                    "Use tabelas padrão para formas de yp; memorize para degrau (constante), rampa (At + B), seno (C sin + D cos)."
                                  ],
                                  "learningObjective": "Classificar corretamente o forçamento e escolher o método ótimo para eficiência.",
                                  "commonMistakes": [
                                    "Confundir ressonância (multiplicar por t se ω coincide com raiz homogênea)",
                                    "Ignorar multiplicidade de raízes na homogênea"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o método de coeficientes indeterminados",
                                  "subSteps": [
                                    "Assuma a forma de yp baseada em g(t): constante para degrau, linear para rampa, C sin(ωt) + D cos(ωt) para senoide.",
                                    "Se ressonância, multiplique por t^s onde s é a multiplicidade.",
                                    "Derive yp e y'p, y''p e substitua na equação.",
                                    "Resolva o sistema linear para os coeficientes indeterminados.",
                                    "Simplifique yp obtida."
                                  ],
                                  "verification": "Substitua yp de volta em y'' + a y' + b y - g(t) = 0 e confirme que resulta em zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/SymPy",
                                    "Tabela de derivadas trigonométricas"
                                  ],
                                  "tips": [
                                    "Agrupe termos sin e cos separadamente para resolver C e D simultaneamente."
                                  ],
                                  "learningObjective": "Dominar a assunção de formas e resolução de sistemas para soluções particulares não ressonantes.",
                                  "commonMistakes": [
                                    "Esquecer fatores de multiplicidade em ressonância",
                                    "Erros em derivadas de produtos sin/cos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o método de variação de parâmetros como alternativa",
                                  "subSteps": [
                                    "Use a solução homogênea yh = c1 y1 + c2 y2, com y1 e y2 linearmente independentes.",
                                    "Assuma yp = u1(t) y1 + u2(t) y2.",
                                    "Configure o sistema: u1' y1 + u2' y2 = 0; u1' y1' + u2' y2' = g(t).",
                                    "Resolva para u1' e u2' usando determinante de Wronskiano W = y1 y2' - y2 y1'.",
                                    "Integre u1 = ∫ u1' dt, u2 = ∫ u2' dt para obter yp."
                                  ],
                                  "verification": "Verifique que yp satisfaz a equação original e não contém constantes arbitrárias.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Fórmula do Wronskiano",
                                    "Tabelas de integrais indefinidas",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": [
                                    "Calcule W primeiro; u1' = -y2 g / W, u2' = y1 g / W."
                                  ],
                                  "learningObjective": "Aplicar variação de parâmetros para qualquer g(t) contínuo, especialmente ressonantes.",
                                  "commonMistakes": [
                                    "Erro no sinal do Wronskiano",
                                    "Esquecer de integrar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar a solução particular",
                                  "subSteps": [
                                    "Substitua yp em ambas as equações (original e derivadas) para validação numérica/analítica.",
                                    "Compare resultados dos dois métodos se aplicável.",
                                    "Discuta limitações: ex., coeficientes indeterminados falha em ressonância.",
                                    "Prepare para solução geral: y = yh + yp.",
                                    "Teste com valores iniciais simples para consistência."
                                  ],
                                  "verification": "yp deve cancelar exatamente g(t) quando plugado na operadora diferencial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos de yp vs g(t)",
                                    "Software de plotagem como Desmos ou MATLAB"
                                  ],
                                  "tips": [
                                    "Use expansão em série ou numérico para verificação extra."
                                  ],
                                  "learningObjective": "Garantir robustez da solução particular através de validação múltipla.",
                                  "commonMistakes": [
                                    "Aceitar yp com constantes arbitrárias (deve ser particular, sem c1,c2)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y'' + 4y' + 3y = t (rampa), yh = c1 e^{-t} + c2 e^{-3t}. Usando coef. indet.: yp = At + B. Derivadas: y'p = A, y''p=0. Subst: 4A + 3(At+B) = t → 3A=1 (A=1/3), 4A+3B=0 (B=-4/9). yp = (1/3)t - 4/9. Verificação: plug-in confirma.",
                              "finalVerifications": [
                                "yp satisfaz a equação não homogênea: L[yp] = g(t).",
                                "yp não contém termos da solução homogênea.",
                                "Resultados de ambos métodos coincidem.",
                                "Comportamento assintótico correto (ex., rampa → linear).",
                                "Verificação numérica em pelo menos 3 pontos t.",
                                "Gráfico de yp sobreposto a g(t) mostra match."
                              ],
                              "assessmentCriteria": [
                                "Escolha correta do método baseado no tipo de g(t) (90% precisão).",
                                "Cálculos algébricos sem erros (verificados por substituição).",
                                "Explicação clara da forma assumida para yp.",
                                "Tratamento adequado de ressonância se aplicável.",
                                "Eficiência: tempo e passos mínimos.",
                                "Validação múltipla demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Resposta forçada em osciladores harmônicos (ressonância).",
                                "Controle de Sistemas: Resposta a entradas em laços de feedback.",
                                "Programação: Implementação numérica em Python (SciPy odeint).",
                                "Matemática Computacional: Soluções simbólicas com SymPy.",
                                "Engenharia de Controle: Modelagem de plantas lineares."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, modela a resposta de uma aeronave a perturbações como rajadas de vento (senoide) ou comandos de controle (degrau/rampa), essencial para design de sistemas de controle de voo estável e autônomo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Aplicar condições iniciais",
                            "description": "Combinar soluções homogênea e particular, ajustando constantes com condições iniciais para obter a resposta completa transitória de um sistema linear contínuo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e listar soluções homogênea e particular",
                                  "subSteps": [
                                    "Identifique a equação diferencial linear (EDL) dada e confirme que a solução homogênea (y_h) e particular (y_p) já foram calculadas corretamente.",
                                    "Escreva explicitamente y_h(t), incluindo todas as raízes do polinômio característico e constantes arbitrárias (ex: c1, c2).",
                                    "Escreva y_p(t) sem constantes arbitrárias, confirmando que atende a equação não homogênea.",
                                    "Verifique dimensionalmente ou por substituição rápida se y_h e y_p estão corretas.",
                                    "Anotar as condições iniciais fornecidas (ex: y(0), y'(0))."
                                  ],
                                  "verification": "Ambas soluções listadas corretamente e condições iniciais anotadas sem erros.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Caderno ou software de anotações (ex: Mathematica, MATLAB)",
                                    "Exemplo de EDL resolvida parcialmente"
                                  ],
                                  "tips": "Sempre diferencie y_h e y_p para preparar a aplicação das condições iniciais.",
                                  "learningObjective": "Compreender os componentes fundamentais da solução geral antes da aplicação de condições.",
                                  "commonMistakes": [
                                    "Confundir y_h com y_p",
                                    "Esquecer multiplicidades em raízes repetidas",
                                    "Não listar todas as constantes arbitrárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formar a solução geral transitória",
                                  "subSteps": [
                                    "Escreva a solução geral: y(t) = y_h(t) + y_p(t), destacando as constantes (c1, c2, etc.).",
                                    "Calcule as derivadas necessárias da solução geral até a ordem da EDL (ex: y'(t), y''(t)).",
                                    "Substitua t=0 nas condições iniciais para formar equações com as constantes.",
                                    "Confirme que y_p contribui corretamente nos valores iniciais.",
                                    "Simplifique expressões algébricas iniciais."
                                  ],
                                  "verification": "Solução geral y(t) e suas derivadas escritas corretamente em função das constantes.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou papel e lápis",
                                    "Tabela de derivadas de funções exponenciais"
                                  ],
                                  "tips": "Mantenha y_p intacta; suas contribuições são fixas, apenas constantes de y_h são ajustadas.",
                                  "learningObjective": "Construir a forma completa da resposta transitória antes da resolução.",
                                  "commonMistakes": [
                                    "Incluir constantes em y_p",
                                    "Erro em derivadas de produtos ou exponenciais",
                                    "Esquecer termos em derivadas de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e resolver o sistema de equações lineares",
                                  "subSteps": [
                                    "Substitua t=0 em y(t), y'(t), etc., criando um sistema linear com as constantes (ex: c1 + c2 + y_p(0) = y(0)).",
                                    "Escreva o sistema matricial ou expandido claramente.",
                                    "Resolva o sistema por substituição, eliminação ou fórmula de Cramer.",
                                    "Substitua as constantes resolvidas de volta em y(t).",
                                    "Verifique numericamente se y(0) e y'(0) atendem com as constantes encontradas."
                                  ],
                                  "verification": "Sistema resolvido corretamente e condições iniciais satisfeitas numericamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Matriz solver online ou calculadora",
                                    "Exemplo numérico específico"
                                  ],
                                  "tips": "Para EDLs de ordem 2, o sistema é 2x2; generalize para ordens maiores.",
                                  "learningObjective": "Aplicar álgebra linear para determinar constantes únicas.",
                                  "commonMistakes": [
                                    "Erro de sinal ao substituir t=0",
                                    "Inverter coeficientes no sistema",
                                    "Arredondamento prematuro em cálculos exatos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a solução completa",
                                  "subSteps": [
                                    "Substitua a solução completa na EDL original para confirmar que satisfaz.",
                                    "Calcule resposta em poucos pontos adicionais (ex: t=1) e compare condições.",
                                    "Analise comportamento assintótico (transitório vs estacionário).",
                                    "Discuta limitações (validez para t>=0).",
                                    "Esboce gráfico qualitativo da resposta."
                                  ],
                                  "verification": "Solução verificada na EDL e condições iniciais; gráfico coerente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Software de plotagem (ex: Desmos, MATLAB)",
                                    "Gráfica"
                                  ],
                                  "tips": "Use sympy ou Wolfram Alpha para verificação rápida.",
                                  "learningObjective": "Garantir robustez e interpretação física da solução transitória.",
                                  "commonMistakes": [
                                    "Não verificar satisfação da EDL",
                                    "Ignorar comportamento em t->inf",
                                    "Erro em interpretação de overshoot"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDL y'' + 3y' + 2y = e^{-t}, y(0)=1, y'(0)=0: y_h = c1 e^{-t} + c2 e^{-2t}, y_p = -0.5 e^{-t}. Solução geral: y(t) = (c1 - 0.5) e^{-t} + c2 e^{-2t}. Aplicando IC: c1=1.5, c2=0. y(t)= e^{-t}. Verificação: satisfaz EDL e IC.",
                              "finalVerifications": [
                                "Solução completa satisfaz todas as condições iniciais exatas.",
                                "Substituição na EDL original resulta em identidade.",
                                "Comportamento transitório decai corretamente para o estacionário.",
                                "Derivadas calculadas consistentemente.",
                                "Solução simplificada sem termos redundantes.",
                                "Gráfico mostra resposta física coerente (sem oscilações espúrias)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formação da solução geral (100% dos termos corretos).",
                                "Correta resolução do sistema linear (sem erros algébricos).",
                                "Verificação completa e documentada.",
                                "Clareza na apresentação passo a passo.",
                                "Interpretação qualitativa adequada.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas massa-mola-amortecedor com forças externas.",
                                "Controle Automático: Cálculo de resposta a degraus iniciais em servomecanismos.",
                                "Programação: Implementação numérica em Python (scipy.integrate) para validação.",
                                "Matemática Computacional: Uso de solvers simbólicos como SymPy.",
                                "Engenharia de Controle: Análise de estabilidade transitória em loops de feedback."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, aplica-se para determinar a resposta transitória de um estabilizador de voo a perturbações iniciais de ângulo de ataque, combinando modos homogêneos (decaimento natural) com particular (controle estacionário), garantindo estabilidade e segurança em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Resposta ao Impulso e Integral de Convolução",
                        "description": "Representação da solução de sistemas lineares invariantes no tempo usando a resposta ao impulso e a convolução para calcular respostas transitórias a entradas arbitrárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Calcular a resposta ao impulso",
                            "description": "Derivar a função h(t), resposta ao impulso δ(t), a partir da equação diferencial do sistema ou sua função de transferência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar o modelo do sistema",
                                  "subSteps": [
                                    "Analise a equação diferencial dada, identificando coeficientes e termos de entrada/saída.",
                                    "Verifique se o sistema é linear invariante no tempo (LTI).",
                                    "Anote as condições iniciais como zero para resposta ao impulso.",
                                    "Se fornecido função de transferência, confirme que é H(s) = Y(s)/X(s)."
                                  ],
                                  "verification": "Modelo escrito corretamente com todos os parâmetros identificados e condições iniciais zeradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Equação diferencial ou função de transferência do problema, caderno de anotações.",
                                  "tips": "Sempre normalize a equação para forma padrão com y'' + a y' + b y = entrada.",
                                  "learningObjective": "Compreender a representação matemática do sistema LTI.",
                                  "commonMistakes": "Ignorar condições iniciais não-zero ou confundir entrada com saída."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de transferência H(s)",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace na equação diferencial assumindo condições iniciais zero.",
                                    "Substitua s por derivadas: L{y''} = s²Y(s), L{y'} = sY(s), L{y} = Y(s).",
                                    "Resolva para H(s) = Y(s)/X(s), simplificando polos e zeros.",
                                    "Se já dada H(s), verifique expandindo para equação diferencial."
                                  ],
                                  "verification": "H(s) obtida e simplificada, com polos e zeros identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabelas de Laplace, calculadora simbólica (opcional como SymPy).",
                                  "tips": "Fatore numerador e denominador para identificar ordem do sistema.",
                                  "learningObjective": "Dominar a transformação de equações diferenciais para domínio s.",
                                  "commonMistakes": "Esquecer o fator s nas derivadas ou não zerar condições iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a resposta ao impulso h(t) via inversa de Laplace",
                                  "subSteps": [
                                    "Substitua X(s) = 1 (para δ(t), L{δ(t)} = 1).",
                                    "Decompõe H(s) em frações parciais: somas de termos A/(s-p).",
                                    "Aplique inversa de Laplace em cada termo usando tabelas.",
                                    "Some os resultados para obter h(t) no domínio tempo."
                                  ],
                                  "verification": "h(t) expressa analiticamente, com unidade Heaviside se aplicável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabelas de transformadas de Laplace inversas, software como MATLAB ou Python.",
                                  "tips": "Para polos complexos, use pares conjugados para senos e cossenos.",
                                  "learningObjective": "Executar decomposição em frações parciais e inversa de Laplace com precisão.",
                                  "commonMistakes": "Erros em resíduos de frações parciais ou esquecimento de e^{-at}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar a solução",
                                  "subSteps": [
                                    "Verifique h(0+) = coeficiente de impulso inicial.",
                                    "Integre h(t) de 0 a ∞ deve ser H(0) para sistemas causais estáveis.",
                                    "Plote h(t) numericamente e compare com simulação.",
                                    "Confirme dimensionalidade e estabilidade (polos no semiplano esquerdo)."
                                  ],
                                  "verification": "Todas verificações passaram, gráfico gerado se possível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python Matplotlib), simulador como Simulink.",
                                  "tips": "Use limite lim_{s->∞} s H(s) para h(0+).",
                                  "learningObjective": "Garantir robustez da solução através de validações múltiplas.",
                                  "commonMistakes": "Não detectar instabilidades ou erros de sinal em exponenciais."
                                }
                              ],
                              "practicalExample": "Para um sistema de massa-mola-amortecedor: m y'' + c y' + k y = x(t). Com m=1, c=2, k=1, H(s) = 1/(s² + 2s + 1) = 1/(s+1)². Frações parciais: h(t) = t e^{-t} u(t). Verifique integral ∞ =1.",
                              "finalVerifications": [
                                "h(t) é zero para t<0 (causalidade).",
                                "∫_{-∞}^∞ h(t) dt = H(0).",
                                "lim_{t->0+} h(t) = lim_{s->∞} s H(s).",
                                "Solução bate com simulação numérica.",
                                "Unidades consistentes (ex: s para tempo).",
                                "Estabilidade confirmada por polos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de H(s) (sem erros algébricos).",
                                "Correta decomposição em frações parciais e inversa de Laplace.",
                                "Validações finais completas e corretas.",
                                "Expressão de h(t) simplificada e explícita.",
                                "Interpretação física coerente.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e análise de funções racionais.",
                                "Física: Dinâmica de sistemas mecânicos e elétricos.",
                                "Engenharia de Controle: Projeto de controladores baseados em resposta ao impulso.",
                                "Processamento de Sinais: Fundamento para convolução e filtros.",
                                "Programação: Implementação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, calcular h(t) para modelar a resposta de uma asa a uma rajada de vento impulsiva (δ(t)), essencial para estabilidade de voo e design de sistemas de controle autônomo em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Computar a integral de convolução",
                            "description": "Avaliar a convolução ∫ h(τ) x(t-τ) dτ para obter a resposta y(t) de um sistema LTI a uma entrada x(t) genérica, incluindo casos com condições iniciais zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Convolução em Sistemas LTI",
                                  "subSteps": [
                                    "Defina a convolução contínua como a operação que combina a entrada x(t) com a resposta ao impulso h(t) para obter y(t).",
                                    "Explique que para sistemas LTI com condições iniciais zero, y(t) = ∫_{-∞}^{∞} h(τ) x(t - τ) dτ.",
                                    "Identifique os limites práticos de integração baseados no suporte de h(τ) e x(t), tipicamente de 0 a t para funções causais.",
                                    "Revise propriedades como comutatividade e associatividade da convolução.",
                                    "Discuta a interpretação física: h(τ) representa o efeito retardado da entrada."
                                  ],
                                  "verification": "Escreva a fórmula geral da convolução e explique verbalmente seu significado em um sistema LTI.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim), caderno de anotações, acesso a Khan Academy ou vídeo introdutório sobre convolução."
                                  ],
                                  "tips": "Visualize a convolução como 'deslizar' h(τ) sobre x(t-τ) e integrar a sobreposição.",
                                  "learningObjective": "Compreender a base teórica da integral de convolução em sistemas lineares invariantes no tempo (LTI).",
                                  "commonMistakes": [
                                    "Confundir convolução com correlação.",
                                    "Ignorar que o sistema é causal e assumir limites de -∞ a ∞ sem ajuste.",
                                    "Esquecer que condições iniciais zero são cruciais para validade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Preparar as Funções h(t) e x(t)",
                                  "subSteps": [
                                    "Extraia h(t), a resposta ao impulso do sistema, e x(t), a entrada genérica, do problema dado.",
                                    "Desenhe os gráficos de h(τ) e x(t - τ) para entender seus suportes e formas.",
                                    "Determine os limites de integração corretos: para funções causais, ∫_0^t h(τ) x(t - τ) dτ.",
                                    "Expresse x(t - τ) explicitamente substituindo τ na função x.",
                                    "Verifique unidades e consistência dimensional entre h e x."
                                  ],
                                  "verification": "Desenhe gráficos de h(τ) e x(t - τ) para um t fixo e anote os limites de integração.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de plotagem como Desmos/MATLAB, exemplos de problemas de sistemas LTI."
                                  ],
                                  "tips": "Sempre plotar funções ajuda a visualizar onde a integral é não-zero.",
                                  "learningObjective": "Preparar corretamente as funções para avaliação da integral de convolução.",
                                  "commonMistakes": [
                                    "Erro na substituição: escrever x(τ - t) em vez de x(t - τ).",
                                    "Não ajustar limites para causalidade.",
                                    "Ignorar funções degrau unitário u(t)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Avaliar a Integral de Convolução",
                                  "subSteps": [
                                    "Escreva a integral explícita: y(t) = ∫ h(τ) x(t - τ) dτ com limites apropriados.",
                                    "Escolha o método de integração: substituição, integração por partes ou tabelas de integrais conhecidas.",
                                    "Realize a integração passo a passo, tratando casos para t < 0 (geralmente y(t)=0) e t ≥ 0.",
                                    "Simplifique a expressão resultante, aplicando propriedades como u(t).",
                                    "Compute numericamente para um valor específico de t para verificação intermediária."
                                  ],
                                  "verification": "Mostre o cálculo completo da integral para um exemplo simples e obtenha y(t) fechada.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha, SymPy ou MATLAB), tabela de integrais."
                                  ],
                                  "tips": "Use substituição u = t - τ para simplificar em alguns casos.",
                                  "learningObjective": "Executar o cálculo matemático preciso da convolução.",
                                  "commonMistakes": [
                                    "Erros de sinal na substituição u = t - τ.",
                                    "Esquecer o fator Jacobian du = -dτ.",
                                    "Não considerar o domínio onde funções são definidas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Interpretar e Analisar o Resultado",
                                  "subSteps": [
                                    "Verifique se y(t) satisfaz a equação diferencial do sistema original.",
                                    "Compare com casos conhecidos: convolução com δ(t) deve dar h(t), com degrau deve dar resposta degrau.",
                                    "Analise propriedades de y(t): estabilidade, tempo de subida, etc.",
                                    "Implemente numericamente em software para plotar y(t) vs. tempo.",
                                    "Discuta limitações: convergência para entradas não acausais."
                                  ],
                                  "verification": "Gere gráfico de y(t) e confirme que coincide com solução analítica em pontos chave.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "MATLAB/Python com SciPy para simulação numérica, osciloscópio virtual se aplicável."
                                  ],
                                  "tips": "Sempre valide com Laplace: Y(s) = H(s)X(s), depois inversa.",
                                  "learningObjective": "Validar e interpretar a solução da convolução no contexto do sistema.",
                                  "commonMistakes": [
                                    "Não verificar estabilidade (ex: polos no semiplano direito).",
                                    "Ignorar y(t)=0 para t<0.",
                                    "Confundir com solução total incluindo iniciais não-zero."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema com h(t) = 2e^{-2t} u(t) e entrada x(t) = u(t), compute y(t) = ∫_0^t 2e^{-2τ} * 1 dτ = 1 - e^{-2t} para t ≥ 0. Isso modela a resposta de um filtro de baixa passa em controle de flaps de aeronave a um comando degrau.",
                              "finalVerifications": [
                                "A integral está corretamente escrita com limites de 0 a t para causalidade.",
                                "O resultado y(t) é zero para t < 0 e contínuo em t=0.",
                                "Verificação via transformada de Laplace: Y(s) = H(s)X(s) coincide.",
                                "Gráfico de y(t) mostra comportamento esperado (assíntota a 1).",
                                "Cálculo numérico em t=1 dá valor aproximado correto (ex: 0.864).",
                                "Satisfaz a EDO original: y'' + ... = x(t)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da integral (25%)",
                                "Correção no cálculo da integração (30%)",
                                "Validação e verificações aplicadas (20%)",
                                "Interpretação física no contexto aeronáutico (15%)",
                                "Clareza na documentação e gráficos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Técnicas avançadas de integração e transformadas integrais.",
                                "Física: Modelagem de sistemas dinâmicos lineares em mecânica de voo.",
                                "Computação: Implementação numérica de convolução em MATLAB/Python para simulações.",
                                "Engenharia de Controle: Aplicação em laços de feedback de aeronaves.",
                                "Processamento de Sinais: Filtragem em radares e sensores embarcados."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a integral de convolução computa a resposta de sistemas de controle de voo (ex: estabilizadores) a entradas como comandos de piloto ou turbulência, essencial para design de autocontroladores em aviões comerciais e militares."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Interpretar componentes transitórios",
                            "description": "Analisar a saída da convolução para identificar e separar os termos transitórios que decaem com o tempo em sistemas estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a saída da convolução e propriedades do sistema",
                                  "subSteps": [
                                    "Obtenha a função de transferência H(s) ou a resposta ao impulso h(t) do sistema LTI contínuo.",
                                    "Confirme a estabilidade do sistema verificando que todos os pólos estão no semiplano esquerdo (Re(p) < 0).",
                                    "Calcule ou obtenha a saída y(t) = ∫ h(τ) x(t-τ) dτ para uma entrada x(t) específica, como degrau unitário.",
                                    "Expresse y(t) na forma decomposicional parcial, separando modos naturais e forçados.",
                                    "Identifique os termos que dependem da resposta ao impulso inicial."
                                  ],
                                  "verification": "A saída y(t) está expressa corretamente com decomposição em termos transitórios e estacionários; pólos confirmados como estáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel ou software como MATLAB/Simulink; tabela de resíduos para decomposição parcial.",
                                  "tips": "Sempre comece pela função de transferência para evitar cálculos desnecessários de convolução integral.",
                                  "learningObjective": "Compreender a estrutura matemática da saída da convolução em sistemas LTI estáveis.",
                                  "commonMistakes": "Ignorar a estabilidade do sistema, assumindo decaimento sem verificar pólos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes transitórios na saída",
                                  "subSteps": [
                                    "Localize os termos exponenciais decaentes em y(t), como A e^{-αt} onde α > 0.",
                                    "Diferencie-os dos termos estacionários (constantes ou sinusoidais persistentes para entradas periódicas).",
                                    "Use o teorema do valor final para confirmar o valor limite t→∞ de y(t).",
                                    "Marque os coeficientes de resíduos associados aos pólos do sistema.",
                                    "Plote y(t) vs. t para visualização qualitativa do decaimento."
                                  ],
                                  "verification": "Lista clara de termos transitórios identificados, com equações e gráfico mostrando decaimento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora gráfica ou Python/MATLAB para plotagem; exemplos de funções de transferência.",
                                  "tips": "Procure por fatores e^{st} onde s tem parte real negativa; ignore pólos de entrada.",
                                  "learningObjective": "Reconhecer matematicamente os termos que decaem devido aos pólos do sistema.",
                                  "commonMistakes": "Confundir transitórios com harmônicos da entrada periódica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Separar e isolar os componentes transitórios",
                                  "subSteps": [
                                    "Escreva y(t) = y_transient(t) + y_stationary(t), isolando explicitamente y_transient(t).",
                                    "Calcule os resíduos para cada polo usando fórmula R_k = lim_{s→p_k} (s - p_k) Y(s).",
                                    "Substitua de volta no domínio do tempo: y_transient(t) = Σ R_k e^{p_k t} para t ≥ 0.",
                                    "Verifique somando y_transient + y_stationary ≈ y(t) numericamente em pontos chave.",
                                    "Analise o tempo de assentamento (e.g., 4/α para decaimento de 2%)."
                                  ],
                                  "verification": "Equações separadas com soma verificada em pelo menos 3 pontos temporais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico como SymPy ou MATLAB Symbolic Toolbox; tabela de Laplace.",
                                  "tips": "Use expansão em frações parciais diretamente em Y(s) = H(s)X(s) para eficiência.",
                                  "learningObjective": "Executar separação algébrica precisa dos componentes.",
                                  "commonMistakes": "Erros em cálculo de resíduos, levando a coeficientes incorretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a separação fisicamente",
                                  "subSteps": [
                                    "Explique o significado físico: transitórios representam 'memória' inicial do sistema.",
                                    "Compare simulação numérica da convolução com a forma separada.",
                                    "Avalie impacto no desempenho (e.g., overshoot devido a transitórios).",
                                    "Discuta condições para decaimento completo (estabilidade e tempo suficiente).",
                                    "Documente em relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório com interpretação física, gráficos coincidentes e análise de impacto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador como MATLAB Simulink ou Python SciPy para convolução numérica.",
                                  "tips": "Simule com ruído para testar robustez da identificação.",
                                  "learningObjective": "Conectar análise matemática a comportamento dinâmico real.",
                                  "commonMistakes": "Interpretar estacionário como transitório em sistemas malhados."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave com H(s) = 1/(s+2)(s+1), para entrada degrau x(t)=u(t), y(t) = 1 - 1.5e^{-t} + 0.5e^{-2t}. Identifique transitórios: -1.5e^{-t} + 0.5e^{-2t}, que decaem, deixando y(∞)=1.",
                              "finalVerifications": [
                                "Todos pólos confirmados no semiplano esquerdo.",
                                "y_transient(t) → 0 quando t → ∞.",
                                "Soma y_transient + y_stationary reproduz y(t) exatamente.",
                                "Gráficos mostram decaimento claro dos transitórios.",
                                "Tempo de assentamento calculado corretamente.",
                                "Interpretação física coerente com aplicação aeronáutica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição parcial (100% coeficientes corretos).",
                                "Correta identificação de termos decaentes vs. persistentes.",
                                "Qualidade dos gráficos e verificações numéricas.",
                                "Profundidade da interpretação física.",
                                "Clareza e completude do relatório.",
                                "Eficiência no uso de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e transformadas de Laplace.",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor como análogos.",
                                "Programação: Simulação numérica em Python/MATLAB.",
                                "Engenharia de Controle: Projeto de controladores para minimizar transitórios."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, interpretar transitórios na resposta ao impulso permite otimizar controladores para reduzir oscilações iniciais durante manobras, garantindo estabilidade e conforto do piloto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Função de Transferência e Transformada de Laplace",
                        "description": "Uso da transformada de Laplace para obter a função de transferência H(s) e inverter para soluções no tempo, focando em respostas em regime permanente.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Obter a função de transferência H(s)",
                            "description": "Aplicar transformada de Laplace bilateral à equação diferencial, considerando condições iniciais zero, para derivar H(s) = Y(s)/X(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e escrever a equação diferencial do sistema LTI",
                                  "subSteps": [
                                    "Examine o modelo físico ou diagrama de blocos para identificar a equação diferencial linear com coeficientes constantes.",
                                    "Escreva a EDO na forma padrão: a_n y^{(n)} + ... + a_0 y = b_m x^{(m)} + ... + b_0 x, onde y é saída e x é entrada.",
                                    "Confirme que o sistema é causal e LTI, com ordem definida.",
                                    "Anote os coeficientes e a ordem da derivada máxima.",
                                    "Verifique se condições iniciais são zero (y(0^-)=0, y'(0^-)=0, etc.)."
                                  ],
                                  "verification": "A equação está escrita corretamente em forma padrão sem erros de coeficientes ou variáveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, diagrama do sistema ou descrição do modelo físico, tabela de referência de EDOs comuns.",
                                  "tips": "Sempre use y(t) para saída e x(t) para entrada para consistência.",
                                  "learningObjective": "Reconhecer e formular precisamente a EDO governante de um sistema dinâmico linear contínuo.",
                                  "commonMistakes": "Confundir entrada e saída; incluir condições iniciais não-zero prematuramente; erros de sinal nos coeficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a transformada de Laplace bilateral à equação diferencial",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace bilateral ∫_{-∞}^∞ f(t) e^{-st} dt a cada termo da EDO.",
                                    "Transforme derivadas: ℒ{y^{(n)}(t)} = s^n Y(s) - s^{n-1} y(0^-) - ... - y^{(n-1)}(0^-).",
                                    "Faça o mesmo para termos de x(t): ℒ{x^{(m)}(t)} = s^m X(s) - termos iniciais.",
                                    "Substitua na equação inteira, movendo todos os termos para um lado.",
                                    "Simplifique expressões algébricas iniciais, mantendo Y(s) e X(s)."
                                  ],
                                  "verification": "Todos os termos estão transformados corretamente, com propriedades de derivada aplicadas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de transformadas de Laplace, calculadora simbólica (opcional como Wolfram Alpha para verificação).",
                                  "tips": "Lembre-se da bilateral: integra de -∞ a ∞, mas para causais é similar à unilateral com t>0.",
                                  "learningObjective": "Dominar a aplicação da transformada de Laplace a EDOs lineares.",
                                  "commonMistakes": "Esquecer fatores s nas derivadas; usar transformada unilateral sem ajustar limites; inverter sinais nos termos iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar condições iniciais zero e simplificar no domínio s",
                                  "subSteps": [
                                    "Substitua todas as condições iniciais y^{(k)}(0^-) = 0 e x^{(k)}(0^-) = 0 para eliminar termos iniciais.",
                                    "Colete termos com Y(s) de um lado e X(s) do outro da equação.",
                                    "Fatore Y(s) e X(s) adequadamente: P(s) Y(s) = Q(s) X(s), onde P e Q são polinômios.",
                                    "Verifique se a equação está balanceada e simplificada (divida por coeficiente líder se necessário).",
                                    "Reduza frações comuns ou simplifique polinômios."
                                  ],
                                  "verification": "Equação simplificada sem termos iniciais residuais, pronta para isolar H(s).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado para polinômios, software como MATLAB/SymPy para expansão de polinômios.",
                                  "tips": "Confirme zero ICs explicitamente para cada derivada até a ordem da EDO.",
                                  "learningObjective": "Simplificar corretamente a EDO transformada assumindo repouso inicial.",
                                  "commonMistakes": "Deixar termos iniciais não-zero; erros aritméticos em expansão de (s^n + ...); não fatorar corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e expressar a função de transferência H(s) = Y(s)/X(s)",
                                  "subSteps": [
                                    "Isolar H(s) = Y(s)/X(s) = Q(s) / P(s) da equação P(s) Y(s) = Q(s) X(s).",
                                    "Escreva H(s) como fração racional própria (grau numerador < grau denominador para sistemas próprios).",
                                    "Identifique polos (raízes de P(s)=0) e zeros (raízes de Q(s)=0) opcionalmente.",
                                    "Verifique ganho em DC (s=0) ou frequência infinita se aplicável.",
                                    "Formate H(s) em notação padrão, como H(s) = (b_m s^m + ... ) / (a_n s^n + ... )."
                                  ],
                                  "verification": "H(s) é uma fração racional correta, com Y(s) = H(s) X(s) reproduzindo a equação original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora gráfica para raízes polinomiais, template de relatório para anotar H(s).",
                                  "tips": "Sempre normalize dividindo por a_n para monico denominador.",
                                  "learningObjective": "Extrair e interpretar a função de transferência de forma precisa.",
                                  "commonMistakes": "Inverter numerador e denominador; não reduzir fração; ignorar grau para impropriedade."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor: m ÿ + b ẏ + k y = x(t), com m=1, b=2, k=1, ICs zero. Aplicando Laplace: (s^2 + 2s + 1) Y(s) = X(s), logo H(s) = 1/(s^2 + 2s + 1) = 1/(s+1)^2.",
                              "finalVerifications": [
                                "H(s) é fração racional com grau(denom) >= grau(num).",
                                "Substituindo de volta, obtém-se a EDO original com ICs zero.",
                                "Pólos e zeros coincidem com análise característica esperada.",
                                "Resposta em frequência em s=jω é consistente com simulação.",
                                "Ganho estático H(0) matches steady-state.",
                                "Nenhuma simplificação algébrica pendente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de propriedades de Laplace (100%).",
                                "Correção na manipulação algébrica e simplificação (90%).",
                                "Identificação correta de entrada/saída e ICs (100%).",
                                "Expressão final de H(s) em forma padrão e própria.",
                                "Verificação reversa: Laplace inversa qualitativa.",
                                "Eficiência nos passos (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e raízes (álgebra avançada).",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Controle Automático: Análise de estabilidade via pólos.",
                                "Programação: Implementação em MATLAB/Simulink para simulação.",
                                "Engenharia de Sinais: Extensão a sistemas discretos via Z-transform."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, obter H(s) para o modelo longitudinal de uma aeronave permite projetar controladores de atitude (pitch/roll), analisar estabilidade de voo e simular respostas a perturbações como rajadas de vento, essencial para certificação FAA/EASA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Calcular resposta via inversa de Laplace",
                            "description": "Usar frações parciais em Y(s) = H(s) X(s) e tabelas de Laplace para encontrar y(t), separando transitório e permanente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a Transformada de Laplace da Saída Y(s)",
                                  "subSteps": [
                                    "Identifique a função de transferência H(s) do sistema e a entrada X(s).",
                                    "Multiplique H(s) por X(s) para obter Y(s), expandindo numeradores e denominadores se necessário.",
                                    "Simplifique Y(s) cancelando fatores comuns e reduzindo frações racionais.",
                                    "Verifique o grau do numerador (menor que denominador para sistemas próprios).",
                                    "Escreva Y(s) na forma racional padrão: Y(s) = N(s)/D(s)."
                                  ],
                                  "verification": "Y(s) está corretamente multiplicada e simplificada, sem erros algébricos evidentes.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela de funções de transferência comuns",
                                    "Papel quadriculado",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre verifique os pólos do denominador para estabilidade inicial.",
                                  "learningObjective": "Dominar a multiplicação de funções racionais no domínio de Laplace.",
                                  "commonMistakes": [
                                    "Esquecer de expandir polinômios antes de multiplicar",
                                    "Cancelar termos incorretamente levando a pólos espúrios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor Y(s) em Frações Parciais",
                                  "subSteps": [
                                    "Fatore o denominador D(s) para encontrar os pólos (raízes).",
                                    "Assuma a forma de decomposição: soma de termos A/(s-p) para pólos simples, ou formas parciais para repetidos.",
                                    "Multiplique ambos os lados por D(s) para obter N(s) = soma de resíduos.",
                                    "Resolva o sistema de equações para os coeficientes (resíduos) usando substituição ou método dos resíduos.",
                                    "Verifique recombinando as frações para recuperar Y(s) original."
                                  ],
                                  "verification": "A soma das frações parciais equals Y(s) multiplicada pelo denominador.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Tabela de fatoração polinomial",
                                    "Software simbólico opcional como SymPy",
                                    "Folha de exercícios de resíduos"
                                  ],
                                  "tips": "Para pólos complexos conjugados, use coeficientes complexos ou forma real diretamente.",
                                  "learningObjective": "Executar decomposição em frações parciais com precisão para funções racionais próprias.",
                                  "commonMistakes": [
                                    "Assumir forma errada para pólos múltiplos",
                                    "Erros de sinal ao resolver coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Transformada Inversa de Laplace",
                                  "subSteps": [
                                    "Consulte a tabela de transformadas de Laplace para cada termo da decomposição.",
                                    "Escreva a inversa para cada fração: L^{-1}{A/(s+a)} = A e^{-at}, etc.",
                                    "Some as inversas para obter y(t) total.",
                                    "Inclua a função unitária Heaviside u(t) se aplicável.",
                                    "Expresse y(t) em forma fechada, simplificando exponenciais e senos/cossenos."
                                  ],
                                  "verification": "Cada termo inverso corresponde corretamente à tabela padrão.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela completa de transformadas de Laplace (unilateral)",
                                    "Calculadora para coeficientes numéricos"
                                  ],
                                  "tips": "Memorize as 10 transformadas mais comuns para agilizar.",
                                  "learningObjective": "Mapear com fluência frações parciais para funções no tempo via tabelas.",
                                  "commonMistakes": [
                                    "Confundir transformadas bilaterais com unilaterais",
                                    "Esquecer fatores de escala em senos/cossenos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Separar Componentes Transitório e Permanente",
                                  "subSteps": [
                                    "Identifique termos transitórios: exponenciais decaindo (Re(polo) < 0).",
                                    "Identifique resposta permanente: termos constantes, rampas ou sinusoidais puros (pólos em jω ou zero).",
                                    "Escreva y(t) = y_transient(t) + y_permanent(t).",
                                    "Verifique limites: lim t->0 y(t) e lim t->inf y(t).",
                                    "Plote ou descreva o comportamento qualitativo."
                                  ],
                                  "verification": "Transitórios tendem a zero, permanentes matcham steady-state esperado.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Gráfico assintótico de Bode opcional",
                                    "Software de plotagem como MATLAB"
                                  ],
                                  "tips": "Use teorema do valor final para validar y_permanent(inf).",
                                  "learningObjective": "Distinguir dinâmicas de curto e longo prazo em respostas de sistemas.",
                                  "commonMistakes": [
                                    "Classificar pólos marginais como transitórios",
                                    "Ignorar oscilações sustentadas como permanentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado H(s) = 1/(s+2), X(s) = 1/s (degrau unitário). Y(s) = 1/[s(s+2)]. Decompor: 1/[s(s+2)] = A/s + B/(s+2) → A=1/2, B=-1/2. y(t) = (1/2) - (1/2)e^{-2t}. Transitório: -(1/2)e^{-2t}, Permanente: 1/2.",
                              "finalVerifications": [
                                "Resolver Y(s) = 1/[(s+1)(s+2)] para X(s)=1/s corretamente.",
                                "Decompor e inverter Y(s) com pólos complexos, como 1/(s^2 + 2s + 5).",
                                "Separar corretamente transitório/permanente em 2 problemas variados.",
                                "Verificar y(inf) usando teorema do valor final.",
                                "Explicar qualitativamente o comportamento de y(t).",
                                "Simular numéricamente em software e comparar com analítico."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na multiplicação e simplificação de Y(s) (20%)",
                                "Correção na decomposição de frações parciais (30%)",
                                "Uso correto da tabela de Laplace sem erros de mapeamento (25%)",
                                "Identificação precisa de componentes transitório e permanente (15%)",
                                "Verificações de consistência (limites, recombinação) (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para resolução de sistemas de resíduos.",
                                "Física: Dinâmica de sistemas massa-mola para analogia com pólos.",
                                "Programação: Implementar inversa numérica em Python/MATLAB.",
                                "Controle Automático: Análise de estabilidade via pólos.",
                                "Engenharia de Software: Validação de modelos simulados."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular a resposta de um estabilizador de voo a uma entrada de degrau (como mudança de trim), separando oscilações transitórias (phugoid/short-period) da velocidade de cruzeiro permanente para otimizar controle de atitude."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Analisar regime permanente",
                            "description": "Identificar o regime permanente usando teorema do valor final ou análise assintótica para entradas como degrau unitário, determinando ganho estático e erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de regime permanente",
                                  "subSteps": [
                                    "Defina regime permanente como o comportamento assintótico da resposta do sistema para t → ∞.",
                                    "Identifique entradas comuns como degrau unitário R(s) = 1/s.",
                                    "Revise função de transferência G(s) e sua relação com a resposta Y(s) = G(s)R(s).",
                                    "Explique ganho estático Kp = lim_{s→0} G(s).",
                                    "Diferencie regime permanente de transitório."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e forneça um diagrama simples de entrada-saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre funções de transferência",
                                    "Tabela de transformadas de Laplace",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar a relação entrada-saída.",
                                  "learningObjective": "O aluno compreenderá o que é regime permanente e entradas padrão como degrau unitário.",
                                  "commonMistakes": [
                                    "Confundir regime permanente com valor inicial",
                                    "Ignorar o domínio da frequência zero para assíntota"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Teorema do Valor Final",
                                  "subSteps": [
                                    "Enuncie o teorema: lim_{t→∞} y(t) = lim_{s→0} s Y(s), se o limite existir.",
                                    "Para degrau unitário, simplifique para lim_{s→0} G(s).",
                                    "Verifique condições de aplicabilidade (polos no semiplano esquerdo).",
                                    "Calcule para um exemplo simples G(s) = 1/(s+1).",
                                    "Compare com simulação numérica básica."
                                  ],
                                  "verification": "Aplique o teorema a G(s) = 5/(s+2) e confirme y(∞) = 2.5.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB/Simulink",
                                    "Folha de exercícios com teoremas"
                                  ],
                                  "tips": "Sempre verifique se lim_{s→0} sY(s) existe antes de aplicar.",
                                  "learningObjective": "O aluno aplicará corretamente o Teorema do Valor Final para prever regime permanente.",
                                  "commonMistakes": [
                                    "Esquecer o fator s em sY(s)",
                                    "Aplicar sem verificar estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar ganho estático",
                                  "subSteps": [
                                    "Defina ganho estático Kp = G(0) para sistemas próprios.",
                                    "Calcule G(0) substituindo s=0 na função de transferência.",
                                    "Para degrau unitário, y(∞) = Kp.",
                                    "Classifique sistemas tipo 0, 1, 2 pelo número de integradores.",
                                    "Exemplo: G(s) = K / (s^2 + 2s + 1), Kp = K."
                                  ],
                                  "verification": "Calcule Kp para G(s) = 10 / (s(s+1)(s+5)) e explique o resultado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Funções de transferência de exemplos aeronáuticos",
                                    "Software de cálculo simbólico"
                                  ],
                                  "tips": "Fatore G(s) para identificar integradores (polos em s=0).",
                                  "learningObjective": "O aluno calculará o ganho estático e o associará ao regime permanente para degrau.",
                                  "commonMistakes": [
                                    "Calcular G(∞) em vez de G(0)",
                                    "Não simplificar frações antes de s=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar análise assintótica",
                                  "subSteps": [
                                    "Descreva análise assintótica: comportamento em ω→0 (baixo frequência) e ω→∞ (alta).",
                                    "Para regime permanente, foque em ω→0: ganho |G(jω)| → Kp.",
                                    "Compare com Teorema do Valor Final.",
                                    "Plote diagrama de Bode aproximado para baixa frequência.",
                                    "Exemplo: Asintota DC de G(s)."
                                  ],
                                  "verification": "Desenhe asintotas de Bode para G(s) = 1/(s+1) e identifique ganho DC.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de Bode (MATLAB)",
                                    "Exemplos de diagramas Bode"
                                  ],
                                  "tips": "Comece sempre pela reta horizontal em baixa frequência.",
                                  "learningObjective": "O aluno usará análise assintótica para confirmar regime permanente.",
                                  "commonMistakes": [
                                    "Confundir fase com magnitude",
                                    "Ignorar slope de -20dB/dec por polo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular erros em regime permanente",
                                  "subSteps": [
                                    "Defina erro e = r(t) - y(t), E(s) = R(s)/(1+G(s)).",
                                    "Para tipo 0: e∞ = 1/(1+Kp); tipo 1: e∞=0 para degrau; tipo 2: para rampa.",
                                    "Calcule para degrau unitário em diferentes tipos.",
                                    "Exemplo: Sistema tipo 0 com Kp=4, e∞=0.2.",
                                    "Discuta implicações para controle."
                                  ],
                                  "verification": "Para G(s)=10/s(s+1), tipo 1, confirme e∞=0 para degrau.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de erros por tipo de sistema",
                                    "Exercícios resolvidos"
                                  ],
                                  "tips": "Memorize: erro zero para entradas de ordem ≤ tipo do sistema.",
                                  "learningObjective": "O aluno determinará erros em regime permanente baseados no tipo do sistema.",
                                  "commonMistakes": [
                                    "Calcular erro sem considerar tipo",
                                    "Usar fórmula errada para degrau em tipo 1"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave com G(s) = 20 / (s(s+5)), aplique degrau unitário no elevator. Use Teorema do Valor Final para y(∞)=4 (ganho estático=4), confirme com análise assintótica (asintota DC=12dB) e erro e∞=0 (tipo 1).",
                              "finalVerifications": [
                                "Calcule corretamente y(∞) para 3 funções de transferência dadas usando ambos métodos.",
                                "Identifique tipo do sistema e erro para degrau unitário.",
                                "Plote resposta temporal simulada e destaque regime permanente.",
                                "Explique diferenças entre teorema e assintótica.",
                                "Resolva problema completo de aeronáutica sem erros.",
                                "Compare resultados com simulação em software."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos limites e cálculos (90% correto).",
                                "Correta identificação de ganho estático e tipo de sistema.",
                                "Uso integrado de teorema e análise assintótica.",
                                "Explicação clara de erros em regime permanente.",
                                "Aplicação contextual a exemplos reais de engenharia.",
                                "Qualidade de diagramas e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites, transformadas de Laplace e análise assintótica.",
                                "Engenharia de Controle: Projeto de compensadores para reduzir erros.",
                                "Física: Dinâmica de veículos aéreos e estabilidade.",
                                "Programação: Simulações em MATLAB/Simulink para validação.",
                                "Estatística: Análise de ruído em regime permanente."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, analisar o regime permanente garante que comandos de piloto (degrau no elevator) levem a ângulos de ataque estáveis sem erro persistente, essencial para autopilot e estabilidade de voo em cruzeiro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Comparar métodos de solução",
                            "description": "Comparar soluções obtidas por métodos diretos, convolução e Laplace, validando consistência para um modelo linear específico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo linear específico e revisar os métodos",
                                  "subSteps": [
                                    "Selecione um modelo linear contínuo simples, como a EDO y'' + a y' + b y = u(t), com condições iniciais zero.",
                                    "Revise as fórmulas chave: solução direta via integração, convolução y(t) = ∫ h(τ) u(t-τ) dτ, e Laplace Y(s) = H(s) U(s).",
                                    "Defina o sinal de entrada u(t), ex: degrau unitário, e calcule a função impulso h(t) ou H(s).",
                                    "Anote todas as premissas: sistema LTI causal, tempo contínuo.",
                                    "Crie uma tabela para registrar soluções de cada método."
                                  ],
                                  "verification": "Confirme que o modelo está definido com EDO, entrada, condições iniciais e funções de transferência anotadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, tabela de transformadas de Laplace.",
                                  "tips": "Escolha coeficientes simples (a=2, b=1) para facilitar cálculos manuais.",
                                  "learningObjective": "Entender e preparar os componentes necessários para comparação de métodos.",
                                  "commonMistakes": "Esquecer condições iniciais zero ou assumir sistema não causal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver usando método direto (integração da EDO)",
                                  "subSteps": [
                                    "Escreva a EDO no formato padrão e aplique método de variação de parâmetros ou coeficientes indeterminados.",
                                    "Integre passo a passo para encontrar a solução homogênea e particular.",
                                    "Aplique condições iniciais para determinar constantes.",
                                    "Simplifique a expressão analítica de y(t).",
                                    "Plote ou tabule valores numéricos em pontos chave (t=0,1,5)."
                                  ],
                                  "verification": "Verifique se y(0)=0, y'(0)=0 e se satisfaz a EDO substituindo valores.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel, lápis, tabela de integrais indefinidas.",
                                  "tips": "Use fator integrante para EDO de primeira ordem após redução.",
                                  "learningObjective": "Dominar solução analítica direta de EDOs lineares.",
                                  "commonMistakes": "Erro em integração por partes ou aplicação incorreta de condições iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver usando convolução e Transformada de Laplace",
                                  "subSteps": [
                                    "Calcule H(s) = 1/(s² + a s + b), encontre h(t) via inversa de Laplace.",
                                    "Compute y(t) por convolução: ∫_0^t h(τ) u(t-τ) dτ.",
                                    "Alternativamente, Y(s) = H(s) U(s), inverta para y(t).",
                                    "Compare numericamente os integrandos em pontos selecionados.",
                                    "Simplifique e verifique identidade com solução direta esperada."
                                  ],
                                  "verification": "Confirme que a convolução converge e matches fórmula conhecida para degrau.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela de Laplace, software como MATLAB para inversa (opcional).",
                                  "tips": "Para degrau, convolução simplifica para ∫_0^t h(τ) dτ.",
                                  "learningObjective": "Aplicar transformadas e convolução para soluções em domínio do tempo.",
                                  "commonMistakes": "Limites errados na integral de convolução (sempre 0 a t para causal)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções e validar consistência",
                                  "subSteps": [
                                    "Alinhe expressões analíticas das três soluções e prove igualdade.",
                                    "Calcule valores numéricos em t=0,1,2,∞ para cada método.",
                                    "Analise erros relativos e grafique y(t) vs t.",
                                    "Discuta vantagens/desvantagens: direto (exato mas tedioso), convolução (intuitiva), Laplace (fácil para entrada complexa).",
                                    "Conclua sobre consistência e robustez numérica."
                                  ],
                                  "verification": "Erros relativos <1% em todos pontos e soluções idênticas analiticamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou MATLAB para plot e tabela comparativa.",
                                  "tips": "Use sympy ou Wolfram Alpha para verificação rápida.",
                                  "learningObjective": "Avaliar e validar equivalência de métodos analíticos.",
                                  "commonMistakes": "Ignorar termos transitórios ou comparar soluções em regime permanente só."
                                }
                              ],
                              "practicalExample": "Para o modelo de controle de atitude em aeronave: y'' + 1.4 y' + 1 y = u(t) (degrau unitário em t=0, y(0)=y'(0)=0). Solução direta: y(t)=1-e^{-0.7t}(cos(0.7t)+sin(0.7t)); valide via Laplace H(s)=1/(s²+1.4s+1), U(s)=1/s; convolução com h(t)=e^{-0.7t} sin(0.7t).",
                              "finalVerifications": [
                                "Soluções analíticas são idênticas para todos métodos.",
                                "Valores numéricos coincidem com erro <0.1% em 5 pontos.",
                                "Gráficos sobrepostos sem discrepâncias.",
                                "Vantagens de cada método justificadas corretamente.",
                                "Validação da EDO satisfeita por soluções.",
                                "Condições iniciais preservadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das soluções derivadas (100% match analítico).",
                                "Qualidade dos cálculos numéricos e gráficos.",
                                "Profundidade da comparação (vantagens, limitações).",
                                "Correção na aplicação de teoremas (convolução, Laplace).",
                                "Clareza na documentação e tabela comparativa.",
                                "Identificação de erros potenciais e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de EDOs e transformadas integrais.",
                                "Física: Dinâmica de sistemas massa-mola para modelagem aerodinâmica.",
                                "Programação: Implementação numérica em Python/MATLAB para simulação.",
                                "Engenharia de Controle: Validação de funções de transferência em aeronaves."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, comparar métodos valida simulações de resposta transitória em sistemas de controle de voo, como estabilização de atitude após perturbação, garantindo precisão em software de certificação FAA antes de testes em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Função de Resposta em Frequência",
                    "description": "H(jω) derivada da função de transferência e suas propriedades para análise em frequência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Definição e Derivação da Função de Resposta em Frequência",
                        "description": "Compreensão da função H(jω) como a transformada de Laplace da função de transferência H(s) avaliada em s = jω, e sua relação com a resposta do sistema a entradas sinusoidais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Derivar H(jω) a partir de H(s)",
                            "description": "Dado uma função de transferência H(s) racional, substituir s por jω para obter H(jω), simplificando expressões complexas e identificando partes real e imaginária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar a função de transferência H(s)",
                                  "subSteps": [
                                    "Identifique o numerador e denominador de H(s), garantindo que esteja na forma racional padrão P(s)/Q(s).",
                                    "Expresse os coeficientes polinomiais claramente, separando termos reais.",
                                    "Verifique se H(s) é própria (grau numerador ≤ grau denominador) ou realize divisão polinomial se necessário.",
                                    "Anote o domínio de estabilidade ou polos zeros iniciais para contexto.",
                                    "Escreva H(s) em formato simbólico usando ferramentas como MATLAB ou papel."
                                  ],
                                  "verification": "H(s) está escrita corretamente com todos coeficientes e pode ser avaliada em pontos reais simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica ou software simbólico (ex: SymPy, MATLAB)"
                                  ],
                                  "tips": "Sempre normalize H(s) dividindo por coeficiente líder do denominador para facilitar cálculos.",
                                  "learningObjective": "Compreender a estrutura algébrica de H(s) para substituição posterior.",
                                  "commonMistakes": [
                                    "Esquecer fatores constantes",
                                    "Confundir numerador com denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a substituição s = jω",
                                  "subSteps": [
                                    "Substitua s por jω em cada termo do numerador e denominador.",
                                    "Expanda potências: (jω)^n usando propriedades de j (j^1 = j, j^2 = -1, j^3 = -j, j^4 = 1).",
                                    "Agrupe termos reais e imaginários em numerador e denominador separadamente.",
                                    "Escreva H(jω) = [Num(jω)] / [Den(jω)], com Num e Den complexos.",
                                    "Teste com ω pequeno para validar expansão inicial."
                                  ],
                                  "verification": "Expressão H(jω) é obtida corretamente sem erros em potências de j.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de fórmulas de potências de j",
                                    "Software para expansão simbólica opcional"
                                  ],
                                  "tips": "Use tabela cíclica de potências de j para agilizar: memorize o ciclo 1, j, -1, -j.",
                                  "learningObjective": "Dominar a transformação analítica de Laplace para Fourier via substituição.",
                                  "commonMistakes": [
                                    "Erro no ciclo de j (ex: j^3 = j ao invés de -j)",
                                    "Não expandir todos os termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simplificar a expressão complexa H(jω)",
                                  "subSteps": [
                                    "Multiplique numerador e denominador pelo conjugado do denominador para racionalizar.",
                                    "Expanda o produto: |Den(jω)|^2 no denominador (sempre real e positivo).",
                                    "Simplifique frações comuns e cancele fatores idênticos.",
                                    "Colete termos semelhantes no numerador resultante.",
                                    "Verifique simplificação comparando com forma expandida inicial."
                                  ],
                                  "verification": "Denominador é real e numerador está na forma A(ω) + jB(ω), com simplificações aplicadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para multiplicações complexas",
                                    "SymPy ou Mathematica para verificação"
                                  ],
                                  "tips": "Racionalize sempre primeiro; evite expansão prematura para reduzir erros aritméticos.",
                                  "learningObjective": "Aplicar álgebra complexa para obter forma cartesiana simplificada.",
                                  "commonMistakes": [
                                    "Erro no conjugado (usar j ao invés de -j)",
                                    "Não cancelar fatores comuns"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar partes real e imaginária e validar",
                                  "subSteps": [
                                    "Extraia Re{H(jω)} = A(ω) / |Den|^2 e Im{H(jω)} = B(ω) / |Den|^2 do numerador racionalizado.",
                                    "Escreva explicitamente H(jω) = Re + j Im.",
                                    "Calcule magnitude |H(jω)| = sqrt(Re^2 + Im^2) e fase arg(H(jω)) = atan2(Im, Re) para verificação.",
                                    "Plote ou tabule valores para ω = 0, 1, ∞ para checar limites conhecidos.",
                                    "Compare com software para confirmação numérica."
                                  ],
                                  "verification": "Partes real e imaginária estão isoladas corretamente e limites batem (ex: H(j0) = H(0)).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de papel ou MATLAB para plot",
                                    "Tabela de valores de teste"
                                  ],
                                  "tips": "Sempre verifique H(j0) = H(s=0) e |H(j∞)| para sistemas próprios.",
                                  "learningObjective": "Interpretar H(jω) em componentes para análise de frequência.",
                                  "commonMistakes": [
                                    "Inverter real e imaginária",
                                    "Esquecer normalização pelo |Den|^2"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = 1 / (s + 1), substitua s = jω: H(jω) = 1 / (jω + 1). Racionalize multiplicando por (1 - jω): H(jω) = (1 - jω) / (1 + ω²) = 1/(1+ω²) - j ω/(1+ω²). Re = 1/(1+ω²), Im = -ω/(1+ω²).",
                              "finalVerifications": [
                                "Derivação manual coincide com resultado simbólico em software.",
                                "Partes real e imaginária são funções reais de ω apenas.",
                                "Limites: H(j0) correto, |H(j∞)| = 0 para sistema próprio.",
                                "Magnitude e fase calculadas consistentemente.",
                                "Sem erros aritméticos em coeficientes.",
                                "Expressão simplificada sem termos canceláveis restantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na substituição s → jω (100% correto).",
                                "Racionalização e simplificação sem erros algébricos.",
                                "Separação clara de Re e Im.",
                                "Verificação de limites e consistência.",
                                "Eficiência: passos lógicos sem redundâncias.",
                                "Interpretação física básica (ex: filtro passa-baixa)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e números imaginários (cálculo de engenharia).",
                                "Física: Análise de circuitos AC e resposta em frequência.",
                                "Controle de Sistemas: Projeto de controladores via Bode plots.",
                                "Processamento de Sinais: Transformada de Fourier contínua."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, deriva H(jω) de modelos de aeronaves para analisar estabilidade em frequência, projetar filtros de controle de voo e simular respostas a perturbações sinusoidais como turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Relacionar resposta ao impulso com FRF",
                            "description": "Explicar como a resposta em frequência H(jω) é a transformada de Fourier da resposta ao impulso h(t), e calcular h(t) via inversa de Fourier de H(jω).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Resposta ao Impulso e Transformada de Fourier",
                                  "subSteps": [
                                    "Defina resposta ao impulso h(t) como a saída de um sistema LTI para entrada δ(t).",
                                    "Explique propriedades da transformada de Fourier: X(jω) = ∫ x(t) e^{-jωt} dt de -∞ a ∞.",
                                    "Discuta a transformada inversa: x(t) = (1/(2π)) ∫ X(jω) e^{jωt} dω de -∞ a ∞.",
                                    "Identifique que para sistemas LTI, a saída y(t) = h(t) * x(t), e em frequência Y(jω) = H(jω) X(jω).",
                                    "Verifique simetria para sinais reais: H(-jω) = H*(jω)."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e propriedades, confirmando com equações escritas à mão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), caderno, calculadora científica"
                                  ],
                                  "tips": "Use tabelas de transformadas de Fourier comuns para referência rápida.",
                                  "learningObjective": "Compreender as bases teóricas necessárias para a relação entre h(t) e H(jω).",
                                  "commonMistakes": "Confundir transformada direta com inversa; esquecer limites de integração infinitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação entre Resposta ao Impulso h(t) e FRF H(jω)",
                                  "subSteps": [
                                    "Considere entrada δ(t), cuja transformada é 1 (Δ(jω) = 1).",
                                    "Aplique a propriedade de convolução: Y(jω) = H(jω) Δ(jω) = H(jω).",
                                    "No domínio do tempo, y(t) = h(t) = ∫ h(τ) δ(t-τ) dτ, levando a H(jω) = Fourier{h(t)}.",
                                    "Escreva explicitamente H(jω) = ∫_{-∞}^∞ h(t) e^{-jωt} dt.",
                                    "Discuta condições de convergência (h(t) absolutamente integrável)."
                                  ],
                                  "verification": "Derive a fórmula H(jω) = Fourier{h(t)} passo a passo e compare com referência padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como MATLAB Symbolic ou Wolfram Alpha, papel quadriculado"
                                  ],
                                  "tips": "Desenhe gráficos de h(t) e H(jω) para visualizar a relação.",
                                  "learningObjective": "Derivar matematicamente que H(jω) é a transformada de Fourier de h(t).",
                                  "commonMistakes": "Ignorar o fator de escala na inversa; assumir causalidade sem justificar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular H(jω) a partir de h(t) Usando Transformada Direta",
                                  "subSteps": [
                                    "Escolha um exemplo simples: h(t) = e^{-at} u(t), a > 0.",
                                    "Calcule ∫_0^∞ e^{-at} e^{-jωt} dt = 1/(a + jω).",
                                    "Generalize para sistemas de ordem superior usando tabelas ou propriedades.",
                                    "Plote magnitude e fase de |H(jω)| e arg{H(jω)}.",
                                    "Verifique simetria e propriedades de sistemas reais."
                                  ],
                                  "verification": "Compute H(jω) para h(t) dado e valide numericamente com FFT em software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (numpy.fft), exemplos de livro-texto"
                                  ],
                                  "tips": "Use integração por partes para exponenciais complexas.",
                                  "learningObjective": "Aplicar transformada de Fourier para obter FRF de h(t).",
                                  "commonMistakes": "Erros em limites de integração para sinais causais; confundir jω com s."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular h(t) a partir de H(jω) Usando Transformada Inversa",
                                  "subSteps": [
                                    "Para H(jω) = 1/(a + jω), aplique inversa: h(t) = (1/(2π)) ∫_{-∞}^∞ [1/(a + jω)] e^{jωt} dω.",
                                    "Use resíduos ou tabelas: resulta em e^{-at} u(t).",
                                    "Implemente numericamente com IFFT para validação.",
                                    "Discuta pares comuns: retardos, escalas, convoluções.",
                                    "Verifique consistência comparando forward e inverse."
                                  ],
                                  "verification": "Obtenha h(t) de H(jω) e confirme que Fourier{h(t)} retorna H(jω) original.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (ifft), tabela de transformadas inversas"
                                  ],
                                  "tips": "Para contorno fechado, escolha semicírculo superior para t>0.",
                                  "learningObjective": "Realizar cálculo inverso para recuperar h(t) de H(jω).",
                                  "commonMistakes": "Fator 1/(2π) esquecido; erros em contorno de integração."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Verificar a Relação em Contextos Práticos",
                                  "subSteps": [
                                    "Analise um sistema aeronáutico simples, como filtro passa-baixa em controle de flaps.",
                                    "Compare análises no tempo e frequência.",
                                    "Discuta limitações: não-estacionariedade, ruído.",
                                    "Resolva problema: dada H(jω), encontre h(t) e responda a senoide.",
                                    "Documente insights em relatório curto."
                                  ],
                                  "verification": "Resolva exercício completo e discuta com colega ou tutor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulador como Simulink, artigos sobre análise vibracional aeronáutica"
                                  ],
                                  "tips": "Sempre normalize FFT para comparações precisas.",
                                  "learningObjective": "Aplicar a relação em cenários reais de engenharia.",
                                  "commonMistakes": "Aplicar FFT sem windowing adequada; ignorar unwrap de fase."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de aeronave com h(t) = 2 e^{-3t} u(t), calcule H(jω) = 2/(3 + jω). Em seguida, dada H(jω) = 1/(1 + jω), derive h(t) = e^{-t} u(t) via inversa e verifique com simulação em MATLAB.",
                              "finalVerifications": [
                                "Deriva corretamente H(jω) = Fourier{h(t)} sem erros.",
                                "Calcula transformada direta para pelo menos dois exemplos.",
                                "Executa inversa analítica e numérica com precisão.",
                                "Explica verbalmente a relação em 2 minutos.",
                                "Valida numericamente forward-inverse pair com erro <1%.",
                                "Identifica e corrige erros comuns em cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (80% peso).",
                                "Correção nos cálculos numéricos e simbólicos.",
                                "Profundidade na explicação conceitual.",
                                "Criatividade em exemplos e aplicações.",
                                "Qualidade de gráficos e visualizações.",
                                "Capacidade de troubleshooting em verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e integrais de contorno.",
                                "Física: Dinâmica de sistemas vibracionais em aeronaves.",
                                "Computação: Implementação de FFT/IFFT em Python/MATLAB.",
                                "Engenharia de Controle: Projeto de filtros baseados em FRF.",
                                "Processamento de Sinais: Análise espectral de dados de voo."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, essa relação é usada para modelar respostas de sistemas de controle de voo a excitações (ex: turbulência), permitindo análise de estabilidade via FRF obtida experimentalmente e simulação de h(t) para predição de oscilações em asas ou fuselagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Calcular resposta a senóide estacionária",
                            "description": "Determinar a resposta y(t) de um sistema LTI a uma entrada u(t) = A cos(ωt + φ) usando H(jω), calculando magnitude |H(jω)| e fase ∠H(jω).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter a Função de Transferência H(s) do Sistema LTI",
                                  "subSteps": [
                                    "Identifique o diagrama de blocos ou equação diferencial do sistema LTI.",
                                    "Aplique a transformada de Laplace para derivar H(s) = Y(s)/U(s).",
                                    "Simplifique H(s) em forma racional (polinômio no numerador e denominador).",
                                    "Verifique se H(s) está na forma padrão para análise em frequência.",
                                    "Anote os parâmetros conhecidos: A, ω, φ da entrada u(t)."
                                  ],
                                  "verification": "Confirme que H(s) é uma função racional estável e corresponde ao sistema dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de blocos do sistema",
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora simbólica (ex: MATLAB ou papel e caneta)"
                                  ],
                                  "tips": "Sempre normalize H(s) dividindo por coeficiente líder do denominador para facilitar cálculos.",
                                  "learningObjective": "Compreender como extrair H(s) de descrições de sistemas LTI.",
                                  "commonMistakes": [
                                    "Esquecer condições iniciais zero para estacionariedade",
                                    "Confundir H(s) com equação diferencial diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar H(jω) na Frequência Específica",
                                  "subSteps": [
                                    "Substitua s = jω em H(s) para obter H(jω).",
                                    "Expresse H(jω) na forma retangular: H(jω) = Re + j Im.",
                                    "Calcule os componentes real e imaginário expandindo polinômios.",
                                    "Use identidades trigonométricas se H(s) estiver em forma polar inicialmente.",
                                    "Registre valores numéricos exatos ou simbólicos."
                                  ],
                                  "verification": "H(jω) deve ser um número complexo válido (ex: 0.5 - j0.2).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função H(s) do passo anterior",
                                    "Calculadora científica",
                                    "Folha de fórmulas complexas"
                                  ],
                                  "tips": "Use j² = -1 consistentemente; teste com ω=0 para ganho DC.",
                                  "learningObjective": "Dominar substituição s=jω e manipulação de números complexos.",
                                  "commonMistakes": [
                                    "Erro em potências de j (j^4=1)",
                                    "Substituir ω por jω incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Magnitude e Fase de H(jω)",
                                  "subSteps": [
                                    "Calcule magnitude |H(jω)| = sqrt(Re² + Im²).",
                                    "Calcule fase ∠H(jω) = atan2(Im, Re) em graus ou radianos.",
                                    "Expresse |H(jω)| em dB se necessário: 20 log10(|H|).",
                                    "Verifique continuidade da fase (ajuste ±360° se saltos).",
                                    "Anote |H(jω)| e ∠H(jω) claramente."
                                  ],
                                  "verification": "Magnitude positiva real; fase entre -180° e 180° tipicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "H(jω) complexo",
                                    "Função atan2 em calculadora",
                                    "Tabela de valores trigonométricos"
                                  ],
                                  "tips": "Use atan2 para quadrantes corretos; magnitude nunca é negativa.",
                                  "learningObjective": "Aplicar fórmulas de magnitude e fase em números complexos.",
                                  "commonMistakes": [
                                    "Usar atan em vez de atan2 (erros de quadrante)",
                                    "Esquecer raiz quadrada na magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a Resposta Estacionária y(t)",
                                  "subSteps": [
                                    "Forme y(t) = A |H(jω)| cos(ωt + φ + ∠H(jω)).",
                                    "Expanda usando identidade cos(a+b) = cos a cos b - sin a sin b se necessário.",
                                    "Compare com forma original u(t) para identificar ganho e deslocamento.",
                                    "Verifique dimensionalidade e unidades.",
                                    "Plote ou esboce y(t) vs u(t) para visualização."
                                  ],
                                  "verification": "y(t) deve ter mesma frequência ω, mas amplitude e fase alteradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Valores de |H| e ∠H",
                                    "Gráfica de seno/cosseno",
                                    "Software de plotagem (opcional)"
                                  ],
                                  "tips": "Mantenha fase em radianos para cálculos trigonométricos.",
                                  "learningObjective": "Sintetizar resposta estacionária completa a partir de H(jω).",
                                  "commonMistakes": [
                                    "Inverter sinal da fase",
                                    "Usar seno em vez de cosseno"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um filtro passa-baixa RC com H(s) = 1/(1 + sRC), entrada u(t) = 10 cos(2π*50 t), ω=314 rad/s, RC=0.01s: H(jω)=1/(1+j3.14) ≈ 0.309 -j0.952, |H|=1, ∠H≈ -72°. Assim y(t)=10 cos(314t -72°).",
                              "finalVerifications": [
                                "H(jω) calculado corretamente como complexo.",
                                "Magnitude e fase coincidem com software de verificação (ex: MATLAB bode).",
                                "y(t) tem amplitude A|H| e fase φ + ∠H.",
                                "Resposta ignora transientes (estacionária).",
                                "Teste com ω→0: y(t)→ ganho DC * u(t).",
                                "Plot y(t) sobreposto a u(t) mostra atraso de fase."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em |H(jω)| e ∠H(jω) (<1% erro).",
                                "Correta manipulação de números complexos em todos passos.",
                                "y(t) expressa na forma exata solicitada.",
                                "Explicação clara de cada cálculo intermediário.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação correta a exemplo numérico dado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de circuitos RLC e vibrações harmônicas.",
                                "Controle Automático: Projeto de controladores em malha fechada.",
                                "Processamento de Sinais: Filtros digitais analógicos.",
                                "Matemática: Números complexos e análise de Fourier."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular a resposta de uma asa flexível a vibrações senoidais (ex: turbulência) usando modelo dinâmico LTI, prevendo fadiga estrutural e otimizando amortecedores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Representações Gráficas da FRF",
                        "description": "Formas de plotar e interpretar H(jω), incluindo diagramas de Bode, Nyquist e polar, para visualização de magnitude e fase em função da frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Construir diagrama de Bode",
                            "description": "Plotar curvas de magnitude em dB e fase em graus versus log(ω) para H(jω), identificando cortes de frequência e inclinações assintóticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Função de Transferência H(jω)",
                                  "subSteps": [
                                    "Obtenha a função de transferência H(s) do sistema linear contínuo.",
                                    "Substitua s por jω para obter H(jω).",
                                    "Expresse H(jω) no formato polar: |H(jω)| e ∠H(jω), ou fatorize em termos de zeros e pólos.",
                                    "Identifique as frequências de corte (ω_c) para cada polo e zero.",
                                    "Calcule os ganhos em baixas e altas frequências."
                                  ],
                                  "verification": "Confirme que H(jω) está fatorizada corretamente e frequências de corte listadas em uma tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de transferência H(s)",
                                    "Papel milimetrado ou software como MATLAB/Python (Matplotlib + Control Systems Library)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre normalize a função para que o ganho DC seja claro; use ω em rad/s.",
                                  "learningObjective": "Dominar a conversão de H(s) para H(jω) e identificação de componentes frequenciais.",
                                  "commonMistakes": [
                                    "Esquecer de converter s → jω",
                                    "Ignorar fatores constantes de ganho",
                                    "Confundir zeros com pólos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Esboçar o Diagrama Assintótico de Magnitude",
                                  "subSteps": [
                                    "Desenhe o eixo log(ω) de 0.1 a 1000 rad/s (escala logarítmica).",
                                    "Plote a linha de referência 0 dB para baixas frequências.",
                                    "Para cada zero: adicione +20 dB/década após ω_z; para cada polo: -20 dB/década após ω_p.",
                                    "Some as contribuições assintóticas em cada segmento (inclinações: 0, ±20, ±40 dB/década).",
                                    "Marque as frequências de corte e verifique a inclinação final em altas frequências."
                                  ],
                                  "verification": "O esboço mostra segmentos retos conectados nos cantos com inclinações corretas e magnitude em dB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel log-log ou ferramenta gráfica (Excel/MATLAB bode() para referência)",
                                    "Tabela de frequências de corte"
                                  ],
                                  "tips": "Comece pelas componentes de baixa frequência e adicione uma por vez; use régua para linhas retas.",
                                  "learningObjective": "Construir aproximações assintóticas precisas para magnitude de H(jω).",
                                  "commonMistakes": [
                                    "Erro no sinal da inclinação (polo/zero)",
                                    "Deslocamento incorreto do eixo log(ω)",
                                    "Não somar contribuições múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Esboçar o Diagrama Assintótico de Fase",
                                  "subSteps": [
                                    "Desenhe o eixo log(ω) alinhado com o de magnitude.",
                                    "Para baixas frequências, fase inicial: 0° (ou múltiplos de 90° baseados em ordem).",
                                    "Para cada zero: transição +90° (0° a +90°) centrada em ω_z (inicia 1 década antes, acaba 1 década após).",
                                    "Para cada polo: transição -90° similarmente.",
                                    "Some as fases em cada região e marque mudanças nos cantos."
                                  ],
                                  "verification": "Fase varia suavemente de valor inicial para final, com transições de ±90° por fator.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel semi-log ou software de plotagem",
                                    "Tabela de fases por década"
                                  ],
                                  "tips": "Use aproximações lineares nas transições para simplicidade; verifique continuidade.",
                                  "learningObjective": "Entender e plotar variações de fase assintóticas em função de frequência.",
                                  "commonMistakes": [
                                    "Transições abruptas em vez de graduais",
                                    "Inverter sinal de fase para pólos/zeros",
                                    "Ignorar fase inicial/final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar o Diagrama e Identificar Características Chave",
                                  "subSteps": [
                                    "Adicione correções reais: -3 dB no canto de magnitude para pólos/zeros simples; suavize fase.",
                                    "Identifique frequências de ressonância, largura de banda e margens de estabilidade se aplicável.",
                                    "Compare com plot exato (usando software) e ajuste.",
                                    "Rotule todos os eixos, cortes de frequência, inclinações e valores chave.",
                                    "Documente observações sobre comportamento do sistema (ex: filtro passa-baixa)."
                                  ],
                                  "verification": "Diagrama final rotulado com curvas reais aproximadas e características identificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para plot Bode exato (MATLAB: bodeplot, Python: control.bode_plot)",
                                    "Marcadores coloridos para rótulos"
                                  ],
                                  "tips": "Cores diferentes para magnitude (azul) e fase (vermelho); sempre valide com simulação.",
                                  "learningObjective": "Aplicar refinamentos e extrair insights analíticos do diagrama de Bode.",
                                  "commonMistakes": [
                                    "Esquecer correção de -3 dB",
                                    "Rótulos ilegíveis",
                                    "Não identificar inclinações assintóticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = 10 / [(s/10 + 1)(s/100 + 1)], fatorize H(jω), plote magnitude: 20 dB inicial, -20 dB/déc após 10 rad/s, -40 dB/déc após 100 rad/s; fase: 0° inicial, -90° entre 1-100 rad/s, -180° final. Identifique cortes em 10 e 100 rad/s.",
                              "finalVerifications": [
                                "Magnitude assintótica correta com inclinações somadas.",
                                "Fase transita ±90° por polo/zero com largura de 2 décadas.",
                                "Frequências de corte marcadas precisamente.",
                                "Correções de -3 dB aplicadas nos cantos.",
                                "Eixos log(ω), dB e graus rotulados corretamente.",
                                "Comportamento em baixas/altas frequências consistente com ordem do sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão das inclinações assintóticas (±5% erro).",
                                "Correta identificação e marcação de ω_c.",
                                "Suavidade e realismo nas transições de fase.",
                                "Rótulos completos e legíveis.",
                                "Comparação qualitativa com plot exato.",
                                "Explicação clara de pelo menos 3 características chave."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Análise de estabilidade via margens de ganho/fase.",
                                "Processamento de Sinais: Design de filtros analógicos.",
                                "Engenharia Mecânica/Aeronáutica: Vibrações e resposta dinâmica de estruturas.",
                                "Matemática: Transformadas de Fourier e logaritmos.",
                                "Programação: Simulação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, diagramas de Bode são usados para analisar a resposta em frequência de sistemas de controle de voo, identificando faixas de operação estável para autopilotos e atenuadores de flutter em asas de aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Interpretar diagrama de Nyquist",
                            "description": "Traçar o lócus de H(jω) no plano complexo à medida que ω varia de 0 a ∞, identificando passagem pelo eixo imaginário e encirclement do ponto -1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Função de Transferência e Resposta em Frequência",
                                  "subSteps": [
                                    "Estude a função de transferência H(s) e sua avaliação em H(jω) para ω real.",
                                    "Revise o plano complexo: eixo real (magnitude), eixo imaginário (fase).",
                                    "Entenda magnitude |H(jω)| e fase ∠H(jω) como coordenadas polares para o lócus.",
                                    "Analise o comportamento assintótico: ω → 0 (baixo frequência) e ω → ∞ (alta frequência).",
                                    "Pratique convertendo H(s) em H(jω) para um sistema simples de 1ª ordem."
                                  ],
                                  "verification": "Desenhe manualmente H(jω) para H(s) = 1/(s+1) em ω=0 e ω=∞, explicando os pontos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre funções de transferência",
                                    "Papel milimetrado",
                                    "Calculadora científica"
                                  ],
                                  "tips": [
                                    "Sempre comece com os limites de frequência para orientação inicial do lócus."
                                  ],
                                  "learningObjective": "Compreender a base matemática do diagrama de Nyquist como lócus de H(jω).",
                                  "commonMistakes": [
                                    "Confundir H(jω) com diagrama de Bode",
                                    "Ignorar o semiplano direito para ω negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Diagrama de Nyquist Passo a Passo",
                                  "subSteps": [
                                    "Calcule H(jω) para vários valores de ω de 0 a ∞, plotando pontos reais e imaginários.",
                                    "Trace o lócus conectando pontos sequencialmente, usando simetria para ω negativo.",
                                    "Inclua o arco semicircular no infinito se necessário para sistemas de ordem alta.",
                                    "Use software para validar o traçado manual.",
                                    "Repita para um sistema de 2ª ordem com polos reais."
                                  ],
                                  "verification": "Compare traçado manual com plot gerado em MATLAB/Python para concordância visual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (control library)",
                                    "Planilha Excel para cálculos",
                                    "Papel e lápis"
                                  ],
                                  "tips": [
                                    "Escolha ω log-espalhados para capturar curvas suaves; foque em regiões de mudança rápida."
                                  ],
                                  "learningObjective": "Dominar a técnica de traçado do lócus de Nyquist.",
                                  "commonMistakes": [
                                    "Esquecer simetria especular sobre o eixo real",
                                    "Não fechar o contorno com arco no infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Passagem pelo Eixo Imaginário e Pontos Críticos",
                                  "subSteps": [
                                    "Resolva Im[H(jω)] = 0 para encontrar frequências de cruzamento do eixo imaginário.",
                                    "Calcule ganho marginal (magnitude no cruzamento) e frequência de cruzamento.",
                                    "Marque o ponto crítico -1 + j0 no plano complexo.",
                                    "Analise direção da passagem (sentido horário ou anti-horário).",
                                    "Pratique em sistemas com zeros no semiplano direito."
                                  ],
                                  "verification": "Liste frequências de cruzamento e ganhos para um exemplo dado, marcando no diagrama.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de problemas resolvidos",
                                    "Solver simbólico como SymPy",
                                    "Gráficos impressos"
                                  ],
                                  "tips": [
                                    "Use equações reais e imaginárias separadas: Re[H(jω)] e Im[H(jω)] = 0."
                                  ],
                                  "learningObjective": "Localizar e interpretar interseções chave no diagrama.",
                                  "commonMistakes": [
                                    "Confundir cruzamento real com imaginário",
                                    "Ignorar múltiplos cruzamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Encirclement do Ponto -1 e Estabilidade",
                                  "subSteps": [
                                    "Conte o número de encirclements (N) do ponto -1 no sentido anti-horário.",
                                    "Aplique o critério de Nyquist: Z = P - N, onde Z=0 para estabilidade.",
                                    "Determine número de polos instáveis abertos (P).",
                                    "Avalie estabilidade condicional e robustez.",
                                    "Teste com laço unitário e não-unitário."
                                  ],
                                  "verification": "Conclua corretamente sobre estabilidade de 3 diagramas diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de exemplos com soluções",
                                    "Software de simulação de controle"
                                  ],
                                  "tips": [
                                    "Encirclement completo é 360° ao redor de -1; conte apenas contornos fechados."
                                  ],
                                  "learningObjective": "Aplicar critério de Nyquist para julgamento de estabilidade.",
                                  "commonMistakes": [
                                    "Errar contagem de encirclements par/impar",
                                    "Confundir P com zeros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Interpretação Completa e Análise de Casos",
                                  "subSteps": [
                                    "Interprete um diagrama completo: estabilidade, margens, desempenho.",
                                    "Compare com diagrama de Bode para validação.",
                                    "Analise efeitos de ganho variável (lócus muda escala).",
                                    "Resolva problemas de sistemas aeronáuticos reais.",
                                    "Crie seu próprio exemplo e interprete."
                                  ],
                                  "verification": "Escreva relatório curto de interpretação para 2 diagramas novos.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Banco de problemas de Nyquist",
                                    "Ferramentas online como Nyquist plotter"
                                  ],
                                  "tips": [
                                    "Sempre relacione com resposta temporal simulada para confirmação."
                                  ],
                                  "learningObjective": "Integrar todos os elementos para interpretação fluida.",
                                  "commonMistakes": [
                                    "Sobrepor interpretação sem contorno completo",
                                    "Ignorar dinâmica não-mínima"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o sistema de controle de atitude de uma aeronave com H(s) = K / (s(s+2)(s+10)), trace o diagrama de Nyquist para K=1. Identifique o cruzamento imaginário em ω≈1.4 rad/s com ganho 0.8 (estável), e para K=1.5 (instável com encirclement). Conte N=1, P=0 → Z=1 polo instável.",
                              "finalVerifications": [
                                "Traçar corretamente lócus de H(jω) para sistema dado sem erros de cálculo.",
                                "Identificar precisamente todos cruzamentos do eixo imaginário e ganhos marginais.",
                                "Contar encirclements de -1 corretamente e concluir estabilidade.",
                                "Explicar impacto de variação de ganho no diagrama.",
                                "Validar interpretação com simulação de resposta em malha fechada.",
                                "Relacionar características do Nyquist com margens de fase e ganho."
                              ],
                              "assessmentCriteria": [
                                "Precisão no traçado do lócus (erro <5% em pontos chave).",
                                "Correta identificação de frequências e ganhos de cruzamento.",
                                "Aplicação precisa do critério de Nyquist (Z = P - N).",
                                "Análise qualitativa de estabilidade e robustez.",
                                "Uso adequado de ferramentas computacionais para validação.",
                                "Clareza na explicação escrita/oral da interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e contornos no plano complexo.",
                                "Física: Dinâmica de sistemas oscilatórios e estabilidade em vibrações.",
                                "Engenharia Mecânica: Análise de controle em atuadores e estruturas.",
                                "Programação: Implementação de plots em MATLAB/Python para automação.",
                                "Engenharia Elétrica: Filtros analógicos e processamento de sinais."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, diagramas de Nyquist são usados para projetar controladores de voo autônomos, garantindo estabilidade em manobras de aeronaves como drones ou aviões comerciais, evitando oscilações perigosas em sistemas de autopilotagem sob variações de carga ou turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Representação em forma polar",
                            "description": "Expressar H(jω) em coordenadas polares |H(jω)| ∠θ(ω) e plotar vetores no plano complexo para frequências específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação polar da função de resposta em frequência H(jω)",
                                  "subSteps": [
                                    "Revise a função de transferência H(s) e sua avaliação em s = jω.",
                                    "Identifique os componentes: magnitude |H(jω)| como módulo do número complexo e fase θ(ω) como argumento.",
                                    "Entenda o plano complexo: eixo real (Re) e imaginário (Im), com |H| como distância da origem e θ como ângulo do vetor.",
                                    "Estude a notação |H(jω)| ∠ θ(ω).",
                                    "Compare com representação retangular H(jω) = Re + j Im."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes da forma polar e desenhe um exemplo simples no plano complexo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, notas de aula sobre números complexos.",
                                  "tips": "Sempre visualize o vetor saindo da origem para fixar a ideia geométrica.",
                                  "learningObjective": "Dominar os conceitos fundamentais da forma polar para funções de frequência.",
                                  "commonMistakes": "Confundir magnitude com parte real ou ignorar o papel da fase na direção do vetor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular magnitude e fase para uma frequência específica ω",
                                  "subSteps": [
                                    "Substitua s = jω na função de transferência H(s) para obter H(jω).",
                                    "Separe H(jω) em partes real (Re) e imaginária (Im).",
                                    "Calcule a magnitude: |H(jω)| = √(Re² + Im²).",
                                    "Calcule a fase: θ(ω) = atan2(Im, Re) em graus ou radianos, considerando o quadrante correto.",
                                    "Expresse como |H(jω)| ∠ θ(ω)."
                                  ],
                                  "verification": "Realize o cálculo para ω dada e confira com software como MATLAB ou Python (numpy).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora gráfica (TI-89 ou similar), software Python com numpy ou MATLAB.",
                                  "tips": "Use a função atan2 para fase correta em todos os quadrantes; evite atan simples.",
                                  "learningObjective": "Executar cálculos precisos de magnitude e fase a partir de H(s).",
                                  "commonMistakes": "Erro no sinal de Im ao substituir jω ou ignorar o quadrante na fase (ex: fase negativa)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar o vetor no plano complexo para a frequência ω",
                                  "subSteps": [
                                    "Desenhe os eixos real e imaginário no plano complexo.",
                                    "Marque a origem e trace o vetor com comprimento |H(jω)| no ângulo θ(ω) a partir da origem.",
                                    "Rotule o comprimento como |H| e o ângulo como θ.",
                                    "Adicione marcações para Re e Im para verificação.",
                                    "Repita para uma segunda frequência para comparar vetores."
                                  ],
                                  "verification": "Desenhe o plot e meça manualmente o comprimento e ângulo para confirmar valores calculados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel milimetrado ou software de plotagem (GeoGebra, Desmos, Matplotlib).",
                                  "tips": "Use escala logarítmica para magnitude se |H| variar muito.",
                                  "learningObjective": "Visualizar graficamente a resposta em frequência como vetores no plano complexo.",
                                  "commonMistakes": "Plotar ângulo no sentido horário (sempre anti-horário) ou inverter eixos real/imaginário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e interpretar o diagrama polar completo para múltiplas frequências",
                                  "subSteps": [
                                    "Selecione um conjunto de frequências ω (ex: 0.1, 1, 10 rad/s).",
                                    "Calcule |H(jω)| e θ(ω) para cada ω.",
                                    "Plote todos os vetores no mesmo plano complexo, formando a curva polar.",
                                    "Analise o padrão: como magnitude e fase mudam com ω.",
                                    "Interprete: identifique ressonância ou atraso de fase."
                                  ],
                                  "verification": "Gere o diagrama polar e descreva qualitativamente o comportamento do sistema.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software MATLAB (bodeplot ou nyquist), Python (matplotlib e control library).",
                                  "tips": "Comece com baixa e alta ω para ver assíntotas.",
                                  "learningObjective": "Integrar cálculos e plots para análise completa da FRF em polar.",
                                  "commonMistakes": "Não normalizar frequências ou pular ω=0 e ω=∞ para contexto."
                                }
                              ],
                              "practicalExample": "Para H(s) = 1/(s + 1) em um sistema de amortecimento aeronáutico, calcule para ω=1 rad/s: H(j1) = 1/(1+j) = 0.5 - j0.5, |H|=√0.5≈0.707 ∠ -45°. Plote vetor de 0.707 no ângulo -45° e repita para ω=0.1 e ω=10.",
                              "finalVerifications": [
                                "Converte corretamente H(jω) para forma polar em 3 exemplos independentes.",
                                "Plota vetores precisos no plano complexo com magnitude e fase corretas.",
                                "Identifica padrões no diagrama polar (ex: rotação com ω crescente).",
                                "Usa software para validar plots manuais.",
                                "Explica a relação entre polar, Bode e Nyquist."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de |H| e θ (erro <5%).",
                                "Qualidade gráfica dos plots (rótulos, escalas corretas).",
                                "Interpretação física correta da magnitude (ganho) e fase (atraso).",
                                "Eficiência no tempo e avoidance de erros comuns.",
                                "Capacidade de generalizar para H(s) de ordem superior."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Números complexos e trigonometria.",
                                "Física: Representação vetorial de forças e vibrações.",
                                "Computação: Programação em Python/MATLAB para automação de plots.",
                                "Engenharia Mecânica: Análise de vibrações em estruturas aeronáuticas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, diagramas polares da FRF são usados para analisar estabilidade de sistemas de controle de voo e resposta a vibrações em asas, identificando frequências críticas de flutter ou fadiga."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Propriedades e Análise via FRF",
                        "description": "Propriedades fundamentais como simetria, máxima magnitude, estabilidade via Nyquist, e uso para análise de desempenho de sistemas dinâmicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Identificar propriedades de H(jω)",
                            "description": "Listar e verificar propriedades como H(-jω) = conj(H(jω)), |H(jω)| par, ∠H(jω) ímpar, e periodicidade em sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e fundamentos de H(jω)",
                                  "subSteps": [
                                    "Ler a definição de H(jω) como a transformada de Fourier da resposta ao impulso h(t).",
                                    "Escrever a fórmula matemática: H(jω) = ∫_{-∞}^{∞} h(t) e^{-jωt} dt.",
                                    "Explicar que se aplica a sistemas lineares invariantes no tempo (LTI) contínuos.",
                                    "Discutir relação com a função de transferência H(s) via substituição s = jω.",
                                    "Identificar domínio de ω (frequência angular real)."
                                  ],
                                  "verification": "Escrever corretamente a fórmula de H(jω) e explicar sua interpretação física.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Notas de aula sobre LTI",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize H(jω) como um fasor no plano complexo para melhor compreensão.",
                                  "learningObjective": "Compreender a origem e representação de H(jω) em sistemas LTI contínuos.",
                                  "commonMistakes": "Confundir H(jω) com H(s) ou ignorar que h(t) é real para sistemas físicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e verificar simetria conjugada H(-jω) = conj(H(jω))",
                                  "subSteps": [
                                    "Assumir h(t) real, comum em sistemas físicos.",
                                    "Substituir ω por -ω na fórmula: H(-jω) = ∫ h(t) e^{jωt} dt.",
                                    "Tomar o conjugado complexo de H(jω): conj(H(jω)) = ∫ h(t) e^{jωt} dt (pois h(t) real).",
                                    "Concluir que H(-jω) = conj(H(jω)).",
                                    "Verificar numericamente com um exemplo simples de h(t)."
                                  ],
                                  "verification": "Derivar a igualdade em um papel e testar com h(t) = e^{-t} u(t).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software MATLAB ou Python (SymPy)",
                                    "Tabela de transformadas de Fourier"
                                  ],
                                  "tips": "Lembre-se: conjugado inverte o sinal imaginário; prove usando propriedades da integral.",
                                  "learningObjective": "Dominar a propriedade de simetria conjugada e sua derivação.",
                                  "commonMistakes": "Esquecer que h(t) deve ser real para a propriedade valer."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar paridade de magnitude e fase: |H(jω)| par e ∠H(jω) ímpar",
                                  "subSteps": [
                                    "Usar simetria conjugada para mostrar |H(-jω)| = |conj(H(jω))| = |H(jω)| (par).",
                                    "Derivar ∠H(-jω) = ∠conj(H(jω)) = -∠H(jω) (ímpar).",
                                    "Plotar |H(jω)| e ∠H(jω) para ω > 0 e estender simetricamente.",
                                    "Explicar implicações: basta calcular para ω ≥ 0.",
                                    "Verificar com gráfico de um filtro passa-baixa."
                                  ],
                                  "verification": "Desenhar gráficos simétricos de |H| e anti-simétricos de ∠H.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Octave/Python Matplotlib)",
                                    "Exemplos de filtros RC/RL"
                                  ],
                                  "tips": "Use log-log para magnitude e linear para fase em Bode plots.",
                                  "learningObjective": "Entender e aplicar propriedades de paridade para simplificar análises.",
                                  "commonMistakes": "Confundir par (even) com ímpar (odd) nas funções magnitude e fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar periodicidade em sistemas discretos e verificação geral",
                                  "subSteps": [
                                    "Introduzir H(e^{jω}) para discretos: periódica com período 2π.",
                                    "Explicar H(e^{j(ω+2π)}) = H(e^{jω}) devido à DTFT.",
                                    "Comparar com contínuos (não periódicos).",
                                    "Verificar todas propriedades em um exemplo misto (contínuo e discreto).",
                                    "Listar sumário: simetria, paridade, periodicidade."
                                  ],
                                  "verification": "Listar as 4 propriedades principais e confirmar com um exemplo discreto simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas sobre DTFT",
                                    "Python com NumPy/SciPy para simulação discreta"
                                  ],
                                  "tips": "Digitalize um sinal contínuo para testar periodicidade.",
                                  "learningObjective": "Diferenciar propriedades contínuas vs. discretas e sintetizar conhecimento.",
                                  "commonMistakes": "Aplicar periodicidade a sistemas contínuos."
                                }
                              ],
                              "practicalExample": "Considere um circuito RC passa-baixa com H(jω) = 1 / (1 + jωRC). Compute H(jω) para ω=1, verifique H(-j1)=conj(H(j1)), |H(j1)|=|H(-j1)| (par), ∠H(-j1)=-∠H(j1) (ímpar). Para discreto, use filtro FIR simétrico e observe H(e^{j(ω+2π)})=H(e^{jω}).",
                              "finalVerifications": [
                                "Lista corretamente simetria conjugada, paridade de |H| e ∠H, e periodicidade discreta.",
                                "Deriva matematicamente pelo menos duas propriedades.",
                                "Aplica propriedades a um exemplo numérico ou gráfico.",
                                "Explica implicações para análise de Bode.",
                                "Diferencia propriedades contínuas de discretas.",
                                "Identifica quando h(t) real é essencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Compreensão conceitual via explicações claras.",
                                "Capacidade de verificação prática com exemplos.",
                                "Uso correto de gráficos para ilustrar paridade.",
                                "Síntese de propriedades em contexto de sistemas LTI.",
                                "Diferenciação precisa entre domínios contínuo e discreto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções complexas, paridade e conjugados.",
                                "Física: Análise de vibrações e ondas em estruturas aeronáuticas.",
                                "Processamento de Sinais: Projeto de filtros analógicos/digitais.",
                                "Engenharia de Controle: Estabilidade via Nyquist.",
                                "Computação: Simulações numéricas em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, ao analisar flutter em asas, as propriedades de H(jω) permitem modelar eficientemente respostas em frequência de estruturas vibrantes, reduzindo computação ao analisar apenas ω ≥ 0 e detectando simetrias para previsão de instabilidades dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Analisar estabilidade e desempenho",
                            "description": "Usar FRF para determinar margens de ganho e fase, largura de banda, fator de qualidade em ressonâncias, e robustez a perturbações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Plotar a Função de Resposta em Frequência (FRF)",
                                  "subSteps": [
                                    "Obtenha o modelo de transferência do sistema linear contínuo.",
                                    "Use software como MATLAB ou Python (control library) para calcular a FRF (magnitude e fase vs. frequência).",
                                    "Plote a FRF em gráfico de Bode (magnitude em dB e fase em graus).",
                                    "Identifique pontos críticos como cruzamentos de 0 dB e -180 graus.",
                                    "Ajuste a escala de frequência para capturar dinâmicas relevantes (ex: 0.1 a 100 rad/s)."
                                  ],
                                  "verification": "Verifique se o gráfico de Bode exibe magnitude decrescente em baixas frequências, picos de ressonância e fase variando de 0 a -180 graus ou mais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software MATLAB/Python com bibliotecas control/sysid; modelo de transferência exemplo (ex: G(s) = 1/(s^2 + 0.2s + 1)).",
                                  "tips": "Use logscale para frequência para melhor visualização de dinâmicas amplas.",
                                  "learningObjective": "Dominar a geração e visualização da FRF para análise subsequente.",
                                  "commonMistakes": "Esquecer de converter para dB na magnitude; plotar frequência linear em vez de log."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar Margens de Ganho e Fase para Estabilidade",
                                  "subSteps": [
                                    "Localize a frequência de ganho unitário (ω_g) onde |G(jω)| = 0 dB.",
                                    "Meça a margem de fase (PM) como 180° + ∠G(jω_g).",
                                    "Localize a frequência de fase crítica (ω_pc) onde ∠G(jω) = -180°.",
                                    "Meça a margem de ganho (GM) como 1 / |G(jω_pc)| em dB (negativo se instável).",
                                    "Interprete: PM > 45° e GM > 6 dB indicam estabilidade robusta."
                                  ],
                                  "verification": "Confirme valores numéricos: ex. PM = 60°, GM = 10 dB, com anotações no gráfico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico de Bode gerado; régua digital ou cursor no software para medições precisas.",
                                  "tips": "Use comandos como margin() no MATLAB para automação inicial, mas entenda manualmente.",
                                  "learningObjective": "Calcular e interpretar margens para avaliar estabilidade.",
                                  "commonMistakes": "Confundir ω_g com ω_pc; calcular PM como diferença direta sem +180°."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Largura de Banda e Analisar Resposta Transitória",
                                  "subSteps": [
                                    "Defina largura de banda (BW) como frequência onde |G(jω)| = -3 dB.",
                                    "Meça BW entre as frequências de corte inferior e superior.",
                                    "Relacione BW com tempo de subida (aprox. 0.35/BW) e tempo de estabilização.",
                                    "Avalie impacto na desempenho: BW maior implica resposta mais rápida.",
                                    "Compare com especificações de desempenho desejadas (ex: BW > 10 rad/s)."
                                  ],
                                  "verification": "Registre BW exata (ex: 5 rad/s) e prediga tempo de subida < 0.1s.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico de Bode; calculadora para relações tempo-frequência.",
                                  "tips": "Foque na região -3 dB próxima à ω_g para sistemas de controle.",
                                  "learningObjective": "Ligar largura de banda a métricas de desempenho temporal.",
                                  "commonMistakes": "Usar -6 dB em vez de -3 dB; ignorar corte inferior em sistemas com integradores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Ressonâncias e Fator de Qualidade (Q)",
                                  "subSteps": [
                                    "Identifique picos na magnitude da FRF (frequências de ressonância ω_r).",
                                    "Calcule Q = |G(jω_r)|_max / |G(jω_r)|_{-3dB nos ombros}.",
                                    "Avalie Q alto (>10) como indicativo de oscilações persistentes.",
                                    "Relacione Q com amortecimento ζ ≈ 1/(2Q).",
                                    "Verifique múltiplas ressonâncias em sistemas de ordem alta."
                                  ],
                                  "verification": "Liste ω_r, Q para cada pico (ex: ω_r=2 rad/s, Q=15).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico de Bode ampliado nos picos; fórmula de Q anotada.",
                                  "tips": "Amplie eixos para precisão nos ombros do pico.",
                                  "learningObjective": "Quantificar seletividade e amortecimento via Q.",
                                  "commonMistakes": "Medir Q do pico ao eixo zero em vez de -3 dB; confundir com BW."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Robustez a Perturbações e Síntese Geral",
                                  "subSteps": [
                                    "Simule perturbações variando parâmetros do modelo (±20%).",
                                    "Replot FRF e reavalie margens/BW/Q para cada caso.",
                                    "Calcule variação percentual nas métricas (ex: ΔPM < 10°).",
                                    "Classifique robustez: alta se métricas estáveis.",
                                    "Recomende compensadores se robustez baixa (ex: notch filter para Q alto)."
                                  ],
                                  "verification": "Tabela comparativa de métricas nominais vs. perturbadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Modelos perturbados; software para simulação paramétrica.",
                                  "tips": "Use loops em MATLAB para automação de múltiplas FRFs.",
                                  "learningObjective": "Avaliar sensibilidade e robustez do sistema.",
                                  "commonMistakes": "Perturbações muito pequenas (<5%); ignorar não-linearidades implícitas."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aleta de aeronave modelado como G(s) = 10 / (s^2 + 0.1s + 25), plote FRF, calcule PM=55°, GM=12 dB, BW=6 rad/s, Q=8 no pico ω_r=5 rad/s, e verifique robustez variando massa da aleta em ±15%.",
                              "finalVerifications": [
                                "Margens de ganho e fase calculadas corretamente (>45° PM, >6 dB GM).",
                                "Largura de banda identificada com precisão de ±0.1 rad/s.",
                                "Fator Q medido para todas ressonâncias com erro <5%.",
                                "Robustez quantificada com tabela de variações <10% em métricas chave.",
                                "Relatório escrito resumindo estabilidade e desempenho.",
                                "Gráficos anotados com todas medições visíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas medições de FRF (erro <1%).",
                                "Interpretação correta de implicações para estabilidade (rubrica 1-5).",
                                "Qualidade dos gráficos e anotações (clareza, legibilidade).",
                                "Análise de robustez abrangente e quantitativa.",
                                "Conexão explícita entre métricas FRF e desempenho temporal.",
                                "Identificação proativa de problemas e sugestões de melhoria."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Projeto de compensadores baseados em margens.",
                                "Dinâmica de Aeronaves: Análise de flutter via picos ressonantes.",
                                "Processamento de Sinais: Filtros e análise espectral.",
                                "Matemática Aplicada: Transformada de Fourier e funções complexas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, essa análise é usada para certificar estabilidade de sistemas de controle de voo, evitando oscilações como flutter em asas, garantindo margens seguras sob variações de velocidade do ar ou danos estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Aplicar em exemplos de sistemas físicos",
                            "description": "Calcular e interpretar FRF para sistemas mecânicos (amortecedor-massa-mola), térmicos ou hidráulicos, relacionando com parâmetros físicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema físico e suas equações de movimento",
                                  "subSteps": [
                                    "Identifique o tipo de sistema (mecânico massa-mola-amortecedor, térmico ou hidráulico).",
                                    "Desenhe o diagrama esquemático do sistema, rotulando massa (m), rigidez (k), amortecimento (c) ou equivalentes.",
                                    "Escreva a equação diferencial de segunda ordem: mẍ + cẋ + kx = f(t).",
                                    "Transforme para o domínio de Laplace para obter a função de transferência G(s) = 1/(ms² + cs + k).",
                                    "Verifique as unidades dos parâmetros para consistência."
                                  ],
                                  "verification": "Equação diferencial e função de transferência corretas, com unidades verificadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou software como MATLAB/Simulink; tabela de parâmetros físicos.",
                                  "tips": "Use analogias entre sistemas (mecânico ↔ elétrico) para facilitar a compreensão.",
                                  "learningObjective": "Compreender a modelagem matemática de sistemas físicos lineares.",
                                  "commonMistakes": "Confundir parâmetros (ex: rigidez k com massa m); ignorar unidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Função de Resposta em Frequência (FRF)",
                                  "subSteps": [
                                    "Substitua s = jω na função de transferência para obter H(jω) = 1/(k - mω² + j c ω).",
                                    "Calcule o módulo |H(jω)| = 1 / sqrt( (k - mω²)² + (cω)² ).",
                                    "Calcule a fase arg(H(jω)) = -atan2(cω, k - mω²).",
                                    "Identifique frequência natural ω_n = sqrt(k/m) e fator de amortecimento ζ = c/(2 sqrt(k m)).",
                                    "Simplifique expressões para casos de amortecimento baixo ou crítico."
                                  ],
                                  "verification": "Expressões de |H(jω)| e fase corretas; ω_n e ζ calculados precisamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (Wolfram Alpha ou MATLAB); notas de derivadas.",
                                  "tips": "Memorize a forma padrão H(jω) para evitar derivações longas em exames.",
                                  "learningObjective": "Dominar a derivação analítica da FRF a partir da função de transferência.",
                                  "commonMistakes": "Erro no sinal de jω (s = jω, não -jω); confusão entre módulo e magnitude ao quadrado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e plotar a FRF para valores numéricos",
                                  "subSteps": [
                                    "Escolha valores: m=1 kg, k=100 N/m, c=0.5 Ns/m (ζ≈0.25).",
                                    "Gere vetor de frequências ω de 0 a 2ω_n.",
                                    "Compute |H(jω)| e fase numericamente usando software.",
                                    "Plote magnitude (dB) e fase vs. log(ω); Bode plot.",
                                    "Marque ω_n, pico de ressonância e largura de banda."
                                  ],
                                  "verification": "Plots gerados com picos corretos (ex: ressonância em ≈9.5 rad/s para exemplo).",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB, Python (matplotlib/scipy) ou Excel; valores de exemplo pré-definidos.",
                                  "tips": "Use logscale para ω para visualizar melhor o comportamento em baixas e altas frequências.",
                                  "learningObjective": "Aplicar cálculos numéricos e visualização da FRF.",
                                  "commonMistakes": "Escala errada no plot (linear vs log); valores de ω insuficientes perto de ω_n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a FRF e relacionar com parâmetros físicos",
                                  "subSteps": [
                                    "Analise o pico de magnitude: posição ≈ω_n, altura ≈1/(2ζ) para ζ baixo.",
                                    "Meça largura de banda Δω ≈ 2ζ ω_n no -3dB.",
                                    "Interprete: alto ζ reduz pico (bom para vibrações); baixo ζ amplifica ressonância.",
                                    "Varie parâmetros (aumente c → ζ↑, pico↓) e observe mudanças.",
                                    "Relacione com física: m afeta ω_n, k afeta rigidez, c dissipa energia."
                                  ],
                                  "verification": "Relatório descrevendo corretamente como parâmetros afetam FRF.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Plots do Step 3; tabela comparativa de variações de parâmetros.",
                                  "tips": "Pense em termos qualitativos primeiro (ex: 'mais amortecimento suaviza o pico').",
                                  "learningObjective": "Interpretar FRF fisicamente, ligando matemática a comportamento real.",
                                  "commonMistakes": "Atribuir efeitos errados (ex: confundir m com c); ignorar fase."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com sistemas alternativos (térmico/hidráulico)",
                                  "subSteps": [
                                    "Modele equivalente térmico: C (capacitância térmica) ~ m, R (resistência) ~ c, K (condutância) ~ k.",
                                    "Derive FRF similar e compare plots.",
                                    "Aplique a hidráulico: inércia ~ m, viscosidade ~ c, compliance ~ 1/k.",
                                    "Discuta similaridades em interpretação (ressonância, amortecimento).",
                                    "Teste numérico rápido para um caso térmico."
                                  ],
                                  "verification": "FRFs comparadas mostrando analogias corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagramas de analogia; software do Step 3.",
                                  "tips": "Use tabelas de analogia força-tensão para conversões rápidas.",
                                  "learningObjective": "Generalizar FRF para múltiplos domínios físicos.",
                                  "commonMistakes": "Erros nas analogias (ex: inverter C e 1/K)."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor com m=1kg, k=100N/m, c=0.5Ns/m: ω_n=10 rad/s, ζ=0.25. FRF mostra pico de |H|≈2 em ω≈9.5 rad/s. Aumentando c para 2Ns/m (ζ=1), pico desaparece, ilustrando controle de vibrações.",
                              "finalVerifications": [
                                "FRF derivada analiticamente coincide com numérica em pelo menos 5 pontos.",
                                "Plots exibem ω_n, ressonância e largura de banda corretamente marcados.",
                                "Interpretação liga variações de m,k,c aos shifts em FRF.",
                                "Analogias com sistemas térmicos/hidráulicos validadas.",
                                "Relatório resume propriedades (pico, fase, roll-off).",
                                "Sem erros unitários ou dimensionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática (derivadas e cálculos: 30%)",
                                "Qualidade dos plots e análises visuais (25%)",
                                "Interpretação física profunda (25%)",
                                "Generalização a outros sistemas (10%)",
                                "Clareza do relatório e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Mecânica Vibracional (engenharia mecânica)",
                                "Controle Automático (estabilidade via Bode)",
                                "Processamento de Sinais (FFT para FRF experimental)",
                                "Engenharia Aeronáutica (vibrações em estruturas alares)"
                              ],
                              "realWorldApplication": "Em aeronáutica, analisar FRF de painéis de fuselagem para evitar ressonância com turbulências, ajustando amortecedores para minimizar fadiga estrutural e ruído."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Determinar solução de modelos via FRF",
                            "description": "Usar H(jω) combinada com transformada de Fourier de entrada para obter Y(jω), e inverter para y(t) em casos estacionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Obter a Função de Resposta em Frequência (FRF) H(jω)",
                                  "subSteps": [
                                    "Revise o modelo do sistema linear contínuo no tempo (ex: equação diferencial).",
                                    "Aplique a transformada de Laplace ou Fourier para derivar H(s) ou diretamente H(jω).",
                                    "Expresse H(jω) em forma de magnitude e fase: |H(jω)| e ∠H(jω).",
                                    "Verifique propriedades como ganho em baixa/alta frequência e ressonâncias.",
                                    "Anote o domínio de validade para análise estacionária (ω > 0)."
                                  ],
                                  "verification": "Confirme que H(jω) satisfaz limites conhecidos (ex: H(j0) = ganho DC) e plote magnitude/fase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Equação diferencial do sistema, tabela de transformadas de Fourier, software como MATLAB ou Python (SciPy).",
                                  "tips": "Use simetria para ω negativo: H(-jω) = conj(H(jω)) em sistemas reais.",
                                  "learningObjective": "Derivar e representar corretamente a FRF de um sistema linear.",
                                  "commonMistakes": "Confundir H(jω) com a função de transferência H(s); esquecer de avaliar em jω."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Transformada de Fourier da Entrada X(jω)",
                                  "subSteps": [
                                    "Identifique a entrada x(t), tipicamente sinusoidal ou periódica estacionária.",
                                    "Aplique a fórmula da transformada de Fourier: X(jω) = ∫ x(t) e^{-jωt} dt.",
                                    "Para sinusoides puras x(t) = A cos(ω0 t + φ), use deltas: X(jω) = (πA/2) [δ(ω - ω0)e^{jφ} + δ(ω + ω0)e^{-jφ}].",
                                    "Normalize se necessário para densidade espectral.",
                                    "Plote o espectro de X(jω) para visualização."
                                  ],
                                  "verification": "Verifique que |X(jω)| corresponde à amplitude da entrada e fase alinhada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Descrição da entrada x(t), tabelas de transformadas de Fourier, calculadora simbólica (SymPy).",
                                  "tips": "Para entradas periódicas, use séries de Fourier para somar harmônicos.",
                                  "learningObjective": "Computar X(jω) para entradas estacionárias comuns em análise de frequência.",
                                  "commonMistakes": "Usar transformada unilateral em vez de bilateral; ignorar componentes DC ou harmônicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Multiplicar H(jω) e X(jω) para Obter Y(jω)",
                                  "subSteps": [
                                    "Multiplique ponto a ponto: Y(jω) = H(jω) * X(jω).",
                                    "Calcule magnitude: |Y(jω)| = |H(jω)| * |X(jω)|.",
                                    "Calcule fase: ∠Y(jω) = ∠H(jω) + ∠X(jω).",
                                    "Identifique picos de ressonância onde |H(jω)| é máximo.",
                                    "Verifique conservação de energia ou propriedades físicas."
                                  ],
                                  "verification": "Plote |Y(jω)| e ∠Y(jω); confirme amplificação/demais em ressonâncias esperadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos de H(jω) e X(jω), software de plotagem (MATLAB bode ou Python matplotlib).",
                                  "tips": "Use escala log para magnitude para melhor visualização de dinâmicas.",
                                  "learningObjective": "Aplicar multiplicação espectral para resposta em frequência.",
                                  "commonMistakes": "Adicionar fases em vez de somar; esquecer wrap-around de fase (mod 2π)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inverter Y(jω) para Obter a Resposta y(t) no Estado Estacionário",
                                  "subSteps": [
                                    "Reconheça que para estacionário, y(t) é soma de sinusoides nos componentes de Y(jω).",
                                    "Use fórmula inversa: y(t) = (1/2π) ∫ Y(jω) e^{jωt} dω, simplificando para deltas.",
                                    "Para entrada senoidal única: y(t) = |H(jω0)| A cos(ω0 t + φ + ∠H(jω0)).",
                                    "Some contribuições de múltiplos harmônicos se aplicável.",
                                    "Valide numericamente com simulação temporal."
                                  ],
                                  "verification": "Compare y(t) com simulação numérica do sistema diferencial; cheque steady-state.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabelas de inversas de Fourier, simulador (Simulink ou ODE solver em Python).",
                                  "tips": "Ignore transientes; foque em t → ∞ para estacionário.",
                                  "learningObjective": "Converter espectro Y(jω) de volta para forma temporal estacionária.",
                                  "commonMistakes": "Incluir transientes na inversa; errar sinal de fase na soma."
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola-amortecedor (mÿ + cẏ + ky = f(t)) com entrada f(t) = cos(ω t), ω=10 rad/s. Derive H(jω) = 1/( -mω² + j c ω + k ), compute Y(jω), e encontre y(t) = |H(j10)| cos(10 t + ∠H(j10)). Simule em MATLAB para verificar.",
                              "finalVerifications": [
                                "Y(jω) = H(jω) X(jω) corretamente calculado em pelo menos 3 frequências.",
                                "y(t) estacionária matches forma A' cos(ω t + φ').",
                                "Plota de Bode de Y(jω) mostra ressonâncias corretas.",
                                "Simulação temporal confirma steady-state sem transientes.",
                                "Unidades consistentes em tempo/frequência.",
                                "Fase wrap-around gerenciada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de H(jω) e X(jω) (90%+ correto).",
                                "Correta multiplicação espectral e cálculo de magnitude/fase.",
                                "Inversão para y(t) sem erros de fase ou amplitude.",
                                "Interpretação física (ex: amplificação em ressonância).",
                                "Uso adequado de ferramentas computacionais.",
                                "Documentação clara com plots e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Controle: Uso em diagramas de Bode para estabilidade.",
                                "Vibrações e Aeroelasticidade: Previsão de flutter em asas.",
                                "Processamento de Sinais: Filtros em telemetria aeronáutica.",
                                "Simulações Numéricas: Integração com FEM para estruturas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, usado para prever respostas vibratórias de fuselagens a turbulência ou motores, evitando fadiga estrutural via análise de FRF em testes de solo/modal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Função de Transferência e Resposta em Frequência",
                "description": "Explora propriedades da função de transferência e função de resposta em frequência para análise de sistemas.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Definição de Função de Transferência",
                    "description": "Representação em domínio de Laplace da relação entrada-saída para sistemas lineares invariantes no tempo (LTI).",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Sistemas Lineares Invariantes no Tempo (LTI)",
                        "description": "Sistemas dinâmicos lineares e invariantes no tempo, fundamentais para a definição de função de transferência, caracterizados por superposição e invariância temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir linearidade em sistemas dinâmicos",
                            "description": "Explicar a propriedade de linearidade como a satisfação do princípio de superposição para adição e escalonamento de entradas, com exemplos de sistemas lineares contínuos no tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Sistemas Dinâmicos",
                                  "subSteps": [
                                    "Defina um sistema dinâmico como um processo que relaciona entradas a saídas ao longo do tempo.",
                                    "Diferencie sistemas lineares de não-lineares usando exemplos simples como amplificadores versus diodos.",
                                    "Revise a notação matemática: y(t) = T[x(t)] para sistemas contínuos no tempo.",
                                    "Identifique sistemas invariantes no tempo (LTI) como pré-requisito para linearidade.",
                                    "Estude a importância da linearidade em análise de frequência e funções de transferência."
                                  ],
                                  "verification": "Resuma em suas palavras o que é um sistema dinâmico e liste 2 exemplos lineares e 2 não-lineares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim)",
                                    "Caderno para anotações",
                                    "Vídeo introdutório sobre LTI systems (YouTube/Khan Academy)"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como molas lineares vs. não-lineares, para fixar o conceito.",
                                  "learningObjective": "Compreender os fundamentos de sistemas dinâmicos e o papel da linearidade.",
                                  "commonMistakes": [
                                    "Confundir linearidade com proporcionalidade simples",
                                    "Ignorar a invariância no tempo",
                                    "Usar exemplos discretos em vez de contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Princípio de Aditividade (Superposição)",
                                  "subSteps": [
                                    "Defina aditividade: T[x1(t) + x2(t)] = T[x1(t)] + T[x2(t)].",
                                    "Derive matematicamente para um sistema integrador simples: y(t) = ∫x(τ)dτ.",
                                    "Teste com duas entradas senoidais: some-as e aplique o operador do sistema.",
                                    "Compare com um sistema não-linear como y(t) = x(t)^2 para mostrar falha na aditividade.",
                                    "Pratique com equações diferenciais lineares homogêneas."
                                  ],
                                  "verification": "Verifique se T[sin(t) + cos(t)] = T[sin(t)] + T[cos(t)] para um filtro passa-baixa ideal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy para simulação)",
                                    "Folha de exercícios com equações diferenciais",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use gráficos para visualizar saídas somadas vs. soma de saídas individuais.",
                                  "learningObjective": "Dominar a propriedade de aditividade e demonstrá-la com exemplos.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar entradas",
                                    "Confundir com convolução prematuramente",
                                    "Não testar com entradas zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Princípio de Homogeneidade (Escalonamento)",
                                  "subSteps": [
                                    "Defina homogeneidade: T[a * x(t)] = a * T[x(t)] para constante a.",
                                    "Combine com aditividade para formar superposição completa.",
                                    "Aplique a um sistema RC: derive a resposta escalonada.",
                                    "Teste falha em sistemas não-lineares como y(t) = |x(t)|.",
                                    "Estenda para escalonamento complexo usando álgebra linear básica."
                                  ],
                                  "verification": "Mostre que para um sistema LTI, T[2*sin(ωt)] = 2*T[sin(ωt)].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulador online de circuitos (Falstad ou LTSpice)",
                                    "Exercícios impressos de superposição",
                                    "Notebook Jupyter para plotagens"
                                  ],
                                  "tips": "Escolha valores de 'a' pequenos e grandes para observar linearidade.",
                                  "learningObjective": "Compreender e aplicar a homogeneidade em sistemas contínuos.",
                                  "commonMistakes": [
                                    "Aplicar escalonamento após saturação não-linear",
                                    "Ignorar fase em sinais senoidais",
                                    "Confundir com normalização de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Linearidade em Exemplos de Sistemas Contínuos LTI",
                                  "subSteps": [
                                    "Analise um circuito RLC série como sistema linear.",
                                    "Verifique superposição com entradas degrau e rampa.",
                                    "Conecte à função de transferência: H(s) = Y(s)/X(s) só válida para LTI.",
                                    "Discuta aproximações lineares em aeronáutica (ex: aerodinâmica em baixos ângulos).",
                                    "Resolva um problema completo: determine se dado sistema é linear."
                                  ],
                                  "verification": "Resolva um exercício onde você prova linearidade de uma equação diferencial de 2ª ordem.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Livro de Engenharia Aeronáutica (capítulo de controle)",
                                    "MATLAB para simular respostas",
                                    "Lista de problemas resolvidos"
                                  ],
                                  "tips": "Sempre verifique as condições de operação linear (sem saturação).",
                                  "learningObjective": "Integrar conceitos em exemplos práticos de sistemas LTI contínuos.",
                                  "commonMistakes": [
                                    "Assumir linearidade sem verificar superposição",
                                    "Misturar domínios tempo e frequência cedo demais",
                                    "Omitir unidades em exemplos físicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de asa de aeronave modelado por equação diferencial linear mẍ + bẋ + kx = F(t), verifique linearidade aplicando superposição a duas forças de vento senoidais distintas e confirmando que a resposta total é a soma das respostas individuais.",
                              "finalVerifications": [
                                "Defina corretamente linearidade usando superposição.",
                                "Forneça 3 exemplos de sistemas lineares contínuos e prove um.",
                                "Identifique e explique por que um sistema quadrático não é linear.",
                                "Aplique superposição a um sinal composto em um filtro LTI.",
                                "Explique relevância para funções de transferência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de aditividade e homogeneidade (30%)",
                                "Qualidade de exemplos e provas matemáticas (25%)",
                                "Correta identificação de sistemas LTI vs. não-lineares (20%)",
                                "Uso apropriado de gráficos/simulações para verificação (15%)",
                                "Conexão clara com aplicações em frequência (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e princípios de superposição vetorial.",
                                "Física: Dinâmica de sistemas mecânicos e elétricos lineares.",
                                "Engenharia de Controle: Modelagem LTI para estabilidade de aeronaves.",
                                "Processamento de Sinais: Análise em domínio da frequência."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a linearidade permite modelar a dinâmica de voo com funções de transferência para design de sistemas de controle automático, como autopilotos que estabilizam aeronaves sob perturbações de vento usando superposição de modos de falha."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Definir invariância no tempo",
                            "description": "Descrever a invariância temporal como a propriedade em que o deslocamento temporal da entrada resulta no mesmo deslocamento na saída, ilustrando com equações diferenciais lineares com coeficientes constantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito intuitivo de invariância temporal",
                                  "subSteps": [
                                    "Analise um sinal de entrada x(t) e sua saída y(t) de um sistema.",
                                    "Aplique um deslocamento temporal à entrada, criando x(t - τ).",
                                    "Observe que a saída deve ser y(t - τ) para o sistema ser invariante no tempo.",
                                    "Compare com sistemas dependentes do tempo, onde o shift altera o ganho.",
                                    "Desenhe gráficos ilustrativos para visualização."
                                  ],
                                  "verification": "Desenhar e rotular gráficos de x(t), y(t), x(t-τ) e y(t-τ) mostrando sobreposição perfeita após shift.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, exemplos gráficos de sinais (seno, degrau).",
                                  "tips": "Use sinais simples como degrau ou seno para visualizar shifts facilmente.",
                                  "learningObjective": "Internalizar intuitivamente que o sistema 'não envelhece' com o tempo.",
                                  "commonMistakes": "Confundir invariância temporal com estacionariedade estatística de sinais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a definição matemática de invariância temporal",
                                  "subSteps": [
                                    "Estude a propriedade: Se y(t) = T{x(t)}, então y(t - τ) = T{x(t - τ)} para todo τ.",
                                    "Denote o operador do sistema como T{·}.",
                                    "Escreva a definição em notação matemática formal.",
                                    "Diferencie de sistemas variantes no tempo, como y(t) = a(t)x(t).",
                                    "Pratique reescrevendo a definição com símbolos específicos."
                                  ],
                                  "verification": "Escrever a definição formal corretamente e dar um contraexemplo de sistema variante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno de anotações, quadro branco ou software como LaTeX para equações.",
                                  "tips": "Lembre-se: o sistema responde da mesma forma independentemente de 'quando' a entrada ocorre.",
                                  "learningObjective": "Dominar a notação matemática precisa da propriedade de time-invariance.",
                                  "commonMistakes": "Esquecer que vale para todo τ e toda entrada x(t)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ilustrar com equações diferenciais lineares de coeficientes constantes",
                                  "subSteps": [
                                    "Considere uma EDO como y''(t) + 2y'(t) + y(t) = x(t).",
                                    "Mostre que coeficientes constantes implicam LTI (linear e time-invariant).",
                                    "Aplique shift: substitua t por t-τ e verifique que a EDO permanece idêntica.",
                                    "Compare com EDO variante: y''(t) + t y'(t) + y(t) = x(t), onde shift altera coeficientes.",
                                    "Resolva um exemplo simples numericamente para τ=1s."
                                  ],
                                  "verification": "Derivar a EDO shiftada e confirmar igualdade com a original.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (Wolfram Alpha ou MATLAB), exemplos de EDOs impressos.",
                                  "tips": "Coeficientes constantes são a chave: eles não dependem de t.",
                                  "learningObjective": "Conectar invariância temporal a EDOs lineares com coeficientes constantes.",
                                  "commonMistakes": "Achar que toda EDO linear é invariante, ignorando coeficientes variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e sintetizar o conceito em sistemas LTI",
                                  "subSteps": [
                                    "Revise as propriedades combinadas: linearidade + invariância temporal = LTI.",
                                    "Discuta implicações para função de transferência H(s).",
                                    "Crie um fluxograma de verificação de time-invariance.",
                                    "Teste com um exemplo prático de engenharia aeronáutica.",
                                    "Resuma em uma frase própria a definição completa."
                                  ],
                                  "verification": "Criar um fluxograma correto e explicar verbalmente para um par.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de diagramação (Draw.io), resumo escrito.",
                                  "tips": "LTI permite Laplace e frequência domain analysis simples.",
                                  "learningObjective": "Integrar o conceito no framework maior de sistemas LTI.",
                                  "commonMistakes": "Separar linearidade de time-invariance como independentes sem conexão."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de um drone, a equação y''(t) + 0.5 y'(t) + y(t) = u(t) modela a resposta ao comando u(t). Se u(t) é atrasado em 0.2s (u(t-0.2)), a resposta y(t) também atrasa exatamente 0.2s, preservando forma e amplitude, permitindo previsibilidade em manobras de voo.",
                              "finalVerifications": [
                                "Define corretamente invariância temporal com notação T{x(t-τ)} = y(t-τ).",
                                "Distingue EDOs com coeficientes constantes de variantes no tempo.",
                                "Desenha gráficos de shift corretos sem distorções.",
                                "Explica ligação com sistemas LTI e função de transferência.",
                                "Identifica exemplo real de sistema invariante.",
                                "Fornece contraexemplo válido de sistema variante."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (80% correto).",
                                "Qualidade dos gráficos e ilustrações (clareza e exatidão).",
                                "Correta derivação de shift em EDOs (passos lógicos).",
                                "Profundidade na distinção LTI vs. não-LTI.",
                                "Criatividade e relevância do exemplo prático.",
                                "Síntese clara em resumo verbal/escrito."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações diferenciais ordinárias (EDOs).",
                                "Física: Dinâmica de sistemas mecânicos e elétricos.",
                                "Informática: Simulações em MATLAB/Simulink para validação.",
                                "Engenharia de Controle: Análise em domínio de frequência."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, sistemas LTI invariantes no tempo são fundamentais para modelar autômatos de voo em aviões comerciais, garantindo que comandos de piloto atrasados resultem em respostas previsíveis e estáveis, essencial para certificação de segurança pela ANAC/FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Identificar propriedades de sistemas LTI",
                            "description": "Listar e exemplificar propriedades como causalidade, estabilidade e representabilidade por convolução, relacionando com análise em domínio de Laplace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Características Básicas de Sistemas LTI",
                                  "subSteps": [
                                    "Defina sistema linear invariante no tempo (LTI) como um sistema que satisfaz superposição e invariância temporal.",
                                    "Explique a representação em domínio do tempo via equação diferencial linear com coeficientes constantes.",
                                    "Discuta a importância da função de transferência H(s) no domínio de Laplace para sistemas LTI.",
                                    "Identifique exemplos simples, como um filtro RC de primeira ordem.",
                                    "Compare LTI com sistemas não-lineares ou variantes no tempo."
                                  ],
                                  "verification": "Resuma em um parágrafo as características básicas de LTI e forneça um exemplo de equação diferencial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim), notas de aula sobre Laplace, calculadora simbólica (MATLAB/SymPy)"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar a invariância temporal.",
                                  "learningObjective": "Compreender os fundamentos que distinguem sistemas LTI de outros.",
                                  "commonMistakes": [
                                    "Confundir linearidade com não-linearidade; ignorar a invariância temporal em exemplos variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedade de Causalidade em Sistemas LTI",
                                  "subSteps": [
                                    "Defina causalidade: saída em t depende apenas de entradas para τ ≤ t.",
                                    "Relacione com função de transferência: polo no semiplano direito implica não-causalidade.",
                                    "Examine impulse response h(t) = 0 para t < 0 em sistemas causais.",
                                    "Teste causalidade em um exemplo: sistema y'(t) + y(t) = x(t).",
                                    "Discuta implicações em simulações reais, como delays em aeronáutica."
                                  ],
                                  "verification": "Classifique 3 funções de transferência como causais ou não, justificando com polos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de transformadas de Laplace, software MATLAB para plotar respostas ao impulso"
                                  ],
                                  "tips": "Verifique sempre o suporte da resposta ao impulso.",
                                  "learningObjective": "Identificar e justificar causalidade usando domínio de Laplace.",
                                  "commonMistakes": [
                                    "Assumir causalidade sem verificar polos; confundir com estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedade de Estabilidade em Sistemas LTI",
                                  "subSteps": [
                                    "Defina estabilidade BIBO: entrada limitada implica saída limitada.",
                                    "Critério de Routh-Hurwitz para polos no semiplano esquerdo.",
                                    "Analise estabilidade via resposta em frequência ou margens de ganho/fase.",
                                    "Exemplo: sistema com polos em s = -1 ± j, estável; s = 1, instável.",
                                    "Relacione com aplicações em controle de aeronaves."
                                  ],
                                  "verification": "Aplique critério de Routh a uma função de transferência de 2ª ordem e conclua sobre estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de Routh, MATLAB Control System Toolbox"
                                  ],
                                  "tips": "Comece com polos simples antes de ordens altas.",
                                  "learningObjective": "Avaliar estabilidade de LTI via Laplace e critérios padrão.",
                                  "commonMistakes": [
                                    "Confundir estabilidade assintótica com BIBO; ignorar polos imaginários puros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Representabilidade por Convolução e Relação com Laplace",
                                  "subSteps": [
                                    "Mostre que saída y(t) = h(t) * x(t) para LTI, onde * é convolução.",
                                    "Transforme para domínio Laplace: Y(s) = H(s) X(s).",
                                    "Exemplo numérico: convolução discreta aproximada para filtro passa-baixa.",
                                    "Discuta eficiência computacional via FFT para simulações.",
                                    "Aplique em análise de sistemas dinâmicos aeronáuticos."
                                  ],
                                  "verification": "Compute convolução analítica ou numérica para um par h(t), x(t) e verifique via Laplace.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python (SciPy para convolução), exemplos de funções de transferência"
                                  ],
                                  "tips": "Use propriedades de Laplace para simplificar cálculos.",
                                  "learningObjective": "Demonstrar representabilidade por convolução e equivalência em Laplace.",
                                  "commonMistakes": [
                                    "Erros em limites de integração na convolução; esquecer normalização em FFT."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Propriedades em Análise Completa de Sistemas LTI",
                                  "subSteps": [
                                    "Liste propriedades: causalidade, estabilidade, convolução, lineares/invariantes.",
                                    "Analise um sistema completo: verifique todas propriedades.",
                                    "Relacione com resposta em frequência via H(jω).",
                                    "Crie fluxograma para identificação de propriedades.",
                                    "Teste com caso real de controle de atitude em aeronave."
                                  ],
                                  "verification": "Produza relatório curto analisando propriedades de um sistema LTI dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Casos de estudo em Engenharia Aeronáutica, simulador Simulink"
                                  ],
                                  "tips": "Use checklist para não omitir propriedades.",
                                  "learningObjective": "Sintetizar identificação de todas propriedades principais de LTI.",
                                  "commonMistakes": [
                                    "Não relacionar de volta ao domínio de Laplace; generalizações sem exemplos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de elevador de aeronave modelado como G(s) = 1/(s^2 + 2s + 1), identifique: causal (h(t)=0 para t<0), estável (polos reais negativos), representável por convolução y(t) = ∫ h(τ)x(t-τ)dτ, verificado via Laplace.",
                              "finalVerifications": [
                                "Liste corretamente causalidade, estabilidade e convolução com definições.",
                                "Classifique 2 sistemas LTI como causais/estáveis com justificativa em polos.",
                                "Compute saída via convolução para input unitário e verifique com H(s)X(s).",
                                "Explique relação entre propriedades e análise em Laplace.",
                                "Identifique erro comum em um exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de propriedades (90%+ correto).",
                                "Uso correto de Laplace para verificações (polos, H(s)).",
                                "Exemplos relevantes e cálculos sem erros.",
                                "Integração de propriedades em análise coesa.",
                                "Criatividade em aplicações aeronáuticas.",
                                "Clareza em verificações e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Estabilidade em laços fechados.",
                                "Processamento de Sinais: Filtros LTI em telemetria.",
                                "Matemática Aplicada: Transformadas e critérios de Routh.",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor como LTI."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, identificar propriedades LTI em modelos de função de transferência permite projetar sistemas de controle de voo estáveis e causais, como estabilização de atitude em drones ou aviões comerciais, evitando oscilações perigosas via análise de polos em Laplace."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1",
                              "10.1.3.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Transformada de Laplace para Sinais e Sistemas",
                        "description": "Ferramenta matemática no domínio de Laplace que transforma equações diferenciais em tempo em funções algébricas, essencial para representar relações entrada-saída.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Calcular a transformada de Laplace de sinais básicos",
                            "description": "Aplicar a transformada de Laplace unilateral ∫ e^{-st} f(t) dt de 0 a ∞ para funções como degrau unitário, rampa e exponencial, obtendo expressões como 1/s, 1/s² e 1/(s+a).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição da Transformada de Laplace Unilateral",
                                  "subSteps": [
                                    "Revise a fórmula da transformada de Laplace unilateral: F(s) = ∫_{0}^{∞} f(t) e^{-st} dt.",
                                    "Identifique as condições de convergência: Re(s) > σ, onde σ é a parte real necessária para convergência.",
                                    "Diferencie transformada unilateral (t≥0) de bilateral (t de -∞ a ∞).",
                                    "Discuta o sinal u(t) (degrau unitário) como multiplicador para causalidade.",
                                    "Esboce graficamente f(t) e e^{-st} para visualização intuitiva."
                                  ],
                                  "verification": "Escreva a fórmula corretamente e explique verbalmente as condições de convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Calculadora científica",
                                    "Tabela de transformadas de Laplace básica"
                                  ],
                                  "tips": "Sempre inclua u(t) implicitamente para sinais causais; foque em Re(s)>0 inicialmente.",
                                  "learningObjective": "Dominar a definição formal e intuitiva da transformada de Laplace unilateral.",
                                  "commonMistakes": [
                                    "Confundir unilateral com bilateral",
                                    "Ignorar limites de integração de 0 a ∞",
                                    "Esquecer o fator e^{-st}"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Transformada do Degrau Unitário u(t)",
                                  "subSteps": [
                                    "Defina f(t) = u(t), onde u(t)=1 para t≥0 e 0 caso contrário.",
                                    "Escreva a integral: F(s) = ∫_{0}^{∞} e^{-st} * 1 dt.",
                                    "Resolva a integral: [-1/s e^{-st}]_{0}^{∞} = 0 - (-1/s) = 1/s, para Re(s)>0.",
                                    "Verifique convergência: limite em ∞ é 0 se Re(s)>0.",
                                    "Confirme com tabela: Laplace{u(t)} = 1/s."
                                  ],
                                  "verification": "Obtenha F(s) = 1/s e justifique a convergência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Calculadora"
                                  ],
                                  "tips": "Use a propriedade do limite exponencial decaindo para ∞.",
                                  "learningObjective": "Aplicar a definição para obter Laplace do degrau unitário.",
                                  "commonMistakes": [
                                    "Integrar de -∞ a ∞",
                                    "Esquecer de avaliar limites corretamente",
                                    "Não especificar Re(s)>0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Transformada da Rampa Unitária t u(t)",
                                  "subSteps": [
                                    "Defina f(t) = t u(t).",
                                    "Escreva F(s) = ∫_{0}^{∞} t e^{-st} dt.",
                                    "Aplique integração por partes: u=t, dv=e^{-st}dt → du=dt, v=-1/s e^{-st}.",
                                    "Resolva: [ -t/s e^{-st} ]_{0}^{∞} + (1/s) ∫_{0}^{∞} e^{-st} dt = 0 + (1/s)(1/s) = 1/s², Re(s)>0.",
                                    "Verifique com propriedade: Laplace{t f(t)} = -d/ds F(s), de 1/s para 1/s²."
                                  ],
                                  "verification": "Derive F(s)=1/s² mostrando passos de integração por partes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Lembre-se da fórmula de integração por partes: ∫ u dv = uv - ∫ v du.",
                                  "learningObjective": "Mestre integração por partes na transformada de Laplace para polinômios lineares.",
                                  "commonMistakes": [
                                    "Erros nos limites da integração por partes",
                                    "Confundir com Laplace de t (sem u(t))",
                                    "Ignorar segunda integração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Transformada da Exponencial e^{-at} u(t)",
                                  "subSteps": [
                                    "Defina f(t) = e^{-at} u(t), a>0.",
                                    "Escreva F(s) = ∫_{0}^{∞} e^{-at} e^{-st} dt = ∫_{0}^{∞} e^{-(s+a)t} dt.",
                                    "Resolva: [-1/(s+a) e^{-(s+a)t}]_{0}^{∞} = 0 - (-1/(s+a)) = 1/(s+a), Re(s)>-a.",
                                    "Verifique convergência: Re(s+a)>0.",
                                    "Confirme com tabela e propriedade de deslocamento."
                                  ],
                                  "verification": "Obtenha F(s)=1/(s+a) e especifique região de convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Calculadora"
                                  ],
                                  "tips": "Substitua s' = s+a para simplificar a integral.",
                                  "learningObjective": "Aplicar a definição para funções exponenciais com deslocamento.",
                                  "commonMistakes": [
                                    "Esquecer u(t)",
                                    "Erro no expoente combinado -(s+a)t",
                                    "Região de convergência errada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Resultados e Explorar Generalizações",
                                  "subSteps": [
                                    "Compare resultados com tabela padrão de Laplace.",
                                    "Teste numericamente: escolha s=2, compute integral aproximada vs analítica.",
                                    "Discuta linearidade: Laplace{α f(t) + β g(t)} = α F(s) + β G(s).",
                                    "Identifique padrões para potências e exponenciais.",
                                    "Pratique com variação: rampa exponencial at e^{-bt} u(t)."
                                  ],
                                  "verification": "Resolva um exemplo combinado corretamente e compare com tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Wolfram Alpha (opcional)",
                                    "Tabela de Laplace completa"
                                  ],
                                  "tips": "Use tabelas para validação rápida após derivação.",
                                  "learningObjective": "Consolidar cálculos e introduzir propriedades básicas.",
                                  "commonMistakes": [
                                    "Não verificar numericamente",
                                    "Ignorar linearidade em combinações",
                                    "Generalizar sem convergência"
                                  ]
                                },
                                {
                                  "practicalExample": "Calcule a transformada de Laplace de f(t) = u(t) + 2 t u(t) + e^{-3t} u(t), obtendo F(s) = 1/s + 2/s² + 1/(s+3), e verifique em s=4.",
                                  "stepNumber": 1,
                                  "title": "Exemplo Prático: Cálculo da Transformada de Laplace de f(t) = u(t) + 2 t u(t) + e^{-3t} u(t)",
                                  "subSteps": [
                                    "1. Identifique os termos individuais da função: u(t), 2t u(t) e e^{-3t} u(t), aproveitando a linearidade da transformada de Laplace.",
                                    "2. Calcule L{u(t)} = 1/s.",
                                    "3. Calcule L{2t u(t)} = 2 L{t u(t)} = 2/s².",
                                    "4. Calcule L{e^{-3t} u(t)} = 1/(s+3).",
                                    "5. Some os resultados: F(s) = 1/s + 2/s² + 1/(s+3)."
                                  ],
                                  "verification": "Avalie F(s) em s=4: F(4) = 1/4 + 2/16 + 1/7 ≈ 0,25 + 0,125 + 0,1429 ≈ 0,5179. Verifique usando uma calculadora ou software como MATLAB/SymPy.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora ou software simbólico (opcional)"
                                  ],
                                  "tips": [
                                    "Use a propriedade de linearidade para somar transformadas de cada termo.",
                                    "Lembre-se que u(t) indica causalidade, com L{u(t)} = 1/s para s > 0."
                                  ],
                                  "learningObjective": "Aplicar a transformada de Laplace a funções piecewise com degrau unitário, exponenciais e polinômios, utilizando linearidade e verificação numérica.",
                                  "commonMistakes": [
                                    "Esquecer o coeficiente 2 em L{2t u(t)}, resultando em 1/s².",
                                    "Confundir L{t u(t)} = 1/s² com L{u(t)}.",
                                    "Não considerar o domínio de convergência (s > 0).",
                                    "Erros aritméticos na soma dos termos."
                                  ]
                                },
                                {
                                  "finalVerifications": [
                                    "Deriva corretamente Laplace{u(t)} = 1/s com passos completos.",
                                    "Obtém Laplace{t u(t)} = 1/s² via integração por partes sem erros.",
                                    "Calcula Laplace{e^{-at} u(t)} = 1/(s+a) especificando Re(s) > -a.",
                                    "Aplica linearidade para soma de sinais básicos.",
                                    "Compara resultados com tabela padrão sem discrepâncias."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão matemática nos cálculos de integrais (100% correto).",
                                    "Clareza na apresentação de passos e justificativas de limites.",
                                    "Correta identificação de regiões de convergência.",
                                    "Uso apropriado de propriedades como integração por partes e linearidade.",
                                    "Capacidade de verificação numérica ou tabular."
                                  ],
                                  "crossCurricularConnections": [
                                    "Matemática: Cálculo integral avançado e séries de potências.",
                                    "Física: Análise de circuitos RC/RL e sistemas massa-mola.",
                                    "Engenharia Elétrica: Resolução de equações diferenciais em regime transitório.",
                                    "Computação: Implementação numérica em MATLAB/Simulink para simulações.",
                                    "Controle Automático: Modelagem de plantas em espaço de Laplace."
                                  ],
                                  "realWorldApplication": "Em engenharia aeronáutica, a transformada de Laplace de sinais básicos é essencial para modelar funções de transferência de sistemas de controle de voo, como respostas a comandos de degrau (manobras abruptas) ou ramps (acelerações suaves), permitindo análise de estabilidade e projeto de controladores PID para aviões.",
                                  "stepNumber": "4.2",
                                  "title": "Derivação da Transformada de Laplace de Sinais Básicos",
                                  "subSteps": [
                                    "Definir a transformada de Laplace unilateral: L{f(t)} = ∫_{0}^∞ f(t) e^{-st} dt, com Re(s) > σ.",
                                    "Derivar L{u(t)} = ∫_{0}^∞ e^{-st} dt = 1/s, para Re(s) > 0.",
                                    "Calcular L{t u(t)} = ∫_{0}^∞ t e^{-st} dt usando integração por partes (u = t, dv = e^{-st} dt).",
                                    "Obter L{e^{-at} u(t)} = ∫_{0}^∞ e^{-(s+a)t} dt = 1/(s+a), para Re(s) > -a.",
                                    "Aplicar propriedade de linearidade: L{α f(t) + β g(t)} = α L{f(t)} + β L{g(t)} para combinações de sinais básicos."
                                  ],
                                  "verification": "Derivações exatas com passos mostrados, regiões de convergência corretas e comparação com tabela padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos manuais",
                                    "Tabela de integrais básicas",
                                    "Calculadora científica",
                                    "Tabela padrão de transformadas de Laplace"
                                  ],
                                  "tips": [
                                    "Sempre inicie a integral em t=0 (devido à unilateralidade e u(t)).",
                                    "Verifique a convergência: Re(s) deve ser maior que o maior polo real.",
                                    "Na integração por partes, lembre-se: ∫ u dv = u v - ∫ v du.",
                                    "Compare resultados com tabela para validação imediata."
                                  ],
                                  "learningObjective": "O aluno será capaz de derivar analiticamente as transformadas de Laplace das funções degrau unitário u(t), rampa t u(t) e exponencial e^{-at} u(t), aplicando integração por partes e linearidade, identificando regiões de convergência.",
                                  "commonMistakes": [
                                    "Integrar de -∞ a ∞ em vez de 0 a ∞ (transformada bilateral errada).",
                                    "Esquecer o sinal negativo em e^{-st} ou erro em du/dv na integração por partes.",
                                    "Não especificar a região de convergência (ex: Re(s) > 0 para u(t)).",
                                    "Aplicar linearidade sem considerar causalidade ou ROC da soma.",
                                    "Confundir L{t} com 1/s (esquecendo u(t))."
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a transformada de Laplace de f(t) = u(t) + 2 t u(t) + e^{-3t} u(t), obtendo F(s) = 1/s + 2/s² + 1/(s+3), e verifique em s=4.",
                              "finalVerifications": [
                                "Deriva corretamente Laplace{u(t)} = 1/s com passos completos.",
                                "Obtém Laplace{t u(t)} = 1/s² via integração por partes sem erros.",
                                "Calcula Laplace{e^{-at} u(t)} = 1/(s+a) especificando Re(s) > -a.",
                                "Aplica linearidade para soma de sinais básicos.",
                                "Compara resultados com tabela padrão sem discrepâncias."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de integrais (100% correto).",
                                "Clareza na apresentação de passos e justificativas de limites.",
                                "Correta identificação de regiões de convergência.",
                                "Uso apropriado de propriedades como integração por partes e linearidade.",
                                "Capacidade de verificação numérica ou tabular."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral avançado e séries de potências.",
                                "Física: Análise de circuitos RC/RL e sistemas massa-mola.",
                                "Engenharia Elétrica: Resolução de equações diferenciais em regime transitório.",
                                "Computação: Implementação numérica em MATLAB/Simulink para simulações.",
                                "Controle Automático: Modelagem de plantas em espaço de Laplace."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, a transformada de Laplace de sinais básicos é essencial para modelar funções de transferência de sistemas de controle de voo, como respostas a comandos de degrau (manobras abruptas) ou ramps (acelerações suaves), permitindo análise de estabilidade e projeto de controladores PID para aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Representar resposta ao impulso em domínio de Laplace",
                            "description": "Explicar que a transformada de Laplace da resposta ao impulso h(t) é H(s), permitindo análise de sistemas LTI via multiplicação no domínio s.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Resposta ao Impulso e Transformada de Laplace",
                                  "subSteps": [
                                    "Defina resposta ao impulso h(t) como a saída de um sistema LTI para entrada δ(t).",
                                    "Revise a transformada de Laplace unilateral: X(s) = ∫[0^∞] x(t) e^{-st} dt.",
                                    "Identifique que para sistemas causais, a transformada de h(t) é H(s).",
                                    "Estude propriedades como linearidade e convolução no domínio do tempo virando multiplicação no s.",
                                    "Examine exemplos simples de h(t), como degrau unitário ou exponencial."
                                  ],
                                  "verification": "Resuma em suas palavras a relação entre h(t) e H(s), citando a definição matemática.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Tabelas de transformadas de Laplace",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar sistemas LTI.",
                                  "learningObjective": "Compreender a base conceitual ligando tempo e domínio s.",
                                  "commonMistakes": [
                                    "Confundir transformada bilateral com unilateral",
                                    "Esquecer causalidade em sistemas reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Transformada de Laplace da Resposta ao Impulso h(t)",
                                  "subSteps": [
                                    "Selecione um h(t) conhecido, ex: h(t) = e^{-at} u(t).",
                                    "Aplique a integral da transformada: H(s) = ∫[0^∞] h(t) e^{-st} dt.",
                                    "Resolva a integral passo a passo, usando integração por partes se necessário.",
                                    "Verifique com tabela de Laplace para confirmação.",
                                    "Generalize para formas comuns como polos e zeros."
                                  ],
                                  "verification": "Compute L{h(t)} para h(t) = e^{-2t} u(t) e confira H(s) = 1/(s+2).",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Folha de exercícios de Laplace",
                                    "Software MATLAB/SymPy para verificação",
                                    "Tabela de transformadas"
                                  ],
                                  "tips": "Comece com funções simples para construir confiança.",
                                  "learningObjective": "Dominar o cálculo explícito de H(s) a partir de h(t).",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Ignorar a função degrau u(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar H(s) como Função de Transferência em Sistemas LTI",
                                  "subSteps": [
                                    "Relacione H(s) = Y(s)/X(s) para entrada X(s) e saída Y(s).",
                                    "Demonstre que Y(s) = H(s) X(s) para análise no domínio s.",
                                    "Plote polos e zeros de H(s) no plano s.",
                                    "Analise estabilidade via posição de polos (Re(s) < 0).",
                                    "Conecte de volta ao tempo: h(t) = L^{-1}{H(s)}."
                                  ],
                                  "verification": "Dado H(s) = 1/(s+1), encontre y(t) para x(t)=δ(t) e confirme h(t)=e^{-t}u(t).",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "MATLAB para plotar polos/zeros",
                                    "Simulador de sistemas (Octave)",
                                    "Notas de função de transferência"
                                  ],
                                  "tips": "Use a regra da mão esquerda para estabilidade rápida.",
                                  "learningObjective": "Associar representação em s à análise de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir H(s) com resposta em frequência",
                                    "Esquecer inversa de Laplace"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em um Exemplo de Sistema Aeronáutico",
                                  "subSteps": [
                                    "Modele um sistema simples de amortecedor em aeronave: mẍ + cẋ + kx = f(t).",
                                    "Encontre h(t) no tempo e compute H(s).",
                                    "Simule resposta a impulso em software.",
                                    "Compare domínios tempo e s para validação.",
                                    "Discuta implicações para controle de vibrações."
                                  ],
                                  "verification": "Gere gráfico de h(t) e |H(jω)|, explicando correspondências.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Exemplo de equação diferencial de 2ª ordem"
                                  ],
                                  "tips": "Escolha parâmetros realistas: m=1, c=2, k=1 para subamortecido.",
                                  "learningObjective": "Aplicar conceito em contexto engenharia aeronáutica.",
                                  "commonMistakes": [
                                    "Normalizar incorretamente a equação",
                                    "Ignorar condições iniciais zero"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flap de aeronave modelado como H(s) = ω_n^2 / (s^2 + 2ζω_n s + ω_n^2), compute L{h(t)} onde h(t) é a resposta ao impulso δ(t), simulando vibração inicial e confirmando estabilidade via polos.",
                              "finalVerifications": [
                                "Calcula corretamente H(s) para pelo menos 3 h(t) diferentes.",
                                "Explica verbalmente a multiplicação Y(s)=H(s)X(s) sem erros.",
                                "Plota e interpreta polos/zeros de H(s).",
                                "Simula resposta em software e valida com teoria.",
                                "Identifica sistemas estáveis a partir de H(s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de Laplace (90%+ correto).",
                                "Profundidade na interpretação de H(s) como função de transferência.",
                                "Criatividade em exemplos aplicados a aeronáutica.",
                                "Capacidade de debugar erros comuns em simulações.",
                                "Integração conceitual entre tempo e domínio s.",
                                "Clareza em verificações e documentação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de integrais e funções complexas.",
                                "Controle Automático: Projeto de controladores via H(s).",
                                "Física: Dinâmica de vibrações em estruturas aeronáuticas.",
                                "Programação: Uso de MATLAB para análise numérica.",
                                "Engenharia Mecânica: Modelagem de sistemas massa-mola-amortecedor."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, representar h(t) como H(s) permite analisar estabilidade de sistemas de controle de voo, prever respostas a perturbações como rajadas de vento, e otimizar filtros em aviônicos para supressão de ruído em sinais de sensores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1",
                              "10.1.3.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Usar propriedades da transformada de Laplace",
                            "description": "Aplicar propriedades como derivada (sF(s) - f(0)), convolução (multiplicação em s) e teorema do valor inicial/final para simplificar equações de sistemas LTI.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e memorizar propriedades básicas da transformada de Laplace para derivadas e teoremas de valor",
                                  "subSteps": [
                                    "Estude a propriedade da derivada: L{f'(t)} = sF(s) - f(0)",
                                    "Aprenda o teorema do valor inicial: lim t->0 f(t) = lim s->∞ sF(s)",
                                    "Memorize o teorema do valor final: lim t->∞ f(t) = lim s->0 sF(s)",
                                    "Pratique com funções simples como exponenciais e senos",
                                    "Derive essas propriedades a partir da definição integral da Laplace"
                                  ],
                                  "verification": "Resolva 3 exercícios simples e compare com soluções conhecidas",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Caderno de anotações",
                                    "Software SymPy ou MATLAB"
                                  ],
                                  "tips": "Sempre verifique as condições iniciais f(0) antes de aplicar",
                                  "learningObjective": "Dominar as fórmulas exatas para derivadas e limites iniciais/finais",
                                  "commonMistakes": [
                                    "Esquecer de subtrair f(0) na derivada",
                                    "Confundir valor inicial com final",
                                    "Não considerar convergência da Laplace"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a propriedade de convolução na transformada de Laplace",
                                  "subSteps": [
                                    "Defina convolução temporal: (f*g)(t) = ∫ f(τ)g(t-τ) dτ de 0 a t",
                                    "Aprenda que L{f*g} = F(s) * G(s), multiplicação no domínio s",
                                    "Estude o inverso: multiplicação em s corresponde a convolução em t",
                                    "Calcule exemplos com funções unitárias e exponenciais",
                                    "Verifique simetria e propriedades associativas"
                                  ],
                                  "verification": "Compute L{convolução de duas funções} e confirme igual a produto F(s)G(s)",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela de pares Laplace",
                                    "Calculadora gráfica",
                                    "Vídeos tutoriais sobre convolução"
                                  ],
                                  "tips": "Use a função degrau unitário para simplificar cálculos iniciais",
                                  "learningObjective": "Aplicar corretamente a transformada de convoluções para simplificar produtos",
                                  "commonMistakes": [
                                    "Confundir limites da integral de convolução",
                                    "Esquecer fator 1/(2π) em Fourier (não aplica aqui)",
                                    "Não normalizar funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar propriedades em equações diferenciais lineares",
                                  "subSteps": [
                                    "Transforme equações diferenciais ordinárias (EDOs) aplicando Laplace bilateralmente",
                                    "Substitua derivadas por sF(s) - condições iniciais",
                                    "Incorpore entradas como convoluções se necessário",
                                    "Resolva para F(s) algebraicamente",
                                    "Aplique teoremas de valor para verificar condições"
                                  ],
                                  "verification": "Transforme uma EDO de 2ª ordem e isole F(s) corretamente",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exercícios de EDOs resolvidas",
                                    "Folha de papel quadriculado",
                                    "Software de álgebra simbólica"
                                  ],
                                  "tips": "Anote todas as condições iniciais no início para evitar erros de propagação",
                                  "learningObjective": "Converter EDOs em equações algébricas no domínio s",
                                  "commonMistakes": [
                                    "Erros de sinal nas condições iniciais",
                                    "Aplicar Laplace só em uma derivada",
                                    "Ignorar termos de entrada forçada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificar funções de transferência de sistemas LTI",
                                  "subSteps": [
                                    "Defina função de transferência H(s) = Y(s)/U(s) para sistemas LTI",
                                    "Use propriedades para derivar H(s) de EDOs com entrada u(t) e saída y(t)",
                                    "Aplique convolução para respostas a entradas arbitrárias",
                                    "Verifique estabilidade com teorema do valor final",
                                    "Pratique com exemplos de sistemas de controle aeronáutico"
                                  ],
                                  "verification": "Derive H(s) para um sistema massa-mola-amortecedor e plote polos",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Modelos de sistemas LTI",
                                    "MATLAB/Simulink para validação",
                                    "Tabela de decomposição parcial"
                                  ],
                                  "tips": "Sempre fatorize o denominador para análise de polos/zeros",
                                  "learningObjective": "Obter e simplificar funções de transferência usando Laplace",
                                  "commonMistakes": [
                                    "Confundir entrada e saída no H(s)",
                                    "Não cancelar fatores comuns",
                                    "Esquecer Laplace da entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola-amortecedor: m y'' + c y' + k y = u(t). Condições iniciais y(0)=0, y'(0)=0. Aplicando Laplace: (m s² Y + c s Y + k Y) = U(s). Então H(s) = Y(s)/U(s) = 1/(m s² + c s + k). Use valor final para estabilidade: lim s->0 s H(s) * (sU(s)) indica resposta estacionária.",
                              "finalVerifications": [
                                "Calcula corretamente L{f'(t)} incluindo f(0)",
                                "Aplica teorema do valor inicial para lim t->0+ f(t)",
                                "Resolve convolução via multiplicação em s",
                                "Transforma EDO de 2ª ordem em H(s)",
                                "Verifica estabilidade de sistema LTI",
                                "Simplifica expressão com propriedades corretas"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de propriedades (100% correto)",
                                "Correta manipulação de condições iniciais",
                                "Uso adequado de convolução em entradas complexas",
                                "Simplificação algébrica sem erros",
                                "Interpretação física dos resultados (ex: estabilidade)",
                                "Eficiência no número de passos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de EDOs e álgebra linear",
                                "Física: Dinâmica de sistemas mecânicos/elétricos",
                                "Programação: Implementação em Python (SymPy) ou MATLAB",
                                "Engenharia de Controle: Análise de estabilidade",
                                "Processamento de Sinais: Filtros e respostas em frequência"
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, usar propriedades de Laplace para modelar e analisar a dinâmica de aeronaves, como resposta de um elevador a comandos de piloto em sistemas LTI, prevendo oscilações e estabilidade de voo via função de transferência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1",
                              "10.1.3.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Definição Formal da Função de Transferência",
                        "description": "Representação H(s) = Y(s)/U(s) no domínio de Laplace para sistemas LTI, assumindo condições iniciais nulas e entradas transformáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Definir função de transferência H(s)",
                            "description": "Estabelecer H(s) como a razão entre a transformada da saída Y(s) e da entrada U(s), válida para sistemas LTI com condições iniciais zero: Y(s) = H(s) U(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Pré-Requisitos: Transformada de Laplace e Sistemas LTI",
                                  "subSteps": [
                                    "Explique o que é a transformada de Laplace e sua utilidade para sistemas dinâmicos.",
                                    "Defina sistemas Linearmente Invariantes no Tempo (LTI) e suas propriedades chave (linearidade e invariância temporal).",
                                    "Discuta a importância das condições iniciais zero para a definição de H(s).",
                                    "Identifique exemplos simples de sistemas LTI, como equações diferenciais lineares.",
                                    "Pratique convertendo uma equação diferencial simples de tempo para domínio s."
                                  ],
                                  "verification": "Resuma em uma frase os três elementos essenciais (Laplace, LTI, condições zero) e forneça um exemplo de sistema LTI.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Sinais e Sistemas (ex: Oppenheim), calculadora simbólica (Wolfram Alpha ou MATLAB).",
                                  "tips": "Use tabelas de transformadas de Laplace para referência rápida.",
                                  "learningObjective": "Compreender os fundamentos necessários para definir H(s).",
                                  "commonMistakes": "Confundir LTI com sistemas não-lineares ou ignorar condições iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Entrada u(t) e Saída y(t) no Domínio do Tempo",
                                  "subSteps": [
                                    "Escolha um sistema LTI simples, como um circuito RLC ou massa-mola.",
                                    "Defina claramente a entrada u(t) (forçamento externo) e saída y(t) (resposta do sistema).",
                                    "Escreva a equação diferencial que relaciona u(t) e y(t).",
                                    "Verifique se o sistema satisfaz LTI e condições iniciais y(0)=0, y'(0)=0.",
                                    "Desenhe um diagrama de bloco esquemático mostrando u(t) → sistema → y(t)."
                                  ],
                                  "verification": "Escreva a equação diferencial para um sistema massa-mola com u(t) como força aplicada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e lápis para diagramas, software de desenho (Draw.io).",
                                  "tips": "Sempre especifique unidades (ex: u(t) em Newtons, y(t) em metros).",
                                  "learningObjective": "Estabelecer entrada e saída no domínio do tempo.",
                                  "commonMistakes": "Escolher sistemas não-LTI ou não definir condições iniciais explicitamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Transformada de Laplace e Derivar Y(s) em Termos de U(s)",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace bilateral à equação diferencial: ℒ{y''} = s²Y(s) - sy(0) - y'(0), simplificando para zero iniciais.",
                                    "Transforme todos os termos da equação diferencial para o domínio s.",
                                    "Agrupe termos contendo Y(s) de um lado e U(s) do outro.",
                                    "Expresse Y(s) = [algum polinômio em s] U(s).",
                                    "Identifique o coeficiente como H(s) preliminar."
                                  ],
                                  "verification": "Derive Y(s) para a equação y'' + 2y' + y = u(t), mostrando simplificações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela de transformadas de Laplace, calculadora simbólica.",
                                  "tips": "Lembre-se: para zero iniciais, ℒ{y''} = s²Y(s).",
                                  "learningObjective": "Transformar o sistema do domínio do tempo para s.",
                                  "commonMistakes": "Esquecer termos de condições iniciais ou erros em propriedades de Laplace (ex: derivada)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição de H(s) = Y(s)/U(s)",
                                  "subSteps": [
                                    "Defina formalmente H(s) = Y(s) / U(s), válida apenas para zero iniciais e LTI.",
                                    "Escreva H(s) como quociente de polinômios: H(s) = N(s)/D(s).",
                                    "Verifique dimensionalidade e causalidade de H(s).",
                                    "Compare com a definição geral: resposta em frequência no domínio s.",
                                    "Teste com u(t) = δ(t) para obter resposta ao impulso h(t) = ℒ⁻¹{H(s)}."
                                  ],
                                  "verification": "Escreva H(s) para o sistema do Step 3 e confirme Y(s) = H(s) U(s).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de controle (MATLAB Simulink) para validação.",
                                  "tips": "H(s) é única para sistemas LTI idênticos.",
                                  "learningObjective": "Definir e validar H(s) completamente.",
                                  "commonMistakes": "Dividir por U(s)=0 ou aplicar a sistemas não-LTI."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor: m y'' + c y' + k y = u(t), com m=1, c=2, k=1, zero iniciais. Aplique Laplace: (s² + 2s + 1) Y(s) = U(s), logo H(s) = 1/(s² + 2s + 1). Verifique: para u(t)=δ(t), y(t)=h(t)=e^{-t} sin(t) ou similar.",
                              "finalVerifications": [
                                "Escreva a definição exata de H(s) incluindo condições.",
                                "Derive H(s) para um sistema RC simples: y' + (1/RC) y = (1/RC) u(t) → H(s)=1/(RC s +1).",
                                "Explique por que H(s) não vale para condições iniciais não-zero.",
                                "Desenhe diagrama de bloco com H(s).",
                                "Compute H(s) para um exemplo aeronáutico: elevador de aeronave simplificado.",
                                "Confirme Y(s) = H(s) U(s) substituindo valores."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de H(s) como Y(s)/U(s) com condições LTI e zero iniciais (peso: 30%).",
                                "Correta aplicação de Laplace sem erros algébricos (25%).",
                                "Identificação clara de entrada/saída e equação diferencial (20%).",
                                "Explicação verbal fluida das limitações de H(s) (15%).",
                                "Exemplo prático derivado corretamente (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios racionais e raízes (estabilidade).",
                                "Física: Dinâmica de sistemas mecânicos/elétricos em aeronáutica.",
                                "Programação: Implementar H(s) em Python/MATLAB para simulações numéricas.",
                                "Engenharia de Controle: Base para diagramas de Bode e análise de frequência."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, H(s) modela a dinâmica de controle de voo, como resposta do elevador a comandos de piloto em sistemas fly-by-wire de aviões comerciais (ex: Boeing 787), permitindo design de controladores PID para estabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Derivar H(s) a partir de equação diferencial",
                            "description": "Transformar uma equação diferencial linear de ordem n, como a_n y^{(n)} + ... + a_0 y = b_m u^{(m)} + ... + b_0 u, em H(s) = (b_m s^m + ... + b_0)/(a_n s^n + ... + a_0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar a equação diferencial",
                                  "subSteps": [
                                    "Escreva a equação diferencial no formato padrão: a_n y^{(n)} + ... + a_0 y = b_m u^{(m)} + ... + b_0 u",
                                    "Identifique os coeficientes a_i para y e seus derivados, e b_j para u e seus derivados",
                                    "Confirme a ordem n do sistema (maior derivada de y) e m para entrada",
                                    "Anote condições iniciais como zero para função de transferência",
                                    "Verifique se é linear e invariante no tempo"
                                  ],
                                  "verification": "Lista de coeficientes e ordens anotados corretamente sem erros de transcrição",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simbólica ou software como SymPy/MATLAB"
                                  ],
                                  "tips": "Sempre use notação clara para derivadas (y', y'', etc.) e substitua por notação de Laplace posteriormente",
                                  "learningObjective": "Reconhecer componentes de uma EDO linear para aplicação de Laplace",
                                  "commonMistakes": [
                                    "Confundir ordem de y com u",
                                    "Ignorar condições iniciais",
                                    "Escrever coeficientes incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Transformada de Laplace aos dois lados da equação",
                                  "subSteps": [
                                    "Aplique L{} em cada termo do lado esquerdo: L{y^{(k)}} = s^k Y(s) - s^{k-1} y(0) - ... (assuma y(0)=y'(0)=...=0)",
                                    "Faça o mesmo para o lado direito: L{u^{(k)}} = s^k U(s) - ... (assuma u iniciais zero)",
                                    "Simplifique eliminando termos iniciais zero, resultando em soma a_k s^k Y(s) = soma b_j s^j U(s)",
                                    "Verifique que todos os termos iniciais foram corretamente zerados",
                                    "Escreva a equação em termos de Y(s) e U(s)"
                                  ],
                                  "verification": "Equação transformada balanceada: polinômio em s multiplicando Y(s) = polinômio em s multiplicando U(s)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Software para cálculo simbólico"
                                  ],
                                  "tips": "Lembre-se: para função de transferência, IC=0 é essencial; anote isso explicitamente",
                                  "learningObjective": "Dominar a aplicação de Laplace a derivadas com condições iniciais zero",
                                  "commonMistakes": [
                                    "Esquecer fatores s^k nos derivados",
                                    "Não zerar corretamente IC",
                                    "Invertar lados da equação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar a função de transferência H(s) = Y(s)/U(s)",
                                  "subSteps": [
                                    "Divida ambos os lados por U(s): [soma a_k s^k] Y(s)/U(s) = soma b_j s^j",
                                    "Assim, H(s) = Y(s)/U(s) = [soma b_j s^j] / [soma a_k s^k]",
                                    "Normalize o denominador dividindo numerador e denominador pelo coeficiente líder a_n (tornar monico)",
                                    "Escreva explicitamente como H(s) = (b_m s^m + ... + b_0) / (s^n + ... + a_0/a_n)",
                                    "Confirme graus: grau numerador ≤ grau denominador para sistemas próprios"
                                  ],
                                  "verification": "H(s) isolada corretamente como razão de polinômios em s",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para álgebra simbólica",
                                    "Calculadora para simplificação"
                                  ],
                                  "tips": "Sempre normalize para coeficiente líder 1 no denominador em engenharia",
                                  "learningObjective": "Extrair H(s) diretamente da equação em domínio s",
                                  "commonMistakes": [
                                    "Não dividir corretamente por U(s)",
                                    "Erros em normalização",
                                    "Confundir numerador com denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e refinar a forma final de H(s)",
                                  "subSteps": [
                                    "Expanda polinômios se necessário e verifique coeficientes",
                                    "Confirme estabilidade potencial (raízes do denominador)",
                                    "Teste com substituição numérica simples (ex: s=0 para ganho DC)",
                                    "Compare com forma esperada para ordem n",
                                    "Documente H(s) final com notação clara"
                                  ],
                                  "verification": "H(s) em forma racional padrão, com testes numéricos passando",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB para validação opcional"
                                  ],
                                  "tips": "Use H(0) = b_0 / a_0 para ganho estático como checagem rápida",
                                  "learningObjective": "Garantir precisão e utilidade prática de H(s)",
                                  "commonMistakes": [
                                    "Erros algébricos em expansão",
                                    "Ignorar normalização",
                                    "Não testar valores limites"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada y'' + 3y' + 2y = u, aplique Laplace: s^2 Y + 3s Y + 2 Y = U → H(s) = 1 / (s^2 + 3s + 2). Normalize já está monico.",
                              "finalVerifications": [
                                "H(s) é uma razão de polinômios com grau(denom) ≥ grau(num)",
                                "Coeficientes batem com os da EDO original após Laplace",
                                "Condições iniciais zero assumidas e justificadas",
                                "Forma normalizada (denominador monico)",
                                "Teste: H(0) = constante de estado estacionário correto",
                                "Sem erros algébricos evidentes"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de Laplace (100% dos termos corretos)",
                                "Isolamento correto de H(s) sem inversão de fração",
                                "Normalização adequada do denominador",
                                "Verificações numéricas ou simbólicas incluídas",
                                "Clareza na documentação passo a passo",
                                "Tempo de execução dentro do estimado"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas integrais e álgebra polinomial",
                                "Física: Modelagem de sistemas dinâmicos (ex: osciladores)",
                                "Engenharia de Controle: Análise de estabilidade via polos",
                                "Processamento de Sinais: Filtros lineares em domínio s"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, derivar H(s) de EDOs modela dinâmica de aeronaves (ex: resposta de atitude a comandos de controle), essencial para design de autômatos de voo em sistemas como fly-by-wire."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.1",
                              "10.1.3.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Verificar condições de existência da função de transferência",
                            "description": "Identificar requisitos como sistema LTI causal, condições iniciais nulas e convergência da transformada de Laplace para entradas e saídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Confirmar que o sistema é LTI (Linear e Invariante no Tempo)",
                                  "subSteps": [
                                    "Analise a equação diferencial do sistema para verificar linearidade: some soluções de entradas lineares devem resultar na solução da soma das entradas.",
                                    "Verifique invariância no tempo: aplique uma entrada atrasada e confirme que a saída também está atrasada pelo mesmo montante.",
                                    "Identifique coeficientes constantes nas equações para confirmar invariância temporal.",
                                    "Teste com superposição para linearidade usando entradas escalares e somadas.",
                                    "Documente evidências de LTI ou identifique violações como não-linearidades (ex: quadráticas)."
                                  ],
                                  "verification": "Escreva um relatório curto confirmando LTI com exemplos matemáticos ou contraexemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Equação diferencial do sistema, papel e caneta, calculadora simbólica (ex: SymPy ou MATLAB)",
                                  "tips": "Use o teste de superposição: se f(t1 + t2) = f(t1) + f(t2) e af(t) = a f(t), é linear.",
                                  "learningObjective": "Compreender e aplicar os testes fundamentais para sistemas LTI.",
                                  "commonMistakes": "Confundir linearidade com simetria; ignorar termos não-lineares como sen(x) ou x²."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Causalidade e Condições Iniciais Nulas",
                                  "subSteps": [
                                    "Defina causalidade: saída y(t) depende apenas de u(τ) para τ ≤ t.",
                                    "Inspecione o modelo: graus de liberdade na derivada mais alta devem igualar a ordem do sistema.",
                                    "Confirme condições iniciais nulas: y(0-) = 0, y'(0-) = 0, etc., para todos os estados.",
                                    "Simule ou analise graficamente a resposta a impulsos para causalidade.",
                                    "Ajuste o modelo se condições iniciais não forem nulas, resetando para t=0-."
                                  ],
                                  "verification": "Crie um diagrama de blocos ou equação mostrando dependência causal e liste condições iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama esquemático do sistema, software de simulação (ex: Simulink)",
                                  "tips": "Causalidade falha em sistemas com previsão futura; verifique ordem da derivada de y vs u.",
                                  "learningObjective": "Identificar causalidade e preparar sistema com condições iniciais zero.",
                                  "commonMistakes": "Assumir causalidade sem verificar dependências futuras; esquecer reset de estados iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Convergência da Transformada de Laplace para Entrada e Saída",
                                  "subSteps": [
                                    "Calcule a transformada de Laplace unilateral L{u(t)} e determine sua região de convergência (ROC).",
                                    "Determine L{y(t)} assumindo condições iniciais nulas e encontre sua ROC.",
                                    "Verifique se as ROCs de U(s) e Y(s) se sobrepõem em uma região comum não vazia.",
                                    "Identifique polos e zeros: ROC deve ser uma faixa no plano s à direita dos polos mais à direita.",
                                    "Teste com entradas específicas (ex: degrau, rampa) para validar convergência prática."
                                  ],
                                  "verification": "Plote os polos/zeros e ROCs no plano s, confirmando sobreposição.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de Laplace, MATLAB ou Python (control library), papel grafado",
                                  "tips": "ROC para sistemas causais é Re(s) > σ_max (polo real máximo); expanda unilateralmente.",
                                  "learningObjective": "Avaliar estabilidade via ROC da transformada de Laplace.",
                                  "commonMistakes": "Usar Laplace bilateral em sistemas causais; ignorar sobreposição de ROCs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Validar a Função de Transferência H(s)",
                                  "subSteps": [
                                    "Compute H(s) = Y(s)/U(s) simplificando algebraicamente.",
                                    "Confirme que H(s) é uma função racional própria (grau numerador ≤ denominador).",
                                    "Verifique estabilidade: todos polos no semiplano esquerdo.",
                                    "Simule resposta em tempo real vs H(s) para validação.",
                                    "Documente conclusão: 'Condições satisfeitas' ou liste falhas."
                                  ],
                                  "verification": "Gere gráfico de resposta ao degrau usando H(s) e compare com simulação original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de controle (MATLAB Control System Toolbox), equações simbólicas",
                                  "tips": "Fatore polos/zeros para simplificar; use partial fractions se necessário.",
                                  "learningObjective": "Finalizar verificação integrando todas as condições em H(s) válida.",
                                  "commonMistakes": "Não simplificar frações; assumir estabilidade sem checar polos."
                                }
                              ],
                              "practicalExample": "Em um modelo de elevador de aeronave, dada a equação m ÿ + b ẏ + k y = u(t), verifique LTI (coeficientes constantes), causal (ordem y=2, u=0), condições iniciais y(0-)=ẏ(0-)=0, e ROCs sobrepostas para u=degrau (ROC Re(s)>0) e y (ROC Re(s)>-σ onde σ é damping).",
                              "finalVerifications": [
                                "Sistema confirmado como LTI com testes de superposição.",
                                "Causalidade e condições iniciais nulas explicitamente verificadas.",
                                "ROCs de U(s) e Y(s) se sobrepõem em região comum.",
                                "H(s) é racional, própria e todos polos no semiplano esquerdo.",
                                "Simulação numérica valida a resposta teórica.",
                                "Relatório lista todas condições com evidências matemáticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de LTI (90% correto).",
                                "Correta determinação de causalidade e ICs (sem erros lógicos).",
                                "Análise ROC precisa com plot correto.",
                                "H(s) derivada corretamente e simplificada.",
                                "Validação prática via simulação ou gráfico.",
                                "Relatório claro, completo e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e análise de funções racionais.",
                                "Controle Automático: Estabilidade e modelagem de sistemas.",
                                "Física: Dinâmica de sistemas mecânicos em aeronáutica.",
                                "Programação: Simulações em MATLAB/Python para validação."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, verificar condições de função de transferência é essencial para modelar sistemas de controle de voo, como estabilizadores automáticos, garantindo que simulações predigam respostas reais de aeronaves sem divergências numéricas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.1",
                              "10.1.3.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Representar diagrama de blocos com H(s)",
                            "description": "Desenhar e interpretar diagramas de blocos onde blocos com H(s) representam multiplicação no domínio de Laplace, somadores para superposição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos de um diagrama de blocos",
                                  "subSteps": [
                                    "Definir diagrama de blocos como representação gráfica de sistemas dinâmicos no domínio de Laplace.",
                                    "Identificar símbolos principais: retângulos para blocos H(s), círculos para somadores, linhas retas para sinais.",
                                    "Explicar que H(s) representa multiplicação por função de transferência no domínio s.",
                                    "Diferenciar entradas (r(s)), saídas (y(s)) e sinais internos.",
                                    "Estudar convenções de direção das setas e ramificações."
                                  ],
                                  "verification": "Desenhar manualmente os símbolos básicos e rotulá-los corretamente em um papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Livro-texto de Sinais e Sistemas"
                                  ],
                                  "tips": "Use cores diferentes para entradas (azul), blocos (verde) e saídas (vermelho) para facilitar a visualização.",
                                  "learningObjective": "Reconhecer e nomear todos os elementos fundamentais de um diagrama de blocos.",
                                  "commonMistakes": "Confundir somadores com multiplicadores ou inverter a direção das setas de sinal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar funções de transferência simples como blocos",
                                  "subSteps": [
                                    "Escrever uma função de transferência simples, ex: H(s) = 1/(s + 1).",
                                    "Desenhar um bloco retangular rotulado com H(s) = 1/(s + 1).",
                                    "Conectar entrada r(s) à esquerda do bloco e saída y(s) = H(s) * r(s) à direita.",
                                    "Verificar que o sinal de saída é a multiplicação no domínio de Laplace.",
                                    "Praticar com mais duas funções: H(s) = K e H(s) = 1/s."
                                  ],
                                  "verification": "Comparar o diagrama desenhado com um modelo padrão de um livro ou software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel",
                                    "Lápis",
                                    "Software como Draw.io ou MATLAB Simulink (opcional)"
                                  ],
                                  "tips": "Sempre escreva H(s) explicitamente dentro do bloco para evitar ambiguidades.",
                                  "learningObjective": "Converter uma função de transferência em um bloco único corretamente.",
                                  "commonMistakes": "Esquecer o domínio de Laplace ou rotular incorretamente como h(t) em vez de H(s)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir diagramas com somadores e múltiplos blocos",
                                  "subSteps": [
                                    "Adicionar um somador: desenhar círculo com + e conectar duas entradas (ex: referência e feedback).",
                                    "Montar sistema em cascata: entrada → H1(s) → H2(s) → saída, com y(s) = H1(s)*H2(s)*r(s).",
                                    "Incluir ramificação: sinal sai de um ponto e vai para dois blocos.",
                                    "Incorporar realimentação simples: saída conectada de volta ao somador via outro bloco.",
                                    "Rotular todos os sinais intermediários."
                                  ],
                                  "verification": "Simular o diagrama em software como Simulink e verificar se a resposta coincide com cálculo analítico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel",
                                    "Regra",
                                    "Software Simulink ou Python com Control Systems Library"
                                  ],
                                  "tips": "Comece pelo sinal de entrada e siga o fluxo lógico para evitar conexões erradas.",
                                  "learningObjective": "Montar diagramas complexos usando somadores para superposição de sinais.",
                                  "commonMistakes": "Colocar somador em vez de multiplicação ou ignorar sinais negativos no somador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar diagramas de blocos",
                                  "subSteps": [
                                    "Dado um diagrama pronto, derivar a função de transferência total Y(s)/R(s).",
                                    "Identificar superposição em somadores e multiplicações sucessivas.",
                                    "Verificar consistência: número de entradas/saídas e rótulos.",
                                    "Analisar um diagrama com realimentação e calcular H(s) equivalente.",
                                    "Documentar a interpretação em equações."
                                  ],
                                  "verification": "Resolver a função de transferência manualmente e comparar com simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama exemplo impresso",
                                    "Calculadora simbólica ou MATLAB"
                                  ],
                                  "tips": "Siga o caminho do sinal da entrada à saída, multiplicando H(s) e somando onde necessário.",
                                  "learningObjective": "Interpretar diagramas para obter funções de transferência e validar representações.",
                                  "commonMistakes": "Erros em ramificações, onde o sinal se divide sem multiplicação extra."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de altitude de aeronave, entrada r(s) é a altitude desejada, passa por somador com feedback -y(s), depois por H1(s) = 1/s (integrador) e H2(s) = K/(s+1) (atuador). Desenhe: r(s) → [+] → H1(s) → H2(s) → y(s), com y(s) ramificado de volta ao somador. Interprete como Y(s) = [H1(s) H2(s) / (1 + H1(s) H2(s))] R(s).",
                              "finalVerifications": [
                                "Desenha corretamente blocos H(s), somadores e conexões.",
                                "Identifica multiplicação por H(s) e superposição em somadores.",
                                "Deriva função de transferência total de um diagrama simples.",
                                "Simula o diagrama e valida com cálculo analítico.",
                                "Explica verbalmente o fluxo de sinais no domínio de Laplace.",
                                "Aplica em exemplo de sistema realimentado sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos símbolos e rótulos (30%)",
                                "Corretude das conexões e fluxo de sinais (25%)",
                                "Capacidade de interpretação e derivação de H(s) total (20%)",
                                "Validação via simulação ou cálculo (15%)",
                                "Clareza e organização do diagrama (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e álgebra de funções racionais.",
                                "Física: Modelagem dinâmica de sistemas mecânicos e elétricos.",
                                "Programação: Simulação em MATLAB/Simulink ou Python (biblioteca control).",
                                "Engenharia de Controle: Aplicação em autômatos industriais."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, diagramas de blocos com H(s) modelam sistemas de controle de voo, como estabilização de atitude em aviões, permitindo análise de estabilidade e projeto de controladores PID para resposta rápida e precisa a perturbações."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Propriedades da Função de Transferência",
                    "description": "Características como polos, zeros, estabilidade, causalidade e minimalidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Polos e Zeros da Função de Transferência",
                        "description": "Definição, localização no plano complexo e influência dos polos e zeros na resposta em frequência de sistemas lineares invariantes no tempo (LTI) contínuos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar polos e zeros de uma função de transferência racional",
                            "description": "Dada uma função de transferência H(s) = N(s)/D(s), determinar os zeros como raízes de N(s)=0 e os polos como raízes de D(s)=0, incluindo multiplicidades e representação no plano s.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de polos e zeros em funções de transferência",
                                  "subSteps": [
                                    "Defina função de transferência H(s) como a razão N(s)/D(s), onde N(s) é o numerador e D(s) o denominador.",
                                    "Explique que zeros são valores de s onde N(s) = 0, fazendo H(s) = 0.",
                                    "Explique que polos são valores de s onde D(s) = 0, fazendo H(s) indefinida.",
                                    "Discuta multiplicidade: raízes repetidas indicam multiplicidade maior que 1.",
                                    "Revise o plano s (plano complexo) para localização de polos e zeros."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos de polos, zeros e plano s, com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas",
                                    "Papel e lápis para diagrama",
                                    "Software como MATLAB para visualização opcional"
                                  ],
                                  "tips": "Use analogias como 'zeros apagam o sinal' e 'polos amplificam ou instabilizam'.",
                                  "learningObjective": "Entender conceitualmente polos e zeros e sua representação no plano s.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar multiplicidades em raízes repetidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e isolar o numerador N(s) e denominador D(s) da função H(s)",
                                  "subSteps": [
                                    "Escreva a função de transferência dada em forma racional H(s) = N(s)/D(s).",
                                    "Expanda polinômios se necessário para forma padrão (ex: s^2 + as + b).",
                                    "Verifique grau de N(s) e D(s); tipicamente deg(D) >= deg(N) para funções próprias.",
                                    "Simplifique cancelando fatores comuns, mas anote antes para evitar perda de polos/zeros cancelados.",
                                    "Confirme que N(s) e D(s) estão em forma monica (coeficiente líder 1)."
                                  ],
                                  "verification": "Apresente N(s) e D(s) isolados e expandidos corretamente para uma H(s) exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função H(s) exemplo impressa",
                                    "Calculadora simbólica ou papel"
                                  ],
                                  "tips": "Sempre escreva H(s) = N(s)/D(s) explicitamente para evitar confusão.",
                                  "learningObjective": "Extrair com precisão os polinômios numerador e denominador.",
                                  "commonMistakes": [
                                    "Não expandir frações impróprias",
                                    "Cancelar fatores sem anotar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os zeros resolvendo N(s) = 0",
                                  "subSteps": [
                                    "Defina a equação N(s) = 0.",
                                    "Use fórmula quadrática para polinômios de grau 2, ou fatoração para graus baixos.",
                                    "Para graus altos, liste raízes possíveis (teorema das raízes racionais).",
                                    "Determine multiplicidades contando raízes repetidas.",
                                    "Expresse zeros em forma complexa a + bi se aplicável."
                                  ],
                                  "verification": "Liste todos os zeros com suas multiplicidades para N(s) dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de fórmulas quadráticas",
                                    "Software como Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Fatore sempre em fatores lineares (s - z_i) para clareza.",
                                  "learningObjective": "Resolver raízes do numerador com precisão e multiplicidades.",
                                  "commonMistakes": [
                                    "Erros aritméticos em raízes quadráticas",
                                    "Esquecer raízes complexas conjugadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os polos resolvendo D(s) = 0",
                                  "subSteps": [
                                    "Defina a equação D(s) = 0.",
                                    "Aplique métodos de resolução de raízes idênticos aos do Step 3.",
                                    "Identifique multiplicidades para polos reais ou complexos.",
                                    "Note polos no semiplano direito (instabilidade potencial em sistemas).",
                                    "Verifique se há polos no infinito se deg(N) < deg(D)."
                                  ],
                                  "verification": "Liste todos os polos com multiplicidades e classifique localização (real, complexo).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos do Step 3",
                                    "Gráficos de polos para referência"
                                  ],
                                  "tips": "Polos determinam estabilidade; memorize que Re(p) < 0 para estabilidade.",
                                  "learningObjective": "Resolver raízes do denominador e entender implicações.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar polos de multiplicidade alta"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Representar polos e zeros no plano s e analisar",
                                  "subSteps": [
                                    "Desenhe o plano complexo com eixos real e imaginário.",
                                    "Marque zeros com 'o' ou círculo, polos com 'x' ou cruz, dimensionando por multiplicidade.",
                                    "Inclua setas para direção de contorno se relevante.",
                                    "Analise padrões: zeros/polos próximos afetam resposta.",
                                    "Documente lista textual e diagrama."
                                  ],
                                  "verification": "Produza diagrama completo do plano s com legendas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software como MATLAB/GeoGebra",
                                    "Exemplos de diagramas"
                                  ],
                                  "tips": "Use escala log para distâncias grandes; rotule valores exatos.",
                                  "learningObjective": "Visualizar e interpretar localização de polos/zeros.",
                                  "commonMistakes": [
                                    "Eixo imaginário invertido",
                                    "Não indicar multiplicidades no diagrama"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = (s + 2)/((s + 1)(s^2 + 2s + 2)), zeros: s = -2 (simples); polos: s = -1 (simples), s = -1 ± j (complexos conjugados, simples). No plano s: zero em (-2,0), polo em (-1,0), polos em (-1,1) e (-1,-1).",
                              "finalVerifications": [
                                "Lista correta de zeros com multiplicidades.",
                                "Lista correta de polos com multiplicidades.",
                                "Diagrama preciso no plano s.",
                                "Identificação de raízes complexas conjugadas.",
                                "Análise de cancelamentos se aplicável.",
                                "Verificação numérica com software."
                              ],
                              "assessmentCriteria": [
                                "Precisão na resolução de equações polinomiais (90% correto).",
                                "Correta identificação de multiplicidades.",
                                "Diagrama claro e rotulado no plano s.",
                                "Explicação conceitual sólida.",
                                "Tratamento adequado de casos complexos.",
                                "Eficiência no tempo e recursos."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Análise de estabilidade de sistemas aeronáuticos.",
                                "Matemática: Resolução de equações polinomiais e números complexos.",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Computação: Simulações em MATLAB/Simulink para validação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, identificar polos e zeros de funções de transferência de aeronaves permite analisar estabilidade de voo, projetar controladores para manobras e prever respostas a perturbações como turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Construir e interpretar o diagrama de polos e zeros",
                            "description": "Plotar polos (×) e zeros (○) no plano complexo para uma H(s) dada e explicar qualitativamente o impacto na magnitude e fase da resposta em frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Polos e Zeros",
                                  "subSteps": [
                                    "Defina zeros como as raízes do numerador da H(s), onde H(s) = 0.",
                                    "Defina polos como as raízes do denominador da H(s), onde H(s) tende ao infinito.",
                                    "Revise o plano complexo: eixo horizontal (real), eixo vertical (imaginário).",
                                    "Identifique os símbolos padrão: ○ para zeros e × para polos.",
                                    "Discuta a multiplicidade: múltiplos símbolos no mesmo local para raízes repetidas."
                                  ],
                                  "verification": "Escreva definições precisas e desenhe um plano complexo vazio com eixos rotulados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Referência de livro de Sinais e Sistemas (cap. Funções de Transferência)"
                                  ],
                                  "tips": "Sempre normalize H(s) para monica (grau numerador ≤ denominador) antes de analisar.",
                                  "learningObjective": "Dominar definições e representação gráfica básica de polos e zeros.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar a parte imaginária em raízes complexas",
                                    "Esquecer de indicar multiplicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair Polos e Zeros de uma Função de Transferência Dada",
                                  "subSteps": [
                                    "Escreva H(s) em forma racional: H(s) = N(s)/D(s).",
                                    "Fatore o numerador N(s) para encontrar zeros: resolva N(s) = 0.",
                                    "Fatore o denominador D(s) para encontrar polos: resolva D(s) = 0.",
                                    "Liste polos e zeros com suas coordenadas (σ + jω).",
                                    "Verifique se há cancelamentos entre polos e zeros comuns."
                                  ],
                                  "verification": "Para H(s) = (s+1)/(s^2 + 3s + 2), liste: zero em -1, polos em -1 e -2 (note cancelamento parcial).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel para fatoração",
                                    "Tabela de raízes quadráticas"
                                  ],
                                  "tips": "Use fórmula quadrática para polinômios de 2º grau: s = [-b ± sqrt(b²-4ac)]/2a.",
                                  "learningObjective": "Extrair com precisão polos e zeros de H(s) polinomial.",
                                  "commonMistakes": [
                                    "Erros de fatoração",
                                    "Não detectar raízes complexas conjugadas",
                                    "Esquecer cancelamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Diagrama de Polos e Zeros no Plano Complexo",
                                  "subSteps": [
                                    "Desenhe os eixos real (Re) e imaginário (Im), marcando origem e escalas.",
                                    "Plote zeros (○) nas posições corretas: parte real no eixo x, imaginária no y.",
                                    "Plote polos (×) nas posições corretas, usando múltiplos símbolos para multiplicidade.",
                                    "Rotule cada polo e zero com suas coordenadas exatas.",
                                    "Adicione uma seta indicativa de frequência crescente (do centro para borda)."
                                  ],
                                  "verification": "Desenhe o diagrama para H(s) = (s+2)/((s+1)(s+3)) e confirme posições: ○(-2,0), ×(-1,0), ×(-3,0).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software como MATLAB/Octave",
                                    "Régua e compasso para precisão"
                                  ],
                                  "tips": "Use escala logarítmica se o plano for amplo; software acelera plotagem precisa.",
                                  "learningObjective": "Criar diagramas precisos e visualmente claros.",
                                  "commonMistakes": [
                                    "Escala inadequada causando desalinhamento",
                                    "Inverter eixos real/imaginário",
                                    "Esquecer rótulos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Qualitativamente o Impacto na Resposta em Frequência",
                                  "subSteps": [
                                    "Para magnitude |H(jω)|: zeros aumentam magnitude (distância de jω ao ○), polos diminuem (distância ao ×).",
                                    "Analise magnitude: polo/zero próximo ao eixo jω causa pico/notch; pares conjugados causam ressonância.",
                                    "Para fase ∠H(jω): cada zero adiciona +90°, polo -90°; ordem segue ângulo de jω aos pontos.",
                                    "Descreva comportamento assintótico: baixa ω segue polos/zeros reais; alta ω por diferença de graus.",
                                    "Combine: magnitude cai 20dB/década por polo extra, fase muda gradualmente."
                                  ],
                                  "verification": "Para o diagrama anterior, explique: magnitude com notch em ω=2 rad/s, fase atraso dominante.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama plotado",
                                    "Gráficos de Bode de referência",
                                    "Software para validar (pzmap)"
                                  ],
                                  "tips": "Pense em |H(jω)| ≈ produto de distâncias; fase soma ângulos vetoriais.",
                                  "learningObjective": "Explicar impactos qualitativos na magnitude e fase.",
                                  "commonMistakes": [
                                    "Confundir efeito de polo/zero na magnitude",
                                    "Ignorar ordem de contribuição de fase",
                                    "Não considerar localização relativa ao eixo jω"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere H(s) = (s + 2) / [(s + 1)(s^2 + 2s + 5)]. Zeros: -2 (○ em -2+0j). Polos: -1 (× em -1+0j), -1±2j (× em -1+2j e -1-2j). Diagrama mostra polo complexo próximo ao eixo jω, causando pico de magnitude em ω≈2 rad/s e fase com atraso rápido; zero real estabiliza baixa frequência.",
                              "finalVerifications": [
                                "Corretamente extrai e plota polos/zeros para H(s) exemplo sem erros.",
                                "Descreve qualitativamente mudança de magnitude ao mover um polo para eixo jω.",
                                "Explica variação de fase para ω de 0 a ∞.",
                                "Identifica cancelamentos em H(s) com fatores comuns.",
                                "Desenha diagrama com rótulos precisos e escala adequada.",
                                "Previsão correta de ressonância por polos complexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de polos/zeros (sem erros algébricos).",
                                "Qualidade visual do diagrama (escala, símbolos, rótulos).",
                                "Correção qualitativa na interpretação de magnitude (efeitos de proximidade).",
                                "Correção na interpretação de fase (contribuições angulares).",
                                "Profundidade na análise assintótica e comportamentos extremos.",
                                "Clareza na explicação verbal ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e raízes de polinômios.",
                                "Física: Dinâmica de sistemas oscilatórios e ressonância.",
                                "Engenharia de Controle: Análise de estabilidade via localização de polos.",
                                "Processamento de Sinais: Filtros analógicos e design de frequência.",
                                "Computação: Simulações em MATLAB para pzplot e bode."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, diagramas de polos e zeros analisam funções de transferência de sistemas de controle de voo, predizendo estabilidade (polos no semiplano esquerdo), overshoot (polos complexos) e resposta a turbulências, essenciais para certificação de aeronaves como no design de autômatos de atitude."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Analisar efeitos de polos e zeros na resposta em frequência",
                            "description": "Prever comportamentos assintóticos da |H(jω)| e arg(H(jω)) baseados na proximidade de polos/zeros ao eixo imaginário e ângulos de aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar localização e representação de polos e zeros no plano s",
                                  "subSteps": [
                                    "Fatore a função de transferência H(s) para identificar numerador (zeros) e denominador (polos).",
                                    "Plote os polos e zeros no plano complexo s, marcando-os com 'x' para polos e 'o' para zeros.",
                                    "Classifique-os por localização: reais, complexos conjugados, proximidade ao eixo imaginário (jω).",
                                    "Determine a multiplicidade de cada polo/zero e anote os ângulos de chegada/partida aproximados.",
                                    "Calcule o ganho em DC (ω=0) e em alta frequência para contexto inicial."
                                  ],
                                  "verification": "Confirme que todos polos e zeros estão corretamente plotados e classificados em um diagrama manual ou software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel quadriculado ou software como MATLAB/Python (control toolbox)",
                                    "Função de transferência exemplo"
                                  ],
                                  "tips": "Use escala logarítmica mentalmente para frequências; priorize polos/zeros próximos ao eixo jω pois dominam o comportamento.",
                                  "learningObjective": "Identificar e visualizar precisamente polos e zeros para análise subsequente.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar multiplicidade (ex: polo duplo dobra efeito)",
                                    "Plotar incorretamente pares conjugados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar impactos na magnitude |H(jω)| (diagrama de Bode)",
                                  "subSteps": [
                                    "Para cada zero: adição de +20 dB/década após ω_z = |zero|, com corner em ω_z.",
                                    "Para cada polo: subtração de -20 dB/década após ω_p = |polo|, corner em ω_p.",
                                    "Ajuste slopes por proximidade ao eixo jω: polos/zeros próximos causam picos/resonâncias em ω próxima.",
                                    "Some contribuições vetoriais para assíntotas: slope total = 20*(#zeros - #polos) em alta freq.",
                                    "Esboce o diagrama assintótico de magnitude, marcando corners e slopes."
                                  ],
                                  "verification": "Compare esboço assintótico com plot exato (Bode) gerado em software; erro < 6dB em pontos chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (bodeplot) ou Python (control.bode_plot)",
                                    "Folha para esboços manuais"
                                  ],
                                  "tips": "Comece com baixa frequência (slope 0 se tipo 0); zeros no numerador aumentam magnitude em alta freq.",
                                  "learningObjective": "Prever curvas de magnitude assintóticas baseadas em localização relativa de polos/zeros.",
                                  "commonMistakes": [
                                    "Esquecer multiplicidade (multiplica slope por ordem)",
                                    "Ignorar fase de aproximação para magnitude perto de corners",
                                    "Não normalizar ganho"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impactos na fase arg(H(jω))",
                                  "subSteps": [
                                    "Para zero simples: fase +90° total, transição de 0° a +90° centrada em ω_z, ~45° em corner.",
                                    "Para polo simples: fase -90° total, transição de 0° a -90° centrada em ω_p.",
                                    "Ajuste por proximidade: polos/zeros próximos ao jω causam mudanças abruptas; use ângulos de chegada (atan).",
                                    "Some fases de todos fatores: arg(H) = sum(arg(num)) - sum(arg(den)) em cada ω.",
                                    "Esboce diagrama assintótico de fase, aproximando retas horizontais e ramps de ±90°/década."
                                  ],
                                  "verification": "Verifique fase em ω=0 (0° ou 180° por tipo) e ω=∞ (±90°*(#z - #p)); erro <15° em sketch.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software para fase (angle(bode))",
                                    "Tabelas de ângulos atan pré-calculados"
                                  ],
                                  "tips": "Fase muda mais rápido perto de corners; para pares conjugados, fase dobra efeito.",
                                  "learningObjective": "Prever variações de fase assintóticas influenciadas por polos/zeros e ângulos.",
                                  "commonMistakes": [
                                    "Confundir sinal (+ para zero, - para polo)",
                                    "Não somar contribuições de todos",
                                    "Ignorar delay de fase em polos reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar análises para previsão completa e validação",
                                  "subSteps": [
                                    "Combine magnitude e fase em diagrama Bode completo assintótico.",
                                    "Preveja comportamentos: ressonâncias (polo complexo próximo jω), roll-off, picos de magnitude.",
                                    "Teste com variação: mova um polo/zero e re-preveja mudanças.",
                                    "Valide com simulação numérica e compare qualitativamente.",
                                    "Documente insights: como proximidade afeta largura de banda ou estabilidade."
                                  ],
                                  "verification": "Simulação confirma previsões assintóticas em >80% das frequências decádicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulador (MATLAB/Simulink)",
                                    "Exemplos variados de H(s)"
                                  ],
                                  "tips": "Foco em regiões dominantes: baixa/alta freq e corners; ignore detalhes finos inicialmente.",
                                  "learningObjective": "Sintetizar efeitos para análise holística de resposta em frequência.",
                                  "commonMistakes": [
                                    "Não considerar interações entre múltiplos polos/zeros próximos",
                                    "Prever linear em log sem assíntotas",
                                    "Esquecer efeitos de zeros no RHP"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = (s/10 + 1) / [(s/100 + 1)(s^2/400 + s/20 + 1)], zero em s=-10 domina baixa freq (slope +20dB/dec após 10 rad/s), polos reais em -100 causam -20dB/dec após, polo complexo ~20 rad/s cria pico magnitude ~10dB e fase drop -180°; sketch Bode prevê roll-off -20dB/dec alta freq.",
                              "finalVerifications": [
                                "Esboços assintóticos de |H(jω)| e arg(H(jω)) coincidem com plots exatos em corners principais.",
                                "Correta identificação de frequências de pico/resonância baseadas em Im(polo/zero).",
                                "Previsão qualitativa de estabilidade (fase margem >45° onde |H|=1).",
                                "Análise de 3 H(s) variadas mostra consistência em predições.",
                                "Explicação verbal correta de 'por que' um polo próximo jω causa oscilação.",
                                "Cálculo manual de slope total em alta freq correto."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos sketches assintóticos (±3dB e ±10° erro médio).",
                                "Correta atribuição de slopes e ramps de fase a polos/zeros específicos.",
                                "Consideração explícita de proximidade ao eixo jω e ângulos de aproximação.",
                                "Validação numérica com discrepâncias explicadas.",
                                "Profundidade em substeps: todos campos preenchidos com detalhes acionáveis.",
                                "Criatividade em exemplos: aplica a contextos aeronáuticos como flaps."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Margens de ganho/fase para estabilidade de aeronaves.",
                                "Processamento de Sinais: Design de filtros notch para vibrações em hélices.",
                                "Dinâmica de Aeronaves: Análise de flutter via polos complexos próximos jω.",
                                "Eletrônica: Amplificadores operacionais em sistemas de navegação.",
                                "Matemática: Análise complexa e contorno integrals para resíduos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, analisa resposta em frequência de atuadores de controle de voo (ex: elevons), prevendo largura de banda para manobras rápidas e evitando ressonâncias com modos estruturais da asa, essencial para certificação FAA via Bode plots em Simulink."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Estabilidade da Função de Transferência",
                        "description": "Critérios para determinar a estabilidade BIBO de sistemas LTI a partir da localização dos polos no plano s.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Verificar estabilidade usando localização de polos",
                            "description": "Determinar se um sistema é estável, instável ou marginalmente estável verificando se todos os polos estão no semiplano esquerdo Re(s)<0, incluindo casos de polos múltiplos na origem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter a função de transferência ou equação característica do sistema",
                                  "subSteps": [
                                    "Identifique a função de transferência G(s) = N(s)/D(s) a partir do diagrama de blocos ou modelo do sistema.",
                                    "Extraia o denominador D(s), que é o polinômio característico.",
                                    "Escreva a equação característica D(s) = 0.",
                                    "Verifique se há polos no infinito ou simplificações necessárias.",
                                    "Confirme que o sistema é linear e invariante no tempo (LTI)."
                                  ],
                                  "verification": "Função de transferência escrita corretamente com denominador identificado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de blocos do sistema",
                                    "Folha de papel ou software como MATLAB/Simulink"
                                  ],
                                  "tips": "Sempre normalize a FT para grau do denominador maior ou igual ao numerador.",
                                  "learningObjective": "Compreender a origem dos polos na função de transferência.",
                                  "commonMistakes": [
                                    "Confundir numerador com denominador",
                                    "Ignorar fatores comuns que cancelam polos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as raízes do polinômio característico (polos)",
                                  "subSteps": [
                                    "Escreva o polinômio D(s) = a_n s^n + ... + a_0 = 0.",
                                    "Use método analítico para polinômios de baixa ordem (até 3º grau) ou numérico para maiores.",
                                    "Aplique fórmula quadrática para 2ª ordem: s = [-b ± sqrt(b²-4ac)] / 2a.",
                                    "Para polinômios altos, use fatoração ou ferramentas computacionais.",
                                    "Liste todos os polos, incluindo multiplicidades."
                                  ],
                                  "verification": "Lista completa de polos com partes real e imaginária calculadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "MATLAB (roots() ou rlocus())",
                                    "Tabelas de raízes para polinômios conhecidos"
                                  ],
                                  "tips": "Verifique multiplicidade contando quantas vezes a raiz aparece.",
                                  "learningObjective": "Dominar o cálculo preciso de polos de polinômios.",
                                  "commonMistakes": [
                                    "Erros aritméticos na fórmula quadrática",
                                    "Esquecer polos complexos conjugados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar e analisar a localização dos polos no plano complexo s",
                                  "subSteps": [
                                    "Desenhe o eixo real (Re(s)) horizontal e imaginário (Im(s)) vertical.",
                                    "Marque cada polo com 'x' no ponto (σ + jω), onde σ = Re(s).",
                                    "Identifique polos no semiplano esquerdo (Re(s) < 0), origem ou direito.",
                                    "Note polos múltiplos, especialmente na origem.",
                                    "Crie um esboço do mapa de polos para visualização."
                                  ],
                                  "verification": "Mapa de polos plotado com todos os polos corretamente posicionados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Software como MATLAB (pzmap()) ou Python (control.pzmap)"
                                  ],
                                  "tips": "Use escala logarítmica para polos muito próximos da origem se necessário.",
                                  "learningObjective": "Visualizar e interpretar localização de polos no plano s.",
                                  "commonMistakes": [
                                    "Confundir eixos real e imaginário",
                                    "Ignorar conjugados simétricos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar o tipo de estabilidade com base nas regras",
                                  "subSteps": [
                                    "Estável: Todos polos com Re(s) < 0.",
                                    "Instável: Qualquer polo com Re(s) > 0.",
                                    "Marginalmente estável: Polos simples na origem (jω axis, incluindo j0), nenhum com Re(s) > 0.",
                                    "Instável para múltiplos polos na origem.",
                                    "Classifique e justifique com referências aos polos."
                                  ],
                                  "verification": "Conclusão de estabilidade escrita com justificativa baseada nos polos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de critérios de estabilidade",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Lembre: polos na origem simples = oscilação sustentada; múltiplos = instável.",
                                  "learningObjective": "Aplicar critérios de estabilidade por localização de polos.",
                                  "commonMistakes": [
                                    "Considerar polos na origem como sempre estáveis",
                                    "Esquecer multiplicidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a função de transferência de um estabilizador de atitude em aeronave G(s) = 1 / (s^2 + 2s + 2), calcule polos s = -1 ± j1 (ambos Re(s)<0) → sistema estável. Se G(s) = 1 / s^2, polos duplos em s=0 → instável.",
                              "finalVerifications": [
                                "Todos os polos foram calculados corretamente com multiplicidades.",
                                "Mapa de polos plotado com posições precisas.",
                                "Classificação de estabilidade (estável/instável/marginal) justificada.",
                                "Casos especiais (polos na origem) tratados adequadamente.",
                                "Nenhuma inconsistência entre cálculo e conclusão.",
                                "Exemplo prático resolvido sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de raízes (90% correto).",
                                "Correta interpretação de localização no plano s.",
                                "Aplicação precisa dos critérios de estabilidade.",
                                "Qualidade do mapa de polos e visualização.",
                                "Justificativa clara e concisa.",
                                "Tratamento de casos edge (múltiplos polos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações polinomiais e números complexos.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento.",
                                "Engenharia de Controle: Projeto de controladores para mover polos.",
                                "Informática: Uso de software numérico para análise de sistemas.",
                                "Engenharia Mecânica: Vibrações e estabilidade estrutural."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, verifica-se a estabilidade de sistemas de controle de voo (ex: autopilot) para evitar oscilações ou divergências que poderiam levar a perda de controle da aeronave, como no caso de falhas em estabilizadores de cauda."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Aplicar critério de Routh-Hurwitz para estabilidade",
                            "description": "Construir tabela de Routh para o denominador da H(s) e identificar número de polos instáveis sem calcular raízes explicitamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar o polinômio característico",
                                  "subSteps": [
                                    "Extraia o denominador da função de transferência H(s), que é o polinômio característico.",
                                    "Escreva o polinômio na forma padrão descendente: a_n s^n + a_{n-1} s^{n-1} + ... + a_0.",
                                    "Liste todos os coeficientes a_n, a_{n-1}, ..., a_0 em uma linha horizontal.",
                                    "Verifique se todos os coeficientes são reais e o primeiro coeficiente a_n ≠ 0.",
                                    "Confirme que o grau n é par ou ímpar e prepare para ordenação por potências de s."
                                  ],
                                  "verification": "Coeficientes listados corretamente em array e polinômio escrito sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência H(s)",
                                    "Papel e caneta ou planilha Excel",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre normalize o polinômio dividindo pelo coeficiente líder se necessário para simplificar.",
                                  "learningObjective": "Preparar o polinômio denominador para construção da tabela de Routh.",
                                  "commonMistakes": [
                                    "Esquecer termos de potências pares ou ímpares",
                                    "Coeficientes com sinal errado",
                                    "Não verificar a_n ≠ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir as primeiras duas linhas da tabela de Routh",
                                  "subSteps": [
                                    "Primeira linha (s^n): Coloque coeficientes dos termos pares começando de a_n: a_n, a_{n-2}, a_{n-4}, ...",
                                    "Segunda linha (s^{n-1}): Coloque coeficientes dos termos ímpares: a_{n-1}, a_{n-3}, a_{n-5}, ...",
                                    "Complete as linhas com zeros à direita se necessário para alinhar colunas.",
                                    "Rótule as linhas com potências de s decrescentes: s^n, s^{n-1}.",
                                    "Verifique se a segunda linha não é toda zero (caso especial futuro)."
                                  ],
                                  "verification": "Primeiras duas linhas da tabela preenchidas corretamente e alinhadas por colunas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de coeficientes do Step 1",
                                    "Papel quadriculado ou software como MATLAB",
                                    "Calculadora"
                                  ],
                                  "tips": "Use alinhamento tabular para evitar erros de posicionamento de coeficientes.",
                                  "learningObjective": "Estabelecer a base da tabela de Routh com coeficientes organizados por paridade.",
                                  "commonMistakes": [
                                    "Confundir ordem par/ímpar de coeficientes",
                                    "Inserir zeros no lugar errado",
                                    "Esquecer completar com zeros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar a tabela de Routh usando recursão",
                                  "subSteps": [
                                    "Para cada elemento da terceira linha em diante: b1 = -det([primeira_coluna_acima]) / divisor, onde divisor é o primeiro da linha anterior.",
                                    "Calcule elementos linha por linha: para linha k, coluna j: -1 * det da matriz 2x2 das duas linhas acima / primeiro elemento da linha anterior.",
                                    "Continue até a linha s^0 ou até completar n+1 linhas.",
                                    "Trate casos especiais: linha toda zero (substitua por derivada da linha anterior), primeira coluna zero (epsilon método).",
                                    "Preencha todas as colunas consistentemente."
                                  ],
                                  "verification": "Tabela completa sem divisões por zero não tratadas e cálculos consistentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela parcial do Step 2",
                                    "Calculadora científica",
                                    "Folha de fórmulas de Routh"
                                  ],
                                  "tips": "Anote o determinante explicitamente: det = |a1 a2; b1 b2| para clareza.",
                                  "learningObjective": "Dominar a recursão para preencher a tabela inteira.",
                                  "commonMistakes": [
                                    "Erro no sinal do determinante (-1 factor)",
                                    "Divisor errado (não primeiro da linha acima)",
                                    "Ignorar casos especiais como linha zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a tabela para determinar estabilidade",
                                  "subSteps": [
                                    "Examine a primeira coluna da tabela completa.",
                                    "Conte o número de mudanças de sinal na primeira coluna (de + para - ou vice-versa).",
                                    "Número de mudanças de sinal = número de polos com parte real positiva (instáveis).",
                                    "Conclua: sistema estável se zero mudanças de sinal e nenhum zero na primeira coluna.",
                                    "Registre polos instáveis e sugira próximos passos se instável."
                                  ],
                                  "verification": "Conclusão de estabilidade com contagem correta de mudanças de sinal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela completa do Step 3",
                                    "Papel para marcar sinais"
                                  ],
                                  "tips": "Destaque sinais na primeira coluna com cores para visualização rápida.",
                                  "learningObjective": "Interpretar resultados da tabela para avaliar estabilidade sem raízes.",
                                  "commonMistakes": [
                                    "Contar mudanças de sinal em colunas erradas",
                                    "Ignorar zeros na primeira coluna",
                                    "Confundir estabilidade (zero mudanças)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = 1 / (s^3 + 3s^2 + 2s + 1):\nCoeficientes: [1, 3, 2, 1]\nTabela de Routh:\ns^3: 1  2\ns^2: 3  1\ns^1: (3*2-1*1)/3=5/3  0\ns^0: 1\nPrimeira coluna: 1,3,5/3,1 (sem mudanças de sinal) → Estável.",
                              "finalVerifications": [
                                "Construir tabela correta para polinômio de 3ª ordem dado.",
                                "Identificar corretamente 2 polos instáveis em exemplo instável.",
                                "Tratar caso de linha zero com derivada.",
                                "Concluir estabilidade sem calcular raízes.",
                                "Explicar número de mudanças de sinal.",
                                "Aplicar a sistemas de transferência reais."
                              ],
                              "assessmentCriteria": [
                                "Tabela de Routh sem erros aritméticos (100% precisão).",
                                "Tratamento correto de casos especiais.",
                                "Contagem precisa de mudanças de sinal.",
                                "Conclusão de estabilidade justificada.",
                                "Tempo de execução eficiente (<80 min total).",
                                "Explicação clara do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e determinantes.",
                                "Física: Dinâmica linear e equações diferenciais.",
                                "Engenharia de Controle: Projeto de estabilizadores.",
                                "Programação: Implementação numérica em MATLAB/Python.",
                                "Estatística: Análise de estabilidade probabilística."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, o critério de Routh-Hurwitz é usado para verificar rapidamente a estabilidade de funções de transferência em sistemas de controle de voo, como estabilizadores de atitude em aviões, evitando simulações caras ou cálculos de raízes complexas durante o design de controladores PID."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Relacionar estabilidade com resposta em frequência",
                            "description": "Explicar por que sistemas estáveis têm |H(jω)| → 0 quando ω → ∞ e integrar com propriedades de polos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade e polos da função de transferência",
                                  "subSteps": [
                                    "Defina estabilidade BIBO para sistemas LTI: saída limitada para entrada limitada.",
                                    "Identifique que estabilidade requer todos os polos de H(s) no semiplano esquerdo (Re(p) < 0).",
                                    "Explique a estrutura de H(s) = N(s)/D(s), destacando sistemas próprios (grau D > grau N).",
                                    "Liste propriedades: polos determinam modos transitórios, zeros afetam resposta.",
                                    "Discuta causalidade e sistemas físicos realistas."
                                  ],
                                  "verification": "Escreva uma definição precisa de estabilidade e identifique polos em um exemplo simples como H(s) = 1/(s+1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Sinais e Sistemas (Oppenheim), caderno para anotações, calculadora.",
                                  "tips": "Desenhe o plano s para visualizar semiplanos.",
                                  "learningObjective": "Compreender a relação entre polos e estabilidade em funções de transferência.",
                                  "commonMistakes": "Confundir estabilidade com ausência de polos no eixo imaginário; lembrar que polos no semiplano direito causam instabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a resposta em frequência e magnitude |H(jω)|",
                                  "subSteps": [
                                    "Substitua s = jω em H(s) para obter H(jω).",
                                    "Calcule a magnitude |H(jω)| = |N(jω)| / |D(jω)|.",
                                    "Plote |H(jω)| em escala log-log para Bode.",
                                    "Discuta comportamento em baixas e altas frequências.",
                                    "Relacione com transformada de Fourier de impulsos."
                                  ],
                                  "verification": "Compute |H(jω)| para H(s) = 1/(s+1) e verifique decréscimo em ω alto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (Sympy/Matlab para plots Bode), exemplos de funções de transferência.",
                                  "tips": "Use aproximações assintóticas iniciais para facilitar cálculos.",
                                  "learningObjective": "Dominar a avaliação da resposta em frequência a partir de H(s).",
                                  "commonMistakes": "Esquecer de normalizar ângulos de fase ao calcular magnitude; sempre verifique unidades de ω."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento assintótico de |H(jω)| quando ω → ∞",
                                  "subSteps": [
                                    "Para sistemas próprios (p = grau D > grau N = z), |H(jω)| ≈ K / ω^{p-z} para ω grande.",
                                    "Demonstre que p - z ≥ 1 implica |H(jω)| → 0 quando ω → ∞.",
                                    "Use teorema de Riemann-Lebesgue: FT de sinal de energia finita decai em ∞.",
                                    "Discuta exceções: sistemas impróprios amplificam altas frequências.",
                                    "Integre com propriedades físicas: sistemas reais filtram ruído alto."
                                  ],
                                  "verification": "Derive assintótica para H(s) = 1/s^2 e confirme |H| → 0.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de derivadas assintóticas, MATLAB para simulações numéricas.",
                                  "tips": "Considere apenas termos dominantes de maior grau.",
                                  "learningObjective": "Explicar matematicamente o decaimento em alta frequência.",
                                  "commonMistakes": "Ignorar ordem relativa p-z; sistemas biproprios podem não decair se p=z."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar estabilidade via polos com o decaimento de |H(jω)|",
                                  "subSteps": [
                                    "Estabilidade (polos Re<0) garante existência de H(jω) contínua no imaginário.",
                                    "Sistemas instáveis têm |H(jω)| → ∞ perto de polos imaginários.",
                                    "Relacione: estabilidade + próprio → |H(jω)| → 0 em ∞, sem ressonâncias infinitas.",
                                    "Exemplo: polo em jω0 causa pico em |H| em ω0.",
                                    "Conclua: decaimento assegura rejeição de ruído alto em sistemas estáveis."
                                  ],
                                  "verification": "Compare |H(jω)| para sistema estável H(s)=(s+1)/(s^2+2s+2) vs instável H(s)=1/(s-1).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplos de currículo (PS-22), simulador online de Bode plots.",
                                  "tips": "Sempre teste com plots para validar teoria.",
                                  "learningObjective": "Relacionar estabilidade, polos e resposta em frequência de forma integrada.",
                                  "commonMistakes": "Atribuir decaimento só à estabilidade, ignorando necessidade de ser próprio."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e sintetizar o conhecimento com exemplos",
                                  "subSteps": [
                                    "Analise H(s) de um oscilador amortecido em aeronáutica.",
                                    "Preveja comportamento: estável → decaimento; instável → crescimento.",
                                    "Discuta implicações em controle: roll-off garante robustez.",
                                    "Crie diagrama conceitual ligando polos → estabilidade → |H|→0.",
                                    "Resolva exercício: prove para polinomio qualquer estável próprio."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que instáveis não decaem uniformemente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Problemas de exercícios de controle aéreo, software de plotagem.",
                                  "tips": "Use analogias: polos como 'molas' que 'afundam' em altas velocidades.",
                                  "learningObjective": "Sintetizar a relação em contexto aeronáutico.",
                                  "commonMistakes": "Generalizar sem considerar bipropriedade; teste múltiplos casos."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave, considere H(s) = 10 / (s^2 + 5s + 10). Todos polos têm Re<0 (estável). Calcule |H(jω)| ≈ 10/ω^2 para ω>>√10, confirmando →0 em altas frequências, rejeitando turbulências rápidas.",
                              "finalVerifications": [
                                "Derivar assintótica |H(jω)| para H(s) dado e mostrar →0.",
                                "Identificar polos e afirmar estabilidade corretamente.",
                                "Explicar por que instabilidade causa falha no decaimento.",
                                "Plotar Bode e apontar roll-off em alta frequência.",
                                "Relacionar com rejeição de ruído em aplicações reais.",
                                "Discutir exceções para sistemas impróprios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação assintótica (p-z correto).",
                                "Correta identificação de estabilidade via polos.",
                                "Explicação clara da integração polos-estabilidade-decaimento.",
                                "Uso adequado de exemplos com cálculos numéricos/plots.",
                                "Profundidade em implicações físicas/aeronáuticas.",
                                "Ausência de erros comuns como confundir próprio com estável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e limites assintóticos.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento.",
                                "Engenharia de Controle: Projeto de compensadores com roll-off.",
                                "Processamento de Sinais: Filtros e teoremas de Fourier."
                              ],
                              "realWorldApplication": "No design de autômatos de voo em aeronaves, essa relação garante que controles estáveis ignorem ruídos de alta frequência (vibrações, turbulência), evitando oscilações perigosas e mantendo estabilidade em manobras rápidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Causalidade e Minimalidade",
                        "description": "Propriedades de causalidade (resposta depende apenas de entradas passadas/futuras) e minimalidade (realização de ordem mínima sem cancelamentos desnecessários).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Verificar causalidade de uma função de transferência",
                            "description": "Confirmar causalidade para sistemas LTI contínuos verificando se H(s) é racional própria (grau de N(s) < grau de D(s)) e polos no semiplano esquerdo para estabilidade causal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar a forma da função de transferência H(s)",
                                  "subSteps": [
                                    "Escreva a função de transferência no formato H(s) = N(s)/D(s), onde N(s) é o numerador e D(s) o denominador.",
                                    "Identifique os polinômios N(s) e D(s) explicitamente.",
                                    "Calcule o grau do numerador (grauN) contando o maior expoente com coeficiente não zero em N(s).",
                                    "Calcule o grau do denominador (grauD) da mesma forma para D(s).",
                                    "Verifique se grauN < grauD; se não, a função não é própria e não é causal."
                                  ],
                                  "verification": "Confirme que grauN < grauD foi calculado corretamente e documentado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência dada",
                                    "Papel e caneta ou software como MATLAB/SymPy"
                                  ],
                                  "tips": "Sempre normalize H(s) para coeficiente líder de D(s) = 1 para simplificar.",
                                  "learningObjective": "Entender a condição de racional própria para causalidade em sistemas LTI.",
                                  "commonMistakes": [
                                    "Confundir grau com número de termos",
                                    "Ignorar coeficientes zero em expoentes altos",
                                    "Esquecer de simplificar frações comuns antes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar os polos da função de transferência",
                                  "subSteps": [
                                    "Escreva a equação característica: D(s) = 0.",
                                    "Fatore D(s) se possível ou use método numérico para encontrar raízes.",
                                    "Liste todos os polos p_i como raízes complexas (a + jb).",
                                    "Verifique multiplicidade de polos (raízes repetidas).",
                                    "Confirme que não há polos no infinito (já garantido por ser própria)."
                                  ],
                                  "verification": "Todos os polos foram encontrados e listados com precisão numérica ou exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou MATLAB (roots() ou solve())",
                                    "Tabela de raízes quadráticas"
                                  ],
                                  "tips": "Para polinômios de grau >4, use ferramentas computacionais para precisão.",
                                  "learningObjective": "Dominar a extração de polos do denominador para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Erro em fatoração de polinômios quadráticos",
                                    "Ignorar polos complexos conjugados",
                                    "Confundir zeros com polos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a localização dos polos no plano s",
                                  "subSteps": [
                                    "Desenhe o plano complexo s (eixo real horizontal, imaginário vertical).",
                                    "Plote cada polo p_i e identifique sua parte real Re(p_i).",
                                    "Cheque se Re(p_i) < 0 para todos os polos (semiplano esquerdo).",
                                    "Identifique qualquer polo com Re(p_i) >= 0 (instável ou marginal).",
                                    "Anote o semiplano de cada polo explicitamente."
                                  ],
                                  "verification": "Diagrama do plano s com polos plotados e condição Re<0 confirmada para todos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de plotagem (pzmap no MATLAB)"
                                  ],
                                  "tips": "Use escala logarítmica para partes reais próximas de zero para melhor visualização.",
                                  "learningObjective": "Aplicar critério de Hurwitz-Routh visualmente para causalidade e estabilidade.",
                                  "commonMistakes": [
                                    "Confundir semiplano esquerdo com direito",
                                    "Esquecer polos imaginários puros (Re=0)",
                                    "Não considerar multiplicidade em polos na borda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir sobre a causalidade da função de transferência",
                                  "subSteps": [
                                    "Revise as duas condições: (1) própria (grauN < grauD) e (2) todos polos em SPE.",
                                    "Se ambas verdadeiras, classifique como causal e estável.",
                                    "Se falhar em qualquer, identifique a falha específica e sugira correção.",
                                    "Documente o resultado em um relatório curto.",
                                    "Teste com variação: altere H(s) e reverifique."
                                  ],
                                  "verification": "Conclusão escrita com justificativa e exemplo de teste variado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Relatório template",
                                    "Exemplos de H(s) variadas"
                                  ],
                                  "tips": "Lembre-se: causalidade requer própria + ROC incluindo jw-axis, mas para LTI contínuos próprios, SPE garante.",
                                  "learningObjective": "Integrar verificações para julgamento final de causalidade em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Afirmar causal sem checar ambas condições",
                                    "Confundir estabilidade com causalidade",
                                    "Não testar casos limite"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = (s + 2) / (s^2 + 4s + 3) = (s+2)/((s+1)(s+3)): grauN=1 < grauD=2 (própria); polos em s=-1 e s=-3 (ambos Re<0). Conclusão: Causal e estável. Caso contrário, H(s)=1/(s-1): polo em s=1 (Re>0), não causal/estável.",
                              "finalVerifications": [
                                "Graus de N(s) e D(s) calculados corretamente.",
                                "Todos polos localizados com exatidão.",
                                "Localização no SPE confirmada para cada polo.",
                                "Conclusão lógica baseada em ambas condições.",
                                "Exemplo prático resolvido sem erros.",
                                "Relatório documenta todas as verificações."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de graus (100% correto).",
                                "Identificação completa e precisa de polos (erro <1%).",
                                "Análise correta de localização no plano s.",
                                "Conclusão integrada e justificada.",
                                "Uso adequado de ferramentas e documentação clara.",
                                "Tratamento de casos edge (polos na borda, próprios estritas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra polinomial e raízes de equações.",
                                "Física: Dinâmica de sistemas lineares e estabilidade.",
                                "Programação: Simulação em MATLAB/Python para pzplot e roots.",
                                "Engenharia de Controle: Análise de laços de feedback em aeronaves.",
                                "Estatística: Análise de incertezas em polos estimados."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, verificar causalidade de funções de transferência em sistemas de controle de voo (ex: autopilot de UAVs) garante que comandos sejam processados apenas após aplicação, evitando instabilidades catastróficas em manobras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Detectar cancelamentos de polos e zeros",
                            "description": "Identificar fatores comuns em N(s) e D(s) que indicam não-minimalidade e simplificar H(s) para forma mínima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a Função de Transferência H(s)",
                                  "subSteps": [
                                    "Escreva H(s) na forma racional H(s) = N(s)/D(s), onde N(s) é o numerador e D(s) o denominador.",
                                    "Identifique os graus de N(s) e D(s) para verificar se é própria ou imprópria.",
                                    "Normalize os coeficientes líderes para 1, se aplicável.",
                                    "Anote os polos como raízes de D(s)=0 e zeros como raízes de N(s)=0.",
                                    "Verifique se H(s) está em forma polinomial explícita."
                                  ],
                                  "verification": "Confirme que H(s) está separada em N(s) e D(s) com graus anotados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como MATLAB ou Python (SymPy) para verificação opcional"
                                  ],
                                  "tips": "Sempre comece expandindo ou escrevendo os polinômios explicitamente para clareza.",
                                  "learningObjective": "Compreender a estrutura fundamental de H(s) como fração racional.",
                                  "commonMistakes": [
                                    "Confundir numerador com denominador",
                                    "Esquecer de considerar multiplicidades de raízes",
                                    "Ignorar normalização de coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Fatorar Numerador e Denominador",
                                  "subSteps": [
                                    "Fatore completamente N(s) em fatores lineares (s - z_i) ou quadráticos irreducíveis.",
                                    "Fatore completamente D(s) em fatores lineares (s - p_j) ou quadráticos irreducíveis.",
                                    "Identifique as raízes (zeros e polos) usando fórmula quadrática ou métodos numéricos se necessário.",
                                    "Escreva N(s) = k ∏ (s - z_i)^{m_i} e D(s) = ∏ (s - p_j)^{n_j}, anotando multiplicidades.",
                                    "Verifique a fatoração multiplicando de volta para confirmar igualdade."
                                  ],
                                  "verification": "Multiplique os fatores de volta e confirme que obtém o polinômio original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de raízes quadráticas",
                                    "Calculadora gráfica ou SymPy"
                                  ],
                                  "tips": "Use fatoração por agrupamento para polinômios de grau alto; teste raízes racionais possíveis.",
                                  "learningObjective": "Dominar a fatoração de polinômios para expor polos e zeros.",
                                  "commonMistakes": [
                                    "Erros em raízes complexas (não considerar pares conjugados)",
                                    "Esquecer multiplicidades",
                                    "Fatorar incorretamente quadráticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Fatores Comuns (Cancelamentos)",
                                  "subSteps": [
                                    "Compare os fatores de N(s) e D(s) para identificar fatores idênticos.",
                                    "Anote a menor multiplicidade para cada fator comum (s - c_k).",
                                    "Marque fatores comuns com destaque (ex: sublinhe ou circule).",
                                    "Confirme que fatores comuns indicam cancelamento, implicando não-minimalidade.",
                                    "Registre o número e tipo de cancelamentos (real, complexo, múltiplo)."
                                  ],
                                  "verification": "Liste explicitamente todos os fatores comuns com suas multiplicidades mínimas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado para alinhamento visual"
                                  ],
                                  "tips": "Alinhe verticalmente os fatores de N(s) e D(s) para comparação fácil.",
                                  "learningObjective": "Identificar precisamente cancelamentos de polos e zeros comuns.",
                                  "commonMistakes": [
                                    "Ignorar multiplicidades diferentes",
                                    "Confundir fatores semelhantes mas distintos",
                                    "Não notar cancelamentos em quadráticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificar H(s) para Forma Mínima",
                                  "subSteps": [
                                    "Cancele cada fator comum elevado à menor multiplicidade compartilhada.",
                                    "Reescreva H(s)_min = N(s)/fatores_comuns / D(s)/fatores_comuns.",
                                    "Multiplique os fatores restantes para obter polinômios simplificados.",
                                    "Verifique os graus reduzidos de N_min(s) e D_min(s).",
                                    "Confirme que não há mais fatores comuns remanescentes."
                                  ],
                                  "verification": "Substitua valores de s em H(s) original e simplificada para confirmar igualdade (exceto nos polos cancelados).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para plotagem de Bode para visualização opcional"
                                  ],
                                  "tips": "Cancele apenas até a multiplicidade mínima; mantenha o ganho DC se aplicável.",
                                  "learningObjective": "Aplicar cancelamento para obter a realização mínima de H(s).",
                                  "commonMistakes": [
                                    "Cancelar além da multiplicidade mínima",
                                    "Alterar o ganho constante",
                                    "Introduzir erros na multiplicação pós-cancelamento"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Minimalidade e Propriedades",
                                  "subSteps": [
                                    "Confirme que N_min(s) e D_min(s) são coprimos (sem fatores comuns).",
                                    "Calcule os polos e zeros finais da forma mínima.",
                                    "Verifique causalidade: grau D_min >= grau N_min.",
                                    "Anote impacto na ordem do sistema (redução de ordem).",
                                    "Discuta implicações: modos não observáveis/controláveis."
                                  ],
                                  "verification": "Use teste de Euclides estendido ou fatoração para provar coprimos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Algoritmo de Euclides para MDC de polinômios"
                                  ],
                                  "tips": "Para sistemas físicos, cancelamentos indicam modos ocultos; investigue causalidade.",
                                  "learningObjective": "Validar a minimalidade e entender consequências de cancelamentos.",
                                  "commonMistakes": [
                                    "Declarar mínima sem verificar coprimos",
                                    "Ignorar violações de causalidade",
                                    "Subestimar redução de ordem"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada H(s) = [(s+1)(s+2)] / [(s+1)^2 (s+3)], fatoramos: N(s)=(s+1)(s+2), D(s)=(s+1)(s+1)(s+3). Fator comum: (s+1)^1. Simplifique para H_min(s) = (s+2) / [(s+1)(s+3)]. Agora mínima, ordem reduzida de 3 para 2.",
                              "finalVerifications": [
                                "Fatore corretamente N(s) e D(s) em um exemplo dado.",
                                "Identifique todos os fatores comuns com multiplicidades.",
                                "Simplifique H(s) obtendo forma coprima.",
                                "Verifique igualdade numérica em pontos não-polo.",
                                "Explique por que a forma simplificada é mínima.",
                                "Identifique redução de ordem do sistema.",
                                "Confirme causalidade na forma mínima."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatoração de polinômios (100% correto).",
                                "Correta detecção de todos os cancelamentos (sem omissões).",
                                "Simplificação exata sem alterar dinâmica (verificação numérica).",
                                "Explicação clara de minimalidade e implicações.",
                                "Tratamento correto de multiplicidades e ganhos.",
                                "Verificação de coprimos via MDC ou inspeção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de polinômios e MDC euclidiano.",
                                "Controle de Sistemas: Realizações mínimas e observabilidade/controlabilidade.",
                                "Engenharia Aeronáutica: Modelagem dinâmica de aeronaves com modos não observáveis.",
                                "Processamento de Sinais: Filtros com cancelamentos afetando resposta em frequência.",
                                "Física: Sistemas dinâmicos com simetrias ocultas."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, detectar cancelamentos em funções de transferência de atitude garante que controladores ignorem modos não controláveis (ex: flexão estrutural), otimizando estabilidade e reduzindo complexidade computacional em flight controllers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Determinar ordem mínima de uma realização",
                            "description": "Calcular a ordem mínima como grau do denominador após cancelamento de polos/zeros comuns e relacionar com minimalidade da descrição no espaço de estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Polos, Zeros e Cancelamento em Funções de Transferência",
                                  "subSteps": [
                                    "Defina função de transferência como G(s) = N(s)/D(s), onde N(s) é numerador e D(s) denominador.",
                                    "Identifique zeros como raízes de N(s) = 0 e polos como raízes de D(s) = 0.",
                                    "Fatore N(s) e D(s) em fatores lineares ou quadráticos.",
                                    "Detecte fatores comuns entre N(s) e D(s) para cancelamento.",
                                    "Explique que cancelamento reduz a ordem efetiva do sistema."
                                  ],
                                  "verification": "Liste polos e zeros corretos e cancele fatores comuns em uma FT exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica ou app de fatoração"
                                  ],
                                  "tips": "Sempre verifique multiplicidade de raízes ao fatorar polinômios.",
                                  "learningObjective": "Dominar identificação e cancelamento de polos/zeros comuns.",
                                  "commonMistakes": [
                                    "Ignorar multiplicidade em cancelamentos parciais",
                                    "Confundir ordem original com ordem mínima"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Ordem Mínima da Função de Transferência",
                                  "subSteps": [
                                    "Após cancelamento, determine o grau do denominador resultante (D_min(s)).",
                                    "Confirme que numerador resultante tem grau menor ou igual ao denominador.",
                                    "A ordem mínima é o grau de D_min(s); verifique se G(s) está em forma própria mínima.",
                                    "Teste estabilidade dos polos restantes.",
                                    "Registre a FT mínima: G_min(s) = N_min(s)/D_min(s)."
                                  ],
                                  "verification": "Calcule e apresente G_min(s) com ordem correta para uma FT de 4ª ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software simbólico como MATLAB/SymPy",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Use divisão polinomial longa se necessário para confirmar cancelamento completo.",
                                  "learningObjective": "Calcular precisamente a ordem mínima após simplificação.",
                                  "commonMistakes": [
                                    "Não cancelar todos os fatores comuns",
                                    "Contar ordem do numerador como mínima"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Ordem Mínima com Realizações no Espaço de Estados",
                                  "subSteps": [
                                    "Explique que ordem mínima da FT é a dimensão mínima do vetor de estado em uma realização.",
                                    "Discuta minimalidade: realização é mínima se controllável e observável.",
                                    "Use critérios: grau da FT mínima = McMillan degree = dim(estado mínima).",
                                    "Construa uma realização canônica (ex: controllability canonical form) e verifique ordem.",
                                    "Compare com realizações não mínimas que têm ordem maior devido a modos não controlláveis/observáveis."
                                  ],
                                  "verification": "Construa matrizes A,B,C para FT mínima e confirme rank das matrizes de controllabilidade/observabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB ou Python com Control Systems Toolbox",
                                    "Folha de fórmulas de espaço de estados"
                                  ],
                                  "tips": "Verifique rank([B AB A^2B ...]) = n para controllabilidade.",
                                  "learningObjective": "Conectar minimalidade em domínio s com espaço de estados.",
                                  "commonMistakes": [
                                    "Assumir toda realização tem ordem da FT original",
                                    "Ignorar modos cancelados como não mínimos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar Conceitos em Exemplos Práticos",
                                  "subSteps": [
                                    "Aplique processo completo a uma FT com cancelamentos múltiplos.",
                                    "Construa realização no espaço de estados e reduza se não mínima.",
                                    "Simule resposta em frequência para comparar original e mínima.",
                                    "Discuta implicações em estabilidade e desempenho.",
                                    "Documente passos em um relatório curto."
                                  ],
                                  "verification": "Resolva um problema completo e explique por que ordem é mínima.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink)",
                                    "Exemplos de problemas impressos"
                                  ],
                                  "tips": "Plotar polos/zeros no plano s ajuda visualizar cancelamentos.",
                                  "learningObjective": "Integrar cálculo de ordem mínima com análise de sistemas.",
                                  "commonMistakes": [
                                    "Esquecer verificação de observabilidade",
                                    "Não simplificar FT ao máximo"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada G(s) = (s^2 + 3s + 2) / (s^3 + 4s^2 + 5s + 2) = (s+1)(s+2) / [(s+1)(s^2 + 3s + 2)] = (s+2) / (s+1)(s+2) após fatoração parcial, mas completa: cancelamento de (s+1) e (s+2)? Espere, D(s)=(s+1)^2 (s+2), N(s)=(s+1)(s+2), então G_min(s)=1/(s+1), ordem mínima 1. No espaço de estados, realização mínima: A=[-1], B=[1], C=[1], dim=1.",
                              "finalVerifications": [
                                "Calcule ordem mínima corretamente em 3 FTs com cancelamentos variados.",
                                "Construa realização mínima no espaço de estados para uma FT dada.",
                                "Verifique controllabilidade e observabilidade via matrizes rank-plenas.",
                                "Compare respostas em frequência de FT original e mínima.",
                                "Explique impacto de não-minimalidade em simulações.",
                                "Identifique erros em uma solução proposta por pares."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cancelamento de polos/zeros (100% fatores corretos).",
                                "Cálculo correto de ordem mínima (grau exato do denominador).",
                                "Correta ligação com dim(estado) e critérios de minimalidade.",
                                "Uso adequado de ferramentas para verificação (plots, ranks).",
                                "Explicação clara de implicações práticas.",
                                "Ausência de erros comuns como contagem errada de ordem."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Projeto de controladores com modelos mínimos.",
                                "Modelagem Aeronáutica: Redução de ordem em dinâmica de voo.",
                                "Processamento de Sinais: Análise de filtros mínimos para eficiência.",
                                "Matemática Aplicada: Teoria de sistemas lineares e graus de liberdade."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, determinar a ordem mínima de funções de transferência de sistemas de controle de voo permite criar modelos de simulação mais eficientes e precisos, reduzindo tempo computacional em simuladores de aeronaves sem perda de comportamento dinâmico essencial, essencial para certificação de aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Definição de Função de Resposta em Frequência",
                    "description": "Transformada de Fourier da resposta ao impulso, avaliada em jω.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Resposta ao Impulso em Sistemas LTI",
                        "description": "A resposta h(t) de um sistema linear e invariante no tempo (LTI) contínuo a um impulso unitário δ(t), que caracteriza completamente o comportamento do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Definir resposta ao impulso",
                            "description": "Explicar que a resposta ao impulso h(t) é a saída de um sistema LTI quando a entrada é o impulso unitário δ(t), e que ela permite representar qualquer resposta via convolução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Sistemas LTI",
                                  "subSteps": [
                                    "Estudar a definição de sistemas lineares: superposição de respostas para entradas lineares.",
                                    "Analisar invariância no tempo: resposta a entrada deslocada é deslocada igualmente.",
                                    "Identificar exemplos de sistemas LTI, como integradores e atrasos.",
                                    "Diferenciar LTI de sistemas não-lineares ou variantes no tempo.",
                                    "Resolver um exercício simples de verificação de propriedades LTI."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as propriedades de um sistema LTI com um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas (ex: Oppenheim), slides de aula, calculadora.",
                                  "tips": "Use diagramas de blocos para visualizar linearidade e invariância.",
                                  "learningObjective": "Compreender as propriedades essenciais que qualificam um sistema como LTI.",
                                  "commonMistakes": "Confundir linearidade com proporcionalidade simples, ignorando superposição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Caracterizar o Impulso Unitário δ(t)",
                                  "subSteps": [
                                    "Memorizar a definição matemática: δ(t) = ∞ para t=0, integral de -∞ a ∞ = 1.",
                                    "Entender propriedades: sifting (∫ f(t)δ(t) dt = f(0)) e representação de derivadas.",
                                    "Visualizar δ(t) como limite de pulsos retangulares estreitos.",
                                    "Praticar com gráficos: esboçar δ(t) e suas propriedades.",
                                    "Calcular respostas a δ(t) em sistemas simples como ganho constante."
                                  ],
                                  "verification": "Esboçar δ(t) e demonstrar a propriedade sifting com uma função teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel gráfico, software MATLAB ou Python (SymPy para plotagem), notas teóricas.",
                                  "tips": "Pense no impulso como uma 'perfuração' instantânea de energia unitária.",
                                  "learningObjective": "Dominar a definição e propriedades do impulso unitário como entrada fundamental.",
                                  "commonMistakes": "Tratar δ(t) como uma função comum sem considerar sua natureza distributiva."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Resposta ao Impulso h(t)",
                                  "subSteps": [
                                    "Definir h(t) como y(t) = resposta de sistema LTI a x(t) = δ(t).",
                                    "Explicar que h(t) é única para cada LTI causal e captura toda a dinâmica do sistema.",
                                    "Derivar graficamente: h(t) é o 'gráfico de influência' do impulso.",
                                    "Relacionar com função de transferência: H(s) = Laplace{h(t)}.",
                                    "Simular h(t) para um sistema RC simples."
                                  ],
                                  "verification": "Escrever a definição formal de h(t) e identificar seu papel em sistemas LTI.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Simulador MATLAB/Simulink, tabela de Laplace, exemplos resolvidos.",
                                  "tips": "Lembre-se: h(t) é a 'assinatura' temporal do sistema.",
                                  "learningObjective": "Estabelecer h(t) como a resposta característica fundamental de LTI.",
                                  "commonMistakes": "Confundir h(t) com resposta degrau ou ignorar causalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar Resposta ao Impulso com Convolução",
                                  "subSteps": [
                                    "Estudar a fórmula de convolução: y(t) = ∫ h(τ)x(t-τ) dτ.",
                                    "Provar que convolução com δ(t) recupera x(t), validando h(t).",
                                    "Calcular y(t) para entrada arbitrária usando h(t) conhecida.",
                                    "Visualizar convolução como 'varredura' de h(t) sobre x(t).",
                                    "Aplicar em exemplo: convolução para sistema de controle."
                                  ],
                                  "verification": "Derivar e computar uma convolução simples usando h(t) e x(t).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB para convolução numérica, papel para integral analítica.",
                                  "tips": "Use mudança de variável para simplificar cálculos de convolução.",
                                  "learningObjective": "Compreender como h(t) representa qualquer resposta via convolução.",
                                  "commonMistakes": "Invertar limites de integração ou esquecer fator de escala em discretos."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flap de uma aeronave, aplique δ(t) como pulso unitário no atuador; h(t) mostra o decaimento da resposta angular, permitindo simular qualquer comando de voo via convolução.",
                              "finalVerifications": [
                                "Definir precisamente h(t) para sistema LTI.",
                                "Explicar propriedades de δ(t) com exemplo sifting.",
                                "Derivar y(t) = h(t) * x(t) via convolução.",
                                "Identificar h(t) em gráfico de resposta a impulso.",
                                "Diferenciar h(t) de outras respostas (degrau, rampa).",
                                "Relacionar h(t) com função de transferência H(s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição de h(t) e δ(t).",
                                "Correta derivação da propriedade de convolução.",
                                "Capacidade de aplicar conceitos em exemplo numérico ou gráfico.",
                                "Identificação clara de sistemas LTI vs. não-LTI.",
                                "Uso apropriado de terminologia técnica.",
                                "Demonstração de compreensão intuitiva via analogias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integrais de convolução e transformadas integrais.",
                                "Física: Modelagem dinâmica de振動 em estruturas aeronáuticas.",
                                "Engenharia de Controle: Análise de estabilidade via resposta impulsiva.",
                                "Processamento de Sinais: Filtros digitais baseados em h[n].",
                                "Informática: Simulações numéricas em Python/MATLAB."
                              ],
                              "realWorldApplication": "No design de sistemas de controle de voo autônomo em drones ou aviões, h(t) modela respostas a perturbações impulsivas como rajadas de vento, otimizando estabilidade via convolução para trajetórias seguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Propriedades da resposta ao impulso",
                            "description": "Descrever propriedades como causalidade (h(t)=0 para t<0 em sistemas físicos), estabilidade (∫|h(t)|dt < ∞) e relação com função de transferência H(s) via transformada de Laplace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Propriedade de Causalidade",
                                  "subSteps": [
                                    "Defina causalidade em sistemas LTI: a saída não pode preceder a entrada.",
                                    "Explique matematicamente h(t) = 0 para t < 0 em sistemas físicos reais.",
                                    "Discuta razões físicas: efeitos não podem ocorrer antes da causa.",
                                    "Ilustre com gráfico: desenhe h(t) com suporte apenas para t ≥ 0.",
                                    "Compare com sistemas não causais em processamento digital."
                                  ],
                                  "verification": "Desenhe o gráfico de h(t) para um sistema causal e confirme h(t)=0 para t<0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, tabela de transformadas de Laplace básica",
                                  "tips": "Sempre relacione causalidade a 'causa precede efeito' para fixar o conceito.",
                                  "learningObjective": "Definir e ilustrar causalidade na resposta ao impulso de sistemas físicos.",
                                  "commonMistakes": "Assumir causalidade em todos os sistemas; lembre que filtros não causais existem em DSP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Propriedade de Estabilidade",
                                  "subSteps": [
                                    "Defina estabilidade BIBO (Bounded-Input Bounded-Output).",
                                    "Apresente critério: ∫_{-∞}^{∞} |h(t)| dt < ∞.",
                                    "Interprete: energia total finita da resposta ao impulso.",
                                    "Calcule para exemplo simples: h(t) = e^{-t} u(t) (estável) vs. h(t) = e^{t} u(t) (instável).",
                                    "Discuta implicações para polos de H(s) no semiplano esquerdo."
                                  ],
                                  "verification": "Compute ∫ |h(t)| dt para um h(t) dado e confirme se é finita.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora científica, software como MATLAB ou Python (SymPy para integrais)",
                                  "tips": "Use u(t) (degrau unitário) para visualizar respostas.",
                                  "learningObjective": "Aplicar critério matemático de estabilidade à resposta ao impulso.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade BIBO; foque na integral."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Relação com Função de Transferência H(s)",
                                  "subSteps": [
                                    "Revise transformada de Laplace: H(s) = ∫_{-∞}^{∞} h(t) e^{-st} dt.",
                                    "Mostre que H(s) = L{h(t)}, preservando causalidade (ROC inclui Re(s)>0).",
                                    "Verifique propriedades: causalidade implica analiticidade em Re(s)>σ.",
                                    "Exemplo: encontre h(t) via inversa de Laplace de H(s) = 1/(s+1).",
                                    "Analise como polos afetam estabilidade em domínio s."
                                  ],
                                  "verification": "Dado H(s), compute h(t) e verifique causalidade/estabilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Tabela de transformadas de Laplace, MATLAB/SymPy para inversa",
                                  "tips": "Pratique pares Laplace comuns para agilizar cálculos.",
                                  "learningObjective": "Conectar h(t), H(s) e transformada de Laplace.",
                                  "commonMistakes": "Ignorar região de convergência (ROC); ela determina causalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar as Propriedades",
                                  "subSteps": [
                                    "Resuma as três propriedades: causalidade, estabilidade e relação H(s).",
                                    "Resolva problema integrado: dado H(s), encontre h(t), verifique propriedades.",
                                    "Discuta violações: impactos em sistemas reais como aeronaves.",
                                    "Crie diagrama de fluxo: entrada impulso → h(t) → propriedades → H(s).",
                                    "Exercício: adapte para sistema aeronáutico simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades para um sistema dado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de exercícios, simulador online de Laplace (ex: Wolfram Alpha)",
                                  "tips": "Use analogias aeronáuticas: impulso como rajada de vento súbita.",
                                  "learningObjective": "Integrar propriedades em análise completa de sistemas LTI.",
                                  "commonMistakes": "Isolar propriedades; sempre conecte ao contexto físico."
                                }
                              ],
                              "practicalExample": "Em um modelo de controle de atitude de aeronave, H(s) = ω_n^2 / (s^2 + 2ζω_n s + ω_n^2). Compute h(t) via Laplace inversa, verifique h(t)=0 para t<0 (causalidade), calcule ∫|h(t)|dt (estabilidade para ζ>0) e relacione de volta a H(s).",
                              "finalVerifications": [
                                "Pode provar h(t)=0 para t<0 a partir de definição física?",
                                "Calcula corretamente ∫|h(t)|dt e interpreta estabilidade?",
                                "Dado H(s), obtém h(t) via Laplace e verifica propriedades?",
                                "Identifica violações de causalidade/estabilidade em exemplos?",
                                "Explica relação bidirecional h(t) ↔ H(s)?",
                                "Aplica conceitos a um sistema aeronáutico simples?"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas definições e cálculos (ex: integral exata).",
                                "Correta interpretação física (causalidade como causa-efeito).",
                                "Domínio da transformada de Laplace e inversa.",
                                "Capacidade de síntese: conectar propriedades em análise integrada.",
                                "Uso de exemplos concretos e verificações.",
                                "Identificação de erros comuns e evitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas integrais e análise complexa.",
                                "Física: Dinâmica de sistemas lineares e conservação de energia.",
                                "Engenharia de Controle: Análise de estabilidade em malhas fechadas.",
                                "Processamento de Sinais: Filtros LTI e respostas em tempo/frequência."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, propriedades da resposta ao impulso garantem que sistemas de controle de voo (ex: autothrottle) sejam causais (respostas não antecipam comandos) e estáveis (rajadas de vento bounded não causam divergências), essencial para certificação de segurança pela FAA/EASA e simulações de flight dynamics."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Representação da saída via convolução",
                            "description": "Demonstrar que a saída y(t) = ∫ h(τ) x(t-τ) dτ, justificando o papel central de h(t) na análise de sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de sistemas LTI e resposta ao impulso h(t)",
                                  "subSteps": [
                                    "Defina um sistema linear e invariante no tempo (LTI).",
                                    "Explique a resposta ao impulso h(t) como a saída para uma entrada δ(t).",
                                    "Discuta propriedades de linearidade e invariância temporal usando h(t).",
                                    "Represente graficamente h(t) para um sistema simples, como um filtro passa-baixa.",
                                    "Relacione h(t) com a caracterização completa do sistema LTI."
                                  ],
                                  "verification": "Escreva uma definição precisa de LTI e desenhe h(t) para um exemplo, confirmando que captura todas as propriedades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Livro-texto de Sinais e Sistemas",
                                    "Software como MATLAB para plotar impulsos"
                                  ],
                                  "tips": "Use analogias como 'h(t) é a impressão digital do sistema' para fixar o conceito.",
                                  "learningObjective": "Compreender o papel fundamental de h(t) como identificador único de sistemas LTI.",
                                  "commonMistakes": "Confundir h(t) com a função de transferência H(s); lembrar que h(t) é no domínio do tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a operação de convolução e suas propriedades",
                                  "subSteps": [
                                    "Defina a integral de convolução: (x * h)(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ.",
                                    "Demonstre a comutatividade: x * h = h * x.",
                                    "Mostre associatividade e distributividade em relação à adição.",
                                    "Interprete fisicamente: cada fatia de x(τ) é 'pesada' por h(t - τ).",
                                    "Calcule convolução discreta para sequências finitas como prática inicial."
                                  ],
                                  "verification": "Compute (δ * x)(t) = x(t) e prove comutatividade para funções simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou Wolfram Alpha",
                                    "Tabelas de convolução comuns",
                                    "Planilha para cálculos discretos"
                                  ],
                                  "tips": "Visualize convolução como 'deslizar e multiplicar' graficamente para intuição.",
                                  "learningObjective": "Dominar a definição e propriedades matemáticas da convolução.",
                                  "commonMistakes": "Esquecer limites de integração (-∞ a ∞) ou inverter x(τ) e h(t-τ)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a representação da saída y(t) via convolução",
                                  "subSteps": [
                                    "Parta da superposição linear: y(t) = ∫ x'(τ) h(t - τ) dτ, onde x'(τ) = x(τ) δ(t - τ).",
                                    "Aplique o teorema do impulso: substitua δ(t - τ) pela derivada de x(τ).",
                                    "Integre por partes para obter y(t) = ∫ h(τ) x(t - τ) dτ.",
                                    "Verifique para entradas especiais: degrau unitário e impulso.",
                                    "Simule numericamente em software para validar a derivação."
                                  ],
                                  "verification": "Derive passo a passo a fórmula y(t) = ∫ h(τ) x(t - τ) dτ a partir de superposição.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SciPy.signal.convolve)",
                                    "Papel para derivação analítica",
                                    "Exemplos de tabelas de Laplace para verificação"
                                  ],
                                  "tips": "Use mudança de variável σ = t - τ para simplificar integrações.",
                                  "learningObjective": "Derivar rigorosamente a fórmula de convolução para saídas de LTI.",
                                  "commonMistakes": "Erro na ordem da convolução; sempre confirme y(t) = (h * x)(t)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar o papel central de h(t) na análise de sistemas lineares",
                                  "subSteps": [
                                    "Explique que h(t) determina univocamente y(t) para qualquer x(t).",
                                    "Compare com outras representações (diferenças, estados).",
                                    "Discuta estabilidade via ∫ |h(t)| dt < ∞.",
                                    "Analise como h(t) revela características como atraso e amortecimento.",
                                    "Aplique em um caso aeronáutico: resposta de um estabilizador."
                                  ],
                                  "verification": "Escreva um parágrafo justificando por que h(t) é central, com exemplo de estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos sobre controle de aeronaves",
                                    "Simulador como Simulink",
                                    "Gráficos de h(t) para sistemas reais"
                                  ],
                                  "tips": "Pense em h(t) como o 'DNA' do sistema: contém toda informação necessária.",
                                  "learningObjective": "Argumentar o porquê h(t) é essencial para análise e design de sistemas LTI.",
                                  "commonMistakes": "Ignorar que h(t) não funciona para sistemas não-lineares ou não-invariantes."
                                }
                              ],
                              "practicalExample": "Para um circuito RC com h(t) = (1/RC) e^{-t/RC} u(t), entrada x(t) = u(t) (degrau unitário), compute y(t) = ∫_0^t (1/RC) e^{-τ/RC} dτ = 1 - e^{-t/RC}, verificando via simulação em MATLAB que coincide com solução diferencial.",
                              "finalVerifications": [
                                "Deriva corretamente y(t) = ∫ h(τ) x(t-τ) dτ a partir de superposição.",
                                "Calcula convolução para pelo menos dois exemplos (impulso e degrau).",
                                "Justifica verbalmente o papel central de h(t) com propriedades como estabilidade.",
                                "Simula numericamente uma convolução e compara com analítica.",
                                "Identifica erros comuns em derivações de convolução.",
                                "Relaciona h(t) com aplicações em sistemas dinâmicos aeronáuticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula de convolução (peso 30%).",
                                "Correção em cálculos de exemplos práticos (peso 25%).",
                                "Profundidade na justificativa do papel de h(t) (peso 20%).",
                                "Qualidade de simulações e gráficos (peso 15%).",
                                "Clareza na interpretação física e erros evitados (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integrais improprias e transformadas de Laplace.",
                                "Física: Propagação de ondas e respostas transitórias em estruturas aeronáuticas.",
                                "Programação: Implementação de convolução em Python/MATLAB para processamento de sinais.",
                                "Controle Automático: Uso de h(t) em análise de laços de feedback."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, a convolução com h(t) modela a resposta de sistemas de controle de voo a perturbações como rajadas de vento, permitindo simular e otimizar estabilidade em aeronaves via software como Simulink, essencial para certificação de segurança pela ANAC/FAA."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Transformada de Fourier",
                        "description": "Transforma de Fourier que converte sinais do domínio do tempo para o domínio da frequência, definida como integral de Fourier avaliada ao longo do eixo imaginário jω.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Definir transformada de Fourier",
                            "description": "Apresentar a fórmula H(jω) = ∫_{-∞}^∞ h(t) e^{-jωt} dt, explicando que ela representa a decomposição espectral do sinal h(t) em componentes harmônicas complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a motivação e conceitos prévios da Transformada de Fourier",
                                  "subSteps": [
                                    "Revise as séries de Fourier para sinais periódicos, destacando limitações para sinais aperiódicos.",
                                    "Compreenda a necessidade de decompor sinais contínuos em componentes de frequência infinitas.",
                                    "Relacione com o contexto de sistemas dinâmicos em engenharia aeronáutica, como análise de vibrações.",
                                    "Identifique a diferença entre domínio do tempo e domínio da frequência.",
                                    "Estude o par de funções seno e cosseno como base para exponenciais complexas."
                                  ],
                                  "verification": "Explique em 3 frases por que a transformada de Fourier é necessária para sinais não periódicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), caderno de anotações, calculadora científica"
                                  ],
                                  "tips": "Visualize sinais como 'sombras' no domínio da frequência para intuitividade.",
                                  "learningObjective": "Compreender a motivação histórica e prática da transformada de Fourier.",
                                  "commonMistakes": [
                                    "Confundir com série de Fourier sem considerar aperiodicidade",
                                    "Ignorar o papel das exponenciais complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Apresentar e memorizar a fórmula da Transformada de Fourier",
                                  "subSteps": [
                                    "Escreva a fórmula padrão: H(jω) = ∫_{-∞}^∞ h(t) e^{-jωt} dt.",
                                    "Identifique os elementos: h(t) como sinal no tempo, ω como frequência angular, j como unidade imaginária.",
                                    "Pratique a escrita da fórmula 5 vezes, variando notação (H(ω) ou ℱ{h(t)}).",
                                    "Memorize os limites de integração de -∞ a ∞.",
                                    "Compare com a transformada inversa para completude."
                                  ],
                                  "verification": "Recite e escreva a fórmula corretamente sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de fórmulas, quadro branco ou papel quadriculado"
                                  ],
                                  "tips": "Use mnemônicos: 'H de harmônicas, integral infinita com expoente imaginário negativo'.",
                                  "learningObjective": "Memorizar e reproduzir precisamente a fórmula da transformada de Fourier.",
                                  "commonMistakes": [
                                    "Escrever limites errados (ex: 0 a ∞)",
                                    "Confundir sinal do expoente (-jωt vs +jωt)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dissecar os componentes matemáticos da fórmula",
                                  "subSteps": [
                                    "Explique o kernel e^{-jωt} = cos(ωt) - j sin(ωt) como projeção ortogonal.",
                                    "Analise o produto h(t) e^{-jωt} como correlação com harmônica de frequência ω.",
                                    "Discuta a integração como soma ponderada infinita de contribuições.",
                                    "Explore o módulo |H(jω)| como amplitude espectral e fase arg(H(jω)) como defasagem.",
                                    "Verifique dimensionalidade: H(jω) tem unidades de h(t) vezes tempo."
                                  ],
                                  "verification": "Desenhe o kernel para ω fixo e explique sua oscilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy para plotar), gráficos de seno/cosseno"
                                  ],
                                  "tips": "Pense no kernel como um 'detector de frequência' que oscila rapidamente para altas ω.",
                                  "learningObjective": "Decompor e entender cada termo da integral.",
                                  "commonMistakes": [
                                    "Interpretar e^{-jωt} como simples oscilador sem componente imaginário",
                                    "Esquecer normalização da transformada inversa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a decomposição espectral e significado físico",
                                  "subSteps": [
                                    "Descreva H(jω) como coeficientes complexos da expansão em base {e^{jωt}}.",
                                    "Explique decomposição: h(t) = (1/2π) ∫_{-∞}^∞ H(jω) e^{jωt} dω.",
                                    "Relacione com espectro: picos em |H(jω)| indicam frequências dominantes.",
                                    "Aplique ao contexto: resposta em frequência de sistemas aeronáuticos.",
                                    "Discuta convergência para sinais de energia finita."
                                  ],
                                  "verification": "Para um sinal delta, derive H(jω)=1 e explique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de espectros (imagens ou simulações), vídeo explicativo curto"
                                  ],
                                  "tips": "Use analogia musical: Fourier como separar notas de uma acorde.",
                                  "learningObjective": "Interpretar H(jω) como decomposição em harmônicas complexas.",
                                  "commonMistakes": [
                                    "Confundir amplitude com potência espectral",
                                    "Ignorar simetria para sinais reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a transformada de Fourier de um pulso retangular h(t) = 1 para |t| < 1, 0 caso contrário, resultando em H(jω) = 2 sinc(ω/π), e interprete os lóbulos como componentes harmônicas em análise de vibração de flap de asa.",
                              "finalVerifications": [
                                "Escreve corretamente a fórmula H(jω) = ∫_{-∞}^∞ h(t) e^{-jωt} dt.",
                                "Explica o papel do kernel e^{-jωt} em 2 frases.",
                                "Descreve H(jω) como decomposição espectral.",
                                "Diferencia transformada de Fourier de série de Fourier.",
                                "Identifica unidades e limites de integração.",
                                "Relaciona com função de transferência em sistemas dinâmicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na recitação da fórmula (100% correto).",
                                "Profundidade na explicação do significado espectral (cobertura de amplitude e fase).",
                                "Capacidade de relacionar com aplicações em engenharia aeronáutica.",
                                "Identificação correta de pelo menos 3 componentes da fórmula.",
                                "Ausência de erros comuns como sinal do expoente.",
                                "Demonstração de compreensão via exemplo simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e integrais improprias.",
                                "Física: Teoria de ondas e decomposição harmônica.",
                                "Processamento de Sinais: Filtros e análise espectral digital.",
                                "Engenharia Mecânica: Vibrações e ressonância estrutural."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, a transformada de Fourier é usada para analisar espectros de vibrações em testes de fadiga de asas, identificando frequências ressonantes que podem levar a falhas estruturais, permitindo otimização de designs via resposta em frequência H(jω)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Condições de existência da transformada",
                            "description": "Explicar critérios como integrabilidade absoluta (∫|h(t)|dt < ∞) e condições de Dirichlet para convergência da transformada de Fourier de h(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Transformada de Fourier",
                                  "subSteps": [
                                    "Revise a definição da transformada de Fourier: H(ω) = ∫_{-∞}^{∞} h(t) e^{-jωt} dt",
                                    "Identifique por que a convergência é crucial para a existência da transformada",
                                    "Estude o conceito de convergência pontual versus convergência uniforme",
                                    "Analise funções simples como retangular e exponencial para intuición inicial",
                                    "Discuta o papel das condições de existência em sistemas lineares invariantes no tempo (SLIT)"
                                  ],
                                  "verification": "Resuma em suas palavras a definição e o motivo da necessidade de condições de existência",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Vídeos Khan Academy sobre Fourier",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Comece com funções pares para simplificar cálculos iniciais",
                                  "learningObjective": "Entender o contexto matemático e físico da transformada de Fourier",
                                  "commonMistakes": [
                                    "Confundir transformada com série de Fourier",
                                    "Ignorar o domínio de frequência ω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Condição de Integrabilidade Absoluta",
                                  "subSteps": [
                                    "Defina integrabilidade absoluta: ∫_{-∞}^{∞} |h(t)| dt < ∞",
                                    "Prove que ela garante convergência absoluta da integral da transformada",
                                    "Calcule a integral absoluta para funções como decaimento exponencial (h(t) = e^{-a|t|})",
                                    "Identifique funções que violam essa condição, como h(t) = 1 (constante)",
                                    "Verifique numericamente usando software para funções truncadas"
                                  ],
                                  "verification": "Calcule e confirme ∫|h(t)|dt < ∞ para pelo menos duas funções exemplo",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy) para integração numérica",
                                    "Folha de exercícios sobre integrais impróprias"
                                  ],
                                  "tips": "Use simetria para funções pares: 2∫_0^∞ |h(t)| dt",
                                  "learningObjective": "Dominar a condição suficiente de integrabilidade absoluta para existência",
                                  "commonMistakes": [
                                    "Confundir com energia finita L2",
                                    "Esquecer limites de -∞ a ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as Condições de Dirichlet",
                                  "subSteps": [
                                    "Enuncie as condições de Dirichlet: h(t) absolutamente integrável em intervalos finitos, limites em ±∞ existem (finito ou infinito)",
                                    "Analise cada uma das três condições de Jordan-Dirichlet detalhadamente",
                                    "Aplique a funções como degrau unitário e impulso, mostrando convergência em valor médio",
                                    "Compare com integrabilidade absoluta: Dirichlet é mais fraca mas suficiente para convergência pontual",
                                    "Resolva exercícios onde Dirichlet vale mas absoluta não"
                                  ],
                                  "verification": "Classifique três funções quanto ao atendimento de Dirichlet vs. absoluta",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de aula de Sinais e Sistemas Dinâmicos",
                                    "Artigo 'Dirichlet Conditions' no Wikipedia para referência rápida"
                                  ],
                                  "tips": "Lembre: Dirichlet permite funções com descontinuidades finitas",
                                  "learningObjective": "Aplicar condições de Dirichlet para verificar existência em casos práticos",
                                  "commonMistakes": [
                                    "Pensar que Dirichlet requer continuidade",
                                    "Confundir com condições para série de Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar Condições em Exemplos de Sistemas Aeronáuticos",
                                  "subSteps": [
                                    "Selecione funções de resposta impulso h(t) de sistemas vibratórios aeronáuticos",
                                    "Teste condições para h(t) = e^{-ζω t} sin(ω_d t) u(t) (amortecida)",
                                    "Identifique contra-exemplos como osciladores não amortecidos puros",
                                    "Implemente verificação numérica da transformada via FFT para confirmação",
                                    "Discuta implicações para análise de frequência em controle de aeronaves"
                                  ],
                                  "verification": "Produza relatório curto com cálculos para um exemplo aeronáutico",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB Simulink para modelos de sistemas",
                                    "Dados de vibração de asas de aeronaves simulados"
                                  ],
                                  "tips": "Use u(t) (degrau) para causalidade em sistemas reais",
                                  "learningObjective": "Integrar condições de existência ao contexto de engenharia aeronáutica",
                                  "commonMistakes": [
                                    "Ignorar causalidade h(t)=0 para t<0",
                                    "Usar FFT sem windowing adequado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flaps de aeronave, verifique se a resposta impulso h(t) = (1/√(1-ζ²)) e^{-ζω_n t} sin(ω_d t + φ) u(t) satisfaz integrabilidade absoluta calculando ∫|h(t)|dt ≈ 1/ω_n √((1+ζ)/2ζ) < ∞, e Dirichlet (limites em ∞ existem, integrável em finitos).",
                              "finalVerifications": [
                                "Calcule corretamente ∫|h(t)|dt para funções dadas",
                                "Enuncie precisamente as três condições de Dirichlet",
                                "Classifique funções exemplo como existentes ou não",
                                "Explique diferenças entre absoluta e Dirichlet",
                                "Aplique a um sinal real de vibração aeronáutica",
                                "Confirme convergência via plot de |H(ω)|"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática das condições",
                                "Correção em cálculos de integrais impróprias",
                                "Capacidade de identificar violações com justificativa",
                                "Clareza na distinção entre tipos de convergência",
                                "Relevância de exemplos ao contexto de sinais dinâmicos",
                                "Uso adequado de ferramentas numéricas para verificação"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e integrais impróprias",
                                "Física: Dinâmica de sistemas vibratórios em aeronáutica",
                                "Programação: Implementação numérica com FFT em Python/MATLAB",
                                "Engenharia de Controle: Estabilidade e resposta em frequência"
                              ],
                              "realWorldApplication": "Na análise de vibrações estruturais de aeronaves, condições de existência garantem que a transformada de Fourier da resposta impulso converja, permitindo design de filtros para supressão de ruído em sistemas de controle de voo autônomo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Avaliação em jω",
                            "description": "Mostrar que H(jω) é obtida substituindo s = jω na função de transferência H(s), ligando domínio Laplace ao de Fourier para sistemas estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão da Função de Transferência H(s) no Domínio de Laplace",
                                  "subSteps": [
                                    "Defina função de transferência como a razão entre transformada de Laplace da saída e da entrada em condições iniciais nulas.",
                                    "Revise exemplos simples como H(s) = 1/(s + a) para sistemas de primeira ordem.",
                                    "Identifique polos e zeros no plano s e sua relação com a estabilidade (polo no semiplano esquerdo para estabilidade).",
                                    "Pratique representando H(s) graficamente no plano s.",
                                    "Discuta o significado físico de H(s) para sistemas lineares invariantes no tempo (LTI)."
                                  ],
                                  "verification": "Resuma em um parágrafo a definição de H(s) e dê um exemplo com polos/zeros corretos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Papel e lápis para esboços no plano s",
                                    "Software SymPy ou MATLAB para plotar polos"
                                  ],
                                  "tips": "Sempre verifique se o denominador tem grau maior que o numerador para funções próprias.",
                                  "learningObjective": "Compreender o conceito fundamental de H(s) e sua interpretação no domínio Laplace.",
                                  "commonMistakes": [
                                    "Confundir H(s) com a equação diferencial",
                                    "Ignorar condições iniciais nulas",
                                    "Erro na identificação de polos no semiplano direito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introdução à Transformada de Fourier e Resposta em Frequência",
                                  "subSteps": [
                                    "Defina a Transformada de Fourier H(jω) como a resposta em frequência para entradas sinusoidais.",
                                    "Explique que para sistemas LTI estáveis, a saída para e^{jωt} é H(jω) e^{jωt}.",
                                    "Discuta o contorno de integração no plano s que leva à linha jω para sistemas estáveis.",
                                    "Compare domínio Laplace (s complexo) com Fourier (ω real).",
                                    "Pratique convertendo uma sinal temporal simples para Fourier."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a relação entre entrada sinusoidal e saída em H(jω).",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Notas de aula sobre Fourier",
                                    "Calculadora gráfica ou Python (NumPy/Matplotlib)",
                                    "Exemplos de tabelas de Fourier"
                                  ],
                                  "tips": "Lembre-se: Fourier é um caso particular de Laplace ao restringir s à linha imaginária.",
                                  "learningObjective": "Entender H(jω) como resposta em regime permanente a sinusoides.",
                                  "commonMistakes": [
                                    "Aplicar Fourier a sistemas instáveis",
                                    "Confundir magnitude e fase de H(jω)",
                                    "Esquecer normalização por 2π"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecendo a Ligação: Substituição s = jω em H(s)",
                                  "subSteps": [
                                    "Demonstre matematicamente que H(jω) = H(s)|_{s=jω} para sistemas causais e estáveis.",
                                    "Derive a propriedade analítica: integral de H(s) ao longo do eixo jω coincide com Fourier.",
                                    "Explique por que isso só vale para sistemas estáveis (região de convergência inclui eixo jω).",
                                    "Calcule H(jω) para H(s) = 1/(s+1), simplificando para forma polar.",
                                    "Verifique numericamente com valores de ω específicos."
                                  ],
                                  "verification": "Substitua s=jω em um H(s) dado e simplifique corretamente H(jω).",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Folha de exercícios com H(s) simples",
                                    "SymPy para simplificação simbólica",
                                    "Gráfica de Bode manual"
                                  ],
                                  "tips": "Use identidade jω = j*ω para separar real e imaginário facilmente.",
                                  "learningObjective": "Dominar a substituição direta e sua validade matemática.",
                                  "commonMistakes": [
                                    "Substituir sem verificar estabilidade",
                                    "Erros algébricos em jω + a",
                                    "Não racionalizar o denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação de Estabilidade e Aplicação Prática",
                                  "subSteps": [
                                    "Critério de estabilidade: todos polos de H(s) no semiplano esquerdo Re(s) < 0.",
                                    "Para um sistema dado, localize polos e confirme inclusão do eixo jω na ROC.",
                                    "Plote |H(jω)| e arg(H(jω)) para validar a resposta em frequência.",
                                    "Compare com simulação temporal para entrada sinusoidal.",
                                    "Discuta limitações para sistemas não estáveis (ex: uso de jω+ε)."
                                  ],
                                  "verification": "Analise um H(s) instável e explique por que não se pode usar H(jω) diretamente.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Tabela de polos de sistemas padrão",
                                    "Software de plotagem como Python Matplotlib"
                                  ],
                                  "tips": "Use o teste de Routh-Hurwitz para confirmar estabilidade rapidamente.",
                                  "learningObjective": "Aplicar o conceito com verificação de pré-condições de estabilidade.",
                                  "commonMistakes": [
                                    "Assumir estabilidade sem checar polos",
                                    "Ignorar efeitos de fase em baixas frequências",
                                    "Confundir ganho DC com H(0)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = 1/(s² + 2s + 2), verifique estabilidade (polos em -1 ± j1, estável). Substitua s = jω: H(jω) = 1/((jω)² + 2jω + 2) = 1/(-ω² + 2jω + 2). Simplifique: magnitude |H(jω)| = 1/√[(2-ω²)² + (2ω)²], plote para ω de 0 a 10 rad/s.",
                              "finalVerifications": [
                                "Explicar corretamente a origem de H(jω) a partir de H(s).",
                                "Calcular H(jω) para pelo menos dois sistemas de 1ª e 2ª ordem.",
                                "Identificar corretamente sistemas estáveis vs. instáveis.",
                                "Plotar diagrama de Bode básico a partir de H(jω).",
                                "Discutir ligação conceitual Laplace-Fourier em uma frase.",
                                "Simular resposta a senoide e comparar com |H(jω)|."
                              ],
                              "assessmentCriteria": [
                                "Precisão na substituição s = jω (sem erros algébricos).",
                                "Correta verificação de estabilidade via polos.",
                                "Interpretação física de magnitude e fase.",
                                "Uso adequado de ferramentas computacionais.",
                                "Clareza na explicação da ligação entre domínios.",
                                "Aplicação em exemplo não trivial."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Diagrama de Bode para projeto de controladores.",
                                "Processamento de Sinais: Filtros analógicos e resposta em frequência.",
                                "Engenharia Aeronáutica: Análise de flutter e vibrações em asas.",
                                "Física: Oscilações harmônicas forçadas em estruturas.",
                                "Matemática: Análise complexa e contornos de integração."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, avalia-se H(jω) de modelos de dinâmica de voo para prever ressonâncias em frequências de turbulência, garantindo estabilidade e conforto em projetos de aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Definição de Função de Resposta em Frequência",
                        "description": "Função H(jω) definida como a transformada de Fourier da resposta ao impulso h(t), avaliada no eixo jω, que descreve o ganho e fase do sistema para entradas sinusoidais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Definir função de resposta em frequência",
                            "description": "Estabelecer formalmente que a função de resposta em frequência é H(jω) = ℱ{h(t)} = ∫_{-∞}^∞ h(t) e^{-jωt} dt, para sistemas LTI contínuos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de sistemas LTI e resposta ao impulso",
                                  "subSteps": [
                                    "Explique o que é um sistema Linear e Invariante no Tempo (LTI).",
                                    "Descreva a importância da resposta ao impulso h(t) para caracterizar sistemas LTI contínuos.",
                                    "Discuta a relação entre entrada x(t), saída y(t) e convolução: y(t) = x(t) * h(t).",
                                    "Identifique exemplos de sistemas LTI em engenharia aeronáutica, como filtros em sensores.",
                                    "Resuma propriedades da resposta ao impulso (causalidade, estabilidade)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a resposta ao impulso e forneça um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Notas de aula sobre LTI",
                                    "Vídeo introdutório sobre convolução"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar a convolução e evite confundir com sistemas não lineares.",
                                  "learningObjective": "Compreender o papel central da resposta ao impulso h(t) em sistemas LTI contínuos.",
                                  "commonMistakes": [
                                    "Confundir LTI com sistemas invariantes em escala",
                                    "Ignorar a causalidade em sistemas reais",
                                    "Esquecer que h(t) é a saída para impulso unitário δ(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Transformada de Fourier para sinais contínuos",
                                  "subSteps": [
                                    "Defina a Transformada de Fourier ℱ{f(t)} = ∫_{-∞}^∞ f(t) e^{-jωt} dt.",
                                    "Explique as propriedades relevantes: linearidade, convolução no tempo vira multiplicação em frequência.",
                                    "Discuta o significado físico: decomposição em componentes sinusoidais (frequências ω).",
                                    "Calcule a FT do impulso unitário δ(t), que é 1.",
                                    "Revise a transformada inversa para reconstruir o sinal no tempo."
                                  ],
                                  "verification": "Derive a propriedade da convolução na domínio da frequência e teste com um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Fourier",
                                    "Software MATLAB ou Python (SymPy para FT simbólica)",
                                    "Applet interativo de Fourier"
                                  ],
                                  "tips": "Visualize espectros com ferramentas online para intuitar o domínio da frequência.",
                                  "learningObjective": "Dominar a definição e propriedades da Transformada de Fourier aplicadas a sinais.",
                                  "commonMistakes": [
                                    "Usar limites finitos na integral em vez de -∞ a ∞",
                                    "Confundir ω (rad/s) com f (Hz)",
                                    "Esquecer o fator e^{-jωt} na definição direta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente a função de resposta em frequência H(jω)",
                                  "subSteps": [
                                    "Estabeleça que para sistemas LTI, a saída para entrada e^{jωt} é H(jω) e^{jωt}.",
                                    "Defina H(jω) = ℱ{h(t)} = ∫_{-∞}^∞ h(t) e^{-jωt} dt.",
                                    "Mostre que Y(jω) = H(jω) X(jω), justificando a multiplicação no domínio da frequência.",
                                    "Escreva a fórmula completa com notação matemática precisa.",
                                    "Verifique para entrada sinusoidal: ganho |H(jω)| e fase ∠H(jω)."
                                  ],
                                  "verification": "Escreva a definição exata de H(jω) e derive Y(jω) = H(jω) X(jω) a partir da convolução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de derivadas e integrais complexas",
                                    "Exemplos resolvidos de livros de sistemas dinâmicos",
                                    "LaTeX para equações"
                                  ],
                                  "tips": "Lembre-se: H(jω) é avaliada no eixo imaginário, não em s genérico da Laplace.",
                                  "learningObjective": "Estabelecer a definição formal de H(jω) como FT de h(t) para LTI contínuos.",
                                  "commonMistakes": [
                                    "Escrever H(ω) em vez de H(jω)",
                                    "Usar transformada bilateral sem cuidado com causalidade",
                                    "Confundir com função de transferência H(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a função de resposta em frequência",
                                  "subSteps": [
                                    "Interprete |H(jω)| como ganho em frequência e ∠H(jω) como desfase.",
                                    "Discuta simetria para sistemas reais: H(-jω) = H*(jω).",
                                    "Calcule H(jω) para um exemplo simples, como integrador h(t) = u(t).",
                                    "Compare com função de transferência H(s) avaliada em s = jω.",
                                    "Resolva um problema: encontre H(jω) dado h(t)."
                                  ],
                                  "verification": "Compute H(jω) para h(t) = e^{-at} u(t) (a>0) e plote magnitude e fase.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para plotar Bode",
                                    "Papel milimetrado para gráficos manuais",
                                    "Tabela de FT comuns"
                                  ],
                                  "tips": "Sempre normalize ω e verifique limites ω→0 e ω→∞ para intuição física.",
                                  "learningObjective": "Aplicar e validar a definição de H(jω) em contextos práticos.",
                                  "commonMistakes": [
                                    "Ignorar a unidade de u(t) na causalidade",
                                    "Plotar sem considerar estabilidade",
                                    "Confundir domínio Laplace com Fourier"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um circuito RC de primeiro ordem com h(t) = (1/RC) e^{-t/RC} u(t), compute H(jω) = 1 / (1 + jω RC). Verifique que para ω=0, H(0)=1 (ganho DC) e para ω→∞, |H|→0 (filtro passa-baixas), simulando um filtro em sensores de aeronaves.",
                              "finalVerifications": [
                                "Escreve corretamente H(jω) = ∫_{-∞}^∞ h(t) e^{-jωt} dt?",
                                "Explica por que Y(jω) = H(jω) X(jω) para LTI?",
                                "Identifica H(jω) como resposta a e^{jωt}?",
                                "Calcula FT simples como para δ(t)?",
                                "Discute relação com H(s)|_{s=jω}?",
                                "Plota magnitude/fase corretamente para exemplo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula matemática (integral e notação H(jω)).",
                                "Compreensão da ligação convolução ↔ multiplicação em frequência.",
                                "Correta interpretação de ganho e fase.",
                                "Aplicação em exemplo numérico ou gráfico.",
                                "Identificação de condições (LTI contínuo, causal).",
                                "Clareza na explicação verbal ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e integrais de Fourier.",
                                "Física: Análise de ondas e vibrações harmônicas.",
                                "Engenharia de Controle: Diagrama de Bode e estabilidade.",
                                "Processamento de Sinais: Filtros analógicos em aeronáutica.",
                                "Eletrônica: Projeto de amplificadores e atenuadores."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, H(jω) é essencial para analisar vibrações de asas sob cargas sinusoidais (ex.: fadiga por flutter), projetar filtros em sistemas de controle de voo e processar sinais de acelerômetros em testes de dinâmica de aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Relação com resposta em regime permanente",
                            "description": "Explicar que para entrada x(t) = e^{jωt}, a saída é y(t) = H(jω) e^{jωt}, revelando magnitude |H(jω)| como ganho e arg{H(jω)} como desfazagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a entrada fasorial e exponenciais complexas",
                                  "subSteps": [
                                    "Revise a representação de sinais senoidais usando exponenciais complexas: x(t) = Re{e^{jωt}}.",
                                    "Explique que e^{jωt} = cos(ωt) + j sin(ωt) é o fasor unitário.",
                                    "Discuta por que usamos fasores para entradas em regime permanente em sistemas LTI.",
                                    "Pratique convertendo uma senoide real em sua forma fasorial complexa.",
                                    "Identifique a frequência angular ω como parâmetro chave."
                                  ],
                                  "verification": "Escreva a forma fasorial de x(t) = cos(ωt) e confirme que é (1/2)(e^{jωt} + e^{-jωt}).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora científica, tabela de identidades trigonométricas.",
                                  "tips": "Sempre normalize o fasor para amplitude 1 para simplificar cálculos iniciais.",
                                  "learningObjective": "Dominar a representação fasorial de entradas senoidais em regime permanente.",
                                  "commonMistakes": "Confundir ω (rad/s) com f (Hz); esquecer o fator de Euler."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a função de transferência H(jω) em frequência",
                                  "subSteps": [
                                    "Lembre que H(s) é a transformada de Laplace da resposta ao impulso, e H(jω) = H(s)|_{s=jω}.",
                                    "Calcule H(jω) para um sistema simples, como um integrador H(s) = 1/s.",
                                    "Interprete H(jω) = |H(jω)| e^{jφ(ω)}, onde φ(ω) = arg{H(jω)}.",
                                    "Plote manualmente o diagrama de Bode para magnitude e fase de um exemplo.",
                                    "Discuta linearidade e invariância no tempo que permitem essa simplificação."
                                  ],
                                  "verification": "Compute H(jω) para H(s) = 1/(s+1) e identifique ganho e fase em ω=1 rad/s.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem como MATLAB/Octave ou papel milimetrado, exemplos de funções de transferência.",
                                  "tips": "Use substituição s = jω diretamente na fórmula racional de H(s).",
                                  "learningObjective": "Calcular e interpretar H(jω) como operador fasorial.",
                                  "commonMistakes": "Esquecer de racionalizar ou confundir H(jω) com H(ω)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a relação de saída y(t) para entrada fasorial",
                                  "subSteps": [
                                    "Assuma entrada x(t) = e^{jωt} em um sistema LTI estável.",
                                    "Mostre que a saída em regime permanente é y(t) = H(jω) e^{jωt}, usando propriedades da convolução.",
                                    "Expanda: y(t) = |H(jω)| e^{j(ωt + φ(ω))}, revelando ganho e desfazagem.",
                                    "Compare com a resposta transitória que decai para zero.",
                                    "Verifique com o teorema do valor final ou simulação."
                                  ],
                                  "verification": "Derive a equação y(t) = H(jω) x(t) para x(t) = e^{jωt} usando Laplace.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabelas de Laplace, simulador como Python (SciPy) ou MATLAB.",
                                  "tips": "Pense em H(jω) como um multiplicador complexo no domínio fasorial.",
                                  "learningObjective": "Estabelecer a relação fundamental entre entrada fasorial e saída em regime permanente.",
                                  "commonMistakes": "Ignorar o regime permanente vs. total; assumir causalidade sem estabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar magnitude e fase na resposta em regime permanente",
                                  "subSteps": [
                                    "Explique |H(jω)| como fator de amplificação da amplitude.",
                                    "Descreva arg{H(jω)} como atraso de fase em graus ou radianos.",
                                    "Converta fase para tempo de atraso: τ = φ(ω)/ω.",
                                    "Aplique a um exemplo aeroespacial, como resposta de um oscilador massa-mola-amortecedor.",
                                    "Discuta implicações para ressonância e estabilidade."
                                  ],
                                  "verification": "Para um sistema dado, calcule ganho e desfazagem em ω específica e interprete.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de sistemas dinâmicos aeronáuticos, calculadora gráfica.",
                                  "tips": "Use polar plot para visualizar H(jω) intuitivamente.",
                                  "learningObjective": "Relacionar |H(jω)| e arg{H(jω)} com ganho e desfazagem física.",
                                  "commonMistakes": "Confundir fase com ganho; não normalizar unidades de fase."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com simulação e análise prática",
                                  "subSteps": [
                                    "Simule um sistema LTI com entrada senoidal em software.",
                                    "Meça saída em regime permanente e extraia ganho/fase.",
                                    "Compare com H(jω) teórico.",
                                    "Analise erros numéricos e convergência.",
                                    "Documente em relatório curto."
                                  ],
                                  "verification": "Gráfico de x(t) vs y(t) mostra amplitude |H| e fase φ corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB/Simulink, Python (control library), osciloscópio virtual.",
                                  "tips": "Espere transientes iniciais morrerem antes de medir regime permanente.",
                                  "learningObjective": "Confirmar teoricamente através de prática computacional.",
                                  "commonMistakes": "Medir durante transiente; escala errada nos gráficos."
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de atitude em aeronave modelado como H(s) = ω_n^2 / (s^2 + 2ζω_n s + ω_n^2), com entrada x(t) = e^{jωt} (torque senoidal). A saída y(t) = H(jω) e^{jωt} mostra como vibrações de motor afetam ângulo de rolagem: ganho |H(jω)| amplifica perto da frequência natural, e fase arg{H(jω)} indica risco de instabilidade.",
                              "finalVerifications": [
                                "Explicar verbalmente y(t) = H(jω) e^{jωt} para x(t) = e^{jωt}.",
                                "Calcular corretamente |H(jω)| e arg{H(jω)} para H(s) = 1/(s+1) em ω=1.",
                                "Identificar ganho como mudança de amplitude e fase como atraso temporal.",
                                "Simular e plotar resposta confirmando teoria.",
                                "Discutir limitação: válida apenas para regime permanente em sistemas estáveis.",
                                "Relacionar a análise de frequência em aeroespacial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação fasorial (90% correto).",
                                "Interpretação física correta de magnitude e fase.",
                                "Qualidade dos subpassos e verificações em simulações.",
                                "Uso adequado de unidades e normalizações.",
                                "Conexão clara com conceitos prévios de LTI.",
                                "Criatividade em exemplos aeronáuticos."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Diagrama de Bode para estabilidade.",
                                "Vibrações e Acústica: Análise de ressonância em estruturas aeronáuticas.",
                                "Processamento de Sinais: Filtros em telemetria de voo.",
                                "Matemática: Análise complexa e transformadas.",
                                "Física: Oscilações forçadas em dinâmica de voo."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, essa relação é usada para prever como turbulências senoidais (modeladas como e^{jωt}) afetam a resposta em regime permanente de superfícies de controle, calculando ganhos de flutter e desfazagens para certificação de aeronaves pela FAA, evitando fadiga estrutural em frequências críticas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Propriedades da Função de Resposta em Frequência",
                    "description": "Magnitude, fase, diagrama de Bode e análise de ganho e largura de banda.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Magnitude da Resposta em Frequência",
                        "description": "A magnitude da função de resposta em frequência, denotada por |H(jω)|, representa o ganho do sistema em função da frequência angular ω, expressa em dB, e é fundamental para analisar como o sistema amplifica ou atenua sinais sinusoidais de diferentes frequências.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir e calcular a magnitude da função de transferência",
                            "description": "Calcular |H(jω)| = |numerador(jω)/denominador(jω)| para funções de transferência racionais simples, como sistemas de primeira e segunda ordem, utilizando propriedades de módulo de números complexos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Função de Transferência e Magnitude",
                                  "subSteps": [
                                    "Defina função de transferência H(s) como a razão entre polinômio numerador N(s) e denominador D(s).",
                                    "Explique que a resposta em frequência é H(jω), substituindo s = jω.",
                                    "Defina magnitude |H(jω)| como |N(jω)| / |D(jω)|.",
                                    "Discuta importância para análise de sistemas lineares invariantes no tempo (LTI).",
                                    "Identifique sistemas de 1ª e 2ª ordem como exemplos simples."
                                  ],
                                  "verification": "Escreva definições corretas e formule |H(jω)| para um exemplo dado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Sinais e Sistemas",
                                    "Acesso a notas de aula"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar H(s). Memorize que |jω| = ω.",
                                  "learningObjective": "Compreender a definição e notação da magnitude da função de transferência.",
                                  "commonMistakes": [
                                    "Confundir H(s) com H(jω)",
                                    "Esquecer de substituir s = jω",
                                    "Ignorar normalização do denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Propriedades de Módulo de Números Complexos",
                                  "subSteps": [
                                    "Lembre que para z = a + jb, |z| = sqrt(a² + b²).",
                                    "Propriedade: |z1 * z2| = |z1| * |z2| e |z1 / z2| = |z1| / |z2|.",
                                    "Para polinômio P(jω) = ∑ ck (jω)^k, calcule |P(jω)| separando termos reais e imaginários.",
                                    "Pratique com termos simples: |1 + jω| e |jω + 1|.",
                                    "Verifique com ω específico, como ω=1."
                                  ],
                                  "verification": "Calcule |1 + j2| e | (1 + j2)/(1 + j1) | corretamente.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de fórmulas de complexos",
                                    "Software GeoGebra ou Wolfram Alpha opcional"
                                  ],
                                  "tips": "Sempre expanda (jω)^n: j^1 = j, j^2 = -1, j^3 = -j, j^4 = 1.",
                                  "learningObjective": "Dominar cálculo de magnitudes de expressões complexas polinomiais.",
                                  "commonMistakes": [
                                    "Erro no ciclo de potências de j",
                                    "Confundir magnitude com fase",
                                    "Não quadrar e somar partes real/imaginária"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Magnitude para Sistemas de Primeira Ordem",
                                  "subSteps": [
                                    "Considere H(s) = K / (τs + 1), então H(jω) = K / (1 + jωτ).",
                                    "Calcule |H(jω)| = |K| / sqrt(1 + (ωτ)^2).",
                                    "Escolha valores: K=1, τ=1, ω=0,1,∞ e plote ou tabule.",
                                    "Verifique limites: ω→0 →1, ω→∞ →0.",
                                    "Compare com ganho em DC e roll-off."
                                  ],
                                  "verification": "Derive e compute |H(j1)| = 1/sqrt(2) ≈0.707 para τ=1.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel quadriculado para gráficos",
                                    "Calculadora",
                                    "Exemplos de curso"
                                  ],
                                  "tips": "Use identidade pitagórica para denominador: |a + jb| = sqrt(a² + b²).",
                                  "learningObjective": "Aplicar fórmula de magnitude a sistemas de 1ª ordem.",
                                  "commonMistakes": [
                                    "Esquecer o τ no termo jωτ",
                                    "Não simplificar sqrt",
                                    "Erro em limites assintóticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Magnitude para Sistemas de Segunda Ordem e Verificar",
                                  "subSteps": [
                                    "Para H(s) = ωn² / (s² + 2ζωn s + ωn²), H(jω) = ωn² / (ωn² - ω² + j 2ζωn ω).",
                                    "Calcule |H(jω)| = ωn² / sqrt( (ωn² - ω²)^2 + (2ζωn ω)^2 ).",
                                    "Exemplo: ωn=1, ζ=0.5, compute para ω=0.5,1,2.",
                                    "Analise picos de ressonância se ζ<1/sqrt(2).",
                                    "Compare com 1ª ordem e discuta diferenças."
                                  ],
                                  "verification": "Obtenha |H(jω)| correto e identifique frequência de pico.",
                                  "estimatedTime": "35-45 minutos",
                                  "materials": [
                                    "Gráficos de Bode pré-impressos",
                                    "MATLAB ou Python (opcional)",
                                    "Tabela de valores ζ típicos"
                                  ],
                                  "tips": "Normalize ω' = ω/ωn para simplificar fórmula.",
                                  "learningObjective": "Executar cálculos completos para 2ª ordem e interpretar resultados.",
                                  "commonMistakes": [
                                    "Erro na expansão do denominador",
                                    "Confundir ζ com ωn",
                                    "Ignorar termo quadrático no real"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de altitude em aeronave modelado por H(s) = 10 / (s + 2), calcule |H(jω)| em ω=1 rad/s: H(j1)=10/(2+j1), |H(j1)|=10/sqrt(4+1)=10/sqrt(5)≈4.47, representando ganho em frequência média.",
                              "finalVerifications": [
                                "Define corretamente |H(jω)| como |N(jω)/D(jω)|.",
                                "Calcula magnitude exata para H(s)=1/(s+1) em ω=1.",
                                "Deriva fórmula para 2ª ordem sem erros algébricos.",
                                "Identifica limites DC e alta frequência corretamente.",
                                "Plota curva de magnitude qualitativamente.",
                                "Explica papel na estabilidade de sistemas dinâmicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de módulo (erro <1%).",
                                "Correta aplicação de propriedades de complexos.",
                                "Clareza na derivação passo a passo.",
                                "Interpretação física dos resultados (ganho, roll-off).",
                                "Uso apropriado de unidades e normalizações.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e análise de funções.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecidos.",
                                "Engenharia de Controle: Diagramas de Bode e estabilidade.",
                                "Processamento de Sinais: Filtros analógicos.",
                                "Computação: Simulação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular |H(jω)| de atuadores de controle de voo garante que o ganho em frequências de turbulência não amplifique oscilações perigosas, otimizando estabilidade e resposta do avião."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Converter magnitude para escala de decibéis",
                            "description": "Aplicar a fórmula 20 log10(|H(jω)|) para expressar a magnitude em dB e identificar comportamentos assintóticos em baixas e altas frequências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Magnitude e Escala de Decibéis",
                                  "subSteps": [
                                    "Defina magnitude da função de transferência H(jω) como |H(jω)|.",
                                    "Explique decibéis (dB) como uma escala logarítmica: 20 log10(x) para amplitude.",
                                    "Revise propriedades logarítmicas: log(ab) = log a + log b, log(a/b) = log a - log b.",
                                    "Identifique por que dB é útil para spans dinâmicos amplos em frequências.",
                                    "Diferencie 20 log10 para tensão/amplitude vs. 10 log10 para potência."
                                  ],
                                  "verification": "Resuma em suas palavras a fórmula 20 log10(|H(jω)|) e dê um exemplo numérico simples (ex: |H|=2 → dB?).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, notas de aula sobre funções de transferência, tabela de logaritmos.",
                                  "tips": "Lembre-se: dB é relativo; zero dB significa ganho unitário.",
                                  "learningObjective": "Compreender o significado físico e matemático da conversão para dB.",
                                  "commonMistakes": "Confundir 20 log10 com 10 log10; esquecer o módulo | |."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Magnitude |H(jω)| para Funções de Transferência Simples",
                                  "subSteps": [
                                    "Escreva H(s) para exemplos como integrador (1/s), duplo integrador (1/s²), ganho constante K.",
                                    "Substitua s = jω e compute |H(jω)| = |numerador| / |denominador|.",
                                    "Simplifique para baixas frequências (ω → 0) e altas (ω → ∞).",
                                    "Plote |H(jω)| em escala linear vs. ω log.",
                                    "Verifique limites assintóticos: ex. para 1/(s+1), |H| ≈ 1 em ω baixa, 1/ω em alta."
                                  ],
                                  "verification": "Calcule |H(jω)| para H(s)=1/(s+1) em ω=0.1, 1, 10 e anote valores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado log-log, software como MATLAB/Octave ou Python (numpy, matplotlib).",
                                  "tips": "Use ângulos para simplificar: |jω + a| = sqrt(ω² + a²).",
                                  "learningObjective": "Dominar cálculo de magnitude em domínio da frequência.",
                                  "commonMistakes": "Esquecer de substituir s=jω corretamente; ignorar termos reais/imaginários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Fórmula de Conversão para Escala de dB",
                                  "subSteps": [
                                    "Pegue valores de |H(jω)| do passo anterior.",
                                    "Compute 20 * log10(|H(jω)|) para cada ω.",
                                    "Plote o diagrama de Bode em dB vs. log10(ω).",
                                    "Identifique inclinações: -20 dB/década para polo simples.",
                                    "Compare com escala linear para visualizar compressão logarítmica."
                                  ],
                                  "verification": "Gere gráfico de Bode para H(s)=1/(s+1) e confirme 0 dB em ω=1, -20 dB/déc em alta freq.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de plotagem (MATLAB bode(), Python control library), calculadora.",
                                  "tips": "log10(10) = 1, então cada década multiplica ω por 10, muda dB por 20*log10(10)=20 dB para ganho 10.",
                                  "learningObjective": "Executar conversão precisa e plotagem em dB.",
                                  "commonMistakes": "Usar log natural (ln) em vez de log10; sinal negativo para magnitudes <1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Comportamentos Assintóticos em Baixas e Altas Frequências",
                                  "subSteps": [
                                    "Para ω → 0 (baixas freq): aproxime H(jω) ≈ H(0), dB ≈ 20 log10(|H(0)|).",
                                    "Para ω → ∞ (altas freq): conte polos/zeros, inclinação = 20*(zeros - polos) dB/década.",
                                    "Desenhe assíntotas: horizontal em baixa, rampas em alta.",
                                    "Compare aproximação assintótica com curva exata (erro <3 dB tipicamente).",
                                    "Aplique a sistemas de ordem superior, ex. H(s)=ω_n² / (s² + 2ζω_n s + ω_n²)."
                                  ],
                                  "verification": "Esboce diagrama de Bode assintótico para H(s)=1/s² e verifique com cálculo exato em 3 pontos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Folhas de gráficos log-log, exemplos de sistemas aeronáuticos (ex. resposta de flap).",
                                  "tips": "Assíntotas facilitam design rápido; erro máximo é 3 dB por canto.",
                                  "learningObjective": "Analisar e aproximar respostas em frequência via assíntotas em dB.",
                                  "commonMistakes": "Inverter inclinações (polo: -20 dB/déc, zero: +20); ignorar frequência de canto."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de atitude em aeronave com H(s) = 10 / (s + 2), calcule |H(jω)| em ω=0.1,1,10 rad/s: ≈5, 4.8, 0.99. Converta para dB: 14 dB, 13.6 dB, -0.1 dB. Assintotas: 14 dB horizontal baixa, -20 dB/déc após ω=2 rad/s.",
                              "finalVerifications": [
                                "Fórmula 20 log10(|H(jω)|) aplicada corretamente em 5 pontos de frequência.",
                                "Gráfico de Bode em dB com assíntotas desenhado e rotulado.",
                                "Comportamentos em baixas/altas freq identificados (ex: constante, -40 dB/déc).",
                                "Erro entre curva exata e assintótica < 5 dB em toda faixa.",
                                "Exemplo prático resolvido com valores numéricos precisos.",
                                "Explicação verbal do porquê usar dB em análise de sistemas dinâmicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de |H(jω)| e dB (erro <1%).",
                                "Correta identificação de assíntotas e inclinações (20 dB/déc por polo/zero).",
                                "Qualidade do gráfico de Bode: eixos log, legendas claras.",
                                "Profundidade na análise de limites ω→0 e ω→∞.",
                                "Criatividade em conectar a exemplo real de engenharia aeronáutica.",
                                "Clareza na documentação de passos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e funções complexas.",
                                "Física: Análise de vibrações e acústica em estruturas aeronáuticas.",
                                "Engenharia de Controle: Diagrama de Bode para estabilidade.",
                                "Processamento de Sinais: Filtros analógicos/digitais."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, converte-se magnitude de funções de transferência de sistemas de controle de voo (ex: resposta em frequência de atuadores de superfície de controle) para dB para diagramas de Bode, permitindo análise rápida de largura de banda, atenuação de ruído em altas frequências e estabilidade em baixas frequências durante simulações de dinâmica de voo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Interpretar picos e cortes na curva de magnitude",
                            "description": "Analisar ressonâncias (picos) e atenuações em função dos polos e zeros do sistema, relacionando com estabilidade e desempenho dinâmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Polos e Zeros em Funções de Transferência",
                                  "subSteps": [
                                    "Defina polos como raízes do denominador e zeros como raízes do numerador da função de transferência H(s).",
                                    "Represente graficamente o plano s complexo e localize polos/zeros para sistemas de segunda ordem.",
                                    "Calcule a magnitude |H(jω)| = |num(jω)/den(jω)| para frequências específicas.",
                                    "Identifique sistemas com polos complexos conjugados próximos ao eixo imaginário.",
                                    "Compare com sistemas dominados por polos reais."
                                  ],
                                  "verification": "Desenhe o diagrama de polos/zeros de um sistema dado e compute |H(jω_r)| onde ω_r é a frequência natural.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Software MATLAB ou Python (Control Systems Toolbox)"
                                  ],
                                  "tips": "Sempre normalize a função de transferência para ganho DC unitário para facilitar comparações.",
                                  "learningObjective": "Compreender a representação de polos e zeros e sua influência inicial na resposta em frequência.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar o módulo da distância no plano s",
                                    "Esquecer de considerar pares conjugados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Efeitos dos Polos na Curva de Magnitude (Picos de Ressonância)",
                                  "subSteps": [
                                    "Estude o comportamento assintótico: polos causam inclinação +20 dB/década na magnitude.",
                                    "Identifique picos quando polos estão próximos do eixo jω (baixa amortecimento ζ < 0.1).",
                                    "Calcule a frequência de pico ω_p ≈ ω_n √(1 - 2ζ²) para sistemas de 2ª ordem.",
                                    "Plote curvas Bode para ζ variando de 0.01 a 0.7 e observe amplificação máxima.",
                                    "Relacione pico alto com oscilações sustentadas no tempo."
                                  ],
                                  "verification": "Para H(s) = ω_n²/(s² + 2ζω_n s + ω_n²), plote Bode e identifique ω_p e magnitude do pico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB: bode(), rlocus()",
                                    "Planilhas com fórmulas de 2ª ordem"
                                  ],
                                  "tips": "Use log-log para visualizar assíntotas; foque em ζ para quantificar ressonância.",
                                  "learningObjective": "Associar localização de polos a picos na magnitude e ressonância.",
                                  "commonMistakes": [
                                    "Atribuir picos a zeros",
                                    "Confundir ω_n com ω_p",
                                    "Ignorar efeitos de polos múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Efeitos dos Zeros na Curva de Magnitude (Cortes e Atenuações)",
                                  "subSteps": [
                                    "Entenda que zeros introduzem inclinação -20 dB/década e notches profundos.",
                                    "Localize cortes em ω_z (frequência do zero) com atenuação máxima de 20 log(ω/ω_z) dB.",
                                    "Compare sistemas com zero no numerador vs. ausência, plotando diferenças em Bode.",
                                    "Analise zeros próximos a polos: cancelamento parcial reduz picos.",
                                    "Examine zeros em RH (direito metade) para não-minimum phase e fase extra."
                                  ],
                                  "verification": "Adicione um zero a um sistema de 2ª ordem e demonstre redução de pico na magnitude.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: control.bode_plot()",
                                    "Exemplos de filtros notch"
                                  ],
                                  "tips": "Zeros 'cortam' energia em frequências específicas; úteis para rejeição de distúrbios.",
                                  "learningObjective": "Reconhecer zeros como causadores de cortes e seu papel em moldar a magnitude.",
                                  "commonMistakes": [
                                    "Pensar que zeros amplificam",
                                    "Confundir notch com anti-ressonância",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Análise com Estabilidade e Desempenho Dinâmico",
                                  "subSteps": [
                                    "Relacione picos altos (>6 dB) a instabilidade marginal ou desempenho pobre (overshoot).",
                                    "Avalie cortes como trade-offs para largura de banda ou rejeição seletiva.",
                                    "Use margens de ganho/fase: pico em magnitude correlaciona com PM baixa.",
                                    "Simule respostas transitórias para validar interpretações de Bode.",
                                    "Otimize localização de polos/zeros para specs aeronáuticas (ex: damping ratio)."
                                  ],
                                  "verification": "Dado um gráfico Bode, prediga overshoot e tempo de estabilização; valide com simulação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB: step(), margin()",
                                    "Casos de estudo em controle de aeronaves"
                                  ],
                                  "tips": "Picos indicam risco de flutter; cortes protegem contra vibrações específicas.",
                                  "learningObjective": "Conectar interpretações gráficas a métricas de estabilidade e desempenho.",
                                  "commonMistakes": [
                                    "Isolar magnitude de fase",
                                    "Ignorar contexto dinâmico",
                                    "Superestimar estabilidade por ausência de picos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Interpretação em Exemplos Aeronáuticos",
                                  "subSteps": [
                                    "Analise FT de um oscilador de asas (polos jω para flutter).",
                                    "Interprete Bode de controlador PID em elevador de aeronave.",
                                    "Crie gráficos sintéticos variando polos/zeros e rotule picos/cortes.",
                                    "Compare com dados reais de wind tunnel tests.",
                                    "Documente relatório com anotações em curvas Bode."
                                  ],
                                  "verification": "Interprete 3 gráficos Bode independentes, justificando estabilidade/desempenho.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasets de Bode aeronáuticos",
                                    "Ferramenta de plotagem online (ex: GeoGebra)"
                                  ],
                                  "tips": "Sempre anote 'por quê' do pico/corte: polo/zero + localização.",
                                  "learningObjective": "Aplicar conceitos de forma autônoma em contextos reais.",
                                  "commonMistakes": [
                                    "Falta de quantificação",
                                    "Não relacionar a aplicação",
                                    "Plots sem legendas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flaps de uma aeronave, a FT H(s) = (s + 10)/(s² + 0.2s + 1) exibe um corte em ω=10 rad/s devido ao zero (rejeita vibrações do motor) e um pico sutil em ω≈1 rad/s pelo baixo amortecimento dos polos, indicando risco de oscilações em manobras rápidas. Interprete para propor realocação do zero.",
                              "finalVerifications": [
                                "Identifica corretamente causas de picos (polos próximos jω) em 90% dos gráficos Bode fornecidos.",
                                "Calcula frequências e magnitudes aproximadas de picos/cortes com erro <10%.",
                                "Relaciona interpretações a estabilidade (ex: pico >10 dB sugere PM <30°).",
                                "Propõe ajustes em polos/zeros para mitigar problemas identificados.",
                                "Valida com simulações transitórias concordantes.",
                                "Documenta análise com diagramas de polos/zeros e anotações claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de polos/zeros causadores (80% acerto).",
                                "Quantificação correta de ω_p, magnitude pico e atenuação (erro <5%).",
                                "Correlação explícita com damping ratio ζ e overshoot esperado.",
                                "Integração de magnitude com implicações de fase/estabilidade.",
                                "Criatividade em aplicações aeronáuticas e sugestões de melhoria.",
                                "Clareza e completude na documentação gráfica/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e contorno no plano s.",
                                "Física: Dinâmica de osciladores amortecidos e ressonância mecânica em estruturas aeronáuticas.",
                                "Engenharia de Controle: Projeto de compensadores para moldar curvas Bode.",
                                "Vibrações e Acústica: Análise de modos flutter e rejeição de ruído.",
                                "Processamento de Sinais: Filtros notch para eliminação de harmônicos."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex: Boeing 787), engenheiros interpretam curvas de magnitude de funções de transferência de superfícies de controle para detectar riscos de flutter (picos altos) ou insuficiente rejeição de turbulência (cortes inadequados), garantindo estabilidade em regime supersônico e evitando falhas catastróficas como o incidente do Lockheed Electra."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Fase da Resposta em Frequência",
                        "description": "A fase da função de resposta em frequência, arg(H(jω)), mede o deslocamento temporal introduzido pelo sistema para sinais sinusoidais, essencial para entender atrasos e sincronismo em sistemas lineares invariantes no tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Calcular a fase da função de transferência",
                            "description": "Determinar arg(H(jω)) = arg(numerador(jω)) - arg(denominador(jω)) para sistemas de baixa ordem, considerando contribuições de polos e zeros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a função de transferência H(s) em domínio da frequência H(jω)",
                                  "subSteps": [
                                    "Escreva a função de transferência H(s) no formato polinomial de numerador e denominador.",
                                    "Substitua s por jω para obter H(jω), onde j é a unidade imaginária e ω é a frequência angular.",
                                    "Expresse H(jω) como H(jω) = |H(jω)| * e^{j * arg(H(jω))}.",
                                    "Identifique que arg(H(jω)) = arg(numerador(jω)) - arg(denominador(jω)).",
                                    "Simplifique expressões trigonométricas usando seno e cosseno para partes real e imaginária."
                                  ],
                                  "verification": "Confirme que H(jω) está corretamente substituído e a fórmula de argumento está anotada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Livro de Sinais e Sistemas"
                                  ],
                                  "tips": "Sempre normalize ω em rad/s para evitar erros de unidade.",
                                  "learningObjective": "Compreender a transição do domínio s para o domínio jω e a definição de fase.",
                                  "commonMistakes": "Esquecer de substituir s por jω ou confundir ω com f (frequência em Hz)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e decompor polos e zeros da função de transferência",
                                  "subSteps": [
                                    "Encontre os zeros resolvendo numerador(jω) = 0 para ω específico.",
                                    "Encontre os polos resolvendo denominador(jω) = 0.",
                                    "Escreva H(jω) em forma de produto: H(jω) = K * ∏ (jω - z_i) / ∏ (jω - p_k), onde z_i são zeros e p_k polos.",
                                    "Para sistemas de baixa ordem (até 2ª ordem), liste explicitamente cada polo e zero.",
                                    "Anote as localizações no plano complexo (eixo real e imaginário)."
                                  ],
                                  "verification": "Liste todos polos e zeros com suas coordenadas complexas para o ω dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou app como GeoGebra",
                                    "Folha de exercícios com exemplos de baixa ordem"
                                  ],
                                  "tips": "Use fatoração para simplificar polinômios quadráticos.",
                                  "learningObjective": "Localizar contribuintes de fase (polos e zeros) no plano jω.",
                                  "commonMistakes": "Confundir zeros (numerador) com polos (denominador) ou ignorar multiplicidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a contribuição de fase de cada polo e zero",
                                  "subSteps": [
                                    "Para cada zero z_i, calcule arg(jω - z_i) = atan2(Im(jω - z_i), Re(jω - z_i)).",
                                    "Para cada polo p_k, calcule arg(jω - p_k) de forma similar.",
                                    "Some as fases dos zeros para arg(numerador(jω)) e subtraia a soma das fases dos polos.",
                                    "Converta ângulos para graus ou radianos consistentes (use graus para convenção aeronáutica).",
                                    "Ajuste para o ângulo principal (-180° a 180°)."
                                  ],
                                  "verification": "Verifique que cada arg individual está entre -180° e 180° e some corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy para atan2)",
                                    "Tabela de valores trigonométricos"
                                  ],
                                  "tips": "Visualize vetores no plano complexo: fase é o ângulo do vetor de ω ao polo/zero.",
                                  "learningObjective": "Dominar o cálculo de argumento usando atan2 para contribuições individuais.",
                                  "commonMistakes": "Usar atan em vez de atan2 (perde sinal do quadrante) ou esquecer sinal negativo para polos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar fases e validar o resultado total",
                                  "subSteps": [
                                    "Some arg_zeros - arg_polos para obter arg(H(jω)).",
                                    "Calcule H(jω) numericamente e use arg(H(jω)) = angle(H(jω)) para confirmação.",
                                    "Plote a fase em um diagrama de Bode manual para ω dado.",
                                    "Teste em múltiplos ω para verificar consistência.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Resultado numérico bate com cálculo direto de H(jω) via software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Octave para validação",
                                    "Gráficos de Bode de referência"
                                  ],
                                  "tips": "Para baixa ordem, evite aproximações; calcule exatamente.",
                                  "learningObjective": "Integrar contribuições para fase total e validar.",
                                  "commonMistakes": "Não ajustar por 360° múltiplos ou ignorar fase de ganho constante K."
                                }
                              ],
                              "practicalExample": "Para H(s) = (s + 1) / [(s + 2)(s + 10)], calcule arg(H(j1)): Zero em -1, polos em -2 e -10. arg(j1 +1) ≈ 45°, arg(j1 +2) ≈ 26.6°, arg(j1 +10) ≈ 5.7°. Fase total = 45° - 26.6° - 5.7° ≈ 12.7°.",
                              "finalVerifications": [
                                "Fase calculada corresponde ao valor obtido via software (erro < 1°).",
                                "Todas contribuições de polos/zeros estão corretamente sinalizadas.",
                                "Ângulo está no intervalo principal (-180° a 180°).",
                                "Processo documentado para pelo menos 3 valores de ω.",
                                "Diagrama vetorial no plano complexo desenhado corretamente.",
                                "Consistência com magnitude |H(jω)| em análise separada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de argumentos individuais (erro < 0.5°).",
                                "Correta subtração de fases de polos.",
                                "Uso apropriado de atan2 para quadrantes corretos.",
                                "Validação cruzada com método direto.",
                                "Clareza na documentação e visualizações.",
                                "Tratamento de casos reais (ex: polos complexos conjugados)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Números complexos e funções trigonométricas.",
                                "Física: Oscilações harmônicas e vetores fasores em circuitos.",
                                "Engenharia de Controle: Diagramas de Bode para estabilidade.",
                                "Processamento de Sinais: Filtros analógicos em aviônica."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, calcular a fase da função de transferência de atuadores de controle de voo (ex: servos de flaps) garante margem de fase >45° para estabilidade, evitando oscilações em manobras de aeronaves como o F-16."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Plotar e interpretar a curva de fase",
                            "description": "Construir gráficos de fase em função de ω (em graus ou radianos), identificando transições de 0° para -180° ou mais em sistemas com polos reais e complexos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de resposta em frequência e fase",
                                  "subSteps": [
                                    "Estude a definição de função de transferência G(s) e sua transformação para G(jω).",
                                    "Revise o conceito de magnitude e fase da resposta em frequência: arg[G(jω)].",
                                    "Identifique como a fase é expressa em graus ou radianos e sua relação com ω.",
                                    "Analise exemplos simples de sistemas de primeira ordem e entenda a transição inicial de fase.",
                                    "Pratique convertendo entre graus e radianos para plotagem."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre definições básicas de fase e forneça um exemplo de G(jω) com fase calculada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Calculadora científica",
                                    "Folha de fórmulas de Bode"
                                  ],
                                  "tips": "Sempre comece com sistemas simples para construir intuição antes de complexos.",
                                  "learningObjective": "Compreender os fundamentos teóricos da fase da resposta em frequência.",
                                  "commonMistakes": [
                                    "Confundir magnitude com fase",
                                    "Esquecer de usar jω na substituição em G(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular fase para polos reais e complexos",
                                  "subSteps": [
                                    "Para polos reais negativos: calcule arg[1/(jω + p)] onde p > 0, notando transição de 0° para -90°.",
                                    "Para pares de polos complexos conjugados: use fórmula tan⁻¹[(ω/ζω_n)/(1 - (ω/ω_n)²)] ajustada para fase.",
                                    "Some fases de zeros e polos usando regra do argumento.",
                                    "Calcule fase em pontos chave: ω=0, ω→∞, e ω=1/τ para polos reais.",
                                    "Tabule valores de fase para pelo menos 10 frequências log-espacadas."
                                  ],
                                  "verification": "Calcule manualmente a fase em 5 frequências para um sistema dado e compare com software (erro <5°).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (Matplotlib + Control Systems Library)",
                                    "Tabela de logaritmos",
                                    "Exemplos de funções de transferência"
                                  ],
                                  "tips": "Use aproximações assintóticas iniciais para agilizar cálculos.",
                                  "learningObjective": "Dominar o cálculo analítico da fase para diferentes configurações de polos.",
                                  "commonMistakes": [
                                    "Não considerar o quadrante correto no arg()",
                                    "Ignorar contribuições de múltiplos polos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar a curva de fase em função de ω",
                                  "subSteps": [
                                    "Escolha escala logarítmica para ω (de 0.1 a 10 rad/s inicialmente).",
                                    "Plote pontos calculados conectando com linhas suaves, marcando transições chave.",
                                    "Identifique curvas assintóticas: 0° em baixa frequência, -90° por polo real, -180° por par complexo.",
                                    "Use software para gerar plot e valide manualmente em 3 pontos.",
                                    "Adicione rótulos: eixos, título, legendas para polos/zeros."
                                  ],
                                  "verification": "Gere um gráfico de fase que corresponda exatamente a um exemplo conhecido, com todas as transições marcadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (bode() ou nyquist())",
                                    "Python (control.bode_plot())",
                                    "Papel milimetrado para plot manual"
                                  ],
                                  "tips": "Marque ω_c (frequência de corte) onde fase = -90° para referência.",
                                  "learningObjective": "Construir graficamente curvas de fase precisas para sistemas dados.",
                                  "commonMistakes": [
                                    "Escala linear em vez de log para ω",
                                    "Plotar fase sem unwrap (saltos de 360°)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar transições de fase e analisar estabilidade",
                                  "subSteps": [
                                    "Identifique transições: 0° → -180° para polos reais (suavidade), ou mais íngreme para complexos.",
                                    "Analise ganho de fase em ω_c e margem de fase para estabilidade.",
                                    "Compare curvas para sistemas com polos reais vs. complexos (subdampados).",
                                    "Discuta implicações: delay de fase em sistemas de controle aeronáutico.",
                                    "Resolva problema: dado gráfico, infira número e tipo de polos."
                                  ],
                                  "verification": "Interprete corretamente 3 gráficos de fase, identificando polos e transições com justificativa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de curvas de Bode de aeronáutica",
                                    "Simulador online de sistemas de controle"
                                  ],
                                  "tips": "Foque em inclinações: -90°/década por polo real, -180° para complexo.",
                                  "learningObjective": "Extrair insights dinâmicos da curva de fase para design de sistemas.",
                                  "commonMistakes": [
                                    "Confundir transições de fase com magnitude",
                                    "Ignorar efeitos de zeros"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um estabilizador de aeronave com G(s) = 1 / (s(s+1)(s² + 0.5s + 1)), plote a fase vs. log(ω): observe transição suave de 0° para -180° devido ao polo real em -1, e queda adicional para -360° pelos polos complexos, identificando risco de instabilidade se margem de fase <45°.",
                              "finalVerifications": [
                                "Plote corretamente curva de fase para sistema com 2 polos reais e 1 par complexo.",
                                "Identifique todas transições de 0° a -180° ou mais em gráfico dado.",
                                "Calcule fase manual em ω=1 rad/s com erro <3°.",
                                "Explique impacto de polo complexo na inclinação da curva.",
                                "Compare fase em graus vs. radianos sem erros de conversão.",
                                "Avalie estabilidade qualitativa a partir da curva."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de fase (±5°).",
                                "Qualidade do plot (escala log, marcações claras).",
                                "Correta identificação de transições e polos.",
                                "Profundidade da interpretação (estabilidade, delay).",
                                "Uso adequado de ferramentas e validação manual.",
                                "Clareza na documentação de passos e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas, logaritmos e argumento complexo.",
                                "Física: Oscilações harmônicas e análise de vibrações em estruturas aeronáuticas.",
                                "Programação: Uso de bibliotecas como Control Toolbox para automação de plots.",
                                "Engenharia de Controle: Margens de estabilidade e diagramas de Bode.",
                                "Estatística: Análise de incertezas em medições de frequência."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, plotar e interpretar curvas de fase é essencial para projetar sistemas de controle de voo autônomo, garantindo estabilidade em manobras (ex: evitar oscilações em flaps ou estabilizadores), onde transições de fase indicam delays que podem levar a flutter ou perda de controle."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Relacionar fase com atraso de grupo",
                            "description": "Calcular o atraso de grupo τ_g(ω) = -dφ/dω e interpretar seu impacto em sinais de banda larga.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Fase na Resposta em Frequência",
                                  "subSteps": [
                                    "Defina a função de fase φ(ω) como o argumento da função de transferência H(jω).",
                                    "Analise gráficos de Bode de fase para sistemas de primeira e segunda ordem.",
                                    "Identifique como a fase varia com a frequência ω em diferentes regiões (baixa, transição, alta).",
                                    "Discuta o significado físico da fase: indica o atraso temporal entre entrada e saída.",
                                    "Pratique leitura de fase em exemplos de sistemas lineares invariantes no tempo (LTI)."
                                  ],
                                  "verification": "Desenhe e rotule um gráfico de Bode de fase para um filtro RC de primeira ordem e explique as regiões.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos de Bode de exemplo, calculadora, software como MATLAB ou Python (SciPy).",
                                  "tips": "Sempre normalize a frequência em rad/s para evitar confusões com Hz.",
                                  "learningObjective": "Compreender a representação e interpretação da fase φ(ω) em sistemas dinâmicos.",
                                  "commonMistakes": "Confundir fase com magnitude; ignorar o sinal negativo na fase para sistemas causais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula do Atraso de Grupo",
                                  "subSteps": [
                                    "Comece com a resposta em regime senoidal: y(t) = |H(jω)| A cos(ωt + φ(ω)).",
                                    "Expresse a saída como envelope e fase: y(t) = Re[ |H(jω)| A e^{j(ωt + φ(ω))} ].",
                                    "Defina o atraso de grupo como a derivada negativa da fase: τ_g(ω) = -dφ(ω)/dω.",
                                    "Derive intuitivamente: para sinal de banda estreita, o atraso é aproximadamente constante.",
                                    "Verifique dimensionalmente: φ em radianos, ω em rad/s, τ_g em segundos."
                                  ],
                                  "verification": "Escreva a derivação passo a passo da fórmula τ_g(ω) = -dφ/dω a partir da resposta fase.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta para derivação, notas de teoria de sinais, vídeo tutorial sobre atraso de grupo.",
                                  "tips": "Use a aproximação de Taylor para φ(ω) ≈ φ(ω_0) - τ_g (ω - ω_0) para banda estreita.",
                                  "learningObjective": "Derivar e justificar matematicamente a relação entre fase e atraso de grupo.",
                                  "commonMistakes": "Esquecer o sinal negativo; confundir com atraso de fase τ_p(ω) = φ(ω)/ω."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Atraso de Grupo em Exemplos Simples",
                                  "subSteps": [
                                    "Para atraso puro H(s) = e^{-sT}: calcule φ(ω) = -ωT, então τ_g(ω) = T (constante).",
                                    "Para filtro RC de primeira ordem H(jω) = 1/(1 + jωRC): φ(ω) = -atan(ωRC), τ_g(ω) = RC / (1 + (ωRC)^2).",
                                    "Plote τ_g(ω) vs. ω para ambos os casos usando software.",
                                    "Compare τ_g com atraso de fase em diferentes frequências.",
                                    "Calcule numericamente para ω = 1/RC e interprete o pico de atraso."
                                  ],
                                  "verification": "Compute e plote τ_g(ω) para um filtro RC com RC=1s, em ω de 0.1 a 10 rad/s.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python para plotagem, tabela de funções φ(ω) comuns.",
                                  "tips": "Use sympy ou diff() no MATLAB para derivadas simbólicas de φ(ω).",
                                  "learningObjective": "Aplicar cálculo diferencial para obter τ_g(ω) de funções de fase conhecidas.",
                                  "commonMistakes": "Erro no cálculo da derivada; plotar em escala log sem linearizar adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Impacto em Sinais de Banda Larga",
                                  "subSteps": [
                                    "Defina sinal de banda larga: espectro significativo em Δω > 1/τ_g.",
                                    "Explique distorção: se τ_g varia com ω, pacotes de onda se dispersam (chirp ou espalhamento).",
                                    "Analise exemplo: pulso modulado em AM com espectro largo em canal com τ_g variável.",
                                    "Discuta mitigação: equalizadores para linearizar τ_g(ω).",
                                    "Relacione com sistemas aeronáuticos: atraso em radares ou controles de voo."
                                  ],
                                  "verification": "Descreva qualitativamente o que acontece com um pulso de banda larga em um filtro RC.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulações de sinais em MATLAB (fft/ifft para dispersão), artigos sobre dispersão em fibras ópticas.",
                                  "tips": "Visualize com animações de ondas se espalhando devido a τ_g(ω) não constante.",
                                  "learningObjective": "Interpretar efeitos físicos do atraso de grupo variável em sinais reais.",
                                  "commonMistakes": "Confundir distorção de amplitude com de fase; subestimar largura de banda."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Contexto Aeronáutico",
                                  "subSteps": [
                                    "Considere um sistema de controle de voo com H(s) aproximada.",
                                    "Calcule τ_g para frequências de interesse (0.1-10 Hz em controle).",
                                    "Avalie impacto em comandos de banda larga (manobras rápidas).",
                                    "Proponha design para τ_g constante (all-pass filters).",
                                    "Simule resposta a um sinal de rampa senoidal."
                                  ],
                                  "verification": "Gere relatório curto com cálculo e interpretação para um modelo simples de atuador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Modelos Simulink de sistemas aeronáuticos, dados de transferência reais.",
                                  "tips": "Foquem em ω próximas à largura de banda do sistema para relevância.",
                                  "learningObjective": "Integrar conceito em aplicações práticas de engenharia aeronáutica.",
                                  "commonMistakes": "Ignorar unidades de frequência em Hz vs rad/s em contextos de controle."
                                }
                              ],
                              "practicalExample": "Em um radar de aeronave, um sinal de pulso chirp (banda larga de 1-10 GHz) passa por um amplificador com φ(ω) não linear. Calcule τ_g(ω) = -dφ/dω ≈ 5 ns no centro, mas variando 20% nas bordas, causando resolução borrada de 3m em alvos distantes. Simule correção com equalizador all-pass para linearizar τ_g.",
                              "finalVerifications": [
                                "Deriva corretamente τ_g(ω) = -dφ/dω para um sistema dado.",
                                "Calcula e plota τ_g(ω) com precisão <5% para filtro RC.",
                                "Explica distorção em sinal de banda larga com diagrama de dispersão.",
                                "Identifica quando τ_g variável causa problemas em aplicações reais.",
                                "Propõe solução qualitativa para minimizar efeitos de atraso de grupo.",
                                "Compara τ_g com atraso de fase em pelo menos dois exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e cálculo (80% peso).",
                                "Qualidade de plots e visualizações (gráficos claros, legendas).",
                                "Profundidade na interpretação física e impacto em banda larga.",
                                "Relevância ao contexto aeronáutico (exemplos específicos).",
                                "Criatividade em soluções de mitigação.",
                                "Clareza na comunicação (relatório ou apresentação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas) e análise assintótica.",
                                "Física: Propagação de ondas e dispersão em meios.",
                                "Engenharia de Comunicações: Processamento de sinais digitais e equalização.",
                                "Controle Automático: Estabilidade e resposta transitória em laços fechados.",
                                "Processamento de Sinais: Transformada de Fourier e filtros digitais."
                              ],
                              "realWorldApplication": "Em sistemas de controle de voo de aeronaves (ex: F-35), atraso de grupo variável em canais de transmissão de comandos pode dispersar sinais de manobra rápida, degradando precisão. Projetistas usam análise de τ_g(ω) para especificar amplificadores com fase linearizada, garantindo resposta <10ms em banda larga para estabilidade em turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Diagrama de Bode",
                        "description": "O diagrama de Bode é uma representação gráfica log-log da magnitude e fase da resposta em frequência, facilitando a análise assintótica de sistemas complexos via aproximações de fatores mínimos e não mínimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Construir o diagrama de Bode de magnitude",
                            "description": "Desenhar curvas assintóticas para polos e zeros (inclinações de ±20 dB/década), corrigindo com fatores de magnitude em frequência de corte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Função de Transferência e Identificar Polos e Zeros",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) em forma fatorada: G(s) = K * ∏ (s/z_i + 1) / ∏ (s/p_j + 1).",
                                    "Identifique todos os zeros (raízes do numerador) e polos (raízes do denominador), convertendo para frequências angulares ω_z e ω_p.",
                                    "Determine o ganho em baixa frequência (K_DC = |G(0)| em dB: 20 log10|K| ajustado por fatores).",
                                    "Ordene as frequências de corte em escala logarítmica (ex: 0.1, 1, 10, 100 rad/s).",
                                    "Anote a inclinação inicial: 0 dB/déc se mesmo número de polos/zeros, ajustando por ordens."
                                  ],
                                  "verification": "Lista completa de polos, zeros e frequências ordenadas, com ganho DC calculado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de transferência G(s)",
                                    "Papel log-log ou software como MATLAB/Octave",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre normalize polos/zeros para forma (τs + 1), onde ω = 1/τ.",
                                  "learningObjective": "Identificar precisamente elementos da função de transferência para base do diagrama.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Esquecer multiplicidade de polos/zeros",
                                    "Erro no cálculo de ganho DC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar as Curvas Assintóticas de Magnitude",
                                  "subSteps": [
                                    "Desenhe o eixo x: log10(ω) de 0.1 a 10^3 rad/s; eixo y: Magnitude em dB de -60 a 60 dB.",
                                    "Trace a reta inicial de baixa frequência com inclinação 0 dB/déc (ou múltiplos de ±20) até a primeira frequência de corte.",
                                    "Em cada zero, aumente inclinação em +20 dB/década (ou +40 para duplo); em cada polo, diminua em -20 dB/déc (-40 para duplo).",
                                    "Continue retas assintóticas até alta frequência, marcando mudanças com setas.",
                                    "Rotule todas as frequências de corte e inclinações nos segmentos."
                                  ],
                                  "verification": "Diagrama com todas retas assintóticas conectadas corretamente nas frequências de corte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel semilogarítmico (eixo x log)",
                                    "Régua e lápis",
                                    "Tabela de frequências log"
                                  ],
                                  "tips": "Use escala log para ω para facilitar décadas; marque 1 década por grande divisão.",
                                  "learningObjective": "Construir esboço assintótico preciso refletindo mudanças de slope por polos/zeros.",
                                  "commonMistakes": [
                                    "Inclinação errada (ex: +20 para polo)",
                                    "Não ordenar frequências corretamente",
                                    "Esquecer mudança cumulativa de slope"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Aplicar Correções de Magnitude nas Frequências de Corte",
                                  "subSteps": [
                                    "Para cada polo/zero simples em ω_c, calcule correção: +3 dB para zero, -3 dB para polo na assintótica.",
                                    "Para múltiplos: zero duplo +6 dB, polo duplo -6 dB; generalize como 10 log10(1 + (ω_c/ω)^2) ≈ 3 dB para simples.",
                                    "Ajuste a assintótica verticalmente em ω_c pela correção, mantendo slopes iguais antes/depois.",
                                    "Some correções cumulativas se próximas (ex: dentro de 1 década).",
                                    "Trace curvas suaves reais aproximadas: arredondamento de 3 dB em ω_c, decay suave."
                                  ],
                                  "verification": "Correções aplicadas e marcadas em cada corner frequency, com valores numéricos anotados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para log10 e fórmulas de correção",
                                    "Tabela de valores dB vs fator (ex: 3dB=1.41)"
                                  ],
                                  "tips": "Correção padrão para 1º ordem: magnitude real = assintótica ± 3 dB em ω_c.",
                                  "learningObjective": "Aplicar fatores de correção para aproximar diagrama assintótico à curva real.",
                                  "commonMistakes": [
                                    "Aplicar correção errada (sinal invertido)",
                                    "Ignorar para ordens altas",
                                    "Não acumular correções próximas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar, Verificar e Rotular o Diagrama Completo",
                                  "subSteps": [
                                    "Adicione curvas reais suaves conectando assintóticas corrigidas (queda suave em polos, pico em zeros).",
                                    "Rotule eixos, título 'Diagrama de Bode de Magnitude', G(s), todas ω_c, slopes e pontos chave.",
                                    "Verifique continuidade, slopes corretos e magnitude em ω=1 rad/s.",
                                    "Compare com plot numérico (se disponível) para validação.",
                                    "Anote faixa de frequência dominante e largura de banda aproximada."
                                  ],
                                  "verification": "Diagrama completo, rotulado e consistente com cálculos iniciais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de plot (opcional: Python/MATLAB para G(jω))",
                                    "Marcadores coloridos para assintótica vs real"
                                  ],
                                  "tips": "Use cores: vermelho para assintótica, azul para corrigida/real.",
                                  "learningObjective": "Produzir diagrama profissional e verificado.",
                                  "commonMistakes": [
                                    "Escalas erradas nos eixos",
                                    "Falta de rótulos",
                                    "Descontinuidades nas curvas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / [(s/10 + 1)(s/100 + 1)], polos em ω=10 e 100 rad/s. Ganho DC: 20 log10(10*10*1)= 23 dB aprox. Assintótica: 23 dB até ω=10 (0 dB/dec), -20 dB/dec até ω=100, -40 dB/dec após. Correções: -3 dB em ω=10, -3 dB em ω=100. Desenhe log ω de 0.1-1000, magnitude -20 a 40 dB.",
                              "finalVerifications": [
                                "Todas frequências de polos/zeros plotadas corretamente em log.",
                                "Slopes mudam exatamente ±20 dB/déc por polo/zero simples.",
                                "Correções de ±3 dB aplicadas em cada ω_c.",
                                "Ganho DC e alta frequência consistentes com G(s).",
                                "Curvas suaves aproximam comportamento real.",
                                "Eixos rotulados com unidades (dB, rad/s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de polos/zeros (100%).",
                                "Correção das assintóticas e slopes (90% match com esperado).",
                                "Aplicação exata de correções em dB (erro <1 dB).",
                                "Qualidade visual e rótulos completos.",
                                "Verificação de continuidade e consistência.",
                                "Explicação oral do processo (se avaliado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos decádicos e propriedades de dB (20 log10).",
                                "Física: Sistemas dinâmicos e resposta em frequência de osciladores.",
                                "Engenharia de Controle: Análise de estabilidade em malhas de feedback.",
                                "Programação: Implementação em Python (control library) ou MATLAB."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, usado para analisar resposta em frequência de sistemas de controle de voo (ex: autopiloto), prevendo estabilidade e largura de banda em atuadores de superfícies de controle, evitando oscilações em manobras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Construir o diagrama de Bode de fase",
                            "description": "Plotar assíntotas de fase para cada polo/zero (±90° com transição em década), somando contribuições para o gráfico total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar polos e zeros da função de transferência",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) no formato polinomial no numerador e denominador.",
                                    "Fatore o numerador para identificar zeros (raízes onde numerador=0).",
                                    "Fatore o denominador para identificar polos (raízes onde denominador=0).",
                                    "Anote as frequências angulares ω_z para zeros e ω_p para polos (|polo/zero|).",
                                    "Registre multiplicidades para polos/zeros repetidos."
                                  ],
                                  "verification": "Lista completa e correta de polos, zeros, suas frequências e multiplicidades, verificada substituindo em G(s).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência G(s)",
                                    "Papel ou software de cálculo simbólico (ex: MATLAB, SymPy)"
                                  ],
                                  "tips": [
                                    "Use conjugados complexos para polos/zeros imaginários.",
                                    "Confirme fatoração resolvendo equações de raízes."
                                  ],
                                  "learningObjective": "Extrair com precisão todos os elementos de fase da função de transferência.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar multiplicidades",
                                    "Esquecer sinal de polos no plano s"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar assíntotas de fase individuais para cada polo e zero",
                                  "subSteps": [
                                    "Para cada zero simples: desenhe linha horizontal em 0° até 0.1ω_z, transição linear +45°/década de 0.1ω_z a 10ω_z, depois +90° horizontal.",
                                    "Para cada polo simples: similar, mas -90° (transição -45°/década).",
                                    "Multiplique por m para polos/zeros de ordem m (±90°m).",
                                    "Marque eixo log(ω) com décadas e rotule frequências de corner (ω_p, ω_z).",
                                    "Use escala semilogarítmica para eixo x (log ω) e linear para fase (graus)."
                                  ],
                                  "verification": "Assíntotas individuais plotadas corretamente para cada componente, com transições marcadas e slopes indicados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel semilogarítmico",
                                    "Régua e lápis",
                                    "Software de plotagem (ex: MATLAB bode plot manual)"
                                  ],
                                  "tips": [
                                    "Comece com baixa frequência (ω→0) sempre em 0° para sistemas mínimos de fase.",
                                    "Desenhe uma por vez para evitar confusão."
                                  ],
                                  "learningObjective": "Construir assíntotas de fase padrão para contribuições individuais de polos/zeros.",
                                  "commonMistakes": [
                                    "Erro no sinal (+90° zero vs -90° polo)",
                                    "Transição errada (não 1 década)",
                                    "Escala log errada no eixo ω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Somar contribuições de fase e plotar o gráfico assintótico total",
                                  "subSteps": [
                                    "Escolha pontos chave: décadas abaixo/entre/acima das frequências de corner.",
                                    "Calcule soma algébrica das fases de todas assíntotas em cada ponto (ex: φ_total = Σ φ_i).",
                                    "Plote a soma como linhas horizontais entre corners e transições lineares.",
                                    "Rotule o gráfico com eixo y em graus (-270° a +270° típico), x em log ω (rad/s).",
                                    "Indique fase em ω→0 (0° para tipo 0) e ω→∞ (-90°(p-z))."
                                  ],
                                  "verification": "Gráfico total com soma correta em pelo menos 5 pontos chave, matching assíntotas individuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos individuais do step 2",
                                    "Calculadora para somas",
                                    "Software para validação (bode(G) no MATLAB)"
                                  ],
                                  "tips": [
                                    "Some vetorialmente se necessário, mas para assíntotas é algébrico.",
                                    "Verifique continuidade nas junções."
                                  ],
                                  "learningObjective": "Combinar contribuições para obter diagrama de fase assintótico preciso.",
                                  "commonMistakes": [
                                    "Soma errada de ângulos",
                                    "Descontinuidade nas corners",
                                    "Esquecer contribuições distantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar, verificar e documentar o diagrama final",
                                  "subSteps": [
                                    "Ajuste curvas reais próximas às corners (±3dB approx para magnitude, similar fase).",
                                    "Compare com plot exato via software.",
                                    "Adicione legendas: título, G(s), unidades, assíntotas vs real.",
                                    "Calcule fase em frequências específicas (ex: largura de banda).",
                                    "Documente suposições (fase mínima, delays)."
                                  ],
                                  "verification": "Diagrama final rotulado, com match >90% com plot numérico em pontos chave.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB, Python control library)",
                                    "Template de relatório"
                                  ],
                                  "tips": [
                                    "Use zoom em corners para precisão.",
                                    "Salve como PDF para portfólio."
                                  ],
                                  "learningObjective": "Produzir diagrama profissional e verificado para análise.",
                                  "commonMistakes": [
                                    "Ignorar correções reais",
                                    "Falta de labels",
                                    "Unidades erradas em ω"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / [s(s+1)(s+10)], polos em 0, -1, -10 (ω_p=0,1,10 rad/s). Assíntotas: polo0 contribui -90° para ω>0.1*0 (todo), polo1: -90° após ω=1 (trans 0.1-10), polo10: -90° após 10 (1-100). Soma: baixa ω ~ -90°, entre 1-10 ~ -180°, alta > -270°. Plot: inicia -90°, transita para -180° em 1 rad/s, -270° em 10 rad/s.",
                              "finalVerifications": [
                                "Assíntotas individuais corretas para todos polos/zeros.",
                                "Soma de fase correta em baixas (ω<<min corner) e altas frequências.",
                                "Transições lineares de ±45°/década marcadas precisamente.",
                                "Gráfico rotulado com eixos, corners e G(s).",
                                "Match qualitativo com bode plot numérico.",
                                "Fase assintótica converge corretamente (±90°(p-z))."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de polos/zeros (100% correto).",
                                "Correção das assíntotas e transições (erro <5° em pontos).",
                                "Qualidade da soma e plotagem (linhas limpas, escala adequada).",
                                "Documentação completa (labels, cálculos mostrados).",
                                "Validação com software (concordância >90%).",
                                "Eficiência temporal e clareza explicativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e logaritmos decádicos.",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Engenharia de Controle: Análise de estabilidade via Nyquist/Margins.",
                                "Programação: Implementação em Python (control.matlab.bode) ou MATLAB.",
                                "Estatística: Confiança em aproximações assintóticas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, diagramas de Bode de fase são essenciais para projetar sistemas de controle de voo autônomo (ex: autopilot em aviões), analisando estabilidade de fase em frequências de turbulência, garantindo margens de fase >45° para evitar oscilações em manobras de alta velocidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Verificar diagrama de Bode com simulação",
                            "description": "Comparar curvas assintóticas com plots exatos gerados por ferramentas como MATLAB, validando precisão em sistemas de terceira ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Derivar Função de Transferência de Terceira Ordem",
                                  "subSteps": [
                                    "Escolha um sistema de terceira ordem realista, como um modelo de oscilador amortecido com polos dominantes, ex: G(s) = ω_n^3 / (s^3 + 2ζω_n s^2 + ω_n^2 s + ω_n^3).",
                                    "Identifique polos e zeros: calcule raízes do denominador usando fórmula cúbica ou fatoração.",
                                    "Normalize a função para ganho DC unitário e anote constantes de tempo τ_i = 1/|p_i|.",
                                    "Verifique estabilidade: todos polos no semiplano esquerdo.",
                                    "Documente a FT em forma padrão com fatores (s/ω_c + 1)."
                                  ],
                                  "verification": "FT escrita corretamente, polos/zeros listados e plotados no plano s.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica",
                                    "Software de álgebra simbólica (opcional, como SymPy)"
                                  ],
                                  "tips": "Escolha polos espaçados (ex: 1, 10, 100 rad/s) para curvas claras de aproximação.",
                                  "learningObjective": "Compreender a estrutura polinomial de FTs de terceira ordem e suas implicações dinâmicas.",
                                  "commonMistakes": [
                                    "Esquecer normalização de ganho",
                                    "Confundir polos com zeros",
                                    "Ignorar multiplicidade de polos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Diagrama de Bode Assintótico Manualmente",
                                  "subSteps": [
                                    "Desenhe o gráfico de magnitude: linhas horizontais (-20 dB/década por polo) e quebras em ω = |p_i|.",
                                    "Adicione aproximações de canto: -3 dB para polos reais, curvas suaves para complexos.",
                                    "Desenhe fase: 0° inicial, -90° por polo/zero, transições de 45°/década.",
                                    "Calcule magnitude em frequências chave (ω << ω_c, ω >> ω_c, ω ≈ ω_c).",
                                    "Rotule eixos log-log para magnitude e log-linear para fase."
                                  ],
                                  "verification": "Diagrama assintótico desenhado com todas quebras de canto marcadas e inclinações corretas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel log-log (semi-log)",
                                    "Régua e compasso",
                                    "Tabelas de Bode padrão"
                                  ],
                                  "tips": "Comece pelas contribuições individuais de cada fator antes de somar.",
                                  "learningObjective": "Dominar regras assintóticas para predição rápida de resposta em frequência.",
                                  "commonMistakes": [
                                    "Inclinação errada (+20 dB/déc por zero)",
                                    "Fase em +90° para polos",
                                    "Escala linear nos eixos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Diagrama de Bode Exato via Simulação",
                                  "subSteps": [
                                    "Abra MATLAB/Octave e defina a FT: num = [ganho]; den = conv([1 p1],[1 p2],[1 p3]).",
                                    "Use bodeplot(sys) ou bode(sys,{0.1,1000}) para gerar magnitude e fase.",
                                    "Ajuste faixa de frequência: de 0.1*ω_min a 10*ω_max.",
                                    "Exporte plots como imagem ou dados numéricos (bodeoptions).",
                                    "Sobreponha curvas assintóticas manualmente no mesmo gráfico usando hold on e semilogx."
                                  ],
                                  "verification": "Plots exatos gerados e salvos, com sobreposição das assintóticas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Control Systems Toolbox",
                                    "Script .m preparado"
                                  ],
                                  "tips": "Use grid e legend para clareza; teste com tf() para sistemas simples primeiro.",
                                  "learningObjective": "Aplicar ferramentas numéricas para computar respostas em frequência precisas.",
                                  "commonMistakes": [
                                    "Faixa de ω inadequada",
                                    "Erro na definição de den (não usar poly)",
                                    "Ignorar unwrap na fase"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Curvas e Validar Precisão",
                                  "subSteps": [
                                    "Meça erros: Δmag(ω) = |20log|G(jω)|_exato - assintótico| em pontos críticos.",
                                    "Identifique regiões: baixa/alta freq. (erro <1 dB), transição (até 6 dB).",
                                    "Calcule métricas: erro máx., RMS, frequência de pico de erro.",
                                    "Analise discrepâncias: efeito de polos próximos, fase não mínima.",
                                    "Conclua validade: assintótico preciso se erro <10% global."
                                  ],
                                  "verification": "Relatório com tabela de erros, gráficos sobrepostos e conclusão quantitativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos do passo 3",
                                    "Excel/MATLAB para métricas",
                                    "Calculadora"
                                  ],
                                  "tips": "Foque em 10-20 pontos por década para amostragem densa.",
                                  "learningObjective": "Avaliar limitações das aproximações assintóticas em sistemas complexos.",
                                  "commonMistakes": [
                                    "Comparar escalas erradas (linear vs log)",
                                    "Ignorar fase",
                                    "Concluir sem quantificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1 / [(s+1)(s+10)(s+100)], o assintótico mostra quebras em 1,10,100 rad/s (-60 dB/déc alta freq.); simulação MATLAB confirma erro máx. de 5 dB perto de 10 rad/s, validando para controle de atitude em aeronaves.",
                              "finalVerifications": [
                                "Curvas assintóticas e exatas coincidem em baixas (<1 dB erro) e altas frequências.",
                                "Erro máximo na magnitude <6 dB na região de transição.",
                                "Fase assintótica segue exata dentro de 20° globalmente.",
                                "Métricas RMS de erro reportadas (<3 dB).",
                                "Discrepâncias explicadas (ex: polos complexos).",
                                "Gráficos sobrepostos legíveis com legendas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da FT (100% polos corretos).",
                                "Diagrama assintótico com inclinações e cantos exatos (90%).",
                                "Simulação MATLAB sem erros de sintaxe e faixa adequada (100%).",
                                "Análise quantitativa de erros com tabela/gráfico (80%).",
                                "Conclusões alinhadas à validação (precisão >90% em extremos).",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: projeto de compensadores baseados em Bode.",
                                "Processamento de Sinais: filtros analógicos em DSP.",
                                "Eletrônica: análise de amplificadores operacionais de 3 pólos.",
                                "Física Aeronáutica: modelagem de aeroelasticidade.",
                                "Programação: scripts MATLAB para automação de análises."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, valida modelos de função de transferência de sistemas de controle de voo (ex: estabilizadores), garantindo estabilidade antes de simulações CFD ou testes em túnel de vento, reduzindo riscos em protótipos como drones ou aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.4",
                        "name": "Análise de Ganho e Largura de Banda",
                        "description": "Análise quantitativa do ganho estático (DC) e da largura de banda (frequência onde |H(jω)| cai para -3dB), métricas chave para especificações de desempenho em controle e processamento de sinais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.4.1",
                            "name": "Determinar ganho em baixa frequência (ganho DC)",
                            "description": "Calcular lim ω→0 |H(jω)| e expressar em dB, relacionando com o valor estático do sistema H(0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Ganho em Baixa Frequência (Ganho DC)",
                                  "subSteps": [
                                    "Defina a função de transferência H(s) e sua resposta em frequência H(jω).",
                                    "Explique que o ganho em frequência é dado por |H(jω)|.",
                                    "Descreva o ganho DC como o limite lim_{ω→0} |H(jω)|, equivalente a |H(0)|.",
                                    "Discuta a importância: representa o ganho estático do sistema para entradas de frequência zero (constantes)."
                                  ],
                                  "verification": "Escreva uma definição clara e relacione ganho DC com H(0) em um parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Apostila de Sinais e Sistemas Dinâmicos",
                                    "Videoaula sobre resposta em frequência"
                                  ],
                                  "tips": "Pense no ganho DC como a amplificação de uma entrada constante (DC).",
                                  "learningObjective": "Entender o significado matemático e físico do ganho DC em sistemas lineares.",
                                  "commonMistakes": [
                                    "Confundir ganho DC com ganho em alta frequência.",
                                    "Esquecer que se trata do módulo |H(jω)|."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Ganho DC via Avaliação Direta de H(0)",
                                  "subSteps": [
                                    "Substitua s = 0 na função de transferência H(s) para obter H(0).",
                                    "Calcule o módulo |H(0)|.",
                                    "Verifique se H(s) está em forma racional (polinômio num/den).",
                                    "Simplifique a expressão resultante."
                                  ],
                                  "verification": "Compute H(0) para H(s) = 5/(s+2) e confirme |H(0)| = 2.5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de papel ou caderno"
                                  ],
                                  "tips": "H(0) é o produto dos coeficientes constantes do numerador dividido pelo denominador em s=0.",
                                  "learningObjective": "Dominar o cálculo direto do ganho DC através de H(0).",
                                  "commonMistakes": [
                                    "Não cancelar fatores comuns antes de substituir s=0.",
                                    "Confundir H(0) com H(j0) sem módulo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Limite lim_{ω→0} |H(jω)| e Confirmar Equivalência",
                                  "subSteps": [
                                    "Substitua s = jω em H(s) para obter H(jω).",
                                    "Escreva |H(jω)| = |num(jω)/den(jω)|.",
                                    "Avalie o limite matemático lim_{ω→0} |H(jω)|.",
                                    "Compare o resultado com |H(0)| para validar a equivalência."
                                  ],
                                  "verification": "Para H(s) = 10/(s+1), mostre que lim_{ω→0} |H(jω)| = 10 = |H(0)|.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy)",
                                    "Tabela de propriedades de módulo"
                                  ],
                                  "tips": "Use propriedades de limite: lim |f(ω)/g(ω)| = |lim f/g| quando aplicável.",
                                  "learningObjective": "Aplicar cálculo de limites para confirmar o ganho DC via frequência.",
                                  "commonMistakes": [
                                    "Erros no cálculo de |jω + a| = sqrt(ω² + a²).",
                                    "Esquecer o módulo absoluto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar o Ganho DC em dB e Interpretar",
                                  "subSteps": [
                                    "Converta |H(0)| para dB usando 20 log_{10}(|H(0)|).",
                                    "Interprete o valor: >0 dB (ganho), <0 dB (atenuação).",
                                    "Relacione com o comportamento estático do sistema (ex: erro em regime permanente).",
                                    "Aplique em um diagrama de Bode qualitativo."
                                  ],
                                  "verification": "Para |H(0)|=2, calcule 6 dB e explique o significado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora com logaritmo",
                                    "Gráficos de Bode exemplo"
                                  ],
                                  "tips": "Lembre: 20 log10(10) = 20 dB, 20 log10(2) ≈ 6 dB.",
                                  "learningObjective": "Converter e interpretar ganho DC em escala logarítmica para análise prática.",
                                  "commonMistakes": [
                                    "Usar 10 log em vez de 20 log para magnitude de tensão.",
                                    "Confundir sinal positivo/negativo."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de atitude em aeronave com H(s) = K / (τs + 1), onde K=50, τ=0.1. Calcule ganho DC: H(0)=50, |H(0)|=50 (34 dB). Isso indica que uma entrada constante de 1 rad/s resulta em saída estática de 50 rad/s, útil para calibração de sensores.",
                              "finalVerifications": [
                                "Calcular corretamente H(0) e |H(0)| para funções dadas.",
                                "Confirmar lim_{ω→0} |H(jω)| = |H(0)|.",
                                "Converter precisamente para dB com 20 log10.",
                                "Interpretar o valor em contexto de sistema estático.",
                                "Identificar erros comuns em cálculos manuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de H(0) e limite (100% correto).",
                                "Correta conversão para dB (erro <0.1 dB).",
                                "Explicação clara da equivalência matemática.",
                                "Interpretação física adequada ao contexto aeronáutico.",
                                "Uso correto de ferramentas e avoidance de erros comuns.",
                                "Completude dos passos com substeps executados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e logaritmos.",
                                "Eletrônica: Análise de amplificadores em DC.",
                                "Controle Automático: Erro em regime permanente.",
                                "Física: Sistemas lineares invariantes no tempo."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, o ganho DC determina a precisão estática de sistemas como autômatos de voo ou servomecanismos de flaps, garantindo que comandos constantes (ex: trim de elevador) produzam respostas previsíveis sem deriva, essencial para estabilidade em voo nivelado."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.4.2",
                            "name": "Identificar largura de banda (-3dB)",
                            "description": "Encontrar ω_c tal que |H(jω_c)| = 1/√2 do valor máximo ou DC, usando diagramas de Bode para sistemas de primeira e segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de largura de banda e ponto -3dB",
                                  "subSteps": [
                                    "Defina largura de banda como a frequência ω_c onde o módulo da função de transferência |H(jω_c)| cai para 1/√2 (≈0.707) do valor máximo ou ganho em DC (ω=0).",
                                    "Calcule matematicamente: -3dB equivale a 20*log10(1/√2) ≈ -3dB, representando uma atenuação de potência pela metade.",
                                    "Explique a importância: indica a faixa de operação efetiva do sistema antes da atenuação significativa.",
                                    "Diferencie de frequência de ressonância em sistemas de segunda ordem.",
                                    "Relacione com resposta transitória: largura de banda maior implica resposta mais rápida."
                                  ],
                                  "verification": "Explique em suas palavras o significado de -3dB e esboce um diagrama de magnitude genérico marcando ω_c.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora científica",
                                    "Notas sobre funções de transferência"
                                  ],
                                  "tips": [
                                    "Lembre-se: use o ganho DC como referência; para sistemas passa-baixa, é |H(0)|."
                                  ],
                                  "learningObjective": "Dominar o conceito matemático e físico da largura de banda -3dB.",
                                  "commonMistakes": [
                                    "Confundir -3dB com queda de 3 vezes no ganho linear",
                                    "Ignorar normalização pelo ganho DC",
                                    "Aplicar diretamente em fase ao invés de magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar diagramas de Bode para sistemas de primeira ordem",
                                  "subSteps": [
                                    "Considere H(s) = ω_0 / (s + ω_0) para passa-baixa; magnitude |H(jω)| = ω_0 / √(ω² + ω_0²).",
                                    "Desenhe o diagrama assintótico de Bode: rampa -20dB/década após ω_0.",
                                    "Identifique ω_c = ω_0 exatamente, onde |H(jω_c)| = 1/√2 do DC (que é 0dB).",
                                    "Verifique numericamente: calcule |H(jω_0)| e confirme -3dB.",
                                    "Pratique com variação de ω_0 e observe o deslocamento do corte."
                                  ],
                                  "verification": "Dado um Bode plot de 1ª ordem, marque ω_c e justifique com cálculo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB/Octave ou Python (matplotlib/control)",
                                    "Exemplos de H(s) de 1ª ordem"
                                  ],
                                  "tips": [
                                    "A aproximação assintótica é precisa em baixas e altas frequências; use exata no corte."
                                  ],
                                  "learningObjective": "Aplicar análise de Bode para identificar ω_c em sistemas de 1ª ordem.",
                                  "commonMistakes": [
                                    "Usar frequência de interseção assintótica sem verificar o ponto exato",
                                    "Confundir polo com zero",
                                    "Esquecer normalização em dB"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar diagramas de Bode para sistemas de segunda ordem",
                                  "subSteps": [
                                    "Considere H(s) = ω_n² / (s² + 2ζω_n s + ω_n²); magnitude depende de fator de amortecimento ζ.",
                                    "Desenhe Bode: pico de ressonância para ζ<0.707, rampa -40dB/década após ω_n.",
                                    "Encontre ω_c resolvendo |H(jω_c)| = |H(0)| / √2 = ω_n / √2 (para DC=1).",
                                    "Use fórmula aproximada: ω_c ≈ ω_n √(1 - 2ζ² + √(2 - 4ζ² + 4ζ⁴)) para ζ<1/√2.",
                                    "Compare com simulação: plote e marque o ponto -3dB."
                                  ],
                                  "verification": "Para H(s) dado de 2ª ordem, compute e marque ω_c no Bode plot gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação (MATLAB bode(), Python control.bode())",
                                    "Tabelas de ζ vs ω_c/ω_n"
                                  ],
                                  "tips": [
                                    "Para ζ=0.707, ω_c = ω_n; para ζ>0.707, ω_c < ω_n."
                                  ],
                                  "learningObjective": "Identificar ω_c em sistemas de 2ª ordem considerando efeitos de amortecimento.",
                                  "commonMistakes": [
                                    "Confundir ω_c com ω_n ou ω_r (ressonância)",
                                    "Ignorar pico de ressonância afetando referência DC",
                                    "Usar aproximações sem validar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação geral e verificar resultados",
                                  "subSteps": [
                                    "Gere ou obtenha Bode plots mistos (1ª+2ª ordem) e identifique ω_c do ganho total.",
                                    "Some contribuições em dB: ω_c onde soma = DC -3dB.",
                                    "Teste com ruído ou sinais: simule resposta e confirme atenuação.",
                                    "Documente processo: anote equações, plots e valores de ω_c.",
                                    "Compare analítico vs gráfico para precisão."
                                  ],
                                  "verification": "Resolva 3 exercícios independentes e autoavalie acurácia >95%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online",
                                    "Software de análise",
                                    "Gráficos de referência"
                                  ],
                                  "tips": [
                                    "Sempre normalize pelo ganho de baixo frequência; use zoom no plot para precisão."
                                  ],
                                  "learningObjective": "Integrar análise para sistemas reais e validar ω_c.",
                                  "commonMistakes": [
                                    "Não somar corretamente magnitudes em cascata",
                                    "Selecionar ponto errado por escala log",
                                    "Esquecer unidades (rad/s vs Hz)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de atitude em aeronave modelado como H(s) = 10 / (s² + 3s + 10) (ζ≈0.15, ω_n=√10 rad/s), plote Bode e identifique ω_c ≈ 3.16 rad/s onde magnitude cai para -3dB do DC (0dB), confirmando faixa de operação estável abaixo dessa frequência.",
                              "finalVerifications": [
                                "Localiza corretamente ω_c em Bode plots de 1ª e 2ª ordem fornecidos.",
                                "Justifica escolha com cálculo de |H(jω_c)| = 1/√2 * |H(0)|.",
                                "Diferencia ω_c de ω_n e ω_r em sistemas subamortecidos.",
                                "Aplica a sistemas em cascata somando dB corretamente.",
                                "Valida com simulação numérica (erro <5%).",
                                "Explica impacto em resposta transitória."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ω_c (erro <2% em plots).",
                                "Compreensão conceitual: explica -3dB corretamente.",
                                "Uso adequado de ferramentas (plots assintóticos vs exatos).",
                                "Tratamento de variações (ζ, ordens mistas).",
                                "Documentação clara de passos e justificativas.",
                                "Aplicação contextual em engenharia aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa, logaritmos decibéis e resolução numérica de equações.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento.",
                                "Engenharia de Controle: Estabilidade e desempenho em malhas de feedback.",
                                "Processamento de Sinais: Filtros analógicos em sensores aviônicos.",
                                "Computação: Simulação em MATLAB/Python para validação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, identificar a largura de banda -3dB em funções de transferência de atuadores ou giroscópios garante que sistemas de controle de voo respondam rapidamente a perturbações (como turbulência) sem amplificar ruídos de alta frequência, otimizando estabilidade e precisão de navegação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.4.3",
                            "name": "Analisar trade-offs entre ganho e largura de banda",
                            "description": "Interpretar como polos dominantes afetam o produto ganho × largura de banda em aplicações como amplificadores e servomecanismos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Ganho, Largura de Banda e Polos Dominantes",
                                  "subSteps": [
                                    "Defina ganho (magnitude da função de transferência em baixa frequência) e largura de banda (frequência onde o ganho cai 3dB).",
                                    "Explique polos dominantes como os polos mais próximos do eixo imaginário no plano s, determinando o comportamento em baixa frequência.",
                                    "Calcule o produto ganho × largura de banda (GBW) para sistemas de segunda ordem simples.",
                                    "Desenhe diagramas de Bode para ilustrar o impacto inicial desses conceitos.",
                                    "Compare GBW em sistemas com e sem polos dominantes."
                                  ],
                                  "verification": "Crie um diagrama de Bode manual para um sistema com polo dominante e confirme que GBW é constante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Sinais e Sistemas (ex: Oppenheim), software MATLAB ou Python (SciPy) para plots de Bode.",
                                  "tips": "Sempre normalize frequências para rad/s para evitar erros de unidade.",
                                  "learningObjective": "Compreender as definições e relações matemáticas básicas entre ganho, largura de banda e polos.",
                                  "commonMistakes": "Confundir largura de banda com frequência de corte (-3dB) sem considerar a inclinação da curva de Bode."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Impacto de Polos Dominantes no Produto GBW",
                                  "subSteps": [
                                    "Derive a fórmula aproximada para GBW em amplificadores operacionais: GBW ≈ |p1| * |p2| / ω0 para polos reais.",
                                    "Simule variações no posicionamento de polos dominantes usando funções de transferência de segunda ordem.",
                                    "Observe como mover polos para a esquerda aumenta largura de banda mas reduz ganho DC.",
                                    "Calcule numericamente GBW para diferentes configurações de polos.",
                                    "Plote curvas de ganho vs. largura de banda para visualizar o trade-off."
                                  ],
                                  "verification": "Gere plots mostrando GBW constante apesar de mudanças em ganho e largura de banda.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink ou Octave, calculadora simbólica (SymPy).",
                                  "tips": "Use aproximações de polos dominantes (ângulo < 60° do eixo real) para simplificar cálculos.",
                                  "learningObjective": "Interpretar matematicamente como polos dominantes mantêm GBW constante enquanto alteram ganho e largura.",
                                  "commonMistakes": "Ignorar a compensação de fase causada por polos não-dominantes em análises aproximadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Análise a Amplificadores Operacionais",
                                  "subSteps": [
                                    "Modele um amplificador de ganho unitário com função de transferência G(s) = A0 / (1 + s/ω_p).",
                                    "Varie A0 e ω_p mantendo GBW fixo e meça desempenho em frequência.",
                                    "Simule resposta transitória para entradas degrau e analise overshoot relacionado a polos.",
                                    "Compare configurações de alto ganho (baixa BW) vs. baixa ganho (alta BW).",
                                    "Otimize para uma aplicação específica, como filtro ativo."
                                  ],
                                  "verification": "Simule e demonstre que dobrar o ganho DC halveia a largura de banda, mantendo GBW.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador LTSpice ou MATLAB, datasheet de um op-amp real (ex: LM741).",
                                  "tips": "Inclua capacitores parasitas reais nos modelos para realismo.",
                                  "learningObjective": "Aplicar trade-offs de GBW em circuitos de amplificação.",
                                  "commonMistakes": "Esquecer que GBW é uma constante intrínseca do op-amp, não do circuito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Trade-offs em Servomecanismos Aeronáuticos",
                                  "subSteps": [
                                    "Modele um servomecanismo simples: G(s) = K / (s(s + a)) com polos em 0 e -a.",
                                    "Analise como polos dominantes afetam estabilidade e resposta rápida em controle de flaps.",
                                    "Calcule trade-offs: alto ganho para precisão estática vs. largura de banda para rastreamento dinâmico.",
                                    "Simule perturbações e verifique limites de performance via GBW.",
                                    "Proponha compensadores para mitigar trade-offs."
                                  ],
                                  "verification": "Produza relatório com plots de resposta em malha fechada mostrando limites de GBW.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Simulink para modelagem de servos, referências de controle aeronáutico.",
                                  "tips": "Considere delays de fase em atuadores reais para aplicações práticas.",
                                  "learningObjective": "Avaliar trade-offs em sistemas de controle dinâmicos reais.",
                                  "commonMistakes": "Superestimar largura de banda ignorando polos de alta frequência em motores."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Trade-offs e Otimização",
                                  "subSteps": [
                                    "Compile dados de steps anteriores em uma tabela de trade-offs.",
                                    "Use critérios como margem de fase e tempo de assentamento para quantificar.",
                                    "Otimize GBW para cenários aeronáuticos específicos (ex: autopilot).",
                                    "Discuta limitações físicas (ruído, potência).",
                                    "Crie gráfico de Pareto para ganho vs. BW."
                                  ],
                                  "verification": "Desenvolva um design otimizado com justificativa de trade-offs escolhidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou Python (Matplotlib) para gráficos.",
                                  "tips": "Priorize requisitos de missão sobre máximos teóricos.",
                                  "learningObjective": "Sintetizar análises para decisões de design baseadas em trade-offs.",
                                  "commonMistakes": "Focar apenas em DC gain sem considerar dinâmica em banda larga."
                                }
                              ],
                              "practicalExample": "Em um servomecanismo de controle de ailerons em uma aeronave, aumentar o ganho DC para precisão em voo estacionário reduz a largura de banda, limitando resposta a turbulências rápidas; simule mover o polo dominante de -10 rad/s para -50 rad/s, dobrando BW mas halveando ganho, mantendo GBW=500 rad/s.",
                              "finalVerifications": [
                                "Explicar verbalmente por que GBW é aproximadamente constante em sistemas com polos dominantes.",
                                "Gerar diagrama de Bode correto para um sistema dado com trade-offs identificados.",
                                "Simular e prever corretamente resposta transitória alterando ganho.",
                                "Identificar polo dominante em uma função de transferência complexa.",
                                "Propor otimização para uma especificação de BW mínima e ganho máximo.",
                                "Calcular GBW com erro <5% para um exemplo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e cálculo de GBW (90%+ acurácia).",
                                "Qualidade e legibilidade de plots de Bode e transitórios.",
                                "Correta identificação de trade-offs com justificativa quantitativa.",
                                "Aplicação contextual a amplificadores e servos aeronáuticos.",
                                "Criatividade em otimizações e consideração de limitações reais.",
                                "Completude da análise subSteps em todos os passos."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Margens de estabilidade e compensação de fase.",
                                "Eletrônica Analógica: Design de filtros ativos limitados por GBW.",
                                "Dinâmica de Voo: Modelagem de atuadores em simulações de aeronaves.",
                                "Processamento de Sinais: Análise espectral em sistemas com BW limitada."
                              ],
                              "realWorldApplication": "No autopilot de aviões comerciais, trade-offs de GBW em servomecanismos garantem rastreamento preciso de trajetória sem oscilações perigosas, balanceando ganho alto para correções estáticas com largura de banda suficiente para manobras dinâmicas, evitando fadiga estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Determinação da Solução de Modelos",
                    "description": "Uso da função de transferência e resposta em frequência para calcular respostas transitórias e estacionárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Função de Transferência",
                        "description": "Representação no domínio de Laplace de sistemas lineares invariantes no tempo (LTI), definida como H(s) = Y(s)/U(s) com condições iniciais nulas. Propriedades: racionalidade, estabilidade via polos, usada para determinar respostas transitórias via transformada inversa.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Derivar a função de transferência a partir de equações diferenciais",
                            "description": "Dado uma equação diferencial linear de ordem n, aplicar transformada de Laplace para obter H(s) = Y(s)/U(s), identificando numerador e denominador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a equação diferencial para transformação de Laplace",
                                  "subSteps": [
                                    "Identifique a equação diferencial linear invariante no tempo de ordem n, na forma de variáveis de entrada u(t) e saída y(t).",
                                    "Confirme que as condições iniciais são zero (para funções de transferência padrão).",
                                    "Reescreva a equação no domínio do tempo, destacando derivadas de y e u.",
                                    "Anote os coeficientes constantes (a_i para y, b_j para u).",
                                    "Verifique se a equação está na forma padrão: ∑ a_k y^(k) = ∑ b_m u^(m)."
                                  ],
                                  "verification": "Equação reescrita corretamente com todas as derivadas identificadas e condições iniciais zero confirmadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simbólica ou software como MATLAB/SymPy"
                                  ],
                                  "tips": "Sempre assuma condições iniciais zero para funções de transferência; anote a ordem n explicitamente.",
                                  "learningObjective": "Compreender a estrutura de equações diferenciais lineares e prepará-las para Laplace.",
                                  "commonMistakes": [
                                    "Esquecer condições iniciais não zero",
                                    "Confundir entrada u(t) com saída y(t)",
                                    "Ignorar coeficientes variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a transformada de Laplace bilateral à equação",
                                  "subSteps": [
                                    "Aplique L{ y^(k)(t) } = s^k Y(s) - termos iniciais (zero para iniciais zero).",
                                    "Transforme cada termo do lado esquerdo: ∑ a_k s^k Y(s).",
                                    "Transforme cada termo do lado direito: ∑ b_m s^m U(s).",
                                    "Substitua na equação transformada: Den(s) Y(s) = Num(s) U(s).",
                                    "Simplifique expressões algébricas iniciais."
                                  ],
                                  "verification": "Equação no domínio s correta, com Y(s) e U(s) isolados em lados opostos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Software de álgebra simbólica (ex: Mathematica)"
                                  ],
                                  "tips": "Use a propriedade da derivada: L{y'} = sY(s) - y(0); memorize para iniciais zero.",
                                  "learningObjective": "Dominar a aplicação da transformada de Laplace a derivadas em equações diferenciais.",
                                  "commonMistakes": [
                                    "Esquecer o fator s^k para derivadas de ordem k",
                                    "Incluir incorretamente condições iniciais",
                                    "Erros em potências de s"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar Y(s) em termos de U(s)",
                                  "subSteps": [
                                    "Divida ambos os lados pela função do denominador: Y(s) = [Num(s)/Den(s)] U(s).",
                                    "Identifique o numerador Num(s) = ∑ b_m s^m e denominador Den(s) = ∑ a_k s^k.",
                                    "Normalize o coeficiente líder do denominador para 1, se necessário.",
                                    "Fatore polinômios Num(s) e Den(s) para identificar zeros e polos.",
                                    "Verifique simplificações de fatores comuns entre num e den."
                                  ],
                                  "verification": "Y(s)/U(s) expressa como fração própria racional com num e den corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Ferramenta de fatoração polinomial online"
                                  ],
                                  "tips": "Sempre normalize Den(s) com coeficiente líder 1 para padronização.",
                                  "learningObjective": "Manipular expressões algébricas no domínio s para isolar a razão Y(s)/U(s).",
                                  "commonMistakes": [
                                    "Dividir pelo numerador em vez do denominador",
                                    "Erros em divisão polinomial",
                                    "Não normalizar coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e validar a função de transferência H(s)",
                                  "subSteps": [
                                    "Defina H(s) = Y(s)/U(s) = Num(s)/Den(s).",
                                    "Escreva H(s) explicitamente como fração racional.",
                                    "Identifique ordem do sistema (grau de Den(s)), zeros (raízes Num) e polos (raízes Den).",
                                    "Verifique estabilidade (polos no semiplano esquerdo).",
                                    "Compare com forma esperada para sistemas físicos."
                                  ],
                                  "verification": "H(s) completa, com num/den identificados, ordem e polos/zeros listados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico de polos/zeros (software como MATLAB polezero)"
                                  ],
                                  "tips": "Plote polos/zeros para visualização intuitiva da dinâmica.",
                                  "learningObjective": "Finalizar e interpretar a função de transferência como modelo de sistema.",
                                  "commonMistakes": [
                                    "Inverter num e den",
                                    "Esquecer fatoração",
                                    "Ignorar ordem relativa num/den"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação m ÿ + c ẏ + k y = u(t) (sistema massa-mola-amortecedor): Aplique Laplace → (m s² + c s + k) Y(s) = U(s) → H(s) = 1 / (m s² + c s + k). Identifique num=1, den=m s² + c s + k.",
                              "finalVerifications": [
                                "H(s) é uma fração própria racional com grau(den) >= grau(num).",
                                "Coeficiente líder do denominador é 1.",
                                "Polos e zeros corretamente identificados e listados.",
                                "Condições iniciais zero assumidas e justificadas.",
                                "Equação original reproduzida ao aplicar Laplace inversa (verificação conceitual).",
                                "Ordem do sistema matches ordem da ED original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de Laplace (sem erros em s^k).",
                                "Correta isolamento de Y(s)/U(s) com simplificação algébrica.",
                                "Identificação clara de numerador e denominador.",
                                "Interpretação física: ordem, polos/zeros relevantes.",
                                "Apresentação limpa de H(s) normalizada.",
                                "Tratamento de casos especiais (ex: ordem relativa)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas integrais e álgebra polinomial.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Controle Automático: Análise de estabilidade via polos.",
                                "Programação: Simulação em MATLAB/Simulink de H(s).",
                                "Engenharia de Controle: Projeto de controladores baseados em H(s)."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, deriva H(s) para modelo longitudinal de aeronave a partir de EDs de movimento, permitindo análise de resposta em frequência para estabilidade de voo e design de sistemas de controle de atitude."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Simplificar diagramas de blocos para obter H(s)",
                            "description": "Usar regras de blocos em série, paralelo, realimentação e soma para reduzir um diagrama de blocos complexo a uma única função de transferência H(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e rotular o diagrama de blocos",
                                  "subSteps": [
                                    "Examine o diagrama completo e identifique todos os blocos de transferência (G1, G2, etc.), somadores e pontos de realimentação.",
                                    "Rotule cada conexão como série, paralelo, soma ou realimentação usando setas e anotações.",
                                    "Desenhe uma cópia simplificada do diagrama destacando as configurações iniciais.",
                                    "Liste todas as funções de transferência envolvidas.",
                                    "Verifique se há loops aninhados ou configurações complexas."
                                  ],
                                  "verification": "O diagrama rotulado mostra corretamente todas as conexões sem omissões ou erros de identificação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho (ex: Draw.io)",
                                    "Tabela de regras de simplificação de blocos",
                                    "Exemplo de diagrama impresso"
                                  ],
                                  "tips": "Comece pelos blocos mais internos e use cores diferentes para tipos de conexão para visualização clara.",
                                  "learningObjective": "Identificar e classificar com precisão as configurações básicas em um diagrama de blocos.",
                                  "commonMistakes": [
                                    "Ignorar somadores negativos",
                                    "Confundir realimentação positiva com negativa",
                                    "Omitir blocos em paralelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simplificar blocos em série e paralelo",
                                  "subSteps": [
                                    "Aplique a regra de série: multiplique as funções de transferência consecutivas (H_eq = G1 * G2).",
                                    "Aplique a regra de paralelo: some as funções (H_eq = G1 + G2).",
                                    "Substitua os grupos simplificados no diagrama original, removendo os blocos individuais.",
                                    "Repita o processo para todos os pares ou grupos em série/paralelo identificados.",
                                    "Atualize o diagrama com os blocos equivalentes."
                                  ],
                                  "verification": "Todos os blocos em série e paralelo foram substituídos por equivalentes corretos, reduzindo o número de blocos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: MATLAB Syms)",
                                    "Folha de fórmulas de blocos",
                                    "Diagrama atualizado do passo 1"
                                  ],
                                  "tips": "Sempre verifique a sinalização (positiva/negativa) antes de multiplicar ou somar.",
                                  "learningObjective": "Aplicar regras de simplificação para configurações série e paralelo com precisão algébrica.",
                                  "commonMistakes": [
                                    "Esquecer de inverter sinal em somadores negativos",
                                    "Multiplicar incorretamente em série com denominadores",
                                    "Não reduzir frações equivalentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simplificar configurações de realimentação",
                                  "subSteps": [
                                    "Identifique loops de realimentação unitária e não-unitária.",
                                    "Aplique a fórmula de realimentação: H(s) = G(s) / (1 + G(s)H(s)) para realimentação negativa unitária.",
                                    "Para realimentação não-unitária, use H(s) = [G(s)] / [1 + G(s)H(s)].",
                                    "Substitua o loop pelo bloco equivalente no diagrama.",
                                    "Repita para loops aninhados, começando pelos internos."
                                  ],
                                  "verification": "Cada loop de realimentação foi corretamente substituído por sua função de transferência equivalente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de fórmulas de realimentação",
                                    "Software de álgebra simbólica",
                                    "Diagrama simplificado do passo 2"
                                  ],
                                  "tips": "Expanda numerador e denominador para verificar simplificações e cancele termos comuns.",
                                  "learningObjective": "Dominar a redução de loops de realimentação para funções de transferência únicas.",
                                  "commonMistakes": [
                                    "Confundir realimentação positiva/negativa",
                                    "Esquecer o sinal no denominador",
                                    "Não lidar com H(s) ≠ 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar resultados e obter H(s) final",
                                  "subSteps": [
                                    "Combine todos os blocos restantes usando regras de série, paralelo ou soma.",
                                    "Expresse a função final como H(s) = numerador / denominador em termos de s.",
                                    "Simplifique a fração algébricamente (cancele fatores comuns).",
                                    "Verifique a consistência dimensional e limites (ex: H(0) para ganho estático).",
                                    "Escreva a H(s) final em forma padrão."
                                  ],
                                  "verification": "A H(s) final é uma fração única e simplificada que reproduz o diagrama original quando expandida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simbólica",
                                    "Papel para expansões algébricas",
                                    "Diagrama final do passo 3"
                                  ],
                                  "tips": "Teste com valores numéricos simples (ex: s=0) para validar.",
                                  "learningObjective": "Integrar todas as simplificações para obter a função de transferência global H(s).",
                                  "commonMistakes": [
                                    "Erros de álgebra no denominador final",
                                    "Não simplificar frações",
                                    "Ignorar ganhos constantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama com G1(s) em série com G2(s), em paralelo com G3(s), realimentado por H(s)=1: 1) Série: G_eq = G1*G2. 2) Paralelo: G_p = G_eq + G3. 3) Realimentação: H(s) = G_p / (1 + G_p). Resultado: H(s) = (G1 G2 + G3) / (1 + G1 G2 + G3).",
                              "finalVerifications": [
                                "Simplificar corretamente um diagrama novo com 4-6 blocos.",
                                "Explicar verbalmente cada regra aplicada.",
                                "Validar H(s) simulando resposta a entrada degrau.",
                                "Identificar erros em uma simplificação fornecida.",
                                "Aplicar em diagrama com realimentação aninhada.",
                                "Comparar H(s) com simulação numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica em todas as simplificações (sem erros de sinal ou multiplicação).",
                                "Número de passos lógicos e sequenciais (redução progressiva).",
                                "Tempo de execução eficiente (menos de 1h para diagrama médio).",
                                "Clareza nas anotações e diagramas intermediários.",
                                "Validação final com testes numéricos ou limites.",
                                "Explicação correta das regras usadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de funções racionais e transformada de Laplace.",
                                "Programação: Implementação em MATLAB/Simulink para verificação.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos.",
                                "Engenharia de Controle: Análise de estabilidade via polos de H(s).",
                                "Eletrônica: Equivalência em circuitos de amplificadores com realimentação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, simplificar diagramas de blocos de sistemas de controle de voo (ex: autopilot) para obter H(s), permitindo análise de estabilidade, projeto de compensadores e simulações de resposta a perturbações como turbulência."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Calcular a resposta ao impulso usando H(s)",
                            "description": "Obter a resposta impulsional h(t) aplicando a transformada de Laplace inversa à função de transferência H(s), decompondo em frações parciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Escrever a Função de Transferência H(s)",
                                  "subSteps": [
                                    "Analise o sistema dado (equação diferencial ou diagrama de blocos) para derivar H(s) = Y(s)/U(s).",
                                    "Escreva H(s) como uma fração racional num(s)/den(s), garantindo que está na forma adequada.",
                                    "Identifique os polos e zeros preliminarmente fatorando numerador e denominador.",
                                    "Normalize o denominador para coeficiente líder 1, se necessário."
                                  ],
                                  "verification": "H(s) derivada corresponde exatamente ao modelo do sistema fornecido e está em forma racional simplificada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica",
                                    "Diagrama de blocos ou equação diferencial do sistema"
                                  ],
                                  "tips": "Verifique simplificações algébricas imediatamente para evitar propagação de erros.",
                                  "learningObjective": "Compreender como a função de transferência H(s) modela sistemas lineares invariantes no tempo (LTI).",
                                  "commonMistakes": [
                                    "Esquecer de dividir por U(s) ao derivar de equações diferenciais",
                                    "Erros em transformadas de Laplace iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor H(s) em Frações Parciais",
                                  "subSteps": [
                                    "Fatore completamente o denominador de H(s) para identificar polos.",
                                    "Escreva a expansão em frações parciais: H(s) = Σ [A_i / (s - p_i)] para polos simples ou formas generalizadas para múltiplos.",
                                    "Multiplique ambos os lados pelo denominador comum e expanda.",
                                    "Iguale coeficientes de potências de s ou use método de cobertura para resolver resíduos A_i."
                                  ],
                                  "verification": "Recombinando as frações parciais, obtém-se exatamente H(s) original sem resíduos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: MATLAB, SymPy)",
                                    "Tabela de identidades algébricas"
                                  ],
                                  "tips": "Para polos simples, o método de cobertura (Heaviside) acelera: A_i = H(p_i) * (s - p_i)|_{s=p_i}.",
                                  "learningObjective": "Dominar a técnica de decomposição em frações parciais para funções racionais próprias.",
                                  "commonMistakes": [
                                    "Cálculos incorretos de resíduos devido a erros aritméticos",
                                    "Não tratar corretamente polos múltiplos com termos t^k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Transformada de Laplace Inversa a Cada Fração Parcial",
                                  "subSteps": [
                                    "Para termo A/(s + a), aplique L^{-1}{A/(s + a)} = A e^{-a t} u(t).",
                                    "Para polos múltiplos, use fórmulas: L^{-1}{1/(s + a)^{k+1}} = t^k e^{-a t} / k! * u(t).",
                                    "Obtenha h_i(t) para cada fração parcial individualmente.",
                                    "Consulte tabela de Laplace para confirmar cada inversa."
                                  ],
                                  "verification": "Cada h_i(t) corresponde à entrada padrão na tabela de transformadas inversas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela completa de transformadas de Laplace",
                                    "Software de verificação simbólica"
                                  ],
                                  "tips": "Sempre multiplique pelo fator u(t) (função degrau unitário) para causalidade.",
                                  "learningObjective": "Aplicar com precisão a transformada inversa de Laplace a componentes parciais.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo no expoente exponencial",
                                    "Erros nos coeficientes fatoriais para polos múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Termos e Obter a Resposta Impulsional h(t)",
                                  "subSteps": [
                                    "Some todas as componentes: h(t) = Σ h_i(t) para t ≥ 0.",
                                    "Simplifique a expressão algébrica resultante, se possível.",
                                    "Inclua explicitamente u(t) e especifique o domínio t ≥ 0.",
                                    "Verifique limites: lim_{t→0+} h(t) = 0 para sistemas próprios e comportamento assintótico."
                                  ],
                                  "verification": "A transformada de Laplace de h(t) reconstrói H(s) original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para soma e simplificação"
                                  ],
                                  "tips": "Plote h(t) mentalmente: deve decair para sistemas estáveis (polos no semiplano esquerdo).",
                                  "learningObjective": "Sintetizar a resposta impulsional completa h(t) do sistema.",
                                  "commonMistakes": [
                                    "Erros de sinal ao somar expoentes",
                                    "Omitir u(t), levando a respostas não causais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Validar a Resposta h(t)",
                                  "subSteps": [
                                    "Compute L{h(t)} e confirme igual a H(s).",
                                    "Verifique propriedades: ∫ h(t) dt de 0 a ∞ = H(0), se aplicável.",
                                    "Simule numericamente se possível (ex: MATLAB).",
                                    "Analise estabilidade baseada nos polos."
                                  ],
                                  "verification": "Todas verificações passam: Laplace inversa, integral, simulação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink)",
                                    "Calculadora numérica"
                                  ],
                                  "tips": "Use syms no MATLAB para verificação automática.",
                                  "learningObjective": "Validar rigorosamente a resposta impulsional derivada.",
                                  "commonMistakes": [
                                    "Não checar causalidade ou estabilidade",
                                    "Ignorar verificações numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere H(s) = 1 / [(s + 1)(s + 2)].\nDecomposição: 1/(s+1) - 1/(s+2).\nInversas: e^{-t} u(t) - e^{-2t} u(t).\nAssim, h(t) = (e^{-t} - e^{-2t}) u(t). Verificação: L{h(t)} reconstrói H(s).",
                              "finalVerifications": [
                                "Decomposição em frações parciais é exata e recombinável a H(s).",
                                "Cada transformada inversa corresponde à tabela padrão.",
                                "h(t) final é causal (zero para t<0) e estável se polos Re<0.",
                                "Limites corretos: h(0+) = 0, decay exponencial.",
                                "Simulação numérica matches a solução analítica."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na decomposição (>95% correto).",
                                "Correção completa das inversas de Laplace sem erros de sinal ou fatoriais.",
                                "Expressão h(t) simplificada e com u(t) explícito.",
                                "Inclusão de pelo menos duas verificações independentes.",
                                "Eficiência: resolução em <90 minutos com explicações claras."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Análise de resposta transitória e estabilidade.",
                                "Processamento de Sinais: Design de filtros e convolução.",
                                "Matemática Avançada: Análise de resíduos e contorno complexo.",
                                "Física Aplicada: Modelagem de sistemas oscilatórios amortecidos.",
                                "Engenharia de Controle: Simulação de laços fechados."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, h(t) modela a resposta de uma aeronave a perturbações impulsivas como rajadas de vento ou comandos de piloto abruptos, essencial para projetar sistemas de controle de voo autônomos e garantir estabilidade em manobras dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.1.4",
                            "name": "Determinar resposta transitória a entrada degrau",
                            "description": "Calcular y(t) para u(t) = degrau unitário multiplicando U(s)=1/s por H(s) e aplicando inversa de Laplace, identificando termos transitórios e estacionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e representar a função de transferência H(s)",
                                  "subSteps": [
                                    "Revise o diagrama de blocos ou equação diferencial do sistema para extrair H(s).",
                                    "Escreva H(s) no formato pólos e zeros: H(s) = K * (s - z1)... / (s - p1)...",
                                    "Confirme que H(s) está em forma própria (racional, coeficientes reais).",
                                    "Anote o ganho estático lim s->0 H(s) para referência futura.",
                                    "Verifique estabilidade: todos os pólos no semiplano esquerdo."
                                  ],
                                  "verification": "H(s) está corretamente escrita e pólos identificados sem erros algébricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, tabela de funções de transferência padrão, calculadora.",
                                  "tips": "Sempre normalize H(s) dividindo pelo maior grau do denominador.",
                                  "learningObjective": "Compreender a representação em domínio s do sistema dinâmico.",
                                  "commonMistakes": "Confundir numerador com denominador; ignorar pólos no infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a transformada de Laplace da entrada degrau unitário",
                                  "subSteps": [
                                    "Lembre que u(t) = 1 para t >= 0, logo U(s) = 1/s.",
                                    "Escreva explicitamente U(s) = 1/s.",
                                    "Confirme condições iniciais zero (estado inicial em repouso).",
                                    "Discuta o significado físico: entrada constante após t=0."
                                  ],
                                  "verification": "U(s) = 1/s está anotado corretamente com condições iniciais zero.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela de transformadas de Laplace.",
                                  "tips": "Use condições iniciais zero para simplificar; caso contrário, ajuste.",
                                  "learningObjective": "Associar entradas temporais às suas imagens em s.",
                                  "commonMistakes": "Escrever U(s) = 1 em vez de 1/s; esquecer ramp ou outros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Y(s) = H(s) * U(s)",
                                  "subSteps": [
                                    "Multiplique H(s) por 1/s: Y(s) = H(s)/s.",
                                    "Simplifique a expressão algébricamente, cancelando fatores comuns se houver.",
                                    "Identifique o novo pólos: inclui pólos de H(s) mais s=0.",
                                    "Verifique grau: denominador deve ter grau um a mais que numerador para estabilidade.",
                                    "Anotar Y(s) em forma compacta."
                                  ],
                                  "verification": "Y(s) é idêntica a H(s)/s sem erros de multiplicação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora simbólica ou software como SymPy/MATLAB.",
                                  "tips": "Fatore s no denominador para visualizar pólos.",
                                  "learningObjective": "Aplicar convolução em domínio s via multiplicação.",
                                  "commonMistakes": "Erro de sinal na multiplicação; não simplificar frações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decompor Y(s) em frações parciais",
                                  "subSteps": [
                                    "Escreva Y(s) = soma A_i / (s - p_i) + termos próprios se necessário.",
                                    "Calcule resíduos A_i = lim (s - p_i) Y(s) para pólos simples.",
                                    "Para pólos múltiplos, use fórmula geral de resíduos.",
                                    "Some os termos e verifique igualando a Y(s) original.",
                                    "Identifique termo estacionário (parte 1/s ou constante)."
                                  ],
                                  "verification": "Soma das frações parciais reconstrói Y(s) exatamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela de resíduos, software de álgebra computacional.",
                                  "tips": "Comece com pólos dominantes; use Heaviside para múltiplos.",
                                  "learningObjective": "Dominar decomposição para inversa de Laplace.",
                                  "commonMistakes": "Erro no cálculo de resíduos; esquecer pólos complexos conjugados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar inversa de Laplace e separar componentes transitórios e estacionários",
                                  "subSteps": [
                                    "Inverta cada fração parcial: L^{-1}{A/(s-p)} = A e^{p t}.",
                                    "Escreva y(t) = soma transitórios + y_estacionario (lim t->inf).",
                                    "Identifique transitórios: termos com Re(p) < 0 que decaem.",
                                    "Estacionário: ganho DC * 1 (para degrau unitário).",
                                    "Plote ou descreva comportamento qualitativo."
                                  ],
                                  "verification": "y(t) é contínua em t=0+, lim t->inf correto, e matches simulação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de Laplace inversa, MATLAB/Simulink para plot.",
                                  "tips": "Use pares conjugados para senos/cossenos reais.",
                                  "learningObjective": "Interpretar resposta temporal e classificar componentes.",
                                  "commonMistakes": "Inverter incorretamente exponenciais complexas; confundir transitório com estacionário."
                                }
                              ],
                              "practicalExample": "Para H(s) = 1/(s+2)(s+1), Y(s) = 1/[s(s+1)(s+2)]. Frações: 1/2 * 1/s - 1/(s+1) + 1/2 * 1/(s+2). y(t) = 0.5 (1 - e^{-t} + e^{-2t}), transitório: -e^{-t} + e^{-2t}, estacionário: 0.5.",
                              "finalVerifications": [
                                "Y(s) = H(s)/s está correto.",
                                "Decomposição em frações parciais reconstrói Y(s).",
                                "y(t) satisfaz y(0+) = 0 e lim t->∞ y(t) = H(0).",
                                "Termos transitórios decaem para zero.",
                                "Gráfico de y(t) mostra overshoot/subida sem erros.",
                                "Identificação correta de pólos dominantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica em Y(s) e frações parciais (90%+ correto).",
                                "Correta inversa de Laplace com manipulação de conjugados.",
                                "Identificação explícita de transitório vs. estacionário.",
                                "Interpretação qualitativa do comportamento dinâmico.",
                                "Tempo de acomodação estimado corretamente.",
                                "Uso apropriado de ferramentas sem dependência excessiva."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e álgebra linear (autovalores).",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor equivalentes.",
                                "Controle Automático: Projeto de controladores baseados em resposta ao degrau.",
                                "Programação: Simulação em Python/MATLAB de respostas.",
                                "Engenharia Mecânica: Vibrações em estruturas aeronáuticas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, determinar a resposta transitória de um sistema de controle de voo (ex: elevador) a um comando de degrau unitário no ângulo de ataque, prevendo overshoot e tempo de estabilização para evitar instabilidades durante manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Resposta em Frequência",
                        "description": "Função H(jω) obtida substituindo s = jω em H(s), descreve ganho de magnitude |H(jω)| e fase ∠H(jω) para entradas sinusoidais estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Calcular H(jω) a partir de H(s)",
                            "description": "Substituir s = jω na função de transferência racional H(s) para obter expressão complexa H(jω), simplificando termos reais e imaginários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar a função de transferência H(s)",
                                  "subSteps": [
                                    "Escreva a função de transferência H(s) no formato racional padrão: H(s) = N(s)/D(s), onde N(s) é o numerador e D(s) o denominador.",
                                    "Identifique os polinômios N(s) e D(s), listando coeficientes reais.",
                                    "Verifique se H(s) está em forma própria (sem fatores comuns canceláveis).",
                                    "Anote o grau dos polinômios para prever complexidade da substituição.",
                                    "Confirme que todos os termos são polinômios em s com coeficientes reais."
                                  ],
                                  "verification": "H(s) está escrita corretamente e analisada, sem erros de transcrição.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função H(s) dada",
                                    "Papel e caneta ou software simbólico como MATLAB/SymPy"
                                  ],
                                  "tips": "Sempre reduza frações antes de substituir para evitar simplificações desnecessárias depois.",
                                  "learningObjective": "Compreender a estrutura de H(s) para facilitar a substituição.",
                                  "commonMistakes": [
                                    "Esquecer de cancelar fatores comuns em N(s)/D(s)",
                                    "Confundir numerador com denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir s por jω em H(s)",
                                  "subSteps": [
                                    "Substitua s = jω em cada termo do numerador N(jω).",
                                    "Substitua s = jω em cada termo do denominador D(jω).",
                                    "Escreva H(jω) = N(jω)/D(jω) com potências de j explicitadas (j^1 = j, j^2 = -1, etc.).",
                                    "Mantenha ω como variável simbólica.",
                                    "Evite simplificar ainda; foque na substituição pura."
                                  ],
                                  "verification": "Todos os s foram substituídos por jω, e potências de j estão corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "H(s) preparada",
                                    "Tabela de potências de j (j^0=1, j^1=j, j^2=-1, j^3=-j, j^4=1)"
                                  ],
                                  "tips": "Use a identidade (jω)^n = j^n * ω^n e reduza j^n ciclicamente.",
                                  "learningObjective": "Dominar a substituição simbólica preservando a forma complexa.",
                                  "commonMistakes": [
                                    "Tratar jω como real",
                                    "Erros em potências de j (ex: j^3 = j ao invés de -j)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir e simplificar a expressão algébrica",
                                  "subSteps": [
                                    "Expanda N(jω) multiplicando termos binomialmente, agrupando reais e imaginários.",
                                    "Expanda D(jω) da mesma forma.",
                                    "Simplifique fração H(jω) = N(jω)/D(jω) multiplicando numerador e denominador pelo conjugado de D(jω) se necessário.",
                                    "Colete termos semelhantes em num e den.",
                                    "Reduza usando j^2 = -1 repetidamente."
                                  ],
                                  "verification": "Expressão expandida sem termos não simplificados e denominador real (se possível).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica opcional",
                                    "Folha para expansões"
                                  ],
                                  "tips": "Para denominadores complexos, multiplique por conj(D(jω)) para realificar.",
                                  "learningObjective": "Aplicar álgebra complexa para obter forma simplificada.",
                                  "commonMistakes": [
                                    "Não realificar denominador",
                                    "Erros em distribuições binomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Separar em partes real e imaginária e verificar",
                                  "subSteps": [
                                    "Escreva H(jω) = Re{H(jω)} + j * Im{H(jω)}, identificando coeficientes.",
                                    "Confirme que todos os coeficientes são funções reais de ω.",
                                    "Substitua valores numéricos específicos de ω para validar.",
                                    "Compare com ferramentas como MATLAB (tf2fr ou freqs).",
                                    "Documente a expressão final."
                                  ],
                                  "verification": "H(jω) em forma retangular correta e verificada numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de verificação (MATLAB/Python)",
                                    "Valores teste de ω"
                                  ],
                                  "tips": "Teste com ω=0 e ω→∞ para checar limites conhecidos.",
                                  "learningObjective": "Expressar e validar H(jω) na forma complexa padrão.",
                                  "commonMistakes": [
                                    "Misturar partes real/imaginária",
                                    "Ignorar verificação numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada H(s) = 1 / (s + 1), substitua s = jω: H(jω) = 1 / (jω + 1). Multiplique num/den por conjugado (1 - jω): H(jω) = (1 - jω) / (1 + ω²) = 1/(1+ω²) - j ω/(1+ω²).",
                              "finalVerifications": [
                                "H(jω) está em forma complexa com partes real e imaginária separadas.",
                                "Denominador é real e positivo.",
                                "Limites ω→0 e ω→∞ coincidem com ganho DC e atenuação alta frequência.",
                                "Verificação numérica com pelo menos 3 valores de ω bate com software.",
                                "Nenhum termo j não agrupado resta.",
                                "Expressão simplificada sem frações desnecessárias."
                              ],
                              "assessmentCriteria": [
                                "Correção na substituição s → jω (100%).",
                                "Simplificação algébrica precisa (incluindo realificação).",
                                "Separação clara em Re + j Im.",
                                "Verificações numéricas e limite incluídas.",
                                "Eficiência: sem passos redundantes ou erros comuns.",
                                "Clareza na apresentação da expressão final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e manipulação de números imaginários.",
                                "Física: Análise de sinais harmônicos em sistemas oscilantes.",
                                "Engenharia de Controle: Projeto de filtros e estabilidade em malha fechada.",
                                "Computação: Uso de ferramentas simbólicas como SymPy ou MATLAB para automação.",
                                "Estatística: Interpretação de espectros de potência via |H(jω)|²."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular H(jω) permite analisar a resposta em frequência de sistemas de controle de voo, como estabilizadores automáticos, para garantir estabilidade e desempenho sob excitações sinusoidais (ex: turbulência), evitando ressonâncias perigosas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Determinar magnitude e fase da resposta em frequência",
                            "description": "Calcular |H(jω)| = √[Re² + Im²] e ∠H(jω) = atan2(Im, Re), plotando curvas de Bode para análise qualitativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Função de Transferência e Resposta em Frequência",
                                  "subSteps": [
                                    "Defina função de transferência H(s) e substitua s = jω para obter H(jω).",
                                    "Identifique parte real (Re) e imaginária (Im) de H(jω).",
                                    "Explique magnitude |H(jω)| como √(Re² + Im²) e fase ∠H(jω) como atan2(Im, Re).",
                                    "Discuta importância das curvas de Bode para análise qualitativa.",
                                    "Resolva um exemplo simples manualmente."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo e resolva H(jω) para ω=1 rad/s em um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas, caderno de anotações.",
                                  "tips": "Use diagramas de fasores para visualizar Re e Im.",
                                  "learningObjective": "Compreender a base matemática da resposta em frequência.",
                                  "commonMistakes": "Confundir H(s) com H(jω); ignorar o sinal da fase com atan2."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Parte Real e Imaginária de H(jω)",
                                  "subSteps": [
                                    "Escreva H(s) para um sistema dado (ex: H(s) = 1/(s+1)).",
                                    "Substitua s = jω e expanda em termos de Re e Im.",
                                    "Calcule Re e Im para múltiplos valores de ω (ex: 0.1, 1, 10 rad/s).",
                                    "Verifique cálculos com uma calculadora ou software simbólico.",
                                    "Tabule os resultados em uma tabela."
                                  ],
                                  "verification": "Tabela completa com Re e Im corretos para 5 valores de ω.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou MATLAB para tabulação.",
                                  "tips": "Para polos reais, Re = num_real / (den_real² + ω²), Im similar.",
                                  "learningObjective": "Dominar o cálculo algébrico de componentes complexas.",
                                  "commonMistakes": "Erros em expansão binomial; esquecer de racionalizar denominador."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Magnitude e Fase",
                                  "subSteps": [
                                    "Aplique fórmula |H(jω)| = √(Re² + Im²) para cada ω.",
                                    "Calcule ∠H(jω) = atan2(Im, Re) em graus ou radianos.",
                                    "Exponencie magnitude em dB: 20*log10(|H|).",
                                    "Fase em graus para curvas de Bode.",
                                    "Crie tabelas de magnitude (dB) e fase vs. log(ω)."
                                  ],
                                  "verification": "Tabelas de magnitude e fase coincidem com valores teóricos conhecidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software como MATLAB, Python (NumPy) ou calculadora.",
                                  "tips": "Use log scale para ω desde o início para Bode.",
                                  "learningObjective": "Aplicar fórmulas exatas de magnitude e fase.",
                                  "commonMistakes": "Usar atan em vez de atan2 (perde quadrantes); esquecer dB."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e Analisar Curvas de Bode",
                                  "subSteps": [
                                    "Plote magnitude em dB vs. log10(ω).",
                                    "Plote fase vs. log10(ω).",
                                    "Identifique pontos de corte (-3dB), inclinações (20dB/década).",
                                    "Compare com aproximações assintóticas.",
                                    "Interprete: largura de banda, atenuação, estabilidade."
                                  ],
                                  "verification": "Gráficos plotados com legendas e análise escrita de 3 características chave.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB, Python (Matplotlib), ou papel milimetrado.",
                                  "tips": "Comece com assintotas retas para verificação rápida.",
                                  "learningObjective": "Gerar e interpretar visualmente respostas em frequência.",
                                  "commonMistakes": "Escala errada (linear vs log); ignorar continuidade na fase."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar Análise Qualitativa",
                                  "subSteps": [
                                    "Descreva comportamento em baixas/altas frequências.",
                                    "Identifique ressonâncias ou picos.",
                                    "Discuta implicações para sistemas dinâmicos (ex: controle).",
                                    "Compare com resposta no tempo.",
                                    "Resolva problema de design simples baseado na Bode."
                                  ],
                                  "verification": "Relatório de 1 página com análise qualitativa e conclusões.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplos de problemas de aeronáutica.",
                                  "tips": "Pense em termos de 'roll-off' para filtros.",
                                  "learningObjective": "Extrair insights qualitativos de gráficos de Bode.",
                                  "commonMistakes": "Superestimar largura de banda; ignorar fase para estabilidade."
                                }
                              ],
                              "practicalExample": "Para H(s) = 10 / (s + 2), calcule H(jω) para ω = 0.1, 1, 10 rad/s. Obtenha |H(j0.1)| ≈ 4.88 (-6.26 dB), ∠ ≈ -2.86°; plote Bode mostrando corte em ω=2 rad/s e queda de 20 dB/década.",
                              "finalVerifications": [
                                "Cálculos de |H(jω)| e ∠H(jω) precisos dentro de 1% para 5 frequências.",
                                "Curvas de Bode plotadas corretamente com escalas log e dB.",
                                "Identificação precisa de frequência de corte e inclinação.",
                                "Análise qualitativa explica 3 comportamentos chave.",
                                "Gráficos coincidem com simulação em software.",
                                "Relatório resume aplicações em sistemas aeronáuticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (90% correto).",
                                "Qualidade e legibilidade dos gráficos de Bode.",
                                "Profundidade da análise qualitativa.",
                                "Correta interpretação de magnitude e fase.",
                                "Uso adequado de ferramentas e unidades (dB, graus).",
                                "Conexão com contexto de engenharia aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Números complexos e funções trigonométricas.",
                                "Física: Oscilações e dinâmica de sistemas.",
                                "Programação: Scripts em MATLAB/Python para automação de plots.",
                                "Controle Automático: Estabilidade via Margem de Fase/Ganho."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, usado para analisar estabilidade de sistemas de controle de voo, como flaps ou autothrottle, garantindo resposta adequada a perturbações em frequência (ex: turbulência) sem oscilações indesejadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Calcular resposta estacionária a sinal senoidal",
                            "description": "Para entrada u(t) = A cos(ωt + φ), obter y_est(t) = A |H(jω)| cos(ωt + φ + ∠H(jω)), verificando regime permanente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a entrada senoidal e avaliar a função de transferência em jω",
                                  "subSteps": [
                                    "Escreva a entrada u(t) = A cos(ωt + φ) em forma fasorial: Ũ(jω) = A e^{jφ}.",
                                    "Obtenha a função de transferência H(s) do sistema dado.",
                                    "Substitua s = jω na H(s) para obter H(jω), simplificando o numerador e denominador.",
                                    "Expresse H(jω) na forma retangular: H(jω) = |H(jω)| e^{j∠H(jω)} ou real + j*imag.",
                                    "Verifique se ω está dentro da faixa de validade do modelo linear."
                                  ],
                                  "verification": "H(jω) calculado corretamente em forma complexa, comparando com solução analítica ou software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função de transferência H(s)",
                                    "Calculadora científica ou MATLAB/SymPy",
                                    "Papel e lápis para cálculos manuais"
                                  ],
                                  "tips": "Sempre normalize ângulos de fase entre -π e π para evitar ambiguidades.",
                                  "learningObjective": "Dominar a representação fasorial de sinais senoidais e avaliação em frequência jω.",
                                  "commonMistakes": [
                                    "Esquecer o expoente jω ao substituir s",
                                    "Confundir a entrada cos com sin sem ajuste de fase",
                                    "Não simplificar frações complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a magnitude |H(jω)| e a fase ∠H(jω)",
                                  "subSteps": [
                                    "Calcule a parte real e imaginária de H(jω).",
                                    "Compute a magnitude: |H(jω)| = √(Re² + Im²).",
                                    "Calcule a fase: ∠H(jω) = atan2(Im, Re), convertendo para graus ou radianos consistentes.",
                                    "Verifique a unidade da magnitude (ganho em dB se aplicável).",
                                    "Registre valores numéricos com precisão de pelo menos 3 casas decimais."
                                  ],
                                  "verification": "Valores de |H(jω)| e ∠H(jω) coincidem com plot de Bode ou cálculo verificado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de funções trigonométricas",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Use a função atan2 para fase correta no quadrante apropriado.",
                                  "learningObjective": "Aplicar operações com números complexos para extrair magnitude e fase.",
                                  "commonMistakes": [
                                    "Usar atan em vez de atan2, levando a fase errada",
                                    "Esquecer raiz quadrada na magnitude",
                                    "Confundir radianos com graus"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a resposta estacionária y_est(t)",
                                  "subSteps": [
                                    "Escreva y_est(t) = A |H(jω)| cos(ωt + φ + ∠H(jω)).",
                                    "Expanda o argumento do cosseno se necessário para forma explícita.",
                                    "Converta para forma senoidal alternativa se o problema exigir (sen vs cos).",
                                    "Simplifique expressões trigonométricas usando identidades.",
                                    "Compare com a entrada para identificar ganho e defasagem."
                                  ],
                                  "verification": "y_est(t) produz o mesmo fasor Ŷ(jω) = H(jω) Ũ(jω) ao converter de volta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Identidades trigonométricas",
                                    "Calculadora para expansão cos(a+b)"
                                  ],
                                  "tips": "Mantenha φ e ∠H na mesma unidade (radianos ou graus).",
                                  "learningObjective": "Sintetizar a saída estacionária a partir de ganho e fase.",
                                  "commonMistakes": [
                                    "Erro no sinal da fase (soma em vez de + ∠H)",
                                    "Esquecer o fator A |H|",
                                    "Não ajustar fase total corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o regime permanente e validar a solução",
                                  "subSteps": [
                                    "Confirme que os transientes decrescem (polos com parte real negativa).",
                                    "Simule numericamente u(t) e y(t) para t grande e compare com y_est(t).",
                                    "Calcule erro entre y(t) total e y_est(t) para t → ∞.",
                                    "Verifique dimensionalidade (unidades de y compatíveis).",
                                    "Teste com valores limite (ω→0 ou ω→∞)."
                                  ],
                                  "verification": "Erro de convergência < 1% em simulação para t > 5/|Re(polo dominante)|.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink ou Python SciPy)",
                                    "Gráficos de resposta no tempo"
                                  ],
                                  "tips": "Use zoom em t grande para visualizar regime estacionário.",
                                  "learningObjective": "Distinguir resposta transitória de estacionária em sistemas lineares.",
                                  "commonMistakes": [
                                    "Ignorar instabilidade (polos no semiplano direito)",
                                    "Não simular para confirmar",
                                    "Confundir regime forçado com total"
                                  ]
                                }
                              ],
                              "practicalExample": "Para H(s) = 1/(s + 1), u(t) = cos(2t), calcule y_est(t). H(j2) = 1/(1 + j2) = (1 - j2)/5, |H| = √5/5 ≈ 0.447, ∠H ≈ -63.43°. Assim, y_est(t) ≈ 0.447 cos(2t - 63.43°). Simule em MATLAB para verificar convergência.",
                              "finalVerifications": [
                                "H(jω) calculado corretamente em forma complexa.",
                                "Magnitude e fase extraídas com precisão numérica.",
                                "Forma de y_est(t) idêntica à fórmula padrão.",
                                "Simulação confirma regime estacionário.",
                                "Fase total ajustada corretamente.",
                                "Valores limite consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos complexos (erro < 0.1%).",
                                "Correta identificação de magnitude e fase.",
                                "Expressão final de y_est(t) simplificada e correta.",
                                "Validação via simulação ou gráfico.",
                                "Explicação clara do regime permanente.",
                                "Uso apropriado de unidades e notação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções trigonométricas.",
                                "Física: Oscilações harmônicas e vibrações mecânicas.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Controle de Sistemas: Diagramas de Bode e estabilidade.",
                                "Engenharia Mecânica: Análise de frequências ressonantes."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, calcular a resposta estacionária de uma asa a vibrações senoidais (ex.: turbulência), prevendo deflexões para evitar fadiga estrutural e otimizar controle de flutter."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Soluções Completas de Modelos Dinâmicos",
                        "description": "Integração de função de transferência e resposta em frequência para obter respostas transitórias totais e partes estacionárias em modelos lineares contínuos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Usar convolução para resposta transitória geral",
                            "description": "Calcular y(t) = ∫ h(τ) u(t-τ) dτ usando h(t) de H(s), ou equivalentemente Y(s) = H(s) U(s) no domínio s para entradas arbitrárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a resposta ao impulso h(t) a partir da função de transferência H(s)",
                                  "subSteps": [
                                    "Identifique a função de transferência H(s) do sistema dinâmico.",
                                    "Aplique a transformada de Laplace inversa para obter h(t) = L^{-1}{H(s)}.",
                                    "Verifique se h(t) satisfaz propriedades como causalidade (h(t)=0 para t<0) e soma finita para estabilidade.",
                                    "Plote h(t) para visualização intuitiva da resposta ao impulso.",
                                    "Anote quaisquer singularidades ou decomposições parciais usadas."
                                  ],
                                  "verification": "Confirme que h(t) é a derivada da resposta degrau e que ∫ h(t) dt = ganho DC está correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela de transformadas de Laplace, software como MATLAB/SymPy para inversa Laplace, papel e lápis.",
                                  "tips": "Use decomposição em frações parciais para H(s) de ordem superior para simplificar a inversa.",
                                  "learningObjective": "Dominar a obtenção da resposta ao impulso no domínio do tempo a partir de H(s).",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/(2πi) na inversa Laplace complexa.",
                                    "Ignorar pólos no semiplano direito indicando instabilidade.",
                                    "Não normalizar h(t) corretamente para unidades de tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e compreender a integral de convolução y(t) = ∫ h(τ) u(t-τ) dτ",
                                  "subSteps": [
                                    "Defina a entrada u(t) e expresse U(s) = L{u(t)} para referência futura.",
                                    "Escreva a fórmula de convolução explicitamente: y(t) = ∫_0^t h(τ) u(t-τ) dτ (para sistemas causais).",
                                    "Identifique simetrias ou propriedades (ex: convolução com degrau dá integral de h(t)).",
                                    "Discuta mudança de variável σ = t - τ para alternar limites de integração.",
                                    "Pratique com entradas simples como degrau ou impulso para validar."
                                  ],
                                  "verification": "Teste com u(t)=δ(t), onde y(t)=h(t), e u(t)=1 (degrau), onde y(t)=∫_0^t h(τ)dτ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de propriedades de convolução, calculadora gráfica.",
                                  "tips": "Lembre-se que convolução é comutativa: ∫ h(τ)u(t-τ)dτ = ∫ u(τ)h(t-τ)dτ.",
                                  "learningObjective": "Entender a interpretação física da convolução como sobreposição de respostas ao impulso.",
                                  "commonMistakes": [
                                    "Integrar de -∞ a ∞ em vez de 0 a t para causalidade.",
                                    "Confundir u(t-τ) com u(τ-t).",
                                    "Esquecer o sinal de Dirac para auto-convolução."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a resposta transitória usando convolução no domínio do tempo",
                                  "subSteps": [
                                    "Substitua h(τ) e u(t-τ) na integral e simplifique analiticamente se possível.",
                                    "Para entradas polinomiais ou exponenciais, use integração por partes ou tabelas.",
                                    "Resolva a integral indefinida e aplique limites de 0 a t.",
                                    "Simplifique a expressão final para y(t), coletando termos.",
                                    "Numere ou simule numericamente para validação (ex: trapezoidal rule)."
                                  ],
                                  "verification": "Diferencie y(t) para obter y'(t) = h(t)*u'(t) + h(0)u(t) e verifique consistência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (Mathematica/MATLAB Symbolic), tabela de integrais.",
                                  "tips": "Para sistemas lineares, divida em componentes exponenciais e convolvaseparadamente.",
                                  "learningObjective": "Executar cálculos de convolução para entradas arbitrárias.",
                                  "commonMistakes": [
                                    "Erros em limites de integração ao trocar variáveis.",
                                    "Não lidar com funções descontínuas em u(t).",
                                    "Omitir termos de inicialização zero."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar usando o método do domínio s: Y(s) = H(s) U(s)",
                                  "subSteps": [
                                    "Calcule U(s) = L{u(t)} usando tabelas ou propriedades.",
                                    "Multiplique Y(s) = H(s) U(s) e simplifique.",
                                    "Aplique inversa Laplace L^{-1}{Y(s)} para obter y(t).",
                                    "Compare as expressões de y(t) dos dois métodos.",
                                    "Analise erros numéricos se aplicável e discuta equivalência."
                                  ],
                                  "verification": "As duas y(t) devem coincidir; plote ambas para t>0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de Laplace (SymPy, MATLAB), plotter gráfico.",
                                  "tips": "O método s é mais rápido para entradas com L conhecidos; use para checagem.",
                                  "learningObjective": "Aplicar teorema da convolução e validar resultados multi-método.",
                                  "commonMistakes": [
                                    "Pólos cancelados incorretamente em Y(s).",
                                    "Inversa Laplace errada por resíduos.",
                                    "Ignorar condições iniciais não-zero."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema aerodinâmico simples modelado por H(s) = 1/(s + 2) (estabilizador de atitude). Para entrada de distúrbio u(t) = t e^{-t} u(t) (rampa exponencial simulando vento), calcule y(t) via convolução: h(t) = e^{-2t} u(t), y(t) = ∫_0^t e^{-2τ} (t-τ) e^{-(t-τ)} dτ = e^{-t} t - (1 - e^{-2t})/4 + (e^{-t} - e^{-2t})/4, verificado com Y(s) = H(s) U(s) = 1/((s+1)(s+2)(s+1)) via parcial.",
                              "finalVerifications": [
                                "y(t) → 0 quando t → ∞ para sistemas estáveis.",
                                "y(0+) = 0 para condições iniciais zero.",
                                "Derivada y'(0+) = h(0) u(0) bate com valor inicial.",
                                "Energia total ∫ y^2(t) dt finita para bounded input.",
                                "Match exato entre métodos tempo e s-domínio.",
                                "Plota de y(t) mostra transitório correto sem overshoot inesperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica da integral de convolução (erro <1%).",
                                "Correta derivação de h(t) via inversa Laplace.",
                                "Equivalência comprovada entre domínios tempo e s.",
                                "Interpretação física da resposta transitória.",
                                "Eficiência computacional e simplificação da expressão final.",
                                "Tratamento correto de causalidade e limites."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas integrais e análise complexa.",
                                "Programação: Implementação numérica em MATLAB/Python (conv/sym).",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Controle Automático: Análise de estabilidade e desempenho transitório.",
                                "Engenharia de Software: Simulação de sistemas em Simulink."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, usado para prever respostas transitórias de aeronaves a distúrbios como rajadas de vento ou comandos de piloto, permitindo design de controladores robustos em simuladores de voo como no F-16 ou drones UAV, otimizando estabilidade e manobrabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.4",
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Combinar respostas transitória e estacionária",
                            "description": "Para entradas como degrau + harmônica, somar y_trans(t) (decai) e y_est(t) (permanente) obtidas via H(s) e H(jω) respectivamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e decompor os componentes da entrada",
                                  "subSteps": [
                                    "Analise a entrada u(t), identificando a parte transitória (ex: degrau) e a parte estacionária (ex: harmônica).",
                                    "Escreva u(t) = u_trans(t) + u_est(t), onde u_trans(t) é o degrau e u_est(t) é a harmônica sin(ωt).",
                                    "Confirme os parâmetros: amplitude do degrau, frequência ω e amplitude da harmônica.",
                                    "Verifique se o sistema é linear e invariante no tempo (LTI) para superposição.",
                                    "Anote H(s) e H(jω) do sistema."
                                  ],
                                  "verification": "Entrada decomposta corretamente em equação matemática com componentes identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, função de transferência H(s), software de plotagem (opcional como MATLAB).",
                                  "tips": "Sempre normalize a entrada para facilitar cálculos; use Heaviside para degrau.",
                                  "learningObjective": "Compreender a decomposição de entradas complexas em componentes superponíveis.",
                                  "commonMistakes": "Confundir harmônica com transitória; ignorar fase da harmônica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a resposta transitória y_trans(t)",
                                  "subSteps": [
                                    "Aplique transformada de Laplace à u_trans(t) para obter U_trans(s).",
                                    "Multiplique por H(s): Y_trans(s) = H(s) U_trans(s).",
                                    "Faça inversa de Laplace para obter y_trans(t), focando nos termos que decaem (pólos de H(s)).",
                                    "Ignore termos estacionários nesta etapa.",
                                    "Plote y_trans(t) para visualizar decaimento."
                                  ],
                                  "verification": "y_trans(t) contém apenas termos transitórios decaindo para zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabelas de Laplace, calculadora simbólica (Mathematica/MATLAB), papel.",
                                  "tips": "Use resíduos ou expansão em frações parciais para inversa rápida.",
                                  "learningObjective": "Dominar cálculo de respostas transitórias via domínio s.",
                                  "commonMistakes": "Incluir pólos em jω como transitórios; erro em inversa de Laplace."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a resposta estacionária y_est(t)",
                                  "subSteps": [
                                    "Calcule H(jω) = |H(jω)| e ∠H(jω) para a frequência da harmônica.",
                                    "y_est(t) = |H(jω)| A sin(ωt + ∠H(jω)), onde A é amplitude da entrada.",
                                    "Confirme que y_est(t) é periódica e não decai.",
                                    "Some se houver componente DC da entrada (ganho em DC).",
                                    "Plote y_est(t) isoladamente."
                                  ],
                                  "verification": "y_est(t) é senoidal com amplitude e fase corretas via H(jω).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, diagrama de Bode (opcional), software de simulação.",
                                  "tips": "Use magnitude e fase diretamente de H(jω) para evitar Laplace desnecessário.",
                                  "learningObjective": "Aplicar análise em frequência para respostas estacionárias.",
                                  "commonMistakes": "Usar H(s) em vez de H(jω); esquecer deslocamento de fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar respostas e validar a solução completa",
                                  "subSteps": [
                                    "Some y(t) = y_trans(t) + y_est(t).",
                                    "Verifique limite t→∞: y(t) → y_est(t).",
                                    "Simule numericamente em software para confirmação.",
                                    "Plote y(t) completa e compare com simulação.",
                                    "Analise estabilidade: pólos de H(s) no semiplano esquerdo."
                                  ],
                                  "verification": "Gráfico de y(t) mostra decaimento inicial seguido de oscilação estacionária.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "MATLAB/Simulink ou Python (SciPy), gráficos.",
                                  "tips": "Use superposição apenas para sistemas LTI; valide com simulação.",
                                  "learningObjective": "Integrar respostas parciais em solução completa via superposição.",
                                  "commonMistakes": "Soma incorreta de fases; não verificar limite assintótico."
                                }
                              ],
                              "practicalExample": "Para H(s) = 1/(s+1), u(t) = 1(t) + sin(2t). y_trans(t) = e^{-t}, y_est(t) = (1/√5) sin(2t - φ) onde φ=atan(2). y(t) = e^{-t} + (1/√5) sin(2t - φ). Simule em MATLAB para ver transição.",
                              "finalVerifications": [
                                "y(t→∞) converge para y_est(t).",
                                "Amplitude e fase de y_est(t) coincidem com H(jω).",
                                "Simulação numérica matches analítica.",
                                "Gráfico mostra decaimento transitório correto.",
                                "Solução é estável (pólos Re<0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição da entrada (100%).",
                                "Cálculo correto de y_trans(t) via Laplace (90%+).",
                                "y_est(t) com magnitude/fase exatas de H(jω) (95%+).",
                                "Soma superposta sem erros aritméticos.",
                                "Validação via plot/simulação incluída.",
                                "Explicação clara do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e Fourier.",
                                "Física: Oscilações forçadas em sistemas mecânicos.",
                                "Programação: Simulação em MATLAB/Python para validação.",
                                "Controle: Análise de estabilidade em malhas de feedback."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, combina resposta transitória (manobra inicial de degrau no manche) com estacionária (turbulência harmônica), essencial para projetar sistemas de controle de voo estáveis em aeronaves como o F-35, prevendo oscilações residuais pós-manobra."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1",
                              "10.1.3.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Aplicar em modelos físicos (mecânico, térmico)",
                            "description": "Derivar H(s) de modelo como mẍ + bẋ + kx = f(t), calcular respostas transitória/estacionária para validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o modelo físico no domínio do tempo",
                                  "subSteps": [
                                    "Identifique o sistema físico (ex: mecânico como massa-mola-amortecedor ou térmico como RC equivalente).",
                                    "Defina as variáveis de estado (posição x, velocidade ẋ) e parâmetros (m, b, k).",
                                    "Escreva a equação diferencial ordinária (EDO) no formato mẍ + bẋ + kx = f(t).",
                                    "Verifique unidades e consistência física dos parâmetros.",
                                    "Desenhe o diagrama esquemático do sistema."
                                  ],
                                  "verification": "A EDO está corretamente escrita e balanceada em termos dimensionais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de dinâmica (ex: Ogata)",
                                    "Software de desenho (opcional)"
                                  ],
                                  "tips": "Sempre considere condições iniciais zero para simplificação inicial.",
                                  "learningObjective": "Entender a representação matemática de sistemas físicos lineares invariantes no tempo.",
                                  "commonMistakes": "Confundir coeficientes (ex: inverter b e k), ignorar forças de amortecimento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de transferência H(s)",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace bilateral à EDO, assumindo condições iniciais zero.",
                                    "Obtenha as expressões em domínio s: Ms²X(s) + BsX(s) + KX(s) = F(s).",
                                    "Divida por X(s) para isolar H(s) = F(s)/X(s) = 1/(Ms² + Bs + K).",
                                    "Simplifique para forma padrão (ex: ω_n, ζ).",
                                    "Verifique o grau do numerador e denominador."
                                  ],
                                  "verification": "H(s) é uma fração própria com polo no denominador e ganho no numerador.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica/MATLAB)",
                                    "Tabelas de Laplace"
                                  ],
                                  "tips": "Use condições iniciais zero para evitar termos adicionais inicialmente.",
                                  "learningObjective": "Dominar a transformação de modelos diferenciais para funções de transferência.",
                                  "commonMistakes": "Esquecer de dividir corretamente por X(s), erros em transformadas de derivadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a resposta transitória",
                                  "subSteps": [
                                    "Escolha uma entrada de teste (ex: degrau unitário u(t) → U(s)=1/s).",
                                    "Multiplique Y(s) = H(s) * U(s) e realize decomposição em frações parciais.",
                                    "Identifique polos e resíduos para inversa de Laplace.",
                                    "Calcule y(t) transitória somando exponenciais dos polos.",
                                    "Plote y(t) vs tempo para visualização."
                                  ],
                                  "verification": "A resposta y(t) converge e exibe overshoot/damping conforme ζ.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Para sistemas de 2ª ordem, use fórmulas padrão de resposta ao degrau.",
                                  "learningObjective": "Analisar o comportamento dinâmico inicial via polos do sistema.",
                                  "commonMistakes": "Erros em decomposição parcial, ignorar polos complexos conjugados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular resposta estacionária e validar o modelo",
                                  "subSteps": [
                                    "Use teorema do valor final: lim t→∞ y(t) = lim s→0 s Y(s).",
                                    "Para entradas senoidais, calcule ganho e fase em ω específica.",
                                    "Compare com simulação numérica ou dados experimentais.",
                                    "Calcule erros (ex: RMSE) entre analítico e simulado.",
                                    "Ajuste parâmetros se necessário para calibração."
                                  ],
                                  "verification": "Resposta estacionária matches com expectativa física (ex: posição final = f/k).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB ode45)",
                                    "Dados experimentais fictícios ou reais"
                                  ],
                                  "tips": "Valide com múltiplas entradas (degrau, rampa) para robustez.",
                                  "learningObjective": "Validar modelos teóricos contra comportamento de regime permanente.",
                                  "commonMistakes": "Aplicar teorema do valor final incorretamente, não considerar estabilidade."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave, modele o flutter como sistema mecânico mẍ + 10ẋ + 100x = f_aero(t), onde f_aero é força aerodinâmica. Derive H(s) = 1/(m s² + 10 s + 100), calcule resposta transitória a degrau (simulando rajada de vento) e valide estacionária com testes de túnel de vento.",
                              "finalVerifications": [
                                "Derivação correta de H(s) a partir da EDO física.",
                                "Resposta transitória y(t) calculada e plotada com overshoot <20% para ζ=0.7.",
                                "Resposta estacionária matches lim s→0 s H(s) U(s).",
                                "Validação numérica com erro <5%.",
                                "Interpretação física dos polos (ex: frequência natural).",
                                "Diagrama de blocos do sistema montado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de Laplace e inversa (90% correto).",
                                "Qualidade da interpretação física das respostas.",
                                "Uso adequado de ferramentas computacionais para validação.",
                                "Identificação e correção de erros comuns.",
                                "Apresentação clara de gráficos e conclusões.",
                                "Conexão com aplicação aeronáutica real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e álgebra de polos/resíduos.",
                                "Programação: Simulações em MATLAB/Python para ODEs.",
                                "Física: Princípios de dinâmica newtoniana e termodinâmica.",
                                "Engenharia de Controle: Diagramas de blocos e estabilidade."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, validação de modelos dinâmicos para controle de flaps ou amortecimento de vibrações em fuselagem, prevendo respostas a turbulências e otimizando estabilidade em voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Diagrama de Blocos e Linearização de Modelos",
                "description": "Aborda representação por diagramas de blocos e técnicas de linearização de modelos não-lineares.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Representação por Diagrama de Blocos",
                    "description": "Elementos básicos como somadores, integradores, ganhos e blocos funcionais para modelar sistemas dinâmicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Somadores",
                        "description": "Elementos gráficos em diagramas de blocos usados para realizar a soma ou subtração algébrica de múltiplos sinais de entrada, produzindo uma única saída que representa a combinação linear dos sinais incidentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Reconhecer o símbolo do somador",
                            "description": "Identificar o símbolo padrão do somador como um círculo pequeno com várias entradas (setas apontando para o círculo) e uma saída (seta saindo do círculo), conforme convenções em engenharia de controle como descrito em Ogata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o contexto dos diagramas de blocos em sistemas dinâmicos",
                                  "subSteps": [
                                    "Revise o conceito básico de diagrama de blocos como representação gráfica de sistemas de controle.",
                                    "Identifique os elementos comuns: blocos (funções de transferência), somadores, integradores e take-off points.",
                                    "Leia a seção relevante do livro de Ogata sobre convenções em engenharia de controle.",
                                    "Anote as funções principais de cada elemento em um diagrama de blocos.",
                                    "Desenhe um diagrama de blocos vazio e label os espaços para somadores."
                                  ],
                                  "verification": "Você pode listar e descrever pelo menos três elementos comuns em diagramas de blocos, incluindo sua função.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro 'Engenharia de Controle Moderno' de Katsuhiko Ogata (capítulo sobre diagramas de blocos)",
                                    "Papel e caneta para anotações",
                                    "Acesso a imagens de diagramas de blocos online"
                                  ],
                                  "tips": "Comece pelo básico para construir uma base sólida; use cores diferentes para destacar cada elemento.",
                                  "learningObjective": "Compreender o papel dos somadores dentro do contexto geral de diagramas de blocos.",
                                  "commonMistakes": [
                                    "Ignorar convenções padrão e assumir símbolos genéricos",
                                    "Confundir diagrama de blocos com fluxogramas de programação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar as características visuais do símbolo do somador",
                                  "subSteps": [
                                    "Observe o símbolo: um círculo pequeno.",
                                    "Identifique as entradas: múltiplas setas apontando para o círculo (geralmente 2 ou mais).",
                                    "Note a saída: uma única seta saindo do círculo.",
                                    "Compare com imagens de Ogata: confirme o tamanho pequeno e a ausência de rótulos dentro do círculo.",
                                    "Desenhe o símbolo 5 vezes de memória, adicionando 2 entradas e 1 saída."
                                  ],
                                  "verification": "Desenhe o símbolo corretamente sem referência, com pelo menos duas entradas e uma saída.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Imagens de diagramas de blocos de Ogata",
                                    "Papel quadriculado e lápis",
                                    "Vídeo tutorial sobre símbolos de controle (YouTube: 'Block Diagram Symbols')"
                                  ],
                                  "tips": "Use setas grossas para entradas e fina para saída para diferenciar visualmente durante o desenho.",
                                  "learningObjective": "Reconhecer e reproduzir com precisão o símbolo padrão do somador conforme convenções de Ogata.",
                                  "commonMistakes": [
                                    "Desenhar o círculo muito grande ou com rótulos como '+', confundindo com notação matemática simples",
                                    "Invertendo direção das setas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar identificação do símbolo em diagramas reais",
                                  "subSteps": [
                                    "Selecione 5 diagramas de blocos de sistemas de controle (ex: controle de velocidade).",
                                    "Circule todos os somadores em cada diagrama.",
                                    "Explique em voz alta por que cada círculo circulado é um somador (entradas múltiplas, saída única).",
                                    "Crie uma tabela: diagrama | posição do somador | número de entradas.",
                                    "Teste com diagramas sem somadores para prática negativa."
                                  ],
                                  "verification": "Identifique corretamente somadores em pelo menos 5 diagramas diferentes sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de diagramas de blocos de Ogata ou sites como Control Tutorials (University of Michigan)",
                                    "Marcador ou software de desenho como Draw.io",
                                    "Impressões de 5-10 diagramas"
                                  ],
                                  "tips": "Procure primeiro pelas setas convergindo para um círculo; ignore blocos retangulares.",
                                  "learningObjective": "Aplicar o reconhecimento do símbolo em contextos variados de diagramas de blocos.",
                                  "commonMistakes": [
                                    "Confundir somador com integrador (que tem '1/s' dentro)",
                                    "Não contar o número correto de entradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar o somador de símbolos semelhantes e consolidar",
                                  "subSteps": [
                                    "Compare somador vs. take-off point (ponto de ramificação sem círculo).",
                                    "Compare com multiplicador ou outros operadores (raros em diagramas padrão).",
                                    "Resolva 3 exercícios: 'Marque todos os somadores' em diagramas complexos.",
                                    "Crie seu próprio diagrama simples com um somador e explique seu uso.",
                                    "Revise todos os desenhos anteriores e corrija erros."
                                  ],
                                  "verification": "Diferencie corretamente somador de 3 símbolos semelhantes em um quiz autoaplicado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de símbolos comuns em diagramas de blocos (tabela impressa)",
                                    "Quiz online ou auto-criado com 10 itens",
                                    "Software como MATLAB Simulink para visualização interativa"
                                  ],
                                  "tips": "Lembre: somador soma entradas; foque na geometria das setas.",
                                  "learningObjective": "Distinguir o somador de elementos similares e consolidar o reconhecimento.",
                                  "commonMistakes": [
                                    "Confundir com ponto de soma em fluxogramas elétricos",
                                    "Esquecer que somadores podem ter sinal negativo em uma entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de blocos para o controle de altitude de uma aeronave, o somador combina o sinal de erro (referência de altitude menos feedback do altímetro) com distúrbios como vento; identifique o círculo com seta da referência e do feedback apontando para ele, e seta de saída para o controlador.",
                              "finalVerifications": [
                                "Desenhe o símbolo do somador de memória com 3 entradas e 1 saída correta.",
                                "Identifique somadores em 10 diagramas de blocos variados sem erros.",
                                "Explique verbalmente a função do somador em um sistema de controle.",
                                "Diferencie somador de integrador e take-off point em exemplos.",
                                "Crie um diagrama simples incluindo um somador corretamente representado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% correto em testes com 10 itens.",
                                "Reprodução visual: Símbolo desenhado idêntico ao padrão de Ogata.",
                                "Explicação conceitual: Descreve entradas/saídas e função sem hesitação.",
                                "Diferenciação: Distingue de 80% dos símbolos semelhantes.",
                                "Aplicação contextual: Usa corretamente em diagrama próprio.",
                                "Tempo de resposta: Reconhece em menos de 5 segundos por instância."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações de soma vetorial e álgebra linear em sinais.",
                                "Física: Combinação de forças ou sinais em sistemas dinâmicos aeronáuticos.",
                                "Programação: Implementação de somadores em simulações MATLAB/Simulink.",
                                "Eletrônica: Equivalência com amplificadores somadores em circuitos op-amp."
                              ],
                              "realWorldApplication": "Nos sistemas de controle fly-by-wire de aeronaves como o Boeing 787, somadores em diagramas de blocos combinam sinais de múltiplos sensores (acelerômetros, giroscópios) para gerar comandos estáveis de estabilização, garantindo segurança em voo turbulento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Explicar a função matemática do somador",
                            "description": "Descrever como o somador computa a saída y(t) = Σ x_i(t), onde x_i(t) são os sinais de entrada, permitindo a representação de equações diferenciais lineares por combinação de termos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Superposição em Sinais",
                                  "subSteps": [
                                    "Revise o princípio de superposição em sistemas lineares, onde a resposta a uma soma de entradas é a soma das respostas individuais.",
                                    "Identifique exemplos cotidianos de soma, como adicionar velocidades de ventos em um voo.",
                                    "Diferencie soma de sinais contínuos (y(t)) de discretos.",
                                    "Desenhe um diagrama simples de dois sinais x1(t) e x2(t) entrando em um somador.",
                                    "Explique verbalmente por que somadores são fundamentais em modelagem linear."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de soma de dois sinais e explique o princípio de superposição em suas próprias palavras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, acesso a um software de desenho como Draw.io ou caderno de notas.",
                                  "tips": "Use setas para representar fluxos de sinal para visualizar melhor a soma.",
                                  "learningObjective": "Entender que somadores aplicam o princípio de superposição linear.",
                                  "commonMistakes": "Confundir soma com multiplicação ou ignorar a linearidade do sistema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula Matemática do Somador",
                                  "subSteps": [
                                    "Escreva a equação geral para n entradas: y(t) = Σ_{i=1 to n} x_i(t).",
                                    "Comece com dois sinais: y(t) = x1(t) + x2(t), e expanda para múltiplos.",
                                    "Verifique dimensionalidade: todos x_i(t) devem ter as mesmas unidades para y(t).",
                                    "Implemente numericamente em uma ferramenta como MATLAB ou Python para validar.",
                                    "Discuta propriedades: comutatividade e associatividade da soma."
                                  ],
                                  "verification": "Escreva e comprove a fórmula y(t) = Σ x_i(t) com um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python/MATLAB com bibliotecas numpy/sympy.",
                                  "tips": "Use símbolos gregos Σ para generalizar e evite notação ambígua.",
                                  "learningObjective": "Dominar a notação matemática exata da operação do somador.",
                                  "commonMistakes": "Esquecer o índice i ou usar soma discreta em sinais contínuos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar o Somador em Diagramas de Blocos",
                                  "subSteps": [
                                    "Desenhe o símbolo padrão do somador: círculo com + e múltiplas entradas/saída.",
                                    "Integre em um diagrama de blocos maior, como um sistema de controle simples.",
                                    "Simule o fluxo: entradas → somador → saída y(t).",
                                    "Compare com somadores em circuitos elétricos (op-amps).",
                                    "Crie um diagrama para uma equação como y'' + y = u1 + u2."
                                  ],
                                  "verification": "Construa e anote um diagrama de blocos com somador corretamente rotulado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de diagramas (Visio, Lucidchart) ou papel quadriculado.",
                                  "tips": "Padronize símbolos: use triângulo para amplificadores, círculo para somadores.",
                                  "learningObjective": "Visualizar o somador como bloco funcional em modelagem de sistemas.",
                                  "commonMistakes": "Invertar sinais de entrada ou confundir com subtratores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Equações Diferenciais Lineares",
                                  "subSteps": [
                                    "Decomponha uma equação diferencial: my'' + cy' + ky = f1(t) + f2(t).",
                                    "Identifique termos somados como entradas para somador.",
                                    "Construa o diagrama de blocos completo usando somadores para combinar termos.",
                                    "Simule em software para verificar y(t).",
                                    "Explique como isso permite linearização de modelos não-lineares."
                                  ],
                                  "verification": "Transforme uma equação diferencial simples em diagrama de blocos usando somador.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB/Simulink ou Python com scipy para simulação.",
                                  "tips": "Comece com equações de segunda ordem comuns em aeronáutica.",
                                  "learningObjective": "Conectar somadores à representação de EDLs em sistemas dinâmicos.",
                                  "commonMistakes": "Ignorar coeficientes ou falhar em normalizar termos."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de aeronave, some forças aerodinâmicas lift(t) + thrust(t) para obter força total net_force(t) = lift(t) + thrust(t), que alimenta o integrador de velocidade.",
                              "finalVerifications": [
                                "Escreva corretamente y(t) = Σ x_i(t) sem erros.",
                                "Desenhe um diagrama de somador com 3 entradas.",
                                "Explique superposição em um exemplo de sinais senoidais.",
                                "Construa diagrama de blocos para y'' + 2y' + y = u1 + u2.",
                                "Simule soma de dois sinais em software e valide saída.",
                                "Discuta limitações em sistemas não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da fórmula (100% correto).",
                                "Clareza e correção do diagrama de blocos.",
                                "Profundidade na explicação de superposição.",
                                "Relevância de exemplos ao contexto aeronáutico.",
                                "Capacidade de simular e verificar numericamente.",
                                "Identificação de erros comuns e prevenção."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípio de superposição de ondas em aerodinâmica.",
                                "Eletrônica: Somadores em amplificadores operacionais para sensores de voo.",
                                "Programação: Operações de soma em simulações numéricas (NumPy).",
                                "Matemática: Séries de Fourier como somas de senos.",
                                "Controle: Blocos em Simulink para sistemas de autopilotagem."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, somadores em diagramas de blocos modelam a combinação de perturbações como vento e turbulência na equação de movimento da aeronave, essencial para design de controladores de estabilidade em voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Conectar somadores em um diagrama simples",
                            "description": "Montar um diagrama de blocos básico utilizando somadores para representar uma equação como ẋ = u - x, conectando entradas de referência, realimentação e distúrbios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação e identificar componentes necessários",
                                  "subSteps": [
                                    "Analise a equação ẋ = u - x para identificar entradas (u), saída (x), derivada (ẋ) e realimentação (-x).",
                                    "Identifique somadores necessários: pelo menos um para somar u e -x.",
                                    "Liste sinais adicionais como referência (r), erro (e = r - x) e distúrbios (d).",
                                    "Desenhe esboços iniciais dos blocos em papel.",
                                    "Defina convenções de sinal: setas para fluxo, + e - para entradas do somador."
                                  ],
                                  "verification": "Lista completa de componentes e esboço inicial desenhado corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Referência da equação impressa"
                                  ],
                                  "tips": [
                                    "Use símbolos padrão: círculo com + e - para somadores.",
                                    "Comece simples, adicione complexidade depois."
                                  ],
                                  "learningObjective": "Identificar e mapear elementos da equação diferencial para componentes de diagrama de blocos.",
                                  "commonMistakes": [
                                    "Confundir ẋ com x.",
                                    "Esquecer sinal negativo na realimentação.",
                                    "Ignorar distúrbios potenciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar os somadores principais",
                                  "subSteps": [
                                    "Desenhe o primeiro somador para calcular o erro: entrada + para referência r, entrada - para realimentação x.",
                                    "Desenhe o segundo somador (se aplicável) para adicionar distúrbio d à saída do primeiro.",
                                    "Posicione os somadores no diagrama com espaço para conexões.",
                                    "Rotule cada somador como 'Somador 1', 'Somador 2' etc.",
                                    "Verifique simetria e legibilidade do layout."
                                  ],
                                  "verification": "Somadores desenhados com entradas + e - corretamente indicadas e rotulados.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel ou software como Draw.io/Lucidchart",
                                    "Régua para alinhamento"
                                  ],
                                  "tips": [
                                    "Mantenha somadores circulares ou triangulares para padrão.",
                                    "Deixe margens para setas longas."
                                  ],
                                  "learningObjective": "Construir blocos fundamentais de soma em diagramas de blocos.",
                                  "commonMistakes": [
                                    "Entradas trocadas (+/-).",
                                    "Somadores desalinhados.",
                                    "Falta de rótulos claros."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar entradas, realimentação e distúrbios",
                                  "subSteps": [
                                    "Conecte referência r à entrada + do primeiro somador com seta rotulada 'r'.",
                                    "Crie loop de realimentação: da saída x (após integrador implícito) à entrada - do somador, rotulada '-x'.",
                                    "Adicione entrada de distúrbio d à entrada + do segundo somador, rotulada 'd'.",
                                    "Trace o sinal de saída ẋ saindo do último somador.",
                                    "Use setas unidirecionais e evite cruzamentos desnecessários."
                                  ],
                                  "verification": "Todas conexões traçadas, rotuladas e sem erros de sinal.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Marcadores coloridos para diferentes sinais",
                                    "Software de diagrama para edição"
                                  ],
                                  "tips": [
                                    "Use cores: azul para entradas, vermelho para realimentação.",
                                    "Curvas suaves em setas para clareza."
                                  ],
                                  "learningObjective": "Estabelecer fluxos de sinal corretos incluindo feedback negativo.",
                                  "commonMistakes": [
                                    "Setas bidirecionais erradas.",
                                    "Esquecer rótulo em conexões.",
                                    "Distúrbio conectado ao somador errado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar o diagrama",
                                  "subSteps": [
                                    "Simule mentalmente o fluxo: r → erro → + d → ẋ, com x realimentado como -x.",
                                    "Verifique se o diagrama reproduz ẋ = u - x (onde u pode ser erro ou r).",
                                    "Adicione legenda de símbolos e equação original no topo.",
                                    "Teste com um valor numérico simples (ex: r=1, x=0 → ẋ=1).",
                                    "Limpe o diagrama: apague linhas extras e alinhe perfeitamente."
                                  ],
                                  "verification": "Diagrama validado simula a equação corretamente com legenda.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Calculadora para simulação numérica",
                                    "Modelo impresso de referência"
                                  ],
                                  "tips": [
                                    "Percorra o diagrama com o dedo seguindo sinais.",
                                    "Compare com exemplos de livros-texto."
                                  ],
                                  "learningObjective": "Garantir fidelidade do diagrama à equação dinâmica.",
                                  "commonMistakes": [
                                    "Não validar fluxo.",
                                    "Legenda incompleta.",
                                    "Erros de sinal em simulação."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o sistema de controle de altitude de uma aeronave modelado por ẋ = u - x (onde x é desvio de altitude, u é comando de elevador), desenhe: somador com r (altitude desejada) em +, x realimentado em -, saída ẋ para integrador (implícito) gerando x, e d (vento) somado.",
                              "finalVerifications": [
                                "Equação ẋ = u - x é reproduzida pelo fluxo de sinais.",
                                "Todas entradas (r, x, d) conectadas corretamente aos somadores.",
                                "Sinais rotulados em todas setas e somadores.",
                                "Layout limpo, sem cruzamentos confusos.",
                                "Simulação numérica simples confirma comportamento.",
                                "Legenda com símbolos padrão incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão das conexões de somadores (100% corretas).",
                                "Correção da realimentação negativa.",
                                "Clareza e legibilidade do diagrama (rótulos visíveis).",
                                "Inclusão de distúrbios opcionais sem erros.",
                                "Validação via simulação mental ou numérica.",
                                "Uso de convenções padrão de diagramas de blocos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de equações diferenciais lineares.",
                                "Física: Modelagem de sistemas dinâmicos em aeronáutica.",
                                "Programação: Implementação em Simulink/MATLAB para simulação.",
                                "Engenharia de Controle: Fundamento para controladores PID."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, diagramas de blocos com somadores modelam sistemas de controle de voo autônomo, como estabilização de atitude em drones ou aviões comerciais, permitindo análise de estabilidade e resposta a distúrbios como turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Integradores",
                        "description": "Elementos que representam a operação de integração no domínio do tempo, essenciais para modelar derivadas em equações diferenciais de sistemas dinâmicos lineares invariantes no tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Identificar o símbolo do integrador",
                            "description": "Reconhecer o triângulo com a notação '1/s' ou ∫ dentro, indicando integração em relação ao tempo, padrão em diagramas de blocos para sistemas contínuos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de integrador em sistemas dinâmicos",
                                  "subSteps": [
                                    "Revise a definição de um integrador como um bloco que realiza integração em relação ao tempo: y(t) = ∫ x(τ) dτ.",
                                    "Estude a representação em domínio de Laplace: 1/s.",
                                    "Analise o papel do integrador em modelar sistemas contínuos, como acumuladores de sinal.",
                                    "Compare com derivador (s) para contrastar funções.",
                                    "Anote exemplos físicos, como velocidade para posição em dinâmica."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que um integrador faz e sua saída para uma entrada unitária em degrau.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas, vídeo introdutório sobre transformada de Laplace (YouTube ou Khan Academy).",
                                  "tips": "Use analogias: integrador é como um tanque que acumula água ao longo do tempo.",
                                  "learningObjective": "Entender a função matemática e física do integrador em sistemas.",
                                  "commonMistakes": "Confundir integração com derivação; ignorar dependência temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar os símbolos padrão do integrador",
                                  "subSteps": [
                                    "Desenhe o triângulo com seta ascendente e '1/s' dentro.",
                                    "Pratique o símbolo alternativo: círculo com ∫ e seta.",
                                    "Identifique variações em diagramas de blocos: triângulo invertido vs. padrão.",
                                    "Copie símbolos de exemplos em livros ou slides de aula.",
                                    "Crie flashcards com símbolos e definações."
                                  ],
                                  "verification": "Desenhe o símbolo de memória sem referência e rotule corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, imagens de diagramas de blocos de fontes confiáveis (ex: Ogata 'Modern Control Engineering').",
                                  "tips": "Associe o triângulo à 'acumulação crescente' como uma pilha.",
                                  "learningObjective": "Reconhecer graficamente os símbolos oficiais do integrador.",
                                  "commonMistakes": "Desenhar triângulo com 's' (somador) ou sem notação '1/s'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o integrador em diagramas de blocos reais",
                                  "subSteps": [
                                    "Examine diagramas de sistemas contínuos, localizando triângulos com '1/s'.",
                                    "Marque todos os integradores em 3-5 diagramas de exemplo.",
                                    "Trace o sinal de entrada para saída através do integrador.",
                                    "Diferencie de amplificadores (retângulos) e somadores (círculos).",
                                    "Simule um diagrama simples no MATLAB/Simulink."
                                  ],
                                  "verification": "Anote e explique 3 diagramas onde identificou corretamente o integrador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagramas de blocos impressos ou digitais, software Simulink (opcional).",
                                  "tips": "Procure sempre por '1/s' ou ∫; ignore triângulos sem notação específica.",
                                  "learningObjective": "Aplicar reconhecimento em contextos de diagramas completos.",
                                  "commonMistakes": "Confundir com ganhos constantes (K) ou delays (e^{-sT})."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação e verificação",
                                  "subSteps": [
                                    "Crie um diagrama de blocos simples com integrador e identifique-o.",
                                    "Resolva exercícios: 'Encontre todos os integradores neste diagrama'.",
                                    "Compare sua identificação com soluções de referência.",
                                    "Discuta com colega ou tutor dúvidas sobre símbolos ambíguos.",
                                    "Registre erros e corrija."
                                  ],
                                  "verification": "Acertar 100% em um quiz de 10 diagramas variados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exercícios online (ex: Control Tutorials for MATLAB), quiz autoavaliativo.",
                                  "tips": "Amplie o diagrama para melhor visualização de símbolos pequenos.",
                                  "learningObjective": "Consolidar identificação por prática iterativa.",
                                  "commonMistakes": "Ignorar notação em diagramas lotados; superestimar similaridades."
                                }
                              ],
                              "practicalExample": "Em um diagrama de blocos para o controle de atitude de um drone, identifique o triângulo com '1/s' que integra aceleração angular para obter ângulo de inclinação, essencial para estabilidade de voo.",
                              "finalVerifications": [
                                "Desenha corretamente o símbolo do integrador sem referência.",
                                "Identifica integradores em 5 diagramas de blocos complexos sem erros.",
                                "Explica a função '1/s' em domínio de Laplace.",
                                "Diferencia integrador de somador e amplificador.",
                                "Aplica em um exemplo real de sistema aeronáutico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do símbolo (triângulo + '1/s' ou ∫).",
                                "Capacidade de localização em diagramas reais (90% acerto).",
                                "Compreensão conceitual (explicação clara da integração temporal).",
                                "Diferenciação de blocos similares.",
                                "Uso correto em simulações simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e transformada de Laplace.",
                                "Física: Dinâmica de sistemas (ex: leis de Newton em aeronaves).",
                                "Eletrônica: Circuitos integradores com amplificadores operacionais.",
                                "Programação: Implementação em Simulink ou Python (control library)."
                              ],
                              "realWorldApplication": "Em sistemas de controle de voo de aeronaves, o símbolo do integrador é usado em diagramas para modelar a integração de velocidades para posições, garantindo estabilidade e precisão em autopilotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Descrever a relação entrada-saída do integrador",
                            "description": "Explicar que para entrada x(t), a saída é y(t) = ∫_{-∞}^t x(τ) dτ, correspondendo à inversa da derivada em modelos de sistemas dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de um integrador",
                                  "subSteps": [
                                    "Revise a definição de integral definida como acumulação de uma função ao longo do tempo.",
                                    "Analise exemplos físicos simples, como posição resultante da integração da velocidade.",
                                    "Identifique que o integrador 'acumula' a entrada x(t) para produzir a saída y(t).",
                                    "Diferencie integração de outras operações como soma ou média.",
                                    "Visualize graficamente: a saída é a área sob a curva da entrada."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que um integrador faz com uma entrada constante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e lápis para esboços gráficos",
                                    "Vídeo introdutório sobre integrais (ex: Khan Academy)"
                                  ],
                                  "tips": [
                                    "Pense em um tanque enchendo: vazão é entrada, volume é saída."
                                  ],
                                  "learningObjective": "Entender intuitivamente que o integrador realiza acumulação temporal.",
                                  "commonMistakes": [
                                    "Confundir integrador com somador discreto",
                                    "Ignorar limites de integração (-∞ a t)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir matematicamente a relação entrada-saída",
                                  "subSteps": [
                                    "Escreva a fórmula y(t) = ∫_{-∞}^t x(τ) dτ em um papel.",
                                    "Explique cada símbolo: x(τ) é entrada, τ é variável dummy, t é tempo atual.",
                                    "Derive verbalmente: para x(t) = constante c, y(t) = c * t + constante.",
                                    "Teste com x(t) = δ(t) (impulso), verificando y(t) = u(t) (degrau).",
                                    "Anote a dependência causal: saída depende apenas do passado da entrada."
                                  ],
                                  "verification": "Resolva y(t) para x(t) = 1 (constante) e confirme linearidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como MATLAB/SymPy",
                                    "Quadro branco para derivações"
                                  ],
                                  "tips": [
                                    "Use τ para evitar confusão com t na entrada."
                                  ],
                                  "learningObjective": "Dominar a notação exata da relação entrada-saída do integrador.",
                                  "commonMistakes": [
                                    "Escrever limites errados (ex: 0 a t em vez de -∞ a t)",
                                    "Confundir com derivada d/dt y(t) = x(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar o integrador com derivada e sistemas dinâmicos",
                                  "subSteps": [
                                    "Lembre que d/dt y(t) = x(t), provando que integrador é inverso da derivada.",
                                    "Discuta em modelos dinâmicos: estados como integrais de entradas (ex: posição de velocidade).",
                                    "Desenhe o símbolo do integrador em diagrama de blocos (triângulo com ∫).",
                                    "Explique linearidade: integrações preserva superposição.",
                                    "Compare com diferenciador: instável vs. integrador suave."
                                  ],
                                  "verification": "Mostre que aplicando derivada na saída obtém-se a entrada original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de diagramas de blocos como Simulink",
                                    "Exemplos de equações diferenciais de sistemas"
                                  ],
                                  "tips": [
                                    "Inverso da derivada significa 'antiderivada' causal."
                                  ],
                                  "learningObjective": "Compreender o papel do integrador como bloco fundamental em modelagem dinâmica.",
                                  "commonMistakes": [
                                    "Pensar que integrador amplifica altas frequências (é o oposto)",
                                    "Ignorar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em contexto de diagramas de blocos",
                                  "subSteps": [
                                    "Construa um diagrama simples: entrada x(t) → integrador → y(t).",
                                    "Simule numericamente com ferramenta (ex: aceleração → velocidade → posição).",
                                    "Analise resposta a diferentes entradas: degrau, rampa, senoide.",
                                    "Descreva verbalmente a relação em um parágrafo completo.",
                                    "Compare com linearização de modelos não-lineares onde integrais aproximam."
                                  ],
                                  "verification": "Desenhe e explique um diagrama com integrador para um sistema de segunda ordem.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulink ou Python com SciPy para simulação",
                                    "Modelos de sistemas dinâmicos impressos"
                                  ],
                                  "tips": [
                                    "Sempre rotule entrada/saída claramente nos diagramas."
                                  ],
                                  "learningObjective": "Integrar o conceito em representações gráficas de sistemas.",
                                  "commonMistakes": [
                                    "Desenhar seta errada (saída não depende de futuro)",
                                    "Esquecer escala de tempo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de controle de atitude de aeronave, a entrada do integrador é a taxa angular ω(t) (velocidade angular medida por giroscópio), e a saída y(t) = ∫ ω(τ) dτ é o ângulo de rolagem acumulado φ(t), essencial para estabilização via laços de feedback.",
                              "finalVerifications": [
                                "Escreve corretamente y(t) = ∫_{-∞}^t x(τ) dτ sem erros de notação.",
                                "Explica que é inverso da derivada com exemplo numérico.",
                                "Desenha o símbolo do integrador em diagrama de blocos.",
                                "Simula resposta a entrada degrau e interpreta resultado.",
                                "Descreve causalidade e acumulação em palavras próprias.",
                                "Diferencia de somador discreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da fórmula (100% correto).",
                                "Compreensão conceitual (explicação clara de acumulação).",
                                "Habilidade de representação gráfica em blocos.",
                                "Correta interpretação de exemplos físicos.",
                                "Identificação de erros comuns e evitações.",
                                "Aplicação contextual em sistemas dinâmicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e equações diferenciais.",
                                "Física: Cinemática (posição = ∫ velocidade).",
                                "Engenharia de Controle: Blocos em laços de feedback.",
                                "Computação: Integração numérica (método de Euler).",
                                "Processamento de Sinais: Filtro integrador em domínio tempo."
                              ],
                              "realWorldApplication": "Nos sistemas de controle de voo autônomo de drones ou aviões (ex: Boeing 787), integradores nos diagramas de blocos acumulam erros de navegação para correções de trajetória, simulados em software como MATLAB/Simulink para certificação aeronáutica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Aplicar integradores em modelagem de EDO",
                            "description": "Converter uma equação diferencial ordinária de primeira ordem, como ẋ + a x = b u, em diagrama de blocos usando integradores e somadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reescrever a EDO na forma padrão para integração",
                                  "subSteps": [
                                    "Analise a equação dada, como ẋ + a x = b u, identificando o termo derivada ẋ, o termo proporcional a x e o termo de entrada u.",
                                    "Isole a derivada: subtraia a x de ambos os lados para obter ẋ = -a x + b u.",
                                    "Verifique os coeficientes: confirme que o sinal do termo x é negativo e o de u é positivo conforme a equação original.",
                                    "Anote a equação reescrita claramente, destacando que ẋ representa a entrada do integrador.",
                                    "Pratique com uma variação: teste com valores numéricos, ex. a=2, b=1."
                                  ],
                                  "verification": "A equação está reescrita como ẋ = -a x + b u, com coeficientes corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Exemplo de EDO impresso"
                                  ],
                                  "tips": "Sempre priorize isolar a derivada mais alta à esquerda para visualização clara.",
                                  "learningObjective": "Compreender a transformação da EDO em forma explícita para modelagem em blocos.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo no termo -a x",
                                    "Confundir coeficientes de x e u",
                                    "Não isolar completamente ẋ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes do diagrama de blocos",
                                  "subSteps": [
                                    "Reconheça o integrador: a saída do integrador é x, e sua entrada é ẋ = -a x + b u.",
                                    "Identifique somadores: necessário um somador para combinar -a x e b u.",
                                    "Determine blocos de ganho: bloco com ganho -a para o feedback de x, e ganho b para a entrada u.",
                                    "Desenhe esboços iniciais dos blocos: integrador (1/s), somador (+), ganhos (-a e b).",
                                    "Liste conexões: saída x vai para ganho -a e volta ao somador; u vai para ganho b."
                                  ],
                                  "verification": "Lista completa de componentes (integrador, somador, ganhos -a e b) identificados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Referência de símbolos de blocos"
                                  ],
                                  "tips": "Lembre-se: integrador é representado por 1/s ou caixa com ∫.",
                                  "learningObjective": "Mapear elementos matemáticos da EDO para blocos funcionais padrão.",
                                  "commonMistakes": [
                                    "Omitir o ganho negativo -a",
                                    "Confundir entrada/saída do integrador",
                                    "Esquecer o somador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o diagrama de blocos completo",
                                  "subSteps": [
                                    "Desenhe o integrador no centro: seta de saída labelada 'x'.",
                                    "Adicione feedback: de 'x' para bloco ganho '-a', depois para somador.",
                                    "Adicione entrada: de 'u' para bloco ganho 'b', depois para somador.",
                                    "Conecte somador à entrada do integrador: saída do somador é ẋ.",
                                    "Rotule todas as setas e blocos claramente, incluindo variáveis e parâmetros."
                                  ],
                                  "verification": "Diagrama desenhado com todas conexões corretas e labels precisos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou software de desenho (ex. Draw.io)",
                                    "Modelos de blocos impressos"
                                  ],
                                  "tips": "Desenhe setas com direção clara e evite cruzamentos desnecessários.",
                                  "learningObjective": "Montar visualmente a representação em blocos da dinâmica da EDO.",
                                  "commonMistakes": [
                                    "Conexão errada do feedback (sem negativo)",
                                    "Inverter entrada/saída do integrador",
                                    "Falta de labels em setas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar o diagrama de blocos",
                                  "subSteps": [
                                    "Derive a EDO a partir do diagrama: simule o sinal através dos blocos para recuperar ẋ + a x = b u.",
                                    "Teste com valores numéricos: substitua a=2, b=1 e verifique equilíbrio em estado estacionário.",
                                    "Compare com forma canônica: confirme que representa corretamente o sistema linear.",
                                    "Identifique pontos de linearização se aplicável, notando suposições.",
                                    "Documente qualquer discrepância e corrija."
                                  ],
                                  "verification": "Diagrama gera a EDO original ao ser 'lida' matematicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software Simulink ou MATLAB (opcional)",
                                    "Papel para derivação"
                                  ],
                                  "tips": "Em estado estacionário (ẋ=0), x = (b/a) u para verificação rápida.",
                                  "learningObjective": "Garantir fidelidade da representação em blocos à equação original.",
                                  "commonMistakes": [
                                    "Ignorar verificação de estado estacionário",
                                    "Erro na derivação simbólica",
                                    "Não testar com números"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO ẋ + 3x = 2u: reescreva como ẋ = -3x + 2u. Diagrama: u → ganho 2 → somador ← ganho -3 ← x (saída do integrador 1/s). Isso modela um sistema de primeira ordem com polo em -3.",
                              "finalVerifications": [
                                "Converte corretamente qualquer EDO dada como ẋ + a x = b u em ẋ = -a x + b u.",
                                "Desenha diagrama com integrador, somador e ganhos corretos sem erros de sinal.",
                                "Valida o diagrama derivando de volta a EDO original.",
                                "Aplica a valores numéricos e verifica estado estacionário x = (b/a)u.",
                                "Explica verbalmente o fluxo de sinal no diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reescrita da EDO (100% dos coeficientes corretos).",
                                "Correção e completude dos componentes do diagrama (todos blocos presentes).",
                                "Clareza e legibilidade do desenho (labels e setas nítidas).",
                                "Validação matemática bem-sucedida (EDO recuperada).",
                                "Tempo de execução dentro do estimado com qualidade alta.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução analítica de EDOs de 1ª ordem.",
                                "Física: Modelagem de sistemas massa-mola-amortecedor equivalentes.",
                                "Engenharia de Controle: Preparação para funções de transferência e controladores.",
                                "Programação: Implementação em Simulink ou Python (SciPy) para simulação.",
                                "Engenharia Aeronáutica: Dinâmica longitudinal de aeronaves."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, essa modelagem é usada para representar a dinâmica de atitude de aeronaves (ex. equação de roll rate ṗ + (L_p/M) p = L_δ_a / M * δ_a), permitindo simulações em Simulink para design de sistemas de controle de voo autônomo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.4",
                            "name": "Interpretar múltiplos integradores",
                            "description": "Representar sistemas de segunda ordem com dois integradores em cascata para modelar aceleração como dupla integração de força em sistemas mecânicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de integrador único em diagramas de blocos",
                                  "subSteps": [
                                    "Defina um integrador como um bloco que realiza a operação de integração temporal: saída y(t) = ∫ u(τ) dτ.",
                                    "Identifique exemplos clássicos: velocidade como integral da aceleração, posição como integral da velocidade.",
                                    "Desenhe um diagrama de blocos simples com um integrador e rotule entrada (força/aceleração) e saída (posição/velocidade).",
                                    "Simule mentalmente ou em papel o comportamento para entrada em degrau (resposta em rampa).",
                                    "Compare com equações diferenciais de primeira ordem."
                                  ],
                                  "verification": "Desenhar corretamente um diagrama de blocos com um integrador e explicar a relação entrada-saída em voz alta ou por escrito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de diagramas como Draw.io ou MATLAB Simulink (opcional)"
                                  ],
                                  "tips": "Sempre rotule as unidades físicas das entradas e saídas para reforçar o significado.",
                                  "learningObjective": "Compreender o papel fundamental de um integrador único na representação de dinâmicas de primeira ordem.",
                                  "commonMistakes": "Confundir integração com derivação ou ignorar o sinal de tempo na integral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir sistemas de segunda ordem com dois integradores em cascata",
                                  "subSteps": [
                                    "Explique que sistemas de segunda ordem requerem dois integradores em série para representar equações diferenciais de ordem 2.",
                                    "Desenhe o diagrama: entrada → integrador1 → integrador2 → saída.",
                                    "Identifique variáveis intermediárias: por exemplo, entrada = aceleração, intermediária = velocidade, saída = posição.",
                                    "Analise o efeito cascata: cada integrador acumula o sinal anterior.",
                                    "Discuta linearidade e propriedades do sistema (estável, causal)."
                                  ],
                                  "verification": "Construir e rotular um diagrama de dois integradores em cascata, identificando todas as variáveis físicas.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplos de diagramas de blocos impressos"
                                  ],
                                  "tips": "Use setas claras e legendas para entradas/saídas para evitar confusão visual.",
                                  "learningObjective": "Representar visualmente a cascata de integradores para modelar dinâmicas de segunda ordem.",
                                  "commonMistakes": "Colocar integradores em paralelo em vez de cascata ou inverter a ordem de integração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar aceleração como dupla integração de força em sistemas mecânicos",
                                  "subSteps": [
                                    "Lembre a lei de Newton: F = m * a, onde a = d²x/dt².",
                                    "Derive: x(t) = (1/m) ∫∫ F(τ) dτ (dupla integração).",
                                    "Monte o diagrama: F/m → integrador (a → v) → integrador (v → x).",
                                    "Inclua ganhos (1/m) e possíveis feedbacks para realismo.",
                                    "Teste com entrada unitária: responda como rampa quadrática."
                                  ],
                                  "verification": "Derivar e desenhar o diagrama completo para um sistema massa-mola simples, confirmando equações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora",
                                    "MATLAB ou Python para simulação rápida (opcional)"
                                  ],
                                  "tips": "Normalize unidades (ex: m=1) para simplificar cálculos iniciais.",
                                  "learningObjective": "Conectar diagramas de blocos à física newtoniana para modelagem mecânica.",
                                  "commonMistakes": "Esquecer o ganho 1/m ou confundir força com aceleração diretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e analisar diagramas de múltiplos integradores em contextos aeronáuticos",
                                  "subSteps": [
                                    "Aplique a um exemplo: modelagem longitudinal de aeronave (força de empuxo → aceleração → velocidade → posição).",
                                    "Identifique loops de realimentação comuns em controle de voo.",
                                    "Analise respostas transitórias (overshoot, tempo de estabilização).",
                                    "Compare com simulações numéricas ou dados reais.",
                                    "Discuta limitações: não-linearidades em altas velocidades."
                                  ],
                                  "verification": "Interpretar um diagrama dado, explicando o fluxo físico de sinais e prevendo comportamento qualitativo.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": [
                                    "Exemplos de diagramas aeronáuticos",
                                    "Software Simulink"
                                  ],
                                  "tips": "Pense em termos de 'o que acontece se a entrada muda abruptamente?'.",
                                  "learningObjective": "Interpretar múltiplos integradores em aplicações reais de engenharia aeronáutica.",
                                  "commonMistakes": "Ignorar efeitos de realimentação ou assumir linearidade absoluta."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de altitude de uma aeronave, a força de empuxo (entrada) é dividida pela massa para obter aceleração vertical, integrada para velocidade vertical e novamente para posição (altitude). Desenhe o diagrama com dois integradores em cascata e simule uma resposta a um comando de subida constante.",
                              "finalVerifications": [
                                "Desenhar corretamente um diagrama de dois integradores em cascata para um sistema mecânico de segunda ordem.",
                                "Explicar verbalmente o significado físico de cada sinal no diagrama.",
                                "Derivar a equação diferencial associada ao diagrama.",
                                "Prever qualitativamente a resposta a entradas em degrau, rampa e impulso.",
                                "Identificar onde adicionar realimentação para controle.",
                                "Simular numericamente e comparar com o diagrama teórico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação do diagrama de blocos (rótulos, conexões).",
                                "Correta associação entre sinais físicos e operações matemáticas.",
                                "Capacidade de derivar equações a partir do diagrama.",
                                "Análise qualitativa e quantitativa da resposta do sistema.",
                                "Identificação de aplicações e limitações em contextos reais.",
                                "Criatividade em extensões (ex: adicionar não-linearidades)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Newton e mecânica clássica.",
                                "Matemática: Equações diferenciais lineares e transformadas de Laplace.",
                                "Engenharia de Controle: Projeto de controladores PID em loops com integradores.",
                                "Programação: Simulação em MATLAB/Simulink ou Python (SciPy).",
                                "Física Computacional: Modelagem numérica de trajetórias."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, essa representação é essencial para modelar a dinâmica longitudinal de aeronaves, permitindo o design de sistemas de controle de voo autônomo (autopiloto) que estabilizam aceleração, velocidade e posição sob perturbações como vento ou mudanças de empuxo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Blocos de Ganho",
                        "description": "Blocos que aplicam uma multiplicação escalar constante (ganho) ao sinal de entrada, representando coeficientes em equações lineares de sistemas dinâmicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Reconhecer o símbolo do bloco de ganho",
                            "description": "Identificar o retângulo com a constante 'K' ou número específico dentro, indicando multiplicação y(t) = K x(t), comum em diagramas de função de transferência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Bloco de Ganho",
                                  "subSteps": [
                                    "Revise a definição de um bloco de ganho: um elemento que multiplica a entrada x(t) por uma constante K, resultando em y(t) = K x(t).",
                                    "Estude a função de transferência associada: G(s) = K, onde K é uma constante real.",
                                    "Analise exemplos simples, como K=2 para amplificação ou K=0.5 para atenuação.",
                                    "Compare com blocos de soma e derivação para contextualizar.",
                                    "Anote a importância em sistemas lineares invariantes no tempo (LTI)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que o bloco de ganho faz, incluindo a equação y(t) = K x(t).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas",
                                    "Anotações de aula sobre diagramas de blocos",
                                    "Vídeo tutorial sobre blocos básicos (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como volume de som (ganho amplifica o sinal).",
                                  "learningObjective": "Compreender o papel matemático e funcional do bloco de ganho em diagramas.",
                                  "commonMistakes": [
                                    "Confundir ganho com soma (soma não multiplica)",
                                    "Achar que K pode ser função de tempo (em LTI, é constante)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar o Símbolo Visual Padrão",
                                  "subSteps": [
                                    "Desenhe o símbolo: um retângulo com 'K' ou número específico dentro, seta de entrada à esquerda e saída à direita.",
                                    "Identifique elementos chave: bordas retas, texto centralizado 'K' em maiúscula, sem curvas ou setas internas.",
                                    "Pratique copiando símbolos de referências padrão (ex: livro Ogata).",
                                    "Compare variações: 'K', '2', '-1', mas sempre retângulo simples.",
                                    "Crie flashcards com o símbolo de um lado e definição do outro."
                                  ],
                                  "verification": "Desenhe o símbolo de memória e rotule entrada/saída corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhos",
                                    "Flashcards digitais (Anki app)",
                                    "Imagens de diagramas de blocos de fontes confiáveis"
                                  ],
                                  "tips": "Associe visualmente: retângulo = multiplicador simples, como uma 'caixa de escala'.",
                                  "learningObjective": "Reconhecer instantaneamente o formato gráfico do bloco de ganho.",
                                  "commonMistakes": [
                                    "Desenhar com setas internas (confunde com integrador)",
                                    "Usar círculo em vez de retângulo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Reconhecimento em Diagramas Simples",
                                  "subSteps": [
                                    "Examine diagramas com um único bloco de ganho e identifique-o.",
                                    "Marque o bloco com 'GANHO' em 5 diagramas de exemplo.",
                                    "Diferencie de blocos de função (ex: 1/s para integrador).",
                                    "Simule entrada/saída: para x(t)=1, y(t)=K.",
                                    "Registre acertos/erros em uma tabela de prática."
                                  ],
                                  "verification": "Identifique corretamente o bloco de ganho em 3 diagramas simples sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de blocos impressos ou digitais",
                                    "Software como MATLAB Simulink para visualização",
                                    "Planilha Excel para tracking"
                                  ],
                                  "tips": "Procure primeiro o retângulo com constante; ignore setas externas.",
                                  "learningObjective": "Aplicar reconhecimento em contextos isolados de diagramas.",
                                  "commonMistakes": [
                                    "Confundir com bloco de atraso (z^{-1} em discreto)",
                                    "Ignorar sinal negativo em K"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer em Diagramas Complexos e Verificar",
                                  "subSteps": [
                                    "Analise diagramas completos de sistemas de controle aeronáutico com múltiplos blocos.",
                                    "Localize todos os blocos de ganho e explique seu papel no fluxo de sinal.",
                                    "Teste com ruído: altere K e observe impacto na saída.",
                                    "Compare com simulações reais em software.",
                                    "Autoavalie com quiz de 10 questões mistas."
                                  ],
                                  "verification": "Liste todos os blocos de ganho em um diagrama complexo e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de sistemas de controle de aeronaves",
                                    "MATLAB ou Python (Control Systems Library)",
                                    "Quiz online gerado"
                                  ],
                                  "tips": "Em diagramas lotados, escaneie por retângulos com constantes numéricas.",
                                  "learningObjective": "Discernir blocos de ganho em cenários reais e complexos.",
                                  "commonMistakes": [
                                    "Confundir com ganhos variáveis (não constantes)",
                                    "Perder blocos pequenos em diagramas densos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de controle de atitude de um drone, o bloco retangular com 'K=5' multiplica o sinal de erro de pitch x(t) por 5, produzindo y(t)=5x(t) para o atuador, amplificando o comando de correção.",
                              "finalVerifications": [
                                "Desenhe o símbolo de memória sem erros.",
                                "Identifique blocos de ganho em 10 diagramas variados (acertos >90%).",
                                "Explique y(t)=K x(t) para 3 valores de K diferentes.",
                                "Diferencie de 5 outros blocos comuns.",
                                "Aplique em um diagrama de aeronáutica simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação visual (100% em símbolos isolados).",
                                "Compreensão conceitual (explicação correta da equação).",
                                "Diferenciação de blocos similares (>80% acerto).",
                                "Velocidade de reconhecimento (<10s por diagrama).",
                                "Aplicação contextual em engenharia (exemplos relevantes).",
                                "Ausência de erros comuns listados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Multiplicação escalar e funções lineares.",
                                "Física: Amplificação de sinais em circuitos elétricos.",
                                "Informática: Operações em processamento de sinais digitais.",
                                "Engenharia Elétrica: Ganhos em amplificadores operacionais."
                              ],
                              "realWorldApplication": "Em sistemas de controle de voo de aeronaves, blocos de ganho representam fatores de amplificação em atuadores, como no autopilot, onde K ajusta a resposta do elevador ao sinal de erro de altitude para estabilidade dinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Calcular saída de um bloco de ganho",
                            "description": "Determinar a saída para uma entrada conhecida, considerando ganhos positivos ou negativos para amplificação ou inversão de sinal em realimentações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e a fórmula de um bloco de ganho",
                                  "subSteps": [
                                    "Estude a definição: um bloco de ganho multiplica a entrada por um fator constante K (ganho).",
                                    "Memorize a fórmula básica: y(t) = K * x(t), onde x(t) é a entrada e y(t) é a saída.",
                                    "Analise representações gráficas: identifique o símbolo do bloco com 'K' dentro.",
                                    "Diferencie ganho positivo (amplificação) de negativo (inversão de sinal).",
                                    "Revise exemplos iniciais com valores numéricos simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e dê um exemplo com K=2 e x=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de bloco de ganho (imagem ou desenho)",
                                    "Folha de anotações",
                                    "Vídeo tutorial sobre diagramas de blocos (opcional)"
                                  ],
                                  "tips": "Desenhe o bloco à mão para fixar a visualização.",
                                  "learningObjective": "Dominar a definição e fórmula fundamental do bloco de ganho.",
                                  "commonMistakes": [
                                    "Confundir ganho com soma.",
                                    "Ignorar o sinal do ganho (positivo/negativo)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar entrada e ganho em um diagrama de blocos",
                                  "subSteps": [
                                    "Examine um diagrama simples com um bloco de ganho isolado.",
                                    "Localize a seta de entrada (x(t)) e o valor de K rotulado no bloco.",
                                    "Anote o valor exato de K, verificando se é positivo ou negativo.",
                                    "Confirme que não há outros blocos interferindo na entrada direta.",
                                    "Pratique com 2-3 diagramas variados."
                                  ],
                                  "verification": "Marque corretamente entrada e K em um diagrama fornecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagramas de blocos impressos ou digitais",
                                    "Lápis e papel para marcações"
                                  ],
                                  "tips": "Sempre leia o rótulo do bloco com atenção para sinais como '-' em K.",
                                  "learningObjective": "Habilidade para extrair parâmetros corretamente de representações visuais.",
                                  "commonMistakes": [
                                    "Ler K errado (ex: 2 como -2).",
                                    "Confundir entrada com saída."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a saída para ganhos positivos e negativos",
                                  "subSteps": [
                                    "Para ganho positivo: multiplique x(t) por K (ex: K=3, x=4 → y=12).",
                                    "Para ganho negativo: multiplique e inverta sinal (ex: K=-2, x=5 → y=-10).",
                                    "Trate funções contínuas: y(t) = K * x(t) (ex: x(t)=sin(t), K=2 → y=2sin(t)).",
                                    "Resolva 5 exercícios variados, incluindo decimais e frações.",
                                    "Verifique unidades: saída mantém unidade da entrada multiplicada por K (adimensional)."
                                  ],
                                  "verification": "Resolva 3 problemas e confira respostas com soluções modelo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de exercícios impressa",
                                    "Calculadora",
                                    "Tabela de soluções"
                                  ],
                                  "tips": "Use parênteses para sinal: y = (-K) * x se K negativo.",
                                  "learningObjective": "Executar cálculos precisos considerando amplificação e inversão.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na inversão.",
                                    "Não distribuir K em funções como senos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em contextos de realimentação simples",
                                  "subSteps": [
                                    "Identifique blocos de ganho em loops de realimentação básica.",
                                    "Calcule saída considerando apenas o ganho local (ignorando loop por ora).",
                                    "Compare com entrada conhecida: note amplificação ou atenuação.",
                                    "Simule um caso com realimentação negativa (K negativo no feedback).",
                                    "Documente o processo em um diagrama resolvido."
                                  ],
                                  "verification": "Calcule saída em um diagrama de realimentação simples e explique impacto do ganho.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagramas com realimentação",
                                    "Software como MATLAB/Simulink (opcional)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Foque no bloco isolado primeiro, depois expanda para o sistema.",
                                  "learningObjective": "Integrar cálculo de ganho em sistemas dinâmicos maiores.",
                                  "commonMistakes": [
                                    "Calcular o loop inteiro prematuramente.",
                                    "Ignorar direção da seta no feedback."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de controle de aeronave, entrada do sensor x(t) = 10 V (sinal de ângulo de ataque), bloco de ganho K = 0.5 (atenuador). Saída y(t) = 5 V para o controlador. Se K = -1 (inversor para correção), y(t) = -10 V, invertendo sinal para estabilização.",
                              "finalVerifications": [
                                "Define corretamente bloco de ganho e fórmula y = Kx.",
                                "Calcula saída para K positivo com precisão.",
                                "Calcula saída para K negativo, incluindo inversão.",
                                "Identifica K e x em diagrama visual.",
                                "Explica impacto em realimentação simples.",
                                "Resolve exemplo prático sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (100% correto).",
                                "Correta interpretação de sinais positivos/negativos.",
                                "Identificação precisa de parâmetros em diagramas.",
                                "Explicação clara do processo passo a passo.",
                                "Aplicação contextual em sistemas reais.",
                                "Tempo de resolução eficiente sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Multiplicação escalar e álgebra linear básica.",
                                "Física: Amplificadores em circuitos elétricos e sinais analógicos.",
                                "Programação: Implementação em Python/MATLAB para simulação de blocos.",
                                "Engenharia de Controle: Fundamento para análise de laços fechados."
                              ],
                              "realWorldApplication": "Em aviões, blocos de ganho modelam amplificadores em sistemas fly-by-wire, ajustando sinais de sensores (ex: acelerômetros) para atuadores de superfícies de controle, garantindo estabilidade e resposta precisa durante manobras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Incorporar ganhos em diagramas de realimentação",
                            "description": "Inserir blocos de ganho em loops de realimentação para representar constantes de tempo ou ganhos estáticos em modelos como o de um R-C série.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Loops de Realimentação e Blocos de Ganho",
                                  "subSteps": [
                                    "Revise a estrutura de um diagrama de blocos padrão com loop de realimentação negativa ou positiva.",
                                    "Identifique os componentes principais: planta, controlador, sensor e soma.",
                                    "Estude o papel dos blocos de ganho: representam amplificadores constantes (K) ou constantes de tempo (τ).",
                                    "Analise exemplos simples de sistemas lineares como R-C série, onde ganho modela 1/RC.",
                                    "Anote definições chave: ganho estático vs. dinâmico."
                                  ],
                                  "verification": "Crie um esboço simples de um loop de realimentação sem ganho e explique verbalmente seu funcionamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de Sinais e Sistemas",
                                    "Vídeo tutorial sobre diagramas de blocos"
                                  ],
                                  "tips": "Use setas para indicar fluxo de sinal e rótulos claros para entradas/saídas.",
                                  "learningObjective": "Dominar os fundamentos teóricos para preparar a inserção de ganhos.",
                                  "commonMistakes": [
                                    "Confundir realimentação positiva com negativa",
                                    "Ignorar a direção do sinal no loop"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Posições para Inserção de Blocos de Ganho no Diagrama",
                                  "subSteps": [
                                    "Examine o modelo físico ou equação diferencial do sistema (ex: R-C série: V_out = V_in / (1 + sRC)).",
                                    "Determine onde o ganho se aplica: no forward path (ex: ganho da planta) ou no feedback path.",
                                    "Calcule o valor do ganho: para R-C, ganho K = 1/RC representando constante de tempo.",
                                    "Marque no diagrama existente os pontos de inserção potenciais.",
                                    "Compare com modelos canônicos de realimentação unitária."
                                  ],
                                  "verification": "Liste 3 posições possíveis de ganho em um diagrama dado e justifique cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de diagramação como Draw.io ou Lucidchart",
                                    "Equações do sistema R-C impressas"
                                  ],
                                  "tips": "Sempre normalize o ganho para facilitar comparações com formas padrão.",
                                  "learningObjective": "Selecionar corretamente locais de inserção baseados no modelo físico.",
                                  "commonMistakes": [
                                    "Inserir ganho no caminho errado, invertendo estabilidade",
                                    "Usar valor incorreto sem dimensionalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Diagrama de Blocos Incorporando o Bloco de Ganho",
                                  "subSteps": [
                                    "Desenhe o loop de realimentação base.",
                                    "Insira o bloco de ganho (retângulo com 'K' ou '1/τ') no forward ou feedback path.",
                                    "Conecte setas corretamente, mantendo soma e take-off points.",
                                    "Rótule entradas (r), saídas (y) e erros (e).",
                                    "Simplifique o diagrama se possível usando regras de bloco (série/paralelo)."
                                  ],
                                  "verification": "Mostre o diagrama final a um colega para confirmação de conexões corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta digital: MATLAB Simulink ou papel quadriculado",
                                    "Modelos de exemplo R-C"
                                  ],
                                  "tips": "Use cores diferentes para forward path (azul) e feedback (vermelho).",
                                  "learningObjective": "Criar diagramas precisos e legíveis com ganhos integrados.",
                                  "commonMistakes": [
                                    "Esquecer soma no ponto de realimentação",
                                    "Conexões cruzadas de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Testar o Diagrama com Simulação",
                                  "subSteps": [
                                    "Calcule a função de transferência do diagrama: G(s)/(1 + G(s)H(s)) com ganho incluso.",
                                    "Compare com a equação original do sistema (ex: validar 1/(1 + sRC)).",
                                    "Simule resposta a degrau no software.",
                                    "Ajuste ganho se discrepâncias aparecerem.",
                                    "Documente o processo de validação."
                                  ],
                                  "verification": "A simulação produz saída idêntica ao modelo teórico dentro de 5% de erro.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Dados de simulação de R-C"
                                  ],
                                  "tips": "Comece com valores numéricos simples (R=1kΩ, C=1μF) para depuração rápida.",
                                  "learningObjective": "Garantir fidelidade do diagrama ao modelo real.",
                                  "commonMistakes": [
                                    "Erro em cálculo de transferência",
                                    "Ignorar efeitos de atraso"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um circuito R-C série low-pass filter (R=1kΩ, C=1μF, τ=1ms), insira um bloco de ganho K=1000 no forward path do loop de realimentação unitária para modelar a constante de tempo, resultando em H(s) = K / (s + K), aproximando 1/(sτ + 1). Desenhe, simule e verifique a resposta a degrau.",
                              "finalVerifications": [
                                "O bloco de ganho está corretamente posicionado no loop.",
                                "Função de transferência derivada combina com o modelo físico.",
                                "Simulação mostra resposta estável e precisa.",
                                "Diagrama é legível com rótulos completos.",
                                "Ganhos dinâmicos/estáticos são distinguidos adequadamente.",
                                "Nenhuma conexão solta ou soma ausente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inserção e cálculo do ganho (30%)",
                                "Clareza e legibilidade do diagrama (20%)",
                                "Validação via função de transferência (20%)",
                                "Simulação correta e análise de resultados (20%)",
                                "Documentação de passos e justificativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Modelagem de filtros R-C em circuitos.",
                                "Controle Automático: Estabilidade em loops com ganhos variáveis.",
                                "Matemática: Transformadas de Laplace para linearização.",
                                "Engenharia Aeronáutica: Sistemas de controle de flight dynamics."
                              ],
                              "realWorldApplication": "Em aviões, incorpora ganhos em diagramas de blocos para modelar atuadores hidráulicos (com constantes de tempo) em sistemas de controle de voo autônomo, garantindo estabilidade e resposta precisa a perturbações como turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.4",
                        "name": "Blocos Funcionais",
                        "description": "Blocos genéricos que encapsulam funções de transferência ou operações não elementares, permitindo a representação compacta de sub-sistemas dinâmicos complexos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.4.1",
                            "name": "Definir um bloco funcional",
                            "description": "Descrever um bloco funcional como um retângulo rotulado com G(s) = Num(s)/Den(s), representando a relação de Laplace Y(s)/X(s) para análise em frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de bloco funcional",
                                  "subSteps": [
                                    "Estude a definição: um bloco funcional representa uma operação ou transformação em um diagrama de blocos.",
                                    "Identifique os elementos principais: entrada X(s), saída Y(s) e função de transferência G(s).",
                                    "Revise o domínio de Laplace: transformadas para análise em frequência.",
                                    "Analise exemplos simples de sistemas lineares invariantes no tempo (LTI).",
                                    "Diferencie bloco funcional de outros elementos como somadores ou ramificações."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é um bloco funcional e sua representação Y(s) = G(s) X(s).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas",
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre diagramas de blocos"
                                  ],
                                  "tips": "Use analogias como 'caixa preta' para visualizar a transformação de sinal.",
                                  "learningObjective": "Dominar a definição conceitual de bloco funcional em sistemas dinâmicos.",
                                  "commonMistakes": "Confundir com função de tempo em domínio temporal em vez de Laplace."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar matematicamente a função de transferência",
                                  "subSteps": [
                                    "Escreva G(s) = Num(s)/Den(s), onde Num(s) e Den(s) são polinômios em s.",
                                    "Entenda que G(s) = Y(s)/X(s) para sistemas LTI.",
                                    "Pratique com exemplos: G(s) = 1/s para integrador.",
                                    "Identifique pólos e zeros a partir de Num(s) e Den(s).",
                                    "Converta equações diferenciais em funções de transferência."
                                  ],
                                  "verification": "Converta uma equação diferencial simples em G(s) e verifique a relação Y(s)/X(s).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB/Simulink",
                                    "Tabela de transformadas de Laplace"
                                  ],
                                  "tips": "Sempre normalize o denominador para grau máximo e coeficiente líder 1.",
                                  "learningObjective": "Capacitar a derivação da função de transferência em domínio s.",
                                  "commonMistakes": "Esquecer de dividir por X(s) ou inverter Num/Den."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar e rotular o bloco funcional",
                                  "subSteps": [
                                    "Desenhe um retângulo como símbolo do bloco.",
                                    "Rotule a função de transferência dentro: G(s) = Num(s)/Den(s).",
                                    "Adicione setas de entrada (X(s)) à esquerda e saída (Y(s)) à direita.",
                                    "Inclua rótulos claros para sinais em domínio Laplace.",
                                    "Pratique em papel ou software, variando exemplos de G(s)."
                                  ],
                                  "verification": "Desenhe 3 blocos diferentes e peça feedback de um colega ou tutor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Software de diagrama como Draw.io ou Simulink"
                                  ],
                                  "tips": "Mantenha proporções padrão: retângulo horizontal com texto centralizado.",
                                  "learningObjective": "Habilitar a representação gráfica precisa do bloco funcional.",
                                  "commonMistakes": "Usar notação em tempo (t) em vez de Laplace (s) ou rotular incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em contexto de diagrama de blocos",
                                  "subSteps": [
                                    "Integre o bloco em um diagrama simples com somador e realimentação.",
                                    "Simule ou analise a resposta em frequência.",
                                    "Compare com software para validação.",
                                    "Documente o processo em um relatório curto.",
                                    "Discuta limitações para sistemas não lineares."
                                  ],
                                  "verification": "Construa um diagrama completo e calcule saída para entrada unitária.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB ou Python com Control Systems Library",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Comece com sistemas de primeira ordem para simplicidade.",
                                  "learningObjective": "Integrar blocos funcionais em análises de sistemas dinâmicos.",
                                  "commonMistakes": "Ignorar direção das setas ou confundir entrada/saída."
                                }
                              ],
                              "practicalExample": "Para um sistema RC de filtro passa-baixa com G(s) = 1/(RC s + 1), desenhe o bloco retangular rotulado G(s) = 1/(τ s + 1) onde τ=RC, com entrada X(s) (tensão de entrada) e saída Y(s) (tensão de saída). Simule em Simulink para verificar atenuação em altas frequências.",
                              "finalVerifications": [
                                "Desenhar corretamente um bloco com G(s) = Num(s)/Den(s).",
                                "Explicar verbalmente Y(s) = G(s) X(s).",
                                "Identificar entrada, saída e função de transferência em um diagrama dado.",
                                "Converter equação diferencial em bloco funcional.",
                                "Integrar em diagrama de blocos simples sem erros.",
                                "Simular e validar com software."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática de G(s).",
                                "Correção gráfica do retângulo e rótulos.",
                                "Compreensão conceitual de Laplace vs. tempo.",
                                "Capacidade de derivação de funções de transferência.",
                                "Aplicação em exemplos reais sem erros comuns.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e análise de polinômios.",
                                "Física: Modelagem de sistemas dinâmicos em circuitos e mecânica.",
                                "Programação: Simulações em MATLAB/Python para controle.",
                                "Engenharia de Controle: Linearização de modelos não lineares."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, blocos funcionais modelam atuadores de flaps ou estabilizadores em sistemas de controle de voo, permitindo análise de estabilidade e resposta em frequência para certificação de aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.2",
                            "name": "Construir diagrama usando blocos funcionais",
                            "description": "Montar um diagrama de blocos para um sistema em série ou paralelo, conectando blocos funcionais como G1(s) e G2(s) para obter transferência composta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e representar os blocos funcionais individuais",
                                  "subSteps": [
                                    "Analise a descrição do sistema para identificar os blocos funcionais, como G1(s) e G2(s).",
                                    "Escreva explicitamente a função de transferência de cada bloco (ex: G1(s) = 1/(s+1)).",
                                    "Desenhe cada bloco como um retângulo com seta de entrada à esquerda, saída à direita e rótulo interno G(s).",
                                    "Rotule as entradas (geralmente 'r' ou 'u') e saídas ('y') de cada bloco.",
                                    "Confirme que as funções de transferência correspondem ao contexto do sistema dinâmico."
                                  ],
                                  "verification": "Blocos individuais desenhados corretamente, com funções de transferência rotuladas e entradas/saídas claras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de diagramação (ex: Draw.io, MATLAB Simulink)",
                                    "Lápis, borracha e régua"
                                  ],
                                  "tips": "Use símbolos padronizados IEEE para blocos para facilitar reconhecimento.",
                                  "learningObjective": "Representar componentes individuais de um sistema como blocos funcionais básicos.",
                                  "commonMistakes": [
                                    "Omitir rótulos de funções de transferência.",
                                    "Inverter direções de entrada e saída."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir diagrama de blocos em configuração série",
                                  "subSteps": [
                                    "Posicione os blocos em linha horizontal, com G1(s) à esquerda de G2(s).",
                                    "Conecte a saída de G1(s) diretamente à entrada de G2(s) com uma seta reta.",
                                    "Adicione sinal de entrada comum ao primeiro bloco e sinal de saída final do último.",
                                    "Calcule e rotule a função de transferência composta: G_total(s) = G1(s) * G2(s).",
                                    "Verifique se não há ramificações ou somadores desnecessários."
                                  ],
                                  "verification": "Diagrama mostra cascata de blocos com conexão direta e função composta como produto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de diagramação",
                                    "Calculadora para funções simbólicas (ex: MATLAB ou papel)"
                                  ],
                                  "tips": "Multiplique numeradores e denominadores das funções para validar a composição.",
                                  "learningObjective": "Montar e representar sistemas em série usando blocos funcionais.",
                                  "commonMistakes": [
                                    "Adicionar somador desnecessário entre blocos.",
                                    "Esquecer de multiplicar as funções de transferência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir diagrama de blocos em configuração paralelo",
                                  "subSteps": [
                                    "Desenhe uma entrada comum dividida para as entradas de G1(s) e G2(s) usando ramificações.",
                                    "Posicione os blocos lado a lado verticalmente.",
                                    "Conecte as saídas de ambos blocos a um somador (círculo com +).",
                                    "Rotule a saída do somador como y e calcule G_total(s) = G1(s) + G2(s).",
                                    "Confirme que as ramificações da entrada não alteram os sinais."
                                  ],
                                  "verification": "Diagrama exibe entrada ramificada, blocos paralelos e somador na saída com soma das funções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de diagramação",
                                    "Símbolos padronizados para somador"
                                  ],
                                  "tips": "Use setas idênticas para ramificação de entrada para indicar sinal igual.",
                                  "learningObjective": "Montar e representar sistemas em paralelo usando blocos funcionais e somadores.",
                                  "commonMistakes": [
                                    "Colocar somador na entrada em vez da saída.",
                                    "Somar funções em vez de multiplicar no paralelo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e simplificar os diagramas construídos",
                                  "subSteps": [
                                    "Compare os diagramas série e paralelo com definições teóricas de conexão.",
                                    "Simplifique funções de transferência compostas (ex: fatorar ou cancelar termos).",
                                    "Teste equivalência substituindo valores numéricos simples para entradas.",
                                    "Identifique redundâncias ou erros de sinal nos diagramas.",
                                    "Documente as funções finais e desenhe versão limpa."
                                  ],
                                  "verification": "Ambos diagramas validados, funções simplificadas e sem erros detectados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy, MATLAB)",
                                    "Referência teórica de diagramas de blocos"
                                  ],
                                  "tips": "Simule com s=0 ou valores constantes para verificação rápida.",
                                  "learningObjective": "Garantir precisão e simplificação em diagramas de blocos compostos.",
                                  "commonMistakes": [
                                    "Ignorar cancelamentos em funções de transferência.",
                                    "Confundir soma com produto ao validar."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave, use G1(s) = 1/(s+1) para sensor de giroscópio e G2(s) = 10/s^2 para atuador de aileron. Construa diagrama série (G_total(s) = 10/(s^2(s+1))) para processamento sequencial e paralelo (G_total(s) = 1/(s+1) + 10/s^2) para combinação de sensores redundantes.",
                              "finalVerifications": [
                                "Todos blocos rotulados com funções de transferência corretas.",
                                "Conexões série mostram cascata sem interrupções.",
                                "Conexões paralelo incluem ramificação de entrada e somador de saída.",
                                "Funções compostas calculadas precisamente (produto para série, soma para paralelo).",
                                "Diagrama legível, com setas direcionais claras e sem cruzamentos confusos.",
                                "Simplificações aplicadas onde possível nos denominadores/numeradores."
                              ],
                              "assessmentCriteria": [
                                "Correção na identificação e representação de blocos individuais (20%)",
                                "Precisão das conexões e somadores no diagrama série (25%)",
                                "Precisão das ramificações e somadores no diagrama paralelo (25%)",
                                "Cálculo exato das funções de transferência compostas (20%)",
                                "Clareza, legibilidade e uso de símbolos padronizados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com funções racionais (multiplicação e soma de frações).",
                                "Física: Modelagem de sistemas dinâmicos lineares e equações diferenciais.",
                                "Programação: Implementação e simulação de diagramas em MATLAB/Simulink ou Python (Control Systems Library).",
                                "Engenharia de Controle: Integração em laços de feedback para análise de estabilidade."
                              ],
                              "realWorldApplication": "Diagramas de blocos em série e paralelo são essenciais no design de sistemas de controle de voo em aeronaves, modelando cascatas de sensores-atuadores (série) ou fusão de dados redundantes (paralelo) para garantir estabilidade e precisão em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.3",
                            "name": "Interpretar pontos de ramificação",
                            "description": "Utilizar pontos de ramificação (pickoff points) para dividir sinais de saída de blocos funcionais para múltiplas vias, como em estruturas de realimentação negativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Pontos de Ramificação",
                                  "subSteps": [
                                    "Defina ponto de ramificação (pickoff point) como o local onde o sinal de saída de um bloco funcional é dividido para alimentar múltiplas vias sem alteração de amplitude.",
                                    "Estude o símbolo gráfico: uma linha de sinal que se bifurca em duas ou mais direções.",
                                    "Aprenda que o sinal ramificado mantém a mesma magnitude em todas as vias, representando conservação de energia em modelos lineares.",
                                    "Diferencie de outros elementos: não é um somador (que combina sinais) nem um ganho (que amplifica).",
                                    "Revise exemplos iniciais em diagramas simples de sistemas de controle."
                                  ],
                                  "verification": "Desenhe um ponto de ramificação simples e explique sua função em uma frase curta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Imagem de diagrama de blocos básico"
                                  ],
                                  "tips": "Visualize o sinal como uma 'cópia idêntica' enviada para múltiplos destinos simultaneamente.",
                                  "learningObjective": "Dominar a definição, símbolo e propriedades fundamentais dos pontos de ramificação.",
                                  "commonMistakes": [
                                    "Confundir com somadores, assumindo combinação de sinais",
                                    "Acreditar que há atenuação ou ganho no ramificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Pontos de Ramificação em Diagramas Existentes",
                                  "subSteps": [
                                    "Analise um diagrama de blocos fornecido, procurando linhas que se dividem de uma saída para múltiplas entradas.",
                                    "Marque todos os pontos de ramificação com setas ou destaques.",
                                    "Verifique se o sinal de saída de um bloco funcional alimenta mais de uma entrada downstream.",
                                    "Pratique em diagramas progressivamente complexos, contando o número de ramificações.",
                                    "Registre o contexto: entrada, bloco origem e vias de destino para cada ramificação."
                                  ],
                                  "verification": "Liste todos os pontos de ramificação em um diagrama dado, com descrições breves de cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de blocos impressos ou digitais",
                                    "Marcadores ou software de edição como Draw.io"
                                  ],
                                  "tips": "Siga o fluxo do sinal da esquerda para a direita, pausando em cada bifurcação.",
                                  "learningObjective": "Desenvolver habilidade para localizar e anotar pontos de ramificação em representações gráficas.",
                                  "commonMistakes": [
                                    "Ignorar ramificações sutis em diagramas densos",
                                    "Confundir loops de realimentação com ramificações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Fluxo de Sinal Através de Pontos de Ramificação",
                                  "subSteps": [
                                    "Trace o caminho do sinal desde a origem até cada via ramificada, notando dependências.",
                                    "Calcule ou descreva o sinal em cada ramo (ex: se saída é X(s), cada ramo recebe X(s)).",
                                    "Analise impactos em estruturas como realimentação negativa, onde ramificação cria caminhos de feedback.",
                                    "Simule qualitativamente: como uma mudança na saída afeta todas as vias simultaneamente.",
                                    "Compare com equações algébricas: ramificação equivale a multiplicar por 1 em múltiplas termos."
                                  ],
                                  "verification": "Descreva o sinal em cada via de uma ramificação específica em um diagrama exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama com realimentação negativa",
                                    "Calculadora ou MATLAB para simulação básica"
                                  ],
                                  "tips": "Pense em termos de 'distribuição idêntica' do sinal, não divisão de potência.",
                                  "learningObjective": "Interpretar dinamicamente como os pontos de ramificação propagam sinais em sistemas.",
                                  "commonMistakes": [
                                    "Assumir atrasos ou perdas nos ramos",
                                    "Não considerar simultaneidade das vias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Pontos de Ramificação em Estruturas de Realimentação Negativa",
                                  "subSteps": [
                                    "Construa um diagrama simples de realimentação negativa com ramificação do sinal de erro.",
                                    "Identifique onde o pickoff point divide o sinal para controlador e medição de feedback.",
                                    "Modifique o diagrama adicionando ou removendo ramificações e observe mudanças no modelo.",
                                    "Derive a equação de transferência, destacando o papel da ramificação.",
                                    "Teste com um exemplo aeronáutico: ramificação de sinal de velocidade para atuador e monitor."
                                  ],
                                  "verification": "Crie e explique um diagrama de realimentação com pelo menos duas ramificações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software Simulink ou papel para desenho",
                                    "Exemplos de sistemas de controle aeronáuticos"
                                  ],
                                  "tips": "Sempre valide conservação: soma de entradas ramificadas deve igualar a saída original.",
                                  "learningObjective": "Aplicar interpretação de ramificações em contextos reais de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Esquecer sinal negativo no feedback",
                                    "Colocar ramificação após somador em vez de antes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de altitude de aeronave, o sinal de erro de altitude (saída do comparador) é ramificado em um pickoff point: uma via vai para o controlador de elevador, outra para o sistema de aviso de stall, garantindo que ambos recebam o mesmo sinal de erro sem perda.",
                              "finalVerifications": [
                                "Identificar corretamente 100% dos pontos de ramificação em um diagrama complexo.",
                                "Traçar e descrever fluxos de sinal através de todas as ramificações.",
                                "Explicar o impacto de uma ramificação em uma equação de transferência.",
                                "Modificar um diagrama adicionando uma ramificação e validar o modelo.",
                                "Aplicar conceito em um exemplo real de realimentação negativa sem erros.",
                                "Diferenciar ramificações de outros elementos em uma análise comparativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pickoff points (sem falsos positivos/negativos).",
                                "Correta interpretação do fluxo de sinal e conservação de magnitude.",
                                "Capacidade de integrar ramificações em análises de sistemas de controle.",
                                "Clareza na descrição verbal ou escrita do papel das ramificações.",
                                "Criatividade em aplicações práticas, como em cenários aeronáuticos.",
                                "Ausência de confusões com somadores, ganhos ou loops de feedback."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de sinais e manipulação de expressões em domínio de Laplace.",
                                "Física: Princípios de dinâmica linear e conservação de energia em sistemas.",
                                "Programação: Implementação de diagramas de blocos em MATLAB/Simulink.",
                                "Engenharia de Controle: Modelagem de sistemas fly-by-wire em aeronáutica.",
                                "Eletrônica: Divisores de sinal em circuitos analógicos equivalentes."
                              ],
                              "realWorldApplication": "Em aviônicos de aeronaves modernas, pontos de ramificação são usados em sistemas fly-by-wire para distribuir sinais de sensores IMU (inertial measurement unit) para atuadores de superfície de controle, computadores de voo redundantes e displays de cockpit, garantindo sincronia e confiabilidade em manobras críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Redução de Diagramas de Blocos",
                    "description": "Regras e técnicas para simplificar diagramas de blocos complexos, obtendo funções de transferência equivalentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Simplificação de Blocos em Série e Paralelo",
                        "description": "Regras básicas para combinar blocos de transferência conectados em série, onde as funções de transferência são multiplicadas, e em paralelo, onde são somadas, obtendo um bloco equivalente simplificado.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Redução de blocos em série",
                            "description": "Identificar configurações de dois ou mais blocos conectados em série e calcular a função de transferência equivalente multiplicando as funções de transferência individuais (G_eq(s) = G1(s) * G2(s) * ... * Gn(s)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de blocos em série",
                                  "subSteps": [
                                    "Defina função de transferência como a razão entre saída e entrada no domínio de Laplace.",
                                    "Explique que blocos em série têm saída de um bloco como entrada do próximo.",
                                    "Desenhe um diagrama simples com dois blocos G1(s) e G2(s) conectados em série.",
                                    "Mostre que a saída final Y(s) = G1(s) * G2(s) * U(s).",
                                    "Discuta por que a multiplicação ocorre devido à convolução no tempo."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de dois blocos em série e escreva a equação G_eq(s) = G1(s) * G2(s).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Sinais e Sistemas",
                                    "Acesso a vídeo introdutório sobre diagramas de blocos"
                                  ],
                                  "tips": "Visualize o sinal fluindo sequencialmente; lembre-se que série significa cascata sem ramificações.",
                                  "learningObjective": "Entender a definição e a justificativa matemática de blocos em série.",
                                  "commonMistakes": [
                                    "Confundir série com paralelo (adição em vez de multiplicação)",
                                    "Esquecer o domínio de Laplace (s)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar configurações de blocos em série em diagramas complexos",
                                  "subSteps": [
                                    "Analise um diagrama de blocos fornecido e circule blocos conectados diretamente em sequência.",
                                    "Ignore ramificações, somadores ou realimentações inicialmente.",
                                    "Agrupe sequências de 2 ou mais blocos em série.",
                                    "Rotule cada grupo como 'série' e liste suas funções G1, G2, etc.",
                                    "Pratique com 3 diagramas de dificuldade crescente."
                                  ],
                                  "verification": "Em um diagrama dado, identifique e liste todos os grupos de blocos em série com precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de blocos impressos ou digitais",
                                    "Marcadores coloridos",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Procure setas conectando saída diretamente à entrada seguinte sem intervenções.",
                                  "learningObjective": "Desenvolver habilidade para detectar padrões de série em diagramas reais.",
                                  "commonMistakes": [
                                    "Incluir somadores como parte da série",
                                    "Ignorar blocos com mais de dois"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a função de transferência equivalente",
                                  "subSteps": [
                                    "Escreva as funções individuais: G1(s), G2(s), ..., Gn(s).",
                                    "Multiplique-as: G_eq(s) = G1(s) × G2(s) × ... × Gn(s).",
                                    "Simplifique a expressão algébrica, cancelando termos comuns no numerador e denominador.",
                                    "Expresse em forma padrão (polinômio/ polinômio).",
                                    "Verifique o grau do denominador (deve aumentar com cada multiplicação)."
                                  ],
                                  "verification": "Calcule G_eq(s) para um grupo de 3 blocos e simplifique corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB/SymPy",
                                    "Folha de exercícios com funções exemplo",
                                    "Tabela de identidades algébricas"
                                  ],
                                  "tips": "Multiplique numeradores e denominadores separadamente para evitar erros.",
                                  "learningObjective": "Dominar a multiplicação e simplificação de funções de transferência racionais.",
                                  "commonMistakes": [
                                    "Erro em multiplicação polinomial",
                                    "Não cancelar fatores comuns",
                                    "Esquecer parênteses em frações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar a redução em um diagrama completo",
                                  "subSteps": [
                                    "Substitua o grupo em série pelo bloco equivalente G_eq(s) no diagrama original.",
                                    "Desenhe o novo diagrama simplificado.",
                                    "Calcule a função de transferência total se possível.",
                                    "Simule numericamente em software para validar (resposta ao degrau).",
                                    "Compare com o diagrama original para confirmar equivalência."
                                  ],
                                  "verification": "Reduza um diagrama completo e produza o diagrama simplificado com G_eq correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (control library)",
                                    "Exemplos de simulação prontos"
                                  ],
                                  "tips": "Sempre teste com entrada unitária para verificação rápida.",
                                  "learningObjective": "Integrar a redução em processos de simplificação maiores.",
                                  "commonMistakes": [
                                    "Não atualizar conexões após substituição",
                                    "Erro de sinal na simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama com três blocos em série: G1(s) = 1/(s+2), G2(s) = 3/(s+1), G3(s) = 1/s. A saída Y(s) = G1(s)*G2(s)*G3(s)*U(s) = [3 / (s(s+1)(s+2))] * U(s). Simplifique cancelando termos se houver e substitua pelo bloco único G_eq(s).",
                              "finalVerifications": [
                                "Identifica corretamente todos os blocos em série em um diagrama dado.",
                                "Calcula G_eq(s) sem erros algébricos para n≥3 blocos.",
                                "Simplifica a fração racional adequadamente.",
                                "Substitui corretamente no diagrama original.",
                                "Valida via simulação numérica (respostas coincidem).",
                                "Explica o processo em palavras claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de séries (90-100%).",
                                "Correção matemática na multiplicação e simplificação (100%).",
                                "Clareza no diagrama simplificado.",
                                "Eficiência na verificação (simulação ou análise).",
                                "Explicação pedagógica do processo.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de frações racionais e polinômios.",
                                "Física: Modelagem de sistemas lineares invariantes no tempo.",
                                "Programação: Implementação em MATLAB/Python para simulações.",
                                "Engenharia de Controle: Pré-requisito para análise de estabilidade."
                              ],
                              "realWorldApplication": "Em sistemas de controle de aeronaves, como a cascata de sensor (acelerômetro) → filtro → controlador → atuador (superfície de controle), onde a redução em série simplifica o modelo para projeto de controladores PID ou análise de resposta transitória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Redução de blocos em paralelo",
                            "description": "Identificar configurações de dois ou mais blocos conectados em paralelo saindo de um mesmo ponto de soma e calcular a função de transferência equivalente somando as funções individuais (G_eq(s) = G1(s) + G2(s) + ... + Gn(s)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de blocos em paralelo em diagramas de blocos",
                                  "subSteps": [
                                    "Revise a definição de diagrama de blocos: representação gráfica de sistemas dinâmicos com blocos (funções de transferência), somadores e pontos de ramificação.",
                                    "Identifique a configuração paralela: dois ou mais blocos saem do mesmo ponto de soma (entrada comum) e convergem para o mesmo ponto de soma posterior (saída comum).",
                                    "Entenda a propriedade matemática: em paralelo, as saídas dos blocos são somadas, resultando em G_eq(s) = G1(s) + G2(s) + ... + Gn(s).",
                                    "Compare com blocos em série (multiplicação) para reforçar a diferença.",
                                    "Desenhe um diagrama simples manualmente com 2 blocos paralelos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que blocos paralelos somam funções de transferência, citando a fórmula G_eq(s).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um diagrama de blocos básico online ou livro-texto de Sinais e Sistemas"
                                  ],
                                  "tips": "Visualize o sinal de entrada se propagando igualmente para todos os blocos paralelos.",
                                  "learningObjective": "Dominar a definição e propriedade fundamental de blocos em paralelo.",
                                  "commonMistakes": [
                                    "Confundir com configuração em série (multiplicação ao invés de soma)",
                                    "Ignorar que a entrada deve ser comum e saída somada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar configurações de blocos em paralelo em diagramas complexos",
                                  "subSteps": [
                                    "Analise um diagrama de blocos fornecido: procure por ramificações de um somador levando a múltiplos blocos que reconvergem em um somador.",
                                    "Marque visualmente os blocos paralelos com cores ou setas.",
                                    "Confirme critérios: mesma entrada, saídas somadas diretamente.",
                                    "Pratique em 3 diagramas de dificuldade crescente (2 blocos, 3 blocos, com ruído).",
                                    "Registre identificações em um caderno."
                                  ],
                                  "verification": "Apresente um diagrama e circule corretamente todos os conjuntos de blocos paralelos identificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de blocos impressos ou digitais (ex: MATLAB Simulink ou imagens de livros)",
                                    "Marcadores ou software de edição de imagem"
                                  ],
                                  "tips": "Comece pelo sinal de entrada e siga as ramificações; ignore loops de realimentação inicialmente.",
                                  "learningObjective": "Desenvolver habilidade de detecção precisa em diagramas reais.",
                                  "commonMistakes": [
                                    "Identificar erroneamente blocos em cascata como paralelos",
                                    "Não notar somadores implícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a função de transferência equivalente para blocos em paralelo",
                                  "subSteps": [
                                    "Escreva as funções individuais: G1(s), G2(s), etc., dos blocos identificados.",
                                    "Some algebricamente: G_eq(s) = G1(s) + G2(s) + ... + Gn(s), simplificando frações comuns se possível.",
                                    "Trate denominadores: encontre MMC e some numeradores.",
                                    "Verifique simplificação: cancele fatores comuns no numerador e denominador.",
                                    "Teste com valores numéricos (ex: s=0) para validar."
                                  ],
                                  "verification": "Calcule G_eq(s) para um exemplo dado e compare com solução modelo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: MATLAB, Wolfram Alpha)",
                                    "Folha de exercícios com funções de transferência"
                                  ],
                                  "tips": "Sempre escreva funções com denominadores comuns para soma precisa.",
                                  "learningObjective": "Executar cálculos algébricos corretos de soma de funções de transferência.",
                                  "commonMistakes": [
                                    "Somar numeradores sem MMC",
                                    "Esquecer de simplificar a fração resultante"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a redução no diagrama e validar o resultado",
                                  "subSteps": [
                                    "Substitua os blocos paralelos por um único bloco G_eq(s) no diagrama original.",
                                    "Redesenhe o diagrama simplificado.",
                                    "Simule numericamente (ex: resposta ao degrau) antes e depois para comparar.",
                                    "Analise impacto na resposta do sistema.",
                                    "Documente o processo completo em um relatório curto."
                                  ],
                                  "verification": "Submeta diagrama simplificado e G_eq(s); simulação bate com original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python Control Systems)",
                                    "Diagrama original"
                                  ],
                                  "tips": "Salve versões antes/depois para comparação visual.",
                                  "learningObjective": "Integrar identificação, cálculo e simplificação em um processo completo.",
                                  "commonMistakes": [
                                    "Não atualizar conexões após substituição",
                                    "Erros de propagação em cálculos simbólicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama com entrada R(s) somada a dois blocos paralelos: G1(s) = 2/(s+1) e G2(s) = 3/(s+2), saindo para Y(s). G_eq(s) = 2/(s+1) + 3/(s+2) = [2(s+2) + 3(s+1)] / [(s+1)(s+2)] = (5s + 7)/(s^2 + 3s + 2). Substitua por um bloco único G_eq(s).",
                              "finalVerifications": [
                                "Identifica corretamente blocos paralelos em um diagrama fornecido.",
                                "Calcula G_eq(s) sem erros algébricos para 3 exemplos.",
                                "Simplifica o diagrama corretamente substituindo blocos.",
                                "Valida resultado via simulação numérica (resposta coincide).",
                                "Explica o processo passo a passo verbalmente.",
                                "Aplica em diagrama com 3+ blocos paralelos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de configurações paralelas (100% corretas).",
                                "Correção algébrica no cálculo de G_eq(s), incluindo simplificação.",
                                "Qualidade do diagrama simplificado (conexões intactas).",
                                "Validação quantitativa via simulação ou teste numérico.",
                                "Clareza na documentação do processo.",
                                "Tempo de execução eficiente sem erros recorrentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de frações racionais e soma de funções (Análise Complexa).",
                                "Eletrônica: Analogia com resistores em paralelo (1/Req = 1/R1 + 1/R2).",
                                "Programação: Paralelismo em simulações (ex: threads somando saídas em Python).",
                                "Física: Sistemas mecânicos com molas em paralelo (keq = k1 + k2).",
                                "Engenharia de Controle: Redução em projetos de aeronaves (múltiplos atuadores)."
                              ],
                              "realWorldApplication": "Em sistemas de controle de aeronaves, como estabilização de voo, onde múltiplos sensores (acelerômetros paralelos) fornecem sinais somados para o controlador, permitindo redução do diagrama para análise de estabilidade e projeto de compensadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Combinação sequencial de série e paralelo",
                            "description": "Aplicar sucessivamente as regras de série e paralelo em diagramas com múltiplas configurações mistas para obter uma função de transferência única equivalente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o diagrama de blocos e identificar configurações iniciais de série e paralelo",
                                  "subSteps": [
                                    "Examine o diagrama completo, identificando pontos de soma e nós de conexão.",
                                    "Marque blocos diretamente em série (saída de um conectada diretamente à entrada do próximo).",
                                    "Marque blocos em paralelo (mesma entrada e saídas somadas).",
                                    "Priorize configurações mistas sequenciais (série seguida de paralelo ou vice-versa).",
                                    "Desenhe uma cópia anotada do diagrama destacando as configurações identificadas."
                                  ],
                                  "verification": "Verifique se todas as configurações série e paralelo estão destacadas corretamente no diagrama anotado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de blocos impresso ou digital",
                                    "Papel, lápis e régua",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Comece pelos pontos de soma, pois eles indicam paralelos; use cores diferentes para série (azul) e paralelo (vermelho).",
                                  "learningObjective": "Desenvolver habilidade para reconhecer padrões básicos de interconexão em diagramas complexos.",
                                  "commonMistakes": [
                                    "Ignorar configurações aninhadas",
                                    "Confundir soma com configuração em série"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar redução de blocos em série sucessivamente",
                                  "subSteps": [
                                    "Selecione a configuração de série mais simples (ex: G1 em série com G2).",
                                    "Calcule a função de transferência equivalente: G_eq = G1 * G2.",
                                    "Substitua os blocos originais por G_eq no diagrama.",
                                    "Atualize conexões de entrada e saída afetadas.",
                                    "Repita para todas as séries sequenciais identificadas."
                                  ],
                                  "verification": "Confirme que cada multiplicação resulta em uma fração simplificada e o diagrama foi atualizado sem perda de conexões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Simulink para cálculos simbólicos",
                                    "Diagrama anotado do passo 1"
                                  ],
                                  "tips": "Simplifique frações imediatamente após multiplicar para evitar expressões complexas.",
                                  "learningObjective": "Dominar a regra de série para reduzir diagramas mistos passo a passo.",
                                  "commonMistakes": [
                                    "Esquecer de propagar sinais de entrada/saída",
                                    "Não simplificar polos e zeros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar redução de blocos em paralelo após as séries",
                                  "subSteps": [
                                    "Identifique novas configurações de paralelo reveladas pelas reduções de série.",
                                    "Calcule G_eq = G_a + G_b para paralelos diretos.",
                                    "Para retroalimentações, ajuste adequadamente (ex: 1/(1/G_a + 1/G_b) se indireto).",
                                    "Substitua e atualize o diagrama.",
                                    "Verifique se restam configurações mistas e repita se necessário."
                                  ],
                                  "verification": "Teste a equivalência somando funções e comparando com o diagrama original via simulação simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SymPy) para validação numérica",
                                    "Diagrama atualizado do passo 2"
                                  ],
                                  "tips": "Use soma algébrica comum para paralelos; fatorize numeradores/denominadores para clareza.",
                                  "learningObjective": "Aplicar regra de paralelo em contextos sequenciais mistos.",
                                  "commonMistakes": [
                                    "Confundir paralelo com soma direta sem ajuste de ganhos",
                                    "Erros em frações invertidas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter e validar a função de transferência única equivalente",
                                  "subSteps": [
                                    "Combine todas as reduções restantes em um único bloco G_total.",
                                    "Escreva a função de transferência final: G(s) = num(s)/den(s).",
                                    "Simplifique cancelando polos e zeros comuns.",
                                    "Simule resposta a um degrau para comparar com o diagrama original.",
                                    "Documente todas as etapas em um relatório resumido."
                                  ],
                                  "verification": "A função final deve produzir a mesma saída que o diagrama original para entradas teste (ex: degrau unitário).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink ou Python Control Systems)",
                                    "Relatório de etapas anteriores"
                                  ],
                                  "tips": "Sempre valide com simulação numérica para detectar erros algébricos.",
                                  "learningObjective": "Integrar reduções sequenciais para uma representação única e verificável.",
                                  "commonMistakes": [
                                    "Não cancelar fatores comuns",
                                    "Ignorar estabilidade da função final"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama com entrada R(s) somando a feedback, G1 em série com paralelo de (G2 e G3), seguido de G4 em série. Reduza: primeiro G1*(G2+G3), depois multiplique por G4, obtendo G_total = G1*(G2+G3)*G4.",
                              "finalVerifications": [
                                "Diagrama reduzido a um único bloco com função de transferência equivalente.",
                                "Cálculos algébricos sem erros de multiplicação/soma.",
                                "Simulação confirma mesma resposta transitória/permanente.",
                                "Todas as configurações mistas foram reduzidas sequencialmente.",
                                "Função simplificada sem polos/zeros canceláveis restantes.",
                                "Documentação completa das etapas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 100% das configurações série/paralelo.",
                                "Correção matemática em todas as reduções (sem erros >5%).",
                                "Eficiência na sequência de reduções (mínimo de passos desnecessários).",
                                "Validação via simulação com erro <1% em respostas.",
                                "Clareza na documentação e simplificação final.",
                                "Tempo total dentro do estimado (2 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de frações racionais e manipulação de Laplace.",
                                "Física: Modelagem dinâmica de sistemas lineares invariantes no tempo.",
                                "Programação: Implementação em Python/MATLAB para automação de reduções.",
                                "Engenharia de Controle: Análise de estabilidade em sistemas aeronáuticos."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, essa técnica é usada para simplificar diagramas de controle de voo autônomo (autopilot), reduzindo modelos complexos de sensores e atuadores a uma função de transferência única para análise de estabilidade e projeto de compensadores em aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Eliminação de Laços de Realimentação Unitária",
                        "description": "Técnicas para remover laços de realimentação com ganho unitário (H(s)=1), calculando a função de transferência equivalente do caminho direto ajustada pelo laço.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Eliminação de realimentação unitária no caminho de retorno",
                            "description": "Identificar um laço de realimentação unitária no feedback e calcular a função equivalente do bloco forward como G_eq(s) = G(s) / (1 + G(s)H(s)), com H(s)=1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de realimentação unitária no caminho de retorno",
                                  "subSteps": [
                                    "Revise a estrutura básica de um diagrama de blocos com realimentação negativa.",
                                    "Identifique o que significa 'realimentação unitária': H(s) = 1, ou seja, ganho de realimentação é 1 sem processamento adicional.",
                                    "Diferencie realimentação no caminho de retorno (feedback path) de outros loops.",
                                    "Desenhe um diagrama simples com G(s) no forward path e H(s)=1 no feedback.",
                                    "Explique verbalmente por que isso cria um loop unitário."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama e explique o loop para um colega ou grave um vídeo de 1 minuto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software como MATLAB/Simulink para diagramas",
                                    "Livro-texto de Sistemas de Controle (ex: Ogata)"
                                  ],
                                  "tips": "Sempre rotule os caminhos claramente: forward G(s), feedback H(s)=1.",
                                  "learningObjective": "Entender a topologia do laço unitário no feedback.",
                                  "commonMistakes": [
                                    "Confundir com realimentação no forward path",
                                    "Assumir H(s) ≠ 1 sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o laço de realimentação unitária em um diagrama dado",
                                  "subSteps": [
                                    "Analise um diagrama de blocos complexo e localize o feedback path.",
                                    "Confirme se H(s) = 1 (ganho unitário, sem função de transferência adicional).",
                                    "Marque o loop unitário destacando G(s) e o retorno unitário.",
                                    "Verifique se o loop está puramente no caminho de retorno sem soma externa.",
                                    "Anote a equação de sinal de saída antes da redução: Y(s) = G(s) E(s), E(s) = R(s) - Y(s)."
                                  ],
                                  "verification": "Anote e circule o loop corretamente em um diagrama impresso ou digital.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de blocos exemplo impresso",
                                    "Ferramenta de desenho como Draw.io ou Visio"
                                  ],
                                  "tips": "Procure por setas de feedback diretas sem blocos intermediários.",
                                  "learningObjective": "Desenvolver habilidade de reconhecimento visual do loop unitário.",
                                  "commonMistakes": [
                                    "Ignorar somadores no loop",
                                    "Confundir com ganho não-unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e calcular a função de transferência equivalente G_eq(s)",
                                  "subSteps": [
                                    "Escreva as equações de sinal: E(s) = R(s) - B(s), B(s) = Y(s) * H(s), com H(s)=1 então B(s)=Y(s).",
                                    "Y(s) = G(s) E(s) = G(s) (R(s) - Y(s)).",
                                    "Resolva para Y(s)/R(s): Y(s) + G(s) Y(s) = G(s) R(s) → Y(s) (1 + G(s)) = G(s) R(s).",
                                    "Assim, T(s) = G(s) / (1 + G(s)), e substitua o loop por G_eq(s) = G(s) / (1 + G(s)).",
                                    "Simplifique algebricamente para um G(s) exemplo, como G(s) = 1/(s+1)."
                                  ],
                                  "verification": "Derive a fórmula passo a passo e compute G_eq(s) para G(s)=K/s, obtendo G_eq(s)=K/(s+K).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo simbólica",
                                    "Calculadora ou MATLAB Symbolic Toolbox"
                                  ],
                                  "tips": "Use álgebra de Laplace: isole Y(s) em um lado da equação.",
                                  "learningObjective": "Mestre a derivação matemática da redução do loop.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo da realimentação",
                                    "Dividir incorretamente por (1 + G(s)H(s)) com H≠1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a eliminação em um diagrama completo e validar",
                                  "subSteps": [
                                    "Substitua o loop unitário por um único bloco G_eq(s).",
                                    "Redesenhe o diagrama reduzido sem o loop.",
                                    "Calcule a função de transferência total do sistema reduzido.",
                                    "Simule numericamente em software para comparar original vs reduzido.",
                                    "Verifique se as respostas coincidem em resposta ao degrau."
                                  ],
                                  "verification": "Simulação mostra erro <1% entre diagramas original e reduzido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python (control library)",
                                    "Diagrama exemplo com G(s)=10/(s^2 + s + 1)"
                                  ],
                                  "tips": "Sempre teste com entrada unitária para validação.",
                                  "learningObjective": "Integrar a técnica em reduções maiores de diagramas.",
                                  "commonMistakes": [
                                    "Não atualizar conexões downstream após remoção",
                                    "Erro em simplificação polinomial"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de atitude de aeronave, diagrama com G(s) = 10 / (s(s+2)) no forward e feedback unitário. Elimine o loop: G_eq(s) = 10 / (s(s+2) + 10) = 10 / (s^2 + 2s + 10). Isso simplifica análise de estabilidade.",
                              "finalVerifications": [
                                "Identifica corretamente loops unitários em 3 diagramas diferentes.",
                                "Deriva G_eq(s) sem erros para G(s) dado.",
                                "Redesenha diagrama reduzido idêntico ao esperado.",
                                "Simulação valida equivalência (respostas coincidem).",
                                "Explica verbalmente o processo em <2 minutos.",
                                "Aplica em diagrama com múltiplos loops."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do loop (100% correto).",
                                "Correção algébrica na derivação de G_eq(s).",
                                "Qualidade do diagrama reduzido (conexões corretas).",
                                "Validação numérica/simulada sem discrepâncias.",
                                "Clareza na explicação escrita/oral.",
                                "Eficiência temporal (dentro de 90 min total)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de funções de transferência e manipulação de frações racionais.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos (ex: equações de movimento).",
                                "Programação: Simulação em MATLAB/Python para controle systems.",
                                "Engenharia Elétrica: Análise de circuitos em malha de realimentação.",
                                "Estatística: Análise de erro em simulações de validação."
                              ],
                              "realWorldApplication": "Em sistemas de controle de voo autônomo de drones ou aviões (ex: autopilot), redução de diagramas unitários simplifica design de controladores PID, permitindo análise rápida de estabilidade e desempenho em estabilização de atitude durante turbulências."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Eliminação de realimentação unitária no caminho direto",
                            "description": "Identificar um laço de realimentação unitária no forward path e simplificar para G_eq(s) = 1 / (1 + G(s)), removendo o laço e ajustando o ganho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o laço de realimentação unitária no caminho direto",
                                  "subSteps": [
                                    "Examine o diagrama de blocos completo, focando no forward path da entrada para a saída.",
                                    "Procure por um ponto de soma onde há um sinal de realimentação com ganho unitário (H=1) retornando diretamente para ele.",
                                    "Confirme que o laço está no caminho direto (forward path) e não envolve outros blocos complexos.",
                                    "Marque visualmente o laço, destacando o ganho G(s) dentro dele e o ponto de soma.",
                                    "Anote a posição exata do laço no diagrama para referência futura."
                                  ],
                                  "verification": "O laço está corretamente identificado e marcado no diagrama, com G(s) isolado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de blocos impresso ou digital",
                                    "Lápis e papel para anotações",
                                    "Software de diagramação como MATLAB Simulink ou Draw.io"
                                  ],
                                  "tips": "Comece sempre pela entrada e siga o sinal forward; unitário significa ganho de realimentação exatamente 1.",
                                  "learningObjective": "Reconhecer visualmente um laço de realimentação unitária no forward path.",
                                  "commonMistakes": [
                                    "Confundir com laços de realimentação não unitários (H≠1)",
                                    "Ignorar laços em caminhos paralelos",
                                    "Identificar laços no feedback path como forward"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Isolar e extrair o ganho G(s) do laço",
                                  "subSteps": [
                                    "Desenhe o laço isolado, mostrando input do ponto de soma -> G(s) -> output do laço, com feedback unitário.",
                                    "Verifique se G(s) é o único elemento no forward do laço; se houver série, combine-os primeiro.",
                                    "Registre a função de transferência G(s) explicitamente, como G(s) = K/(s+1).",
                                    "Confirme o sinal de feedback: negativo para estabilidade típica em sistemas de controle.",
                                    "Copie G(s) para uso no cálculo equivalente."
                                  ],
                                  "verification": "G(s) está extraído e escrito corretamente, com diagrama isolado desenhado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simbólica ou MATLAB para funções complexas"
                                  ],
                                  "tips": "Use setas para indicar direção do sinal e sinal (+/-) no ponto de soma.",
                                  "learningObjective": "Extrair precisamente o ganho de um laço unitário para simplificação.",
                                  "commonMistakes": [
                                    "Incluir blocos externos no G(s)",
                                    "Esquecer o sinal de feedback",
                                    "Usar H(s) em vez de 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o ganho equivalente G_eq(s)",
                                  "subSteps": [
                                    "Aplique a fórmula para laço unitário no forward path: G_eq(s) = 1 / (1 + G(s)).",
                                    "Substitua G(s) na fórmula e simplifique algebricamente se possível.",
                                    "Verifique o denominador: deve ser 1 + G(s) para feedback negativo unitário.",
                                    "Escreva G_eq(s) em forma simplificada, como fração própria.",
                                    "Compare com a transferência fechada esperada para validação inicial."
                                  ],
                                  "verification": "G_eq(s) calculado está correto e simplificado, com passos algébricos mostrados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Software como Mathematica ou SymPy para simplificação simbólica"
                                  ],
                                  "tips": "Lembre-se: para feedback unitário direto, é 1/(1+G(s)); teste com G(s)=1 para G_eq=0.5.",
                                  "learningObjective": "Dominar a fórmula de simplificação para laços unitários no forward path.",
                                  "commonMistakes": [
                                    "Usar G/(1+G) em vez de 1/(1+G)",
                                    "Esquecer parênteses no denominador",
                                    "Invertir sinal de feedback"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Substituir o laço pelo ganho equivalente e verificar o diagrama",
                                  "subSteps": [
                                    "Remova o laço completo do diagrama original (ponto de soma, G(s) e linha de feedback).",
                                    "Insira um único bloco com G_eq(s) no local exato do forward path onde o laço estava.",
                                    "Redesenhe o diagrama simplificado e confirme que os sinais de entrada/saída permanecem conectados corretamente.",
                                    "Calcule a transferência overall antes/depois para validar equivalência.",
                                    "Anote mudanças e guarde ambas versões para comparação."
                                  ],
                                  "verification": "Diagrama simplificado é equivalente, com transferência overall idêntica à original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de simulação como Simulink",
                                    "Ferramentas de plotagem de Bode para verificação"
                                  ],
                                  "tips": "Sempre valide com um sinal de teste unitário step response.",
                                  "learningObjective": "Aplicar a substituição corretamente e validar a redução.",
                                  "commonMistakes": [
                                    "Deixar resquícios do laço",
                                    "Colocar G_eq no lugar errado",
                                    "Não verificar equivalência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama com forward path contendo um laço unitário em torno de G(s) = 1/s (integrador com feedback unitário). Identifique o laço, isole G(s)=1/s, calcule G_eq(s) = 1 / (1 + 1/s) = s/(s+1). Substitua: o laço vira um bloco s/(s+1), simplificando o diagrama para análise posterior de estabilidade em controle de atitude de aeronaves.",
                              "finalVerifications": [
                                "Pode identificar corretamente laços unitários em 90% dos diagramas testados.",
                                "Calcula G_eq(s) sem erros algébricos em exemplos variados.",
                                "Substitui o laço mantendo a transferência overall inalterada.",
                                "Explica a fórmula e sua derivada de Mason's rule.",
                                "Valida simplificação via simulação numérica.",
                                "Identifica quando a fórmula NÃO se aplica (ex: H≠1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do laço (visual e descritiva).",
                                "Correção matemática do cálculo de G_eq(s) (100% match).",
                                "Qualidade do diagrama simplificado (conexões corretas).",
                                "Validação quantitativa (transfer functions iguais).",
                                "Explicação clara dos passos e justificativa da fórmula.",
                                "Eficiência temporal e ausência de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de funções racionais e simplificação de frações.",
                                "Programação: Implementação em Python/MATLAB para automação de redução de blocos.",
                                "Física: Modelagem de sistemas dinâmicos em mecânica de voo.",
                                "Engenharia de Controle: Pré-requisito para análise de estabilidade (Routh-Hurwitz).",
                                "Estatística: Verificação via Monte Carlo simulations de respostas."
                              ],
                              "realWorldApplication": "Em sistemas de controle de aeronaves, como estabilização de atitude em drones ou aviões, essa técnica reduz diagramas complexos de autômatos de voo, permitindo análise rápida de estabilidade e projeto de compensadores PID para manobras precisas e seguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Regras de Movimentação de Pontos de Soma e Derivação",
                        "description": "Regras para reposicionar pontos de soma e derivação em relação a blocos de transferência sem alterar a função de transferência global do diagrama.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Movimentação de ponto de soma para antes ou após bloco",
                            "description": "Aplicar a regra de mover um ponto de soma através de um bloco de transferência G(s), ajustando entradas como E(s) = [U(s) ± G(s)V(s)] / G(s) ou similar, mantendo equivalência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a regra de movimentação do ponto de soma para a direita (após o bloco G(s))",
                                  "subSteps": [
                                    "Desenhe um diagrama básico: U(s) e V(s) somam em E(s), E(s) entra em G(s) produzindo Y(s) = G(s) [U(s) + V(s)].",
                                    "Derive algebricamente: Y(s) = G(s)U(s) + G(s)V(s).",
                                    "Redesenhe o diagrama com G(s)U(s) e G(s)V(s) somando diretamente em Y(s), movendo o ponto de soma após G(s).",
                                    "Confirme equivalência expandindo a nova expressão.",
                                    "Repita para soma subtrativa: U(s) - V(s)."
                                  ],
                                  "verification": "A expressão de Y(s) é idêntica em ambos os diagramas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simbólica ou software como MATLAB"
                                  ],
                                  "tips": "Multiplique TODAS as entradas do ponto de soma por G(s), preservando sinais (+ ou -).",
                                  "learningObjective": "Dominar a regra de multiplicação das entradas por G(s) ao mover o ponto de soma para após o bloco.",
                                  "commonMistakes": [
                                    "Multiplicar apenas uma entrada",
                                    "Inverter o sinal na subtração",
                                    "Esquecer G(s) em uma das ramificações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a regra de movimentação do ponto de soma para a esquerda (antes do bloco G(s))",
                                  "subSteps": [
                                    "Desenhe diagrama: U(s)G(s) e V(s) somam em Y(s) = G(s)U(s) + V(s).",
                                    "Derive: Y(s) = G(s) [U(s) + V(s)/G(s)].",
                                    "Redesenhe com U(s) e V(s)/G(s) somando em E(s), então G(s)E(s) = Y(s).",
                                    "Verifique algebricamente a equivalência.",
                                    "Adapte para subtração: ajuste E(s) = [U(s) ± V(s)/G(s)]."
                                  ],
                                  "verification": "Simule numericamente com valores de G(s), U(s), V(s) e compare Y(s).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de transformadas de Laplace",
                                    "MATLAB ou Python (SymPy)"
                                  ],
                                  "tips": "Divida APENAS a entrada não afetada pelo bloco por G(s); preserve causalidade.",
                                  "learningObjective": "Aplicar divisão por G(s) corretamente ao mover o ponto de soma para antes do bloco.",
                                  "commonMistakes": [
                                    "Dividir U(s) em vez de V(s)",
                                    "Não inverter sinal em casos subtrativos",
                                    "Ignorar pólos/zeros introduzidos por 1/G(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar aplicação das regras em diagramas simples",
                                  "subSteps": [
                                    "Selecione um diagrama com um bloco G(s) e ponto de soma adjacente.",
                                    "Identifique direção de movimentação (esquerda ou direita).",
                                    "Aplique a regra correspondente, ajustando entradas.",
                                    "Desenhe o novo diagrama e verifique equivalência algébrica.",
                                    "Repita com 2-3 variações, incluindo subtração."
                                  ],
                                  "verification": "O diagrama reduzido produz a mesma função de transferência Y(s)/U(s).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Folhas de exercícios com diagramas impressos",
                                    "Software de diagramas de blocos como Simulink"
                                  ],
                                  "tips": "Sempre anote a expressão algébrica antes e depois da transformação.",
                                  "learningObjective": "Executar transformações fluentemente em configurações básicas.",
                                  "commonMistakes": [
                                    "Confundir direção da movimentação",
                                    "Esquecer ajuste de sinal",
                                    "Não verificar todas as entradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar em redução de diagramas complexos",
                                  "subSteps": [
                                    "Pegue um diagrama com múltiplos blocos e pontos de soma.",
                                    "Escolha um ponto de soma para mover através de G(s) adjacente.",
                                    "Aplique a regra, simplifique o diagrama resultante.",
                                    "Calcule funções de transferência antes/depois para validar.",
                                    "Otimize o diagrama completo usando múltiplas movimentações."
                                  ],
                                  "verification": "Função de transferência final coincide em simulações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagramas complexos de exemplo",
                                    "MATLAB/Simulink para simulação"
                                  ],
                                  "tips": "Use movimentação para isolar blocos ou alinhar com regras de série/paralelo.",
                                  "learningObjective": "Integrar a regra em processos de redução completos com verificação.",
                                  "commonMistakes": [
                                    "Aplicar regra em blocos não lineares",
                                    "Perder rastreamento de ramificações",
                                    "Não validar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Diagrama original: U(s) → (+) ← V(s) → E(s) → G(s) → Y(s). Equivalente: U(s) → G(s) → (+) ← [V(s) → G(s)] → Y(s). Y(s) = G(s)(U(s) + V(s)) em ambos. Para inverso: U(s) → G(s) → (+) ← V(s) → Y(s) torna-se U(s) → (+) ← [V(s)/G(s)] → E(s) → G(s) → Y(s).",
                              "finalVerifications": [
                                "Deriva corretamente a equivalência algébrica para 3 diagramas dados.",
                                "Transforma diagramas sem erros de sinal ou fator G(s).",
                                "Simula e compara saídas em software para validação.",
                                "Explica impacto de pólos/zeros em 1/G(s).",
                                "Aplica em diagrama com 4+ blocos corretamente.",
                                "Identifica quando a regra não se aplica (ex: realimentação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (100% match).",
                                "Correção de sinais e fatores G(s)/1/G(s).",
                                "Clareza nos diagramas desenhados.",
                                "Tempo de execução eficiente (< tempo estimado).",
                                "Validação por simulação ou álgebra.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de funções de transferência e manipulação simbólica.",
                                "Física: Modelagem dinâmica de sistemas lineares invariantes no tempo.",
                                "Programação: Implementação de diagramas em Simulink ou Python Control Systems Library.",
                                "Engenharia de Software: Refatoração de modelos para otimização computacional."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, simplifica diagramas de blocos de sistemas de controle de voo (ex: autôpilotos), permitindo análise rápida de estabilidade, redução de complexidade em simulações de voo e projeto eficiente de controladores para estabilização de aeronaves sob turbulência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Movimentação de ponto de derivação para antes ou após bloco",
                            "description": "Aplicar a regra de mover um ponto de derivação (take-off point) através de um bloco G(s), escalando a saída como V(s) = U(s)/G(s) ou V(s) = G(s)U(s), preservando a estrutura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de pontos de derivação e blocos em diagramas",
                                  "subSteps": [
                                    "Desenhe um diagrama simples com entrada U(s), bloco G(s) e saída Y(s) = G(s)U(s).",
                                    "Identifique o ponto de derivação (take-off point) após o bloco G(s), onde V(s) = Y(s) = G(s)U(s).",
                                    "Explique verbalmente a direção do fluxo de sinal e o que significa mover o ponto através do bloco.",
                                    "Compare configurações: take-off antes vs. após o bloco.",
                                    "Anote as equações equivalentes para cada posição."
                                  ],
                                  "verification": "Desenho correto do diagrama com ponto de derivação identificado e equações escritas.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos de diagramas de blocos impressos",
                                    "Livro-texto de teoria de controle (ex: Ogata)"
                                  ],
                                  "tips": "Sempre rotule claramente U(s), Y(s) e V(s) para evitar confusões.",
                                  "learningObjective": "Identificar pontos de derivação e entender sua relação algébrica com blocos G(s).",
                                  "commonMistakes": "Confundir ponto de derivação com ponto de soma; ignorar a direção do fluxo de sinal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Movimentar ponto de derivação para antes do bloco (inserir G(s) no ramo)",
                                  "subSteps": [
                                    "Parta de take-off após G(s), onde V(s) = G(s)U(s).",
                                    "Desloque o take-off para a entrada U(s) do bloco.",
                                    "Insira um bloco G(s) em série no ramo de derivação: V(s) = G(s) × U(s).",
                                    "Desenhe o novo diagrama e escreva a equação de V(s).",
                                    "Confirme que V(s) permanece igual à original."
                                  ],
                                  "verification": "Diagrama modificado desenhado com G(s) no ramo e equação V(s) = G(s)U(s) confirmada.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Software de desenho como Draw.io ou Simulink (opcional)"
                                  ],
                                  "tips": "Use setas grossas para o ramo principal e finas para o derivado para visualização clara.",
                                  "learningObjective": "Aplicar corretamente o escalar G(s)U(s) ao mover o take-off upstream (para antes).",
                                  "commonMistakes": "Esquecer de inserir G(s) no ramo, resultando em V(s) = U(s) incorreto; inverter com 1/G(s)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Movimentar ponto de derivação para após o bloco (inserir 1/G(s) no ramo)",
                                  "subSteps": [
                                    "Parta de take-off antes de G(s), onde V(s) = U(s).",
                                    "Desloque o take-off para a saída Y(s) = G(s)U(s) do bloco.",
                                    "Insira um bloco 1/G(s) em série no ramo de derivação: V(s) = Y(s)/G(s) = U(s).",
                                    "Desenhe o novo diagrama e verifique a equação de V(s).",
                                    "Confirme preservação da estrutura original."
                                  ],
                                  "verification": "Diagrama com 1/G(s) no ramo desenhado e equação V(s) = U(s) validada.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para manipulação simbólica",
                                    "Exemplos digitais em MATLAB/Simulink"
                                  ],
                                  "tips": "Teste com G(s) numérico simples (ex: G(s)=2) para validar numericamente.",
                                  "learningObjective": "Aplicar corretamente o escalar U(s)/G(s) ao mover o take-off downstream (para após).",
                                  "commonMistakes": "Usar G(s) em vez de 1/G(s), alterando o valor de V(s); não normalizar a equação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência e aplicar em diagrama completo",
                                  "subSteps": [
                                    "Compare equações originais e modificadas algebraicamente.",
                                    "Aplique a regra em um diagrama com múltiplos blocos e um take-off.",
                                    "Redesenhe o diagrama simplificado e compute a função de transferência geral.",
                                    "Simule numericamente se possível para validar.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Equações iguais antes/depois e diagrama simplificado correto.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Software Simulink ou Python (Control library)",
                                    "Papel para anotações",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Sempre verifique se a saída principal Y(s) permanece inalterada.",
                                  "learningObjective": "Validar a preservação da estrutura do diagrama após movimentação.",
                                  "commonMistakes": "Alterar acidentalmente a saída principal; ignorar polos/zeros introduzidos incorretamente."
                                }
                              ],
                              "practicalExample": "Considere U(s) → [G(s)] → Y(s), com take-off após G(s): V(s) = Y(s) = G(s)U(s). Mover para antes: U(s) → take-off → [G(s) no ramo] → V(s) = G(s)U(s), e U(s) → [G(s)] → Y(s). Equivalência: ambos V(s) = G(s)U(s). Inverso: take-off antes V(s)=U(s), mover após: Y(s) → take-off → [1/G(s)] → V(s) = Y(s)/G(s) = U(s).",
                              "finalVerifications": [
                                "Consegue mover take-off em ambas direções sem alterar V(s).",
                                "Desenha diagramas equivalentes corretamente.",
                                "Valida algebraicamente V(s) original = V(s) modificado.",
                                "Identifica erros comuns em exemplos dados.",
                                "Aplica em diagrama com 2-3 blocos.",
                                "Explica a regra em palavras próprias."
                              ],
                              "assessmentCriteria": [
                                "Precisão no escalar: G(s) para antes, 1/G(s) para após.",
                                "Preservação exata da equação de V(s) e Y(s).",
                                "Clareza nos desenhos de diagramas.",
                                "Correta identificação de direção de movimento.",
                                "Validação algébrica completa.",
                                "Aplicação em exemplo complexo sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de funções de transferência e manipulação simbólica.",
                                "Programação: Simulação em MATLAB/Simulink ou Python (biblioteca control).",
                                "Física: Modelagem dinâmica de sistemas lineares invariantes no tempo.",
                                "Engenharia Mecânica: Análise de laços de controle em estruturas aeronáuticas.",
                                "Informática: Representação gráfica de sistemas em ferramentas CAD."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, essa regra simplifica diagramas de blocos complexos em sistemas de controle de voo, como autothrottle ou estabilização de atitude em aeronaves, permitindo análise rápida de estabilidade (ex: critérios de Routh-Hurwitz) e redução de ordem de modelos para simulações em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Aplicação combinada de regras de movimentação",
                            "description": "Usar múltiplas movimentações de soma e derivação em diagramas complexos para isolar configurações redutíveis como série, paralelo ou laços unitários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Inicial do Diagrama de Blocos Complexo",
                                  "subSteps": [
                                    "Examine o diagrama completo, identificando todos os pontos de soma (+) e derivação (ramificações).",
                                    "Marque blocos em série, paralelo ou laços unitários visíveis.",
                                    "Desenhe uma cópia do diagrama e anote os ganhos (G1, G2, etc.) de cada bloco.",
                                    "Identifique caminhos de sinal principais e feedback loops.",
                                    "Registre o número total de blocos e pontos de soma/derivação."
                                  ],
                                  "verification": "Lista completa de pontos de soma/derivação e configurações potenciais anotada no diagrama.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de diagramação (ex: Draw.io, MATLAB Simulink)",
                                    "Lápis e borracha",
                                    "Referência às regras básicas de movimentação"
                                  ],
                                  "tips": "Comece pelos pontos de soma mais acessíveis; use cores diferentes para somas e derivações.",
                                  "learningObjective": "Compreender a estrutura global do diagrama para planejar reduções eficientes.",
                                  "commonMistakes": [
                                    "Ignorar laços de feedback ocultos",
                                    "Confundir soma com derivação",
                                    "Não anotar ganhos iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação de Configurações Redutíveis e Planejamento de Movimentações",
                                  "subSteps": [
                                    "Procure por pares de soma/derivação que permitam movimentação para isolar série/paralelo.",
                                    "Priorize movimentações que criem laços unitários ou blocos em série simples.",
                                    "Desenhe setas provisórias indicando a sequência de movimentações (ex: mover soma para a esquerda).",
                                    "Avalie o impacto de cada movimentação na equivalência do diagrama.",
                                    "Liste 2-3 sequências alternativas de movimentações combinadas."
                                  ],
                                  "verification": "Sequência planejada de pelo menos 3 movimentações anotada com justificativa.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Diagrama copiado do Step 1",
                                    "Tabela de regras de movimentação impressa",
                                    "Calculadora para ganhos preliminares"
                                  ],
                                  "tips": "Use a regra 'movimentar soma através de bloco' para acessar derivações internas.",
                                  "learningObjective": "Selecionar e priorizar movimentações combinadas para simplificação stepwise.",
                                  "commonMistakes": [
                                    "Planejar movimentações que criem loops infinitos",
                                    "Esquecer de preservar a direção do sinal",
                                    "Não considerar múltiplas derivações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução Sequencial das Movimentações Combinadas",
                                  "subSteps": [
                                    "Aplique a primeira movimentação: mova um ponto de soma através de um bloco ou derivação.",
                                    "Atualize o diagrama imediatamente e verifique equivalência local.",
                                    "Execute a segunda e terceira movimentações, isolando uma configuração redutível (série/paralelo/laço).",
                                    "Reduza a configuração isolada usando regras padrão (ex: soma de ganhos em paralelo).",
                                    "Continue com movimentações adicionais até simplificar o máximo possível."
                                  ],
                                  "verification": "Diagrama atualizado após cada movimentação, com anotações de mudanças.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Diagrama em edição",
                                    "Software Simulink para simulação opcional",
                                    "Folha de verificação de equivalência"
                                  ],
                                  "tips": "Sempre desenhe o 'antes' e 'depois' de cada movimentação para visualização clara.",
                                  "learningObjective": "Executar movimentações múltiplas com precisão, mantendo a equivalência do sistema.",
                                  "commonMistakes": [
                                    "Inverter sinais ao mover somas",
                                    "Alterar ganhos inadvertidamente",
                                    "Aplicar regra errada em configurações mistas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação Final e Simplificação Completa",
                                  "subSteps": [
                                    "Compare o diagrama simplificado com o original via função de transferência equivalente.",
                                    "Teste numericamente com entradas unitárias (ex: degrau) em ambos diagramas.",
                                    "Identifique simplificações adicionais ou erros nas movimentações.",
                                    "Documente o diagrama final com equação de transferência.",
                                    "Reflita sobre otimizações para diagramas semelhantes."
                                  ],
                                  "verification": "Função de transferência original e final idênticas; simulação numérica converge.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink para cálculo de TF",
                                    "Entradas de teste (degrau, impulso)"
                                  ],
                                  "tips": "Use syms no MATLAB para funções de transferência simbólicas exatas.",
                                  "learningObjective": "Validar a redução combinada e garantir fidelidade ao modelo dinâmico.",
                                  "commonMistakes": [
                                    "Não verificar feedback loops preservados",
                                    "Erros de sinal em simulações",
                                    "Parar antes da simplificação máxima"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama com entrada R(s), soma1 recebendo R(s) e feedback H(s), saída de G1(s) para soma2, que soma com derivação de G2(s) em paralelo, e laço unitário via G3(s). Movimente soma2 através de G1 para isolar paralelo G1-G2, depois mova derivação para criar laço unitário em G3, reduzindo para bloco único equivalente.",
                              "finalVerifications": [
                                "Diagrama reduzido possui ≤50% dos blocos originais.",
                                "Função de transferência coincide com a original em simulação.",
                                "Todas movimentações documentadas sem perda de sinal.",
                                "Configurações redutíveis (série/paralelo/laço) isoladas corretamente.",
                                "Nenhum loop ou sinal invertido introduzido.",
                                "Tempo total de redução <2 horas para diagrama médio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de ≥3 movimentações combinadas (90%+ correta).",
                                "Documentação clara de antes/depois em cada step.",
                                "Equivalência verificada via TF ou simulação numérica.",
                                "Eficiência: redução máxima com mínimo steps.",
                                "Identificação correta de erros comuns evitados.",
                                "Criatividade em sequências alternativas planejadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de Laplace e manipulação de frações racionais.",
                                "Programação: Implementação em MATLAB/Simulink para automação de reduções.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos (ex: controle de flaps).",
                                "Controle Automático: Análise de estabilidade pós-redução (polos/raízes).",
                                "Engenharia de Software: Diagramação UML similar a blocos de sinal."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, reduz diagramas de blocos complexos de sistemas de controle de voo (ex: autopilot em PS-22), permitindo análise rápida de estabilidade e projeto de controladores PID para manobras seguras em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Ponto de Operação Estacionário",
                    "description": "Definição e identificação de pontos de equilíbrio para linearização de modelos não-lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Definição de Ponto de Operação Estacionário",
                        "description": "Conceito fundamental de ponto de equilíbrio ou operação estacionária em sistemas dinâmicos não-lineares, onde as variáveis de estado e entrada permanecem constantes ao longo do tempo, satisfazendo as equações diferenciais com derivadas nulas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Explicar a definição matemática de ponto estacionário",
                            "description": "Descrever formalmente um ponto de operação estacionário como um conjunto (x_eq, u_eq) tal que f(x_eq, u_eq) = 0, onde f representa a dinâmica não-linear dx/dt = f(x, u), identificando condições de equilíbrio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas Dinâmicos Não-Lineares",
                                  "subSteps": [
                                    "Estude a equação geral de um sistema dinâmico contínuo: dx/dt = f(x, u), onde x é o vetor de estado e u é a entrada.",
                                    "Identifique que f é uma função não-linear em sistemas reais como aeronaves.",
                                    "Diferencie sistemas lineares (dx/dt = Ax + Bu) dos não-lineares.",
                                    "Discuta exemplos simples, como o movimento de um pêndulo.",
                                    "Anote as componentes: estado x(t), entrada u(t) e dinâmica f."
                                  ],
                                  "verification": "Resuma em suas palavras a equação dx/dt = f(x, u) e dê um exemplo não-linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Sistemas Dinâmicos (ex: Ogata), vídeo introdutório no YouTube sobre dinâmica não-linear.",
                                  "tips": "Visualize x como posição/velocidade em uma aeronave.",
                                  "learningObjective": "Compreender a representação matemática básica de sistemas dinâmicos não-lineares.",
                                  "commonMistakes": "Confundir x com saída y; lembrar que y = h(x,u) é separada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito Intuitivo de Ponto Estacionário",
                                  "subSteps": [
                                    "Defina intuitivamente: ponto onde o estado não muda se a entrada for constante.",
                                    "Pense em equilíbrio: como um avião em voo reto e nivelado sem acelerações.",
                                    "Discuta que em t → ∞, dx/dt → 0 para estados constantes.",
                                    "Compare com repouso em mecânica clássica.",
                                    "Esboce um gráfico de x(t) constante ao longo do tempo."
                                  ],
                                  "verification": "Descreva verbalmente um cenário onde um sistema está 'estacionário'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta para esboços, simulador simples como MATLAB ode45 para plotar trajetórias.",
                                  "tips": "Use analogias cotidianas como carro em velocidade constante.",
                                  "learningObjective": "Graspar o conceito físico de equilíbrio em sistemas dinâmicos.",
                                  "commonMistakes": "Achar que u_eq deve ser zero; u_eq pode ser não-zero (ex: empuxo constante)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição Matemática do Ponto Estacionário",
                                  "subSteps": [
                                    "Estabeleça: Um ponto estacionário (x_eq, u_eq) satisfaz f(x_eq, u_eq) = 0.",
                                    "Escreva explicitamente: dx/dt |_{x=x_eq, u=u_eq} = 0.",
                                    "Verifique que x(t) = x_eq constante implica derivada zero.",
                                    "Discuta que x_eq e u_eq são constantes (não funções de t).",
                                    "Resolva um exemplo simples: f(x,u) = x^2 - u = 0 → x_eq = sqrt(u_eq)."
                                  ],
                                  "verification": "Escreva a definição formal e resolva f(x_eq, u_eq)=0 para um caso dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno de exercícios, software como SymPy ou MATLAB para resolver equações.",
                                  "tips": "Substitua diretamente na equação f para checar.",
                                  "learningObjective": "Dominar a definição matemática precisa de ponto de operação estacionário.",
                                  "commonMistakes": "Esquecer que ambos x_eq e u_eq são necessários; não é só f(x_eq)=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Condições de Equilíbrio e Aplicar em Exemplos",
                                  "subSteps": [
                                    "Liste condições: f contínua, soluções únicas para x_eq dado u_eq.",
                                    "Aplique a um modelo de aeronave: empuxo = arrasto em cruzeiro → (x_eq, u_eq).",
                                    "Verifique numericamente: simule dx/dt próximo a (x_eq, u_eq).",
                                    "Discuta estabilidade (não obrigatória aqui, mas mencione).",
                                    "Documente o par (x_eq, u_eq) para um sistema dado."
                                  ],
                                  "verification": "Identifique (x_eq, u_eq) para um modelo não-linear fornecido e prove f=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Modelo exemplo em PDF ou Jupyter notebook com dinâmica de voo simplificada.",
                                  "tips": "Use iterações numéricas se analítico for difícil.",
                                  "learningObjective": "Aplicar a definição para identificar pontos estacionários reais.",
                                  "commonMistakes": "Ignorar dependência em u; equilíbrio requer u_eq específico."
                                }
                              ],
                              "practicalExample": "Em um modelo simplificado de aeronave, dx/dt = [v; (T - D)/m], onde T=empuxo (u), D=arrasto(x,v). Ponto estacionário: v_eq constante, T_eq = D_eq → f(v_eq, T_eq)=0, representando voo em cruzeiro estável.",
                              "finalVerifications": [
                                "Escreva corretamente dx/dt = f(x,u) e defina (x_eq, u_eq) tal que f(x_eq, u_eq)=0.",
                                "Identifique x_eq e u_eq em um exemplo numérico simples.",
                                "Explique por que dx/dt=0 implica estado constante.",
                                "Diferencie de linearização (que usa Jacobiana em torno do ponto).",
                                "Resolva f(x_eq, u_eq)=0 para um sistema dado.",
                                "Descreva condições de equilíbrio sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (f(x_eq, u_eq)=0).",
                                "Compreensão conceitual de equilíbrio dinâmico.",
                                "Capacidade de aplicar a definição em exemplos concretos.",
                                "Identificação correta de x_eq e u_eq como pares.",
                                "Ausência de confusão com pontos de equilíbrio sem entrada (u=0).",
                                "Clareza na explicação verbal e escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Equilíbrio em mecânica newtoniana (forças zero).",
                                "Controle Automático: Ponto de linearização para controladores.",
                                "Matemática: Solução de sistemas de equações não-lineares.",
                                "Engenharia Mecânica: Análise de operação nominal em máquinas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, pontos estacionários definem condições de voo nominal (ex: cruzeiro) para linearizar modelos não-lineares em sistemas de controle de voo autônomo, simuladores e análise de estabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Diferenciar ponto estacionário de trajetórias transitórias",
                            "description": "Comparar o comportamento em ponto estacionário (constante) com respostas transitórias em sistemas não-lineares, usando exemplos simples como o pêndulo ou sistemas térmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Conceitos Fundamentais de Ponto Estacionário e Trajetórias Transitórias",
                                  "subSteps": [
                                    "Estude a definição de ponto estacionário: estado onde derivadas são zero e variáveis de estado são constantes.",
                                    "Identifique trajetórias transitórias como o caminho dinâmico do sistema desde condição inicial até o ponto estacionário.",
                                    "Revise equações diferenciais para sistemas lineares e não-lineares, focando em soluções de equilíbrio.",
                                    "Desenhe gráficos conceituais de respostas transitórias convergindo para o estacionário.",
                                    "Compare com exemplos cotidianos, como um carro parando (transitório) vs. parado (estacionário)."
                                  ],
                                  "verification": "Crie um diagrama explicando os dois conceitos e explique verbalmente para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Sistemas Dinâmicos",
                                    "Papel e caneta para diagramas",
                                    "Vídeo introdutório sobre equilíbrios (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use setas em gráficos para mostrar direção do fluxo transitório em direção ao estacionário.",
                                  "learningObjective": "Compreender precisamente as definições e distinções entre ponto estacionário e trajetórias transitórias.",
                                  "commonMistakes": [
                                    "Confundir ponto estacionário com solução exata da EDO; lembrar que é apenas equilíbrio, não necessariamente estável.",
                                    "Ignorar não-linearidades que podem criar múltiplos pontos estacionários."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos Simples em Sistemas Lineares para Base de Comparação",
                                  "subSteps": [
                                    "Resolva uma EDO linear simples, como m*dx/dt + kx = 0 (oscilador amortecido), identificando transitório e estacionário (x=0).",
                                    "Plote a solução analítica ou numérica mostrando decaimento para zero.",
                                    "Simule no MATLAB/Simulink ou Python (SciPy) uma resposta a degrau.",
                                    "Observe como o transitório depende de condições iniciais.",
                                    "Documente diferenças: transitório oscila/decresce, estacionário é constante."
                                  ],
                                  "verification": "Gere e interprete um gráfico de simulação mostrando convergência ao estacionário.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB/Python com bibliotecas Odeint/Solve_ivp",
                                    "Template de código para simulação de EDOs"
                                  ],
                                  "tips": "Comece com condições iniciais variadas para ver como transitórios mudam, mas estacionário permanece.",
                                  "learningObjective": "Aplicar análise em lineares para contrastar com não-lineares posteriormente.",
                                  "commonMistakes": [
                                    "Assumir que todo sistema linear tem único estacionário; focar em origens estáveis.",
                                    "Não normalizar gráficos para visualizar claramente o decaimento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Diferenças em Sistemas Não-Lineares com Exemplos como Pêndulo",
                                  "subSteps": [
                                    "Estude equação do pêndulo não-linear: d²θ/dt² + (g/l)sin(θ) = 0.",
                                    "Encontre pontos estacionários: θ=0 (equilíbrio estável), θ=π (instável).",
                                    "Simule trajetórias desde θ inicial ≠0, mostrando oscilações amortecidas ou caóticas para estacionário.",
                                    "Compare com aproximação linear (sin(θ)≈θ) e note discrepâncias em grandes ângulos.",
                                    "Analise sistema térmico: dT/dt = -k(T - T_amb), identificando T=T_amb como estacionário e resfriamento como transitório."
                                  ],
                                  "verification": "Produza simulações comparativas (linear vs. não-linear) com legendas explicativas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Simulador online de pêndulo (PhET ou similar)",
                                    "Código Python para pêndulo não-linear"
                                  ],
                                  "tips": "Use fase portraits para visualizar trajetórias convergindo a pontos estacionários.",
                                  "learningObjective": "Diferenciar comportamentos em não-lineares, destacando múltiplos equlilíbrios e dependência inicial.",
                                  "commonMistakes": [
                                    "Linearizar prematuramente; sempre verificar não-linearidades primeiro.",
                                    "Confundir instável com não-estacionário."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação e Aplicar Linearização ao Redor do Ponto Estacionário",
                                  "subSteps": [
                                    "Resuma tabela comparativa: linear vs. não-linear (único/múltiplos estacionários, transitórios simples/complexos).",
                                    "Aplique linearização: derive Jacobiano em ponto estacionário do pêndulo.",
                                    "Simule resposta linearizada vs. original, validando para pequenas perturbações.",
                                    "Discuta estabilidade via autovalores.",
                                    "Crie fluxograma para diferenciar em qualquer sistema dinâmico."
                                  ],
                                  "verification": "Apresente tabela e fluxograma em relatório curto (1 página).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel para tabelas",
                                    "Ferramenta de desenho como Draw.io para fluxogramas"
                                  ],
                                  "tips": "Foque em perturbações pequenas para validar linearização.",
                                  "learningObjective": "Integrar conceitos via linearização, preparando para análise avançada.",
                                  "commonMistakes": [
                                    "Aplicar linearização longe do ponto; válida só localmente.",
                                    "Ignorar autovalores para estabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um pêndulo simples em Python: libere de θ=0.5 rad, observe oscilações transitórias amortecidas convergindo para θ=0 (estacionário). Compare com liberação de θ=π+0.1 (afasta do instável).",
                              "finalVerifications": [
                                "Define corretamente ponto estacionário como onde ẋ=0.",
                                "Descreve trajetórias transitórias como dinâmicas iniciais para equilíbrio.",
                                "Identifica múltiplos pontos em não-lineares com exemplo.",
                                "Plota e interpreta gráfico de faseportrait.",
                                "Explica linearização e sua limitação.",
                                "Distingue estabilidade de estacionariedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (30%): Definições exatas sem confusões.",
                                "Análise qualitativa (25%): Interpretação correta de gráficos/simulações.",
                                "Exemplos aplicados (20%): Uso relevante de pêndulo/térmico.",
                                "Comparação clara (15%): Tabelas/fluxos bem estruturados.",
                                "Profundidade não-linear (10%): Reconhecimento de peculiaridades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de EDOs e autovalores.",
                                "Física: Dinâmica clássica e estabilidade de equilíbrio.",
                                "Engenharia de Controle: Linearização para design de controladores.",
                                "Computação: Simulações numéricas em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em aeronáutica, diferencia trim conditions (estacionário de voo estável) de manobras transitórias (decolagem/pouso), essencial para análise de estabilidade em diagramas de fase de aeronaves não-lineares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Identificar tipos de pontos estacionários",
                            "description": "Classificar pontos de equilíbrio como estáveis, instáveis ou saddle points com base em linearizações locais, referenciando conceitos de estabilidade de Lyapunov.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar pontos de operação estacionária",
                                  "subSteps": [
                                    "Resolver a equação f(x*) = 0 para encontrar os pontos de equilíbrio x* onde o sistema para.",
                                    "Verificar se o ponto satisfaz as condições de equilíbrio para sistemas autônomos.",
                                    "Listar todos os pontos candidatos em um sistema dado.",
                                    "Confirmar dimensionalidade (para vetores em R^n).",
                                    "Documentar os pontos em uma tabela com valores aproximados."
                                  ],
                                  "verification": "Lista completa de pontos x* onde derivadas são zero, validada por substituição na equação original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora gráfica ou software simbólico como SymPy/MATLAB.",
                                  "tips": "Comece com sistemas unidimensionais para prática antes de multivariáveis.",
                                  "learningObjective": "Capacidade de localizar precisamente todos os pontos de equilíbrio em um sistema dinâmico.",
                                  "commonMistakes": "Ignorar soluções múltiplas ou raízes complexas que não são reais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar linearização local ao redor do ponto estacionário",
                                  "subSteps": [
                                    "Calcular a matriz Jacobiana J(x) = ∂f/∂x avaliada em x*.",
                                    "Derivar cada entrada da Jacobiana simbolicamente.",
                                    "Verificar simetria ou propriedades especiais da matriz.",
                                    "Implementar em software para validação numérica.",
                                    "Armazenar a matriz linearizada A = J(x*)."
                                  ],
                                  "verification": "Matriz Jacobiana corretamente computada e igual à derivada parcial em x*, checada por diferenciação numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de álgebra computacional (MATLAB, Python com SymPy), quadro branco.",
                                  "tips": "Use regras de derivação em cadeia para termos compostos; teste com valores numéricos pequenos.",
                                  "learningObjective": "Habilidade em obter a aproximação linear válida perto do ponto de equilíbrio.",
                                  "commonMistakes": "Erro no cálculo de derivadas parciais ou avaliação errada em x*."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e analisar autovalores da matriz linearizada",
                                  "subSteps": [
                                    "Resolver det(A - λI) = 0 para encontrar autovalores λ.",
                                    "Determinar partes reais de todos os autovalores.",
                                    "Classificar: todos Re(λ) < 0 (estável), algum Re(λ) > 0 (instável), Re(λ) com sinais mistos (saddle).",
                                    "Verificar autovetores se necessário para direção.",
                                    "Plotar ou tabular os autovalores."
                                  ],
                                  "verification": "Autovalores corretos confirmados por multiplicação A v = λ v para autovetores v.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial, MATLAB eig() ou numpy.linalg.eig.",
                                  "tips": "Para matrizes 2x2, use fórmula quadrática; evite arredondamentos em software.",
                                  "learningObjective": "Interpretação precisa dos autovalores para inferir comportamento local.",
                                  "commonMistakes": "Confundir parte real com módulo ou ignorar autovalores complexos conjugados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar o tipo de ponto estacionário e referenciar Lyapunov",
                                  "subSteps": [
                                    "Aplicar critérios: atrator (estável), repulsor (instável), selim (saddle).",
                                    "Comparar com definição de estabilidade de Lyapunov (trajetórias convergem para x* em norma).",
                                    "Simular numericamente trajetórias próximas para visualização.",
                                    "Documentar classificação final com justificativa.",
                                    "Discutir limitações da linearização (hiperbolicidade)."
                                  ],
                                  "verification": "Classificação consistente com autovalores e simulação qualitativa de trajetórias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de simulação (Python ODEINT, MATLAB ode45), gráficos de fase.",
                                  "tips": "Sempre simule para confirmação visual; Lyapunov garante para Re(λ)<0.",
                                  "learningObjective": "Classificação robusta integrando linearização e teoria de Lyapunov.",
                                  "commonMistakes": "Classificar saddle como estável por autovalor zero ou não hiperbólico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e sintetizar a análise",
                                  "subSteps": [
                                    "Comparar resultados com exemplos conhecidos.",
                                    "Testar sensibilidade a perturbações pequenas.",
                                    "Redigir relatório com classificações para todos pontos.",
                                    "Discutir aplicações em sistemas reais.",
                                    "Preparar para exercícios de extensão."
                                  ],
                                  "verification": "Relatório completo com classificações corretas para múltiplos pontos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou documento LaTeX para relatório.",
                                  "tips": "Use diagramas de fase para intuição visual.",
                                  "learningObjective": "Síntese crítica da análise de estabilidade.",
                                  "commonMistakes": "Generalizar de linear para não-linear sem caveats."
                                }
                              ],
                              "practicalExample": "Considere o sistema não-linear em aeronáutica: \\dot{x} = -x + x y, \\dot{y} = x^2 - y^2. Pontos de equilíbrio: (0,0), (1,1), (-1,-1). Linearize em (0,0): J = [[-1,0],[0,-1]] → autovalores -1,-1 → estável. Em (1,1): J=[[0,1],[-2,0]] → λ=±i√2 → saddle? Não, calcule precisamente: trace=-0? Espere, exemplo padrão pêndulo invertido ou Lotka-Volterra simplificado. Classifique (0,0) como saddle.",
                              "finalVerifications": [
                                "Todos pontos de equilíbrio identificados corretamente.",
                                "Matriz Jacobiana computada sem erros.",
                                "Autovalores e partes reais analisadas precisamente.",
                                "Classificação (estável/instável/saddle) justificada.",
                                "Simulação confirma comportamento local.",
                                "Referência a Lyapunov aplicada adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de pontos estacionários (100%).",
                                "Correção no cálculo da Jacobiana e autovalores (90%).",
                                "Classificação coerente com teoria linear (95%).",
                                "Integração de Lyapunov para validação (80%).",
                                "Qualidade de simulações e visualizações (85%).",
                                "Relatório claro e completo (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Cálculo de autovalores e diagonalização.",
                                "Física: Dinâmica de partículas e osciladores.",
                                "Engenharia de Controle: Análise de estabilidade em laços fechados.",
                                "Computação: Simulação numérica de EDOs com SciPy/MATLAB.",
                                "Matemática Aplicada: Teorema de Hartman-Grobman."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, classificar pontos de trim (equilíbrio de voo) como estáveis permite projetar controladores automáticos estáveis, evitando instabilidades como stall ou spin em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Identificação de Pontos de Equilíbrio",
                        "description": "Métodos para encontrar pontos de operação estacionária em modelos não-lineares, resolvendo equações algébricas resultantes das condições de equilíbrio.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Resolver equações para pontos de equilíbrio",
                            "description": "Dado um modelo não-linear dx/dt = f(x, u), igualar f(x, u) = 0 e resolver o sistema algébrico para x_eq e u_eq, aplicando em exemplos como modelo de tanque ou circuito RLC não-linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo dinâmico e identificar variáveis",
                                  "subSteps": [
                                    "Leia o modelo dado dx/dt = f(x, u) e identifique as equações não-lineares.",
                                    "Liste as variáveis de estado x (vetor) e de entrada u (vetor).",
                                    "Defina conceitualmente x_eq e u_eq como soluções onde f(x_eq, u_eq) = 0.",
                                    "Anote as dimensões de x e u (ex: escalar ou vetorial).",
                                    "Esboce o diagrama conceitual do sistema (ex: tanque ou RLC)."
                                  ],
                                  "verification": "Verifique se a lista de x, u e suas dimensões está correta e conceitualmente alinhada com f(x,u)=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do modelo",
                                    "Papel, caneta ou software de notas (ex: Jupyter Notebook)"
                                  ],
                                  "tips": "Use notação vetorial clara (x ∈ ℝⁿ) para evitar confusões em sistemas multivariáveis.",
                                  "learningObjective": "Identificar componentes do modelo dinâmico e compreender o conceito de equilíbrio estacionário.",
                                  "commonMistakes": [
                                    "Confundir variáveis de estado x com entradas u",
                                    "Ignorar não-linearidades implícitas em f(x,u)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular as equações de equilíbrio",
                                  "subSteps": [
                                    "Iguale dx/dt = 0, resultando em f(x_eq, u_eq) = 0.",
                                    "Expanda f(x,u) explicitamente para cada componente do vetor.",
                                    "Substitua x por x_eq e u por u_eq nas equações.",
                                    "Escreva o sistema algébrico completo (ex: para tanque: 0 = u_eq - c √h_eq).",
                                    "Identifique se u_eq é dado ou livre."
                                  ],
                                  "verification": "Confira se todas as equações foram corretamente zeradas e o sistema está balanceado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelo expandido do Step 1",
                                    "Calculadora simbólica (ex: SymPy ou MATLAB)"
                                  ],
                                  "tips": "Mantenha a notação consistente; use subscrito '_eq' para clareza.",
                                  "learningObjective": "Transformar modelo diferencial em sistema algébrico não-linear.",
                                  "commonMistakes": [
                                    "Esquecer de zerar corretamente dx/dt",
                                    "Não expandir componentes vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema algébrico para x_eq e u_eq",
                                  "subSteps": [
                                    "Tente solução analítica isolando variáveis (ex: h_eq = (u_eq / c)^2 para tanque).",
                                    "Se não analítico, use métodos numéricos (ex: fsolve no MATLAB ou scipy.optimize).",
                                    "Forneça valores iniciais razoáveis para iterações numéricas.",
                                    "Encontre todas as soluções reais físicas (descartar complexas ou negativas).",
                                    "Calcule resíduos para validar |f(x_eq, u_eq)| < ε (ex: ε=1e-6)."
                                  ],
                                  "verification": "Teste substituindo x_eq, u_eq de volta em f() e confirme que ≈0.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB, Python com SciPy, ou papel para analítico)",
                                    "Valores iniciais estimados"
                                  ],
                                  "tips": "Para não-lineares como √h, isole termos quadráticos para exatidão.",
                                  "learningObjective": "Aplicar técnicas algébricas e numéricas para resolver não-lineares.",
                                  "commonMistakes": [
                                    "Chutes iniciais ruins levando a convergência falha",
                                    "Aceitar soluções não-físicas (ex: h_eq <0)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e aplicar em exemplo prático",
                                  "subSteps": [
                                    "Aplique em exemplo específico (ex: tanque ou RLC não-linear).",
                                    "Compare com condições físicas esperadas (ex: h_eq >0, estável).",
                                    "Analise estabilidade qualitativa (Jacobiano em x_eq).",
                                    "Documente soluções em tabela (x_eq, u_eq, resíduo).",
                                    "Discuta múltiplos equilíbrios se aplicável."
                                  ],
                                  "verification": "Soluções validadas numericamente e fisicamente plausíveis no exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo concreto (tanque: A dh/dt = u - c√h)",
                                    "Software de plotagem para visualização"
                                  ],
                                  "tips": "Sempre plote f(x,u) vs x para visualizar interseções com zero.",
                                  "learningObjective": "Validar pontos de equilíbrio em contextos reais e identificar múltiplos.",
                                  "commonMistakes": [
                                    "Ignorar múltiplas raízes em não-lineares",
                                    "Não checar plausibilidade física"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelo de tanque: A * dh/dt = u - c * sqrt(h), com A=1 m², c=0.1 m^{5/2}/s. Para u_eq=0.04 m³/s, resolva 0 = 0.04 - 0.1 * sqrt(h_eq) → h_eq = (0.04/0.1)^2 = 1.6 m. Verifique resíduo ≈0.",
                              "finalVerifications": [
                                "Sistema f(x_eq, u_eq)=0 está corretamente formulado.",
                                "Soluções x_eq e u_eq são numericamente precisas (resíduo <1e-6).",
                                "Soluções são fisicamente plausíveis (ex: h_eq ≥0).",
                                "Múltiplos equilíbrios identificados se existirem.",
                                "Validação por substituição direta confirmada.",
                                "Documentação inclui tabela de resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das equações de equilíbrio (100% correto).",
                                "Correção das soluções analíticas/numéricas (erro <1%).",
                                "Identificação de soluções físicas e descarte de inválidas.",
                                "Uso adequado de ferramentas numéricas com chutes iniciais.",
                                "Análise qualitativa de múltiplos equilíbrios.",
                                "Clareza na documentação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra não-linear e métodos numéricos (Newton-Raphson).",
                                "Física: Dinâmica de fluidos (tanque) ou circuitos (RLC).",
                                "Programação: Implementação em Python/MATLAB para solvers.",
                                "Controle Automático: Base para linearização em torno de x_eq.",
                                "Engenharia Aeronáutica: Cálculo de trim em aerodinâmica."
                              ],
                              "realWorldApplication": "Em aeronáutica, identifica condições de trim (equilíbrio) para controle de voo estável, como altitude constante em cruzeiro ou hover em drones, essencial para linearização e design de controladores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Aplicar identificação em sistemas reais",
                            "description": "Identificar pontos estacionários em aplicações práticas como sistemas mecânicos (massa-mola com atrito não-linear) ou térmicos, usando diagramas de fase para visualização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Pontos Estacionários",
                                  "subSteps": [
                                    "Defina ponto estacionário como estado onde derivadas são zero (ẋ = 0).",
                                    "Estude equações diferenciais não-lineares para sistemas reais.",
                                    "Revise exemplos simples como massa-mola sem atrito para base.",
                                    "Discuta impacto de não-linearidades como atrito Coulomb ou viscoso.",
                                    "Anote diferenças entre lineares e não-lineares em equilíbrio."
                                  ],
                                  "verification": "Escreva definições e exemplos em um resumo de 1 página sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Sistemas Dinâmicos, notas de aula, calculadora.",
                                  "tips": "Use analogias como 'carro parado em rampa' para fixar ideia.",
                                  "learningObjective": "Compreender matematicamente pontos estacionários em contextos não-lineares.",
                                  "commonMistakes": "Confundir ponto estacionário com estabilidade; ignorar não-linearidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar um Sistema Mecânico Real: Massa-Mola com Atrito Não-Linear",
                                  "subSteps": [
                                    "Descreva o sistema: massa m, mola k, atrito μ sign(ẋ) + bẋ.",
                                    "Escreva equações de movimento: mẍ + bẋ + μ sign(ẋ) + kx = 0.",
                                    "Simplifique para primeira ordem: ẋ = f(x, ẋ).",
                                    "Identifique variáveis de estado (x, v = ẋ).",
                                    "Desenhe diagrama esquemático do sistema físico."
                                  ],
                                  "verification": "Produza equações de estado corretas e diagrama validado por simulação básica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, software como MATLAB/Simulink ou Python (SciPy).",
                                  "tips": "Comece com atrito linear para validar, depois adicione não-linear.",
                                  "learningObjective": "Construir modelo matemático preciso de sistema real não-linear.",
                                  "commonMistakes": "Esquecer sinal do atrito Coulomb; unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Pontos Estacionários Matematicamente",
                                  "subSteps": [
                                    "Defina ẋ1 = 0, ẋ2 = 0 onde x1 = x, x2 = v.",
                                    "Resolva sistema: f1(x1,x2)=0, f2(x1,x2)=0.",
                                    "Para massa-mola: encontre x_eq onde k x_eq = μ sign(0) (geralmente x_eq=0 se sem força externa).",
                                    "Liste todos os pontos (ex: múltiplos devido a não-linearidade).",
                                    "Verifique dimensionalmente as soluções."
                                  ],
                                  "verification": "Liste coordenadas exatas dos pontos e prove ẋ=0 neles.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), folhas de cálculo.",
                                  "tips": "Use substituição stepwise; teste numericamente.",
                                  "learningObjective": "Resolver analiticamente equilíbrios em modelos não-lineares.",
                                  "commonMistakes": "Assumir sign(0)=0 incorretamente; perder soluções triviais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Interpretar com Diagrama de Fase",
                                  "subSteps": [
                                    "Plote vetores de campo: dx/dt vs dy/dt em grade (x,v).",
                                    "Marque pontos estacionários com símbolos (X para instáveis, etc.).",
                                    "Trace trajetórias numéricas ao redor dos pontos.",
                                    "Analise estabilidade qualitativa via setas convergentes/divergentes.",
                                    "Compare com sistema térmico simples (ex: equilíbrio de temperatura)."
                                  ],
                                  "verification": "Gere diagrama de fase com pontos corretos e pelo menos 3 trajetórias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (MATLAB pplane, Python Matplotlib/PhasePortrait).",
                                  "tips": "Use zoom em pontos para clareza; salve como imagem anotada.",
                                  "learningObjective": "Interpretar dinâmica qualitativa via diagramas de fase.",
                                  "commonMistakes": "Escala errada no plot; ignorar direção das setas."
                                }
                              ],
                              "practicalExample": "Em um sistema massa-mola com atrito Coulomb (μ=0.5N), m=1kg, k=10N/m: equações ẋ=v, v̇= -10x -0.5 sign(v) -ẋ (b=1). Pontos estacionários em (0,0); diagrama de fase mostra espiral para (0,0) estável.",
                              "finalVerifications": [
                                "Todos pontos estacionários identificados corretamente.",
                                "Diagrama de fase plotado com vetores e trajetórias precisas.",
                                "Estabilidade qualitativa descrita para cada ponto.",
                                "Modelo validado com simulação numérica.",
                                "Aplicação a sistema térmico alternativo demonstrada.",
                                "Relatório resume achados sem erros matemáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas equações e soluções (30%).",
                                "Qualidade e legibilidade do diagrama de fase (25%).",
                                "Análise de estabilidade correta e fundamentada (20%).",
                                "Relevância ao contexto aeronáutico (15%).",
                                "Clareza na documentação e exemplos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica newtoniana e não-linearidades reais.",
                                "Controle Automático: Linearização em torno de trim points.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Engenharia Mecânica: Vibrações em estruturas aeronáuticas."
                              ],
                              "realWorldApplication": "Em aeronáutica, identificar pontos de equilíbrio para condições de trim em aeronaves (ex: velocidade/ângulo de ataque estacionário), analisando estabilidade via diagramas de fase para evitar flutter ou perda de controle em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Verificar unicidade e existência de pontos",
                            "description": "Analisar condições para existência e unicidade de pontos de equilíbrio, usando ferramentas como gráficos de funções ou teoremas de ponto fixo em contextos de linearização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Pontos de Equilíbrio",
                                  "subSteps": [
                                    "Defina ponto de equilíbrio como estado onde derivadas são zero (ẋ = 0) em sistemas dinâmicos.",
                                    "Explique existência: soluções para f(x*, u*) = 0.",
                                    "Discuta unicidade: apenas uma solução x* para dado u*.",
                                    "Relacione com linearização: expansão de Taylor ao redor de x*."
                                  ],
                                  "verification": "Escreva definições precisas e dê um exemplo simples de sistema com ponto de equilíbrio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Sistemas Dinâmicos",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use notação padrão ẋ = f(x, u) para clareza.",
                                  "learningObjective": "Dominar definições e contexto de pontos de equilíbrio em sistemas.",
                                  "commonMistakes": [
                                    "Confundir ponto de equilíbrio com mínimo de potencial",
                                    "Ignorar dependência em u"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Existência Usando Gráficos e Funções",
                                  "subSteps": [
                                    "Plote f(x, u) para u fixo e identifique interseções com eixo x (onde f=0).",
                                    "Use teorema do valor intermediário para provar existência em intervalos.",
                                    "Verifique continuidade e sinal de f em limites para existência.",
                                    "Aplique em exemplos não-lineares simples.",
                                    "Teste numericamente com valores discretos."
                                  ],
                                  "verification": "Gere gráfico com pelo menos um ponto de equilíbrio identificado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Octave/Python Matplotlib)",
                                    "Calculadora"
                                  ],
                                  "tips": "Escolha escalas adequadas no gráfico para visualizar interseções.",
                                  "learningObjective": "Aplicar ferramentas gráficas e teoremas para confirmar existência.",
                                  "commonMistakes": [
                                    "Assumir existência sem verificar continuidade",
                                    "Ignorar múltiplas interseções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Unicidade com Teoremas de Ponto Fixo",
                                  "subSteps": [
                                    "Reformule como ponto fixo: x* = g(x*), com g derivada de f.",
                                    "Aplique Teorema de Banach (mapeamento contração) para unicidade global.",
                                    "Use Teorema de Brouwer para convexos compactos.",
                                    "Verifique condições: Lipschitz com constante <1 para Banach.",
                                    "Compare com monotonicidade estrita de f."
                                  ],
                                  "verification": "Prove unicidade para um exemplo usando um teorema específico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Notas de Análise Funcional",
                                    "Software simbólico (SymPy)"
                                  ],
                                  "tips": "Calcule derivada de g para verificar constante de Lipschitz.",
                                  "learningObjective": "Usar teoremas rigorosos para provar unicidade.",
                                  "commonMistakes": [
                                    "Aplicar Banach sem verificar contração",
                                    "Confundir Brouwer (existência) com unicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contextos de Linearização e Sistemas Aeronáuticos",
                                  "subSteps": [
                                    "Linearize modelo não-linear ao redor de x*: A = df/dx |_{x*}.",
                                    "Verifique existência/unicidade no contexto de operação estacionária (ex: voo nivelado).",
                                    "Simule perturbações para validar estabilidade local.",
                                    "Integre com diagramas de blocos: encontre u* para x* desejado.",
                                    "Avalie impacto em controle de aeronaves."
                                  ],
                                  "verification": "Linearize um modelo simples e confirme unicidade do ponto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Exemplos de modelos aeronáuticos"
                                  ],
                                  "tips": "Escolha pontos de equilíbrio fisicamente relevantes (estáveis).",
                                  "learningObjective": "Integrar análise em linearização prática.",
                                  "commonMistakes": [
                                    "Linearizar em ponto não-equilíbrio",
                                    "Ignorar não-linearidades residuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de controle de atitude de aeronave: ẋ = sin(x) - u, com u constante. Plote sin(x) - u = 0 para u=0 (equilíbrios em kπ). Para |u|<1, múltiplos; para unicidade perto de 0, use g(x) = arcsin(u) + x ajustado e verifique contração.",
                              "finalVerifications": [
                                "Identifica todos os pontos de equilíbrio via gráfico e álgebra.",
                                "Aplica corretamente pelo menos um teorema de ponto fixo.",
                                "Lineariza modelo e verifica estabilidade local.",
                                "Simula numericamente para confirmar unicidade.",
                                "Explica condições falhando em exemplos sem unicidade.",
                                "Relaciona com operação estacionária em sistemas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de existência (gráficos/teoremas): 25%.",
                                "Correta aplicação de teoremas para unicidade: 25%.",
                                "Qualidade da linearização e análise local: 20%.",
                                "Uso adequado de ferramentas/simulações: 15%.",
                                "Clareza na explicação e exemplos: 10%.",
                                "Conexão com contexto aeronáutico: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise real e teoria de ponto fixo (Banach/Brouwer).",
                                "Física: Dinâmica não-linear e estabilidade de sistemas.",
                                "Computação: Simulações numéricas e plotagem (MATLAB/Python).",
                                "Engenharia de Controle: Linearização para síntese de controladores."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, verificar unicidade de pontos de equilíbrio em modelos de voo (ex: trim conditions) garante um único estado estacionário estável para controladores automáticos, evitando ambiguidades em manobras como decolagem ou cruzeiro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Relevância para Linearização de Modelos",
                        "description": "Uso de pontos de operação estacionária como base para linearizar modelos não-lineares em torno deles, obtendo aproximações lineares válidas localmente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Preparar modelo para linearização em ponto estacionário",
                            "description": "Definir variáveis desviadas δx = x - x_eq e δu = u - u_eq, e preparar a expansão de Taylor de primeira ordem para f(x, u) ≈ A δx + B δu.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o ponto de operação estacionário",
                                  "subSteps": [
                                    "Analise o sistema dinâmico dado por ẋ = f(x, u).",
                                    "Resolva as equações de equilíbrio: f(x_eq, u_eq) = 0 para encontrar x_eq e u_eq.",
                                    "Verifique se o ponto é estacionário substituindo nos equações originais.",
                                    "Documente os valores numéricos ou simbólicos de x_eq e u_eq.",
                                    "Confirme estabilidade inicial do ponto, se aplicável."
                                  ],
                                  "verification": "Os valores de x_eq e u_eq satisfazem f(x_eq, u_eq) = 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica (ex: SymPy ou MATLAB), modelo do sistema.",
                                  "tips": "Use soluções analíticas quando possível; numéricas para sistemas complexos.",
                                  "learningObjective": "Compreender e localizar pontos de equilíbrio em sistemas não-lineares.",
                                  "commonMistakes": "Confundir equilíbrio com estado inicial arbitrário; ignorar dependências algébricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir variáveis desviadas",
                                  "subSteps": [
                                    "Introduza δx = x - x_eq para o vetor de estado.",
                                    "Introduza δu = u - u_eq para a entrada de controle.",
                                    "Expresse o estado original: x = x_eq + δx, u = u_eq + δu.",
                                    "Substitua nas equações dinâmicas: ẋ = f(x_eq + δx, u_eq + δu).",
                                    "Verifique a notação para consistência dimensional."
                                  ],
                                  "verification": "As expressões δx e δu estão corretamente definidas e substituídas no modelo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, editor de equações (ex: LaTeX ou MathType).",
                                  "tips": "Mantenha x_eq e u_eq como constantes fixas para simplificação.",
                                  "learningObjective": "Dominar a transformação para coordenadas desviadas em torno do equilíbrio.",
                                  "commonMistakes": "Esquecer o sinal na definição (δx = x - x_eq vs. x_eq - x); inconsistência em vetores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as matrizes Jacobianas A e B",
                                  "subSteps": [
                                    "Compute a matriz A = ∂f/∂x |_{x_eq, u_eq} (Jacobiana em relação a x).",
                                    "Compute a matriz B = ∂f/∂u |_{x_eq, u_eq} (Jacobiana em relação a u).",
                                    "Calcule elementos parciais analiticamente ou numericamente.",
                                    "Verifique simetria ou propriedades esperadas das matrizes.",
                                    "Armazene A e B em forma matricial explícita."
                                  ],
                                  "verification": "As derivadas parciais em A e B coincidem com avaliações no ponto (x_eq, u_eq).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software simbólico (MATLAB Symbolic Toolbox, SymPy), calculadora matricial.",
                                  "tips": "Para funções não-lineares complexas, use diferenciação numérica com precisão alta.",
                                  "learningObjective": "Aplicar cálculo multivariável para linearização via Taylor.",
                                  "commonMistakes": "Avaliar Jacobianas em ponto errado; confundir ordem de diferenciação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever a aproximação linear de primeira ordem",
                                  "subSteps": [
                                    "Aplique expansão de Taylor: f(x, u) ≈ f(x_eq, u_eq) + A δx + B δu.",
                                    "Simplifique sabendo que f(x_eq, u_eq) = 0, resultando em δẋ ≈ A δx + B δu.",
                                    "Expresse o modelo linearizado completo: δẋ = A δx + B δu.",
                                    "Compare com o modelo original para validar linearidade local.",
                                    "Documente o modelo final em forma de equação ou diagrama."
                                  ],
                                  "verification": "O modelo linearizado reduz ao original quando δx=0 e δu=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, software de simulação (ex: Simulink para visualização).",
                                  "tips": "Ignore termos de ordem superior para primeira ordem; valide com simulações pequenas.",
                                  "learningObjective": "Construir o modelo linearizado pronto para análise de controle.",
                                  "commonMistakes": "Incluir termo constante zero incorretamente; esquecer δẋ em vez de ẋ."
                                }
                              ],
                              "practicalExample": "Para um modelo de drone em hover: ẋ = [v_x; v_y; ...], com x_eq = [0;0;...], u_eq constante de thrust. Defina δx = x - x_eq, compute A (matriz de dinâmica) e B (controle de motores), resultando em δẋ ≈ A δx + B δu para controlador PID.",
                              "finalVerifications": [
                                "x_eq e u_eq satisfazem f(x_eq, u_eq) = 0.",
                                "δx e δu estão corretamente definidos e substituídos.",
                                "Matrizes A e B são Jacobianas avaliadas no ponto correto.",
                                "Modelo linearizado é δẋ = A δx + B δu sem termos constantes.",
                                "Dimensões de A (n x n) e B (n x m) são consistentes.",
                                "Validação numérica: perturbação pequena reproduz linearização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do ponto estacionário (100% correto).",
                                "Corretude das definições de δx e δu (sem erros de sinal).",
                                "Cálculo exato das Jacobianas A e B.",
                                "Apresentação clara do modelo linearizado final.",
                                "Validação e verificações incluídas.",
                                "Eficiência temporal e uso de recursos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e expansões de Taylor.",
                                "Física: Dinâmica de sistemas não-lineares em engenharia.",
                                "Programação: Implementação em MATLAB/Simulink para Jacobianas simbólicas.",
                                "Controle Automático: Base para estabilização LQR ou pole placement."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, lineariza modelos de aeronaves em trim (voo nivelado) para design de sistemas de controle de voo autônomo, como autopilotas em aviões comerciais ou drones, permitindo análise de estabilidade e síntese de controladores lineares eficientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Calcular Jacobianas em pontos de equilíbrio",
                            "description": "Computar as matrizes Jacobianas ∂f/∂x |_(x_eq,u_eq) = A e ∂f/∂u |_(x_eq,u_eq) = B para obter o modelo linearizado d(δx)/dt = A δx + B δu.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Ponto de Equilíbrio (x_eq, u_eq)",
                                  "subSteps": [
                                    "Defina o sistema dinâmico não-linear como dx/dt = f(x, u).",
                                    "Resolva f(x_eq, u_eq) = 0 para encontrar estados e entradas de equilíbrio.",
                                    "Verifique se múltiplos pontos de equilíbrio existem e selecione o relevante para o contexto aeronáutico.",
                                    "Documente os valores numéricos ou simbólicos de x_eq e u_eq.",
                                    "Confirme estabilidade qualitativa do ponto usando análise básica."
                                  ],
                                  "verification": "Confirme que f(x_eq, u_eq) = 0 com cálculo numérico ou simbólico exato.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo matemático do sistema (equações dx/dt = f(x,u))",
                                    "Software simbólico como SymPy ou MATLAB",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Comece com sistemas simples como pêndulo para praticar antes de modelos complexos de aeronaves.",
                                  "learningObjective": "Compreender e localizar pontos de operação estacionária em sistemas dinâmicos não-lineares.",
                                  "commonMistakes": [
                                    "Confundir equilíbrio com estado inicial arbitrário",
                                    "Ignorar dependências algébricas entre x_eq e u_eq"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Preparar o Modelo Não-Linear f(x, u)",
                                  "subSteps": [
                                    "Escreva explicitamente as equações diferenciais dx/dt = f(x, u) para cada componente x_i.",
                                    "Identifique dimensões: n estados (x ∈ ℝ^n), m entradas (u ∈ ℝ^m).",
                                    "Expresse f como vetor de funções f_i(x, u).",
                                    "Substitua valores de equilíbrio para confirmar f(x_eq, u_eq) = 0.",
                                    "Prepare derivadas parciais simbólicas iniciais."
                                  ],
                                  "verification": "Lista completa de equações f(x,u) documentada e avaliada em equilíbrio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência do modelo (ex: equações de voo de drone)",
                                    "Notebook Jupyter com SymPy",
                                    "Livro de dinâmica de sistemas"
                                  ],
                                  "tips": "Use notação matricial desde o início para facilitar Jacobianas.",
                                  "learningObjective": "Preparar o modelo não-linear para linearização sistemática.",
                                  "commonMistakes": [
                                    "Omitir componentes de entrada u nas funções f",
                                    "Erros de indexação em vetores multi-dimensionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Matriz Jacobiana A = ∂f/∂x |_(x_eq, u_eq)",
                                  "subSteps": [
                                    "Compute todas as derivadas parciais ∂f_i/∂x_j para i=1..n, j=1..n.",
                                    "Avalie cada entrada da matriz em (x_eq, u_eq).",
                                    "Use regras de derivação: produto, cadeia, etc., para funções compostas.",
                                    "Monte a matriz A (n x n) e verifique simetria ou propriedades esperadas.",
                                    "Implemente computação simbólica para precisão."
                                  ],
                                  "verification": "Matriz A com todas as entradas corretas, confirmadas por software ou cálculo manual duplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para derivadas simbólicas",
                                    "Matriz em branco n x n",
                                    "Exemplos resolvidos de Jacobianas"
                                  ],
                                  "tips": "Derive termo a termo; evite aproximações numéricas iniciais.",
                                  "learningObjective": "Dominar o cálculo de Jacobianas de estado para linearização.",
                                  "commonMistakes": [
                                    "Derivar em ponto errado (não em equilíbrio)",
                                    "Confundir ∂f/∂x com Hessiana"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Matriz Jacobiana B = ∂f/∂u |_(x_eq, u_eq)",
                                  "subSteps": [
                                    "Compute derivadas parciais ∂f_i/∂u_k para i=1..n, k=1..m.",
                                    "Avalie em (x_eq, u_eq) para formar matriz B (n x m).",
                                    "Verifique se B é rank completo ou singularidades.",
                                    "Compare com A para insights sobre controlabilidade.",
                                    "Documente em formato matricial."
                                  ],
                                  "verification": "Matriz B completa e avaliada corretamente no ponto de equilíbrio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do Step 3",
                                    "Ferramentas de plotagem de autovalores para análise inicial"
                                  ],
                                  "tips": "Em sistemas de voo, B relaciona-se diretamente com superfícies de controle.",
                                  "learningObjective": "Calcular Jacobianas de entrada para modelos lineares afins.",
                                  "commonMistakes": [
                                    "Assumir B identidade sem cálculo",
                                    "Erros em dimensões m ≠ n"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formar e Validar o Modelo Linearizado",
                                  "subSteps": [
                                    "Escreva d(δx)/dt = A δx + B δu.",
                                    "Simule numericamente o modelo linear vs. não-linear perto de equilíbrio.",
                                    "Calcule autovalores de A para estabilidade linearizada.",
                                    "Verifique linearidade local com perturbações pequenas.",
                                    "Documente relatório com A, B e validação."
                                  ],
                                  "verification": "Simulação mostra concordância entre modelos linear e não-linear em região pequena.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (scipy.integrate)",
                                    "Dados de simulação"
                                  ],
                                  "tips": "Use δx = x - x_eq pequeno (1-5% de x_eq).",
                                  "learningObjective": "Integrar Jacobianas em modelo linearizado completo e validado.",
                                  "commonMistakes": [
                                    "Ignorar validação numérica",
                                    "Escala errada de perturbações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um modelo simplificado de drone em hover: dx/dt = [v; g sinθ - k v; u - g cosθ], com x=[x,v,θ], encontre x_eq=[0,0,0], u_eq=g, compute A = [[0,1,0]; [0,-k, g], [0,0,0]] e B = [[0]; [0]; [1]] em equilíbrio.",
                              "finalVerifications": [
                                "f(x_eq, u_eq) = 0 confirmado.",
                                "Todas as entradas de A e B derivadas e avaliadas corretamente.",
                                "Modelo linearizado escrito como d(δx)/dt = A δx + B δu.",
                                "Simulação valida concordância local.",
                                "Autovalores de A analisados.",
                                "Relatório documentado com equações e matrizes."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivadas parciais (100% corretas).",
                                "Correta avaliação no ponto de equilíbrio.",
                                "Dimensões matriciais adequadas (A: nxn, B: nxm).",
                                "Validação numérica com erro <5% em simulação.",
                                "Clareza na documentação e ausência de erros algébricos.",
                                "Análise qualitativa de estabilidade incluída."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear.",
                                "Controle Automático: Análise de linearização para LQR/LQG.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Dinâmica de sistemas aeronáuticos não-lineares.",
                                "Engenharia de Software: Verificação e validação de modelos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, usado para linearizar equações de movimento de aeronaves em condições de voo trim (ex: cruzeiro estável), permitindo design de controladores PID/LQR para estabilidade e manobras em aviões/drones."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Linearização por Expansão de Taylor",
                    "description": "Aproximação de primeira ordem usando série de Taylor ao redor de um ponto de operação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Série de Taylor",
                        "description": "Expansão de uma função suave em série infinita de potências ao redor de um ponto específico, permitindo aproximações locais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Fórmula da série de Taylor univariada",
                            "description": "Derivar e aplicar a fórmula da série de Taylor para funções de uma variável: f(x) ≈ f(x0) + f'(x0)(x - x0) + (1/2)f''(x0)(x - x0)^2 + ..., identificando termos até segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Expansão em Série",
                                  "subSteps": [
                                    "Revise o conceito de polinômios e aproximações locais de funções contínuas e diferenciáveis.",
                                    "Estude a motivação da série de Taylor: aproximar funções complexas por polinômios simples em torno de um ponto x0.",
                                    "Identifique os requisitos: função f(x) com derivadas contínuas até ordem n em x0.",
                                    "Discuta o limite quando o número de termos tende ao infinito para funções analíticas.",
                                    "Compare com aproximação linear (primeira ordem) versus quadrática (segunda ordem)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que a série de Taylor converge para a função em x0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Gráfico de funções como sin(x) e exp(x)",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize graficamente a tangente (1ª ordem) e a parábola (2ª ordem) tocando a curva em x0.",
                                  "learningObjective": "Entender a base teórica da série de Taylor como aproximação polinomial local.",
                                  "commonMistakes": [
                                    "Confundir com série de Maclaurin (x0=0)",
                                    "Ignorar a necessidade de derivadas contínuas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula Geral da Série de Taylor Univariada",
                                  "subSteps": [
                                    "Comece com a definição integral da série de Taylor usando o resto de Lagrange.",
                                    "Derive o termo geral: f(x) = Σ [f^(n)(x0)/n!] (x - x0)^n para n de 0 a ∞.",
                                    "Foque na truncagem até segunda ordem: f(x) ≈ f(x0) + f'(x0)(x - x0) + (1/2)f''(x0)(x - x0)^2.",
                                    "Prove os coeficientes usando indução ou expansão binomial generalizada.",
                                    "Escreva a fórmula explicitamente para n=0,1,2."
                                  ],
                                  "verification": "Escreva a fórmula completa até segunda ordem e justifique cada termo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de derivadas básicas",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Lembre-se: o fatorial n! no denominador garante convergência rápida.",
                                  "learningObjective": "Derivar e memorizar a fórmula exata até segunda ordem.",
                                  "commonMistakes": [
                                    "Esquecer o 1/2 no termo quadrático",
                                    "Confundir f''(x0) com f'(x0)^2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Fórmula a Funções Simples",
                                  "subSteps": [
                                    "Escolha uma função exemplo, como f(x) = sin(x), x0 = π/4.",
                                    "Calcule f(x0), f'(x0), f''(x0) explicitamente.",
                                    "Substitua na fórmula e simplifique até segunda ordem.",
                                    "Plote a função original versus a aproximação para validar visualmente.",
                                    "Calcule o erro de truncagem (resto de Taylor) qualitativamente."
                                  ],
                                  "verification": "Produza a expansão correta e um gráfico comparativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Python/MATLAB para plotagem",
                                    "Funções de teste pré-definidas"
                                  ],
                                  "tips": "Use x0 onde as derivadas são fáceis, como 0 ou π/2 para trigonométricas.",
                                  "learningObjective": "Executar cálculos precisos de expansão para funções univariadas.",
                                  "commonMistakes": [
                                    "Erro em cálculo de derivadas em x0",
                                    "Não expandir (x - x0)^2 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Usar Termos até Segunda Ordem em Linearização",
                                  "subSteps": [
                                    "Relacione com linearização de modelos não-lineares em equilíbrio (ex: sistemas dinâmicos).",
                                    "Aplique a uma equação diferencial não-linear, linearizando em torno de um ponto de operação.",
                                    "Ignore termos de ordem superior para obter modelo linearizado.",
                                    "Verifique a validade do modelo em uma vizinhança pequena de x0.",
                                    "Discuta quando a segunda ordem é necessária (curvatura significativa)."
                                  ],
                                  "verification": "Linearize uma equação exemplo e compare com solução numérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de sistemas aeronáuticos",
                                    "Software de simulação como Simulink"
                                  ],
                                  "tips": "Em engenharia, x0 é o ponto de equilíbrio estável.",
                                  "learningObjective": "Aplicar a série de Taylor para linearização prática em contextos de engenharia.",
                                  "commonMistakes": [
                                    "Incluir termos desnecessários",
                                    "Não avaliar o raio de convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para modelar o movimento de uma aeronave, linearize a função de arrasto f(α) = k α^3 + c α em torno do ângulo de ataque de equilíbrio α0 = 5°, usando série de Taylor até segunda ordem para obter um modelo linear aproximado para controle de voo.",
                              "finalVerifications": [
                                "Escreve corretamente a fórmula até segunda ordem sem erros.",
                                "Calcula expansões para pelo menos duas funções diferentes.",
                                "Identifica o papel da segunda derivada na curvatura da aproximação.",
                                "Avalia graficamente a precisão da aproximação em uma vizinhança de x0.",
                                "Aplica a linearização a um modelo dinâmico simples.",
                                "Discute limitações do resto de Taylor."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% dos termos corretos).",
                                "Corretude nos cálculos de derivadas e substituições (erro <1%).",
                                "Qualidade da visualização gráfica e análise de erro.",
                                "Relevância da aplicação ao contexto de linearização.",
                                "Clareza na explicação de conceitos e justificativas.",
                                "Criatividade em exemplos interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aproximações em oscilações harmônicas pequenas (lei de Hooke).",
                                "Programação: Implementar série de Taylor em Python para simulações numéricas.",
                                "Controle Automático: Linearização de plantas não-lineares para PID.",
                                "Cálculo Numérico: Estimativa de erros e métodos de otimização."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a série de Taylor univariada é usada para linearizar equações não-lineares de dinâmica de voo em torno de condições de trim, permitindo o design de controladores estáveis para sistemas de autopilotagem em aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Série de Taylor multivariada",
                            "description": "Estender a expansão de Taylor para funções de múltiplas variáveis: f(x,y) ≈ f(x0,y0) + ∇f·Δ + (1/2)Δ^T H Δ, onde ∇f é o gradiente e H a matriz hessiana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar derivadas parciais e introduzir o gradiente",
                                  "subSteps": [
                                    "Recordar o conceito de derivadas parciais para funções f(x,y).",
                                    "Calcular derivadas parciais primeiras ∂f/∂x e ∂f/∂y em um ponto (x0,y0).",
                                    "Construir o vetor gradiente ∇f = [∂f/∂x, ∂f/∂y] no ponto de expansão.",
                                    "Interpretar geometricamente o gradiente como direção de maior variação.",
                                    "Praticar com funções simples como f(x,y) = x² + y²."
                                  ],
                                  "verification": "Calcular corretamente o gradiente de pelo menos três funções multivariadas dadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno e lápis",
                                    "Calculadora gráfica",
                                    "Livro de Cálculo Multivariável (capítulo de funções vetoriais)"
                                  ],
                                  "tips": "Use notação vetorial para visualizar o gradiente como um vetor no plano.",
                                  "learningObjective": "Dominar o cálculo e interpretação do gradiente como primeira aproximação linear.",
                                  "commonMistakes": [
                                    "Confundir derivada parcial com derivada total",
                                    "Esquecer de avaliar no ponto (x0,y0)",
                                    "Ignorar a direção do gradiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e calcular a matriz Hessiana",
                                  "subSteps": [
                                    "Calcular derivadas parciais segundas: ∂²f/∂x², ∂²f/∂x∂y, ∂²f/∂y∂x, ∂²f/∂y².",
                                    "Montar a matriz Hessiana H = [[∂²f/∂x², ∂²f/∂x∂y], [∂²f/∂y∂x, ∂²f/∂y²]] no ponto (x0,y0).",
                                    "Verificar simetria da Hessiana (∂²f/∂x∂y = ∂²f/∂y∂x).",
                                    "Interpretar a Hessiana como curvatura da função.",
                                    "Exercitar com f(x,y) = sin(x)cos(y)."
                                  ],
                                  "verification": "Construir a Hessiana correta para duas funções e verificar sua simetria.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para verificação numérica",
                                    "Caderno",
                                    "Tutorial online sobre Hessiana"
                                  ],
                                  "tips": "A simetria facilita cálculos; use propriedades de derivadas mistas.",
                                  "learningObjective": "Compreender a Hessiana como termo quadrático da expansão.",
                                  "commonMistakes": [
                                    "Erro no sinal das derivadas segundas",
                                    "Não avaliar na base (x0,y0)",
                                    "Confundir ordem das derivadas mistas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a expansão de Taylor multivariada",
                                  "subSteps": [
                                    "Escrever a fórmula completa: f(x,y) ≈ f(x0,y0) + ∇f · Δ + (1/2) Δ^T H Δ, onde Δ = [x-x0, y-y0].",
                                    "Expandir o termo linear: ∇f · Δ = ∂f/∂x Δx + ∂f/∂y Δy.",
                                    "Expandir o termo quadrático: (1/2) [Δx, Δy] H [Δx; Δy].",
                                    "Comparar com univariada para intuición.",
                                    "Derivar a aproximação linear (primeira ordem) e quadrática."
                                  ],
                                  "verification": "Escrever e expandir corretamente a série para uma função dada até segunda ordem.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Caderno",
                                    "Notas de aula sobre Taylor univariada"
                                  ],
                                  "tips": "Comece com Δ pequeno para validar a aproximação numericamente.",
                                  "learningObjective": "Formular precisamente a expansão de Taylor multivariada de segunda ordem.",
                                  "commonMistakes": [
                                    "Fator 1/2 esquecido no termo quadrático",
                                    "Erro na multiplicação matricial Δ^T H Δ",
                                    "Confundir notação vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em linearização de modelos dinâmicos",
                                  "subSteps": [
                                    "Escolher um modelo não-linear, ex: equação de movimento f(v, α) em aerodinâmica.",
                                    "Linearizar ao redor de equilíbrio (x0,y0) usando a expansão (ignorar termos >1).",
                                    "Implementar numericamente e plotar aproximação vs. original.",
                                    "Analisar erro de aproximação para Δ pequeno.",
                                    "Discutir validade local da linearização."
                                  ],
                                  "verification": "Linearizar um modelo dado e mostrar gráfico com erro <5% em vizinhança.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplos de modelos aeronáuticos",
                                    "Gráficos para visualização"
                                  ],
                                  "tips": "Use plots 3D para visualizar superfície vs. parabolóide aproximado.",
                                  "learningObjective": "Aplicar a expansão para linearizar sistemas em engenharia.",
                                  "commonMistakes": [
                                    "Não truncar termos superiores",
                                    "Escolha inadequada do ponto de expansão",
                                    "Ignorar dependências no contexto dinâmico"
                                  ]
                                }
                              ],
                              "practicalExample": "Linearize a função de sustentação em aeronáutica L(α, Ma) = CL0 * α + k * α² * Ma ao redor de (α0=5°, Ma0=0.8), calculando gradiente e Hessiana para obter modelo linear ΔL ≈ ∂L/∂α Δα + ∂L/∂Ma ΔMa.",
                              "finalVerifications": [
                                "Calcular gradiente e Hessiana corretamente para funções dadas.",
                                "Expandir série de Taylor multivariada até segunda ordem sem erros.",
                                "Linearizar um modelo não-linear e validar numericamente.",
                                "Interpretar termos físico-matematicamente.",
                                "Identificar limitações da aproximação (raio de convergência)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de derivadas e expansões (90% correto).",
                                "Capacidade de aplicação em contexto real (ex: aerodinâmica).",
                                "Interpretação qualitativa dos termos (gradiente como inclinação, Hessiana como curvatura).",
                                "Análise de erros e validade da aproximação.",
                                "Clareza na derivação e comunicação dos resultados.",
                                "Uso correto de ferramentas computacionais para verificação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aproximações em mecânica clássica e dinâmica de fluidos.",
                                "Controle Automático: Linearização para síntese de controladores.",
                                "Programação: Implementação numérica em Python/MATLAB para otimização.",
                                "Otimização: Uso em métodos de Newton multivariados."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a série de Taylor multivariada é essencial para linearizar equações não-lineares de movimento de aeronaves ao redor de condições de equilíbrio (ex: voo nivelado), permitindo o design de sistemas de controle estável como autopilotos em sinais e sistemas dinâmicos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Aproximação de primeira ordem",
                            "description": "Truncar a série de Taylor no termo linear para obter a aproximação afim: f(x) ≈ f(x0) + f'(x0)(x - x0), justificando sua validade para pequenas perturbações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos da Série de Taylor",
                                  "subSteps": [
                                    "Lembre-se da fórmula geral da série de Taylor para uma função f(x) ao redor de x0: f(x) = f(x0) + f'(x0)(x - x0) + (f''(x0)/2!)(x - x0)^2 + ...",
                                    "Identifique os termos: termo constante f(x0), termo linear f'(x0)(x - x0), e termos de ordem superior.",
                                    "Discuta a convergência: a série converge para funções suficientemente suaves em um raio ao redor de x0.",
                                    "Pratique escrevendo a série para funções simples como sin(x) ou e^x ao redor de x0 = 0.",
                                    "Compare visualmente a série completa vs. truncada em um gráfico mental ou esboçado."
                                  ],
                                  "verification": "Escreva corretamente a série de Taylor de ordem 3 para f(x) = e^x em x0=0 e identifique os três primeiros termos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Gráficos online de séries de Taylor (ex: Desmos)"
                                  ],
                                  "tips": "Sempre normalize em torno do ponto de expansão x0 para simplificar cálculos.",
                                  "learningObjective": "Compreender a estrutura infinita da série de Taylor e identificar componentes individuais.",
                                  "commonMistakes": [
                                    "Confundir derivadas com potências",
                                    "Esquecer o fator (x - x0)^n",
                                    "Ignorar o fatorial no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Aproximação de Primeira Ordem",
                                  "subSteps": [
                                    "Trunque a série no termo linear: f(x) ≈ f(x0) + f'(x0)(x - x0).",
                                    "Nomeie isso como aproximação afim ou linear.",
                                    "Calcule f(x0) e f'(x0) para uma função genérica.",
                                    "Interprete geometricamente: é a reta tangente à curva em x0.",
                                    "Esboce a tangente em um gráfico para visualizar."
                                  ],
                                  "verification": "Derive a aproximação afim para f(x) = sin(x) em x0 = π/2 e confirme que coincide com cos(x) ≈ 1 - (x - π/2)^2/2, mas truncada linearmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem como GeoGebra ou Python/Matplotlib"
                                  ],
                                  "tips": "Pense na derivada como inclinação da tangente para lembrar o termo linear.",
                                  "learningObjective": "Construir e nomear corretamente a fórmula da aproximação de primeira ordem.",
                                  "commonMistakes": [
                                    "Incluir termos quadráticos acidentalmente",
                                    "Usar f(x) em vez de f(x0)",
                                    "Confundir f'(x0) com f'(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Aproximação a Funções Específicas",
                                  "subSteps": [
                                    "Escolha uma função não-linear, como f(x) = x^2 + sin(x), e x0.",
                                    "Calcule f(x0) e f'(x0).",
                                    "Escreva e avalie a aproximação para valores de x próximos a x0.",
                                    "Compare numericamente com o valor exato para δx pequeno (ex: 0.01).",
                                    "Registre os erros para diferentes tamanhos de perturbação."
                                  ],
                                  "verification": "Para f(x) = e^x em x0=1, calcule aproximação em x=1.1 e compare com exato (erro < 0.01).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para cálculos numéricos"
                                  ],
                                  "tips": "Use δx = x - x0 para simplificar notação em cálculos.",
                                  "learningObjective": "Executar cálculos precisos da aproximação e compará-la com valores reais.",
                                  "commonMistakes": [
                                    "Erros aritméticos em derivadas",
                                    "Avaliar em δx grande onde falha",
                                    "Não subtrair x0 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a Validade para Pequenas Perturbações",
                                  "subSteps": [
                                    "Analise o resto da série de Taylor: R1(x) = (f''(ξ)/2)(x - x0)^2 para algum ξ entre x0 e x.",
                                    "Mostre que |R1| ≈ O((x - x0)^2), pequeno quando |x - x0| << 1.",
                                    "Use exemplos numéricos para demonstrar erro quadrático.",
                                    "Discuta condições: f diferenciável e f' contínua.",
                                    "Relacione com linearização em sistemas dinâmicos (equilíbrio em x0)."
                                  ],
                                  "verification": "Explique por quê a aproximação é boa para |δx| < 0.1, citando o resto quadrático, com exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de cálculo ou notas de aula",
                                    "Software para plotar erro vs. δx"
                                  ],
                                  "tips": "Grafique log(erros) vs. log(|δx|) para ver inclinação 2, confirmando ordem quadrática.",
                                  "learningObjective": "Justificar matematicamente a precisão para pequenas perturbações.",
                                  "commonMistakes": [
                                    "Ignorar o resto da série",
                                    "Achar válida para δx grande",
                                    "Confundir com aproximação quadrática"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Engenharia Aeronáutica, linearize a equação de arrasto D(v) = 0.5 ρ v^2 C_d A em torno de velocidade de cruzeiro v0=200 m/s: D(v) ≈ D(v0) + ρ v0 C_d A (v - v0), usada para modelar pequenas variações de velocidade em controle de voo.",
                              "finalVerifications": [
                                "Deriva corretamente a aproximação afim para 3 funções dadas.",
                                "Calcula valores aproximados com erro <1% para |δx|<0.05.",
                                "Explica geometricamente como reta tangente.",
                                "Quantifica o resto como O(δx^2).",
                                "Aplica a um exemplo de sistema dinâmico.",
                                "Identifica quando a aproximação falha (δx grande)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% dos termos corretos).",
                                "Correção nos cálculos numéricos (erro relativo <0.5%).",
                                "Profundidade da justificativa de validade (inclui resto da série).",
                                "Clareza na interpretação geométrica e física.",
                                "Criatividade na aplicação a contexto aeronáutico.",
                                "Identificação precisa de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas e tangentes.",
                                "Física: Aproximações em movimento harmônico pequeno.",
                                "Programação: Implementar em Python para plotar aproximações.",
                                "Controle de Sistemas: Linearização para estabilidade.",
                                "Estatística: Aproximações lineares em regressão."
                              ],
                              "realWorldApplication": "Na análise de estabilidade de aeronaves, lineariza equações não-lineares de dinâmica ao redor de pontos de equilíbrio (ex: voo nivelado), permitindo uso de ferramentas lineares como eigenvalores para prever comportamento sob pequenas perturbações, essencial para certificação de segurança pela ANAC/FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Ponto de Operação",
                        "description": "Ponto de equilíbrio estável onde variáveis do sistema permanecem constantes na ausência de perturbações, essencial para linearização.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Definição de ponto de equilíbrio",
                            "description": "Identificar o ponto de operação (x0, u0) onde dx/dt = 0 para sistemas autônomos ou f(x0, u0) = 0 em equações dinâmicas não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Sistemas Dinâmicos",
                                  "subSteps": [
                                    "Revise a definição de sistemas dinâmicos contínuos: dx/dt = f(x, u).",
                                    "Identifique sistemas autônomos (u=0 ou constante) versus não-autônomos.",
                                    "Entenda que equilíbrio ocorre quando a derivada temporal é zero: dx/dt = 0.",
                                    "Diferencie ponto de equilíbrio de soluções de equilíbrio (constantes).",
                                    "Estude notação: x0 (estado de equilíbrio), u0 (entrada de equilíbrio)."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos chave e forneça um exemplo simples de não-equilíbrio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Sistemas Dinâmicos, caderno de anotações",
                                  "tips": "Use diagramas de fase para visualizar trajetórias convergindo para equilíbrio.",
                                  "learningObjective": "Dominar terminologia e condições matemáticas de equilíbrio.",
                                  "commonMistakes": "Confundir equilíbrio com estado estacionário em sistemas discretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Equilíbrio em Sistemas Autônomos",
                                  "subSteps": [
                                    "Escreva a equação autônoma: dx/dt = f(x).",
                                    "Resolva f(x0) = 0 para encontrar x0.",
                                    "Analise estabilidade qualitativa (ex: sinal de df/dx em x0).",
                                    "Verifique com plot de f(x) ou diagrama de fase.",
                                    "Teste numericamente: simule dx/dt próximo a x0."
                                  ],
                                  "verification": "Encontre x0 para dx/dt = x(1 - x) e confirme dx/dt=0 em x0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica, software como MATLAB ou Python (SciPy)",
                                  "tips": "Comece com equações escalares lineares para ganhar confiança.",
                                  "learningObjective": "Resolver algebraicamente pontos de equilíbrio em sistemas sem entrada.",
                                  "commonMistakes": "Ignorar múltiplas raízes ou soluções complexas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar Ponto de Operação em Sistemas Não-Lineares com Entrada",
                                  "subSteps": [
                                    "Escreva dx/dt = f(x, u) e assuma u constante (u0).",
                                    "Resolva f(x0, u0) = 0 simultaneamente para x0 e u0.",
                                    "Para vetores: F(x0, u0) = 0 (sistema de equações não-lineares).",
                                    "Use métodos numéricos se analítico impossível (ex: fsolve no MATLAB).",
                                    "Valide substituindo de volta na equação original."
                                  ],
                                  "verification": "Para dx/dt = -x + u, encontre (x0=1, u0=1) e verifique.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de resolução numérica (MATLAB, Python), exemplos impressos",
                                  "tips": "Fixe u0 primeiro se possível, depois resolva para x0.",
                                  "learningObjective": "Lidar com entradas constantes em modelos não-lineares.",
                                  "commonMistakes": "Esquecer que u0 deve ser constante para equilíbrio."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em Contextos Aeronáuticos",
                                  "subSteps": [
                                    "Selecione modelo simples de aeronave (ex: velocidade constante em voo nivelado).",
                                    "Identifique equações: dx/dt = f(x, u) onde x=velocidade, u=empuxo.",
                                    "Resolva para ponto de trim (equilíbrio).",
                                    "Compare com linearização em torno de (x0, u0).",
                                    "Simule perturbações para observar retorno ao equilíbrio."
                                  ],
                                  "verification": "Documente (x0, u0) para um modelo dado e plote trajetórias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Modelos de exemplo em PDF, simulador (Simulink ou Python)",
                                  "tips": "Relacione com 'trim' em aviação para motivação.",
                                  "learningObjective": "Contextualizar definição em engenharia aeronáutica.",
                                  "commonMistakes": "Não considerar restrições físicas (ex: u0 > 0)."
                                }
                              ],
                              "practicalExample": "Em um modelo simplificado de drone: dx/dt = -0.1x + u - 0.05x^2. Para u0=1, resolva -0.1x0 +1 -0.05x0^2=0 → x0≈5.26 (velocidade de cruzeiro estável).",
                              "finalVerifications": [
                                "dx/dt = 0 exatamente em (x0, u0).",
                                "Trajetórias simuladas convergem para x0 com u=u0 constante.",
                                "Jacobiano em (x0,u0) permite análise de estabilidade.",
                                "Solução única ou múltiplas identificadas corretamente.",
                                "Validação numérica com erro <1e-6.",
                                "Documentação clara com passos algébricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na resolução de f(x0,u0)=0.",
                                "Correta distinção entre autônomo e não-autônomo.",
                                "Uso apropriado de ferramentas numéricas.",
                                "Interpretação física do ponto de equilíbrio.",
                                "Clareza na verificação e documentação.",
                                "Identificação de múltiplos equilíbrios se aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações não-lineares e séries de Taylor.",
                                "Física: Dinâmica de partículas e estabilidade em mecânica.",
                                "Controle Automático: Linearização para controladores LQR/PID.",
                                "Programação: Simulações numéricas em Python/MATLAB."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, define condições de trim (voo estável) para aeronaves, essencial para design de controladores de voo autônomo e análise de manobras seguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Cálculo do ponto de operação",
                            "description": "Resolver equações algébricas não-lineares para encontrar valores constantes de estado (x*) e entrada (u*) que satisfazem as condições de equilíbrio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo do sistema e condições de equilíbrio",
                                  "subSteps": [
                                    "Identifique as equações diferenciais não-lineares do sistema: dx/dt = f(x, u).",
                                    "Defina as condições de equilíbrio: dx/dt = 0, com x = x* constante e u = u* constante.",
                                    "Reescreva as equações para f(x*, u*) = 0.",
                                    "Analise as dimensões: número de equações igual ao número de variáveis desconhecidas (x* e u*).",
                                    "Registre os valores conhecidos ou restrições do problema."
                                  ],
                                  "verification": "Confirme que as equações de equilíbrio estão corretamente formuladas e balanceadas em número de equações e variáveis.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Equações do modelo do sistema",
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre verifique unidades físicas para consistência nas equações.",
                                  "learningObjective": "Entender conceitualmente o que é um ponto de operação e como derivá-lo das equações dinâmicas.",
                                  "commonMistakes": [
                                    "Confundir variáveis de estado com entradas",
                                    "Esquecer de definir dx/dt = 0",
                                    "Ignorar restrições físicas como valores positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e simplificar as equações algébricas não-lineares",
                                  "subSteps": [
                                    "Substitua dx/dt = 0 nas equações originais para obter f(x*, u*) = 0.",
                                    "Expresse entradas u* em termos de estados x* se possível, ou vice-versa.",
                                    "Simplifique expressões algébricas usando identidades matemáticas.",
                                    "Identifique se há soluções triviais (ex: x*=0, u*=0).",
                                    "Anote o sistema como um conjunto de n equações não-lineares para n incógnitas."
                                  ],
                                  "verification": "As equações resultantes devem ser puramente algébricas, sem derivadas, e resolvíveis para x* e u*.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como SymPy ou Mathematica (opcional)"
                                  ],
                                  "tips": "Use substituições auxiliares para reduzir não-linearidades quando possível.",
                                  "learningObjective": "Capacitar a transformação de modelos dinâmicos em problemas estáticos não-lineares.",
                                  "commonMistakes": [
                                    "Manter termos dinâmicos acidentalmente",
                                    "Erros de álgebra básica",
                                    "Não considerar múltiplas soluções possíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver as equações não-lineares",
                                  "subSteps": [
                                    "Avalie se solução analítica é viável (ex: polinômios baixos graus).",
                                    "Se analítica falhar, use métodos numéricos: inicial guess, fsolve no MATLAB/Python ou Newton-Raphson manual.",
                                    "Implemente solver numérico com chute inicial razoável baseado em física.",
                                    "Encontre todas as soluções relevantes e selecione a fisicamente plausível.",
                                    "Calcule precisão com tolerância (ex: 1e-6)."
                                  ],
                                  "verification": "Substitua x* e u* de volta nas equações de equilíbrio e confirme que f(x*, u*) ≈ 0.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "MATLAB/Octave/Python com SciPy",
                                    "Calculadora gráfica para casos simples"
                                  ],
                                  "tips": "Comece com chute inicial próximo do esperado; plote funções para visualizar interseções.",
                                  "learningObjective": "Dominar técnicas analíticas e numéricas para resolução de sistemas não-lineares.",
                                  "commonMistakes": [
                                    "Chute inicial ruim levando a convergência errada",
                                    "Ignorar múltiplas raízes",
                                    "Não checar tolerância de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar o ponto de operação",
                                  "subSteps": [
                                    "Verifique se x* e u* satisfazem restrições físicas (ex: velocidades positivas, ângulos razoáveis).",
                                    "Calcule resíduos: ||f(x*, u*)|| < epsilon.",
                                    "Documente o ponto: valores exatos, método usado, chute inicial.",
                                    "Discuta sensibilidade a parâmetros.",
                                    "Prepare para linearização subsequente (Jacobiana em x*, u*)."
                                  ],
                                  "verification": "Resíduos numéricos devem ser inferiores a 1e-6 e valores fisicamente consistentes.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Software de plotagem (opcional)",
                                    "Folha de cálculo para documentação"
                                  ],
                                  "tips": "Sempre valide com simulação dinâmica curta em torno do ponto.",
                                  "learningObjective": "Garantir robustez e aplicabilidade prática do ponto de operação calculado.",
                                  "commonMistakes": [
                                    "Aceitar soluções não-físicas",
                                    "Esquecer documentação",
                                    "Não testar resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de controle de altitude de aeronave: dV/dt = (T - D(V, α)) / m, dh/dt = V sin(α), com equilíbrio em voo nivelado: T* = D(V*, α*), V* sin(α*) = 0 → α*=0, resolva T* = D(V*, 0) numericamente para V* dado.",
                              "finalVerifications": [
                                "Equações de equilíbrio corretamente derivadas de dx/dt = 0.",
                                "Soluções x* e u* com resíduos < 1e-6.",
                                "Valores fisicamente plausíveis no contexto aeronáutico.",
                                "Documentação completa com método e chute inicial.",
                                "Preparação para linearização (identificação de Jacobiana).",
                                "Teste de sensibilidade a variações de parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das equações de equilíbrio (100% correto).",
                                "Correta implementação e convergência do solver numérico.",
                                "Seleção apropriada da solução física entre múltiplas.",
                                "Validação rigorosa com resíduos e restrições.",
                                "Clareza na documentação e discussão de limitações.",
                                "Tempo de execução eficiente sem erros evitáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra não-linear e métodos numéricos (Newton-Raphson).",
                                "Programação: Implementação de solvers em Python/MATLAB.",
                                "Física: Dinâmica de sistemas aeronáuticos e equilíbrio.",
                                "Controle Automático: Base para linearização e controle LTI.",
                                "Engenharia de Software: Validação e testes numéricos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular pontos de operação (trim conditions) para voo estável em velocidades e altitudes específicas, essencial para design de controladores de voo autônomos em drones ou aviões comerciais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Linearização de Modelos Dinâmicos",
                        "description": "Aplicação da expansão de Taylor de primeira ordem em equações diferenciais não-lineares para obter um modelo linearizado válido localmente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Linearização de função escalar",
                            "description": "Aplicar Taylor em f(x,u) ≈ f(x0,u0) + (∂f/∂x)(x-x0) + (∂f/∂u)(u-u0), definindo variáveis de desvio δx = x - x0 e δu = u - u0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Expansão de Taylor para Funções Multivariáveis",
                                  "subSteps": [
                                    "Revise a expansão de Taylor univariável: f(x) ≈ f(x0) + f'(x0)(x - x0).",
                                    "Estenda para funções f(x,u): inclua termos de primeira ordem em ambas as variáveis.",
                                    "Identifique que a linearização ignora termos de ordem superior para pequenas perturbações.",
                                    "Anote a fórmula geral: f(x,u) ≈ f(x0,u0) + (∂f/∂x)(x-x0) + (∂f/∂u)(u-u0).",
                                    "Discuta validade: aproximação boa perto de (x0,u0)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem da fórmula e suas limitações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sistemas Dinâmicos (cap. Linearização)",
                                    "Caderno para anotações",
                                    "Calculadora simbólica (ex: SymPy)"
                                  ],
                                  "tips": "Visualize graficamente: a reta tangente em 2D para f(x,u).",
                                  "learningObjective": "Entender conceitualmente a base matemática da linearização.",
                                  "commonMistakes": [
                                    "Confundir com expansão completa (incluir quadráticos)",
                                    "Ignorar que é aproximação local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Verificar o Ponto de Operação (x0, u0)",
                                  "subSteps": [
                                    "Defina o ponto de equilíbrio: onde δx = 0 e δu = 0 implicam dinâmica nula.",
                                    "Para sistemas dinâmicos, resolva f(x0,u0) = 0 se aplicável.",
                                    "Confirme que (x0,u0) é estável ou de interesse (ex: voo nivelado).",
                                    "Calcule f(x0,u0) explicitamente.",
                                    "Documente valores numéricos ou simbólicos."
                                  ],
                                  "verification": "Mostre que f(x0,u0) é computado corretamente e é o ponto desejado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função f(x,u) exemplo",
                                    "Software MATLAB/SymPy para avaliação"
                                  ],
                                  "tips": "Escolha pontos realistas do contexto aeronáutico, como trim conditions.",
                                  "learningObjective": "Identificar corretamente o operating point para linearização.",
                                  "commonMistakes": [
                                    "Escolher ponto arbitrário sem justificativa",
                                    "Não verificar f(x0,u0)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Derivadas Parciais no Ponto de Operação",
                                  "subSteps": [
                                    "Compute ∂f/∂x |_{(x0,u0)} usando regras de derivação (produto, cadeia).",
                                    "Compute ∂f/∂u |_{(x0,u0)} de forma similar.",
                                    "Substitua x=x0, u=u0 nas derivadas.",
                                    "Use ferramentas simbólicas para evitar erros algébricos.",
                                    "Armazene como A = ∂f/∂x e B = ∂f/∂u."
                                  ],
                                  "verification": "Derivadas coincidem com solução analítica conhecida ou numérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função f(x,u)",
                                    "SymPy/MATLAB para derivadas simbólicas",
                                    "Papel para derivações manuais"
                                  ],
                                  "tips": "Para funções complexas, derive passo a passo para transparência.",
                                  "learningObjective": "Dominar cálculo de sensibilidades parciais em equilíbrio.",
                                  "commonMistakes": [
                                    "Derivar em ponto errado",
                                    "Esquecer substituição em (x0,u0)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a Aproximação Linear e Definir Variáveis de Desvio",
                                  "subSteps": [
                                    "Escreva f(x,u) ≈ f(x0,u0) + A δx + B δu, onde δx = x - x0, δu = u - u0.",
                                    "Simplifique: se f(x0,u0)=0, fica f ≈ A δx + B δu.",
                                    "Expresse o modelo linearizado completo em termos de δx, δu.",
                                    "Verifique no ponto: δx=0, δu=0 implica f≈0.",
                                    "Compare com original para pequenas perturbações."
                                  ],
                                  "verification": "Substitua valores pequenos e confira erro <5%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Gráficos para plotar original vs linear"
                                  ],
                                  "tips": "Sempre introduza δ para clareza em simulações.",
                                  "learningObjective": "Construir e expressar o modelo linearizado final.",
                                  "commonMistakes": [
                                    "Esquecer f(x0,u0)",
                                    "Não definir δx, δu explicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Linearize a função de sustentação L(α, V) = 0.5 ρ V² S CL(α), em α0=5°, V0=100 m/s, onde CL(α)=a α. Compute ∂L/∂α e ∂L/∂V em (α0,V0), obtenha L ≈ L0 + (∂L/∂α) δα + (∂L/∂V) δV.",
                              "finalVerifications": [
                                "A linearização reproduz f(x0,u0) exatamente.",
                                "Derivadas parciais calculadas corretamente (ver analítico).",
                                "Variáveis δx e δu definidas e usadas consistentemente.",
                                "Erro de aproximação <1% para perturbações de 5%.",
                                "Modelo escrito na forma δẋ = A δx + B δu se dinâmico.",
                                "Gráfico mostra boa sobreposição perto do ponto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual da expansão de Taylor (100%).",
                                "Correção no cálculo de ∂f/∂x e ∂f/∂u (80%).",
                                "Uso correto de δx, δu (obrigatório).",
                                "Verificação numérica da aproximação.",
                                "Clareza na derivação e documentação.",
                                "Aplicação contextual em aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo Multivariável (derivadas parciais).",
                                "Controle Automático: Modelos lineares para LQR/LQG.",
                                "Física: Pequenas perturbações em dinâmica de fluidos.",
                                "Programação: SymPy para automação de linearização.",
                                "Engenharia de Software: Validação de modelos numéricos."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, lineariza-se o modelo não-linear de 6-DOF em condições de trim (voo nivelado) para projetar autômatos de piloto estável, como em simuladores de voo da Boeing ou SpaceX."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Linearização de sistemas vetoriais",
                            "description": "Para ẋ = f(x,u), obter A = ∂f/∂x |_{x0,u0} e B = ∂f/∂u |_{x0,u0}, resultando em δ̇x = A δx + B δu.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e representar o sistema dinâmico não-linear",
                                  "subSteps": [
                                    "Leia a equação diferencial autônoma ou forçada: ẋ = f(x, u), onde x ∈ ℝⁿ e u ∈ ℝᵐ.",
                                    "Escreva explicitamente cada componente f_i(x, u) para i = 1 a n.",
                                    "Determine as dimensões dos vetores x e u, e confirme que f é contínua e diferenciável.",
                                    "Identifique possíveis pontos de equilíbrio resolvendo f(x₀, u₀) = 0.",
                                    "Anote o contexto físico ou de engenharia do sistema (ex.: dinâmica de aeronave)."
                                  ],
                                  "verification": "Reescreva corretamente o sistema com dimensões e componentes explícitas em um papel ou software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Software simbólico (SymPy ou MATLAB)",
                                    "Notas de aula sobre sistemas dinâmicos"
                                  ],
                                  "tips": [
                                    "Sempre especifique dimensões para evitar confusões em cálculos matriciais.",
                                    "Desenhe um diagrama esquemático do sistema para visualização."
                                  ],
                                  "learningObjective": "Compreender a estrutura vetorial do sistema não-linear e suas propriedades básicas.",
                                  "commonMistakes": [
                                    "Confundir estado x com entrada u.",
                                    "Esquecer de verificar diferenciabilidade de f."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o ponto de linearização (x₀, u₀)",
                                  "subSteps": [
                                    "Escolha um ponto de equilíbrio estável ou de operação nominal (x₀, u₀) tal que f(x₀, u₀) = 0.",
                                    "Justifique a escolha com base no contexto (ex.: voo nivelado em aeronáutica).",
                                    "Calcule numericamente ou simbolicamente os valores de x₀ e u₀ se necessário.",
                                    "Defina as variáveis de variação: δx = x - x₀ e δu = u - u₀.",
                                    "Verifique se o ponto é admissível (dentro do domínio de f)."
                                  ],
                                  "verification": "Confirme que ẋ(x₀, u₀) = 0 e anote δx e δu corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB",
                                    "Referências teóricas sobre equilíbrio"
                                  ],
                                  "tips": [
                                    "Prefira pontos de equilíbrio para simplificação.",
                                    "Use valores realistas do contexto aeronáutico."
                                  ],
                                  "learningObjective": "Selecionar adequadamente o ponto de operação para linearização válida.",
                                  "commonMistakes": [
                                    "Escolher pontos fora do domínio.",
                                    "Não definir variações δx e δu explicitamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as matrizes Jacobianas A e B",
                                  "subSteps": [
                                    "Compute a matriz A = ∂f/∂x |_{(x₀,u₀)}, calculando cada entrada a_{ij} = ∂f_i/∂x_j no ponto.",
                                    "Compute a matriz B = ∂f/∂u |_{(x₀,u₀)}, calculando cada entrada b_{ij} = ∂f_i/∂u_j no ponto.",
                                    "Use expansão de Taylor de primeira ordem: f(x,u) ≈ f(x₀,u₀) + A δx + B δu.",
                                    "Verifique dimensões: A é n×n, B é n×m.",
                                    "Simplifique expressões usando regras de derivação parcial (ex.: chain rule para funções compostas)."
                                  ],
                                  "verification": "As matrizes A e B devem ter dimensões corretas e derivadas avaliadas precisamente no ponto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel milimetrado",
                                    "SymPy/MATLAB para derivação simbólica",
                                    "Tabela de derivadas comuns"
                                  ],
                                  "tips": [
                                    "Use notação matricial desde o início.",
                                    "Verifique simetria ou propriedades especiais de A."
                                  ],
                                  "learningObjective": "Dominar o cálculo de Jacobianas para sistemas vetoriais não-lineares.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais (confundir variáveis).",
                                    "Avaliar Jacobiana em ponto errado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar a equação linearizada",
                                  "subSteps": [
                                    "Escreva a equação linearizada: δ̇x = A δx + B δu.",
                                    "Substitua de volta x = x₀ + δx e u = u₀ + δu para confirmar.",
                                    "Compare o comportamento linearizado com o original em simulações pequenas.",
                                    "Analise autovalores de A para estabilidade local.",
                                    "Documente o modelo linear para uso em controle ou simulação."
                                  ],
                                  "verification": "A equação δ̇x = A δx + B δu é equivalente à aproximação de Taylor de 1ª ordem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Ferramenta de autovalores"
                                  ],
                                  "tips": [
                                    "Teste com perturbações pequenas para validar.",
                                    "Prepare para próxima etapa de controle."
                                  ],
                                  "learningObjective": "Construir e interpretar o modelo linearizado completo.",
                                  "commonMistakes": [
                                    "Esquecer o termo f(x₀,u₀)=0.",
                                    "Não verificar dimensões finais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o modelo longitudinal simplificado de uma aeronave: ẋ₁ = x₂, ẋ₂ = -g θ + (T/m) cos θ u, onde x=[V, α], mas simplificado para pêndulo controlado como proxy: ẋ₁ = x₂, ẋ₂ = -(g/l) sin(x₁) + b u, com ponto (x₀,u₀)=(0,0). Então A = [[0,1], [-(g/l), 0]], B = [[0], [b]]. Simule em MATLAB para verificar.",
                              "finalVerifications": [
                                "Matrizes A (n×n) e B (n×m) corretas dimensionalmente.",
                                "Derivadas parciais avaliadas precisamente em (x₀,u₀).",
                                "Equação δ̇x = A δx + B δu reproduz equilíbrio em δx=0, δu=0.",
                                "Simulação pequena coincide com não-linear.",
                                "Autovalores de A indicam estabilidade local esperada.",
                                "Documentação completa com justificativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Jacobianas (sem erros algébricos).",
                                "Correta seleção e justificativa do ponto (x₀,u₀).",
                                "Interpretação física correta da linearização.",
                                "Validação via simulação ou análise qualitativa.",
                                "Clareza na documentação e uso de notação vetorial.",
                                "Identificação de limitações da aproximação linear."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Multivariável: Derivadas parciais e Jacobianas.",
                                "Teoria de Controle: Modelos para LQR/LQG e estabilização.",
                                "Engenharia Aeronáutica: Análise de estabilidade de voo.",
                                "Programação e Simulação: Uso de MATLAB/Simulink.",
                                "Física: Dinâmica não-linear de sistemas mecânicos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a linearização é essencial para projetar controladores de atitude e estabilidade em aeronaves, permitindo análise de modos de voo (phugoid, short-period) e síntese de leis de comando em Simulink para UAVs ou aviões comerciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Validação da aproximação",
                            "description": "Avaliar o erro de linearização comparando respostas lineares e não-lineares para pequenas perturbações ao redor do ponto de operação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo não-linear e o ponto de operação",
                                  "subSteps": [
                                    "Identifique o sistema dinâmico não-linear relevante, como as equações de movimento de um pêndulo ou modelo longitudinal de aeronave.",
                                    "Especifique o ponto de operação (equilíbrio ou trim), resolvendo para estados e entradas constantes onde derivadas são zero.",
                                    "Calcule as condições de equilíbrio: dx/dt = 0 e u = u_eq.",
                                    "Documente todas as variáveis de estado x_eq, entrada u_eq e parâmetros do modelo.",
                                    "Verifique numericamente se o ponto satisfaz as equações não-lineares."
                                  ],
                                  "verification": "Confirme que no ponto de operação, as derivadas de estado são zero simulando ou calculando analiticamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Equações do modelo (papel ou editor de texto), calculadora ou software simbólico como SymPy/MATLAB Symbolic.",
                                  "tips": "Escolha um modelo familiar; para aeronáutica, use equações de voo simplificadas.",
                                  "learningObjective": "Compreender como identificar e validar pontos de operação em sistemas não-lineares.",
                                  "commonMistakes": "Esquecer de verificar se dx/dt = 0 no ponto eq; assumir linearidade prematuramente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o modelo linearizado via expansão de Taylor",
                                  "subSteps": [
                                    "Calcule as matrizes Jacobianas: A = df/dx em x_eq, B = df/du em x_eq, onde f é a dinâmica não-linear.",
                                    "Forme o modelo linear: δẋ = A δx + B δu, com δx = x - x_eq, δu = u - u_eq.",
                                    "Implemente analiticamente ou simbolicamente as derivadas parciais necessárias.",
                                    "Verifique dimensionalidade: A deve ser n x n, B n x m.",
                                    "Salve o modelo linear em formato simulável (matrizes numéricas)."
                                  ],
                                  "verification": "Compare a linearização de primeira ordem com a definição exata de Taylor para confirmação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (MATLAB, Python SymPy), equações não-lineares.",
                                  "tips": "Use funções diff() em MATLAB/SymPy para Jacobianas automáticas.",
                                  "learningObjective": "Dominar a linearização local via série de Taylor de primeira ordem.",
                                  "commonMistakes": "Avaliar Jacobianas em ponto errado; ignorar termos de segunda ordem inicialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular respostas para pequenas perturbações",
                                  "subSteps": [
                                    "Defina perturbações pequenas: δu(t) como degrau ou seno de amplitude 1-5% do u_eq.",
                                    "Simule o modelo não-linear completo com perturbação inicial em x_eq.",
                                    "Simule o modelo linearizado com mesmas condições iniciais e entradas.",
                                    "Registre trajetórias de estado δx_nl(t) e δx_lin(t) por 10-20 unidades de tempo.",
                                    "Plote respostas lado a lado para visualização qualitativa."
                                  ],
                                  "verification": "Trajetórias devem divergir minimamente nas primeiras oscilações para perturbações pequenas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (MATLAB Simulink, Python SciPy odeint, ou Octave).",
                                  "tips": "Use solver adaptativo (ode45) e tempo de simulação suficiente para transientes.",
                                  "learningObjective": "Executar simulações comparativas de modelos linear e não-linear.",
                                  "commonMistakes": "Perturbações grandes demais (invalida linearidade); escalas de plot erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar respostas e quantificar erro de aproximação",
                                  "subSteps": [
                                    "Calcule erros: e(t) = δx_nl(t) - δx_lin(t) para cada estado.",
                                    "Compute métricas: erro RMS, máximo absoluto, norma L2 sobre o intervalo.",
                                    "Plote erros e analise se < 5-10% para validar.",
                                    "Teste múltiplas perturbações (degrau, rampa, seno) para robustez.",
                                    "Conclua validade: aceitável se erros pequenos perto do ponto de operação."
                                  ],
                                  "verification": "Erro RMS < threshold (ex: 5%) e convergência qualitativa das trajetórias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Scripts de simulação e pós-processamento (MATLAB/Python com NumPy/Matplotlib).",
                                  "tips": "Normalize erros pela magnitude da perturbação para comparabilidade.",
                                  "learningObjective": "Quantificar precisão da linearização e interpretar resultados.",
                                  "commonMistakes": "Métricas inadequadas; ignorar fase vs amplitude em respostas oscilatórias."
                                }
                              ],
                              "practicalExample": "Para um modelo longitudinal simplificado de aeronave (equações de pitch rate q e ângulo de ataque α), linearize ao redor de voo nivelado (α_eq=0, q_eq=0). Aplique perturbação δθ_c = 0.01 rad (degrau em comando de elevador). Simule não-linear vs linear: valide se erro em α(t) fica <2% nos primeiros 5s.",
                              "finalVerifications": [
                                "Erros RMS <5% para todas perturbações testadas.",
                                "Trajetórias coincidem qualitativamente nas primeiras oscilações.",
                                "Análise de sensibilidade mostra validade para δx,δu <10% do eq.",
                                "Relatório documenta Jacobianas, simulações e métricas.",
                                "Teste com 3+ tipos de entrada confirma consistência.",
                                "Conclusão explícita: 'Aproximação válida/rejeitada' com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das Jacobianas (erro <1% numérico).",
                                "Escolha adequada de perturbações pequenas e múltiplas.",
                                "Cálculo correto de métricas de erro (RMS, max, L2).",
                                "Interpretação qualitativa e quantitativa coerente.",
                                "Documentação clara de plots, equações e conclusões.",
                                "Uso eficiente de ferramentas de simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Taylor e cálculo multivariável.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Dinâmica não-linear de sistemas aeronáuticos.",
                                "Estatística: Análise de erro e métricas de validação.",
                                "Controle: Base para design de controladores LQR/PID."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, validação assegura que controladores lineares (ex: piloto automático) funcionem perto de condições de trim, como cruzeiro, evitando instabilidades em manobras reais de aeronaves comerciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Aplicações da Linearização",
                    "description": "Exemplos de linearização em sistemas mecânicos, eletromecânicos e outros modelos dinâmicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Linearização em Sistemas Mecânicos",
                        "description": "Aplicação da técnica de linearização em modelos dinâmicos mecânicos, como pêndulos e sistemas massa-mola, para aproximar o comportamento não linear em torno de pontos de equilíbrio.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Linearizar o modelo de um pêndulo simples",
                            "description": "Derivar a equação não linear de um pêndulo simples e realizar sua linearização em torno da posição de equilíbrio vertical usando expansão de Taylor de primeira ordem, obtendo o modelo linearizado para pequenas oscilações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a equação de movimento não linear do pêndulo simples",
                                  "subSteps": [
                                    "Analise o pêndulo simples composto por uma massa puntiforme m suspensa por uma haste rígida de comprimento l sem massa.",
                                    "Aplique a segunda lei de Newton para rotação: torque igual a momento de inércia vezes aceleração angular.",
                                    "Calcule o torque gravitacional: -mg l sinθ, onde θ é o ângulo do equilíbrio vertical.",
                                    "O momento de inércia I = m l², resultando em m l² d²θ/dt² = -m g l sinθ.",
                                    "Simplifique para d²θ/dt² + (g/l) sinθ = 0."
                                  ],
                                  "verification": "Verifique se a equação obtida é d²θ/dt² + (g/l) sinθ = 0, com θ em radianos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência de dinâmica (ex: livro de Beer & Johnston)"
                                  ],
                                  "tips": "Use coordenadas de Lagrange para confirmação: L = (1/2) m l² (dθ/dt)² - m g l (1 - cosθ).",
                                  "learningObjective": "Compreender a origem física da não linearidade introduzida pelo termo sinθ.",
                                  "commonMistakes": [
                                    "Confundir torque com força linear",
                                    "Usar aproximação sinθ ≈ θ prematuramente",
                                    "Esquecer o sinal negativo do torque restaurador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o ponto de equilíbrio estável",
                                  "subSteps": [
                                    "Defina o ponto de equilíbrio como solução de equilíbrio da equação não linear: d²θ/dt² = 0 implica sinθ = 0.",
                                    "Identifique θ = 0 (posição vertical descendente) e θ = π (vertical ascendente).",
                                    "Analise a estabilidade: para θ=0, pequenas perturbações levam a oscilações; para θ=π, instável.",
                                    "Confirme que a linearização será em torno de θ_eq = 0.",
                                    "Introduza variáveis de desvio: φ = θ - θ_eq = θ."
                                  ],
                                  "verification": "Confirme que θ_eq = 0 é o equilíbrio estável por inspeção qualitativa ou linearização preliminar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico qualitativo de potencial V(θ) = -cosθ"
                                  ],
                                  "tips": "Plote o potencial efetivo V(θ) = -(g/l) cosθ para visualizar o mínimo em θ=0.",
                                  "learningObjective": "Reconhecer pontos de equilíbrio e sua estabilidade em sistemas não lineares.",
                                  "commonMistakes": [
                                    "Confundir estabilidade de θ=0 e θ=π",
                                    "Ignorar que linearização é só para equilíbrio estável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a expansão de Taylor de primeira ordem",
                                  "subSteps": [
                                    "Expanda sinθ em série de Taylor em torno de θ=0: sinθ = θ - θ³/6 + O(θ⁵).",
                                    "Para pequenas oscilações (|θ| << 1 rad), retenha apenas o termo de primeira ordem: sinθ ≈ θ.",
                                    "Substitua na equação não linear: d²θ/dt² + (g/l) θ ≈ 0.",
                                    "Discuta o erro de truncamento: erro ~ θ³/6, válido para |θ| < 10-15°.",
                                    "Generalize: f(θ) ≈ f(θ_eq) + f'(θ_eq)(θ - θ_eq), aqui f(θ) = sinθ, f(0)=0, f'(0)=cos0=1."
                                  ],
                                  "verification": "Verifique a derivada: d(sinθ)/dθ |_{θ=0} = 1, confirmando sinθ ≈ θ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de expansões de Taylor",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use SymPy para computar: series(sin(θ), θ, 0, 4) para visualizar termos.",
                                  "learningObjective": "Aplicar expansão de Taylor multivariable para linearização de funções não lineares.",
                                  "commonMistakes": [
                                    "Retenção de termos de ordem superior desnecessariamente",
                                    "Erro no cálculo da derivada em θ=0",
                                    "Aplicar Taylor em ponto errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter e interpretar o modelo linearizado",
                                  "subSteps": [
                                    "Escreva o modelo linear: d²θ/dt² + ω² θ = 0, onde ω² = g/l (oscilador harmônico simples).",
                                    "Solucione: θ(t) = A cos(ω t + φ), com período T = 2π √(l/g).",
                                    "Compare com não linear: para pequenas amplitudes, períodos coincidem; para grandes, período aumenta.",
                                    "Formule em espaço de estados: x1=θ, x2=dθ/dt, dx/dt = [0 1; -(g/l) 0] x.",
                                    "Valide numericamente ou graficamente."
                                  ],
                                  "verification": "Modelo final: ÿ + (g/l) y = 0, com solução oscilatória de frequência √(g/l).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "MATLAB/Simulink ou Python (matplotlib para plotar soluções)",
                                    "Valores típicos: l=1m, g=9.81 m/s²"
                                  ],
                                  "tips": "Simule em Python: resolva numericamente não linear vs linear para θ0=0.1 rad vs 1 rad.",
                                  "learningObjective": "Interpretar o modelo linear como base para análise de controle e simulações.",
                                  "commonMistakes": [
                                    "Confundir frequência natural com período",
                                    "Esquecer conversão para forma de estado",
                                    "Ignorar dependência de l e g"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um pêndulo de l=0.5m, g=9.8 m/s². Derive não linear, linearize e simule em Python (usando odeint) oscilações com θ0=5° (pequena, coincide com linear) vs θ0=45° (divergência visível). Plote θ(t) para ambas.",
                              "finalVerifications": [
                                "Equação não linear derivada corretamente como ÿ + (g/l) sinθ = 0.",
                                "Ponto de equilíbrio θ=0 identificado e estável.",
                                "Expansão de Taylor sinθ ≈ θ com justificativa de primeira ordem.",
                                "Modelo linear ÿ + (g/l) θ = 0 obtido e interpretado como SHO.",
                                "Solução analítica e comparação qualitativa com não linear.",
                                "Matriz de estado ou diagrama de blocos representado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e Taylor (sem erros algébricos).",
                                "Correta identificação de equilíbrio e justificativa de estabilidade.",
                                "Adequada truncagem da série e estimativa de validade (|θ|<0.2 rad).",
                                "Interpretação física do modelo linear (frequência, período independentes de amplitude).",
                                "Uso de ferramentas computacionais para validação numérica.",
                                "Clareza na apresentação de passos e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Taylor e aproximações assintóticas.",
                                "Física: Mecânica clássica, oscilações não lineares e caos.",
                                "Engenharia de Controle: Modelagem linear para PID e LQR em sistemas reais.",
                                "Programação: Simulação numérica com ODE solvers (Python/MATLAB).",
                                "Engenharia Mecânica/Aeronáutica: Estabilização de braços robóticos ou flaps."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, linearização de pêndulos modela estabilizadores de cauda ou sistemas de controle de atitude em drones e aviões, permitindo design de controladores lineares robustos para pequenas perturbações, como em flight control systems da NASA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Linearizar sistema massa-mola com amortecimento não linear",
                            "description": "Aplicar linearização em um sistema massa-mola onde o amortecimento ou a mola apresenta não linearidades, calculando as derivadas parciais no ponto de operação e formando a matriz jacobiana para o modelo linearizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o Sistema Massa-Mola com Amortecimento Não Linear",
                                  "subSteps": [
                                    "Derive a equação de movimento usando a segunda lei de Newton: m * ÿ = -k y - c(ẏ) ẏ, onde c(ẏ) é não linear (ex: c(ẏ) = c1 + c3 |ẏ|^2).",
                                    "Expresse o sistema em forma de espaço de estados: defina x1 = y, x2 = ẏ; então ẋ1 = x2, ẋ2 = - (k/m) x1 - (1/m) c(x2) x2 + u/m.",
                                    "Identifique as funções vetoriais f(x) = [x2; - (k/m) x1 - (1/m) c(x2) x2], g(x)u.",
                                    "Verifique dimensionalidade e unidades para consistência.",
                                    "Esboce o diagrama de fase qualitativo para entender o comportamento não linear."
                                  ],
                                  "verification": "Equações de estado não lineares escritas corretamente e validadas por simulação simples ou plotagem.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de simulação como MATLAB ou Python (SciPy)",
                                    "Referência: Livro de Dinâmica Não Linear (ex: Khalil)"
                                  ],
                                  "tips": "Sempre normalize forças por massa para obter acelerações; teste com valores numéricos simples.",
                                  "learningObjective": "Construir representação matemática precisa do sistema não linear em espaço de estados.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo nas forças restauradoras",
                                    "Confundir amortecimento dependente de velocidade com constante",
                                    "Não expressar explicitamente como f(x,u)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Calcular o Ponto de Operação",
                                  "subSteps": [
                                    "Escolha um ponto de equilíbrio estático (x_eq, u_eq) onde f(x_eq, u_eq) = 0 (ex: deslocamento y_eq com força u_eq = k y_eq).",
                                    "Para amortecimento não linear, confirme que no equilíbrio ẏ_eq = 0, logo termo de amortecimento some.",
                                    "Calcule valores numéricos: ex: m=1kg, k=10N/m, c(ẏ)=0.5 + 0.1 ẏ^2, y_eq=0.1m, u_eq=1N.",
                                    "Linearize coordenadas em torno do ponto: δx = x - x_eq, δu = u - u_eq.",
                                    "Documente o ponto de operação em tabela com valores exatos."
                                  ],
                                  "verification": "Ponto de operação satisfaz f(x_eq, u_eq)=0, comprovado por substituição numérica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou MATLAB para resolver equilíbrio",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Para equilíbrio não trivial, resolva algebricamente m*0 = -k y_eq + u_eq.",
                                  "learningObjective": "Selecionar adequadamente o ponto de linearização relevante para operação real.",
                                  "commonMistakes": [
                                    "Escolher ponto onde ẏ_eq ≠ 0, invalidando equilíbrio",
                                    "Ignorar entrada u_eq necessária para deslocamento estático",
                                    "Erros de arredondamento em valores numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a Matriz Jacobiana",
                                  "subSteps": [
                                    "Calcule derivadas parciais: A = ∂f/∂x |_(x_eq,u_eq), com elementos A11=∂f1/∂x1=0, A12=∂f1/∂x2=1, A21=∂f2/∂x1=-k/m, A22=∂f2/∂x2 = - (1/m) [c(x2) + x2 dc/dx2 ]|_{eq}.",
                                    "Para amortecimento não linear c(ẏ)=c1 + c3 ẏ^2, dc/dẏ = 2 c3 ẏ, logo no eq (ẏ=0), A22 = -c1/m.",
                                    "Calcule B = ∂f/∂u |_(eq) = [0; 1/m].",
                                    "Forme matrizes A (2x2) e B (2x1) explicitamente com valores numéricos.",
                                    "Verifique simetria ou propriedades esperadas (ex: autovalores com parte real negativa)."
                                  ],
                                  "verification": "Matriz A computada e elementos batem com fórmula analítica, testados numericamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/SymPy para derivadas simbólicas",
                                    "Papel para cálculo manual"
                                  ],
                                  "tips": "Use regra da cadeia para termos produto como c(x2)*x2: d/dx2 (c x2) = c + x2 dc/dx2.",
                                  "learningObjective": "Dominar cálculo de Jacobiana para sistemas não lineares com termos não lineares em velocidade.",
                                  "commonMistakes": [
                                    "Derivar incorretamente termos produto no amortecimento",
                                    "Avaliar derivadas no ponto errado (não eq)",
                                    "Confundir ordem das parciais ∂f_i/∂x_j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e Validar o Modelo Linearizado",
                                  "subSteps": [
                                    "Escreva equações lineares: δẋ = A δx + B δu.",
                                    "Simule resposta linear vs não linear em torno do eq para pequenas perturbações.",
                                    "Analise autovalores de A para estabilidade (ex: ζ e ω_n para sistema massa-mola).",
                                    "Compare com modelo linear clássico (sem não linearidade) para discutir aproximação.",
                                    "Documente limitações da linearização (válida para pequenas δx)."
                                  ],
                                  "verification": "Simulação mostra sobreposição >90% para perturbações <10% do eq; autovalores corretos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Gráficos de resposta temporal/frequência"
                                  ],
                                  "tips": "Use ode45 para simular não linear e lsim para linear; plote sobrepostas.",
                                  "learningObjective": "Aplicar e validar modelo linearizado em contexto dinâmico.",
                                  "commonMistakes": [
                                    "Não subtrair eq nas simulações",
                                    "Usar perturbações grandes invalidando linearidade",
                                    "Ignorar efeitos do não linear em altas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema: m=1kg, k=10N/m, amortecimento c(ẏ)=0.5 + 0.1 ẏ^2 (não linear). Ponto eq: x_eq=[0.1; 0]m/s, u_eq=1N. Jacobiana A=[0 1; -10 -0.5], B=[0;1]. Modelo linear: δÿ + 0.5 δẏ + 10 δy = δu.",
                              "finalVerifications": [
                                "Matriz Jacobiana calculada corretamente com todas derivadas parciais no ponto de operação.",
                                "Simulação linear e não linear coincidem para perturbações pequenas (erro <5%).",
                                "Autovalores de A indicam comportamento dinâmico esperado (amortecido).",
                                "Equações lineares em forma δẋ = A δx + B δu derivadas sem erros algébricos.",
                                "Limitações da aproximação discutidas (ex: válida para |δx| < 0.05m).",
                                "Código/simulação reproduzível compartilhadado."
                              ],
                              "assessmentCriteria": [
                                "Precisão no modelamento não linear (100% match com equações padrão).",
                                "Correção das derivadas parciais na Jacobiana (verificação simbólica).",
                                "Qualidade da validação por simulação (gráficos comparativos claros).",
                                "Interpretação física dos elementos de A/B (ex: A22 captura amortecimento linearizado).",
                                "Documentação completa com valores numéricos e analíticos.",
                                "Identificação de erros comuns evitados no processo."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso da linearização para design de controladores LQR ou PID em aeronaves.",
                                "Programação Computacional: Implementação em MATLAB/Simulink para simulação dinâmica.",
                                "Física Aplicada: Análise de vibrações não lineares em estruturas aeronáuticas.",
                                "Matemática Avançada: Cálculo vetorial e análise de estabilidade linear.",
                                "Engenharia Mecânica: Modelagem de suspensões e amortecedores em landing gear."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, lineariza-se modelos de flaps ou trem de pouso com fricção/amortecimento não linear (ex: Coulomb + viscoso) para design de sistemas de controle de estabilidade em voo, permitindo análise em malha de Bode ou root locus para certificação FAA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Analisar estabilidade do modelo linearizado mecânico",
                            "description": "Verificar a estabilidade do sistema mecânico linearizado através da análise dos autovalores da matriz jacobiana e comparar com o comportamento não linear original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e revisar a matriz Jacobiana do modelo linearizado",
                                  "subSteps": [
                                    "Identifique o ponto de equilíbrio do sistema mecânico não linear.",
                                    "Escreva as equações de movimento não lineares do sistema.",
                                    "Compute a matriz Jacobiana A avaliada no ponto de equilíbrio.",
                                    "Verifique se a linearização está correta derivando parcialmente as equações em relação às variáveis de estado e entrada.",
                                    "Documente a matriz A final com dimensões n x n para um sistema de ordem n."
                                  ],
                                  "verification": "Confirme que todos os elementos da matriz A foram calculados corretamente comparando com derivações manuais ou simbólicas em software.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Equações do modelo não linear",
                                    "Software simbólico como SymPy ou MATLAB Symbolic Toolbox",
                                    "Papel e calculadora"
                                  ],
                                  "tips": [
                                    "Use notação vetorial para estados; sempre normalize unidades para consistência."
                                  ],
                                  "learningObjective": "Compreender como a linearização em torno do equilíbrio produz a matriz de dinâmica linear A.",
                                  "commonMistakes": [
                                    "Esquecer de avaliar no ponto de equilíbrio exato",
                                    "Confundir variáveis de estado com saídas",
                                    "Erros em derivadas parciais de termos não lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os autovalores da matriz Jacobiana",
                                  "subSteps": [
                                    "Implemente a matriz A em um software numérico ou compute analiticamente para sistemas de baixa ordem.",
                                    "Use funções de autovalores (eig em MATLAB ou numpy.linalg.eig em Python).",
                                    "Extraia as partes real e imaginária de cada autovalor λ_i.",
                                    "Ordene os autovalores por parte real crescente para análise.",
                                    "Valide o cálculo com métodos alternativos, como decomposição QR para matrizes grandes."
                                  ],
                                  "verification": "Compare autovalores computados com soluções analíticas conhecidas para um caso teste simples (ex: oscilador harmônico).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Matriz A do passo anterior"
                                  ],
                                  "tips": [
                                    "Para matrizes reais, autovalores vêm em pares conjugados; foque na parte real para estabilidade."
                                  ],
                                  "learningObjective": "Dominar o cálculo numérico e analítico de autovalores para sistemas lineares.",
                                  "commonMistakes": [
                                    "Usar autovalores errados devido a escala numérica; sempre cheque cond number da matriz",
                                    "Ignorar autovalores complexos",
                                    "Confundir autovalores com autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a estabilidade baseada nos autovalores",
                                  "subSteps": [
                                    "Verifique se todos os autovalores têm parte real negativa (Re(λ_i) < 0) para estabilidade assintótica.",
                                    "Classifique: estável (todos Re<0), instável (qualquer Re>0), marginal (Re=0).",
                                    "Determine o autovalor dominante (maior Re(λ_i)) e seu tempo de assentamento aproximado 4/|Re|.",
                                    "Analise modos oscilatórios se houver pares imaginários.",
                                    "Desenhe o lugar das raízes no plano complexo para visualização."
                                  ],
                                  "verification": "Crie um gráfico do lugar das raízes e confirme critérios de estabilidade qualitativamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot ou Matplotlib)",
                                    "Lista de autovalores"
                                  ],
                                  "tips": [
                                    "Lembre: para sistemas contínuos, sinal negativo na parte real indica estabilidade."
                                  ],
                                  "learningObjective": "Interpretar autovalores para prever comportamento dinâmico e estabilidade.",
                                  "commonMistakes": [
                                    "Confundir estabilidade discreta vs contínua",
                                    "Ignorar multiplicidade algébrica de autovalores",
                                    "Esquecer de considerar entradas externas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com o comportamento do modelo não linear original",
                                  "subSteps": [
                                    "Simule o sistema não linear numericamente (ex: ode45 em MATLAB ou solve_ivp em Python).",
                                    "Simule o modelo linearizado com mesmas condições iniciais próximas ao equilíbrio.",
                                    "Compare trajetórias de estado, erros e tempos de convergência.",
                                    "Quantifique a discrepância usando métricas como RMSE entre simulações.",
                                    "Conclua sobre a validade da aproximação linear no regime de interesse."
                                  ],
                                  "verification": "Gere gráficos sobrepostos de simulações linear e não linear mostrando concordância.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Simulink ou Python SciPy.integrate",
                                    "Equações originais não lineares"
                                  ],
                                  "tips": [
                                    "Use condições iniciais pequenas para validar linearização; amplie para testar limites."
                                  ],
                                  "learningObjective": "Avaliar a precisão da linearização comparando simulações.",
                                  "commonMistakes": [
                                    "Condições iniciais grandes invalidam linearização",
                                    "Escalas de tempo inconsistentes nas simulações",
                                    "Ignorar efeitos de não linearidades fracas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo invertido modelado por θ'' = (g/l) sin(θ) - (b/m) θ', linearize em θ=π (equilíbrio instável). Compute A = [[0,1], [g/l, -b/m]], autovalores mostram Re>0 confirmando instabilidade. Simule não linear vs linear: trajetórias divergem rapidamente, validando análise.",
                              "finalVerifications": [
                                "Matriz Jacobiana correta derivada e avaliada.",
                                "Autovalores calculados com precisão numérica <1e-6.",
                                "Critérios de estabilidade aplicados corretamente.",
                                "Simulações comparativas mostram concordância qualitativa.",
                                "Conclusão escrita sobre estabilidade e validade da linearização.",
                                "Gráficos de lugar das raízes e trajetórias gerados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de Jacobiana e autovalores (90%+ correto).",
                                "Interpretação correta de estabilidade (sem erros lógicos).",
                                "Qualidade das simulações e comparações (gráficos claros, métricas quantitativas).",
                                "Documentação completa com explicações passo a passo.",
                                "Identificação de limitações da aproximação linear.",
                                "Aplicação correta de conceitos teóricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, decomposição espectral).",
                                "Física: Dinâmica clássica e equações de Lagrange/Euler-Lagrange.",
                                "Controle Automático: Projeto de controladores baseados em modelos lineares.",
                                "Computação: Programação numérica e simulação diferencial.",
                                "Engenharia de Materiais: Modelos com não linearidades de fricção ou folgas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, analisar estabilidade de modelos linearizados de asas flexíveis ou drones para prever flutter ou perda de controle, permitindo design seguro de controladores estabilizantes antes de testes em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Linearização em Sistemas Eletromecânicos",
                        "description": "Exemplos de linearização em dispositivos eletromecânicos, como motores elétricos, focando na interação entre circuitos elétricos e componentes mecânicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Linearizar o modelo de um motor DC",
                            "description": "Obter o modelo não linear de um motor de corrente contínua considerando saturação ou não linearidades no torque e realizar linearização em torno de um ponto de operação específico, resultando em equações lineares para velocidade e corrente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular o modelo não linear do motor DC",
                                  "subSteps": [
                                    "Relembrar as equações fundamentais: elétrica (V = R i + L di/dt + K_e(ω) ω) e mecânica (J dω/dt = K_t(i) i - b ω - T_l).",
                                    "Incorporar não linearidades específicas, como saturação em K_t(i) = K_t_max * (1 - e^{-|i|/I_sat}) ou K_e(ω) similar.",
                                    "Definir variáveis de estado: i (corrente) e ω (velocidade angular).",
                                    "Escrever o modelo em forma de equações diferenciais não lineares: dx/dt = f(x,u), onde x = [i, ω]^T, u = [V, T_l]^T.",
                                    "Documentar todas as não linearidades assumidas (ex: saturação de torque)."
                                  ],
                                  "verification": "Modelo não linear escrito corretamente com todas as não linearidades identificadas e equações balanceadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel ou editor LaTeX/MATLAB",
                                    "Referências: livros de controle como Ogata ou Franklin"
                                  ],
                                  "tips": "Comece com o modelo linear básico e adicione uma não linearidade por vez para clareza.",
                                  "learningObjective": "Compreender e expressar matematicamente o comportamento não linear de um motor DC.",
                                  "commonMistakes": [
                                    "Esquecer termos de acoplamento eletromecânico (back-EMF)",
                                    "Ignorar dependência de parâmetros em variáveis de estado",
                                    "Confundir torque com potência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e calcular o ponto de operação",
                                  "subSteps": [
                                    "Escolher valores realistas para o ponto de equilíbrio: V0, i0, ω0, T_l0 (ex: regime permanente sem aceleração).",
                                    "Resolver para equilíbrio: di/dt=0, dω/dt=0, obtendo i0 = (V0 - K_e(ω0) ω0)/R, T_l0 = K_t(i0) i0 - b ω0.",
                                    "Iterar numericamente se necessário para consistência com não linearidades.",
                                    "Calcular os valores numéricos dos parâmetros no ponto (ex: K_t(i0), K_e(ω0)).",
                                    "Registrar o ponto: x0 = [i0, ω0]^T, u0 = [V0, T_l0]^T."
                                  ],
                                  "verification": "Ponto de operação satisfaz equações de equilíbrio (substituir em f(x0,u0)=0).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Simulink para iterações",
                                    "Dados típicos de motor DC (R=1Ω, L=0.1H, etc.)"
                                  ],
                                  "tips": "Use valores realistas de catálogos de motores para credibilidade.",
                                  "learningObjective": "Determinar condições de equilíbrio estável para linearização.",
                                  "commonMistakes": [
                                    "Não verificar se dω/dt=0 e di/dt=0",
                                    "Escolher ponto fora do range operacional realista",
                                    "Ignorar iterações para não linearidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a linearização via expansão de Taylor",
                                  "subSteps": [
                                    "Definir variáveis desviadas: δx = x - x0, δu = u - u0.",
                                    "Computar Jacobianas: A = ∂f/∂x |_{x0,u0}, B = ∂f/∂u |_{x0,u0}.",
                                    "Derivar elementos da matriz A: A11 = ∂(di/dt)/∂i, A12 = ∂(di/dt)/∂ω, etc., considerando derivadas das não linearidades.",
                                    "Derivar B similarmente.",
                                    "Aproximar: d(δx)/dt ≈ A δx + B δu."
                                  ],
                                  "verification": "Matrizes A e B calculadas corretamente, com derivadas parciais precisas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou MATLAB Symbolic Toolbox",
                                    "Papel para derivações manuais"
                                  ],
                                  "tips": "Use regras da cadeia para derivadas de produtos como K_t(i) i.",
                                  "learningObjective": "Aplicar linearização small-signal usando Jacobianas.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais de não linearidades",
                                    "Confundir ordem das variáveis de estado",
                                    "Esquecer sinal negativo no back-EMF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar o modelo linear",
                                  "subSteps": [
                                    "Escrever equações lineares em δi e δω explicitamente.",
                                    "Converter para espaço de estado: δẋ = A δx + B δu, y = C δx + D δu (definir saídas como ω, i).",
                                    "Simular resposta linear vs. não linear em torno de x0 para pequena perturbação.",
                                    "Comparar polos ou ganho DC para validação.",
                                    "Documentar modelo final em forma de função de transferência se aplicável."
                                  ],
                                  "verification": "Simulação mostra boa aproximação para sinais pequenos (<10% de x0).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Dados do ponto de operação"
                                  ],
                                  "tips": "Perturbe com degrau pequeno em V e compare trajetórias.",
                                  "learningObjective": "Obter e validar modelo linear para análise de controle.",
                                  "commonMistakes": [
                                    "Não definir matrizes C/D corretamente",
                                    "Simular perturbações grandes onde linearização falha",
                                    "Ignorar validação numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com R=1Ω, L=0.5H, J=0.01kgm², b=0.1Nms, K_t_max=0.05Nm/A (saturado: K_t(i)=0.05*(1-e^{-|i|/5})), ponto: V0=12V, i0=4A, ω0=200rad/s. Linearização resulta em A = [[-2, -0.48], [0.2, -10]], B=[[2,0], [0,-100]]. Simule δv=1V degrau.",
                              "finalVerifications": [
                                "Modelo não linear inclui todas não linearidades especificadas.",
                                "Ponto de operação equilibra exatamente as equações.",
                                "Matrizes A e B derivadas corretamente com todas derivadas parciais.",
                                "Equações lineares em δx reproduzem small-signal behavior em simulação.",
                                "Documentação completa com valores numéricos e plots de validação.",
                                "Função de transferência opcional derivada e polos calculados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das derivações (100% correto: excelente).",
                                "Escolha adequada do ponto de operação (realista e estável: bom).",
                                "Validação via simulação (erro <5% em 10s: ótimo).",
                                "Clareza na documentação e explicação de passos.",
                                "Identificação correta de impactos das não linearidades.",
                                "Eficiência: tempo dentro do estimado com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso em design de controladores PID para atuadores.",
                                "Eletrônica: Modelagem de drivers de motor H-bridge.",
                                "Mecânica Aeronáutica: Atuadores em flaps ou hélices de drones.",
                                "Programação: Implementação em Simulink para sistemas embarcados.",
                                "Matemática: Aplicação de álgebra linear e análise de estabilidade."
                              ],
                              "realWorldApplication": "Em aeronaves UAVs, linearização de motores DC permite design de loops de controle para estabilização de atitude, compensando não linearidades em manobras, reduzindo overshoot em 30% e melhorando precisão de velocidade em voo autônomo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Linearizar sistema servomotor com feedback",
                            "description": "Aplicar linearização em um servomotor com não linearidades em atrito coulombiano ou backlash, derivando o diagrama de blocos linearizado para análise de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema servomotor não linear",
                                  "subSteps": [
                                    "Identifique os componentes principais do servomotor: motor DC, engrenagens, carga inercial e mecanismo de feedback.",
                                    "Escreva as equações dinâmicas não lineares, incluindo torque do motor, atrito coulombiano (T_c * sign(ω)) e backlash (modelado como folga angular).",
                                    "Inclua o loop de feedback com sensor de posição (ex: encoder) e controlador proporcional.",
                                    "Defina variáveis de estado: posição θ, velocidade ω, corrente i.",
                                    "Valide o modelo com dados típicos de servomotores aeronáuticos."
                                  ],
                                  "verification": "Modelo matemático escrito e diagramado em software como MATLAB/Simulink.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Referências: Franklin 'Feedback Control of Dynamic Systems'",
                                    "Dados de datasheet de servomotor"
                                  ],
                                  "tips": "Comece com o modelo mais simples e adicione não linearidades gradualmente.",
                                  "learningObjective": "Compreender e formular o modelo dinâmico não linear completo de um servomotor com feedback.",
                                  "commonMistakes": [
                                    "Ignorar o atraso do backlash no modelo",
                                    "Confundir atrito viscoso com coulombiano",
                                    "Esquecer a constante de tempo elétrica do motor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar ponto de operação e computar linearização",
                                  "subSteps": [
                                    "Escolha um ponto de equilíbrio estático (ex: ω=0, θ=θ_0, i=i_0) relevante para operação aeronáutica.",
                                    "Calcule as derivadas parciais das funções não lineares em torno do ponto de operação (Jacobiano).",
                                    "Linearize equações de estado: dx/dt = A(x_0)(x - x_0) + B(u - u_0).",
                                    "Trate backlash: approxime como ganho reduzido ou modelo piecewise linearizado.",
                                    "Verifique estabilidade do ponto linearizado via autovalores de A."
                                  ],
                                  "verification": "Matrizes A, B, C linearizadas calculadas e validadas numericamente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Calculadora simbólica (MATLAB Symbolic Toolbox)",
                                    "Folha de papel para derivadas manuais",
                                    "Exemplos de linearização de Ogata 'Modern Control Engineering'"
                                  ],
                                  "tips": "Use expansões de Taylor de primeira ordem; ignore termos quadráticos para precisão inicial.",
                                  "learningObjective": "Dominar a técnica de linearização via Jacobiano para sistemas não lineares.",
                                  "commonMistakes": [
                                    "Escolher ponto de operação instável",
                                    "Erro em derivadas parciais do sign(ω)",
                                    "Não normalizar variáveis de desvio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o diagrama de blocos linearizado",
                                  "subSteps": [
                                    "Converta o modelo de espaço de estados linearizado em funções de transferência G(s) = C(sI - A)^(-1)B.",
                                    "Desenhe o diagrama de blocos: planta linearizada, controlador, feedback unitário.",
                                    "Incorpore efeitos linearizados: ganho de atrito como perturbação, backlash como não mínimo de fase.",
                                    "Simplifique o diagrama usando regras de Mason para ganho em malha fechada.",
                                    "Implemente no Simulink para visualização."
                                  ],
                                  "verification": "Diagrama de blocos completo com funções de transferência corretas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulink Block Diagram",
                                    "MATLAB Control System Toolbox",
                                    "Papel milimetrado para esboço manual"
                                  ],
                                  "tips": "Use tf() no MATLAB para converter espaço de estados em TF rapidamente.",
                                  "learningObjective": "Transformar modelos linearizados em representações de diagrama de blocos para análise de controle.",
                                  "commonMistakes": [
                                    "Inverter sinal no feedback",
                                    "Esquecer polo zero devido a backlash",
                                    "Não considerar delay do encoder"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar o modelo linearizado",
                                  "subSteps": [
                                    "Simule resposta ao degrau no modelo não linear vs. linearizado.",
                                    "Compare polos e zeros, margens de estabilidade (Bode/Nyquist).",
                                    "Ajuste parâmetros para matching em faixa operacional (ex: baixa velocidade para atrito).",
                                    "Avalie sensibilidade a variações no ponto de operação.",
                                    "Documente limitações da linearização."
                                  ],
                                  "verification": "Gráficos de simulação mostrando boa aproximação (<10% erro em regime transitório).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Stepinfo() e margin() no MATLAB",
                                    "Dados experimentais simulados"
                                  ],
                                  "tips": "Teste múltiplos pontos de operação para robustez.",
                                  "learningObjective": "Avaliar validade da linearização e preparar para design de controladores.",
                                  "commonMistakes": [
                                    "Simular fora da faixa de validade linear",
                                    "Ignorar saturação em atuadores",
                                    "Confundir erro de modelagem com erro numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone aeronáutico, linearize o servomotor de controle de alettons com backlash nas engrenagens: modelo não linear mostra oscilações; linearizado permite PID com overshoot <15%.",
                              "finalVerifications": [
                                "Modelo não linear corretamente formulado com atrito e backlash.",
                                "Matrizes Jacobianas computadas e funções de transferência derivadas.",
                                "Diagrama de blocos em Simulink simulável e matching com não linear.",
                                "Análise de estabilidade confirma polos no semiplano esquerdo.",
                                "Relatório com gráficos de validação.",
                                "Discussão de aplicações em sistemas de voo autônomo."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações não lineares (20%)",
                                "Correção da linearização Jacobiana (25%)",
                                "Qualidade do diagrama de blocos e TF (20%)",
                                "Validação via simulação (20%)",
                                "Análise de limitações e estabilidade (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear (Jacobianos).",
                                "Física: Dinâmica eletromecânica e leis de Newton.",
                                "Informática: Programação em MATLAB/Simulink para modelagem.",
                                "Engenharia Mecânica: Modelagem de atrito e engrenagens."
                              ],
                              "realWorldApplication": "Projeto de atuadores em aviões comerciais (ex: flaps controlados por servomotores), onde linearização permite sintetizar controladores robustos contra não linearidades, garantindo precisão em manobras de voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Linearização em Sistemas Térmicos e Hidráulicos",
                        "description": "Aplicações da linearização em modelos dinâmicos térmicos e hidráulicos, como tanques e sistemas de resfriamento, para facilitar a análise e o controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Linearizar modelo de tanque hidráulico",
                            "description": "Derivar a equação não linear de nível de um tanque com entrada variável e linearizá-la em torno de um nível de operação constante, obtendo ganho estático e constante de tempo do modelo linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivação do modelo não linear do tanque hidráulico",
                                  "subSteps": [
                                    "Identifique as variáveis principais: nível do líquido h(t), vazão de entrada q_in(t), vazão de saída q_out(t), área da seção transversal A.",
                                    "Escreva a equação de balanço de massa: A * dh/dt = q_in(t) - q_out(t).",
                                    "Modele a vazão de saída como função não linear do nível: q_out(h) = C * sqrt(2*g*h), onde C é o coeficiente de vazão e g é a gravidade.",
                                    "Substitua na equação de balanço para obter dh/dt = (q_in(t) - C * sqrt(2*g*h)) / A.",
                                    "Verifique as unidades e assuma condições iniciais."
                                  ],
                                  "verification": "Confirme que a equação dh/dt = (q_in - C*sqrt(2*g*h))/A está correta e balanceada dimensionalmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou software como MATLAB/Simulink",
                                    "Referência: livro de dinâmica de sistemas ou notas de aula sobre balanço de massa"
                                  ],
                                  "tips": "Desenhe um diagrama esquemático do tanque para visualizar as variáveis.",
                                  "learningObjective": "Compreender e derivar o modelo dinâmico não linear baseado em princípios físicos fundamentais.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na vazão de saída",
                                    "Não considerar a dependência não linear sqrt(h)",
                                    "Ignorar a área A na equação diferencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição do ponto de operação constante",
                                  "subSteps": [
                                    "Escolha um nível de operação constante h_s (steady-state).",
                                    "Determine a vazão de entrada constante q_in_s no estado estacionário.",
                                    "Calcule a vazão de saída no steady-state: q_out_s = C * sqrt(2*g*h_s).",
                                    "Imponha a condição de equilíbrio: q_in_s = q_out_s.",
                                    "Defina variáveis de desvio: h'(t) = h(t) - h_s, q_in'(t) = q_in(t) - q_in_s."
                                  ],
                                  "verification": "Verifique se no ponto h_s, dh/dt = 0 com q_in_s = q_out_s.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de valores típicos para tanques hidráulicos (ex: A=1m², C=0.6, g=9.81 m/s²)"
                                  ],
                                  "tips": "Escolha valores numéricos realistas para h_s, como 2 metros, para facilitar cálculos posteriores.",
                                  "learningObjective": "Selecionar e justificar um ponto de linearização apropriado para análise local.",
                                  "commonMistakes": [
                                    "Confundir variáveis de estado com variáveis de desvio",
                                    "Não garantir q_in_s = q_out_s no steady-state",
                                    "Escolher h_s=0, que torna a linearização singular"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realização da linearização via expansão de Taylor",
                                  "subSteps": [
                                    "Expanda q_out(h) em série de Taylor ao redor de h_s: q_out(h) ≈ q_out(h_s) + (dq_out/dh|_{h_s}) * (h - h_s).",
                                    "Calcule a derivada: dq_out/dh|_{h_s} = C * sqrt(2*g / (4 h_s)) = (q_out_s)/(2 h_s).",
                                    "Substitua na equação de balanço: A * dh'/dt = q_in' - (q_out_s)/(2 h_s) * h'.",
                                    "Ignore termos de ordem superior para obter o modelo linear aproximado.",
                                    "Escreva na forma padrão dh'/dt = - (1/τ) h' + (K/τ) q_in', onde τ e K serão identificados."
                                  ],
                                  "verification": "Confirme que a aproximação linear é válida para pequenas perturbações |h'| << h_s.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou MATLAB Symbolic Toolbox",
                                    "Folha de derivadas de Taylor"
                                  ],
                                  "tips": "Use notação δh = h - h_s para clareza nas expansões.",
                                  "learningObjective": "Aplicar expansão de Taylor de primeira ordem para linearizar equações diferenciais não lineares.",
                                  "commonMistakes": [
                                    "Erros no cálculo da derivada de sqrt(h)",
                                    "Incluir termos quadráticos na linearização",
                                    "Esquecer de dividir por A na constante de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificação do ganho estático e constante de tempo",
                                  "subSteps": [
                                    "Identifique a constante de tempo τ = (2 A h_s)/q_out_s a partir do coeficiente de h'.",
                                    "Determine o ganho estático K = 2 h_s / q_out_s do coeficiente de q_in'.",
                                    "Escreva o modelo linear completo: τ dh'/dt + h' = K q_in'.",
                                    "Interprete fisicamente: τ é o tempo para 63% da resposta, K é variação de h por variação unitária de q_in.",
                                    "Teste com valores numéricos: compute τ e K para h_s=2m, A=1m², etc."
                                  ],
                                  "verification": "Simule uma resposta em degrau no modelo linear e confirme comportamento de 1ª ordem com τ e K corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python com scipy para simulação",
                                    "Gráfico de resposta em degrau"
                                  ],
                                  "tips": "Ganho K = dh_ss / dq_in_ss no steady-state linearizado.",
                                  "learningObjective": "Extrair e interpretar parâmetros chave (ganho estático K e constante de tempo τ) do modelo linearizado.",
                                  "commonMistakes": [
                                    "Inverter K e 1/τ",
                                    "Não simplificar τ = 2 A h_s / q_out_s",
                                    "Confundir ganho DC com ganho dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e interpretação do modelo linearizado",
                                  "subSteps": [
                                    "Compare respostas do modelo não linear e linear para pequenas entradas.",
                                    "Analise o erro de linearização para perturbações maiores.",
                                    "Discuta limitações: válida apenas perto de h_s, h>0.",
                                    "Crie diagrama de blocos do modelo linear: integrador com ganhos.",
                                    "Documente valores finais de K e τ."
                                  ],
                                  "verification": "Plote simulações lado a lado; erro <5% para |h'|<10% de h_s.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulink ou Python (matplotlib, control library)",
                                    "Dados numéricos do exemplo"
                                  ],
                                  "tips": "Use Simulink para modelar ambos e comparar saídas.",
                                  "learningObjective": "Validar a precisão da linearização e compreender seu escopo de validade.",
                                  "commonMistakes": [
                                    "Não validar numericamente",
                                    "Ignorar condições h>=0",
                                    "Assumir linearidade global"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aeronave, linearize o modelo de um tanque de combustível hidráulico com A=0.5m², h_s=1.5m, q_out_s=0.3m³/s. Obtenha τ≈5 minutos e K=10m/(m³/s), útil para projetar controladores de nível durante voo.",
                              "finalVerifications": [
                                "Equação não linear dh/dt = (q_in - C*sqrt(2gh))/A derivada corretamente.",
                                "Ponto de operação h_s satisfaz q_in_s = q_out_s.",
                                "Derivada dq_out/dh|_{h_s} = q_out_s / (2 h_s) calculada com precisão.",
                                "Modelo linear dh'/dt = -h'/τ + (K/τ) q_in' com τ=2 A h_s / q_out_s e K=2 h_s / q_out_s.",
                                "Simulação valida erro pequeno para perturbações locais.",
                                "Interpretação física de K (ganho estático) e τ (constante de tempo) fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e linearização (sem erros algébricos).",
                                "Correta identificação de τ e K com fórmulas explícitas em termos de parâmetros físicos.",
                                "Validação numérica/simulada com gráficos comparativos.",
                                "Explicação clara das limitações da aproximação linear.",
                                "Uso apropriado de notação de desvio e steady-state.",
                                "Aplicação contextual a sistemas aeronáuticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansão em série de Taylor e equações diferenciais.",
                                "Física: Balanço de massa e conservação de energia/momento em fluidos.",
                                "Controle Automático: Modelagem para síntese de controladores PID.",
                                "Programação: Simulação em MATLAB/Python para análise dinâmica.",
                                "Engenharia Mecânica: Aplicações em sistemas hidráulicos e térmicos semelhantes."
                              ],
                              "realWorldApplication": "Controle de nível em tanques de combustível de aeronaves, sistemas de refrigeração hidráulica em motores a jato, ou reservatórios industriais, onde modelos lineares facilitam o design de controladores estáveis e robustos para operação segura."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Linearizar sistema de resfriamento térmico",
                            "description": "Realizar linearização da equação de balanço térmico não linear (considerando perdas por radiação) em torno de uma temperatura de equilíbrio, formando o modelo de primeira ordem linearizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema de resfriamento térmico não linear",
                                  "subSteps": [
                                    "Identifique as variáveis principais: temperatura do objeto T(t), temperatura ambiente T_amb, fluxo de calor de entrada Q_in, massa m, capacidade calorífica específica c.",
                                    "Escreva a equação de balanço térmico: m c dT/dt = Q_in - h A (T - T_amb) - ε σ A (T^4 - T_amb^4), destacando o termo não linear de radiação.",
                                    "Defina os parâmetros típicos para um sistema aeronáutico, como dissipador de calor em eletrônicos de bordo.",
                                    "Desenhe um diagrama esquemático do sistema, incluindo fontes de calor e perdas.",
                                    "Verifique dimensionalmente a equação para consistência."
                                  ],
                                  "verification": "A equação não linear está corretamente escrita e balanceada termicamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel ou software de edição (LaTeX/MATLAB), tabela de constantes físicas (ε, σ)"
                                  ],
                                  "tips": "Comece com unidades SI para evitar erros; use símbolos consistentes.",
                                  "learningObjective": "Compreender a origem da não linearidade em sistemas térmicos devido à radiação.",
                                  "commonMistakes": [
                                    "Esquecer o fator de emissão ε ou constante de Stefan-Boltzmann σ",
                                    "Confundir convecção com radiação",
                                    "Ignorar dependência temporal em T_amb"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o ponto de equilíbrio (steady-state)",
                                  "subSteps": [
                                    "Defina condições de equilíbrio: dT/dt = 0, T = T_eq, Q_in = Q_eq.",
                                    "Resolva para T_eq: Q_eq = h A (T_eq - T_amb) + ε σ A (T_eq^4 - T_amb^4).",
                                    "Escolha valores numéricos realistas para um sistema de aeronave (ex: T_amb=300K, Q_eq=100W, parâmetros h, A, etc.).",
                                    "Calcule numericamente T_eq usando métodos iterativos se necessário (ex: fsolve no MATLAB).",
                                    "Documente os valores de todas as variáveis no equilíbrio."
                                  ],
                                  "verification": "T_eq satisfaz a equação de steady-state com erro < 0.1%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Python para resolução numérica"
                                  ],
                                  "tips": "Use temperaturas em Kelvin sempre para radiação.",
                                  "learningObjective": "Identificar e calcular estados de equilíbrio em sistemas não lineares.",
                                  "commonMistakes": [
                                    "Usar Celsius em vez de Kelvin",
                                    "Não iterar corretamente para T_eq",
                                    "Esquecer perdas por convecção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a linearização via expansão de Taylor",
                                  "subSteps": [
                                    "Defina variáveis de desvio: δT = T - T_eq, δQ = Q_in - Q_eq.",
                                    "Aplique expansão de Taylor de primeira ordem em torno de T_eq para o termo não linear f(T) = h A (T - T_amb) + ε σ A (T^4 - T_amb^4).",
                                    "Calcule a derivada df/dT em T_eq: ∂f/∂T|_eq = h A + 4 ε σ A T_eq^3.",
                                    "Forme a aproximação linear: f(T) ≈ f(T_eq) + (∂f/∂T|_eq) δT.",
                                    "Substitua na equação diferencial para obter m c d(δT)/dt ≈ δQ - (∂f/∂T|_eq) δT."
                                  ],
                                  "verification": "A derivada parcial está corretamente computada e a aproximação linear derivada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de derivadas, software simbólico (SymPy ou MATLAB Symbolic)"
                                  ],
                                  "tips": "Lembre-se: apenas primeira ordem, ignore termos quadráticos ou superiores.",
                                  "learningObjective": "Aplicar expansão de Taylor para linearizar funções não lineares em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Erro no expoente da derivada de T^4 (deve ser 4 T^3)",
                                    "Não linearizar corretamente as variáveis de desvio",
                                    "Confundir δQ com Q_eq"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e interpretar o modelo linearizado de primeira ordem",
                                  "subSteps": [
                                    "Reescreva como equação de primeira ordem: d(δT)/dt = - (1/τ) δT + (1/(m c)) δQ, onde τ = m c / (∂f/∂T|_eq).",
                                    "Calcule numericamente a constante de tempo τ com os valores do exemplo.",
                                    "Converta para função de transferência: G(s) = δT(s)/δQ(s) = K / (τ s + 1), com K = 1/(m c / τ).",
                                    "Simule resposta a degrau em δQ usando MATLAB/Simulink para validar.",
                                    "Compare resposta linear vs. não linear em torno de T_eq."
                                  ],
                                  "verification": "Modelo linear reproduz comportamento não linear com erro <5% em ±10% de T_eq.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (control library), Simulink opcional"
                                  ],
                                  "tips": "Plote respostas para visualização intuitiva da validade da linearização.",
                                  "learningObjective": "Construir e analisar modelos lineares aproximados para controle.",
                                  "commonMistakes": [
                                    "Inverter sinal no polo do sistema",
                                    "Esquecer fator de ganho K",
                                    "Simular fora da região de validade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de resfriamento de eletrônicos de uma aeronave, onde Q_in varia com carga computacional (50-150W), T_amb=298K, m=0.5kg, c=900J/kgK, h=10W/m²K, A=0.1m², ε=0.8, σ=5.67e-8. Linearize em T_eq≈320K para projetar um controlador PID simples.",
                              "finalVerifications": [
                                "Equação não linear corretamente escrita com termo de radiação.",
                                "T_eq calculado e verificado numericamente.",
                                "Derivada linearizadora ∂f/∂T|_eq exata (incluindo 4εσA T_eq^3).",
                                "Modelo de 1ª ordem com τ e K corretos.",
                                "Simulação confirma validade da linearização.",
                                "Função de transferência em forma padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivada de linearização (100% correto).",
                                "Cálculo numérico de T_eq e τ sem erros >1%.",
                                "Interpretação física correta da constante de tempo τ.",
                                "Validação via simulação com gráficos comparativos.",
                                "Clareza na documentação de passos e suposições.",
                                "Identificação de limitações da aproximação linear."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansão de Taylor e cálculo diferencial.",
                                "Física/Termodinâmica: Leis de conservação de energia e mecanismos de perda térmica.",
                                "Engenharia de Controle: Modelos para síntese de controladores.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Engenharia Mecânica: Dimensionamento de trocadores de calor."
                              ],
                              "realWorldApplication": "Linearização essencial para controle de temperatura em aviônicos de aeronaves, permitindo uso de técnicas lineares como PID ou LQR em sistemas não lineares, garantindo operação segura em voo sob variações de altitude e carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Comparar precisão da linearização em sistemas térmicos/hidráulicos",
                            "description": "Simular e comparar respostas do modelo não linear original versus linearizado para diferentes desvios do ponto de operação, avaliando o intervalo de validade da aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Modelar o Sistema Não Linear",
                                  "subSteps": [
                                    "Escolha um sistema térmico (ex: balanço de calor) ou hidráulico (ex: fluxo em tubulações) relevante para aeronáutica.",
                                    "Derive as equações diferenciais não lineares completas baseadas em leis físicas (conservação de massa, energia, momentum).",
                                    "Implemente o modelo não linear em software de simulação como MATLAB ou Python (SciPy).",
                                    "Valide o modelo com condições iniciais conhecidas ou dados de referência.",
                                    "Defina o ponto de operação (estado estacionário) para linearização futura."
                                  ],
                                  "verification": "Modelo não linear simulado com saída estável no ponto de operação e sem erros numéricos evidentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python com NumPy/SciPy",
                                    "Livro-texto de dinâmica de sistemas térmicos/hidráulicos",
                                    "Papel e caneta para derivação manual"
                                  ],
                                  "tips": [
                                    "Comece com um sistema de baixa ordem (1-2 variáveis de estado) para simplicidade.",
                                    "Use unidades consistentes (SI) para evitar erros."
                                  ],
                                  "learningObjective": "Modelar precisamente sistemas físicos não lineares com equações diferenciais.",
                                  "commonMistakes": [
                                    "Omitir termos não lineares como produtos de variáveis.",
                                    "Escolher ponto de operação instável.",
                                    "Ignorar restrições físicas como capacitâncias finitas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Linearização no Ponto de Operação",
                                  "subSteps": [
                                    "Calcule as matrizes Jacobianas (A, B, C, D) no ponto de operação usando derivadas parciais.",
                                    "Implemente o modelo linearizado como sistema de estado-espaco ou função de transferência.",
                                    "Verifique a linearização analiticamente para entradas pequenas.",
                                    "Compare respostas iniciais do modelo linearizado com o não linear para perturbações mínimas.",
                                    "Documente o ponto de operação escolhido (valores numéricos de estados e entradas)."
                                  ],
                                  "verification": "Matrizes linearizadas corretas e resposta linearizada coincide com não linear para desvios <1%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Symbolic Toolbox ou SymPy para Jacobianas",
                                    "Planilhas para cálculos manuais",
                                    "Referências sobre linearização (ex: Ogata)"
                                  ],
                                  "tips": [
                                    "Use expansão de Taylor de primeira ordem rigorosamente.",
                                    "Automatize cálculo de Jacobianas no software para precisão."
                                  ],
                                  "learningObjective": "Aplicar linearização matemático-física corretamente em sistemas reais.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais (sinais errados).",
                                    "Linearizar em torno de zero em vez de ponto de operação real.",
                                    "Esquecer normalização de variáveis de saída."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Executar Simulações Comparativas",
                                  "subSteps": [
                                    "Defina cenários de simulação: desvios de 5%, 10%, 20%, 50% do ponto de operação em entrada.",
                                    "Configure simulações idênticas para modelos não linear e linearizado (mesmo solver, tempo de simulação).",
                                    "Execute simulações para cada desvio, registrando respostas transitórias e em regime permanente.",
                                    "Gere gráficos sobrepostos de respostas (tempo vs. saída) para comparação visual.",
                                    "Calcule métricas quantitativas iniciais como erro quadrático médio (MSE)."
                                  ],
                                  "verification": "Gráficos gerados para pelo menos 4 desvios com respostas plotadas corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink ou ODE solvers em Python",
                                    "Ferramentas de plotagem (Matplotlib/Plotly)",
                                    "Computador com bom desempenho numérico"
                                  ],
                                  "tips": [
                                    "Use solver adaptativo (ode45) para precisão.",
                                    "Normalize erros em porcentagem para comparação justa."
                                  ],
                                  "learningObjective": "Simular dinâmicas comparativas de modelos lineares e não lineares.",
                                  "commonMistakes": [
                                    "Diferentes condições iniciais entre simulações.",
                                    "Escalas de eixo inadequadas nos gráficos.",
                                    "Ignorar transientes iniciais na comparação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Precisão e Avaliar Intervalo de Validade",
                                  "subSteps": [
                                    "Compare qualitativamente: sobreposição de curvas, fase e amplitude de oscilações.",
                                    "Calcule erros quantitativos (MSE, máximo erro absoluto) para cada desvio.",
                                    "Identifique o intervalo de validade (ex: desvios <15% com erro <5%).",
                                    "Discuta limitações (ex: saturação, bifurcações) e proponha melhorias (linearização em múltiplos pontos).",
                                    "Relate conclusões em tabela ou relatório resumido."
                                  ],
                                  "verification": "Relatório com métricas, gráficos e intervalo de validade explicitamente definido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Excel ou Python Pandas para tabelas de erro",
                                    "Templates de relatório LaTeX/Word"
                                  ],
                                  "tips": [
                                    "Plote erros vs. desvio para visualização clara.",
                                    "Considere ruído ou não linearidades ocultas."
                                  ],
                                  "learningObjective": "Avaliar rigorosamente a precisão da linearização e seu escopo de aplicação.",
                                  "commonMistakes": [
                                    "Subjetividade na avaliação qualitativa sem métricas.",
                                    "Generalizar intervalo de validade além dos dados simulados.",
                                    "Confundir erro transitório com permanente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema térmico de controle de cabine de aeronave, modele o balanço de calor não linear (Q = m*c*dT/dt + h*A*(T-Tamb)). Linearize em T=25°C, simule degraus de aquecimento de 2°C, 5°C, 10°C e compare curvas de temperatura: linearizada precisa até 5°C (erro<3%), diverge em 10°C devido a convecção não linear.",
                              "finalVerifications": [
                                "Modelos não linear e linearizado implementados e validados.",
                                "Simulações comparativas executadas para ≥4 desvios do ponto de operação.",
                                "Gráficos sobrepostos mostram concordância visual e métricas quantitativas (MSE<5% em intervalo válido).",
                                "Intervalo de validade quantificado (ex: desvios <15%).",
                                "Relatório documenta limitações e aplicações aeronáuticas.",
                                "Código de simulação reproduzível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da linearização (Jacobianas precisas).",
                                "Qualidade das simulações (consistência, precisão numérica).",
                                "Análise quantitativa robusta (erros calculados corretamente).",
                                "Identificação precisa do intervalo de validade.",
                                "Clareza nos gráficos e relatório.",
                                "Relevância ao contexto aeronáutico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e séries de Taylor.",
                                "Programação: Simulação numérica e visualização de dados.",
                                "Física: Termodinâmica e mecânica dos fluidos.",
                                "Engenharia de Controle: Projeto de controladores lineares.",
                                "Estatística: Análise de erro e validação de modelos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, essa habilidade é essencial para projetar sistemas de controle de atitude, flaps hidráulicos ou ar-condicionado de cabine, onde linearizações validam controladores PID para manobras pequenas, garantindo estabilidade em voo sem simulações não lineares computacionalmente caras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Modelagem no Espaço de Estados",
                "description": "Descreve a modelagem de sistemas dinâmicos utilizando representações no espaço de estados.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Definição de Variáveis de Estado",
                    "description": "Conceito fundamental de variáveis de estado que descrevem completamente o comportamento de sistemas dinâmicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1.1",
                        "name": "Definição Formal de Variável de Estado",
                        "description": "Conceito básico de variável de estado como uma função do tempo que, em conjunto com a entrada do sistema, determina unicamente a saída futura para qualquer instante inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1.1",
                            "name": "Definir variável de estado",
                            "description": "Explicar com precisão o conceito de variável de estado em sistemas dinâmicos, destacando sua relação com equações diferenciais de ordem n e a necessidade de n variáveis independentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações diferenciais ordinárias (EDOs) de ordem n em sistemas dinâmicos",
                                  "subSteps": [
                                    "Estude a forma geral de uma EDO de ordem n: f(y, y', y'', ..., y^(n), t) = 0.",
                                    "Identifique exemplos de sistemas físicos representados por EDOs, como o movimento de uma aeronave.",
                                    "Diferencie EDOs lineares invariantes no tempo (LTI) de não-lineares.",
                                    "Pratique reduzindo uma EDO de ordem 2 para equações de primeira ordem.",
                                    "Analise a dependência temporal e as condições iniciais necessárias."
                                  ],
                                  "verification": "Resolva manualmente uma EDO de ordem 2 e liste as derivadas necessárias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce & DiPrima)",
                                    "Folha de papel e calculadora",
                                    "Vídeo tutorial sobre EDOs em sistemas dinâmicos"
                                  ],
                                  "tips": "Comece com exemplos simples como massa-mola para visualizar o comportamento dinâmico.",
                                  "learningObjective": "Compreender como EDOs modelam a evolução temporal de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir ordem da EDO com número de variáveis",
                                    "Ignorar condições iniciais",
                                    "Não distinguir derivadas de estados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a modelagem no espaço de estados",
                                  "subSteps": [
                                    "Aprenda a representação em espaço de estados: dx/dt = Ax + Bu, y = Cx + Du.",
                                    "Entenda por que sistemas de primeira ordem são preferíveis para análise e simulação.",
                                    "Converta uma EDO escalar de ordem n em um vetor de estado de dimensão n.",
                                    "Defina o vetor de estado x(t) como as n primeiras derivadas da variável principal.",
                                    "Pratique com uma EDO de ordem 3, identificando o vetor x."
                                  ],
                                  "verification": "Converta uma EDO de ordem 2 em forma vetorial e verifique se dx/dt tem dimensão 2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink para simulação",
                                    "Apostila de Controle Moderno",
                                    "Exemplos de sistemas aeronáuticos"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar a transformação.",
                                  "learningObjective": "Dominar a conversão de EDOs de alta ordem para sistemas de primeira ordem.",
                                  "commonMistakes": [
                                    "Escolher variáveis dependentes em vez de independentes",
                                    "Esquecer a matriz de entrada",
                                    "Não normalizar o vetor de estado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente a variável de estado",
                                  "subSteps": [
                                    "Memorize a definição: Uma variável de estado é um conjunto mínimo de n variáveis independentes que, com entradas e condições iniciais, descreve completamente o sistema.",
                                    "Relacione com teorema de existência e unicidade de soluções de EDOs.",
                                    "Discuta a minimalidade: n igual à ordem da EDO para realizações mínimas.",
                                    "Identifique requisitos: variáveis devem ser contínuas, diferenciáveis e independentes.",
                                    "Aplique em contexto aeronáutico: estados como posição, velocidade e ângulo de ataque."
                                  ],
                                  "verification": "Escreva a definição formal e aplique a um exemplo de ordem 2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo sobre modelagem de estados em aeronáutica",
                                    "Quadro branco para derivações",
                                    "Referência: Ogata - Engenharia de Controle Moderno"
                                  ],
                                  "tips": "Pense em 'estado' como 'memória' do sistema no instante t.",
                                  "learningObjective": "Explicar precisamente o conceito e sua relação com EDOs de ordem n.",
                                  "commonMistakes": [
                                    "Confundir variáveis de estado com saídas",
                                    "Usar mais de n variáveis desnecessariamente",
                                    "Ignorar independência linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar independência e validar a escolha de variáveis de estado",
                                  "subSteps": [
                                    "Teste a independência: a matriz de Jacobiano deve ser de posto n.",
                                    "Construa uma realização canônica (Controllability ou Observability).",
                                    "Simule numericamente para confirmar que n variáveis bastam.",
                                    "Analise redundâncias em exemplos não-mínimos.",
                                    "Aplique a um sistema real: modelo de atitude de uma aeronave."
                                  ],
                                  "verification": "Para uma EDO dada, prove que suas variáveis de estado são mínimas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB para simulação de estados",
                                    "Exercícios resolvidos de espaços de estados",
                                    "Ferramenta online como Octave"
                                  ],
                                  "tips": "Sempre verifique a transformabilidade para forma canônica.",
                                  "learningObjective": "Garantir que as variáveis escolhidas sejam adequadas e mínimas.",
                                  "commonMistakes": [
                                    "Escolher variáveis não diferenciáveis",
                                    "Não testar observabilidade/controlabilidade",
                                    "Omitir validação numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o modelo de um oscilador harmônico para vibrações em asas de aeronave: mẍ + cẋ + kx = F(t). Defina x1 = x (posição), x2 = ẋ (velocidade). Então, ẋ1 = x2, ẋ2 = -(k/m)x1 - (c/m)x2 + (1/m)F(t). Aqui, 2 variáveis de estado independentes descrevem completamente o sistema de ordem 2.",
                              "finalVerifications": [
                                "Explique verbalmente a definição de variável de estado e sua relação com EDOs de ordem n.",
                                "Converta uma EDO de ordem 3 em espaço de estados com n=3 variáveis.",
                                "Identifique erros em uma escolha não-mínima de estados.",
                                "Simule em software e confirme evolução única com condições iniciais.",
                                "Discuta por que n variáveis são necessárias e suficientes.",
                                "Aplique a um exemplo aeronáutico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos elementos chave).",
                                "Correta conversão de EDOs para espaço de estados.",
                                "Demonstração de independência e minimalidade.",
                                "Uso apropriado de exemplos contextualizados em aeronáutica.",
                                "Clareza na explicação de relações com teoremas de EDOs.",
                                "Validação prática via simulação ou cálculo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Equações Diferenciais e Álgebra Linear (autovalores).",
                                "Física: Dinâmica de Sistemas Mecânicos e Vibrações.",
                                "Engenharia de Controle: Análise de Controlabilidade e Observabilidade.",
                                "Computação: Simulação Numérica em MATLAB/Python.",
                                "Engenharia Aeronáutica: Modelagem de Dinâmica de Voo."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, variáveis de estado são usadas no controle de atitude de aeronaves (ex: F-16), onde estados como ângulo de ataque, velocidade angular e posição quaternionica permitem simulações precisas de manobras e estabilidade em flight simulators da NASA ou Boeing."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.2",
                            "name": "Identificar variáveis de estado em equações diferenciais",
                            "description": "Dado uma equação diferencial linear de ordem n, selecionar corretamente as n variáveis de estado que representem o estado interno do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a equação diferencial e identificar sua ordem",
                                  "subSteps": [
                                    "Leia atentamente a equação diferencial linear fornecida.",
                                    "Identifique a variável dependente principal (geralmente y(t)).",
                                    "Conte o maior número de derivadas presentes para determinar a ordem n.",
                                    "Confirme que é uma equação linear com coeficientes constantes.",
                                    "Escreva a equação na forma padrão: a_n y^(n) + ... + a_0 y = f(t)."
                                  ],
                                  "verification": "A ordem n está corretamente anotada e a forma padrão está escrita sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora opcional",
                                    "Referência de equações diferenciais"
                                  ],
                                  "tips": "Sempre normalize a equação dividindo pelo coeficiente líder para simplificar.",
                                  "learningObjective": "Compreender a estrutura de uma equação diferencial linear de ordem n.",
                                  "commonMistakes": [
                                    "Confundir ordem com o número de termos",
                                    "Ignorar coeficientes variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar o conceito de variáveis de estado",
                                  "subSteps": [
                                    "Defina variáveis de estado como o conjunto mínimo de funções que descrevem completamente o estado interno do sistema.",
                                    "Entenda que para uma EDO de ordem n, são necessárias exatamente n variáveis independentes.",
                                    "Lembre que as variáveis de estado devem ser contínuas e diferenciáveis.",
                                    "Discuta por que derivadas sucessivas da variável dependente são escolhidas.",
                                    "Esboce um diagrama conceitual do sistema dinâmico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e o motivo da escolha de n variáveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para diagrama",
                                    "Notas de aula sobre espaço de estados"
                                  ],
                                  "tips": "Pense no estado como 'memória' do sistema no instante atual.",
                                  "learningObjective": "Dominar a definição formal e o propósito das variáveis de estado.",
                                  "commonMistakes": [
                                    "Escolher menos ou mais que n variáveis",
                                    "Selecionar variáveis dependentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar as variáveis de estado usando o método padrão",
                                  "subSteps": [
                                    "Defina x1(t) = y(t).",
                                    "Defina x2(t) = dy/dt = y'(t).",
                                    "Continue sequencialmente: xk(t) = y^(k-1)(t) para k=2 até n.",
                                    "Liste explicitamente as n variáveis: x = [x1, x2, ..., xn]^T.",
                                    "Derive as equações diferenciais para cada xi: dx1/dt = x2, dx2/dt = x3, ..., dxn/dt = expressão da EDO."
                                  ],
                                  "verification": "Escreva o vetor de estado x(t) e confirme que tem dimensão n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para derivações",
                                    "Software simbólico como MATLAB/SymPy opcional"
                                  ],
                                  "tips": "Use notação vetorial desde o início para visualizar o espaço de estados.",
                                  "learningObjective": "Aplicar corretamente o método canônico de escolha de variáveis de estado.",
                                  "commonMistakes": [
                                    "Inverter a ordem das derivadas",
                                    "Esquecer a última equação dxn/dt"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e representar o modelo em espaço de estados",
                                  "subSteps": [
                                    "Escreva o modelo completo: dx/dt = A x + B u, y = C x + D u (para caso geral).",
                                    "Verifique se as derivadas das xi reproduzem a EDO original.",
                                    "Confirme minimalidade: o sistema tem ordem n e não pode ser reduzido.",
                                    "Teste com valores iniciais para simular continuidade.",
                                    "Compare com alternativas não-canônicas se aplicável."
                                  ],
                                  "verification": "Substitua as xi de volta na EDO e veja se ela é satisfeita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora para matrizes",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Construa a matriz A sistematicamente para evitar erros algébricos.",
                                  "learningObjective": "Validar a seleção de variáveis de estado e formar o modelo completo.",
                                  "commonMistakes": [
                                    "Erros em coeficientes da matriz A",
                                    "Ignorar entrada/saída no modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação y'' + 3y' + 2y = u(t), ordem n=2. Variáveis: x1 = y, x2 = y'. Então dx1/dt = x2, dx2/dt = -2x1 -3x2 + u, y = x1.",
                              "finalVerifications": [
                                "Lista exatamente n variáveis de estado corretas.",
                                "Equações dx/dt derivadas reproduzem a EDO original.",
                                "Vetor de estado tem dimensão n.",
                                "Modelo é linear e tempo-invariante.",
                                "Condições iniciais são consistentes com as xi.",
                                "Minimalidade confirmada (não observável/reduzível)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da ordem n (100%).",
                                "Correção na definição das n variáveis (x1=y, ..., xn=y^(n-1)) (100%).",
                                "Equações de estado dx/dt sem erros algébricos (90%).",
                                "Validação por substituição na EDO original (100%).",
                                "Representação matricial completa e correta (85%).",
                                "Explicação conceitual clara (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de sistemas massa-mola-amortecedor.",
                                "Controle Automático: Projeto de controladores no espaço de estados.",
                                "Matemática: Teoria de sistemas lineares e autovalores.",
                                "Engenharia de Controle: Estabilização de aeronaves via LQR.",
                                "Computação: Simulação em MATLAB/Simulink."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, identificar variáveis de estado em equações da dinâmica de voo (ex: equações de atitude de uma aeronave) permite modelar o movimento em espaço de estados para design de sistemas de controle autônomo, como autopilotos que estabilizam a aeronave durante turbulências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.3",
                            "name": "Explicar a unicidade da evolução do estado",
                            "description": "Demonstrar como as condições iniciais das variáveis de estado e a entrada determinam unicamente a trajetória futura do sistema dinâmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Variáveis de Estado",
                                  "subSteps": [
                                    "Defina variáveis de estado como o menor conjunto de variáveis que descrevem completamente o estado interno do sistema em qualquer instante.",
                                    "Explique que o vetor de estado x(t) captura toda a memória do sistema necessária para prever o futuro.",
                                    "Discuta como x(t) evolui de acordo com equações diferenciais ordinárias (EDOs).",
                                    "Ilustre com um exemplo simples de um sistema de primeira ordem.",
                                    "Diferencie variáveis de estado de entradas e saídas."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique variáveis de estado em um sistema dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Sistemas Dinâmicos, quadro branco, exemplos de circuitos RLC ou massa-mola.",
                                  "tips": "Sempre pergunte: 'O que preciso saber para prever o futuro do sistema?'",
                                  "learningObjective": "Compreender o papel fundamental das variáveis de estado na descrição completa do sistema.",
                                  "commonMistakes": "Confundir variáveis de estado com entradas externas ou saídas observáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Equação de Evolução do Estado",
                                  "subSteps": [
                                    "Apresente a forma padrão: dx/dt = A x + B u, onde x é o vetor de estado, u a entrada.",
                                    "Explique que A determina a dinâmica interna e B como a entrada afeta o estado.",
                                    "Discuta condições iniciais x(0) e entrada u(t) como determinantes da solução.",
                                    "Derive a solução integral formal: x(t) = e^{A t} x(0) + ∫ e^{A(t-τ)} B u(τ) dτ.",
                                    "Enfatize que a solução é uma integral definida unicamente pelos parâmetros dados."
                                  ],
                                  "verification": "Escreva a equação de estado para um sistema dado e identifique componentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Simulink para simulação, calculadora matricial.",
                                  "tips": "Visualize a matriz exponencial como propagador de estado ao longo do tempo.",
                                  "learningObjective": "Dominar a representação matemática da evolução do estado.",
                                  "commonMistakes": "Ignorar a dependência explícita em x(0) e u(t) na solução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Teorema de Existência e Unicidade",
                                  "subSteps": [
                                    "Revise o teorema de Picard-Lindelöf para EDOs lineares com coeficientes contínuos.",
                                    "Mostre que para sistemas lineares invariantes no tempo, A e B Lipschitz garantem solução única.",
                                    "Discuta extensão para sistemas lineares: solução única global para todos t.",
                                    "Compare com sistemas não-lineares onde unicidade pode falhar.",
                                    "Prove informalmente usando contração no espaço de Banach."
                                  ],
                                  "verification": "Enuncie o teorema e aplique a um exemplo linear simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de Teoria de EDOs, exemplos resolvidos de teoremas.",
                                  "tips": "Lembre-se: linearidade + Lipschitz = unicidade garantida.",
                                  "learningObjective": "Entender as condições matemáticas que asseguram unicidade.",
                                  "commonMistakes": "Assumir unicidade sem condições de regularidade nas funções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à Trajetória Futura em Sistemas Dinâmicos",
                                  "subSteps": [
                                    "Integre conceitos: dada x(0) e u(t), x(t) é unicamente determinada para t > 0.",
                                    "Simule numericamente dois cenários com mesmas x(0)/u(t) e verifique identicidade.",
                                    "Discuta implicações para previsibilidade e controle em aeronáutica.",
                                    "Analise sensibilidade a pequenas variações em x(0).",
                                    "Conclua com propriedades como causalidade e determinismo."
                                  ],
                                  "verification": "Simule e compare trajetórias idênticas em software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Python (SciPy) para simulações.",
                                  "tips": "Use solvers numéricos com tolerância baixa para validar unicidade.",
                                  "learningObjective": "Demonstrar como condições iniciais/entry determinam unicamente a evolução.",
                                  "commonMistakes": "Confundir unicidade com estabilidade ou convergência."
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de atitude de uma aeronave simplificado: dx/dt = [-0.1, 1; 0, -0.2] x + [0; 1] u, com x(0) = [1; 0] e u(t) = sin(t). Simule x(t) e mostre que qualquer outro solver ou método inicial produz a mesma trajetória exata.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de unicidade para EDOs lineares.",
                                "Derive a solução de estado para um sistema de 2ª ordem.",
                                "Simule e confirme identicidade de trajetórias com mesmas condições.",
                                "Explique verbalmente por que x(0) e u(t) determinam unicamente o futuro.",
                                "Identifique cenários onde unicidade falha (ex: não-linearidades).",
                                "Aplique a um exemplo aeronáutico real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução de estado (80% correto).",
                                "Compreensão demonstrada via simulação idêntica em múltiplos runs.",
                                "Explicação clara da dependência em x(0) e u(t).",
                                "Uso correto de teoremas matemáticos subjacentes.",
                                "Aplicação contextual a sistemas dinâmicos aeronáuticos.",
                                "Identificação de erros comuns e contra-exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Equações Diferenciais Ordinárias.",
                                "Física: Dinâmica de sistemas mecânicos (ex: osciladores).",
                                "Engenharia de Controle: Previsibilidade em laços de feedback.",
                                "Computação: Simulação numérica e solvers de EDOs."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, essa unicidade garante que o modelo de espaço de estado de um controlador de voo autônomo, dado o estado inicial da aeronave (posição, velocidade) e comandos de entrada (empuxo, superfícies), preveja unicamente a trajetória futura, essencial para navegação segura e simulações de certificação FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.2",
                        "name": "Propriedades das Variáveis de Estado",
                        "description": "Características essenciais como minimalidade, completude e independência das variáveis de estado para descrever completamente sistemas dinâmicos lineares e não lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.2.1",
                            "name": "Verificar minimalidade do conjunto de estados",
                            "description": "Determinar se um conjunto proposto de variáveis é mínimo, ou seja, não pode ser reduzido sem perda de informação sobre o comportamento do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Condições de Minimalidade",
                                  "subSteps": [
                                    "Ler a definição de conjunto de estados mínimo: não pode ser reduzido sem perda de informação dinâmica.",
                                    "Estudar condições necessárias: independência linear das trajetórias de estado e captura completa da dinâmica.",
                                    "Identificar critérios formais: controlabilidade e observabilidade (Teorema de Kalman).",
                                    "Anotar exemplos de conjuntos não mínimos (ex.: variáveis redundantes).",
                                    "Comparar com conjuntos mínimos em diagramas de fluxo."
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito as condições de minimalidade com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Sistemas Dinâmicos, caderno e caneta.",
                                  "tips": "Use analogias como 'bagagem mínima para viagem' para visualizar redundâncias.",
                                  "learningObjective": "Compreender conceitualmente o que torna um conjunto de estados mínimo.",
                                  "commonMistakes": "Confundir minimalidade com ordem zero ou ignorar observabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Representação no Espaço de Estados",
                                  "subSteps": [
                                    "Derivar equações diferenciais do sistema físico proposto.",
                                    "Escolher variáveis candidatas de estado e formar vetores x, u, y.",
                                    "Montar matrizes A (dinâmica), B (entrada), C (saída) e D (feedthrough).",
                                    "Verificar consistência: dx/dt = Ax + Bu e y = Cx + Du.",
                                    "Simular numericamente uma trajetória inicial para validar."
                                  ],
                                  "verification": "Resolver manualmente ou via software e comparar saída com modelo original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software MATLAB/Simulink ou Python (SciPy), papel quadriculado.",
                                  "tips": "Comece com sistemas de baixa ordem (n=2) para prática rápida.",
                                  "learningObjective": "Construir modelo em espaço de estado a partir de descrição do sistema.",
                                  "commonMistakes": "Escolher variáveis dependentes lineares, levando a singularidades em A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Controlabilidade e Observabilidade",
                                  "subSteps": [
                                    "Calcular matriz de controlabilidade: [B, AB, A²B, ..., A^{n-1}B] e seu posto (deve ser n).",
                                    "Calcular matriz de observabilidade: [C; CA; CA²; ...; CA^{n-1}] e seu posto (deve ser n).",
                                    "Usar autovalores de A para confirmar ausência de modos não controláveis/observáveis.",
                                    "Se posto < n, identificar subespaços nulos e variáveis redundantes.",
                                    "Testar remoção de uma variável e reavaliar posto das matrizes."
                                  ],
                                  "verification": "Posto das matrizes = dimensão do espaço de estados (n).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora matricial ou MATLAB (funções ctrb, obsv, rank).",
                                  "tips": "Use forma canônica de Kalman para simplificar cálculos iniciais.",
                                  "learningObjective": "Aplicar testes de Kalman para avaliar minimalidade.",
                                  "commonMistakes": "Esquecer de verificar posto completo ou confundir controlabilidade com estabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar Minimalidade e Reduzir se Necessário",
                                  "subSteps": [
                                    "Se ambos testes passam, declarar conjunto mínimo.",
                                    "Se falha, realizar redução de ordem via decomposição (modos controláveis/observáveis).",
                                    "Comparar respostas em malha aberta/fechada antes/depois da redução.",
                                    "Documentar novas variáveis de estado reduzidas.",
                                    "Validar com simulação de cenários de falha ou perturbação."
                                  ],
                                  "verification": "Simulações coincidem e ordem é mínima possível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Simulador (MATLAB/Simulink), gráficos de resposta.",
                                  "tips": "Sempre normalize matrizes para evitar erros numéricos.",
                                  "learningObjective": "Finalizar verificação e otimizar conjunto de estados.",
                                  "commonMistakes": "Não validar redução com simulações dinâmicas."
                                }
                              ],
                              "practicalExample": "Em um sistema de dois tanques acoplados (h1, h2 níveis de água), proponha estados [h1, h2, dh1/dt]. Verifique: monte A/B/C, calcule postos (se posto=3, mínimo; senão, reduza para [h1 - h2, dh1/dt]). Simule vazão de entrada e confirme saídas idênticas.",
                              "finalVerifications": [
                                "Explica corretamente critérios de controlabilidade e observabilidade.",
                                "Calcula postos das matrizes sem erros para exemplo dado.",
                                "Identifica e remove redundâncias em conjunto não mínimo.",
                                "Valida redução via simulação de trajetórias.",
                                "Documenta conclusões com justificativa formal.",
                                "Discute limitações para sistemas não lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (posto correto).",
                                "Correta interpretação de resultados de testes Kalman.",
                                "Qualidade da redução de ordem, se aplicável.",
                                "Validação prática via simulação.",
                                "Clareza na documentação e explicação.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Cálculo de posto e autovalores.",
                                "Controle Automático: Projeto de controladores baseados em realizações mínimas.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/fluidos.",
                                "Computação: Algoritmos numéricos para análise de sistemas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, verificar minimalidade em modelos de controle de voo (ex.: estabilização de asas) reduz carga computacional em flight controllers embarcados, melhorando eficiência e confiabilidade em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.2.2",
                            "name": "Avaliar completude das variáveis de estado",
                            "description": "Analisar se um conjunto de variáveis descreve completamente o estado interno, permitindo prever a saída para qualquer entrada futura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Completude das Variáveis de Estado",
                                  "subSteps": [
                                    "Leia a definição: variáveis de estado são completas se descrevem unicamente o estado interno, permitindo prever qualquer saída futura para entradas dadas.",
                                    "Estude exemplos onde variáveis incompletas levam a ambiguidades (ex: dois estados diferentes produzem mesmas saídas).",
                                    "Revise propriedades relacionadas: minimalidade, observabilidade e controlabilidade.",
                                    "Anote critérios matemáticos: rank da matriz de observabilidade deve ser n (dimensão do estado).",
                                    "Discuta com pares ou tutor para esclarecer dúvidas."
                                  ],
                                  "verification": "Resuma o conceito em 3 frases próprias e identifique 2 exemplos de incompletude.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre modelagem em espaço de estado, livro-texto de sistemas dinâmicos, exemplos online de MATLAB/Simulink.",
                                  "tips": "Use diagramas de fluxo de sinal para visualizar o estado interno.",
                                  "learningObjective": "Definir e exemplificar completude das variáveis de estado.",
                                  "commonMistakes": "Confundir completude com observabilidade (completude foca na suficiência descritiva do estado)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar e Analisar o Modelo do Sistema",
                                  "subSteps": [
                                    "Escreva as equações diferenciais ou de diferença do sistema.",
                                    "Converta para forma de espaço de estado: dx/dt = Ax + Bu, y = Cx + Du.",
                                    "Identifique as variáveis de estado propostas (x1, x2, ...).",
                                    "Calcule as matrizes A, B, C, D.",
                                    "Verifique dimensões: número de estados n deve ser mínimo possível."
                                  ],
                                  "verification": "Confirme que as equações reproduzem o comportamento original do sistema.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado ou software como MATLAB, Python (control library), exemplos de sistemas aeronáuticos.",
                                  "tips": "Comece com sistemas de baixa ordem (n=2) para prática.",
                                  "learningObjective": "Construir representação precisa em espaço de estado.",
                                  "commonMistakes": "Escolher variáveis redundantes, aumentando ordem desnecessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Testes Matemáticos de Completude",
                                  "subSteps": [
                                    "Construa a matriz de observabilidade O = [C; CA; CA^2; ...; CA^{n-1}].",
                                    "Calcule o rank de O; deve ser igual a n para completude.",
                                    "Verifique controlabilidade com matriz de controllabilidade se relevante.",
                                    "Simule duas trajetórias iniciais diferentes e verifique se saídas futuras divergem para entradas iguais.",
                                    "Identifique estados indistinguíveis se rank < n."
                                  ],
                                  "verification": "Rank(O) == n e simulações mostram previsibilidade única.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Simulink ou Python (numpy, scipy para eigenvalores e rank), calculadora matricial.",
                                  "tips": "Use comandos prontos como 'obsv(A,C)' no MATLAB para agilizar.",
                                  "learningObjective": "Aplicar critérios algébricos para validar completude.",
                                  "commonMistakes": "Ignorar modos não observáveis que mascaram incompletude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar a Completude",
                                  "subSteps": [
                                    "Execute simulações numéricas para entradas arbitrárias e compare previsões.",
                                    "Reduza o modelo se possível (realização mínima via transformações).",
                                    "Registre achados: completo ou não, e sugestões de correção.",
                                    "Teste com ruído ou perturbações para robustez.",
                                    "Prepare relatório com gráficos de simulação."
                                  ],
                                  "verification": "Previsões de saída coincidem perfeitamente para estados iniciais únicos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de simulação (Simulink, Python matplotlib para plots), template de relatório.",
                                  "tips": "Grave vídeos curtos das simulações para evidência visual.",
                                  "learningObjective": "Confirmar completude via validação prática e relatar resultados.",
                                  "commonMistakes": "Sobrepor confiança em testes analíticos sem simulação numérica."
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola-amortecedor em uma asa de aeronave: equações mẍ + cẋ + kx = u, y = x. Variáveis propostas: x1 = x (posição), x2 = ẋ (velocidade). Matriz A = [[0,1],[-k/m,-c/m]], C=[1,0]. Calcule rank(O)=2 → completo, permitindo prever vibrações futuras da asa para qualquer controle u.",
                              "finalVerifications": [
                                "Rank da matriz de observabilidade é igual à dimensão do estado n.",
                                "Simulações de trajetórias passadas convergem a estados únicos com saídas futuras idênticas.",
                                "Modelo prevê corretamente saídas para 5 entradas arbitrárias.",
                                "Não há pares de estados indistinguíveis.",
                                "Redução de ordem não altera comportamento dinâmico.",
                                "Testes com ruído confirmam robustez da completude."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de matrizes e rank (100% correto).",
                                "Qualidade das simulações e gráficos (clareza e relevância).",
                                "Profundidade da análise de incompletude potencial (identifica causas).",
                                "Relatório completo com conclusões justificadas.",
                                "Aplicação correta de conceitos teóricos.",
                                "Criatividade em exemplos de validação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Cálculo de rank e autovalores.",
                                "Programação Computacional: Simulações em MATLAB/Python.",
                                "Física Aplicada: Dinâmica de sistemas aeronáuticos.",
                                "Engenharia de Controle: Minimal realizations."
                              ],
                              "realWorldApplication": "Em simulações de voo de aeronaves, variáveis de estado completas garantem que modelos de controle predigam precisamente respostas a turbulências ou comandos de piloto, evitando instabilidades catastróficas em sistemas autônomos como drones ou aviões comerciais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.2.3",
                            "name": "Discutir independência linear das variáveis",
                            "description": "Explicar e verificar a independência das variáveis de estado em sistemas lineares contínuos, relacionando com a ordem do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Independência Linear Vetorial",
                                  "subSteps": [
                                    "Revise a definição de independência linear: um conjunto de vetores é linearmente independente se nenhuma combinação linear não-trivial resulta no vetor zero.",
                                    "Estude exemplos em R² e R³, como vetores canônicos versus vetores colineares.",
                                    "Pratique identificando conjuntos independentes e dependentes usando equações lineares.",
                                    "Explore o conceito de base e dimensão de um espaço vetorial.",
                                    "Relacione independência linear à representação única de vetores em uma base."
                                  ],
                                  "verification": "Resolva 3 problemas de identificação de independência linear e confira com soluções conhecidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), caderno e calculadora.",
                                  "tips": "Visualize graficamente em 2D para intuição rápida.",
                                  "learningObjective": "Dominar a definição e identificação de independência linear em espaços vetoriais.",
                                  "commonMistakes": "Confundir independência com ortogonalidade ou normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Representação de Espaço de Estado em Sistemas Lineares Contínuos",
                                  "subSteps": [
                                    "Lembre a forma canônica: dx/dt = Ax + Bu, y = Cx + Du, onde x são variáveis de estado.",
                                    "Identifique as variáveis de estado x como um vetor coluna em Rⁿ.",
                                    "Discuta como as variáveis de estado capturam a dinâmica interna do sistema.",
                                    "Analise a matriz A e sua relação com a ordem n do sistema.",
                                    "Examine exemplos simples como integrador ou oscilador harmônico."
                                  ],
                                  "verification": "Escreva a equação de espaço de estado para um sistema massa-mola e identifique x.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula de Sinais e Sistemas, MATLAB ou Octave para simulação.",
                                  "tips": "Sempre normalize unidades para consistência.",
                                  "learningObjective": "Entender o papel das variáveis de estado na modelagem dinâmica.",
                                  "commonMistakes": "Confundir variáveis de estado com entradas ou saídas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Independência Linear às Variáveis de Estado",
                                  "subSteps": [
                                    "Verifique se as colunas da matriz de identidade inicial (para x) são independentes.",
                                    "Discuta que variáveis de estado independentes implicam minimalidade do modelo.",
                                    "Analise transformações de coordenadas: x' = Tx, preservando independência se T invertível.",
                                    "Identifique dependências: se rank([x1 x2 ... xn]) < n, há dependência.",
                                    "Relacione à ordem do sistema: n independentes = ordem n mínima."
                                  ],
                                  "verification": "Para um sistema dado, compute o rank do vetor de estados ao longo do tempo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software MATLAB (função rank()), exemplos de sistemas lineares.",
                                  "tips": "Use a função rank() em MATLAB para verificação numérica rápida.",
                                  "learningObjective": "Reconhecer quando variáveis de estado são linearmente independentes.",
                                  "commonMistakes": "Ignorar dependências temporais ou assumir independência por inspeção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Discutir Implicações da Independência Linear",
                                  "subSteps": [
                                    "Implemente teste: resolva Ax = 0 para x ≠ 0; se só solução trivial, independente.",
                                    "Discuta relação com observabilidade e controlabilidade.",
                                    "Analise impacto em sistemas não mínimos: redução de ordem via eliminação de estados dependentes.",
                                    "Exemplo: sistema com estados redundantes (duplo integrador mal modelado).",
                                    "Conclua discutindo por que independência garante ordem correta."
                                  ],
                                  "verification": "Crie um relatório curto com exemplo verificado e discussão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Simulink, papel e lápis para derivações.",
                                  "tips": "Teste numericamente com ruído para robustez.",
                                  "learningObjective": "Avaliar independência e suas consequências na modelagem.",
                                  "commonMistakes": "Confundir rank da matriz A com rank das trajetórias de estado."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Exemplos e Contraexemplos Práticos",
                                  "subSteps": [
                                    "Modele um circuito RLC e verifique independência de correntes/tensões.",
                                    "Crie um contraexemplo: adicione estado dependente e reduza ordem.",
                                    "Simule trajetórias e plote para visualização de dependência.",
                                    "Discuta em grupo ou anote implicações para aeronáutica.",
                                    "Resuma relação: independência ↔ ordem mínima ↔ eficiência computacional."
                                  ],
                                  "verification": "Simulação MATLAB mostrando rank= n antes/depois redução.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB com toolbox Control Systems, exemplos de aeronáutica.",
                                  "tips": "Use plot3 para visualizar independência em 3D.",
                                  "learningObjective": "Aplicar conceitos a casos reais e sintetizar conhecimentos.",
                                  "commonMistakes": "Overfitting modelos sem checar minimalidade."
                                }
                              ],
                              "practicalExample": "Em um sistema massa-mola-amortecedor (ordem 2), as variáveis de estado x = [posição; velocidade] são linearmente independentes (rank=2). Se adicionar um estado redundente como 'aceleração integral', rank cai para 2, revelando dependência e permitindo redução para ordem mínima.",
                              "finalVerifications": [
                                "Conjunto de variáveis de estado tem rank n igual à ordem do sistema.",
                                "Nenhuma combinação linear não-trivial zera o vetor de estado.",
                                "Transformação de coordenadas preserva invertibilidade da matriz T.",
                                "Simulação mostra trajetórias que spanam Rⁿ sem colinearidade.",
                                "Modelo mínimo confirmado por ausência de modos não observáveis/controláveis.",
                                "Discussão verbal explica relação com ordem do sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de independência linear (90% correto).",
                                "Correta aplicação a espaço de estado com exemplos (rank verificado).",
                                "Relação clara com ordem mínima do sistema.",
                                "Uso adequado de ferramentas como MATLAB para verificação.",
                                "Discussão de implicações práticas e erros comuns.",
                                "Relatório estruturado com visualizações.",
                                "Profundidade em contraexemplos e reduções."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: bases, rank e nulidade.",
                                "Controle Automático: realizabilidade mínima e Kalman's decomposition.",
                                "Física: dinâmica newtoniana e Lagrangiana para escolha de estados.",
                                "Programação: implementação numérica de testes de rank em Python/MATLAB.",
                                "Engenharia Aeronáutica: modelagem de flight dynamics."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, variáveis de estado independentes (ex: posição, velocidade, ângulos de Euler) garantem modelos de ordem mínima para simulações eficientes de estabilidade e manobras, evitando computação desnecessária em flight control systems como no F-16."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.3",
                        "name": "Espaço de Estados e Representação",
                        "description": "Conjunto de todas as possíveis combinações de valores das variáveis de estado, formando o espaço vetorial que modela o sistema dinâmico.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.3.1",
                            "name": "Definir o espaço de estados",
                            "description": "Descrever o espaço de estados como o R^n onde n é o número de variáveis de estado, e ilustrar com exemplos simples de sistemas mecânicos ou elétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de variáveis de estado",
                                  "subSteps": [
                                    "Identifique o que são variáveis de estado em sistemas dinâmicos: quantidades que determinam completamente o comportamento futuro do sistema.",
                                    "Distinga variáveis de estado de entradas e saídas.",
                                    "Liste exemplos de variáveis de estado em sistemas contínuos, como posição e velocidade.",
                                    "Explique por que o número de variáveis de estado define a ordem do sistema.",
                                    "Discuta minimalidade: escolha de variáveis independentes."
                                  ],
                                  "verification": "Escreva uma definição curta das variáveis de estado e liste 3 exemplos de um sistema conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro de texto de sistemas dinâmicos (cap. espaço de estados)"
                                  ],
                                  "tips": "Lembre-se: estados devem capturar toda a memória do sistema.",
                                  "learningObjective": "Compreender o papel fundamental das variáveis de estado na modelagem dinâmica.",
                                  "commonMistakes": "Confundir estados com entradas (ex: força como estado em vez de entrada)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir matematicamente o espaço de estados",
                                  "subSteps": [
                                    "Defina o espaço de estados S como o conjunto de todos os possíveis vetores de estado x = [x1, x2, ..., xn]^T.",
                                    "Explique que para sistemas lineares contínuos, S = R^n, onde n é o número de variáveis de estado.",
                                    "Descreva propriedades: S é um espaço vetorial euclidiano de dimensão n.",
                                    "Ilustre graficamente para n=1 (linha real) e n=2 (plano).",
                                    "Discuta trajetórias no espaço de estado: curvas parametrizadas por tempo."
                                  ],
                                  "verification": "Desenhe o espaço de estados para n=2 e rotule os eixos como componentes de estado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de desenho vetorial ou GeoGebra"
                                  ],
                                  "tips": "Pense no espaço de estados como um 'mapa' onde o sistema evolui.",
                                  "learningObjective": "Formalizar o espaço de estados como R^n e suas implicações geométricas.",
                                  "commonMistakes": "Esquecer que n é finito e fixo para sistemas lineares de ordem finita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ilustrar com exemplo de sistema mecânico",
                                  "subSteps": [
                                    "Escolha um sistema massa-mola-amortecedor: equações mẍ + bẋ + kx = u.",
                                    "Identifique variáveis de estado: x1 = x (posição), x2 = ẋ (velocidade).",
                                    "Escreva o vetor de estado x = [x1, x2]^T ∈ R^2.",
                                    "Desenhe o espaço de fase (R^2) com trajetórias elípticas para resposta livre.",
                                    "Simule uma condição inicial e trace a evolução."
                                  ],
                                  "verification": "Escreva as equações em forma de estado e identifique S = R^2 explicitamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "MATLAB ou Python (SymPy para simulação)"
                                  ],
                                  "tips": "Use espaço de fase para visualizar estabilidade (origem atratora).",
                                  "learningObjective": "Aplicar a definição a um sistema mecânico clássico.",
                                  "commonMistakes": "Escolher aceleração como estado redundante, violando minimalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com exemplo de sistema elétrico",
                                  "subSteps": [
                                    "Considere um circuito RLC série: L i̇ + R i + (1/C) ∫i dt = v(t).",
                                    "Escolha estados: x1 = i (corrente), x2 = ∫i dt (carga no capacitor).",
                                    "Forme x = [x1, x2]^T ∈ R^2.",
                                    "Escreva as equações ẋ = A x + B u.",
                                    "Compare com o mecânico: analogia posição-carga, velocidade-corrente."
                                  ],
                                  "verification": "Derive a matriz A para o circuito e confirme S = R^2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de circuito online (Falstad ou LTSpice)",
                                    "Papel para derivação"
                                  ],
                                  "tips": "Analogias mecânico-elétrico aceleram a compreensão.",
                                  "learningObjective": "Estender a definição a domínios elétricos com analogias.",
                                  "commonMistakes": "Inverter estados (ex: tensão como estado primário em vez de carga)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e praticar generalizações",
                                  "subSteps": [
                                    "Compare os dois exemplos: ambos n=2, S=R^2.",
                                    "Generalize para sistemas de ordem superior (ex: n=4 para dois amortecedores).",
                                    "Discuta não-linearidades: S ainda R^n localmente.",
                                    "Crie seu próprio exemplo simples e defina seu espaço de estados.",
                                    "Resolva um exercício: dado modelo diferencial, encontre S."
                                  ],
                                  "verification": "Crie e documente um exemplo original com S explicitamente definido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios de livro-texto",
                                    "Notebook Jupyter para plotar"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso determina unicamente o futuro?' para validar estados.",
                                  "learningObjective": "Consolidar o conceito através de síntese e criação independente.",
                                  "commonMistakes": "Assumir S como subconjunto de R^n em vez do espaço completo."
                                }
                              ],
                              "practicalExample": "Em um sistema massa-mola simples (m=1kg, k=1N/m), estados x1=posição (m), x2=velocidade (m/s). Espaço de estados S = R^2. Trajetória: elipse centrada na origem para movimento livre.",
                              "finalVerifications": [
                                "Descreve corretamente S = R^n com n= número de estados independentes.",
                                "Identifica estados mínimos em exemplos mecânicos e elétricos.",
                                "Desenha representação gráfica do espaço para n≤3.",
                                "Explica evolução temporal como curva em S.",
                                "Generaliza para sistemas de ordem arbitrária.",
                                "Distingue espaço de estados de espaço de entradas/saídas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de S = R^n (pontos plenos).",
                                "Correta identificação de variáveis de estado em exemplos (sem redundâncias).",
                                "Qualidade das ilustrações gráficas e analogias.",
                                "Capacidade de generalizar a novos sistemas.",
                                "Clareza na explicação de propriedades (dimensão, trajetórias).",
                                "Ausência de erros comuns como confusão com variáveis dependentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (espaços vetoriais, bases).",
                                "Física: Dinâmica clássica e circuitos elétricos.",
                                "Computação: Simulações numéricas (ODE solvers em Python/MATLAB).",
                                "Engenharia de Controle: Base para análise de estabilidade e observabilidade."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, o espaço de estados modela dinâmica de voo (ex: ângulos de Euler e velocidades em R^6+), essencial para design de controladores automáticos de estabilidade em aviões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.3.2",
                            "name": "Representar sistema no espaço de estados",
                            "description": "Converter uma equação diferencial em forma de espaço de estados, escrevendo as equações dx/dt = f(x,u) e y = g(x,u).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a equação diferencial do sistema",
                                  "subSteps": [
                                    "Identifique a ordem da equação diferencial (número de derivadas mais altas).",
                                    "Escreva a equação na forma padrão: a_n y^(n) + ... + a_0 y = b_m u^(m) + ... + b_0 u.",
                                    "Destaque as variáveis de entrada (u) e saída (y).",
                                    "Verifique se o sistema é linear ou não-linear para escolher a forma de representação.",
                                    "Anote as condições iniciais se fornecidas."
                                  ],
                                  "verification": "Confirme que a ordem e coeficientes estão corretamente identificados em um rascunho.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, equação diferencial impressa ou anotada, calculadora.",
                                  "tips": "Sempre normalize a equação dividindo pelo coeficiente líder para simplificar.",
                                  "learningObjective": "Compreender a estrutura da equação diferencial para preparar a escolha de estados.",
                                  "commonMistakes": "Ignorar termos não-lineares ou confundir entrada com saída."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as variáveis de estado",
                                  "subSteps": [
                                    "Escolha x1 = y, x2 = dy/dt, ..., xn = d^(n-1)y/dt^(n-1) para sistemas lineares de ordem n.",
                                    "Para não-lineares, selecione variáveis que capturem a dinâmica completa.",
                                    "Expresse todas as derivadas em termos das variáveis de estado x e entrada u.",
                                    "Verifique se as equações são causalmente resolvíveis (dx/dt depende só de x atuais e u).",
                                    "Liste o vetor de estado x = [x1, x2, ..., xn]^T."
                                  ],
                                  "verification": "Escreva explicitamente cada xi e confirme independência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, lápis para revisões.",
                                  "tips": "Use a forma canônica de fase para iniciantes em sistemas lineares.",
                                  "learningObjective": "Selecionar variáveis de estado mínimas e independentes.",
                                  "commonMistakes": "Escolher estados redundantes ou que não cubram toda a dinâmica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as equações do espaço de estados dx/dt = f(x, u)",
                                  "subSteps": [
                                    "Substitua as derivadas nas equações usando as definições de estado.",
                                    "Expresse dx1/dt = x2, dx2/dt = x3, ..., dxn/dt = expressão resolvida da equação original.",
                                    "Resolva para a derivada mais alta e isole termos lineares ou não-lineares.",
                                    "Escreva em forma matricial para lineares: dx/dt = A x + B u.",
                                    "Teste substituindo valores numéricos simples para validar."
                                  ],
                                  "verification": "Derive dx/dt e confirme que reproduz a equação diferencial original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica ou software como MATLAB/SymPy (opcional), folhas de rascunho.",
                                  "tips": "Mantenha a ordem das derivadas consistente para evitar erros de sinal.",
                                  "learningObjective": "Construir o vetor dinâmico corretamente.",
                                  "commonMistakes": "Erros de sinal em derivadas ou divisão incorreta por coeficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a equação de saída y = g(x, u)",
                                  "subSteps": [
                                    "Expresse y diretamente em termos de estados: y = x1 + termos de u se houver alimentação direta.",
                                    "Para lineares, use y = C x + D u.",
                                    "Inclua saídas múltiplas se aplicável.",
                                    "Verifique dimensionalidade: y escalar ou vetor compatível.",
                                    "Combine com dx/dt para formar o modelo completo."
                                  ],
                                  "verification": "Substitua de volta na equação original e veja se y é recuperado corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para matrizes, caneta.",
                                  "tips": "D é zero na maioria dos casos físicos sem alimentação direta.",
                                  "learningObjective": "Completar o modelo com saída adequada.",
                                  "commonMistakes": "Esquecer termos de alimentação direta (D u)."
                                }
                              ],
                              "practicalExample": "Para o sistema massa-mola-amortecedor: m ÿ + b ẏ + k y = u. Defina x1 = y, x2 = ẏ. Então dx/dt = [0 1; -k/m -b/m] [x1; x2] + [0; 1/m] u, y = [1 0] [x1; x2].",
                              "finalVerifications": [
                                "Simule numericamente os primeiros passos e compare com solução analítica da ED original.",
                                "Verifique se o modelo tem o mesmo número mínimo de estados (observabilidade/controle).",
                                "Confirme linearidade/inlinearidade preservada nas equações.",
                                "Teste com u=0: dinâmica livre deve coincidir.",
                                "Verifique estabilidade qualitativa (autovalores para lineares)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha de variáveis de estado (mínimas e independentes).",
                                "Correção das equações dx/dt e y (reproduz ED original).",
                                "Forma matricial clara e correta para lineares.",
                                "Tratamento adequado de não-linearidades se presentes.",
                                "Verificações internas documentadas.",
                                "Clareza na apresentação (legendas, unidades)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, autovalores).",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Programação: Implementação em MATLAB/Simulink para simulação.",
                                "Controle Automático: Base para controladores LQR ou observadores."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, representa dinâmica de aeronaves (ex: modelo de atitude com equações de Euler) para design de sistemas de controle de voo autônomo em drones ou aviões."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1.2",
                              "10.1.5.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.3.3",
                            "name": "Aplicar em exemplos práticos",
                            "description": "Identificar e definir variáveis de estado em sistemas reais como circuitos RLC ou massas-molas, justificando a escolha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o sistema físico e identificar componentes principais",
                                  "subSteps": [
                                    "Descreva o diagrama esquemático ou físico do sistema (ex: circuito RLC ou massa-mola).",
                                    "Liste todos os elementos dinâmicos: resistores, indutores, capacitores, massas, molas, amortecedores.",
                                    "Identifique entradas (forças, tensões) e saídas (posições, correntes).",
                                    "Determine as leis físicas governantes (Kirchhoff, Newton).",
                                    "Esboce o grafo de dependências entre variáveis."
                                  ],
                                  "verification": "Confirme que o diagrama está completo e as leis físicas listadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, software de diagramação (ex: Draw.io), referências teóricas de dinâmica.",
                                  "tips": "Comece sempre pelo mais simples: desenhe o sistema como se explicasse para um colega.",
                                  "learningObjective": "Compreender a estrutura dinâmica do sistema para basear a escolha de estados.",
                                  "commonMistakes": "Ignorar elementos parasitas ou assumir linearidade sem verificar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar variáveis candidatas para estados",
                                  "subSteps": [
                                    "Liste variáveis que armazenam energia: corrente no indutor (i_L), tensão no capacitor (v_C), posição da massa (x), velocidade (v).",
                                    "Priorize variáveis independentes que descrevam completamente o estado futuro.",
                                    "Evite variáveis derivadas ou dependentes (ex: tensão em resistor).",
                                    "Conte o número mínimo de estados necessários (ordem do sistema).",
                                    "Registre todas as candidatas em uma tabela."
                                  ],
                                  "verification": "Verifique se as variáveis selecionadas são suficientes para prever o comportamento futuro sem memória adicional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela em planilha (Excel/Google Sheets), equações diferenciais do sistema.",
                                  "tips": "Pense em 'memória' do sistema: o que ele 'lembra' do passado?",
                                  "learningObjective": "Selecionar variáveis que capturam a dinâmica inerente do sistema.",
                                  "commonMistakes": "Escolher variáveis redundantes, levando a modelos não mínimos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar a escolha das variáveis de estado",
                                  "subSteps": [
                                    "Explique por que cada variável é necessária (ex: i_L para fluxo magnético, v_C para carga elétrica).",
                                    "Demonstre independência: derive uma a partir das outras sem perda de informação.",
                                    "Compare com alternativas e justifique superioridade (minimalidade, simplicidade).",
                                    "Discuta linearidade e condições de validade.",
                                    "Escreva um parágrafo de justificativa formal para cada variável."
                                  ],
                                  "verification": "A justificativa deve convencer um revisor de que o conjunto é mínimo e completo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentador (Word/Google Docs), exemplos de livros-texto.",
                                  "tips": "Use analogias: estados são como 'combustível restante' em um carro.",
                                  "learningObjective": "Desenvolver raciocínio físico-matemático para validação de modelos.",
                                  "commonMistakes": "Justificativas vagas sem ligação à conservação de energia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar o modelo de espaço de estado",
                                  "subSteps": [
                                    "Escreva as equações diferenciais: dx/dt = A x + B u, y = C x + D u.",
                                    "Substitua as variáveis escolhidas e derive matrizes A, B, C, D.",
                                    "Simule numericamente para um caso simples e compare com solução analítica.",
                                    "Verifique controllabilidade e observabilidade básicas.",
                                    "Documente o modelo completo."
                                  ],
                                  "verification": "Simulação reproduz comportamento esperado com erro <5%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python (SciPy), simulador online (ex: Falstad para RLC).",
                                  "tips": "Teste com entrada zero: o sistema deve relaxar corretamente.",
                                  "learningObjective": "Construir representação matricial acionável para análise e controle.",
                                  "commonMistakes": "Erros de sinal nas derivadas ou matrizes invertidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e refinar o modelo",
                                  "subSteps": [
                                    "Compare com modelos padrão de literatura para o sistema.",
                                    "Identifique limitações (ex: não-linearidades ignoradas).",
                                    "Teste sensibilidade a parâmetros.",
                                    "Proponha melhorias ou extensões.",
                                    "Resuma lições aprendidas."
                                  ],
                                  "verification": "Modelo coincide com referências em pelo menos 90% dos casos testados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências bibliográficas (Ogata, Franklin), relatórios de simulação.",
                                  "tips": "Sempre pergunte: 'Isso modela o mundo real?'",
                                  "learningObjective": "Criticar e iterar modelos para robustez.",
                                  "commonMistakes": "Aceitar o primeiro modelo sem validação cruzada."
                                }
                              ],
                              "practicalExample": "Para um circuito RLC série com entrada de tensão u(t), defina estados como x1 = i_L (corrente no indutor), x2 = v_C (tensão no capacitor). Justificativa: i_L armazena energia magnética (LI^2/2), v_C armazena energia elétrica (CV^2/2), capturando toda dinâmica. Equações: dx1/dt = -R/L x1 -1/L x2 +1/L u; dx2/dt = x1/C.",
                              "finalVerifications": [
                                "O número de estados equals ordem do sistema diferencial.",
                                "Energia total é função positiva definida dos estados.",
                                "Simulação com u=0 converge a equilíbrio.",
                                "Matriz A tem autovalores com partes reais negativas (estabilidade).",
                                "Justificativa cobre independência e minimalidade.",
                                "Modelo reproduz resposta em frequência conhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis energéticas (30%).",
                                "Qualidade da justificativa física-matemática (25%).",
                                "Corretude das equações de estado (20%).",
                                "Validação via simulação (15%).",
                                "Clareza e completude da documentação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de energia e leis de Kirchhoff/Newton.",
                                "Controle Automático: Preparação para controllabilidade e estabilização.",
                                "Programação: Implementação em MATLAB/Python para simulação.",
                                "Matemática: Álgebra linear e sistemas diferenciais lineares.",
                                "Engenharia Mecânica: Analogia massa-mola com aeroelasticidade."
                              ],
                              "realWorldApplication": "Em aeronáutica, modela dinâmica de flexão de asas (massa-mola) ou circuitos de controle de potência em aviões, permitindo design de controladores PID/LQR para estabilidade de voo e redução de vibrações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Equações de Estado Contínuas",
                    "description": "Representação matricial das derivadas das variáveis de estado em função das entradas e estados atuais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Vetor de Estado e Derivada Temporal",
                        "description": "Definição do vetor de estado x(t) como o conjunto mínimo de variáveis que descrevem completamente o estado interno de um sistema dinâmico contínuo no tempo t, e sua derivada temporal ṗ(t) que representa a taxa de variação das variáveis de estado.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar variáveis de estado em sistemas dinâmicos",
                            "description": "Dado um sistema descrito por equações diferenciais ordinárias, selecionar o conjunto mínimo de variáveis independentes que formam o vetor de estado x(t), garantindo que o sistema seja completamente observável e controlável a partir delas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Representação em Espaço de Estado",
                                  "subSteps": [
                                    "Estude a definição de vetor de estado: conjunto mínimo de variáveis que descrevem completamente o estado futuro do sistema.",
                                    "Revise a forma canônica: \\dot{x}(t) = A x(t) + B u(t), y(t) = C x(t) + D u(t).",
                                    "Analise exemplos simples de sistemas de primeira e segunda ordem.",
                                    "Identifique a relação entre ordem das EDOs e dimensão do vetor de estado.",
                                    "Pratique convertendo EDOs escalares em forma vetorial."
                                  ],
                                  "verification": "Explique em suas palavras o papel do vetor de estado e forneça um exemplo de sistema de 2ª ordem.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre modelagem em espaço de estado",
                                    "Livro 'Control Systems Engineering' de Nise (cap. 3)",
                                    "Vídeo tutorial sobre espaço de estado no YouTube"
                                  ],
                                  "tips": "Sempre pergunte: 'Essas variáveis capturam toda a memória do sistema?'",
                                  "learningObjective": "Compreender o conceito teórico de vetor de estado e sua representação matricial.",
                                  "commonMistakes": [
                                    "Confundir variáveis de estado com variáveis de entrada ou saída",
                                    "Ignorar a derivada temporal nas EDOs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Equações Diferenciais para Identificar Candidatos a Estados",
                                  "subSteps": [
                                    "Escreva todas as EDOs do sistema fornecidas.",
                                    "Identifique variáveis dependentes cuja derivada aparece nas equações.",
                                    "Selecione variáveis independentes que não dependam de derivadas de outras (estados iniciais).",
                                    "Forme o vetor candidato x(t) com essas variáveis.",
                                    "Expresse todas as derivadas \\dot{x_i} em termos de x, u e parâmetros."
                                  ],
                                  "verification": "Construa o vetor x(t) candidato e escreva as equações \\dot{x} = f(x, u).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta para derivações",
                                    "Software MATLAB/Simulink para prototipagem",
                                    "Exemplos de EDOs de sistemas aeronáuticos"
                                  ],
                                  "tips": "Comece pelas EDOs de maior ordem e reduza recursivamente.",
                                  "learningObjective": "Extrair variáveis de estado diretamente das EDOs originais.",
                                  "commonMistakes": [
                                    "Incluir variáveis redundantes",
                                    "Esquecer dependências não lineares iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Minimalidade do Conjunto de Estados",
                                  "subSteps": [
                                    "Confirme que o vetor x(t) tem dimensão igual à ordem total do sistema.",
                                    "Elimine variáveis desnecessárias testando linear independência.",
                                    "Reescreva o modelo em forma linearizada se aplicável: \\dot{x} = A x + B u.",
                                    "Calcule o rank da matriz de estado para validar.",
                                    "Teste se o estado futuro é unicamente determinado pelo atual e entradas."
                                  ],
                                  "verification": "Demonstre que adicionar/remover variáveis quebra a descrição completa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB para rank",
                                    "Folhas de exercícios com sistemas de ordens variadas"
                                  ],
                                  "tips": "Use o critério: 'O sistema deve ser resolvível unicamente a partir de x(0) e u(t).'",
                                  "learningObjective": "Garantir que o vetor de estado seja mínimo e suficiente.",
                                  "commonMistakes": [
                                    "Sobredimensionar x(t) com variáveis auxiliares",
                                    "Não linearizar adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Observabilidade e Controlabilidade",
                                  "subSteps": [
                                    "Construa as matrizes A, B, C (assumindo saídas y conhecidas).",
                                    "Calcule a matriz de controllability: [B, AB, A²B, ..., A^{n-1}B] e verifique rank n.",
                                    "Calcule a matriz de observability: [C; CA; CA²; ...; CA^{n-1}] e verifique rank n.",
                                    "Interprete resultados: full rank significa controlável/observável.",
                                    "Ajuste x(t) se necessário para satisfazer as condições."
                                  ],
                                  "verification": "Forneça as matrizes de controllability e observability com seus ranks.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB script para computar ranks",
                                    "Tabela de propriedades de sistemas lineares"
                                  ],
                                  "tips": "Para sistemas SISO, verifique determinante não zero dos testes de Kalman.",
                                  "learningObjective": "Validar que o vetor de estado permite controle e observação completos.",
                                  "commonMistakes": [
                                    "Confundir controllability com observability",
                                    "Erro em potências de matrizes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um modelo simplificado de dinâmica longitudinal de uma aeronave: equações para velocidade u e ângulo de ataque α: \\dot{u} = -g θ - (ρ V S C_D / (2m)) u + ..., \\dot{α} = (ρ V S C_L / (2m V)) α - q + δ_e / τ. Variáveis de estado: x(t) = [u, α, θ]^T (mínimo para capturar dinâmica, observável via sensores IMU e controlável via elevador δ_e).",
                              "finalVerifications": [
                                "O vetor x(t) tem dimensão igual à ordem das EDOs.",
                                "Equações \\dot{x} = A x + B u e y = C x são completamente definidas.",
                                "Matriz de controllability tem rank full (n).",
                                "Matriz de observability tem rank full (n).",
                                "Simulação inicial com x(0) e u(t) reproduz trajetórias corretas.",
                                "Nenhuma variável adicional é necessária para prever o futuro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do vetor mínimo x(t) (100% match com solução ótima).",
                                "Correção das matrizes A, B, C derivadas (verificação algébrica).",
                                "Cálculo correto de ranks de controllability/observability (>95% accuracy).",
                                "Explicação clara da minimalidade e propriedades (rubrica qualitativa).",
                                "Aplicação bem-sucedida no exemplo prático.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de EDOs e álgebra linear (autovalores para estabilidade).",
                                "Física: Dinâmica newtoniana em sistemas mecânicos aeronáuticos.",
                                "Computação: Simulação em MATLAB/Simulink para validação numérica.",
                                "Engenharia de Controle: Projeto de LQR ou observadores Kalman.",
                                "Engenharia Aeronáutica: Modelagem de dinâmica de voo e flutter."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, identificar corretamente o vetor de estado em modelos de dinâmica de voo permite projetar sistemas de controle autônomo (fly-by-wire) para estabilidade e manobrabilidade, como no autopilot do Boeing 787, evitando instabilidades catastróficas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Escrever a derivada temporal do vetor de estado",
                            "description": "Derivar a expressão matemática para ṗ(t) = dx/dt a partir das equações diferenciais do sistema físico, como em sistemas mecânicos (posição e velocidade) ou elétricos (corrente e tensão).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de vetor de estado e sua derivada temporal",
                                  "subSteps": [
                                    "Defina o vetor de estado x(t) como um vetor coluna contendo todas as variáveis independentes necessárias para descrever o sistema dinâmico.",
                                    "Explique que a derivada temporal ẋ(t) = dx/dt representa a taxa de variação do vetor de estado ao longo do tempo.",
                                    "Revise exemplos simples: em mecânica, x = [posição; velocidade]; em elétricos, x = [carga; corrente].",
                                    "Identifique que ẋ(t) = f(x(t), u(t), t), onde u(t) é a entrada.",
                                    "Anote a importância para sistemas lineares invariantes no tempo: ẋ = Ax + Bu."
                                  ],
                                  "verification": "Escreva definições corretas em um papel e compare com referências do livro-texto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas Dinâmicos",
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar como x(t) evolui para ẋ(t).",
                                  "learningObjective": "Entender a relação fundamental entre estado e sua derivada em sistemas dinâmicos.",
                                  "commonMistakes": "Confundir vetor de estado com vetor de saída; ignorar dependência de entradas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar variáveis de estado a partir das equações diferenciais do sistema físico",
                                  "subSteps": [
                                    "Analise o sistema físico (ex: mecânico ou elétrico) e liste todas as equações diferenciais de ordem n.",
                                    "Escolha variáveis de estado como a menor quantidade de funções e suas derivadas que descrevam o sistema (minimalidade).",
                                    "Para sistemas mecânicos: posição e velocidade; para elétricos: tensão no capacitor e corrente no indutor.",
                                    "Forme o vetor x(t) = [x1(t); x2(t); ...; xn(t)] com essas variáveis.",
                                    "Verifique se as equações podem ser expressas apenas em termos de x e suas derivadas."
                                  ],
                                  "verification": "Liste 2-3 variáveis de estado para um sistema dado e confirme que capturam toda a dinâmica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de sistemas físicos do contexto aeronáutico",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Comece com sistemas de 2ª ordem para praticar; evite variáveis redundantes.",
                                  "learningObjective": "Selecionar corretamente variáveis de estado para representação no espaço de estados.",
                                  "commonMistakes": "Escolher variáveis dependentes, levando a singularidades na matriz Jacobiana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as componentes de ẋ(t) a partir das equações diferenciais",
                                  "subSteps": [
                                    "Para cada xi(t), escreva dxi/dt expresso em termos de x1, x2, ..., xn e u(t).",
                                    "Substitua derivadas mais altas por outras variáveis de estado (ex: aceleração = ẋ2).",
                                    "Agrupe termos lineares em x para formar Ax e em u para Bu.",
                                    "Escreva ẋ(t) como um vetor coluna com cada linha correspondendo a ẋi.",
                                    "Simplifique expressões algébricas e verifique unidades físicas."
                                  ],
                                  "verification": "Derive ẋ para um sistema simples e confira dimensionalmente (unidades de velocidade para posição).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB para verificação",
                                    "Folhas de exercícios"
                                  ],
                                  "tips": "Trabalhe componente por componente; use substituição sucessiva.",
                                  "learningObjective": "Transformar equações diferenciais em forma de vetor de derivada temporal.",
                                  "commonMistakes": "Esquecer termos de entrada u(t) ou sinais negativos em amortecimento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a representação matricial e validar a derivada temporal",
                                  "subSteps": [
                                    "Construa a matriz A identificando coeficientes de cada xj em ẋi (Aij).",
                                    "Construa a matriz B para entradas (coluna com coeficientes de u).",
                                    "Escreva a equação completa ẋ(t) = A x(t) + B u(t).",
                                    "Simule numericamente um passo inicial para verificar estabilidade.",
                                    "Compare com soluções analíticas conhecidas do sistema."
                                  ],
                                  "verification": "Gere a matriz A e B para o exemplo e resolva ẋ em t=0 com valores iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Tabela de sistemas padrão"
                                  ],
                                  "tips": "Use a estrutura canônica (Companion form) se possível para validação.",
                                  "learningObjective": "Finalizar a forma matricial padrão da derivada temporal do vetor de estado.",
                                  "commonMistakes": "Erros de sinal na matriz A; dimensões incorretas de A (deve ser n x n)."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor (modelo de suspensão aeronáutica): m ÿ + c ẏ + k y = u(t). Escolha x1 = y (posição), x2 = ẏ (velocidade). Então ẋ1 = x2; ẋ2 = -(k/m)x1 - (c/m)x2 + (1/m)u. Matriz A = [0 1; -k/m -c/m], B = [0; 1/m].",
                              "finalVerifications": [
                                "A derivada ẋ(t) tem o mesmo número de componentes que x(t).",
                                "Todas as componentes de ẋ são funções apenas de x e u, sem derivadas externas.",
                                "Unidades físicas são consistentes (ex: m/s para velocidade).",
                                "Simulação inicial em software reproduz comportamento esperado.",
                                "Matriz A captura os polos do sistema (verificar autovalores)."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de cada componente de ẋ(t) (sem erros de cálculo).",
                                "Correta identificação de variáveis de estado mínimas e independentes.",
                                "Representação matricial A e B com coeficientes exatos.",
                                "Validação dimensional e física da equação final.",
                                "Capacidade de aplicar a sistemas de diferentes domínios (mecânico/elétrico).",
                                "Clareza na explicação oral ou escrita do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações diferenciais lineares.",
                                "Física: Leis de Newton e Kirchhoff para modelagem.",
                                "Engenharia de Controle: Preparação para análise de estabilidade e simulação.",
                                "Programação: Implementação em MATLAB para simulação de ẋ = Ax + Bu."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, usada para modelar dinâmica de voo (equações de atitude e velocidade angular), permitindo design de controladores para estabilidade de aeronaves ou drones, como no autopilot de aviões comerciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Interpretar propriedades do vetor de estado",
                            "description": "Explicar como o vetor de estado captura a memória do sistema, permitindo prever o comportamento futuro a partir de condições iniciais x(t0), independentemente do passado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição e propriedades básicas do vetor de estado",
                                  "subSteps": [
                                    "Revise a equação de estado contínua: dx/dt = Ax + Bu.",
                                    "Identifique o vetor x(t) como o conjunto de variáveis que descrevem completamente o estado do sistema.",
                                    "Liste propriedades chave: minimalidade, linearidade e dimensionalidade.",
                                    "Compare com representação em espaço de frequência (Laplace).",
                                    "Desenhe um diagrama esquemático de um sistema de 2ª ordem."
                                  ],
                                  "verification": "Resuma em uma frase o que é o vetor de estado e liste 3 propriedades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas Dinâmicos",
                                    "Folha de papel e caneta",
                                    "Videoaula sobre espaço de estados"
                                  ],
                                  "tips": "Use analogias como 'snapshot' do sistema para fixar o conceito.",
                                  "learningObjective": "Definir o vetor de estado e suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir vetor de estado com vetor de entrada u(t)",
                                    "Ignorar a dimensionalidade mínima do vetor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender como o vetor de estado captura a memória do sistema",
                                  "subSteps": [
                                    "Explique que o estado atual contém toda a informação necessária do histórico.",
                                    "Analise um exemplo simples: oscilador harmônico massa-mola, onde x = [posição, velocidade].",
                                    "Simule mentalmente: sem estado inicial correto, o futuro é imprevisível.",
                                    "Discuta o conceito de 'história finita' vs. dependência infinita do passado.",
                                    "Registre em tabela: passado → estado → futuro."
                                  ],
                                  "verification": "Descreva por que o vetor x(t0) 'lembra' o sistema sem precisar do histórico completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy)",
                                    "Exemplo de oscilador harmônico"
                                  ],
                                  "tips": "Pense no estado como o 'DNA' do sistema dinâmico.",
                                  "learningObjective": "Explicar o papel do vetor de estado como repositório de memória.",
                                  "commonMistakes": [
                                    "Achar que entradas passadas são sempre necessárias",
                                    "Não diferenciar memória de estado de memória em redes neurais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a previsão do comportamento futuro a partir de condições iniciais",
                                  "subSteps": [
                                    "Derive a solução da equação de estado: x(t) = e^{A(t-t0)} x(t0) + integral de entradas.",
                                    "Mostre que x(t0) determina unicamente o futuro para entradas conhecidas.",
                                    "Implemente uma simulação numérica simples de um sistema.",
                                    "Varie x(t0) e observe impactos no traço temporal.",
                                    "Compare curvas com diferentes condições iniciais."
                                  ],
                                  "verification": "Plote e interprete duas trajetórias com x(t0) diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Octave",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use a matriz exponencial para visualizar propagação.",
                                  "learningObjective": "Demonstrar como x(t0) permite previsão determinística.",
                                  "commonMistakes": [
                                    "Esquecer o termo de entrada na solução",
                                    "Confundir previsão com estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a independência do passado além de t0",
                                  "subSteps": [
                                    "Estude a propriedade de Markov: futuro depende só do presente e entradas futuras.",
                                    "Prove para um sistema linear: solução ignora u(τ) para τ < t0.",
                                    "Aplique a um contexto aeronáutico: modelo de atitude de aeronave.",
                                    "Discuta implicações para simulações e controle preditivo.",
                                    "Resolva exercício: dado histórico, ignore-o e preveja com x(t0)."
                                  ],
                                  "verification": "Explique e demonstre com equação por que o passado pré-t0 é irrelevante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios de livro-texto",
                                    "Modelo de aeronave simples (equações lineares)"
                                  ],
                                  "tips": "Lembre: 'O passado é prólogo, mas o estado é o agora'.",
                                  "learningObjective": "Compreender a independência histórica via propriedade de Markov.",
                                  "commonMistakes": [
                                    "Incluir entradas passadas na previsão",
                                    "Aplicar só a sistemas lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de controle de altitude de uma aeronave, o vetor de estado x = [velocidade vertical, taxa de descida] captura a 'memória' dinâmica. Com x(t0) = [0, 0], aplicando thrust constante, prevê-se ascensão estável; alterando x(t0) para [-10 m/s, 0], simula-se recuperação de perda de altitude, ignorando histórico de voo prévio.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de memória do vetor de estado em 1 minuto.",
                                "Resolver um problema: dado A, B e x(t0), esboçar x(t) qualitativamente.",
                                "Simular em software e interpretar independência do passado.",
                                "Diferenciar vetor de estado de outros vetores (entrada/saída).",
                                "Aplicar conceito a um sistema aeronáutico real.",
                                "Listar 3 consequências de um x(t0) incorreto em simulações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e propriedades do vetor de estado (30%).",
                                "Clareza na explicação de captura de memória e Markov (25%).",
                                "Capacidade de previsão via condições iniciais em exemplos (20%).",
                                "Uso correto de simulações e derivações matemáticas (15%).",
                                "Conexões com aplicações práticas em aeronáutica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: matrizes exponenciais e autovalores.",
                                "Física: dinâmica newtoniana e conservação de energia.",
                                "Programação: simulações numéricas em Python/MATLAB.",
                                "Engenharia de Controle: observabilidade e controlabilidade.",
                                "Computação Científica: métodos de integração ODE."
                              ],
                              "realWorldApplication": "No design de sistemas de controle fly-by-wire em aeronaves, o vetor de estado modela variáveis como ângulo de ataque e velocidade angular, permitindo previsões precisas de manobras a partir do estado atual, essencial para autopilotos e recuperação de falhas, independentemente de histórico de voo remoto."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Equação de Estado Linear Contínua",
                        "description": "Representação matricial da dinâmica do sistema na forma ṗ(t) = A x(t) + B u(t), onde A é a matriz de sistema e B a matriz de entrada, para sistemas lineares invariantes no tempo (LTI).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Derivar a matriz A a partir de equações diferenciais",
                            "description": "Converter um conjunto de equações diferenciais lineares acopladas em uma equação matricial ṗ = A x, identificando coeficientes físicos como constantes de amortecimento ou rigidez em sistemas mecânicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular as equações diferenciais do sistema físico",
                                  "subSteps": [
                                    "Analise o sistema mecânico (ex.: massas-spring-damper) e identifique variáveis de estado (posições, velocidades).",
                                    "Escreva as equações de Newton para cada grau de liberdade, incluindo forças de mola, amortecimento e inércia.",
                                    "Expresse as equações em termos de derivadas de segunda ordem ou mistas.",
                                    "Substitua coeficientes físicos: k (rigidez), c (amortecimento), m (massa).",
                                    "Verifique consistência dimensional das equações."
                                  ],
                                  "verification": "As equações estão balanceadas e refletem corretamente as leis físicas do sistema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama do sistema físico",
                                    "Folha de papel ou software de edição (ex.: LaTeX, MATLAB)",
                                    "Tabela de parâmetros físicos (m, k, c)"
                                  ],
                                  "tips": "Comece pelo diagrama livre-corpo para evitar erros de sinal nas forças.",
                                  "learningObjective": "Formular EDOs acopladas a partir de princípios físicos fundamentais.",
                                  "commonMistakes": [
                                    "Esquecer forças de reação entre componentes acoplados",
                                    "Inverter sinais de amortecimento ou rigidez",
                                    "Não considerar todas as variáveis de estado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter equações de segunda ordem para forma de primeira ordem",
                                  "subSteps": [
                                    "Defina o vetor de estado x = [x1, x2, ẋ1, ẋ2]^T para um sistema de 2 DOF.",
                                    "Expresse as derivadas primeiras: ẋ1 = v1, ẋ2 = v2 (onde v são velocidades).",
                                    "Para acelerações: expresse ẋ̇1 e ẋ̇2 em termos lineares de x1, x2, v1, v2.",
                                    "Reescreva todas as EDOs como ẋ_i = soma de coeficientes * x_j.",
                                    "Confirme que o sistema está na forma ẋ = f(x), linear."
                                  ],
                                  "verification": "Cada equação tem derivada de primeira ordem igual a combinação linear das variáveis de estado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Equações do Step 1",
                                    "Calculadora ou software simbólico (ex.: SymPy, Mathematica)"
                                  ],
                                  "tips": "Use velocidades como estados auxiliares para reduzir ordem.",
                                  "learningObjective": "Transformar EDOs de ordem superior em sistema de primeira ordem.",
                                  "commonMistakes": [
                                    "Definir vetor de estado incorreto (ex.: só posições)",
                                    "Não linearizar termos não-lineares se presentes",
                                    "Erros em substituições algébricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e preencher a matriz A",
                                  "subSteps": [
                                    "Crie uma matriz A vazia de tamanho n x n (n = número de estados).",
                                    "Para cada linha i de ẋ_i = ..., identifique coeficientes de cada x_j e preencha A[i,j].",
                                    "Agrupe coeficientes físicos: amortecimento em linhas de velocidades, rigidez em linhas de acelerações.",
                                    "Escreva explicitamente A em termos de m, c, k.",
                                    "Simplifique frações e verifique simetria se aplicável."
                                  ],
                                  "verification": "Multiplicando A x resulta nas expressões exatas de ẋ do Step 2.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Vetor x e ẋ do Step 2",
                                    "Matriz em branco (papel ou Excel/MATLAB)"
                                  ],
                                  "tips": "Padronize o vetor de estado como [posições; velocidades] para A em bloco.",
                                  "learningObjective": "Extrair coeficientes matriciais de expressões lineares.",
                                  "commonMistakes": [
                                    "Índices errados na matriz (linhas vs colunas)",
                                    "Dividir incorretamente por massas",
                                    "Ignorar termos de acoplamento entre massas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, interpretar e validar a matriz A",
                                  "subSteps": [
                                    "Multiplique A x manualmente ou numericamente e compare com ẋ original.",
                                    "Analise entradas: diagonais de amortecimento negativos, off-diagonais de acoplamento.",
                                    "Discuta estabilidade (autovalores negativos para amortecido).",
                                    "Teste com valores numéricos específicos do sistema.",
                                    "Documente interpretações físicas das entradas de A."
                                  ],
                                  "verification": "Simulação ou multiplicação matricial reproduz as EDOs originais sem discrepâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A completa",
                                    "Software numérico (MATLAB, Python NumPy)"
                                  ],
                                  "tips": "Use propriedades como trace(A) = soma de pólos para validação rápida.",
                                  "learningObjective": "Interpretar matriz A fisicamente e validar numericamente.",
                                  "commonMistakes": [
                                    "Não verificar multiplicação A x",
                                    "Interpretar coeficientes sem sinal físico",
                                    "Ignorar normalização por massa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de duas massas m1=m2=1 kg conectadas por molas k1=1 N/m (parede-m1), k2=2 N/m (m1-m2), k3=1 N/m (m2-parede) e amortecedores c1=c2=0.5 Ns/m: Escreva EDOs m1ẍ1 = -k1 x1 -k2(x1-x2) -c1 ẋ1 -c2(ẋ1-ẋ2), similar para m2. Converta para x=[x1,x2,ẋ1,ẋ2]^T, derive A = [[0,0,1,0]; [0,0,0,1]; [-3,-(-2),-1.5,0.5]; [2,-3,0.5,-1]] (após divisões por m).",
                              "finalVerifications": [
                                "Matriz A tem dimensões n x n onde n=2*DOF.",
                                "A x reproduz exatamente as derivadas de estado.",
                                "Coeficientes físicos (k/m, c/m) aparecem corretamente com sinais.",
                                "Sistema é linear e invariante no tempo.",
                                "Autovalores indicam comportamento esperado (oscilatório amortecido).",
                                "Validação numérica com valores específicos converge."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação inicial das EDOs físicas (90% correto).",
                                "Correta definição e ordenação do vetor de estado.",
                                "Matriz A sem erros algébricos ou de sinal (verificação por multiplicação).",
                                "Interpretação física adequada dos elementos de A.",
                                "Validação numérica ou analítica completa.",
                                "Clareza na documentação e passos intermediários."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Leis de Newton e energia potencial/cinética.",
                                "Álgebra Linear: Estrutura de matrizes e autovalores para estabilidade.",
                                "Controle Automático: Uso de A em controladores state-space.",
                                "Programação Numérica: Simulação em MATLAB/Simulink de dinâmica.",
                                "Engenharia Mecânica: Análise modal de vibrações."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, derivação de A modela vibrações flutter em asas de aeronaves, permitindo análise de estabilidade e design de dampers para evitar falhas catastróficas como no caso histórico do Tacoma Narrows Bridge adaptado a aeroelasticidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Construir a matriz de entrada B",
                            "description": "Determinar a matriz B que relaciona as entradas u(t) (forças, tensões) às derivadas dos estados, considerando pontos de aplicação das entradas em diagramas de blocos ou modelos físicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar estados, entradas e pontos de aplicação",
                                  "subSteps": [
                                    "Liste todos os estados do sistema (ex.: posição, velocidade, ângulos em modelos aeronáuticos).",
                                    "Identifique as entradas u(t), como forças, tensões ou momentos (ex.: empuxo, controle de superfície).",
                                    "Marque os pontos de aplicação das entradas no diagrama de blocos ou modelo físico.",
                                    "Determine as dimensões: n estados (linhas de B) e m entradas (colunas de B).",
                                    "Anote relações físicas iniciais entre entradas e estados."
                                  ],
                                  "verification": "Verifique se lista de estados e entradas está completa e dimensões de B são n x m.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de blocos do sistema, papel e lápis, software de modelagem como Simulink.",
                                  "tips": "Use convenções padrão: estados em vetor coluna x, entradas em u.",
                                  "learningObjective": "Compreender a estrutura do espaço de estados e papéis de x e u.",
                                  "commonMistakes": "Confundir estados com saídas ou ignorar múltiplas entradas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar equações diferenciais lineares focando nas entradas",
                                  "subSteps": [
                                    "Escreva as equações de movimento não-lineares se aplicável e linearize ao redor do ponto de equilíbrio.",
                                    "Expresse cada derivada de estado dx_i/dt em termos de estados e entradas.",
                                    "Isole os termos que envolvem u_j(t) para cada entrada j.",
                                    "Considere massas, inertias ou coeficientes físicos nos pontos de aplicação.",
                                    "Garanta linearidade: ignore produtos u*x ou u^2."
                                  ],
                                  "verification": "Equações mostram dx/dt = f(x) + g(u), onde g(u) é linear em u.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Equações físicas do modelo (ex.: Newton-Euler para aeronaves), calculadora.",
                                  "tips": "Para aero: use forças aerodinâmicas como C_L * q * S * delta_e para entrada de elevador.",
                                  "learningObjective": "Aplicar leis físicas para expressar impactos das entradas nas dinâmicas.",
                                  "commonMistakes": "Esquecer fatores de escala como 1/massa ou atrasos em pontos de aplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a matriz B a partir dos coeficientes das entradas",
                                  "subSteps": [
                                    "Para cada linha i (estado i) e coluna j (entrada j), extraia o coeficiente multiplicando u_j em dx_i/dt.",
                                    "Preencha B_{i,j} = coeficiente de u_j em dx_i/dt.",
                                    "Se entrada não afeta estado diretamente, B_{i,j} = 0.",
                                    "Escreva B em forma matricial compacta.",
                                    "Confira simetria ou propriedades físicas (ex.: B coluna única para uma entrada)."
                                  ],
                                  "verification": "Multiplicar B * u deve reproduzir exatamente os termos de entrada nas equações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha com equações derivadas, MATLAB ou Python para matriz simbólica.",
                                  "tips": "Use notação: coluna j de B é resposta em x' à entrada unitária u_j com x=0.",
                                  "learningObjective": "Mapear coeficientes escalares para estrutura matricial.",
                                  "commonMistakes": "Inverter linhas/colunas ou usar coeficientes errados de linearização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar a matriz B",
                                  "subSteps": [
                                    "Substitua B nas equações completas x' = A x + B u e compare com originais.",
                                    "Teste com u constante: integre numericamente e cheque consistência física.",
                                    "Analise ranks ou nulidades se múltiplas entradas.",
                                    "Compare com diagramas de blocos: ganhos de entrada devem coincidir.",
                                    "Documente suposições (ex.: ponto de linearização)."
                                  ],
                                  "verification": "Simulação com MATLAB ode45 reproduz comportamento esperado para u teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB/Simulink ou Python (scipy.integrate), valores numéricos do sistema.",
                                  "tips": "Teste u = [1;0;...] para isolar colunas de B.",
                                  "learningObjective": "Garantir corretude e robustez da modelagem.",
                                  "commonMistakes": "Ignorar unidades inconsistentes ou erros de sinal em forças."
                                }
                              ],
                              "practicalExample": "Em um modelo longitudinal simplificado de aeronave: estados [u, alpha, q, theta], entrada u = delta_e (deflexão elevador). B tem elementos como B(2,1) = coeficiente aerodinâmico C_{alpha,delta_e} * (q_bar * S / m) para impacto em alpha-dot.",
                              "finalVerifications": [
                                "Dimensões de B são n x m corretas.",
                                "B * u_step reproduz termos de entrada nas equações originais.",
                                "Simulação numérica com B coincide com solução analítica para u constante.",
                                "Colunas de B refletem pontos físicos de aplicação (zeros onde não há influência).",
                                "Unidades de B são consistentes (ex.: m/s^2 por unidade de u).",
                                "Linearização é válida no regime operacional (ex.: aero supersônica)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de coeficientes físicos (90% match com equações).",
                                "Correta estrutura matricial sem erros dimensionais.",
                                "Validação via substituição e simulação bem-sucedida.",
                                "Explicação clara de origens físicas de cada elemento não-zero.",
                                "Tratamento adequado de múltiplas entradas ou redundâncias.",
                                "Documentação completa com suposições e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Newton-Euler para dinâmicas de corpos rígidos.",
                                "Matemática: Álgebra linear e linearização de sistemas não-lineares.",
                                "Controle Automático: Preparação para controllability via rank([B AB ...]).",
                                "Engenharia Mecânica: Modelagem de vibrações com forças externas.",
                                "Programação: Implementação em MATLAB/Stateflow para simulação."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, a matriz B modela como comandos de piloto (entradas em superfícies de controle) afetam velocidades e atitudes, essencial para sintetizar leis de controle estável em fly-by-wire systems como no Boeing 787."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Verificar consistência da representação",
                            "description": "Validar se a forma ṗ = A x + B u preserva a dimensionalidade e linearidade do sistema original, comparando com soluções analíticas para casos simples como osciladores harmônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o sistema dinâmico original e sua solução analítica",
                                  "subSteps": [
                                    "Identifique a equação diferencial do sistema original, como o oscilador harmônico: m ÿ + c ẏ + k y = u.",
                                    "Derive ou recorde a solução analítica exata para condições iniciais dadas e entrada u(t).",
                                    "Calcule manualmente trajetórias para casos simples (ex: u=0, condições iniciais não nulas).",
                                    "Verifique unidades e dimensionalidade das variáveis (posição, velocidade, tempo).",
                                    "Documente propriedades lineares do sistema (superposição, homogeneidade)."
                                  ],
                                  "verification": "Confirme que a solução analítica satisfaz a equação diferencial diferenciando e substituindo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software simbólico como SymPy/MATLAB Symbolic Toolbox.",
                                  "tips": "Use soluções padrão para oscilador: y(t) = e^(-ζω t) (A cos(ω_d t) + B sin(ω_d t)).",
                                  "learningObjective": "Compreender o comportamento dinâmico do sistema original.",
                                  "commonMistakes": "Ignorar amortecimento ou confundir frequência natural com amortecida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a representação em espaço de estado",
                                  "subSteps": [
                                    "Defina o vetor de estado x = [y; ẏ] para o oscilador harmônico.",
                                    "Escreva as equações: ẋ₁ = x₂; ẋ₂ = (-k/m) x₁ - (c/m) x₂ + (1/m) u.",
                                    "Forme as matrizes A = [[0,1]; [-k/m, -c/m]] e B = [[0]; [1/m]].",
                                    "Verifique se o número de estados corresponde à ordem da equação diferencial.",
                                    "Expresse saídas se necessário (C x + D u)."
                                  ],
                                  "verification": "Substitua valores numéricos em A e B e confirme que derivadas coincidem com equações originais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora matricial ou MATLAB/Python (NumPy).",
                                  "tips": "Padronize estado como [posição; velocidade] para sistemas mecânicos.",
                                  "learningObjective": "Converter corretamente equações diferenciais em forma ẋ = A x + B u.",
                                  "commonMistakes": "Erro de sinal nas matrizes A ou inversão de estados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar preservação de dimensionalidade e linearidade",
                                  "subSteps": [
                                    "Confira dimensões: dim(x) = ordem do sistema, dim(A)=n×n, dim(B)=n×m.",
                                    "Teste linearidade: verifique se ẋ(α x1 + β x2) = α ẋ1 + β ẋ2 e similar para u.",
                                    "Analise autovalores de A para confirmar pólos do sistema original.",
                                    "Verifique consistência de unidades em A (1/tempo), B (adequado).",
                                    "Simule numericamente passos iniciais e compare com analítico."
                                  ],
                                  "verification": "Dimensões batem e autovalores de A igualam raízes características originais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de álgebra linear (MATLAB eig() ou Python scipy.linalg.eig).",
                                  "tips": "Raízes características do oscilador: soluções de s² + (c/m)s + k/m = 0.",
                                  "learningObjective": "Garantir que a representação mantém propriedades intrínsecas do sistema.",
                                  "commonMistakes": "Confundir dimensionalidade de estado com ordem do sistema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções analíticas e numéricas da representação",
                                  "subSteps": [
                                    "Integre numericamente ẋ = A x + B u usando método como Runge-Kutta (ode45 em MATLAB).",
                                    "Compare trajetórias x(t) numérica vs. analítica para múltiplos t.",
                                    "Calcule erro: ||x_num(t) - x_anal(t)|| < tolerância (ex: 1e-6).",
                                    "Teste para diferentes entradas u(t) (degrau, impulso).",
                                    "Gere gráficos de sobreposição para visualização."
                                  ],
                                  "verification": "Erros abaixo de 1% em toda trajetória e gráficos coincidem visualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB/Simulink, Python (scipy.integrate.odeint + matplotlib).",
                                  "tips": "Use condições iniciais pequenas para evitar saturação numérica.",
                                  "learningObjective": "Validar fidelidade da representação via simulação.",
                                  "commonMistakes": "Passo de tempo grande causando erro de integração."
                                }
                              ],
                              "practicalExample": "Para um oscilador harmônico com m=1 kg, k=1 N/m, c=0 (não amortecido), u=0, x0=[1;0]. Solução analítica: y(t)=cos(t). Espaço de estado: A=[[0,1];[-1,0]], solução numérica deve coincidir exatamente.",
                              "finalVerifications": [
                                "Dimensões de A (n×n), B (n×1) corretas.",
                                "Autovalores de A igualam raízes da equação característica.",
                                "Trajetórias numéricas e analíticas coincidem com erro <1e-6.",
                                "Linearidade preservada em testes de superposição.",
                                "Unidades consistentes em todas matrizes.",
                                "Gráficos de fase idênticos."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação de A e B (100% match com padrão).",
                                "Precisão da análise dimensional (todas verificadas).",
                                "Qualidade da comparação (erro quantificado e gráficos).",
                                "Identificação correta de linearidade.",
                                "Documentação clara de passos e resultados.",
                                "Tratamento de casos edge (u≠0)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e diagonalização de A.",
                                "Física: dinâmica de sistemas mecânicos.",
                                "Programação: simulação numérica com ODE solvers.",
                                "Controle Automático: validade de modelos para controle.",
                                "Matemática Numérica: estabilidade de integradores."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, verificar modelos de espaço de estado de asas oscilantes ou sistemas de controle de voo, garantindo que simulações predigam flutter ou estabilidade corretamente antes de testes reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Equação de Saída e Matrizes Associadas",
                        "description": "Relação entre as saídas observáveis y(t) e o estado interno via y(t) = C x(t) + U u(t), com matrizes C e D definindo observabilidade direta e alimentação direta.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Definir a matriz de saída C",
                            "description": "Construir a matriz C que mapeia o vetor de estado x(t) para as saídas y(t) desejadas, como posição em sistemas mecânicos ou tensão em circuitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo de espaço de estado e o papel da matriz C",
                                  "subSteps": [
                                    "Estude a forma geral das equações de estado contínuas: ẋ = Ax + Bu e y = Cx + Du.",
                                    "Identifique que C é a matriz de saída que linearmente combina os estados x para produzir as saídas y.",
                                    "Analise exemplos simples onde D=0 (sem alimentação direta).",
                                    "Discuta dimensões: C tem tamanho (dim(y) x dim(x)).",
                                    "Esboce um diagrama conceitual do fluxo de estado para saída."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel de C em um sistema genérico e confirme dimensões corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de sistemas dinâmicos, notas de aula, quadro branco.",
                                  "tips": "Use analogias como 'C é o filtro que seleciona quais partes do estado são observáveis'.",
                                  "learningObjective": "Compreender conceitualmente a função e estrutura da matriz C no modelo de espaço de estado.",
                                  "commonMistakes": "Confundir C com A (matriz de dinâmica) ou ignorar dimensões das variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar variáveis de estado e saídas desejadas no sistema físico",
                                  "subSteps": [
                                    "Descreva o sistema físico (ex: elevador de aeronave).",
                                    "Liste todos os estados x(t) (ex: posição, velocidade angular).",
                                    "Defina saídas y(t) relevantes (ex: posição do elevador, tensão em atuador).",
                                    "Verifique se y é diretamente mensurável a partir de x.",
                                    "Documente em tabela: estados vs. saídas."
                                  ],
                                  "verification": "Crie uma tabela que liste estados e saídas com suas unidades e relações físicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama do sistema aeronáutico, software de desenho (ex: Draw.io), calculadora.",
                                  "tips": "Priorize saídas fisicamente mensuráveis como posição ou ângulo em aeronáutica.",
                                  "learningObjective": "Mapear componentes físicos do sistema para variáveis matemáticas de estado e saída.",
                                  "commonMistakes": "Incluir saídas não lineares ou derivadas de estados não definidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz C mapeando estados para saídas",
                                  "subSteps": [
                                    "Para cada saída y_i, escreva y_i como combinação linear de estados: y_i = soma(c_{ij} * x_j).",
                                    "Preencha as linhas de C correspondentes aos coeficientes c_{ij}.",
                                    "Se y_i = x_k (saída direta), defina linha i com 1 na coluna k e 0s elsewhere.",
                                    "Para múltiplas saídas, repita para cada linha.",
                                    "Escreva a matriz C explicitamente."
                                  ],
                                  "verification": "Multiplique C * x e confirme que resulta em y esperado para um vetor x de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado, MATLAB ou Python (NumPy) para matrizes, exemplos resolvidos.",
                                  "tips": "Comece com sistemas de baixa ordem (2x2) para praticar.",
                                  "learningObjective": "Construir matematicamente a matriz C a partir de relações físicas.",
                                  "commonMistakes": "Erros de indexação (linhas/colunas trocadas) ou coeficientes incorretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a matriz C no modelo completo",
                                  "subSteps": [
                                    "Integre C no modelo completo com A e B conhecidos.",
                                    "Simule resposta a entrada unitária e verifique se y corresponde ao esperado.",
                                    "Cheque observabilidade parcial (rank de [C; CA; ...]).",
                                    "Ajuste C se necessário baseado em simulações.",
                                    "Documente o modelo final."
                                  ],
                                  "verification": "Execute simulação numérica e plote y(t) vs. comportamento físico esperado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB/Simulink ou Python (SciPy), dados de simulação de aeronave.",
                                  "tips": "Use funções como ss() no MATLAB para criar sistema de espaço de estado.",
                                  "learningObjective": "Validar a corretude da matriz C através de simulações e análise.",
                                  "commonMistakes": "Ignorar termo D ou assumir observabilidade sem checar."
                                }
                              ],
                              "practicalExample": "Em um modelo de elevador de aeronave: estados x = [ângulo de ataque α, velocidade angular q]^T. Saída desejada y = α (para sensor de ângulo). Então C = [1 0], pois y = 1*α + 0*q.",
                              "finalVerifications": [
                                "Dimensões de C são corretas: (número de saídas x número de estados).",
                                "C * x_teste produz y esperado para vetores de teste conhecidos.",
                                "Simulação do sistema com C mostra saídas fisicamente plausíveis.",
                                "Matriz C é consistente com diagrama físico do sistema.",
                                "Rank da matriz de observabilidade é máximo possível.",
                                "Nenhum coeficiente NaN ou infinito em C."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação correta do papel de C (20%).",
                                "Identificação correta de estados/saídas (25%).",
                                "Construção matemática exata de C (30%).",
                                "Validação via simulação sem erros (15%).",
                                "Documentação clara e organizada (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: multiplicação de matrizes e propriedades.",
                                "Física: dinâmica de sistemas mecânicos/aeroespaciais.",
                                "Programação: implementação em MATLAB/Python para simulações.",
                                "Controle Automático: observabilidade e projeto de observadores."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a matriz C é usada em sistemas de controle de voo (fly-by-wire) para mapear estados internos (como ângulos e velocidades) para medições de sensores (altímetro, giroscópio), permitindo simulações precisas e leis de controle estáveis em aviões comerciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Incorporar alimentação direta com matriz D",
                            "description": "Identificar e incluir a matriz D em casos onde a saída depende diretamente da entrada, como em amplificadores ou sistemas sem dinâmica nas entradas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Alimentação Direta e a Matriz D",
                                  "subSteps": [
                                    "Revise as equações de estado contínuas padrão: ẋ = Ax + Bu e y = Cx + Du.",
                                    "Explique o papel da matriz D como termo de alimentação direta da entrada u para a saída y.",
                                    "Discuta cenários onde D ≠ 0, como amplificadores ou sensores sem dinâmica.",
                                    "Compare modelos com D=0 versus D≠0 através de diagramas de bloco.",
                                    "Analise impactos na resposta em frequência e transitórios."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre modelos com e sem D, citando exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sistemas Dinâmicos (ex: Ogata), slides de aula sobre espaço de estado, software MATLAB/Simulink.",
                                  "tips": "Desenhe diagramas de bloco para visualizar o feedthrough.",
                                  "learningObjective": "Entender o significado físico e matemático da matriz D nas equações de saída.",
                                  "commonMistakes": "Confundir D com C (ganho estático vs. dependência de estado)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Quando Incluir a Matriz D",
                                  "subSteps": [
                                    "Examine o diagrama do sistema físico para dependências diretas u → y.",
                                    "Analise equações diferenciais: se y contém termos algébricos de u, D é necessária.",
                                    "Verifique especificações do sistema: amplificadores, atuadores hidráulicos em aeronaves.",
                                    "Use critérios: ausência de dinâmica nas entradas para saídas (polos em infinito).",
                                    "Pratique com 3 exemplos: um com D=0 e dois com D≠0."
                                  ],
                                  "verification": "Classifique 5 sistemas dados como requerendo D ou não, justificando cada um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de problemas de aula, papel e lápis para diagramas.",
                                  "tips": "Pergunte: 'A saída muda instantaneamente com a entrada?' Se sim, use D.",
                                  "learningObjective": "Reconhecer cenários reais onde a saída depende diretamente da entrada.",
                                  "commonMistakes": "Ignorar D em sistemas com sensores rápidos, levando a modelos imprecisos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Incorporar a Matriz D no Modelo",
                                  "subSteps": [
                                    "Derive as dimensões: D é m x r, onde m=dim(y), r=dim(u).",
                                    "Extraia coeficientes de alimentação direta das equações físicas.",
                                    "Forme a equação completa y = Cx + Du.",
                                    "Implemente em MATLAB: defina matrizes A,B,C,D.",
                                    "Simule resposta a degrau para validar feedthrough."
                                  ],
                                  "verification": "Gere código MATLAB funcional e plote y(t) mostrando efeito imediato de u.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Octave, template de script para espaço de estado.",
                                  "tips": "Use ss() no MATLAB para criar o sistema e step() para simular.",
                                  "learningObjective": "Construir matematicamente e computacionalmente modelos com D.",
                                  "commonMistakes": "Dimensões erradas de D, causando erro de matriz incompatível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Analisar o Modelo com Matriz D",
                                  "subSteps": [
                                    "Compare simulações com D versus sem D.",
                                    "Calcule ganho DC e verifique consistência física.",
                                    "Analise estabilidade e observabilidade considerando D.",
                                    "Ajuste D baseado em dados experimentais.",
                                    "Documente o modelo completo em relatório curto."
                                  ],
                                  "verification": "Produza gráficos comparativos e relatório de 1 página validando o modelo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação, dados de referência de sistemas aeronáuticos.",
                                  "tips": "Verifique lim t→∞ y(t) para ganho estático correto.",
                                  "learningObjective": "Validar a inclusão de D através de análise e simulação.",
                                  "commonMistakes": "Esquecer efeitos de D em controladores, como em LQR ou observadores."
                                }
                              ],
                              "practicalExample": "Em um amplificador de sinal em um sistema de controle de flaps de aeronave, a tensão de saída y = 10*u + 0.5*x, onde u é a tensão de entrada e x o estado interno. Aqui, D = [10] captura o ganho direto, essencial para modelar respostas rápidas sem overshoot indesejado.",
                              "finalVerifications": [
                                "O modelo simula saída instantânea para entrada degrau.",
                                "Dimensões de D são corretas (m x r).",
                                "Ganho DC do sistema corresponde ao esperado.",
                                "Simulação com D=0 difere significativamente da com D.",
                                "Equações físicas são fielmente representadas.",
                                "Código MATLAB roda sem erros e produz plots claros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de necessidade de D (30%).",
                                "Correção na construção das matrizes (25%).",
                                "Qualidade das simulações e validações (20%).",
                                "Explicação conceitual clara (15%).",
                                "Documentação e gráficos profissionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Impacto em projetadores LQG.",
                                "Eletrônica: Modelagem de amplificadores operacionais.",
                                "Processamento de Sinais: Feedthrough em filtros digitais.",
                                "Física Aplicada: Sistemas massa-mola com sensores diretos."
                              ],
                              "realWorldApplication": "Em aviões comerciais, modelar atuadores eletro-hidráulicos de superfícies de controle onde a posição y depende diretamente do comando u via D, permitindo simulações precisas de fly-by-wire para certificação FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Montar o modelo completo no espaço de estados",
                            "description": "Combinar equações de estado e saída para formar o modelo quadruplete (A, B, C, D), aplicando em exemplos de sistemas eletromecânicos ou térmicos da bibliografia (Ogata, Lathi).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações fundamentais de estado e saída",
                                  "subSteps": [
                                    "Leia as definições das equações de estado contínuas: dx/dt = Ax + Bu",
                                    "Estude a equação de saída: y = Cx + Du",
                                    "Identifique o quadruplete (A, B, C, D) como representação completa do modelo",
                                    "Consulte exemplos iniciais em Ogata (Capítulo 5) ou Lathi (Capítulo 7)",
                                    "Anote as dimensões típicas: A (n x n), B (n x m), C (p x n), D (p x m)"
                                  ],
                                  "verification": "Resuma em um parágrafo as equações e dimensões corretas sem erros conceituais",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Ogata 'Sistema de Controle Moderno'",
                                    "Livro Lathi 'Sinais e Sistemas Lineares'",
                                    "Caderno de anotações"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar as relações entre x, u e y",
                                  "learningObjective": "Compreender a estrutura matemática do modelo no espaço de estados",
                                  "commonMistakes": [
                                    "Confundir equação de estado com equação de saída",
                                    "Ignorar o termo Du na saída"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o sistema físico e identificar variáveis",
                                  "subSteps": [
                                    "Escolha um sistema da bibliografia, ex: circuito RLC série ou motor DC",
                                    "Defina variáveis de estado x (ex: correntes e tensões ou posição e velocidade)",
                                    "Identifique entradas u (ex: tensão de alimentação) e saídas y (ex: tensão de saída)",
                                    "Derive as equações diferenciais não lineares do sistema físico",
                                    "Linearize ao redor de um ponto de operação se necessário"
                                  ],
                                  "verification": "Liste x, u, y com dimensões e equações diferenciais derivadas corretamente",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de Ogata p. 250-260",
                                    "Software MATLAB para plotar equações",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Comece com sistemas de baixa ordem (1-2 estados) para prática inicial",
                                  "learningObjective": "Mapear componentes físicos para variáveis de modelagem",
                                  "commonMistakes": [
                                    "Escolher variáveis dependentes como estados independentes",
                                    "Esquecer linearização para sistemas não lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as matrizes A, B, C e D",
                                  "subSteps": [
                                    "Expresse dx/dt em forma matricial: compare coeficientes para preencher A e B",
                                    "Forme a equação de saída y = Cx + Du identificando coeficientes",
                                    "Verifique dimensões: linhas/colunas devem coincidir com ordens de x, u, y",
                                    "Escreva explicitamente cada elemento das matrizes",
                                    "Use sympy ou MATLAB para simbolicamente confirmar"
                                  ],
                                  "verification": "Matrizes montadas com todos elementos corretos e dimensões compatíveis",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Exemplos resolvidos de Lathi Capítulo 7",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Escreva as matrizes em formato LaTeX para clareza visual",
                                  "learningObjective": "Montar o quadruplete (A,B,C,D) a partir de equações diferenciais",
                                  "commonMistakes": [
                                    "Erro nos sinais dos coeficientes em A",
                                    "Dimensões incompatíveis entre matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar o modelo e simular",
                                  "subSteps": [
                                    "Implemente o modelo em MATLAB: use ss() para criar sistema de estados",
                                    "Simule resposta a degrau ou impulso e compare com solução analítica",
                                    "Verifique observabilidade e controlabilidade básicas (rank das matrizes)",
                                    "Aplique em um exemplo térmico: tanque com fluxo de calor (Ogata ex. 5-3)",
                                    "Documente discrepâncias e ajustes necessários"
                                  ],
                                  "verification": "Simulação reproduz comportamento físico esperado com erro <5%",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Bibliografia para exemplos térmicos/eletromecânicos"
                                  ],
                                  "tips": "Use step() e impulse() para validação rápida",
                                  "learningObjective": "Confirmar integridade do modelo completo via simulação",
                                  "commonMistakes": [
                                    "Não verificar singularidades nas matrizes",
                                    "Ignorar condições iniciais na simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC: estados x = [ω; i] (velocidade angular e corrente), entrada u = Va (tensão de armadura), saída y = ω. Monte A = [[-b/J, K_t/J]; [-K_e/L, -R/L]], B = [[0; 1/L]], C = [1 0], D = 0, simulando resposta a degrau em MATLAB.",
                              "finalVerifications": [
                                "Matrizes A, B, C, D possuem dimensões corretas e elementos precisos",
                                "Simulação no MATLAB coincide com solução analítica ou física esperada",
                                "Sistema é controlável (rank([B AB ...]) = n) e observável (rank([C; CA; ...]) = n)",
                                "Aplicação em pelo menos dois exemplos (eletromecânico e térmico)",
                                "Documentação completa com equações derivadas e código fonte"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das matrizes (100% dos coeficientes corretos)",
                                "Correta identificação de variáveis de estado, entrada e saída",
                                "Validação via simulação com métricas quantitativas (ex: RMSE < 0.05)",
                                "Clareza na documentação e explicação do processo",
                                "Aplicação criativa em exemplos da bibliografia",
                                "Ausência de erros dimensionais ou conceituais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Álgebra matricial e autovalores para análise de A",
                                "Física Aplicada: Dinâmica de sistemas eletromecânicos e térmicos",
                                "Controle Automático: Preparação para projetar controladores estado-espaco",
                                "Programação Numérica: Uso de MATLAB/Simulink para modelagem",
                                "Engenharia Aeronáutica: Modelagem de atuadores em aeronaves"
                              ],
                              "realWorldApplication": "Em aeronáutica, modelar o sistema de controle de flaps de uma asa: estados (ângulo, velocidade angular), entrada (tensão servo), saída (ângulo medido), permitindo simulações de estabilidade de voo e projeto de controladores PID/estado-espaco em softwares como X-Plane ou MATLAB Aerospace Toolbox."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Equações de Saída",
                    "description": "Relação algébrica entre variáveis de estado, entradas e saídas do sistema.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Forma Geral das Equações de Saída",
                        "description": "Representação algébrica padrão das equações de saída em modelos de espaço de estados para sistemas lineares invariantes no tempo (LTI), dada por y(t) = C x(t) + D u(t), onde y são as saídas, x as variáveis de estado e u as entradas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar a equação de saída em um modelo de espaço de estados",
                            "description": "Reconhecer e distinguir a equação de saída y = C x + D u das equações de estado no modelo completo de espaço de estados, identificando os componentes algébricos envolvidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do modelo de espaço de estados",
                                  "subSteps": [
                                    "Revise o modelo completo: ẋ = A x + B u e y = C x + D u",
                                    "Identifique as variáveis: x (vetor de estado), u (vetor de entrada), y (vetor de saída)",
                                    "Entenda o papel das matrizes A, B, C e D",
                                    "Diferencie equações diferenciais (estado) de algébricas (saída)",
                                    "Esboce um diagrama esquemático do modelo"
                                  ],
                                  "verification": "Escreva corretamente o modelo completo de espaço de estados a partir da memória",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Referência: Livro de Sinais e Sistemas Dinâmicos (capítulo de modelagem)"
                                  ],
                                  "tips": [
                                    "Use notação matricial padrão para evitar confusões",
                                    "Desenhe setas para fluxos de x, u e y"
                                  ],
                                  "learningObjective": "Dominar os componentes fundamentais do modelo de espaço de estados",
                                  "commonMistakes": [
                                    "Confundir vetor de estado x com saída y",
                                    "Esquecer o termo direto D u"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e diferenciar as equações do modelo",
                                  "subSteps": [
                                    "Examine a equação de estado ẋ = A x + B u e note seu caráter diferencial",
                                    "Compare com a equação de saída y = C x + D u, destacando o caráter algébrico",
                                    "Identifique que a saída y depende diretamente de x e u, sem derivadas",
                                    "Classifique os termos: C x (dependente de estado) e D u (alimentação direta)",
                                    "Pratique rotulando cada equação em um modelo dado"
                                  ],
                                  "verification": "Destaque corretamente qual equação é a de saída em um modelo escrito",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de modelos de espaço de estados impressos ou digitais",
                                    "Calculadora matricial opcional"
                                  ],
                                  "tips": [
                                    "Procure pela ausência de derivadas (pontos) para identificar saída",
                                    "Leia as equações de baixo para cima"
                                  ],
                                  "learningObjective": "Distinguir precisamente a equação de saída das de estado",
                                  "commonMistakes": [
                                    "Assumir que toda equação com y é de saída sem verificar forma",
                                    "Ignorar o termo D u como opcional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer os componentes específicos da equação de saída",
                                  "subSteps": [
                                    "Identifique a matriz C como coeficiente do vetor de estado x",
                                    "Localize a matriz D como ganho direto da entrada u para y",
                                    "Verifique a forma exata y = C x + D u em diferentes representações",
                                    "Note variações: D pode ser zero em alguns sistemas",
                                    "Extraia C e D de um modelo completo fornecido"
                                  ],
                                  "verification": "Apontar e nomear C, x, D e u na equação de saída de um exemplo",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Softwares como MATLAB ou Octave para visualização de matrizes",
                                    "Planilha com exemplos de matrizes"
                                  ],
                                  "tips": [
                                    "C tem dimensões (saídas x estados), D (saídas x entradas)",
                                    "Sempre confira dimensões para validação"
                                  ],
                                  "learningObjective": "Reconhecer os elementos algébricos y = C x + D u",
                                  "commonMistakes": [
                                    "Confundir C com A ou B",
                                    "Omitir D u achando que é sempre zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em contextos reais",
                                  "subSteps": [
                                    "Aplique em um modelo de aeronáutica simples (ex: elevador de avião)",
                                    "Identifique a equação de saída em 3 exemplos variados",
                                    "Compare modelos com e sem termo D",
                                    "Explique verbalmente a distinção para um colega",
                                    "Registre erros e corrija"
                                  ],
                                  "verification": "Identificar corretamente a equação de saída em 3 modelos independentes sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de modelos aeronáuticos (PDF ou online)",
                                    "Fórum ou parceiro para explicação"
                                  ],
                                  "tips": [
                                    "Comece com sistemas SISO (single-input single-output) para simplicidade",
                                    "Use cores para destacar y="
                                  ],
                                  "learningObjective": "Aplicar o reconhecimento de forma autônoma e consistente",
                                  "commonMistakes": [
                                    "Generalizar demais sem verificar termo direto",
                                    "Não considerar contexto do sistema"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de elevador de aeronave: ẋ = [[-0.1, 0], [0, -0.2]] x + [[1], [0.5]] u; y = [1, 0] x + [0] u. A equação de saída é y = [1 0] x + [0] u, onde C = [1 0], D = [0], representando ângulo de ataque como saída direta do estado de rotação.",
                              "finalVerifications": [
                                "Identifica y = C x + D u em qualquer modelo de espaço de estados apresentado",
                                "Explica a diferença algébrica vs. diferencial das equações",
                                "Extrai corretamente matrizes C e D",
                                "Reconhece quando D é zero ou não",
                                "Aplica em exemplos de engenharia aeronáutica sem hesitação",
                                "Distingue de outras formas de modelagem (ex: transferência)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização da equação de saída (100% correto)",
                                "Compreensão dos componentes C, x, D, u demonstrada",
                                "Capacidade de distinção clara de equações de estado",
                                "Uso correto de terminologia técnica",
                                "Aplicação consistente em exemplos variados",
                                "Explicação verbal ou escrita clara e concisa"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de matrizes C e D",
                                "Controle Automático: Uso em controladores de estado",
                                "Física Dinâmica: Modelagem de sistemas aeronáuticos",
                                "Programação: Implementação em MATLAB/Simulink",
                                "Matemática Aplicada: Análise de sistemas lineares"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, identificar a equação de saída permite monitorar variáveis como velocidade, altitude ou ângulos de ataque em sistemas de controle de voo autônomo, integrando sensores reais (u) e estados internos (x) para estabilidade e navegação precisa em aviões ou drones."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Escrever a equação de saída para sistemas SISO",
                            "description": "Formular a equação de saída para sistemas mono-entrada mono-saída (SISO), determinando as matrizes C (1xn) e D (1xm) escalares ou vetoriais a partir de descrições do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral da equação de saída para sistemas SISO",
                                  "subSteps": [
                                    "Revise as equações de estado completas: ẋ = A x + B u e y = C x + D u",
                                    "Identifique que em SISO, u é escalar (m=1), y é escalar (p=1), C é vetor linha 1xn e D é escalar 1x1",
                                    "Analise o papel de C como combinação linear dos estados x que formam a saída y",
                                    "Entenda D como o termo de alimentação direta (feedthrough) da entrada u para y",
                                    "Estude exemplos canônicos onde D=0 (sem feedthrough)"
                                  ],
                                  "verification": "Explique em voz alta ou por escrito os componentes C e D e dê um exemplo simples",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Anotações de equações de estado",
                                    "Livro-texto de Sistemas Dinâmicos (cap. Espaço de Estados)",
                                    "Video-aula sobre representações em espaço de estado"
                                  ],
                                  "tips": "Sempre escreva as dimensões das matrizes para evitar confusões",
                                  "learningObjective": "Dominar a estrutura matemática da equação de saída SISO",
                                  "commonMistakes": [
                                    "Confundir C com a matriz A de dinâmica",
                                    "Ignorar dimensões matriciais",
                                    "Assumir D sempre zero sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a descrição do sistema para identificar variáveis relevantes",
                                  "subSteps": [
                                    "Leia a descrição do sistema e liste todos os estados x1, x2, ..., xn",
                                    "Identifique a entrada u e confirme que é mono-entrada (escalar)",
                                    "Determine qual é a saída y desejada (ex: posição, tensão, velocidade)",
                                    "Mapeie quais estados contribuem diretamente para y",
                                    "Verifique se há dependência direta de u em y (feedthrough)"
                                  ],
                                  "verification": "Crie um diagrama esquemático ligando estados, entrada e saída",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do sistema impressa ou digital",
                                    "Papel e caneta para diagrama",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Use setas para mostrar dependências: estados → y via C, u → y via D",
                                  "learningObjective": "Extrair informações chave da descrição textual do sistema",
                                  "commonMistakes": [
                                    "Omitir estados não observáveis",
                                    "Confundir entrada com perturbação",
                                    "Não notar feedthrough em sistemas elétricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz C a partir dos estados e saída",
                                  "subSteps": [
                                    "Atribua coeficientes 1 aos estados que aparecem diretamente em y, 0 aos demais",
                                    "Para combinações lineares, determine os pesos (ex: y = 2x1 + 0.5x2 → C = [2, 0.5, 0, ...])",
                                    "Expresse y como combinação linear: y = ∑ ci xi",
                                    "Verifique dimensões: C deve ser 1xn onde n = dim(x)",
                                    "Teste com substituição simbólica: C x deve igualar y sem u"
                                  ],
                                  "verification": "Substitua valores numéricos de x em C x e confirme que obtém y esperada",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB/Octave",
                                    "Exemplos de sistemas SISO",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Comece com y = x1 (C=[1 0 ...]) e generalize",
                                  "learningObjective": "Formular C corretamente para qualquer combinação de estados",
                                  "commonMistakes": [
                                    "Usar colunas em vez de linha para C",
                                    "Inverter coeficientes",
                                    "Incluir u em C"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar D, escrever a equação final e validar",
                                  "subSteps": [
                                    "Verifique se y depende diretamente de u: se sim, D = coeficiente; senão D=0",
                                    "Escreva a equação completa: y = C x + D u",
                                    "Substitua em um exemplo numérico para validar",
                                    "Compare com diagrama de blocos do sistema",
                                    "Discuta casos especiais (D≠0 em sistemas com derivadas ou atrasos)"
                                  ],
                                  "verification": "Simule com valores iniciais e confirme y(t) via equação",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Simulink ou Python (control library)",
                                    "Exemplo numérico resolvido",
                                    "Gráficos de resposta ao degrau"
                                  ],
                                  "tips": "D é raro em sistemas mecânicos, comum em elétricos (ex: tensão de entrada)",
                                  "learningObjective": "Completar e validar a equação de saída SISO",
                                  "commonMistakes": [
                                    "Esquecer D em sistemas com ganho estático",
                                    "Erros de sinal em D",
                                    "Não validar dimensionalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola-amortecedor SISO: estados x = [posição y, velocidade ẏ]^T, entrada u = força F. Saída desejada: posição y. Assim, y = [1  0] x + 0 u, ou seja C = [1 0], D = 0. Se saída fosse velocidade, C = [0 1]. Para feedthrough, imagine um amplificador onde y = k u + estado interno.",
                              "finalVerifications": [
                                "Escrever corretamente C e D para 3 descrições de sistemas SISO diferentes",
                                "Validar dimensionalmente a equação y = C x + D u",
                                "Simular numéricamente e comparar y com a descrição original",
                                "Explicar o impacto de D≠0 na resposta em frequência",
                                "Identificar erros em equações dadas por pares",
                                "Construir equação a partir de diagrama de blocos SISO"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estados e saída (100%)",
                                "Correção das dimensões e coeficientes de C e D (100%)",
                                "Validação numérica ou simbólica sem erros",
                                "Clareza na escrita da equação final",
                                "Capacidade de generalizar para novos sistemas",
                                "Detecção de feedthrough corretamente",
                                "Explicação coerente dos componentes"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação vetor-matriz e combinações lineares",
                                "Física (Dinâmica): modelagem de sistemas mecânicos e elétricos",
                                "Programação: implementação em MATLAB/Simulink para simulação",
                                "Controle Automático: ligação com observabilidade",
                                "Engenharia de Software: documentação de modelos matemáticos"
                              ],
                              "realWorldApplication": "Em aeronáutica, modelar a saída de sensores (ex: altitude ou ângulo de ataque) a partir de estados internos de um controlador de voo, permitindo simulações em Simulink para estabilidade de aeronaves como o Embraer E-Jet, onde C seleciona medidas de posição/velocidade e D modela offsets diretos de atuadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Diferenciar equações de saída de equações dinâmicas",
                            "description": "Explicar a diferença entre as equações de saída (algébricas, sem derivadas) e as equações de estado (diferenciais), destacando o papel da saída como combinação linear instantânea de estados e entradas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Equações de Estado Dinâmicas",
                                  "subSteps": [
                                    "Estude a forma geral das equações de estado: dx/dt = A x + B u.",
                                    "Identifique que são diferenciais, envolvendo derivadas de estados x em relação ao tempo.",
                                    "Note que dependem de estados atuais x e entradas u, definindo a evolução temporal do sistema.",
                                    "Analise um exemplo simples: modelo de um oscilador massa-mola.",
                                    "Escreva as equações para um sistema com um estado (posição)."
                                  ],
                                  "verification": "Escreva corretamente a forma geral das equações de estado e identifique a derivada dx/dt em um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas",
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre espaço de estados"
                                  ],
                                  "tips": "Lembre-se: equações de estado descrevem 'como o sistema muda ao longo do tempo'.",
                                  "learningObjective": "Compreender a natureza diferencial das equações de estado e sua função na modelagem dinâmica.",
                                  "commonMistakes": [
                                    "Confundir estados com saídas",
                                    "Esquecer o termo de derivada dx/dt",
                                    "Ignorar dependência temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir as Equações de Saída Algébricas",
                                  "subSteps": [
                                    "Estude a forma geral: y = C x + D u.",
                                    "Observe que não há derivadas; é uma relação algébrica instantânea.",
                                    "Identifique C como matriz que combina estados em saídas, e D para entradas diretas.",
                                    "Diferencie 'feedthrough' (D ≠ 0) de sistemas sem ele.",
                                    "Escreva para um exemplo: saída como posição medida em um sistema massa-mola."
                                  ],
                                  "verification": "Formule y = C x + D u e explique por que é algébrica, sem derivadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre modelagem em espaço de estado",
                                    "Calculadora ou software MATLAB/Simulink"
                                  ],
                                  "tips": "Pense na saída como um 'instantâneo' dos estados e entradas atuais.",
                                  "learningObjective": "Dominar a estrutura estática das equações de saída e seu papel em medir o sistema.",
                                  "commonMistakes": [
                                    "Incluir derivadas em y",
                                    "Confundir C com A",
                                    "Assumir D sempre zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Diferenciar as Duas Equações",
                                  "subSteps": [
                                    "Liste diferenças: dinâmicas (derivadas, tempo) vs. algébricas (instantâneas, sem tempo).",
                                    "Crie uma tabela comparativa: componentes, dependências, função no modelo.",
                                    "Discuta o papel: estados evoluem (dx/dt), saídas são combinações lineares (y).",
                                    "Analise impacto: sem saída, estados são internos; saída permite observação.",
                                    "Identifique em um diagrama de bloco do modelo em espaço de estado."
                                  ],
                                  "verification": "Preencha uma tabela de comparação correta e explique verbalmente as diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em branco para comparação",
                                    "Diagrama de modelo em espaço de estado impresso"
                                  ],
                                  "tips": "Use cores: azul para dinâmico (tempo), vermelho para algébrico (instantâneo).",
                                  "learningObjective": "Discernir precisamente as diferenças estruturais e funcionais entre equações de saída e estado.",
                                  "commonMistakes": [
                                    "Achar que saída tem dinâmica",
                                    "Ignorar combinação linear",
                                    "Confundir entradas em ambas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em um Exemplo Integrado",
                                  "subSteps": [
                                    "Escolha um sistema aeronáutico simples: modelo longitudinal de aeronave (estados: velocidade, ângulo de ataque).",
                                    "Escreva equações de estado dx/dt = A x + B δ (δ=deflexão de elevador).",
                                    "Defina saídas y = [velocidade, altura] = C x + D u.",
                                    "Simule numericamente um passo e observe: estados evoluem, saídas seguem instantaneamente.",
                                    "Modifique C e veja impacto apenas em y, não em x."
                                  ],
                                  "verification": "Implemente o modelo em software e descreva como y difere de dx/dt em uma simulação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy)",
                                    "Dados de modelo de aeronave exemplo"
                                  ],
                                  "tips": "Comece com D=0 para simplificar, depois adicione feedthrough.",
                                  "learningObjective": "Aplicar a diferenciação em contexto real, reforçando compreensão prática.",
                                  "commonMistakes": [
                                    "Misturar matrizes A/C",
                                    "Não simular evolução temporal",
                                    "Esquecer unidades em saídas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de controle de altitude de uma aeronave, as equações de estado dx/dt = A x + B u descrevem como velocidade vertical (estado) e ângulo de ataque evoluem com deflexão de elevador (u). A equação de saída y = C x + D u mede instantaneamente a altitude (y) como combinação linear da velocidade atual e entrada, sem derivadas, permitindo feedback imediato para o piloto.",
                              "finalVerifications": [
                                "Escreva corretamente dx/dt = A x + B u e y = C x + D u.",
                                "Explique verbalmente: 'Por que y não tem derivadas?'",
                                "Identifique em um modelo dado qual equação é dinâmica.",
                                "Modifique C e prediga só impacto em y.",
                                "Diferencie em diagrama de bloco.",
                                "Simule e plote x vs y, notando diferenças temporais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de derivadas apenas em equações de estado (100%).",
                                "Correta formulação de y como linear em x e u (sem erros matriciais).",
                                "Explicação clara do papel funcional: evolução vs. observação.",
                                "Uso correto de exemplos contextualizados em aeronáutica.",
                                "Demonstração prática via simulação ou cálculo manual.",
                                "Ausência de confusões comuns como dinâmica em y."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Matrizes A, B, C, D e combinações lineares.",
                                "Física/Dinâmica: Equações diferenciais de movimento em sistemas aeronáuticos.",
                                "Programação: Implementação em MATLAB/Python para simulação de modelos.",
                                "Controle Automático: Uso em observadores e controladores baseados em saída.",
                                "Engenharia de Software: Modelagem em ferramentas como Simulink."
                              ],
                              "realWorldApplication": "No design de sistemas de controle fly-by-wire em aeronaves, equações de estado modelam dinâmica interna (ex.: instabilidades), enquanto equações de saída integram dados de sensores (altímetro, GPS) como combinações instantâneas de estados, permitindo correções reais em tempo real para estabilidade e navegação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Matrizes de Saída C e D",
                        "description": "Matrizes que definem a relação linear entre variáveis de estado, entradas e saídas: C (p x n, p saídas, n estados) e D (p x m, m entradas), incluindo o termo de alimentação direta.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Determinar dimensões das matrizes C e D",
                            "description": "Calcular as dimensões corretas das matrizes C e D com base no número de estados (n), entradas (m) e saídas (p) de um sistema dado, garantindo compatibilidade matricial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as equações do espaço de estado",
                                  "subSteps": [
                                    "Escrever a equação de estado: ẋ = A x + B u",
                                    "Escrever a equação de saída: y = C x + D u",
                                    "Identificar as dimensões das vetores: x (n × 1), u (m × 1), y (p × 1)",
                                    "Explicar o papel de cada matriz: A (transição de estados), B (entradas), C (saídas de estados), D (saídas diretas de entradas)",
                                    "Discutir compatibilidade matricial básica nas equações"
                                  ],
                                  "verification": "Capaz de recitar as equações completas com dimensões corretas dos vetores e matrizes associadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para anotar equações",
                                    "Referência de livro ou notas sobre modelagem em espaço de estado",
                                    "Exemplo de sistema dinâmico simples"
                                  ],
                                  "tips": [
                                    "Sempre comece pelas equações padrão para evitar confusões",
                                    "Desenhe diagramas de blocos para visualizar fluxos"
                                  ],
                                  "learningObjective": "Dominar a estrutura fundamental das equações de espaço de estado e suas implicações dimensionais.",
                                  "commonMistakes": [
                                    "Confundir a ordem das equações (estado vs. saída)",
                                    "Esquecer o termo D na equação de saída",
                                    "Invertir dimensões de vetores (linhas vs. colunas)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar parâmetros do sistema: n, m e p",
                                  "subSteps": [
                                    "Analisar a descrição do sistema para determinar n (número de estados independentes)",
                                    "Contar m (número de entradas ou controles do sistema)",
                                    "Determinar p (número de saídas ou variáveis medidas)",
                                    "Documentar esses valores com justificativa baseada no contexto físico do sistema",
                                    "Verificar consistência com exemplos reais, como um modelo de aeronave"
                                  ],
                                  "verification": "Lista clara de n, m, p extraída corretamente de uma descrição de sistema fornecida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Descrição de um sistema exemplo (ex: diagrama de aeronave)",
                                    "Planilha ou tabela para registrar valores"
                                  ],
                                  "tips": [
                                    "Estados são variáveis dinâmicas; entradas são ações externas; saídas são observáveis",
                                    "Use diagramas de corpo livre para sistemas físicos"
                                  ],
                                  "learningObjective": "Extrair com precisão os parâmetros dimensionais n, m e p de uma especificação de sistema.",
                                  "commonMistakes": [
                                    "Contar estados dependentes como independentes",
                                    "Confundir entradas com perturbações",
                                    "Subestimar saídas baseadas em sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar dimensões da matriz C",
                                  "subSteps": [
                                    "Lembrar que y (p × 1) = C x (n × 1), logo C deve ser p × n",
                                    "Verificar regra de multiplicação: linhas de C = dim(y), colunas de C = dim(x)",
                                    "Calcular explicitamente: linhas = p, colunas = n",
                                    "Testar com multiplicação simbólica: C (p×n) × x (n×1) → p×1",
                                    "Anotar a dimensão final: C ∈ ℝ^{p × n}"
                                  ],
                                  "verification": "Declaração correta de dim(C) = p × n com demonstração de multiplicação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB",
                                    "Tabela de regras de dimensões matriciais"
                                  ],
                                  "tips": [
                                    "Pense em C como 'mapa' de estados para saídas",
                                    "Sempre confirme com um exemplo numérico pequeno"
                                  ],
                                  "learningObjective": "Calcular e justificar as dimensões da matriz C para compatibilidade na equação de saída.",
                                  "commonMistakes": [
                                    "Invertir p e n (colocar n × p)",
                                    "Ignorar o vetor x na multiplicação",
                                    "Confundir com dimensões de A ou B"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar dimensões da matriz D",
                                  "subSteps": [
                                    "Lembrar que o termo direto y (p × 1) = D u (m × 1), logo D deve ser p × m",
                                    "Verificar regra: linhas de D = dim(y), colunas de D = dim(u)",
                                    "Calcular: linhas = p, colunas = m",
                                    "Testar multiplicação: D (p×m) × u (m×1) → p×1",
                                    "Anotar: D ∈ ℝ^{p × m}, notando que D é frequentemente zero em sistemas físicos"
                                  ],
                                  "verification": "Declaração correta de dim(D) = p × m com prova de compatibilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmos da etapa anterior",
                                    "Exemplo onde D ≠ 0 (ex: sistema com alimentação direta)"
                                  ],
                                  "tips": [
                                    "D representa efeitos instantâneos de u em y; comum ser nulo",
                                    "Compare com C para reforçar diferenças"
                                  ],
                                  "learningObjective": "Calcular e justificar dimensões da matriz D, destacando seu papel direto.",
                                  "commonMistakes": [
                                    "Assumir D sempre n × m como B",
                                    "Confundir colunas com estados em vez de entradas",
                                    "Esquecer verificação de multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar compatibilidade geral das dimensões",
                                  "subSteps": [
                                    "Listar todas as dimensões: A (n×n), B (n×m), C (p×n), D (p×m)",
                                    "Simular multiplicações completas nas equações",
                                    "Identificar inconsistências potenciais e corrigi-las",
                                    "Aplicar a valores numéricos de n, m, p de um exemplo",
                                    "Documentar o modelo dimensional completo"
                                  ],
                                  "verification": "Tabela ou diagrama confirmando todas as dimensões compatíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela dimensional",
                                    "Software de simulação como MATLAB para teste"
                                  ],
                                  "tips": [
                                    "Crie uma tabela: matriz | linhas | colunas",
                                    "Teste com n=2, m=1, p=2 para validação rápida"
                                  ],
                                  "learningObjective": "Garantir que todo o modelo em espaço de estado seja dimensionalmente consistente.",
                                  "commonMistakes": [
                                    "Inconsistência entre B e D (ambas envolvem m)",
                                    "Esquecer verificação de A (sempre quadrada n×n)",
                                    "Não testar com números concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de dinâmica longitudinal de uma aeronave: n=4 (estados: velocidade u, ângulo de ataque α, pitch q, altura h), m=2 (entradas: empuxo T, elevador δe), p=3 (saídas: u, α, h). Assim, C é 3×4 e D é 3×2. Verificação: C × x (3×4 × 4×1 = 3×1), D × u (3×2 × 2×1 = 3×1).",
                              "finalVerifications": [
                                "Dimensões de C declaradas corretamente como p × n",
                                "Dimensões de D como p × m com justificativa",
                                "Compatibilidade confirmada em y = C x + D u",
                                "Valores de n, m, p identificados precisamente do contexto",
                                "Tabela dimensional completa sem erros",
                                "Exemplo numérico testado e correto"
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta nas dimensões calculadas (100%)",
                                "Justificativa clara baseada em regras matriciais",
                                "Identificação correta de n, m, p com evidências",
                                "Verificação de compatibilidade demonstrada",
                                "Clareza na documentação e exemplos",
                                "Ausência de erros comuns como inversão de dimensões"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Regras de multiplicação e dimensões de matrizes",
                                "Física/Engenharia Mecânica: Modelagem de sistemas dinâmicos multilineares",
                                "Programação/Computação: Implementação em MATLAB ou Python (NumPy) para simulações",
                                "Controle Automático: Uso em controladores PID ou LQR",
                                "Engenharia de Software: Validação dimensional em código de simulação"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, determinar dimensões corretas de C e D é essencial para modelar sistemas de controle de voo em software como MATLAB/Simulink, garantindo simulações precisas de estabilidade e resposta de aeronaves a perturbações, evitando erros que poderiam levar a instabilidades em flight tests ou certificações FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Construir matriz C para observabilidade de estados",
                            "description": "Definir a matriz C para mapear variáveis de estado internas para saídas físicas mensuráveis, considerando exemplos em sistemas mecânicos ou elétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo de espaço de estado e identificar variáveis",
                                  "subSteps": [
                                    "Analise as equações diferenciais do sistema: ẋ = Ax + Bu e y = Cx + Du.",
                                    "Liste todas as variáveis de estado (x) internas, como posição e velocidade em sistemas mecânicos.",
                                    "Identifique as saídas físicas mensuráveis (y), como sensores de posição ou tensão.",
                                    "Determine as dimensões: n estados (dim x = n), p saídas (dim y = p), logo C é p x n.",
                                    "Confirme se D é zero para sistemas sem alimentação direta nas saídas."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito as variáveis de estado, saídas e dimensões esperadas para C.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplos de sistemas mecânicos/elétricos de um livro de controle",
                                    "Software como MATLAB para simulação opcional"
                                  ],
                                  "tips": "Comece sempre pelas equações físicas do sistema para evitar confusões com abstrações matemáticas.",
                                  "learningObjective": "Compreender a estrutura do modelo de espaço de estado e mapear variáveis físicas para componentes matriciais.",
                                  "commonMistakes": [
                                    "Confundir estados com entradas",
                                    "Ignorar dimensões levando a matrizes incompatíveis",
                                    "Esquecer de considerar múltiplas saídas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir saídas mensuráveis e mapear para estados",
                                  "subSteps": [
                                    "Selecione saídas baseadas em sensores reais: ex., posição em massa-mola ou corrente em RLC.",
                                    "Expresse cada saída como combinação linear dos estados: y1 = c11 x1 + c12 x2 + ...",
                                    "Para observabilidade, garanta que C permita reconstruir todos os estados de y ao longo do tempo.",
                                    "Esboce a linha de cada saída na matriz C, preenchendo coeficientes baseados nas relações físicas.",
                                    "Verifique linearidade: saídas devem ser lineares em estados para modelo linear."
                                  ],
                                  "verification": "Escreva as expressões de y em termos de x e confirme que correspondem a uma matriz C válida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama esquemático do sistema (desenhe se necessário)",
                                    "Tabela de variáveis físicas vs. estados",
                                    "Calculadora ou MATLAB para testes matriciais"
                                  ],
                                  "tips": "Pense em 'o que o sensor mede diretamente?'. Use identidade para estados diretamente mensuráveis.",
                                  "learningObjective": "Mapear saídas físicas mensuráveis aos estados internos via coeficientes de C.",
                                  "commonMistakes": [
                                    "Assumir todas as saídas mensuráveis sem justificativa física",
                                    "Usar coeficientes arbitrários em vez de derivados das leis físicas",
                                    "Esquecer saídas derivadas como velocidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e testar a matriz C para observabilidade",
                                  "subSteps": [
                                    "Monte a matriz C linha por linha: cada linha corresponde a uma saída.",
                                    "Exemplo: para massa-mola com y = posição, C = [1 0]; para y = posição e velocidade, C = [[1 0], [0 1]].",
                                    "Calcule a matriz de observabilidade O = [C; CA; CA²; ... CA^{n-1}] e verifique rank(O) = n.",
                                    "Ajuste C se necessário para garantir observabilidade plena (evite dependências lineares).",
                                    "Simule em software para validar: aplique entradas e veja se estados são reconstruíveis de y."
                                  ],
                                  "verification": "Construa O e confirme rank completo; simule um passo e reconstrua x de y.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy/Control library)",
                                    "Exemplo numérico de sistema 2x2",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Para sistemas SISO (uma saída), teste observabilidade via polos do observador; use svd(O) para rank.",
                                  "learningObjective": "Construir C explicitamente e validar observabilidade para estimar estados não mensuráveis.",
                                  "commonMistakes": [
                                    "Construir C com rank insuficiente",
                                    "Confundir observabilidade com controlabilidade",
                                    "Ignorar D em sistemas com alimentação direta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em exemplos reais e refinar",
                                  "subSteps": [
                                    "Aplique a um sistema mecânico: pêndulo duplo com ângulos como estados, saídas de encoders.",
                                    "Aplique a um elétrico: circuito RLC série com corrente e tensão como estados/saídas.",
                                    "Compare C antes/depois de ajustes para observabilidade.",
                                    "Documente o processo: equações -> C -> O -> rank.",
                                    "Discuta limitações: ruído em sensores afeta observabilidade prática."
                                  ],
                                  "verification": "Resolva 2 exemplos independentes e apresente Cs com verificação de observabilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de livros/textos de Engenharia Aeronáutica",
                                    "Simulador online como Octave Online",
                                    "Relatório template para documentação"
                                  ],
                                  "tips": "Escolha sistemas onde nem todos estados são mensuráveis para praticar reconstrução.",
                                  "learningObjective": "Aplicar construção de C em contextos aeronáuticos/mecânicos/elétricos com validação.",
                                  "commonMistakes": [
                                    "Overfitting C a um exemplo sem generalização",
                                    "Não testar com simulações dinâmicas",
                                    "Desconsiderar não-linearidades aproximadas como lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema massa-mola-amortecedor aeronáutico (flap de asa): estados x = [posição do flap, velocidade]. Sensores medem posição (y1 = x1) e aceleração (y2 ≈ derivada, mas mapeada como [0 1] para velocidade). C = [[1 0]; [0 1]] garante observabilidade plena, permitindo estimar desgaste interno via dinâmica observada.",
                              "finalVerifications": [
                                "Conseguiu construir C correta para um sistema dado com dimensões p x n?",
                                "Calculou corretamente a matriz de observabilidade O e seu rank?",
                                "Identificou e corrigiu um C não observável em um exemplo?",
                                "Aplicou C em pelo menos um sistema mecânico e um elétrico?",
                                "Explicou como C mapeia estados internos para saídas mensuráveis?",
                                "Simulou reconstrução de estados a partir de y em software?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estados e saídas físicas (20%)",
                                "Correção das dimensões e coeficientes de C (25%)",
                                "Validação de observabilidade via rank(O) (25%)",
                                "Uso de exemplos concretos com justificativa física (15%)",
                                "Clareza na documentação e verificações (10%)",
                                "Aplicação em múltiplos contextos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Eigenvalores e rank de matrizes para observabilidade.",
                                "Física: Leis de Newton/Kirchhoff para derivar relações estado-saída.",
                                "Controle Automático: Projeto de observadores de Luenberger usando C.",
                                "Engenharia Aeronáutica: Monitoramento de flight dynamics em aviões.",
                                "Processamento de Sinais: Filtragem de Kalman para estados estimados via C."
                              ],
                              "realWorldApplication": "Em aeronaves, a matriz C é usada em sistemas de controle de voo (fly-by-wire) para estimar estados internos como ângulo de ataque ou deformação estrutural a partir de sensores limitados (giroscópios, acelerômetros), garantindo estabilidade e segurança sem sensores em todos os estados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Interpretar o papel da matriz D (alimentação direta)",
                            "description": "Analisar o impacto do termo D u na saída, que representa transmissão instantânea de entrada para saída sem passar pelos estados dinâmicos, comum em sistemas com acoplamento direto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Equações Fundamentais do Espaço de Estado",
                                  "subSteps": [
                                    "Escrever a equação de estado dinâmica: dx/dt = A x + B u",
                                    "Escrever a equação de saída: y = C x + D u",
                                    "Identificar os componentes: x (estado), u (entrada), y (saída)",
                                    "Explicar o papel dinâmico de A, B, C e o direto de D",
                                    "Diferenciar estados integrados de termos instantâneos"
                                  ],
                                  "verification": "Escrever corretamente as duas equações em uma folha e rotulá-las",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de livro ou PDF de Sistemas Dinâmicos"
                                  ],
                                  "tips": "Use notação matricial consistente e destaque o termo D u visualmente",
                                  "learningObjective": "Compreender a estrutura completa das equações no espaço de estado",
                                  "commonMistakes": [
                                    "Confundir a equação de estado com a de saída",
                                    "Esquecer o termo D na saída",
                                    "Ignorar dimensões das matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar a Equação de Saída y = C x + D u",
                                  "subSteps": [
                                    "Analisar o termo C x: dependência dos estados internos (atraso dinâmico)",
                                    "Isolar o termo D u: transmissão direta da entrada para saída",
                                    "Verificar dimensões: D é matriz de tamanho (dimensão y) x (dimensão u)",
                                    "Simular com D=0: saída puramente dependente de estados",
                                    "Comparar com D≠0: impacto imediato de u em y"
                                  ],
                                  "verification": "Desenhar diagrama de blocos mostrando feedthrough de D",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (NumPy)",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Pense em D como um 'atalho' elétrico ou mecânico sem inércia",
                                  "learningObjective": "Diferenciar contribuições dinâmica (C x) e estática (D u) na saída",
                                  "commonMistakes": [
                                    "Atribuir dinâmica ao termo D u",
                                    "Assumir D sempre zero",
                                    "Confundir dimensões de C e D"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Impacto do Termo D u na Dinâmica do Sistema",
                                  "subSteps": [
                                    "Explicar 'transmissão instantânea': y muda imediatamente com u, sem delay",
                                    "Discutir acoplamento direto: comum em sensores/amplificadores",
                                    "Analisar estabilidade: D não afeta pólos (eigenvalues de A), mas ganho DC",
                                    "Identificar cenários sem D (puros integradores) vs. com D (feedforward)",
                                    "Calcular ganho estático: lim t→∞ y(t) para entrada degrau"
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito o que acontece se u varia subitamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial online",
                                    "Exemplos de matrizes impressas"
                                  ],
                                  "tips": "Simule mentalmente: 'u entra e sai direto como um fio' vs. 'passa por filtro'",
                                  "learningObjective": "Analisar como D u causa resposta imediata sem estados dinâmicos",
                                  "commonMistakes": [
                                    "Achar que D afeta dinâmica interna",
                                    "Ignorar D em simulações",
                                    "Confundir com matriz B"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolher sistema simples: y = x1 + 2 u (D = [2])",
                                    "Simular passo na entrada u e observar y instantânea",
                                    "Comparar simulação com D=0 vs D≠0",
                                    "Identificar feedthrough em diagrama de blocos",
                                    "Documentar conclusões sobre impacto em controle"
                                  ],
                                  "verification": "Gerar gráfico de y vs t mostrando salto inicial devido a D",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB, Octave ou Python (control library)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use funções como step() em MATLAB para visualizar feedthrough",
                                  "learningObjective": "Aplicar interpretação em simulação e validar conceitualmente",
                                  "commonMistakes": [
                                    "Não normalizar escalas no gráfico",
                                    "Esquecer inicializar x(0)=0",
                                    "Interpretar salto como instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de elevador de aeronave, u é o comando de piloto (deflexão), x inclui velocidades angulares. D u modela o efeito direto da deflexão no momento pitch (saída y), sem delay dos estados inerciais, permitindo resposta rápida em manobras.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de D em 1 minuto",
                                "Identificar feedthrough em uma matriz de saída dada",
                                "Simular e mostrar gráfico com e sem D",
                                "Calcular ganho estático corretamente",
                                "Diferenciar sistemas com/ sem acoplamento direto",
                                "Discutir implicações em projeto de controladores"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de transmissão instantânea (90%)",
                                "Correta análise dimensional de D (100%)",
                                "Uso correto de simulações para validação (80%)",
                                "Identificação de cenários reais de aplicação (70%)",
                                "Ausência de confusão com termos dinâmicos (100%)",
                                "Clareza em explicações e diagramas (85%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Multiplicação e propriedades de matrizes",
                                "Controle Automático: Diagrama de blocos e feedforward",
                                "Engenharia Elétrica: Amplificadores operacionais com ganho direto",
                                "Física: Sistemas lineares invariantes no tempo",
                                "Programação: Simulação numérica em Python/MATLAB"
                              ],
                              "realWorldApplication": "Na aviação, a matriz D é crucial em modelos de flight dynamics para atuadores hidráulicos, onde comandos de piloto afetam diretamente forças aerodinâmicas (ex: ailerons), otimizando controladores para estabilidade e manobrabilidade em voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Exemplos e Aplicações das Equações de Saída",
                        "description": "Aplicação prática das equações de saída em sistemas reais, como mecânicos, eletromecânicos, relacionando com linearização e diagramas de blocos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Derivar equações de saída de um sistema físico linearizado",
                            "description": "A partir de um modelo físico (ex.: circuito RLC ou massa-mola-amortecedor), linearizar e extrair as matrizes C e D para o modelo de espaço de estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o sistema físico, variáveis de estado, entrada e saída",
                                  "subSteps": [
                                    "Selecione um sistema físico linear ou linearizável, como circuito RLC série ou sistema massa-mola-amortecedor.",
                                    "Defina as variáveis de estado x (ex.: corrente i e tensão no capacitor Vc para RLC; posição q e velocidade dq/dt para massa-mola).",
                                    "Especifique a entrada u (ex.: tensão de entrada Vs ou força F).",
                                    "Defina as saídas y desejadas (ex.: tensão no capacitor Vc ou posição q).",
                                    "Anote as dimensões: n estados, m entradas, p saídas."
                                  ],
                                  "verification": "Documente uma tabela com variáveis x, u, y e suas dimensões confirmadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama esquemático do sistema",
                                    "Referência de modelo físico (livro ou notas)"
                                  ],
                                  "tips": "Priorize saídas fisicamente mensuráveis para facilitar verificação experimental.",
                                  "learningObjective": "Compreender a estrutura do modelo de espaço de estados e suas componentes principais.",
                                  "commonMistakes": "Confundir variáveis de estado com saídas ou entradas diretas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar ou derivar o modelo linearizado de estado (matrizes A e B)",
                                  "subSteps": [
                                    "Escreva as equações diferenciais não-lineares originais do sistema.",
                                    "Linearize em torno do ponto de operação (equilíbrio) usando expansões de Taylor: Δẋ = A Δx + B Δu.",
                                    "Identifique a matriz A (Jacobiano de f em relação a x) e B (em relação a u).",
                                    "Verifique se o modelo está na forma canônica de espaço de estados.",
                                    "Teste dimensionalidade: A (n x n), B (n x m)."
                                  ],
                                  "verification": "Matrizes A e B derivadas e multiplicação matricial resulta em unidades consistentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/SymPy",
                                    "Folha de equações diferenciais"
                                  ],
                                  "tips": "Use simetria do sistema para simplificar Jacobianos.",
                                  "learningObjective": "Dominar a linearização e formação das equações de estado.",
                                  "commonMistakes": "Esquecer termos de segunda ordem na linearização ou erros em derivadas parciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar as equações de saída em termos de estados e entradas",
                                  "subSteps": [
                                    "Defina algebraicamente as saídas y como funções de x e u: y = g(x, u).",
                                    "Linearize g se necessário: Δy ≈ C Δx + D Δu.",
                                    "Calcule C como Jacobiano de g em relação a x no ponto de operação.",
                                    "Calcule D como Jacobiano de g em relação a u (geralmente 0 para sistemas sem alimentação direta).",
                                    "Escreva explicitamente y = C x + D u."
                                  ],
                                  "verification": "Substitua valores de x e u conhecidos e confira se y coincide com definição física.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software simbólico para Jacobianos",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Para saídas puramente dependentes de estados, D=0; confirme ausência de caminhos diretos u→y.",
                                  "learningObjective": "Extrair matrizes de saída do modelo físico linearizado.",
                                  "commonMistakes": "Incluir estados desnecessários em C ou assumir D≠0 incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e validar as matrizes C e D",
                                  "subSteps": [
                                    "Monte a matriz C (p x n) com coeficientes dos estados nas expressões de y.",
                                    "Monte D (p x m) similarmente para entradas diretas.",
                                    "Verifique dimensões: linhas de C/D = número de saídas, colunas = estados/entradas.",
                                    "Simule resposta a uma entrada degrau e confira saídas.",
                                    "Compare com modelo conhecido ou simulação física."
                                  ],
                                  "verification": "C e D têm dimensões corretas e y calculado = y esperado em testes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Dados de simulação"
                                  ],
                                  "tips": "Use eye() ou zeros() para matrizes identidade ou nulas em software.",
                                  "learningObjective": "Construir e validar matrizes de saída no formato padrão.",
                                  "commonMistakes": "Erros de transposição ou mismatch de índices em matrizes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar consistência e robustez do modelo completo",
                                  "subSteps": [
                                    "Integre o modelo completo: ẋ = Ax + Bu, y = Cx + Du.",
                                    "Analise observabilidade (rank([C; CA; ...]) = n).",
                                    "Teste com perturbações pequenas em x e u.",
                                    "Documente suposições (linearidade local, ponto de operação).",
                                    "Prepare para uso em controle ou simulação."
                                  ],
                                  "verification": "Modelo passa em simulação numérica e análise qualitativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação de sistemas dinâmicos"
                                  ],
                                  "tips": "Verifique observabilidade para garantir que saídas permitam reconstruir estados.",
                                  "learningObjective": "Assegurar que equações de saída integrem corretamente ao modelo.",
                                  "commonMistakes": "Ignorar efeitos não-lineares residuais ou falta de observabilidade."
                                }
                              ],
                              "practicalExample": "Em um circuito RLC série linear (R=1Ω, L=1H, C=1F), estados x=[i; Vc], entrada u=Vs. Saída y=Vc. Linearização dá C=[0 1], D=[0], pois Vc depende só do estado Vc, sem caminho direto Vs→Vc.",
                              "finalVerifications": [
                                "Matriz C tem dimensões (p x n) e coeficientes corretos.",
                                "Matriz D tem dimensões (p x m) e é zero se sem alimentação direta.",
                                "Substituição de x e u conhecidos reproduz y física exata.",
                                "Modelo completo é observável (rank do observability matrix = n).",
                                "Simulação numérica coincide com solução analítica.",
                                "Unidades e escalas são consistentes em todas matrizes."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de C e D (sem erros algébricos).",
                                "Correta identificação de dependências estado-saída e entrada-saída.",
                                "Validação dimensional e numérica completa.",
                                "Clareza na documentação de passos e suposições.",
                                "Análise de observabilidade e robustez incluída.",
                                "Aplicação correta a exemplo físico realista."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Jacobianos e manipulação matricial.",
                                "Física Clássica: Equações diferenciais de circuitos e mecânica.",
                                "Engenharia de Controle: Observabilidade e modelos de espaço de estados.",
                                "Programação Computacional: Simulação em MATLAB/Python.",
                                "Análise Numérica: Linearização e estabilidade."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, derivar C e D para modelo de um atuador de flap em aeronave permite simular e controlar ângulo de ataque via sensores de posição, essencial para estabilidade de voo autônomo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Converter diagrama de blocos para equações de saída",
                            "description": "Traduzir um diagrama de blocos em representação de espaço de estados, identificando especificamente a equação de saída y = C x + D u.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Diagrama de Blocos e Identificar Componentes Principais",
                                  "subSteps": [
                                    "Examine o diagrama de blocos para identificar a entrada u, saída y e blocos funcionais (somas, ganhos, integradores).",
                                    "Marque todas as variáveis internas que podem servir como estados x (saídas de integradores ou delays).",
                                    "Desenhe um fluxograma simplificado destacando caminhos de u para y, incluindo vias diretas (feedthrough) e indiretas via estados.",
                                    "Liste as dimensões: número de entradas (m), estados (n) e saídas (p)."
                                  ],
                                  "verification": "Confirme que todos os nós principais estão rotulados e caminhos de sinal traçados corretamente em um esboço.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Diagrama de blocos impresso ou digital, papel quadriculado, lápis e borracha",
                                  "tips": "Comece pelas saídas y e trace para trás até u para evitar confusão em diagramas complexos.",
                                  "learningObjective": "Compreender a estrutura topológica do diagrama para mapear variáveis de estado e saídas.",
                                  "commonMistakes": "Ignorar caminhos de feedthrough (diretos de u para y) ou confundir variáveis transitórias com estados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os Estados x e Matrizes Associadas",
                                  "subSteps": [
                                    "Selecione as variáveis de estado x como saídas de integradores (ou delays discretos).",
                                    "Ordene os estados x = [x1, x2, ..., xn]^T de forma lógica (ex: ordem de integração).",
                                    "Identifique dependências lineares iniciais para A e B, mas foque em preparar para C e D.",
                                    "Verifique se a escolha de estados captura toda a dinâmica observável."
                                  ],
                                  "verification": "Escreva x explicitamente e confirme que dx/dt pode ser expresso em termos de x e u.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Folha de cálculo para matrizes, software como MATLAB ou Python (opcional para simulação inicial)",
                                  "tips": "Use convenção de indexação consistente (ex: x1 como primeiro integrador) para evitar erros em C.",
                                  "learningObjective": "Estabelecer a base vetorial de estados necessária para formar a saída linear.",
                                  "commonMistakes": "Escolher estados redundantes ou não mínimos, levando a matrizes C desnecessariamente grandes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Equação de Saída y = C x + D u",
                                  "subSteps": [
                                    "Trace todos os caminhos da saída y até os estados x para determinar os coeficientes da matriz C.",
                                    "Identifique e calcule ganhos diretos de u para y (sem passar por estados) para formar D.",
                                    "Escreva y como combinação linear: cada componente yi = soma(c_ij * xj) + soma(d_ik * uk).",
                                    "Monte as matrizes C (p x n) e D (p x m) explicitamente."
                                  ],
                                  "verification": "Substitua valores numéricos simbólicos em um exemplo simples e compare y calculada com diagrama.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": "Calculadora ou software simbólico (SymPy/Python), exemplos de diagramas resolvidos",
                                  "tips": "Use superposição para caminhos múltiplos: some contribuições de cada estado e entrada separadamente.",
                                  "learningObjective": "Derivar precisamente os coeficientes C e D a partir da topologia do diagrama.",
                                  "commonMistakes": "Esquecer multiplicadores de ganho em caminhos ou inverter índices de matrizes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar a Equação de Saída",
                                  "subSteps": [
                                    "Simule o sistema com entradas de teste (ex: degrau unitário) e compare y do diagrama vs. equação.",
                                    "Verifique dimensões: C tem p linhas e n colunas; D tem p linhas e m colunas.",
                                    "Teste casos limite: u=0 (y=Cx), estados zero (y=Du).",
                                    "Ajuste se houver discrepâncias, revisando caminhos perdidos."
                                  ],
                                  "verification": "Gráfico de simulação coincide em pelo menos 3 condições iniciais diferentes.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Software de simulação (MATLAB Simulink ou Python com control library), plotter",
                                  "tips": "Sempre normalize unidades de sinal para evitar erros numéricos em validação.",
                                  "learningObjective": "Garantir que a equação capture fielmente a dinâmica de saída do diagrama.",
                                  "commonMistakes": "Não testar feedthrough (D=0 assumido erroneamente) ou condições iniciais não zero."
                                }
                              ],
                              "practicalExample": "Considere um diagrama com u somado a um ganho K1*x1, depois integrado para x1, e y = 2*x1 + 0.5*u. Estados: x = [x1]. Então C = [2], D = [0.5]. Simule u(t)=1 para t>0, x(0)=0: y deve subir linearmente para 2t + 0.5.",
                              "finalVerifications": [
                                "Equação y = C x + D u reproduz saídas idênticas do diagrama em simulações.",
                                "Matrizes C e D têm dimensões corretas (p x n e p x m).",
                                "Casos u=0 e x=0 produzem y esperados.",
                                "Nenhum caminho de sinal no diagrama é ignorado na equação.",
                                "Coeficientes numéricos batem com ganhos e somas do diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estados e caminhos (90% correto).",
                                "Correção dos coeficientes C e D (sem erros de sinal ou ganho).",
                                "Validação via simulação ou teste analítico demonstrada.",
                                "Explicação clara de cada coeficiente derivado do diagrama.",
                                "Dimensões e notação matricial consistentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Manipulação de vetores e matrizes para C e D.",
                                "Programação: Implementação em Python/MATLAB para simulação e verificação.",
                                "Física/Dinâmica: Aplicação em modelagem de sistemas mecânicos como asas de aeronaves.",
                                "Controle Automático: Uso em observadores e controladores baseados em espaço de estados."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, converte diagramas de blocos de sistemas de controle de voo (ex: autopilot) para espaço de estados, permitindo design de observadores de estado para estimar ângulos de ataque ou velocidades não diretamente mensuráveis, essencial para estabilidade em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Verificar consistência em sistemas MIMO",
                            "description": "Para sistemas multi-entrada multi-saída (MIMO), validar a equação de saída matricial, computando y para vetores x e u dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos das Equações de Saída em Sistemas MIMO",
                                  "subSteps": [
                                    "Defina as equações de estado: dx/dt = A x + B u",
                                    "Defina a equação de saída: y = C x + D u",
                                    "Explique o que MIMO significa: múltiplas entradas (u) e saídas (y)",
                                    "Identifique dimensões típicas: x (n x 1), u (m x 1), y (p x 1)",
                                    "Discuta o papel de cada matriz: C (p x n), D (p x m)"
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito as equações e dimensões sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro de Sinais e Sistemas, notas de aula, quadro branco",
                                  "tips": "Desenhe diagramas de blocos para visualizar fluxos MIMO",
                                  "learningObjective": "Compreender a estrutura matemática das equações de saída MIMO",
                                  "commonMistakes": "Confundir ordem das matrizes ou ignorar o termo D u (alimentação direta)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Sistema com Dados Fornecidos",
                                  "subSteps": [
                                    "Colete as matrizes A, B, C, D, vetor de estado x e vetor de entrada u",
                                    "Verifique dimensões: compatibilidade entre C (p x n) e x (n x 1), D (p x m) e u (m x 1)",
                                    "Anote valores numéricos exatos em uma tabela organizada",
                                    "Confirme se o sistema está no tempo discreto ou contínuo (foco em saída estática)",
                                    "Prepare ferramentas computacionais como MATLAB ou Python (NumPy)"
                                  ],
                                  "verification": "Lista de matrizes e vetores com dimensões confirmadas e sem inconsistências",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software MATLAB/Python, papel e caneta para anotações",
                                  "tips": "Use comandos como size() no MATLAB para checar dimensões rapidamente",
                                  "learningObjective": "Preparar dados corretamente para computação segura",
                                  "commonMistakes": "Erros de transcrição de matrizes ou mismatch de dimensões"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o Vetor de Saída y",
                                  "subSteps": [
                                    "Calcule o produto matricial C * x",
                                    "Calcule o produto matricial D * u",
                                    "Some os resultados: y = (C * x) + (D * u)",
                                    "Execute a computação manualmente para sistemas pequenos (2x2)",
                                    "Valide com software: y_computed = C*x + D*u"
                                  ],
                                  "verification": "Resultado y numérico coincide entre cálculo manual e software (erro < 1e-6)",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial, MATLAB/Python script",
                                  "tips": "Multiplique linha por coluna sistematicamente para evitar erros algébricos",
                                  "learningObjective": "Executar multiplicação matricial vetor corretamente",
                                  "commonMistakes": "Inverter ordem de multiplicação (não comutativa) ou esquecer parênteses"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Consistência do Sistema MIMO",
                                  "subSteps": [
                                    "Verifique dimensões de y: deve ser p x 1",
                                    "Compare y com valores esperados ou simulações dinâmicas",
                                    "Cheque propriedades físicas: saídas dentro de ranges realistas",
                                    "Analise impacto de u em y via D (ganho direto)",
                                    "Teste sensibilidade: varie x/u ligeiramente e observe y"
                                  ],
                                  "verification": "Relatório escrito confirmando consistência com evidências numéricas",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos de simulação, tabela de comparação",
                                  "tips": "Use norm(y) ou plot para visualizar anomalias",
                                  "learningObjective": "Identificar e justificar consistência em equações MIMO",
                                  "commonMistakes": "Ignorar termo D u ou aceitar dimensões erradas sem checagem"
                                }
                              ],
                              "practicalExample": "Considere um sistema MIMO de aeronave: A (4x4), B (4x2), C (2x4), D (2x2), x = [10; 5; 0; 0], u = [1; 0.5]. Compute y = C x + D u = [15.2; 3.1], verificando se altitudes e velocidades de saída são consistentes com física de voo.",
                              "finalVerifications": [
                                "Dimensões de y corretas (p x 1)",
                                "Cálculo y idêntico em métodos manual e computacional",
                                "Valores de y fisicamente plausíveis",
                                "Consistência com equações de estado associadas",
                                "Ausência de erros numéricos significativos",
                                "Relatório documenta todos os passos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na multiplicação matricial (100% correta)",
                                "Verificação completa de dimensões e consistência",
                                "Uso adequado de ferramentas computacionais",
                                "Explicação clara de passos e justificativas",
                                "Identificação de potenciais erros e correções",
                                "Aplicação contextual em engenharia aeronáutica"
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso em reguladores MIMO de aeronaves",
                                "Programação Computacional: Implementação em MATLAB/Simulink",
                                "Física Aplicada: Dinâmica de voo multi-variável",
                                "Matemática Linear: Álgebra matricial avançada"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, verifica consistência de modelos de controle de flight dynamics MIMO para sistemas como autopilotos, garantindo que saídas (altitude, roll) respondam corretamente a entradas (thrust, aileron) em simuladores de voo ou certificação FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Linearização de Sistemas Não-Lineares",
                    "description": "Técnica para aproximar sistemas não-lineares por modelos lineares no espaço de estados em torno de pontos de equilíbrio.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Sistemas Não-Lineares no Espaço de Estados",
                        "description": "Representação matemática de sistemas dinâmicos não-lineares utilizando equações diferenciais no formato de espaço de estados, onde as dinâmicas são descritas por \\dot{x} = f(x, u) e y = h(x, u), destacando a não-linearidade nas funções f e h.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar a forma geral de um sistema não-linear no espaço de estados",
                            "description": "Reconhecer e escrever a representação canônica de um sistema não-linear como \\dot{x} = f(x, u) e y = h(x, u), diferenciando de modelos lineares e identificando termos não-lineares em exemplos de sistemas mecânicos ou elétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar representação no espaço de estados para sistemas lineares",
                                  "subSteps": [
                                    "Defina o vetor de estado x, entrada u e saída y.",
                                    "Escreva as equações lineares canônicas: \\dot{x} = A x + B u e y = C x + D u.",
                                    "Explique a invariância e o propósito do modelo no espaço de estados.",
                                    "Compare com representações em tempo/frequência (Laplace).",
                                    "Resolva um exemplo simples linear manualmente."
                                  ],
                                  "verification": "Escrever corretamente as equações lineares para um sistema RC simples e simular uma resposta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Signals and Systems (Oppenheim)",
                                    "Caderno e calculadora",
                                    "Software MATLAB ou Python (SciPy)"
                                  ],
                                  "tips": "Sempre desenhe o diagrama de blocos para visualizar o sistema antes de modelar.",
                                  "learningObjective": "Compreender a base linear para contrastar com não-lineares.",
                                  "commonMistakes": [
                                    "Confundir estado com saída",
                                    "Esquecer o termo D em y",
                                    "Ignorar dependência temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a forma geral canônica de sistemas não-lineares",
                                  "subSteps": [
                                    "Apresente \\dot{x} = f(x, u) e y = h(x, u), onde f e h são funções não-lineares.",
                                    "Explique que f e h não são matriciais, mas funções vetoriais arbitrárias.",
                                    "Discuta condições como Lipschitz para existência de soluções.",
                                    "Diferencie explicitamente de lineares: ausência de superposição.",
                                    "Derive um exemplo trivial: \\dot{x} = x^2 + u."
                                  ],
                                  "verification": "Reescrever a forma geral de cor e explicar diferenças chave em um parágrafo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre controle não-linear",
                                    "Vídeo Khan Academy sobre EDOs",
                                    "Python Jupyter Notebook"
                                  ],
                                  "tips": "Use notação vetorial consistente: x ∈ ℝ^n, u ∈ ℝ^m.",
                                  "learningObjective": "Reconhecer e escrever a representação padrão não-linear.",
                                  "commonMistakes": [
                                    "Escrever f como matriz",
                                    "Confundir h(x,u) com observador linear",
                                    "Omitir dependência em u"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar termos não-lineares em exemplos físicos",
                                  "subSteps": [
                                    "Analise um sistema mecânico: pêndulo (sin(θ), θ ≠ pequeno).",
                                    "Analise um sistema elétrico: diodo (i = I_s (e^{v/V_t} - 1)).",
                                    "Extraia equações diferenciais e destaque termos como sin(x), x^2, e^{x}.",
                                    "Defina vetor de estado para converter em primeira ordem.",
                                    "Classifique: polinomial, trigonométrico, exponencial."
                                  ],
                                  "verification": "Identificar e listar todos os termos não-lineares em 3 equações dadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de física (Halliday)",
                                    "Simulink ou MATLAB para plotar",
                                    "Folhas com equações de pêndulo e diodo"
                                  ],
                                  "tips": "Procure produtos x*u, potências >1, funções transcendentais.",
                                  "learningObjective": "Detectar não-linearidades em modelos reais.",
                                  "commonMistakes": [
                                    "Considerar sin(θ) ≈ θ como linear sempre",
                                    "Ignorar atrito não-linear",
                                    "Confundir com acoplamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir representação completa e diferenciar modelos",
                                  "subSteps": [
                                    "Escolha um exemplo (pêndulo): defina x = [θ, ω], escreva \\dot{x} = f(x,u).",
                                    "Defina y (ex: posição θ).",
                                    "Compare com aproximação linear ao redor de equilíbrio.",
                                    "Simule numericamente para visualizar diferença.",
                                    "Documente em relatório curto."
                                  ],
                                  "verification": "Produzir código ou equações para um sistema completo e plotar respostas linear vs não-linear.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Python (ODEINT)",
                                    "Exemplos de aeronáutica: modelo de asa flexível"
                                  ],
                                  "tips": "Verifique dimensões: dim(f) = n x 1.",
                                  "learningObjective": "Aplicar integralmente o conhecimento para modelagem.",
                                  "commonMistakes": [
                                    "Estado incompleto (esquecer velocidades)",
                                    "Erro em Jacobiana para linearização",
                                    "Simulação instável por step size"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo simples: m l \\ddot{θ} + c \\dot{θ} + m g sin(θ) = u. Defina x1 = θ, x2 = \\dot{θ}, então \\dot{x1} = x2, \\dot{x2} = - (c/m l) x2 - (g/l) sin(x1) + (1/m l) u, y = x1. Termo não-linear: sin(x1).",
                              "finalVerifications": [
                                "Escrever corretamente \\dot{x} = f(x,u), y = h(x,u) para um novo sistema.",
                                "Identificar todos os termos não-lineares em equações mecânicas/elétricas.",
                                "Diferenciar verbalmente linear de não-linear.",
                                "Plotar simulações mostrando comportamento não-linear (ex: bifurcação).",
                                "Linearizar corretamente ao redor de um ponto.",
                                "Explicar papel na engenharia aeronáutica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na forma canônica (100% correta).",
                                "Identificação completa de não-linearidades (sem omissões).",
                                "Correção conceitual em diferenças lineares/não-lineares.",
                                "Qualidade da simulação e análise visual.",
                                "Clareza na documentação e exemplos.",
                                "Conexão com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações Diferenciais Não-Lineares e Teorema de Picard-Lindelöf.",
                                "Física: Dinâmica Não-Linear em Mecânica Clássica.",
                                "Computação: Solução Numérica de EDOs (Runge-Kutta).",
                                "Engenharia de Controle: Preparação para Linearização (Jacobiano).",
                                "Engenharia Aeronáutica: Modelagem de Aerodinâmica Não-Linear."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, modela dinâmicas de voo não-lineares como coeficientes de sustentão dependentes do ângulo de ataque (stall), permitindo linearização para controle de estabilidade em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Converter diagramas de blocos em modelos não-lineares no espaço de estados",
                            "description": "Transformar um diagrama de blocos não-linear em equações diferenciais matriciais no espaço de estados, aplicando regras de manipulação de blocos e identificando variáveis de estado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Diagrama de Blocos e Identificar Componentes",
                                  "subSteps": [
                                    "Examine o diagrama de blocos, identificando entradas (u), saídas (y) e blocos funcionais (somadores, multiplicadores, funções não-lineares, integradores).",
                                    "Liste todas as variáveis de sinal ao longo das conexões entre blocos.",
                                    "Classifique cada bloco: linear (ganho, soma) ou não-linear (multiplicação, saturação, funções trigonométricas).",
                                    "Desenhe um esboço anotado do diagrama destacando loops de feedback e caminhos de sinal.",
                                    "Determine o número aproximado de variáveis de estado com base nos integradores ou elementos de memória."
                                  ],
                                  "verification": "Crie um inventário escrito ou tabela com todos os blocos, variáveis e classificações; confirme que cobre 100% do diagrama.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de blocos impresso ou digital",
                                    "Papel quadriculado ou software de desenho (ex: Draw.io)",
                                    "Caneta e lápis"
                                  ],
                                  "tips": "Comece pelas entradas e saídas, seguindo o fluxo de sinal para evitar pular loops ocultos.",
                                  "learningObjective": "Compreender a estrutura topológica do diagrama para mapear equações corretamente.",
                                  "commonMistakes": [
                                    "Ignorar feedbacks implícitos",
                                    "Confundir variáveis de entrada com estados",
                                    "Não anotar não-linearidades cedo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever Equações Diferenciais para Cada Bloco",
                                  "subSteps": [
                                    "Para cada bloco linear (ganho k, soma), escreva a relação algébrica: ex. e = u1 - u2.",
                                    "Para blocos não-lineares (ex. produto x*y), escreva f(x,y) explicitamente.",
                                    "Identifique integradores: dx/dt = input do integrador.",
                                    "Expresse todas as equações em termos de variáveis de sinal identificadas no Step 1.",
                                    "Substitua funções não-lineares conhecidas (ex. sin(θ) ≈ θ para pequenas angles, mas mantenha exata aqui)."
                                  ],
                                  "verification": "Liste todas as equações em um documento, verificando dimensionalidade e consistência de unidades.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de equações",
                                    "Calculadora simbólica (ex: SymPy ou MATLAB)",
                                    "Referência de funções não-lineares comuns"
                                  ],
                                  "tips": "Use notação consistente: subscritos para variáveis (ex. x1, u). Numere as equações sequencialmente.",
                                  "learningObjective": "Traduzir blocos gráficos em equações matemáticas precisas, preservando não-linearidades.",
                                  "commonMistakes": [
                                    "Linearizar prematuramente",
                                    "Esquecer derivadas em integradores",
                                    "Inverter sinais em somadores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar Variáveis de Estado e Formular Equações Matriciais",
                                  "subSteps": [
                                    "Escolha variáveis de estado x como saídas de integradores ou elementos de memória mínima.",
                                    "Expresse derivadas ẙ = f(x, u) substituindo equações dos Steps anteriores.",
                                    "Para saídas, escreva y = h(x, u).",
                                    "Reorganize em forma matricial vetorial: ẙ = f(x,u), mesmo se não-lineares (sem A, B lineares).",
                                    "Verifique ordem do sistema: número de estados deve igualar integradores independentes."
                                  ],
                                  "verification": "Escreva o modelo final ẙ = f(x,u), y = h(x,u) e simule numericamente um passo para checar.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python com SciPy)",
                                    "Template de modelo de espaço de estado"
                                  ],
                                  "tips": "Use regra de Caughy para seleção de estados em loops; priorize minimalidade.",
                                  "learningObjective": "Mapear equações de blocos para representação canônica de espaço de estado não-linear.",
                                  "commonMistakes": [
                                    "Escolher estados redundantes",
                                    "Não expressar todas ẙ em termos de x e u apenas",
                                    "Confundir x com variáveis algébricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Modelo de Espaço de Estado",
                                  "subSteps": [
                                    "Compare simulações do diagrama original vs. modelo de estado para uma entrada teste.",
                                    "Cheque preservação de não-linearidades: plote respostas para grandes sinais.",
                                    "Identifique singularidades ou condições iniciais críticas.",
                                    "Documente suposições (ex. unidades SI) e limitações do modelo.",
                                    "Otimize notação: vetorize x, u, y claramente."
                                  ],
                                  "verification": "Gráfico de simulação sobreposto mostra match <5% erro para entrada senoidal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink ou Python (odeint/scipy.integrate)",
                                    "Dados de entrada de teste"
                                  ],
                                  "tips": "Use entradas escalonadas ou senoidais para validação rápida.",
                                  "learningObjective": "Garantir fidelidade do modelo derivado ao sistema original.",
                                  "commonMistakes": [
                                    "Não testar regimes não-lineares",
                                    "Ignorar condições iniciais",
                                    "Erro de transcrição em substituições"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um diagrama de blocos para um pêndulo invertido: θ'' = (g sinθ - b θ' - u)/l, com integradores para θ' e θ. Converta: x1=θ, x2=θ', ẙ_1 = x2, ẙ_2 = (g sin(x1) - b x2 - u)/l, y=x1.",
                              "finalVerifications": [
                                "Modelo tem número correto de estados igual a integradores.",
                                "Equações ẙ = f(x,u) contêm todas não-linearidades originais.",
                                "Simulação numérica reproduz resposta do diagrama para u=step.",
                                "Variáveis de estado são independentes e mínimas.",
                                "Saída y=h(x,u) matches sinal de saída do bloco.",
                                "Unidades e dimensionalidade consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de blocos e equações (90% cobertura).",
                                "Correta seleção de variáveis de estado (sem redundâncias).",
                                "Forma matricial não-linear válida e simulável.",
                                "Validação via simulação com erro <10%.",
                                "Documentação clara com passos reproduzíveis.",
                                "Tratamento adequado de não-linearidades sem linearização inadvertida."
                              ],
                              "crossCurricularConnections": [
                                "Controle Não-Linear: Base para linearização em torno de trim points.",
                                "Simulação Computacional: Implementação em ODE solvers (MATLAB ode45).",
                                "Dinâmica de Voos: Modelagem de aeronaves com aerodinâmica não-linear.",
                                "Matemática Aplicada: Sistemas de EDO não-lineares e teoria de Lyapunov.",
                                "Programação: Codificação em Python/MATLAB para análise."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, converte diagramas de dinâmica de voo não-linear (ex. stall, flaps) em modelos de espaço de estado para simulações de controle autônomo em drones ou aviões, permitindo design de controladores robustos como LQR não-linear ou MPC."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Analisar estabilidade qualitativa de sistemas não-lineares",
                            "description": "Avaliar pontos fixos e comportamentos qualitativos próximos a equilíbrios sem linearizar, usando conceitos como autônomos e fluxos vetoriais em exemplos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender sistemas autônomos e identificar pontos fixos",
                                  "subSteps": [
                                    "Revise a definição de sistemas autônomos: equações diferenciais onde o vetor de estado não depende explicitamente do tempo.",
                                    "Aprenda a encontrar pontos de equilíbrio resolvendo f(x) = 0 para sistemas dx/dt = f(x).",
                                    "Pratique com exemplos unidimensionais, como dx/dt = x - x².",
                                    "Estenda para sistemas bidimensionais, identificando múltiplos pontos fixos.",
                                    "Desenhe os pontos fixos em um plano de fase."
                                  ],
                                  "verification": "Liste corretamente todos os pontos fixos de um sistema dado e justifique.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Sistemas Dinâmicos (ex: Perko), papel e lápis, software como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Comece com sistemas 1D para ganhar confiança antes de 2D.",
                                  "learningObjective": "Identificar e localizar pontos de equilíbrio em sistemas autônomos não-lineares.",
                                  "commonMistakes": [
                                    "Confundir pontos fixos com soluções triviais",
                                    "Ignorar multiplicidade ou condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e interpretar fluxos vetoriais ou campos de direção",
                                  "subSteps": [
                                    "Aprenda a plotar o campo vetorial: em uma grade de pontos (x,y), compute f(x,y) e desenhe setas proporcionais.",
                                    "Use software para gerar plots automáticos (ex: quiver no MATLAB ou Python).",
                                    "Interprete o fluxo: direção das trajetórias próximas aos pontos fixos.",
                                    "Trace trajetórias nulas e observe convergência/divergência.",
                                    "Pratique com exemplos como o modelo Lotka-Volterra simplificado."
                                  ],
                                  "verification": "Gere e descreva um campo vetorial correto para um sistema dado, destacando padrões.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software: MATLAB, Python (numpy, matplotlib), ou Desmos para 1D",
                                    "Exemplos de problemas impressos"
                                  ],
                                  "tips": "Escolha uma grade fina para visualização clara; normalize vetores para evitar setas muito longas.",
                                  "learningObjective": "Visualizar qualitativamente o comportamento dinâmico via fluxos vetoriais.",
                                  "commonMistakes": [
                                    "Escala errada nas setas levando a interpretações falsas",
                                    "Ignorar a magnitude do vetor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar estabilidade qualitativa dos pontos fixos",
                                  "subSteps": [
                                    "Defina tipos: attractor (sink), repeller (source), saddle, center, etc.",
                                    "Use o teorema de linearização qualitativa: analise sinal do fluxo em vizinhanças.",
                                    "Aplique testes: convergência de trajetórias (estável), divergência (instável), oscilações.",
                                    "Diferencie casos hiperbólicos de não-hiperbólicos.",
                                    "Pratique classificação em 5 exemplos variados."
                                  ],
                                  "verification": "Classifique corretamente a estabilidade de 3 pontos fixos em um sistema com justificativa qualitativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Diagramas de fase prontos para análise",
                                    "Tabela de referência de classificações",
                                    "Software para simulações numéricas (ode45 no MATLAB)"
                                  ],
                                  "tips": "Pense em 'setas apontando para dentro' para sinks; teste múltiplas direções próximas.",
                                  "learningObjective": "Avaliar estabilidade sem computar autovalores, baseado em fluxos.",
                                  "commonMistakes": [
                                    "Classificar baseado só em 1D",
                                    "Confundir saddle com center"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise em exemplos aeronáuticos simples",
                                  "subSteps": [
                                    "Escolha modelo não-linear: ex. equações de atitude de aeronave com termos cúbicos.",
                                    "Identifique pontos fixos (equilíbrio de voo).",
                                    "Plote fluxo vetorial e classifique estabilidade (ex. spin recovery).",
                                    "Simule trajetórias numéricas para validar análise qualitativa.",
                                    "Discuta limitações e quando linearizar é necessário."
                                  ],
                                  "verification": "Produza relatório completo de análise para um exemplo aeronáutico dado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Modelos específicos de aeronáutica (ex. short-period approximation não-linear)",
                                    "Python/MATLAB para simulação",
                                    "Artigos sobre dinâmica de voo"
                                  ],
                                  "tips": "Integre com contexto de engenharia: foque em regimes de voo críticos.",
                                  "learningObjective": "Integrar análise qualitativa a problemas reais de sistemas dinâmicos aeronáuticos.",
                                  "commonMistakes": [
                                    "Over-simplificar modelo ignorando não-linearidades chave",
                                    "Não validar com simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema bidimensional autônomo dx/dt = y, dy/dt = -x - x³ (pêndulo não-linear Duffing). Identifique o ponto fixo (0,0), plote o campo vetorial mostrando oscilações amortecidas, e classifique como attractor centro-like para pequenas amplitudes, mas verifique estabilidade qualitativa via fluxo.",
                              "finalVerifications": [
                                "Identifica todos os pontos fixos corretamente em um sistema dado.",
                                "Gera campo vetorial preciso e interpreta padrões de fluxo.",
                                "Classifica estabilidade com justificativa qualitativa sem linearização.",
                                "Valida análise com trajetórias simuladas.",
                                "Discute limitações da abordagem qualitativa.",
                                "Aplica corretamente a um exemplo aeronáutico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de pontos fixos (100% corretos).",
                                "Qualidade e correção do campo vetorial/diagrama de fase.",
                                "Correta classificação de estabilidade com evidências visuais.",
                                "Profundidade da interpretação qualitativa (fluxo, convergência).",
                                "Integração com simulações numéricas para validação.",
                                "Clareza na comunicação do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de osciladores não-lineares (pêndulos, vibrações).",
                                "Biologia: Modelos populacionais (predador-presa autônomos).",
                                "Computação: Simulações numéricas e visualização de dados.",
                                "Engenharia Mecânica: Estabilidade de estruturas e controle.",
                                "Matemática: Análise qualitativa de EDOs."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, analisar estabilidade qualitativa de modos de voo não-lineares como stall recovery ou spin, permitindo avaliações rápidas de segurança sem computação pesada, essencial para design de flight control systems."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Pontos de Equilíbrio",
                        "description": "Definição e cálculo de pontos de equilíbrio em sistemas não-lineares, onde \\dot{x} = 0 para u constante, representando condições de operação estacionária para linearização.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Calcular pontos de equilíbrio de um sistema não-linear",
                            "description": "Resolver f(x_e, u_e) = 0 para encontrar pares (x_e, u_e) de equilíbrio, utilizando métodos numéricos ou analíticos em sistemas de 2-3 estados, como pêndulos ou circuitos não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo do sistema não-linear e equações de equilíbrio",
                                  "subSteps": [
                                    "Identifique o sistema dinâmico não-linear dado por ẋ = f(x, u).",
                                    "Estabeleça as condições de equilíbrio: f(x_e, u_e) = 0.",
                                    "Especifique o número de estados (2-3) e entradas, definindo variáveis x_e e u_e.",
                                    "Escreva explicitamente as equações f_i(x_e, u_e) = 0 para cada estado.",
                                    "Documente o contexto físico, como pêndulo ou circuito."
                                  ],
                                  "verification": "Verifique se as equações f(x_e, u_e) = 0 estão corretamente transcritas e balanceadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo matemático do sistema",
                                    "Papel e caneta ou software como MATLAB/SymPy",
                                    "Referências teóricas sobre o sistema"
                                  ],
                                  "tips": [
                                    "Comece com sistemas simples de 2 estados para prática.",
                                    "Use notação vetorial para clareza."
                                  ],
                                  "learningObjective": "Compreender e formular precisamente as condições de equilíbrio para sistemas não-lineares.",
                                  "commonMistakes": [
                                    "Confundir equações dinâmicas com estáticas.",
                                    "Esquecer dependências entre estados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar métodos analíticos para solução",
                                  "subSteps": [
                                    "Tente resolver algebraicamente f(x_e, u_e) = 0 isolando variáveis.",
                                    "Para sistemas de 2 estados, substitua e resolva quadraticamente ou por inspeção.",
                                    "Use ferramentas simbólicas como SymPy para equações polinomiais.",
                                    "Liste todas as soluções reais e descarte complexas ou não-físicas.",
                                    "Calcule valores numéricos aproximados das soluções analíticas."
                                  ],
                                  "verification": "Substitua as soluções encontradas de volta em f(x_e, u_e) e confirme que resulta em zero.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico (SymPy, Mathematica)",
                                    "Calculadora gráfica",
                                    "Folha de exercícios com exemplos"
                                  ],
                                  "tips": [
                                    "Priorize soluções triviais como x_e = 0.",
                                    "Verifique domínios físicos das soluções."
                                  ],
                                  "learningObjective": "Dominar resolução analítica de equações não-lineares de baixa dimensão.",
                                  "commonMistakes": [
                                    "Ignorar múltiplas raízes.",
                                    "Erros em manipulações algébricas simples."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar métodos numéricos para casos complexos",
                                  "subSteps": [
                                    "Escolha um método como Newton-Raphson ou fsolve, definindo função residual r(x,u) = f(x,u).",
                                    "Forneça chute inicial razoável baseado em conhecimento físico.",
                                    "Implemente em código (MATLAB/Python) com Jacobiana se necessário.",
                                    "Execute iterações até convergência (tolerância < 1e-6).",
                                    "Varie chutes iniciais para encontrar múltiplos pontos de equilíbrio."
                                  ],
                                  "verification": "Confirme convergência e resíduo |f(x_e, u_e)| < 1e-8; plote trajetórias para visualização.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy fsolve)",
                                    "Exemplo de código template",
                                    "Computador"
                                  ],
                                  "tips": [
                                    "Use chutes próximos a equilíbrios conhecidos.",
                                    "Monitore iterações para evitar divergência."
                                  ],
                                  "learningObjective": "Aplicar e codificar solvers numéricos para equações não-lineares.",
                                  "commonMistakes": [
                                    "Chute inicial ruim levando a não-convergência.",
                                    "Não computar Jacobiana corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar os pontos de equilíbrio",
                                  "subSteps": [
                                    "Compare soluções analíticas e numéricas para consistência.",
                                    "Avalie viabilidade física (ex: ângulos reais em pêndulo).",
                                    "Plote o espaço de fase ou superfícies nulas de f para visualização.",
                                    "Registre pares (x_e, u_e) com precisão e contexto.",
                                    "Discuta implicações para linearização futura."
                                  ],
                                  "verification": "Todos os pontos listados satisfazem f(x_e, u_e) = 0 e são fisicamente plausíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot, Python Matplotlib)",
                                    "Relatório template"
                                  ],
                                  "tips": [
                                    "Use gráficos para identificar pontos perdidos.",
                                    "Documente sensibilidade a parâmetros."
                                  ],
                                  "learningObjective": "Validar resultados e conectá-los ao contexto de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Aceitar soluções numéricas sem verificação residual.",
                                    "Omitir pontos instáveis mas válidos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo duplo não-linear com estados [θ1, ω1, θ2, ω2] e entrada u (torque), resolva f(θ1_e, ω1_e, θ2_e, ω2_e, u_e) = 0. Solução analítica: ω1_e = ω2_e = 0, θ1_e = θ2_e = 0 ou π (equilíbrios pendulares e invertidos), ajustando u_e para torque de equilíbrio.",
                              "finalVerifications": [
                                "Todos os pares (x_e, u_e) satisfazem exatamente f(x_e, u_e) = 0.",
                                "Múltiplos equilíbrios (se aplicável) foram identificados variando chutes iniciais.",
                                "Soluções são fisicamente viáveis no contexto do sistema.",
                                "Resultados analíticos coincidem com numéricos dentro de tolerância.",
                                "Gráficos confirmam nulidade das funções em pontos encontrados.",
                                "Documentação inclui equações, código e valores precisos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações de equilíbrio formuladas (100% corretas).",
                                "Número e qualidade das soluções encontradas (todos os reais identificados).",
                                "Correta implementação e convergência numérica.",
                                "Validação rigorosa com resíduos e plots.",
                                "Clareza na documentação e discussão física.",
                                "Eficiência temporal e escolha de métodos apropriados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo numérico e álgebra não-linear.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Programação: Implementação de solvers em Python/MATLAB.",
                                "Controle Automático: Base para linearização e estabilização.",
                                "Engenharia: Análise de estabilidade em aeronaves."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular pontos de equilíbrio de modelos não-lineares de flight dynamics (ex: stall ou hover em drones) é essencial para projetar controladores que estabilizem aeronaves em manobras críticas, simulando condições de voo reais em software como X-Plane ou MATLAB Simulink."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Verificar condições de equilíbrio em exemplos físicos",
                            "description": "Aplicar o conceito de equilíbrio em sistemas reais como tanques hidráulicos ou braços robóticos, confirmando estabilidade local via linearização preliminar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Modelar o Sistema Físico Não-Linear",
                                  "subSteps": [
                                    "Escolha um exemplo físico real, como um tanque hidráulico ou braço robótico invertido.",
                                    "Identifique as variáveis de estado (ex: nível h no tanque, ângulo θ no braço).",
                                    "Escreva as equações diferenciais não-lineares governantes (ex: dh/dt = (Qin - k√h)/A para tanque).",
                                    "Defina entradas de controle u e parâmetros do sistema.",
                                    "Documente todas as equações em forma vetorial ẋ = f(x,u)."
                                  ],
                                  "verification": "Equações não-lineares corretamente derivadas e coincidem com referências padrão do sistema escolhido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, software de simulação como MATLAB/Simulink (opcional), referências teóricas de dinâmica não-linear.",
                                  "tips": "Comece com um sistema de baixa ordem (1-2 estados) para simplicidade inicial.",
                                  "learningObjective": "Compreender e formular modelos matemáticos precisos de sistemas físicos reais.",
                                  "commonMistakes": "Esquecer termos não-lineares como √h ou sen(θ); confundir estados com saídas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar Pontos de Equilíbrio",
                                  "subSteps": [
                                    "Defina condições de equilíbrio: ẋ = 0 para entrada constante u = ue.",
                                    "Substitua nas equações: f(xe, ue) = 0.",
                                    "Resolva o sistema algébrico para xe (ex: he = (Qin/k)^2 para tanque).",
                                    "Verifique se o ponto é fisicamente viável (ex: h > 0).",
                                    "Liste todos os pontos de equilíbrio possíveis."
                                  ],
                                  "verification": "Pontos xe calculados satisfazem f(xe, ue) = 0 numericamente (erro < 1e-6).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou solver simbólico (MATLAB syms), equações do Step 1.",
                                  "tips": "Use substituição backward para resolver equações implícitas.",
                                  "learningObjective": "Identificar configurações estáticas onde o sistema permanece sem perturbações.",
                                  "commonMistakes": "Ignorar restrições físicas como h ≥ 0; múltiplas soluções não verificadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Linearização Preliminar ao Redor do Equilíbrio",
                                  "subSteps": [
                                    "Compute a matriz Jacobiana ∂f/∂x em (xe, ue) para formar A = Df(xe,ue).",
                                    "Compute ∂f/∂u para B.",
                                    "Forme o modelo linearizado: δẋ = A δx + B δu.",
                                    "Verifique dimensionalidade: A é n x n para n estados.",
                                    "Simplifique expressões analiticamente se possível."
                                  ],
                                  "verification": "Matrizes A e B derivadas corretamente por diferenciação parcial e avaliadas em xe.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (MATLAB Symbolic Toolbox), papel para derivações manuais.",
                                  "tips": "Use regra da cadeia para termos compostos; numéricas para validação.",
                                  "learningObjective": "Aplicar linearização de Taylor para aproximar sistemas não-lineares localmente.",
                                  "commonMistakes": "Erro na ordem de diferenciação; esquecer avaliação em (xe,ue)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Local via Análise Espectral",
                                  "subSteps": [
                                    "Calcule autovalores λi da matriz A.",
                                    "Verifique partes reais Re(λi) < 0 para todos i (estável).",
                                    "Analise multiplicidades ou modos oscilatórios se Re(λi)=0.",
                                    "Compare com critérios como Routh-Hurwitz para validação.",
                                    "Documente conclusão: estável, instável ou neutro."
                                  ],
                                  "verification": "Autovalores computados coincidem com solver numérico (ex: eig(A) no MATLAB).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB ou Python (numpy.linalg.eig), matriz A do Step 3.",
                                  "tips": "Para sistemas reais, foque em Re(λ) dominante.",
                                  "learningObjective": "Interpretar espectro da matriz linearizada para prever comportamento local.",
                                  "commonMistakes": "Confundir autovalores com autovetores; ignorar parte imaginária."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Simulação Numérica",
                                  "subSteps": [
                                    "Simule o sistema não-linear e linearizado com perturbação inicial δx0.",
                                    "Plote trajetórias de x(t) para ambos modelos.",
                                    "Compare convergência ao equilíbrio.",
                                    "Ajuste parâmetros se discrepâncias >5%.",
                                    "Conclua sobre validade da aproximação local."
                                  ],
                                  "verification": "Simulações mostram convergência similar para pequenas perturbações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ode45 ou Simulink, código de simulação pronto.",
                                  "tips": "Use perturbações pequenas (1% de xe) para validade linear.",
                                  "learningObjective": "Conectar teoria linearizada com comportamento dinâmico simulado.",
                                  "commonMistakes": "Perturbações grandes invalidam linearização; escalas de plot erradas."
                                }
                              ],
                              "practicalExample": "Em um tanque hidráulico com dh/dt = (Qin - 0.1√h)/10, para Qin=1, encontre he≈100, linearize A=[-0.0005], confirme Re(λ)=-0.0005<0 (estável), simule perturbação h(0)=105 convergindo a 100.",
                              "finalVerifications": [
                                "Equações não-lineares e pontos de equilíbrio corretos.",
                                "Matriz A linearizada precisa e autovalores calculados.",
                                "Estabilidade local confirmada por Re(λ)<0.",
                                "Simulações validam aproximação para perturbações pequenas.",
                                "Conclusões documentadas com plots e valores numéricos.",
                                "Fisicamente viável e consistente com contexto aeronáutico."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Correta identificação e análise de equilíbrio/estabilidade.",
                                "Qualidade das simulações e interpretação de resultados.",
                                "Documentação clara com equações, plots e conclusões.",
                                "Aplicação correta ao exemplo físico escolhido.",
                                "Profundidade na discussão de limitações da linearização."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Projeto de controladores lineares baseados em A/B.",
                                "Mecânica dos Sólidos/Fluidos: Modelagem de sistemas físicos reais.",
                                "Álgebra Linear: Computação de autovalores e Jacobianas.",
                                "Programação Computacional: Simulações em MATLAB/Python.",
                                "Engenharia de Controle Aeronáutico: Estabilização de aeronaves."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, verifica estabilidade de pontos de equilíbrio em sistemas como atuadores hidráulicos de flaps ou braços robóticos de montagem, permitindo design de controladores que mantêm aeronaves estáveis durante manobras, prevenindo oscilações catastróficas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Técnica de Linearização via Série de Taylor",
                        "description": "Aproximação de primeira ordem de funções não-lineares em torno de pontos de equilíbrio usando expansão em série de Taylor multivariable, resultando em modelo linear \\dot{\\delta x} = A \\delta x + B \\delta u e \\delta y = C \\delta x + D \\delta u.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Derivar as matrizes jacobianas A, B, C e D",
                            "description": "Calcular as derivadas parciais ∂f/∂x |_{(x_e,u_e)} = A, ∂f/∂u = B, ∂h/∂x = C e ∂h/∂u = D para um sistema dado, usando regras de diferenciação matricial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo do sistema não-linear",
                                  "subSteps": [
                                    "Identifique as funções vetoriais f(x, u) e h(x, u) do sistema dado, onde \\dot{x} = f(x, u) e y = h(x, u).",
                                    "Determine as dimensões: x ∈ ℝⁿ, u ∈ ℝᵐ, y ∈ ℝᵖ.",
                                    "Revise regras de diferenciação matricial: derivadas parciais de funções vetoriais resultam em matrizes Jacobianas.",
                                    "Anote o ponto de linearização (x_e, u_e) se fornecido, ou prepare para calculá-lo.",
                                    "Esboce o sistema em papel para visualizar dependências."
                                  ],
                                  "verification": "Lista completa de f, h, dimensões e ponto de linearização anotada corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Papel e caneta, documento do sistema (equações), software simbólico (MATLAB Symbolic ou SymPy).",
                                  "tips": "Comece sempre pelas dimensões para evitar erros de shape nas matrizes.",
                                  "learningObjective": "Entender a estrutura do sistema não-linear e preparar para linearização.",
                                  "commonMistakes": "Confundir f (dinâmica) com h (saída); ignorar dimensões vetoriais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o ponto de equilíbrio (x_e, u_e)",
                                  "subSteps": [
                                    "Resolva f(x_e, u_e) = 0 para encontrar o equilíbrio estacionário.",
                                    "Se múltiplos pontos, selecione o relevante para o contexto (ex: voo nivelado em aeronáutica).",
                                    "Verifique se h(x_e, u_e) é consistente com condições de saída desejadas.",
                                    "Calcule valores numéricos ou simbólicos exatos.",
                                    "Documente os valores em uma tabela."
                                  ],
                                  "verification": "Confirme que f(x_e, u_e) = 0 vetor zero e valores anotados.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Calculadora ou solver numérico (fsolve no MATLAB/Python), equações do sistema.",
                                  "tips": "Use substituição iterativa se analítico difícil; priorize soluções estáveis.",
                                  "learningObjective": "Localizar precisamente o ponto de equilíbrio para avaliação das derivadas.",
                                  "commonMistakes": "Não resolver para u_e também; assumir x_e=0 sem verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as matrizes Jacobianas A e B da dinâmica",
                                  "subSteps": [
                                    "Compute A = ∂f/∂x |_{(x_e,u_e)}, calculando cada entrada ∂f_i/∂x_j no ponto.",
                                    "Aplique regras: para f_i = g(x_k, u_l), use chain rule ∂g/∂x_k * ∂x_k/∂x_j.",
                                    "Compute B = ∂f/∂u |_{(x_e,u_e)} similarmente, cada ∂f_i/∂u_l.",
                                    "Use software para simplificar expressões simbólicas.",
                                    "Verifique simetria ou propriedades esperadas (ex: A diagonal dominante)."
                                  ],
                                  "verification": "Matrizes A (n×n) e B (n×m) com todas entradas corretas no ponto de equilíbrio.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Software simbólico (SymPy para Python, Symbolic Math Toolbox MATLAB), papel para rascunhos.",
                                  "tips": "Diferencie elemento a elemento; avalie sempre em (x_e, u_e) após derivar.",
                                  "learningObjective": "Dominar derivação de Jacobianas para equações dinâmicas não-lineares.",
                                  "commonMistakes": "Derivar sem avaliar no equilíbrio; erro em chain rule para produtos/quotientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular as matrizes Jacobianas C e D da saída",
                                  "subSteps": [
                                    "Compute C = ∂h/∂x |_{(x_e,u_e)}, cada ∂h_k/∂x_j.",
                                    "Compute D = ∂h/∂u |_{(x_e,u_e)}, cada ∂h_k/∂u_l.",
                                    "Simplifique expressões e avalie numericamente se possível.",
                                    "Confirme dimensões: C (p×n), D (p×m).",
                                    "Compare com modelo linearizado esperado."
                                  ],
                                  "verification": "Matrizes C e D corretas, dimensões certas e avaliadas no equilíbrio.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Mesmo software simbólico, resultados de passos anteriores.",
                                  "tips": "Saídas h são frequentemente lineares, então C/D podem ser constantes.",
                                  "learningObjective": "Aplicar derivação Jacobiana a funções de saída.",
                                  "commonMistakes": "Esquecer ∂/∂u em D se h depender de u (feedthrough)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar as matrizes linearizadas",
                                  "subSteps": [
                                    "Verifique dimensões e se derivadas zeram corretamente (ex: numéricas próximas de zero).",
                                    "Substitua em aproximação linear: δ\\dot{x} ≈ A δx + B δu, δy ≈ C δx + D δu.",
                                    "Analise autovalores de A para estabilidade.",
                                    "Compare com simulação numérica curta.",
                                    "Documente em relatório com matrizes finais."
                                  ],
                                  "verification": "Todas matrizes validadas numericamente e interpretadas.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": "Software numérico (MATLAB ode45 ou Python scipy.integrate), eigenvalues.",
                                  "tips": "Use limite pequeno δx para testar linearização via simulação.",
                                  "learningObjective": "Validar e interpretar o modelo linearizado.",
                                  "commonMistakes": "Ignorar feedthrough D; não checar estabilidade."
                                }
                              ],
                              "practicalExample": "Para um modelo simplificado de atitude de aeronave: \\dot{x} = [sin(x1) + u1; x1*x2 + u2], y = [x1; x2], equilíbrio (x_e,u_e)=(0,0). Então A = [[cos(0), 0]; [0, 0]] = [[1,0];[0,0]], B=[[1,0];[0,1]], C=[[1,0];[0,1]], D=0. Calcule manualmente e verifique com SymPy.",
                              "finalVerifications": [
                                "Dimensões corretas: A(n×n), B(n×m), C(p×n), D(p×m).",
                                "Avaliação exata em (x_e, u_e): derivadas não avaliadas resultam em erro.",
                                "Verificação numérica: perturbação pequena reproduz modelo linear.",
                                "Autovalores de A consistentes com linearização esperada.",
                                "Sem erros de sinal ou transposição em regras de derivada.",
                                "D feedthrough correto se h depende de u."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas parciais elemento a elemento (90% correto).",
                                "Correta avaliação no ponto de equilíbrio.",
                                "Uso apropriado de regras matriciais (chain/product rule).",
                                "Validação dimensional e numérica.",
                                "Interpretação qualitativa (estabilidade, acoplamento).",
                                "Clareza na documentação de cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Avançada: Cálculo vetorial e multivariável.",
                                "Controle Automático: Uso em design de LQR/LQG controladores.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos.",
                                "Simulação Numérica: Integração com solvers ODE."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, essas matrizes são essenciais para linearizar modelos não-lineares de voo (ex: 6-DOF aircraft dynamics) ao redor de trim conditions como voo nivelado, permitindo design de controladores lineares como PID ou state-feedback para autopilot systems em aviões comerciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Construir o modelo linearizado completo",
                            "description": "Combinar as matrizes jacobianas para formar o modelo linearizado em variáveis de desvio (δx = x - x_e, etc.), validando com simulações numéricas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir variáveis de desvio e preparar matrizes Jacobianas",
                                  "subSteps": [
                                    "Identifique o ponto de equilíbrio (x_e, u_e, y_e) do sistema não-linear.",
                                    "Defina δx = x - x_e, δu = u - u_e, δy = y - y_e.",
                                    "Recupere as matrizes Jacobianas calculadas: A = ∂f/∂x|_{eq}, B = ∂f/∂u|_{eq}, C = ∂h/∂x|_{eq}, D = ∂h/∂u|_{eq}.",
                                    "Verifique dimensões: A (n x n), B (n x m), C (p x n), D (p x m), onde n=estados, m=entradas, p=saídas.",
                                    "Anote as expressões matriciais em um documento ou caderno."
                                  ],
                                  "verification": "Confirme que δx, δu, δy estão definidos corretamente e que as Jacobianas têm dimensões compatíveis com o sistema.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Caderno ou editor de texto",
                                    "Matrizes Jacobianas de passos anteriores",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Use notação consistente para evitar confusões entre variáveis originais e de desvio.",
                                  "learningObjective": "Compreender a transformação para coordenadas desviadas em torno do equilíbrio.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair o ponto de equilíbrio nas definições de δ",
                                    "Inverter dimensões das matrizes Jacobianas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formar as equações do modelo linearizado em espaço de estados",
                                  "subSteps": [
                                    "Escreva δẋ = A δx + B δu.",
                                    "Escreva δy = C δx + D δu.",
                                    "Expanda as matrizes se necessário, substituindo elementos numéricos ou simbólicos das Jacobianas.",
                                    "Verifique se o modelo em equilíbrio satisfaz: A x_e + B u_e = 0 (para δx=0, δu=0).",
                                    "Simplifique expressões se houver dependências lineares ou zeros."
                                  ],
                                  "verification": "Substitua δx=0, δu=0 e confirme que δẋ=0 e δy=y_e - y_e=0.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel milimetrado ou LaTeX/MATLAB para equações",
                                    "Valores numéricos do ponto de equilíbrio"
                                  ],
                                  "tips": "Mantenha o modelo em forma matricial compacta para facilitar simulações.",
                                  "learningObjective": "Montar o modelo linearizado completo a partir das derivadas parciais.",
                                  "commonMistakes": [
                                    "Não validar o equilíbrio no modelo linearizado",
                                    "Confundir A com C ou B com D"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o modelo linearizado em simulador numérico",
                                  "subSteps": [
                                    "Configure o simulador (ex: MATLAB ode45 ou Python scipy.integrate.odeint).",
                                    "Codifique o modelo não-linear original f(x,u) e h(x,u).",
                                    "Codifique o modelo linearizado: δẋ = A δx + B δu, integrando de volta para x = x_e + δx.",
                                    "Defina condições iniciais próximas ao equilíbrio (pequenos desvios).",
                                    "Execute simulações para ambos os modelos com a mesma entrada δu(t)."
                                  ],
                                  "verification": "Execute uma simulação de 10-20 segundos e plote δx NL vs δx L.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (NumPy, SciPy, Matplotlib)",
                                    "Código-fonte do sistema não-linear"
                                  ],
                                  "tips": "Use entradas δu senoidais pequenas para testar linearidade.",
                                  "learningObjective": "Implementar e simular modelos lineares para verificação prática.",
                                  "commonMistakes": [
                                    "Erros de indexação em matrizes no código",
                                    "Condições iniciais grandes que invalidam linearização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar o modelo linearizado por comparação numérica",
                                  "subSteps": [
                                    "Gere plots de trajetórias: estados NL vs L para múltiplas simulações.",
                                    "Calcule erros: RMSE = sqrt(mean((δx_NL - δx_L)^2)) para cada estado.",
                                    "Compare respostas em frequência (Bode ou FFT se aplicável).",
                                    "Ajuste tolerâncias: erro < 5% em região linear (||δx|| < 10% do range).",
                                    "Documente limitações: região de validade da aproximação."
                                  ],
                                  "verification": "Confirme RMSE baixo (<1e-3 ou 5%) para desvios pequenos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot ou Matplotlib)",
                                    "Dados de simulação salvos"
                                  ],
                                  "tips": "Teste com perturbações crescentes para mapear região de validade.",
                                  "learningObjective": "Avaliar precisão da linearização via métricas quantitativas.",
                                  "commonMistakes": [
                                    "Ignorar offsets no plot que mascaram erros",
                                    "Usar escalas inadequadas nos gráficos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo invertido (modelo de estabilização de aeronave): f(θ, ω, u) com θ=0 (equilíbrio invertido). Jacobianas A=[0 1; 9.8/L 0], B=[0; 1/mL^2]. Simule δθ com u=sen(0.1t), compare NL vs L: trajetórias coincidem para |δθ|<0.1 rad.",
                              "finalVerifications": [
                                "Modelo em equilíbrio: δẋ=0 quando δx=0, δu=0.",
                                "Dimensões matriciais corretas e elementos coincidem com Jacobianas.",
                                "Simulações mostram sobreposição de trajetórias para desvios pequenos.",
                                "RMSE dos estados <5% do sinal.",
                                "Região de validade documentada (ex: ||δx|| < 10%).",
                                "Código reproduzível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de variáveis de desvio e montagem de A,B,C,D (90% correto).",
                                "Implementação numérica sem erros de codificação.",
                                "Validação quantitativa com métricas (RMSE, gráficos comparativos).",
                                "Identificação correta de erros comuns e limitações.",
                                "Clareza na documentação das equações e resultados.",
                                "Eficiência temporal: conclusão em <2 horas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear (matrizes Jacobianas).",
                                "Programação: Simulação numérica em MATLAB/Python (integração ODE).",
                                "Física: Dinâmica não-linear de sistemas aeronáuticos.",
                                "Controle Automático: Base para síntese de LQR/LQG.",
                                "Engenharia de Software: Validação e testes de modelos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, lineariza-se o modelo 6-DOF de uma aeronave em torno de condições de trim (voo nivelado) para projetar leis de controle de estabilidade aumentada, como em fly-by-wire do F-16, validando com simulações em X-Plane ou MATLAB antes de testes em voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Aplicar linearização em sistemas de engenharia",
                            "description": "Realizar linearização de um sistema eletromecânico ou térmico em torno de um equilíbrio, comparando respostas linear e não-linear via MATLAB ou similar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o sistema não-linear e determinar o ponto de equilíbrio",
                                  "subSteps": [
                                    "Escolha um sistema eletromecânico ou térmico relevante, como um pêndulo invertido ou um trocador de calor.",
                                    "Escreva as equações diferenciais não-lineares que descrevem o sistema.",
                                    "Resolva as equações para encontrar os pontos de equilíbrio estável ou instável.",
                                    "Verifique as condições de equilíbrio definindo derivadas temporais iguais a zero.",
                                    "Documente as variáveis de estado e entradas do sistema."
                                  ],
                                  "verification": "Confirme que as equações de equilíbrio resultam em derivadas nulas e plote o diagrama de fase próximo ao ponto.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Papel e caneta ou software como MATLAB para equações simbólicas; referência teórica de dinâmica não-linear.",
                                  "tips": "Comece com sistemas clássicos como pêndulo para familiarizar; anote todas as variáveis explicitamente.",
                                  "learningObjective": "Compreender a representação matemática de sistemas não-lineares e localizar pontos de equilíbrio.",
                                  "commonMistakes": "Esquecer termos não-lineares nas equações ou confundir equilíbrio estável com instável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a linearização analítica via expansão em série de Taylor",
                                  "subSteps": [
                                    "Selecione o ponto de equilíbrio como centro de expansão (x0, u0).",
                                    "Compute as derivadas parciais das funções não-lineares em relação a estados (A = df/dx) e entradas (B = df/du).",
                                    "Aplique a aproximação de primeira ordem: δẋ = A δx + B δu.",
                                    "Ignore termos de ordem superior para validação inicial.",
                                    "Simplifique a matriz jacobiana e verifique simetria ou propriedades especiais."
                                  ],
                                  "verification": "Compare a função linearizada com a original via plot de superfície ou Taylor remainder estimado.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Calculadora simbólica (MATLAB Symbolic Toolbox) ou software como Mathematica; quadro branco.",
                                  "tips": "Use syms no MATLAB para derivadas automáticas; sempre normalize variáveis para simplificar.",
                                  "learningObjective": "Dominar a técnica de linearização local usando jacobianas.",
                                  "commonMistakes": "Erro no cálculo de parciais ou não linearizar corretamente as saídas (C e D matrizes)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar os modelos linear e não-linear em MATLAB ou Simulink",
                                  "subSteps": [
                                    "Crie o script MATLAB para o modelo não-linear usando ode45.",
                                    "Converta o modelo linear para espaço de estados e use lsim ou step.",
                                    "Configure Simulink para ambos os modelos com blocos integradores.",
                                    "Defina condições iniciais próximas ao equilíbrio (pequenas perturbações).",
                                    "Adicione plots para estados vs tempo."
                                  ],
                                  "verification": "Execute simulações curtas e confirme que ambos os modelos rodam sem erros numéricos.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "MATLAB ou Octave com toolboxes de controle e Simulink; exemplos de código de repositórios open-source.",
                                  "tips": "Use funções como linearize() no Symbolic Toolbox para automação; teste com step responses.",
                                  "learningObjective": "Implementar modelos dinâmicos computacionalmente para análise.",
                                  "commonMistakes": "Escala errada nas perturbações iniciais ou solver inadequado para não-lineares rígidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, comparar respostas e analisar discrepâncias",
                                  "subSteps": [
                                    "Aplique a mesma entrada (ex: pulso ou seno) aos dois modelos.",
                                    "Plote trajetórias de estados superpostas para diferentes amplitudes.",
                                    "Calcule métricas como erro quadrático médio entre respostas.",
                                    "Analise regiões de validade da aproximação linear (ganho de fase, overshoot).",
                                    "Discuta limitações e quando usar linear vs não-linear."
                                  ],
                                  "verification": "As respostas coincidem para perturbações <10% do equilíbrio, divergindo para maiores.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Scripts MATLAB desenvolvidos; ferramentas de plot como subplot e legend.",
                                  "tips": "Varie amplitudes de entrada sistematicamente; use zoom nos plots iniciais.",
                                  "learningObjective": "Avaliar precisão da linearização através de simulações comparativas.",
                                  "commonMistakes": "Comparar em escalas muito amplas onde linearização falha ou ignorar ruído numérico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar resultados e documentar o processo",
                                  "subSteps": [
                                    "Compare com literatura ou dados experimentais se disponíveis.",
                                    "Gere relatório com equações, códigos e plots.",
                                    "Teste sensibilidade a parâmetros do sistema.",
                                    "Proponha melhorias como linearização em múltiplos pontos.",
                                    "Arquive código em repositório versionado."
                                  ],
                                  "verification": "Relatório completo com conclusões claras sobre validade da linearização.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor LaTeX ou Word para relatório; GitHub para código.",
                                  "tips": "Inclua seções de 'lições aprendidas'; cite referências como Khalil 'Nonlinear Systems'.",
                                  "learningObjective": "Sintetizar análise e comunicar achados de forma profissional.",
                                  "commonMistakes": "Omitir unidades ou legendas nos plots; superestimar validade da linearização."
                                }
                              ],
                              "practicalExample": "Considere um pêndulo invertido sobre um carrinho (sistema eletromecânico clássico em controle aeronáutico). Linearize as equações não-lineares em torno da posição vertical superior instável, implemente em MATLAB/Simulink e compare respostas a uma perturbação angular de 5° vs 20° para uma entrada de força no carrinho.",
                              "finalVerifications": [
                                "Matrizes A e B da linearização são corretas via cálculo manual e simbólico.",
                                "Simulações mostram concordância <5% de erro para pequenas perturbações.",
                                "Plots de fase confirmam trajetórias similares próximas ao equilíbrio.",
                                "Código roda reproduzivelmente em diferentes máquinas.",
                                "Relatório documenta limitações e aplicações.",
                                "Comparação com modelo teórico de referência coincide."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação analítica (30%): Jacobianas corretas e simplificadas.",
                                "Implementação computacional (25%): Código limpo, eficiente e comentado.",
                                "Análise comparativa (20%): Plots claros com métricas quantitativas.",
                                "Validação e interpretação (15%): Discussão de validade e erros.",
                                "Documentação (10%): Relatório completo e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansões em série de Taylor e cálculo multivariável.",
                                "Programação: Modelagem numérica em MATLAB/Simulink e análise de dados.",
                                "Física: Dinâmica não-linear e estabilidade de equilíbrio.",
                                "Engenharia de Controle: Projeto de controladores lineares baseados em linearização.",
                                "Engenharia Aeronáutica: Modelagem de instabilidades em voo."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a linearização é essencial para projetar sistemas de controle de estabilidade em aeronaves, como estabilização de atitude em drones ou aviões, onde equações não-lineares de aerodinâmica são aproximadas em torno de condições de trim para sintetizar controladores LQR ou PID."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Avaliar validade da aproximação linear",
                            "description": "Determinar o raio de validade da linearização analisando termos de segunda ordem da série de Taylor e simulando desvios pequenos vs. grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Expansão de Taylor e Linearização do Sistema Não-Linear",
                                  "subSteps": [
                                    "Identifique o ponto de linearização (equilíbrio ou condição operacional nominal).",
                                    "Escreva a equação diferencial não-linear do sistema.",
                                    "Expanda a função não-linear f(x) em série de Taylor em torno do ponto x0: f(x) ≈ f(x0) + f'(x0)(x-x0) + (1/2)f''(x0)(x-x0)^2 + ...",
                                    "Derive a aproximação linear: δẋ = A δx, onde A = ∂f/∂x |_{x0}.",
                                    "Discuta o papel dos termos de ordem superior na precisão da aproximação."
                                  ],
                                  "verification": "Confirme que a aproximação linear é corretamente derivada e o termo quadrático é isolado na expansão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica (ex: SymPy ou MATLAB Symbolic Toolbox)",
                                  "tips": "Sempre normalize as variáveis de desvio (δx = x - x0) para simplificar cálculos.",
                                  "learningObjective": "Compreender os fundamentos matemáticos da linearização via Taylor e identificar componentes lineares e não-lineares.",
                                  "commonMistakes": [
                                    "Esquecer de avaliar as derivadas no ponto exato x0.",
                                    "Confundir termos lineares com quadráticos durante a expansão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os Termos de Segunda Ordem da Série de Taylor",
                                  "subSteps": [
                                    "Calcule a matriz jacobiana A = ∂f/∂x |_{x0} para o termo linear.",
                                    "Calcule o tensor hessiano H = ∂²f/∂x² |_{x0} para o termo quadrático: (1/2) δx^T H δx.",
                                    "Expresse o termo de segunda ordem completo na dinâmica: δẋ ≈ A δx + (1/2) H(δx, δx).",
                                    "Implemente numericamente ou simbolicamente para um sistema específico.",
                                    "Verifique dimensionalidade e unidades dos termos calculados."
                                  ],
                                  "verification": "Os termos lineares e quadráticos devem coincidir com derivações analíticas conhecidas para sistemas padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de computação simbólica (MATLAB, Python com SymPy), exemplos de sistemas não-lineares",
                                  "tips": "Use funções vectorizadas em software para evitar erros de indexação em matrizes Hessianas.",
                                  "learningObjective": "Dominar o cálculo preciso de termos de segunda ordem para quantificar não-linearidades locais.",
                                  "commonMistakes": [
                                    "Erro na avaliação do Hessiano (derivadas parciais incorretas).",
                                    "Ignorar dependência em variáveis de estado múltiplas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Contribuição Relativa dos Termos de Segunda Ordem",
                                  "subSteps": [
                                    "Defina uma métrica de erro: |termo quadrático| / |termo linear| < ε (ex: ε=0.05 para 5%).",
                                    "Plote ou tabule a razão em função do desvio δx para diferentes direções.",
                                    "Determine o raio de validade r como max{||δx|| : razão < ε}.",
                                    "Analise anisotropia: raio varia por direção no espaço de estados.",
                                    "Compare com bounds teóricos (ex: resto de Lagrange na série de Taylor)."
                                  ],
                                  "verification": "Gráficos mostram região onde termo quadrático é negligible (<5% do linear).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (MATLAB plot, Python Matplotlib), dados numéricos dos passos anteriores",
                                  "tips": "Escolha ε baseado no contexto de aplicação (mais estrito para controle preciso).",
                                  "learningObjective": "Avaliar quantitativamente quando a aproximação linear é válida com base em análise de erro.",
                                  "commonMistakes": [
                                    "Usar norma L1 em vez de L2 para vetores de desvio.",
                                    "Ignorar direção do desvio, assumindo isotropia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Desvios Pequenos vs. Grandes e Validar o Raio",
                                  "subSteps": [
                                    "Simule trajetórias com o modelo linear e não-linear para δx dentro e fora do raio r.",
                                    "Compare respostas em tempo (ex: overshoot, tempo de assentamento).",
                                    "Calcule métricas de erro: RMSE entre simulações linear e não-linear.",
                                    "Ajuste r iterativamente até que erro < threshold para desvios pequenos.",
                                    "Documente conclusões com visualizações de fase ou tempo."
                                  ],
                                  "verification": "Simulações mostram concordância boa para ||δx|| < r e divergência para ||δx|| > r.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador numérico (MATLAB Simulink, Python SciPy odeint), modelo do sistema",
                                  "tips": "Use passos de tempo pequenos na simulação para capturar dinâmica rápida.",
                                  "learningObjective": "Validar analiticamente o raio de validade através de simulações comparativas.",
                                  "commonMistakes": [
                                    "Condições iniciais inconsistentes entre modelos.",
                                    "Escala de tempo inadequada levando a erros numéricos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo duplo em equilíbrio vertical (modelo aeronáutico simplificado para estabilidade de rotorcraft): linearize em θ1=θ2=0, calcule Hessiano, determine r ≈ 0.1 rad onde termo quadrático <5% do linear, e simule desvios de 0.05 rad (boa approx.) vs. 0.3 rad (divergência).",
                              "finalVerifications": [
                                "Cálculo correto do Hessiano para o sistema dado.",
                                "Gráfico de razão quadrático/linear vs. ||δx|| identifica raio r claramente.",
                                "Simulações mostram erro RMSE <5% dentro de r e >20% fora.",
                                "Relatório resume raio de validade com justificativa quantitativa.",
                                "Análise considera direções críticas no espaço de estados.",
                                "Comparação com literatura ou casos conhecidos valida resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de Taylor (90%+ correção).",
                                "Definição rigorosa e justificada do raio de validade.",
                                "Qualidade das simulações e visualizações (clareza e legibilidade).",
                                "Análise de erros e sensibilidade a parâmetros.",
                                "Integração de teoria e prática na conclusão.",
                                "Documentação completa e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Taylor e análise de erros de aproximação.",
                                "Programação: Implementação numérica em Python/MATLAB para Hessiano e simulações.",
                                "Física: Dinâmica não-linear de sistemas mecânicos/aeroespaciais.",
                                "Controle: Limites de controladores lineares em regimes não-lineares.",
                                "Estatística: Métricas de erro como RMSE para validação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, avaliar o raio de validade da linearização de equações de movimento de uma aeronave em voo nivelado permite projetar controladores LQR válidos apenas em envelopes operacionais pequenos, evitando instabilidade em manobras agressivas como decolagens ou turbulências, otimizando simuladores de voo e certificação FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Conversão de Função de Transferência para Espaço de Estados",
                    "description": "Métodos para transformar representações em domínio de Laplace em modelos matriciais de espaço de estados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Forma Canônica Controlável",
                        "description": "Método padrão para converter uma função de transferência em representação de espaço de estados, onde a matriz A é em forma companheira e a matriz B é uma coluna de uns, facilitando a análise de controlabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Identificar coeficientes da função de transferência",
                            "description": "Extrair os coeficientes do polinômio característico e do numerador de uma função de transferência G(s) = N(s)/D(s) para sistemas lineares invariantes no tempo (LTI).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma padrão da função de transferência",
                                  "subSteps": [
                                    "Revise a definição de função de transferência G(s) = N(s)/D(s) para sistemas LTI.",
                                    "Identifique que N(s) é o polinômio do numerador e D(s) o do denominador (polinômio característico).",
                                    "Estude exemplos de funções de transferência de baixa e alta ordem.",
                                    "Anote a forma expandida: N(s) = b_m s^m + ... + b_0; D(s) = a_n s^n + ... + a_0.",
                                    "Compare com funções de transferência normalizadas (grau de D(s) >= N(s))."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre N(s) e D(s) com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Folha de anotações",
                                    "Exemplos de funções de transferência impressos"
                                  ],
                                  "tips": "Sempre normalize dividindo por coeficiente líder de D(s) para torná-lo 1.",
                                  "learningObjective": "Reconhecer a estrutura matemática de G(s) e seus componentes polinomiais.",
                                  "commonMistakes": [
                                    "Confundir numerador com denominador",
                                    "Ignorar normalização do coeficiente líder"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Separar numerador e denominador de G(s)",
                                  "subSteps": [
                                    "Escreva G(s) dada explicitamente.",
                                    "Circule ou destaque N(s) e D(s) na fração.",
                                    "Confirme os graus: deg(N) <= deg(D) para funções próprias.",
                                    "Reescreva G(s) destacando fração N(s)/D(s).",
                                    "Verifique se há fatores comuns para simplificar (cancelar)."
                                  ],
                                  "verification": "Mostre G(s) com N(s) e D(s) isolados e graus indicados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência exemplo em papel",
                                    "Calculadora simbólica (opcional como Wolfram Alpha)"
                                  ],
                                  "tips": "Use parênteses para delimitar claramente N(s) e D(s).",
                                  "learningObjective": "Isolar com precisão os polinômios numerador e denominador.",
                                  "commonMistakes": [
                                    "Não simplificar fatores comuns",
                                    "Erro na identificação da fração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir polinômios em forma padrão e identificar coeficientes",
                                  "subSteps": [
                                    "Expanda N(s) na forma b_m s^m + b_{m-1} s^{m-1} + ... + b_0.",
                                    "Expanda D(s) na forma a_n s^n + a_{n-1} s^{n-1} + ... + a_0.",
                                    "Liste os coeficientes: para N(s): [b_m, b_{m-1}, ..., b_0]; para D(s): [a_n, ..., a_0].",
                                    "Normalize se necessário (a_n = 1).",
                                    "Anote os coeficientes em vetores ou listas."
                                  ],
                                  "verification": "Escreva os vetores de coeficientes num e den explicitamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software MATLAB/Simulink para verificação (opcional)"
                                  ],
                                  "tips": "Ordene coeficientes do maior para menor grau (coeficiente líder primeiro).",
                                  "learningObjective": "Extrair e listar coeficientes polinomiais de forma padronizada.",
                                  "commonMistakes": [
                                    "Ordem invertida dos coeficientes",
                                    "Esquecer termos zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e associar coeficientes à forma canônica controlável",
                                  "subSteps": [
                                    "Confira se os coeficientes batem com a matriz A na forma canônica: a_i = -companheiro de D(s).",
                                    "Simule ou calcule polos/raízes para validar.",
                                    "Compare com representação em espaço de estados.",
                                    "Documente os coeficientes para uso em conversão.",
                                    "Teste com um exemplo numérico completo."
                                  ],
                                  "verification": "Construa matriz companheira A usando coeficientes e confirme estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de formas canônicas",
                                    "MATLAB para tf2ss"
                                  ],
                                  "tips": "Use tf2ss no MATLAB para dupla verificação.",
                                  "learningObjective": "Validar coeficientes no contexto de modelagem em espaço de estados.",
                                  "commonMistakes": [
                                    "Sinais errados nos coeficientes da matriz A",
                                    "Não normalizar D(s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada G(s) = (2s + 4)/(s^2 + 5s + 6), N(s)=2s+4 → coeficientes num=[2,4]; D(s)=s^2+5s+6 → coeficientes den=[1,5,6] (normalizado). Na forma canônica controlável, A = [[0,1,0], [0,0,1], [-6,-5,-1]].",
                              "finalVerifications": [
                                "Coeficientes de N(s) e D(s) listados corretamente em ordem decrescente.",
                                "Normalização aplicada (coeficiente líder de D(s)=1).",
                                "Graus dos polinômios identificados e corretos.",
                                "Sem fatores comuns não cancelados.",
                                "Coeficientes compatíveis com matriz companheira A.",
                                "Verificação numérica via raízes ou simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de todos coeficientes (100% correto).",
                                "Forma padronizada e ordenada dos vetores.",
                                "Explicação clara da normalização e simplificação.",
                                "Associação correta com espaço de estados.",
                                "Ausência de erros aritméticos em expansões.",
                                "Validação independente (ex: software)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios e álgebra linear (matrizes companheiras).",
                                "Programação: Implementação em MATLAB/Python para tf2ss.",
                                "Controle Automático: Uso em controladores PID.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos.",
                                "Engenharia de Software: Simulações em Simulink."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, identificar coeficientes de funções de transferência modela a dinâmica de aeronaves (ex: estabilizador de voo), permitindo conversão para espaço de estados para design de controladores que garantem estabilidade em manobras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Construir as matrizes A, B, C e D",
                            "description": "Montar a matriz A em forma companheira com coeficientes do denominador, B como vetor coluna de [0;0;...;1], C com coeficientes do numerador e D=0 para funções estritamente próprias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar os coeficientes da função de transferência",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) = N(s)/D(s) em forma polinomial, onde N(s) é o numerador e D(s) o denominador.",
                                    "Normalize os coeficientes para que o termo de maior grau do denominador seja 1 (monico).",
                                    "Liste os coeficientes do denominador [a_n-1, a_n-2, ..., a_0] e do numerador [b_m, b_m-1, ..., b_0], considerando o grau n do denominador.",
                                    "Confirme que a função é estritamente própria (grau N < grau D).",
                                    "Anote o número de estados n = grau(D)."
                                  ],
                                  "verification": "Verifique se os coeficientes estão corretamente listados e normalizados, comparando com a FT original.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Função de transferência dada",
                                    "Papel e calculadora",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Sempre comece pela normalização para evitar erros de escala nas matrizes.",
                                  "learningObjective": "Compreender a extração precisa de coeficientes para modelagem em espaço de estados.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar o denominador",
                                    "Confundir ordem dos coeficientes (reverso)",
                                    "Não verificar se é estritamente própria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz A em forma companheira",
                                  "subSteps": [
                                    "Crie uma matriz n x n zerada.",
                                    "Preencha a última linha com os coeficientes negativos do denominador: [-a_n-1, -a_n-2, ..., -a_0].",
                                    "Preencha a subdiagonal com 1's: A[i+1,i] = 1 para i=1 a n-1.",
                                    "Verifique a estrutura: primeira coluna zeros exceto última linha, e identidade na subdiagonal.",
                                    "Confirme que A representa a forma canônica controlável."
                                  ],
                                  "verification": "Multiplique A por um vetor de estados e veja se reproduz a dinâmica do denominador.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Coeficientes anotados",
                                    "Matriz em papel ou software (MATLAB: companion)",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Lembre-se: coeficientes com sinal negativo na última linha!",
                                  "learningObjective": "Dominar a construção da matriz de sistema em forma companheira.",
                                  "commonMistakes": [
                                    "Sinais errados nos coeficientes",
                                    "Colocar 1's na superdiagonal em vez de subdiagonal",
                                    "Ordem invertida dos coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o vetor de entrada B",
                                  "subSteps": [
                                    "Crie um vetor coluna n x 1 com zeros.",
                                    "Coloque 1 na última posição: B = [0; 0; ...; 0; 1].",
                                    "Verifique dimensões: compatível com A (n x 1).",
                                    "Confirme que B seleciona o estado mais alto para entrada.",
                                    "Teste multiplicação A*B para validar."
                                  ],
                                  "verification": "A*B deve resultar em um vetor com 1 na penúltima posição e zeros ajustados.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Matriz A construída",
                                    "Papel ou software"
                                  ],
                                  "tips": "B é sempre o vetor canônico e_n para forma controlável.",
                                  "learningObjective": "Entender o papel do vetor B na acessibilidade do sistema.",
                                  "commonMistakes": [
                                    "Colocar o 1 na primeira posição",
                                    "Fazer B linha em vez de coluna",
                                    "Esquecer zeros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a matriz C e o escalar D",
                                  "subSteps": [
                                    "Crie C como vetor linha 1 x n com coeficientes do numerador [b_0, b_1, ..., b_{n-1}], ajustando para grau < n.",
                                    "Defina D = 0 para funções estritamente próprias.",
                                    "Verifique dimensões: C (1 x n), D (1 x 1).",
                                    "Confirme que y = C*x + D*u reproduz a saída.",
                                    "Monte o modelo completo: dx/dt = A x + B u; y = C x + D u."
                                  ],
                                  "verification": "Simule o sistema e compare saída com FT original.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Coeficientes do numerador",
                                    "Matrizes A e B",
                                    "Software de simulação (opcional)"
                                  ],
                                  "tips": "Para numerador de grau m < n-1, preencha zeros à direita em C.",
                                  "learningObjective": "Completar o modelo de saída na forma canônica.",
                                  "commonMistakes": [
                                    "Ordem errada em C (reverso)",
                                    "Definir D ≠ 0 em estritamente própria",
                                    "Dimensões incompatíveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = (2s + 3)/(s² + 4s + 5): Denominador [1,4,5] → A = [[0,1],[ -5,-4 ]]; B=[0;1]; C=[3,2]; D=0.",
                              "finalVerifications": [
                                "Construir corretamente A, B, C, D para uma FT de ordem 3.",
                                "Verificar que A*B reproduz a dinâmica esperada.",
                                "Simular o sistema e comparar resposta ao degrau com FT original.",
                                "Confirmar minimalidade: pares (A,B) e (A,C) controlável/observável.",
                                "Aplicar em software e plotar respostas.",
                                "Explicar verbalmente o significado físico de cada matriz."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e normalização de coeficientes (20%)",
                                "Correção na estrutura da matriz A companheira (30%)",
                                "Construção exata de B, C e D (20%)",
                                "Verificações e simulações válidas (15%)",
                                "Explicação clara do processo (10%)",
                                "Ausência de erros comuns (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e polinômios.",
                                "Programação: Implementação em MATLAB/Simulink para simulação.",
                                "Engenharia de Controle: Análise de controlabilidade.",
                                "Física: Modelagem dinâmica de sistemas aeronáuticos.",
                                "Informática: Uso de bibliotecas como Control Systems Toolbox."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, essa conversão é essencial para modelar sistemas de controle de voo de aeronaves, permitindo simulações em Simulink para estabilidade e projeto de controladores em espaço de estados, como no autopilot de aviões comerciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Aplicar a conversão em exemplo de segunda ordem",
                            "description": "Converter uma função de transferência de segunda ordem, como G(s) = (ω²)/(s² + 2ζωs + ω²), para espaço de estados e verificar a estrutura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e parametrizar a função de transferência de segunda ordem",
                                  "subSteps": [
                                    "Escreva a forma geral da função de transferência G(s) = ω² / (s² + 2ζω s + ω²).",
                                    "Identifique os parâmetros ω (frequência natural) e ζ (fator de amortecimento) do exemplo dado.",
                                    "Expresse os coeficientes do denominador: a1 = 2ζω e a0 = ω².",
                                    "Confirme que o numerador é constante e igual a ω² para sistemas próprios.",
                                    "Anote valores numéricos se fornecidos no exemplo."
                                  ],
                                  "verification": "Verifique se os coeficientes a1 e a0 foram corretamente extraídos e coincidem com os parâmetros ω e ζ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de álgebra simbólica como MATLAB/SymPy",
                                    "Referência de funções de transferência de segunda ordem"
                                  ],
                                  "tips": "Sempre normalize a função de transferência para garantir que o ganho em DC seja 1 quando aplicável.",
                                  "learningObjective": "Compreender a estrutura padrão de uma função de transferência de segunda ordem e extrair parâmetros chave.",
                                  "commonMistakes": [
                                    "Confundir ω² com ω",
                                    "Esquecer de identificar corretamente o numerador constante",
                                    "Não normalizar coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir as matrizes A e B na forma canônica controlável",
                                  "subSteps": [
                                    "Defina o vetor de estado x = [x1; x2], onde ẋ1 = x2 e ẋ2 = -a0 x1 - a1 x2 + u.",
                                    "Monte a matriz A = [[0, 1], [-a0, -a1]], substituindo a0 = ω² e a1 = 2ζω.",
                                    "Defina B = [0; 1] para entrada única na forma controlável (Companion).",
                                    "Escreva explicitamente A e B com símbolos ω e ζ.",
                                    "Substitua valores numéricos do exemplo para validação inicial."
                                  ],
                                  "verification": "Confirme que A está na forma companion e que det(sI - A) = s² + a1 s + a0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB para verificação",
                                    "Tabela de formas canônicas"
                                  ],
                                  "tips": "Lembre-se: a última linha de A contém os coeficientes negativos do denominador.",
                                  "learningObjective": "Dominar a construção das matrizes dinâmicas A e B para sistemas de segunda ordem.",
                                  "commonMistakes": [
                                    "Invertar os coeficientes em A (sinais errados)",
                                    "Usar forma observável em vez de controlável",
                                    "Colocar B incorretamente como [1; 0]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar as matrizes C, D e verificar a saída",
                                  "subSteps": [
                                    "Para G(s) = ω² / (s² + 2ζω s + ω²), defina C = [ω², 0] na forma controlável.",
                                    "Confirme D = 0, pois não há alimentação direta.",
                                    "Escreva o modelo completo: ẋ = A x + B u, y = C x + D u.",
                                    "Verifique o ganho estático: C (-A)^{-1} B = 1.",
                                    "Teste com valores numéricos para consistência."
                                  ],
                                  "verification": "Calcule a função de transferência a partir de C (sI - A)^{-1} B e confirme que iguala G(s) original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB (ss2tf) ou Python Control Systems Library",
                                    "Folha de cálculo para álgebra matricial"
                                  ],
                                  "tips": "Use a identidade adj(sI - A) / det(sI - A) para verificação simbólica rápida.",
                                  "learningObjective": "Completar o modelo de espaço de estados com matrizes de saída corretas.",
                                  "commonMistakes": [
                                    "Errar o posicionamento de C (deve ser [k, 0] para k=ω²)",
                                    "Esquecer D=0",
                                    "Não verificar ganho DC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a estrutura e propriedades do modelo",
                                  "subSteps": [
                                    "Verifique controllabilidade: rank([B, A B]) = 2 para segunda ordem.",
                                    "Confirme os autovalores de A são as raízes do denominador de G(s).",
                                    "Simule resposta ao degrau e compare com simulação de G(s).",
                                    "Analise a estrutura: confirme forma companion (uma 1 na superdiagonal).",
                                    "Documente qualquer discrepância e corrija."
                                  ],
                                  "verification": "Matrículas de controllabilidade full rank e espectro coincidente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (scipy.signal, control.matlab)",
                                    "Gráficos de resposta temporal"
                                  ],
                                  "tips": "Para sistemas de segunda ordem, controllabilidade é garantida se pólos distintos ou ζ <1.",
                                  "learningObjective": "Garantir que o modelo no espaço de estados preserve as dinâmicas originais.",
                                  "commonMistakes": [
                                    "Não checar rank da matriz de controllabilidade",
                                    "Ignorar discrepâncias numéricas",
                                    "Confundir autovalores com zeros"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado G(s) = 25 / (s² + 5s + 25) onde ω=5, ζ=0.5. Converta para espaço de estados: A = [[0,1],[-25,-5]], B=[0;1], C=[25,0], D=0. Verifique com ss2tf(A,B,C,D) == G(s).",
                              "finalVerifications": [
                                "Matrizes A, B, C, D escritas corretamente com coeficientes exatos.",
                                "Função de transferência reconstruída a partir do modelo SS coincide com G(s) original.",
                                "Matriz de controllabilidade tem rank cheio (2).",
                                "Autovalores de A igualam raízes do polinômio característico.",
                                "Simulação de resposta ao degrau matches entre TF e SS.",
                                "Ganho em estado estacionário é 1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de coeficientes (100% correto).",
                                "Correta aplicação da forma canônica controlável (A companion, B padrão).",
                                "Verificação algébrica e numérica demonstrada.",
                                "Análise de propriedades (controllability, observability implícita).",
                                "Clareza na documentação e explicação dos passos.",
                                "Tratamento de erros comuns evitado."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso em sintetizadores de controladores LQR/LQG.",
                                "Programação Numérica: Implementação em MATLAB/Python para simulações.",
                                "Engenharia Aeronáutica: Modelagem de osciladores em controle de atitude de aeronaves.",
                                "Matemática Aplicada: Álgebra linear e teoria de sistemas lineares.",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor equivalentes."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, converte funções de transferência de sistemas de controle de flight (ex.: estabilizador de roll) para espaço de estados, permitindo design de observadores e controladores modernos como em autopilotos de drones ou aviões comerciais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Forma Canônica Observável",
                        "description": "Representação alternativa de espaço de estados derivada da função de transferência, com ênfase na observabilidade, onde a matriz C é uma linha de uns e A é transposição da forma controlável.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Derivar matrizes para observabilidade",
                            "description": "Construir matriz A como companheira transposta, C como vetor linha de [1 0 ... 0], B com coeficientes do numerador e D=0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e extrair os coeficientes da função de transferência",
                                  "subSteps": [
                                    "Obtenha a função de transferência G(s) = N(s)/D(s) no contexto dado.",
                                    "Expresse o denominador D(s) = s^n + a_{n-1} s^{n-1} + ... + a_1 s + a_0, anotando todos os a_i (com a_0 sendo o termo constante).",
                                    "Expresse o numerador N(s) = b_{n-1} s^{n-1} + ... + b_1 s + b_0, completando com zeros se o grau for menor que n-1 (coeficientes de baixo para alto grau).",
                                    "Confirme a ordem n do sistema e liste todos os coeficientes a_i e b_i em tabelas ou listas claras.",
                                    "Verifique se o coeficiente líder do denominador é 1 (normalizado)."
                                  ],
                                  "verification": "Compare os coeficientes listados com a expansão polinomial original da G(s) para garantir exatidão.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Função de transferência fornecida",
                                    "Papel e lápis",
                                    "Calculadora ou software simbólico como MATLAB/SymPy"
                                  ],
                                  "tips": "Mantenha a convenção de coeficientes com índice baixo para termos de baixo grau (b_0 constante, b_1 para s, etc.).",
                                  "learningObjective": "Dominar a extração precisa de coeficientes polinomiais para modelagem em espaço de estados.",
                                  "commonMistakes": [
                                    "Inverter a ordem dos coeficientes (ex: confundir b_0 com b_{n-1})",
                                    "Não adicionar zeros necessários no numerador",
                                    "Ignorar a normalização do denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz A na forma companheira transposta",
                                  "subSteps": [
                                    "Crie uma matriz quadrada n x n inicializada com zeros.",
                                    "Preencha a superdiagonal com 1's: para i = 1 até n-1, defina A[i][i+1] = 1.",
                                    "Preencha a última linha com os coeficientes negativos do denominador: para j = 1 até n, defina A[n][j] = -a_{j-1} (onde a_0 é o primeiro da linha).",
                                    "Revise a estrutura: deve ter 1's na superdiagonal e -a_i na última linha.",
                                    "Anotar ou desenhar a matriz explicitamente."
                                  ],
                                  "verification": "Confirme que det(sI - A) = D(s) (polinômio característico coincide com o denominador).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Lista de coeficientes a_i",
                                    "Papel quadriculado ou MATLAB para matrizes"
                                  ],
                                  "tips": "Pense na matriz A como um shift register com feedback na última linha.",
                                  "learningObjective": "Construir corretamente a matriz de sistema na forma canônica observável.",
                                  "commonMistakes": [
                                    "Colocar 1's na subdiagonal em vez de superdiagonal",
                                    "Esquecer o sinal negativo nos -a_i",
                                    "Ordem errada dos a_i na última linha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os vetores C, B e a matriz D",
                                  "subSteps": [
                                    "Defina o vetor linha C como [1, 0, 0, ..., 0] (dimensão 1 x n).",
                                    "Construa o vetor coluna B com os coeficientes do numerador: B = [b_0; b_1; ...; b_{n-1}] (n x 1).",
                                    "Defina D = 0 (escalar, pois função de transferência strict proper).",
                                    "Escreva C, B e D explicitamente ao lado da matriz A.",
                                    "Verifique dimensões: A (n x n), B (n x 1), C (1 x n), D (1 x 1)."
                                  ],
                                  "verification": "Confirme dimensões compatíveis para as equações de estado: \\dot{x} = A x + B u, y = C x + D u.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Coeficientes b_i",
                                    "Papel ou editor de matriz"
                                  ],
                                  "tips": "B tem b_0 no topo (primeira entrada) correspondendo ao termo constante do numerador.",
                                  "learningObjective": "Completar o modelo de espaço de estados com entradas/saídas corretas.",
                                  "commonMistakes": [
                                    "Usar C como [0 ... 1] em vez de [1 0 ... 0]",
                                    "Inverter ordem em B (colocar altos graus no topo)",
                                    "Definir D diferente de 0 para TF proper"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a equivalência do modelo com a função de transferência original",
                                  "subSteps": [
                                    "Calcule a função de transferência do modelo: G_model(s) = C (sI - A)^{-1} B + D.",
                                    "Use expansão ou software para simplificar G_model(s) e comparar com G(s) original.",
                                    "Verifique o polinômio característico: det(sI - A) == D(s).",
                                    "Confirme ganho em DC ou valores em polos se possível.",
                                    "Documente qualquer discrepância e corrija."
                                  ],
                                  "verification": "G_model(s) idêntica a G(s) original em todos os termos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Matrizes A,B,C,D construídas",
                                    "MATLAB, Python (control library) ou cálculo manual para baixa ordem"
                                  ],
                                  "tips": "Para ordens baixas (n<=3), calcule manualmente; para maiores, use software.",
                                  "learningObjective": "Validar a transformação da TF para espaço de estados.",
                                  "commonMistakes": [
                                    "Erro de cálculo em (sI - A)^{-1}",
                                    "Não considerar D=0",
                                    "Ignorar mismatch nos coeficientes b_i"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) = (2s + 3)/(s^2 + 5s + 6). Coeficientes: n=2, a_1=5, a_0=6, b_1=2, b_0=3. Matriz A = [[0, 1], [-6, -5]], B = [[3], [2]], C = [1, 0], D=0. Verificação: polinômio char = s^2 + 5s + 6, e C(sI-A)^{-1}B = (2s+3)/(s^2+5s+6).",
                              "finalVerifications": [
                                "Matriz A possui 1's na superdiagonal e -a_{j-1} na última linha.",
                                "Vetor C é exatamente [1 0 ... 0].",
                                "Vetor B lista b_0 no topo até b_{n-1} na base.",
                                "D = 0.",
                                "Polinômio característico det(sI - A) coincide com D(s).",
                                "Função de transferência reconstruída matches a original.",
                                "Dimensões de todas as matrizes/vetores são consistentes (n x n para A)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de todos os coeficientes a_i e b_i (100% correto).",
                                "Estrutura exata da matriz A (superdiagonal e última linha).",
                                "Correta definição de C, B e D conforme especificações.",
                                "Validação bem-sucedida da equivalência TF <=> espaço de estados.",
                                "Clareza na documentação e ausência de erros aritméticos.",
                                "Eficiência no tempo estimado e uso adequado de materiais.",
                                "Identificação e correção de erros comuns demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes companheiras, polinômios característicos).",
                                "Engenharia de Controle: Projeto de observadores e análise de observabilidade.",
                                "Engenharia Aeronáutica: Modelagem de dinâmica de voo e autômatos de aeronaves.",
                                "Programação Computacional: Implementação em MATLAB/Simulink ou Python Control Systems.",
                                "Física: Sistemas dinâmicos lineares em vibrações e controle."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, derivar matrizes na forma canônica observável permite projetar observadores de estado para sistemas de controle de voo, estimando variáveis não diretamente mensuráveis (como velocidade angular) a partir de sensores limitados, essencial em autômatos de piloto automático e sistemas de estabilidade de aeronaves."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Comparar com forma controlável",
                            "description": "Analisar diferenças e similaridades entre formas canônicas controlável e observável, verificando equivalência via transformações de similaridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições das Formas Canônicas Controlável e Observável",
                                  "subSteps": [
                                    "Estude a matriz A, B e C para a Forma Canônica Controlável (CCF): A em companion form com últimos elementos da linha, B = [0;0;...;1], C = [b0 b1 ... bn-1].",
                                    "Analise a Forma Canônica Observável (OCF): A em companion form com primeiros elementos da coluna, B = [bn-1 ... b0]^T, C = [0 0 ... 1].",
                                    "Escreva as equações de estado para ambas as formas a partir de uma função de transferência genérica G(s) = num(s)/den(s).",
                                    "Identifique similaridades: ambas derivam da mesma FT e têm dimensão n x n.",
                                    "Liste diferenças chave: estrutura de B e C invertidas."
                                  ],
                                  "verification": "Escreva as matrizes A, B, C para um sistema de ordem 2 e confirme que representam a mesma FT.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de controle (ex: Ogata), notas de aula sobre espaço de estado, calculadora simbólica (MATLAB/SymPy).",
                                  "tips": "Use diagramas para visualizar a 'inversão' entre controle e observação.",
                                  "learningObjective": "Compreender as estruturas matriciais exatas de CCF e OCF.",
                                  "commonMistakes": "Confundir a posição dos coeficientes polinomiais em B e C."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Transformações de Similaridade em Espaço de Estado",
                                  "subSteps": [
                                    "Defina transformação de similaridade: A' = T^{-1} A T, B' = T^{-1} B, C' = C T.",
                                    "Verifique que a FT permanece invariante: C' (sI - A')^{-1} B' = C T (sI - T^{-1} A T)^{-1} T^{-1} B = C (sI - A)^{-1} B.",
                                    "Prove que autovalores e polos são preservados.",
                                    "Discuta condições: T deve ser invertível.",
                                    "Exemplo simples: transforme uma matriz diagonal para outra similar."
                                  ],
                                  "verification": "Aplique a transformação a um sistema conhecido e confirme que a FT não muda.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de álgebra linear (MATLAB, Python NumPy), exemplos resolvidos de livros.",
                                  "tips": "Lembre-se: similaridade preserva propriedades dinâmicas, não a base.",
                                  "learningObjective": "Dominar como transformações preservam equivalência dinâmica.",
                                  "commonMistakes": "Esquecer de transformar B e C corretamente (T^{-1}B vs CT)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Transformação T entre OCF e CCF",
                                  "subSteps": [
                                    "Para um sistema de ordem n, defina T como a matriz dos coeficientes da FT invertida: T = [0 1 0 ...; 0 0 1 ...; ... ; an-1 ... a0].",
                                    "Mostre que para OCF para CCF: A_ccf = T^{-1} A_ocf T.",
                                    "Calcule T^{-1} explicitamente para ordem baixa.",
                                    "Verifique B_ccf = T^{-1} B_ocf e C_ccf = C_ocf T.",
                                    "Generalize para qualquer ordem usando propriedades de companion matrices."
                                  ],
                                  "verification": "Compute T para ordem 2 e confirme A', B', C' coincidem com CCF.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivação, MATLAB para validação numérica.",
                                  "tips": "T é frequentemente a matriz de Hankel ou reversa dos coeficientes.",
                                  "learningObjective": "Derivar explicitamente a matriz T que relaciona CCF e OCF.",
                                  "commonMistakes": "Erro no sinal ou posição ao inverter coeficientes (ai vs (-1)^i ai)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diferenças, Similaridades e Verificar Equivalência",
                                  "subSteps": [
                                    "Liste similaridades: mesmas dimensões, autovalores, FT idêntica.",
                                    "Diferenças: CCF otimizada para controle (B simples), OCF para observação (C simples).",
                                    "Aplique T a um exemplo e compare numericamente.",
                                    "Discuta implicações: rank([B AB ...]) para controlabilidade igual em ambas.",
                                    "Conclua equivalência via similaridade."
                                  ],
                                  "verification": "Para um exemplo dado, mostre que todas as matrizes transformadas batem e FT é igual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplo prático de FT, simulador (Simulink ou Python Control).",
                                  "tips": "Sempre verifique numericamente após derivação analítica.",
                                  "learningObjective": "Comparar criticamente as formas e validar equivalência.",
                                  "commonMistakes": "Ignorar que similaridade não preserva controlabilidade/observabilidade diretamente (mas elas são equivalentes)."
                                }
                              ],
                              "practicalExample": "Considere G(s) = 1/(s^2 + 3s + 2). CCF: A=[0 1; -2 -3], B=[0;1], C=[1 0]. OCF: A=[0 -2; 1 -3], B=[0;1], C=[1 0]. Derive T = [[0 1]; [1 0]], verifique A_ocf = T^{-1} A_ccf T, etc. Simule resposta ao degrau em ambas.",
                              "finalVerifications": [
                                "Derivação correta de T para ordem 2 e 3.",
                                "Verificação numérica: FT idêntica após transformação.",
                                "Identificação precisa de 3+ similaridades e 3+ diferenças.",
                                "Cálculo correto de controlabilidade/observabilidade em ambas formas.",
                                "Explicação verbal da equivalência via similaridade.",
                                "Aplicação bem-sucedida a um novo exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de matrizes CCF e OCF (90% correto).",
                                "Correção na derivação de T e transformações (sem erros algébricos).",
                                "Profundidade na análise de similaridades/diferenças (cobertura completa).",
                                "Validação numérica e simbólica da equivalência.",
                                "Clareza na explicação de implicações práticas.",
                                "Capacidade de generalizar para ordem n."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Matrizes companion e diagonalização.",
                                "Controle Automático: Análise de controlabilidade/observabilidade.",
                                "Análise Numérica: Estabilidade em simulações computacionais.",
                                "Engenharia de Software: Implementação em MATLAB/Python para verificação."
                              ],
                              "realWorldApplication": "Em design de sistemas de controle para aeronaves, como estabilização de flight controllers, onde CCF facilita síntese de ganhos de estado e OCF otimiza filtros de observador de estado, garantindo modelos equivalentes para simulações de voo reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Converter função de transferência de terceira ordem",
                            "description": "Aplicar o método para G(s) de ordem 3, montando explicitamente as matrizes 3x3 e validando a função de transferência resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os coeficientes da função de transferência de terceira ordem",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) = N(s)/D(s), onde D(s) = s³ + a₂s² + a₁s + a₀ e N(s) = b₂s² + b₁s + b₀.",
                                    "Normalize o denominador para que o coeficiente de s³ seja 1.",
                                    "Liste explicitamente os valores de a₂, a₁, a₀ (do denominador) e b₂, b₁, b₀ (do numerador).",
                                    "Verifique se a função é própria estrita (grau N < grau D).",
                                    "Anotar os coeficientes em uma tabela para referência."
                                  ],
                                  "verification": "Coeficientes extraídos e listados corretamente sem erros aritméticos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Função de transferência G(s) fornecida",
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora para simplificações"
                                  ],
                                  "tips": "Sempre confirme a normalização do denominador dividindo numerador e denominador pelo coeficiente líder de D(s).",
                                  "learningObjective": "Extrair com precisão os coeficientes polinomiais necessários para a construção das matrizes de espaço de estados.",
                                  "commonMistakes": [
                                    "Confundir coeficientes de numerador e denominador",
                                    "Esquecer de inverter sinais ao identificar a_i",
                                    "Não normalizar o polinômio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de sistema A na forma canônica observável",
                                  "subSteps": [
                                    "Estruture a matriz A (3x3) como: primeira linha [0, 0, -a₀]; segunda linha [1, 0, -a₁]; terceira linha [0, 1, -a₂].",
                                    "Substitua os valores de a₀, a₁, a₂ pelos coeficientes identificados, aplicando sinal negativo onde especificado.",
                                    "Verifique a estrutura: deve ser uma matriz companheira transposta com coeficientes no off-diagonal.",
                                    "Escreva a matriz A explicitamente com números.",
                                    "Confirme dimensionalidade: 3x3 para ordem 3."
                                  ],
                                  "verification": "Matriz A possui a estrutura exata da forma canônica observável com coeficientes corretos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Coeficientes anotados do Step 1",
                                    "Papel quadriculado ou software de matriz (ex: MATLAB)",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: a forma observável tem os coeficientes nos elementos A(1,3), A(2,3), A(3,3) com shifts nas linhas.",
                                  "learningObjective": "Montar corretamente a matriz dinâmica A que captura a estrutura observável do sistema.",
                                  "commonMistakes": [
                                    "Usar forma controlável em vez de observável",
                                    "Esquecer os sinais negativos nos a_i",
                                    "Colocar coeficientes na posição errada da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os vetores de entrada B, saída C e alimentação direta D",
                                  "subSteps": [
                                    "Construa o vetor B (3x1) como coluna [b₀; b₁; b₂], usando os coeficientes do numerador diretamente.",
                                    "Defina o vetor C (1x3) como [0, 0, 1], característico da forma observável.",
                                    "Estabeleça D = 0, pois a FT é strict proper.",
                                    "Escreva B, C e D explicitamente com os valores numéricos.",
                                    "Verifique compatibilidade: A (3x3), B (3x1), C (1x3)."
                                  ],
                                  "verification": "Vetores B e C corretos, com C fixo em [0 0 1] e B matching os b_i.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Coeficientes do numerador",
                                    "Papel para vetores",
                                    "Ferramenta de edição de matrizes"
                                  ],
                                  "tips": "B é simplesmente a coluna dos coeficientes do numerador na ordem crescente de potência.",
                                  "learningObjective": "Completar a representação de espaço de estados com entrada, saída e alimentação adequadas à forma observável.",
                                  "commonMistakes": [
                                    "Inverter a ordem dos b_i em B",
                                    "Definir C incorretamente como linha de b_i",
                                    "Esquecer D=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a conversão revertendo para função de transferência",
                                  "subSteps": [
                                    "Calcule a FT a partir das matrizes: G(s) = C (sI - A)^{-1} B + D.",
                                    "Compute det(sI - A) para obter o denominador e confirme que matches D(s).",
                                    "Extraia o numerador comparando adj(sI - A) ou usando fórmula para forma canônica.",
                                    "Compare coeficientes da FT calculada com a original G(s).",
                                    "Se não bater, revise A, B ou C."
                                  ],
                                  "verification": "Função de transferência recuperada é idêntica à original em todos os coeficientes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Matrizes A, B, C completas",
                                    "Software simbólico como MATLAB (syms) ou SymPy",
                                    "Folha de cálculos manuais"
                                  ],
                                  "tips": "Use propriedades da forma canônica para simplificar: den(sI-A) = D(s) diretamente.",
                                  "learningObjective": "Verificar a equivalência entre representações de FT e espaço de estados.",
                                  "commonMistakes": [
                                    "Erros em cálculos de inversa ou determinante",
                                    "Ignorar sinais nos coeficientes",
                                    "Não comparar todos os termos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = (2s² + 3s + 1)/(s³ + 4s² + 5s + 2), coefs: a₂=4, a₁=5, a₀=2; b₂=2, b₁=3, b₀=1. A = [[0,0,-2],[1,0,-5],[0,1,-4]], B=[1;3;2], C=[0,0,1], D=0. Validação: Reverter dá G(s) original.",
                              "finalVerifications": [
                                "Matriz A (3x3) exibe estrutura observável com -a_i corretos.",
                                "Vetor B (3x1) matches coeficientes b_i em ordem.",
                                "Vetor C = [0 0 1] exatamente.",
                                "D = 0 confirmado.",
                                "FT revertida idêntica à original (todos coefs iguais).",
                                "Sem erros dimensionais ou aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de coeficientes (20%)",
                                "Correção da estrutura e valores da matriz A (25%)",
                                "Acurácia de B, C e D (20%)",
                                "Sucesso na validação por reversão (25%)",
                                "Clareza na documentação e cálculos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes companheiras e formas canônicas.",
                                "Controle Automático: Design de observadores de estado para sistemas aeronáuticos.",
                                "Programação Computacional: Implementação em MATLAB/Simulink para simulações dinâmicas.",
                                "Matemática Aplicada: Análise de polinômios e determinantes simbólicos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, converter funções de transferência de sistemas de atitude ou flaps de terceira ordem para forma observável permite projetar observadores de estado robustos, essenciais para sistemas de controle fly-by-wire em aeronaves, garantindo estimativa precisa de estados não mensuráveis durante voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Verificação e Conversões Equivalentes",
                        "description": "Técnicas para validar a conversão e realizar transformações entre representações equivalentes no espaço de estados, garantindo consistência com a função de transferência original.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Calcular função de transferência a partir de espaço de estados",
                            "description": "Usar a fórmula G(s) = C(sI - A)^{-1}B + D para verificar se a representação em espaço de estados reproduz a função de transferência original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação das Matrizes do Espaço de Estados",
                                  "subSteps": [
                                    "Identifique as matrizes A (nxn), B (nxm), C (pxn) e D (pxm) fornecidas no problema.",
                                    "Verifique as dimensões das matrizes para garantir compatibilidade nas multiplicações.",
                                    "Anote as matrizes simbolicamente, introduzindo a variável complexa s onde necessário.",
                                    "Confirme se o sistema é MIMO ou SISO para simplificar cálculos futuros.",
                                    "Transcreva as matrizes em um software simbólico como MATLAB ou SymPy, se disponível."
                                  ],
                                  "verification": "Matrizes corretamente transcritas e dimensões validadas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matrizes do problema",
                                    "Papel e caneta",
                                    "Software simbólico (MATLAB/SymPy)"
                                  ],
                                  "tips": "Use notação matricial padrão e label as matrizes claramente para evitar confusões.",
                                  "learningObjective": "Compreender a estrutura e dimensões das representações em espaço de estados.",
                                  "commonMistakes": [
                                    "Erros de transcrição das matrizes",
                                    "Confusão entre linhas e colunas nas dimensões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construção da Matriz sI - A",
                                  "subSteps": [
                                    "Construa a matriz identidade I de ordem n (dimensão de A).",
                                    "Multiplique I por s para obter sI.",
                                    "Subtraia a matriz A de sI elemento a elemento.",
                                    "Expresse todos os elementos como funções de s.",
                                    "Verifique a simetria ou propriedades especiais da matriz resultante."
                                  ],
                                  "verification": "Matriz sI - A formada corretamente, com elementos dependentes de s.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matrizes A",
                                    "Calculadora matricial ou software"
                                  ],
                                  "tips": "Para ordens baixas (n≤3), faça manualmente; para maiores, use ferramentas computacionais.",
                                  "learningObjective": "Dominar a construção simbólica de sI - A para análise de sistemas lineares.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na subtração de A",
                                    "Erros em multiplicação escalar sI"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo da Inversa (sI - A)^{-1}",
                                  "subSteps": [
                                    "Calcule o determinante det(sI - A) para obter o denominador.",
                                    "Compute a matriz adjunta adj(sI - A).",
                                    "Forme a inversa como adj(sI - A) / det(sI - A).",
                                    "Simplifique os polinômios racionais nos elementos da inversa.",
                                    "Valide a inversa multiplicando (sI - A) * inversa = I."
                                  ],
                                  "verification": "Inversa correta confirmada pela multiplicação identidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas de inversa matricial",
                                    "Software simbólico"
                                  ],
                                  "tips": "Use a fórmula de Cayley-Hamilton para simplificar em sistemas de alta ordem.",
                                  "learningObjective": "Aplicar cálculo de inversas matriciais simbólicas em funções racionais.",
                                  "commonMistakes": [
                                    "Erros no cálculo do determinante",
                                    "Confusão entre adjunta e transpososta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo Final G(s) = C(sI - A)^{-1}B + D e Verificação",
                                  "subSteps": [
                                    "Multiplique C pela inversa (sI - A)^{-1} para obter C*(sI - A)^{-1}.",
                                    "Multiplique o resultado por B: C*(sI - A)^{-1}*B.",
                                    "Adicione a matriz D ao resultado.",
                                    "Simplifique a fração racional para forma padrão (polinômio/denominador).",
                                    "Compare com a função de transferência original para validar equivalência."
                                  ],
                                  "verification": "G(s) simplificada coincide com a função de transferência original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Inversa calculada",
                                    "Ferramentas de simplificação algébrica"
                                  ],
                                  "tips": "Fatore numerador e denominador para verificar pólos e zeros.",
                                  "learningObjective": "Realizar multiplicações matriciais simbólicas e validar equivalência de modelos.",
                                  "commonMistakes": [
                                    "Erros de associação em multiplicações matriciais",
                                    "Omitir simplificação final"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema com A = [[0, 1], [-2, -3]], B = [[0], [1]], C = [1, 0], D = 0. Calcule sI - A = [[s, -1], [2, s+3]], det = s(s+3)+2 = s²+3s+2. Inversa = (1/det) * [[s+3, 1], [-2, s]]. Então C*inv*B = (s+3)/(s²+3s+2), que simplifica para 1/(s+1)(s+2), matching a FT original.",
                              "finalVerifications": [
                                "G(s) calculada é idêntica à função de transferência original após simplificação.",
                                "Determinante e elementos da inversa estão corretos.",
                                "Dimensões de todas as multiplicações são compatíveis.",
                                "Pólos e zeros de G(s) coincidem com os do espaço de estados.",
                                "Validação numérica em pontos específicos de s (ex: s=0, s=1).",
                                "Código em MATLAB/SymPy reproduz o mesmo resultado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais simbólicos (sem erros algébricos).",
                                "Correta simplificação da fração racional em forma mínima.",
                                "Validação completa de equivalência com FT original.",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Clareza na documentação dos passos intermediários.",
                                "Identificação e correção de erros comuns em inversas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Cálculo de determinantes e inversas matriciais.",
                                "Controle Automático: Verificação de modelos para design de controladores.",
                                "Programação Computacional: Implementação em MATLAB/Python para simulações.",
                                "Física Dinâmica: Modelagem de sistemas mecânicos em aeronáutica.",
                                "Análise Numérica: Validação com métodos numéricos para s reais."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, verifica-se a equivalência entre modelos em espaço de estados e funções de transferência para o design de sistemas de controle de voo autônomo, garantindo estabilidade e desempenho em aeronaves como drones ou aviões comerciais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Aplicar transformação de similaridade",
                            "description": "Realizar mudança de base com matriz P para converter entre formas canônicas, preservando as matrizes de entrada/saída ajustadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o sistema original e selecionar a forma canônica alvo",
                                  "subSteps": [
                                    "Represente o sistema no espaço de estado com matrizes A, B, C, D.",
                                    "Determine as autovalores e autovetores de A usando decomposição espectral ou forma de Jordan.",
                                    "Escolha a forma canônica desejada (ex: diagonal, controllability canonical, observer canonical).",
                                    "Verifique se o sistema é diagonalizável ou requer forma de Jordan.",
                                    "Defina os requisitos de preservação (função de transferência inalterada)."
                                  ],
                                  "verification": "Confirme que as dimensões das matrizes estão corretas e autovalores foram calculados precisamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Python (NumPy)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece sempre pela análise espectral de A para guiar a escolha da forma alvo.",
                                  "learningObjective": "Compreender as propriedades invariantes sob transformações de similaridade.",
                                  "commonMistakes": [
                                    "Ignorar multiplicidades algébricas vs geométricas",
                                    "Confundir formas canônicas de controllability e observability"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de transformação P",
                                  "subSteps": [
                                    "Para forma diagonal: Monte P com colunas como autovetores de A.",
                                    "Para forma de Jordan: Construa P com autovetores generalizados em cadeias.",
                                    "Para formas canônicas de controllability/observability: Use polinômio característico e vetores de controllability.",
                                    "Calcule a inversa P^{-1} e verifique det(P) ≠ 0.",
                                    "Ajuste P para preservar dimensões de entrada/saída."
                                  ],
                                  "verification": "Multiplique P^{-1} A P e veja se resulta na forma canônica desejada para A.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB eig(), sympy)",
                                    "Folha de cálculo para matrizes"
                                  ],
                                  "tips": "Normalizar autovetores para simplificar cálculos numéricos.",
                                  "learningObjective": "Dominar a construção de matrizes de mudança de base para formas canônicas.",
                                  "commonMistakes": [
                                    "Ordem incorreta das colunas em P",
                                    "Não verificar invertibilidade de P"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a transformação de similaridade nas matrizes",
                                  "subSteps": [
                                    "Calcule \\bar{A} = P^{-1} A P.",
                                    "Calcule \\bar{B} = P^{-1} B.",
                                    "Calcule \\bar{C} = C P.",
                                    "Mantenha D inalterado.",
                                    "Armazene as novas matrizes em formato legível."
                                  ],
                                  "verification": "Verifique se as multiplicações matriciais estão corretas comparando com valores esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta computacional para multiplicação matricial",
                                    "Editor de texto para documentar"
                                  ],
                                  "tips": "Use funções built-in como 'ss' no MATLAB para automação.",
                                  "learningObjective": "Executar transformações preservando dinâmica do sistema.",
                                  "commonMistakes": [
                                    "Esquecer de transformar B ou C",
                                    "Erro de sinal em P^{-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência e validar a transformação",
                                  "subSteps": [
                                    "Compare autovalores de A e \\bar{A}.",
                                    "Calcule funções de transferência originais e transformadas para igualdade.",
                                    "Simule respostas ao degrau para ambos sistemas.",
                                    "Confirme preservação de observabilidade e controlabilidade.",
                                    "Documente discrepâncias e corrija P se necessário."
                                  ],
                                  "verification": "Funções de transferência idênticas e simulações sobrepostas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB Simulink ou Python Control Systems Library",
                                    "Gráficos de resposta temporal"
                                  ],
                                  "tips": "Use 'minreal' para reduzir e comparar sistemas.",
                                  "learningObjective": "Validar que a transformação preserva comportamento dinâmico.",
                                  "commonMistakes": [
                                    "Não testar múltiplas entradas/saídas",
                                    "Ignorar singularidades numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um sistema SISO com A = [[0,1],[-2,-3]], B=[0;1], C=[1,0], D=0 (polinômio char: s^2 +3s+2). Para forma diagonal: autovalores -1,-2; P = [[1,1],[-1,-2]]; \\bar{A}=diag(-1,-2), \\bar{B}=P^{-1}[0;1], etc. Verifique FT(s)=1/(s^2+3s+2) preservada.",
                              "finalVerifications": [
                                "Autovalores de A e \\bar{A} coincidem.",
                                "Função de transferência original = transformada.",
                                "Respostas simuladas ao degrau são idênticas.",
                                "Rank de matrizes de controllabilidade/observabilidade preservado.",
                                "Det(P) ≠ 0 e numérico estável.",
                                "Formato de \\bar{A} é exatamente a canônica alvo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de P (erro <1e-6).",
                                "Correção das transformações em A,B,C (verificação matricial).",
                                "Preservação da função de transferência (igualdade exata).",
                                "Validação via simulação (sobreposição >99%).",
                                "Documentação clara de passos e verificações.",
                                "Eficiência computacional (tempo < esperado)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição modal e formas canônicas.",
                                "Teoria de Controle: Análise de modos e desacoplamento.",
                                "Programação Numérica: Implementação em MATLAB/Python.",
                                "Engenharia de Sistemas: Modelagem de aeronaves dinâmicas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, transforma modelos de espaço de estado de aeronaves em formas modais para análise de estabilidade de voo, desacoplamento de modos longitudinais/laterais-direcionais, e design de controladores em PS-22 Sinais e Sistemas Dinâmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Tratar casos com polos múltiplos ou zeros no infinito",
                            "description": "Adaptar métodos para funções de transferência impróprias ou com estrutura em cascata/paralelo, usando decomposição parcial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e classificar a função de transferência",
                                  "subSteps": [
                                    "Analise o numerador e denominador para determinar graus.",
                                    "Encontre raízes do denominador (polos) e verifique multiplicidades.",
                                    "Encontre raízes do numerador (zeros) e identifique zeros no infinito se grau(num) >= grau(den).",
                                    "Classifique como imprópria, com polos múltiplos ou ambos.",
                                    "Esboce o diagrama de polos-zeros."
                                  ],
                                  "verification": "Lista de polos com multiplicidades e confirmação de zeros no infinito está correta e documentada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de transferência G(s), calculadora simbólica (MATLAB/SymPy), papel para esboço.",
                                  "tips": "Use fatoração parcial inicial para visualizar multiplicidades.",
                                  "learningObjective": "Reconhecer estruturas especiais em funções de transferência para guiar a conversão.",
                                  "commonMistakes": "Ignorar multiplicidade de polos ou confundir zeros no infinito com polos no infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar decomposição parcial para polos múltiplos",
                                  "subSteps": [
                                    "Escreva a forma generalizada: G(s) = Σ [A_k / (s-p)^k] para k=1 a m (multiplicidade m).",
                                    "Multiplique por denominador e iguale coeficientes ou use fórmula de Heaviside.",
                                    "Resolva sistema linear para coeficientes A_k.",
                                    "Verifique somando frações parciais.",
                                    "Simplifique expressões algébricas."
                                  ],
                                  "verification": "Soma das frações parciais iguala G(s) original via expansão e comparação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de álgebra simbólica, equações lineares solver.",
                                  "tips": "Comece com o termo de maior k usando derivadas para Heaviside.",
                                  "learningObjective": "Dominar decomposição parcial generalizada para polos múltiplos.",
                                  "commonMistakes": "Erro nos coeficientes de termos derivados ou esquecimento de termos completos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar zeros no infinito (funções impróprias)",
                                  "subSteps": [
                                    "Se grau(num) > grau(den), execute divisão polinomial para obter parte polinomial Q(s) + resto R(s)/D(s).",
                                    "Se grau(num) = grau(den), extraia ganho direto D0 + R(s)/D(s).",
                                    "Converta Q(s) em integradores em série no espaço de estados.",
                                    "Aplique decomposição parcial no resto próprio R(s)/D(s).",
                                    "Documente separação clara."
                                  ],
                                  "verification": "G(s) = Q(s) + R(s)/D(s) e R(s)/D(s) é própria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Divisor polinomial tool, MATLAB polydiv.",
                                  "tips": "Normalize para monico denominador antes da divisão.",
                                  "learningObjective": "Separar componentes impróprios para conversão modular.",
                                  "commonMistakes": "Divisão incorreta levando a restos impróprios ou perda de termos constantes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter para espaço de estados e combinar estruturas",
                                  "subSteps": [
                                    "Para cada fração parcial simples: use forma canônica observador ou controlador.",
                                    "Para polos múltiplos: use Jordan block na matriz A.",
                                    "Para parte polinomial: adicione estados de feedforward ou integradores em cascata.",
                                    "Combine em cascata (multiplicação) ou paralelo (soma) via matrizes compostas.",
                                    "Escreva matrizes A, B, C, D finais."
                                  ],
                                  "verification": "Matrizes resultantes têm dimensões corretas e estrutura Jordan para múltiplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabelas de formas canônicas, MATLAB ss() function.",
                                  "tips": "Use representação em paralelo para decomposição parcial.",
                                  "learningObjective": "Construir realizações de estado para casos especiais.",
                                  "commonMistakes": "Estrutura errada de Jordan ou conexões incorretas em cascata."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar equivalência da conversão",
                                  "subSteps": [
                                    "Converta espaço de estados de volta para G(s) via tf(ss(A,B,C,D)).",
                                    "Compare polos, zeros e resposta ao degrau.",
                                    "Simule respostas em tempo discreto.",
                                    "Confirme minimalidade via rank observability/controllability.",
                                    "Ajuste se necessário."
                                  ],
                                  "verification": "Função de transferência reconstruída matches original dentro de tolerância numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB Control Systems Toolbox ou Python control library.",
                                  "tips": "Use step() e impulse() para plots comparativos.",
                                  "learningObjective": "Validar corretude da modelagem em espaço de estados.",
                                  "commonMistakes": "Tolerar discrepâncias numéricas sem investigar não-minimalidade."
                                }
                              ],
                              "practicalExample": "Para G(s) = (s^2 + 3s + 2) / [s^2 (s+1)] (polos múltiplos em s=0, zeros finitos), divida para Q(s)=1 + (s+1)/[s^2 (s+1)], decompõe resto em A/s + B/s^2 + C/(s+1), converte cada para SS e combine em paralelo com feedforward.",
                              "finalVerifications": [
                                "Polos e multiplicidades preservados na matriz A (autovalores).",
                                "Zeros no infinito refletidos por D não-zero ou dimensões de estado.",
                                "Resposta ao degrau simulada matches analítica.",
                                "Sistema mínimo (rank observability = rank controllability = n).",
                                "Conversão inversa yields G(s) idêntica.",
                                "Estabilidade consistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição parcial (coeficientes corretos ±0.01).",
                                "Correta identificação de casos especiais (100%).",
                                "Matrizes A,B,C,D bem-formadas sem erros dimensionais.",
                                "Verificação numérica com erro <1e-6.",
                                "Explicação clara de adaptações para múltiplos/zeros infinito.",
                                "Eficiência na combinação (sem estados redundantes)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (formas de Jordan), análise de polinômios.",
                                "Programação: Simulação em MATLAB/Python para validação.",
                                "Física: Dinâmica de sistemas aeronáuticos (ex: controle de atitude).",
                                "Engenharia de Controle: Estabilização de plantas com polos múltiplos.",
                                "Estatística: Análise de minimalidade via singular values."
                              ],
                              "realWorldApplication": "Em sistemas de controle de aeronaves, como estabilização de atitude em drones ou aviões, onde modelos de transferência de giroscópios têm polos múltiplos (integradores) e zeros no infinito (acelerômetros), permitindo simulações precisas em espaço de estados para LQR ou observadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Análise de Sinais Contínuos e Discretos",
                "description": "Inclui séries e transformadas de Fourier, janelamento, amostragem e transformada de Fourier discreta.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Séries de Fourier",
                    "description": "Representação de sinais periódicos contínuos como soma de funções harmônicas sinusoidais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Sinais Periódicos e Base Harmônica",
                        "description": "Compreensão dos sinais periódicos contínuos no tempo e sua decomposição em componentes harmônicas sinusoidais com frequências múltiplas da fundamental, preparando o terreno para a representação via séries de Fourier.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar e caracterizar sinais periódicos",
                            "description": "Dado um sinal x(t), determinar se é periódico, calcular o período fundamental T, a frequência fundamental f0 = 1/T e a pulsação fundamental ω0 = 2π/T, considerando casos com períodos comuns.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Propriedades de Sinais Periódicos",
                                  "subSteps": [
                                    "Estude a definição formal: um sinal x(t) é periódico se existe T > 0 tal que x(t + T) = x(t) para todo t.",
                                    "Aprenda que o período fundamental T0 é o menor T > 0 que satisfaz a condição.",
                                    "Analise exemplos básicos: sin(ωt), cos(ωt), sinal quadrado e dente de serra.",
                                    "Diferencie sinais periódicos de aperiódicos, como exponenciais decrescentes.",
                                    "Visualize graficamente a repetição do sinal em pelo menos dois períodos."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e identifique o T0 de um sinal seno simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim)",
                                    "Gráficos de funções trigonométricas online (Desmos ou MATLAB)"
                                  ],
                                  "tips": "Desenhe o gráfico manualmente para internalizar a repetição visual.",
                                  "learningObjective": "Dominar a definição conceitual de periodicidade e período fundamental.",
                                  "commonMistakes": [
                                    "Confundir período com amplitude.",
                                    "Achar que sinais quasi-periódicos são estritamente periódicos.",
                                    "Ignorar que T0 é o menor positivo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar se um Sinal Dado é Periódico",
                                  "subSteps": [
                                    "Examine a forma matemática do sinal x(t) e procure padrões repetitivos.",
                                    "Teste a condição x(t + T) = x(t) para possíveis T candidatos.",
                                    "Para somas de funções periódicas, verifique se todos os períodos têm um múltiplo comum (MMC).",
                                    "Use gráficos para inspecionar visualmente a repetição.",
                                    "Classifique como 'periódico', 'aperiódico' ou 'indeterminado' com justificativa."
                                  ],
                                  "verification": "Analise 3 sinais dados (ex: sin(t) + cos(2t), e^{-t} sin(t)) e classifique corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib)",
                                    "Lista de 5 sinais de exemplo impressa"
                                  ],
                                  "tips": "Comece sempre testando T pequeno e verifique se funciona para todo t.",
                                  "learningObjective": "Desenvolver habilidade para determinar periodicidade em sinais arbitrários.",
                                  "commonMistakes": [
                                    "Assumir periodicidade só por repetição visual aproximada.",
                                    "Esquecer de verificar para somas de harmônicos incommensuráveis.",
                                    "Não testar múltiplos períodos possíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Período Fundamental T0",
                                  "subSteps": [
                                    "Para sinal único como sin(2πft), calcule T0 = 1/f.",
                                    "Para combinações, encontre o MMC dos períodos individuais Ti.",
                                    "Confirme que T0 é o menor valor testando submultiplos.",
                                    "Resolva equações como x(t + T) = x(t) algebricamente.",
                                    "Valide com gráfico: o sinal deve se repetir exatamente em T0."
                                  ],
                                  "verification": "Calcule T0 para x(t) = sin(2πt/3) + cos(4πt/5) e prove que é o MMC.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou Python para MMC",
                                    "Folha de exercícios com sinais compostos"
                                  ],
                                  "tips": "Liste todos Ti individuais e use MMC = lcm(T1*k1, T2*k2) ajustando inteiros.",
                                  "learningObjective": "Calcular precisamente o período fundamental em casos simples e compostos.",
                                  "commonMistakes": [
                                    "Tomar MMC incorreto dos períodos.",
                                    "Confundir período de uma componente com T0 total.",
                                    "Não verificar se T candidato é o menor."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Frequência Fundamental f0 e Pulsação ω0",
                                  "subSteps": [
                                    "Calcule f0 = 1/T0 a partir do T0 obtido.",
                                    "Compute ω0 = 2π / T0 ou 2π f0.",
                                    "Expresse resultados em unidades corretas (Hz para f0, rad/s para ω0).",
                                    "Verifique consistência: harmônicos devem ser múltiplos inteiros de f0.",
                                    "Aplique em sinal real: plote e anote f0 e ω0 no gráfico."
                                  ],
                                  "verification": "Para um sinal dado, forneça T0, f0 e ω0 com 3 casas decimais e gráfico anotado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de conversão de unidades",
                                    "Software de simulação (Octave ou similar)"
                                  ],
                                  "tips": "Sempre arredonde T0 para valor exato racional antes de inverter.",
                                  "learningObjective": "Converter período em frequência e pulsação com precisão.",
                                  "commonMistakes": [
                                    "Usar f0 = 2π/T em vez de 1/T.",
                                    "Confundir f0 (Hz) com ω0 (rad/s).",
                                    "Erro de unidade em cálculos numéricos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sinal de vibração em uma asa de aeronave: x(t) = 2 sin(2π t / 4) + sin(2π t / 2). Verifique periodicidade (sim, pois períodos 4s e 2s têm MMC=4s), T0=4s, f0=0.25 Hz, ω0=π/2 rad/s. Plote para confirmar repetição a cada 4s.",
                              "finalVerifications": [
                                "Classificar corretamente 5 sinais mistos como periódicos ou não.",
                                "Calcular T0 exato para 3 sinais com períodos comuns.",
                                "Derivar f0 e ω0 sem erros aritméticos em 4 exemplos.",
                                "Explicar graficamente por que um T candidato não é fundamental.",
                                "Identificar MMC corretamente em somas de 3 componentes periódicas.",
                                "Aplicar conceitos a um sinal real-world plotado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição de periodicidade (100%).",
                                "Correção no cálculo de T0, considerando MMC (90%+).",
                                "Exatidão em f0=1/T0 e ω0=2π/T0 (sem erros de unidade).",
                                "Qualidade de verificações gráficas e algébricas.",
                                "Profundidade na análise de casos especiais (períodos irracionais).",
                                "Clareza na justificativa escrita para cada resultado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções periódicas e mínimo comum múltiplo (LCM).",
                                "Física: Ondas mecânicas e vibrações harmônicas.",
                                "Engenharia Mecânica: Análise de sinais em estruturas dinâmicas.",
                                "Processamento de Sinais: Pré-requisito para Séries de Fourier.",
                                "Informática: Simulação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, identificar sinais periódicos em dados de vibração de turbinas ou asas permite análise de ressonância, previsão de fadiga estrutural e design de sistemas de controle ativo para mitigar oscilações perigosas durante voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Reconhecer funções harmônicas ortogonais",
                            "description": "Explicar a ortogonalidade das funções {1, cos(nω0 t), sen(nω0 t)} sobre um período T, demonstrando integrais de produtos nulos para n ≠ m, fundamental para a decomposição de Fourier.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de ortogonalidade em espaços de funções",
                                  "subSteps": [
                                    "Defina ortogonalidade como a propriedade onde o produto interno de duas funções distintas é zero.",
                                    "Explique o produto interno para funções contínuas: ∫ f(t) g(t) dt sobre um intervalo.",
                                    "Discuta a importância da ortogonalidade em bases para expansão de funções.",
                                    "Compare com vetores ortogonais em álgebra linear.",
                                    "Identifique o intervalo de integração: um período T para funções periódicas."
                                  ],
                                  "verification": "Resuma em suas palavras o que significa ortogonalidade e dê um exemplo simples com vetores.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), caderno de anotações, calculadora"
                                  ],
                                  "tips": "Use analogia com vetores para visualizar melhor o conceito abstrato.",
                                  "learningObjective": "Entender a definição e relevância da ortogonalidade funcional.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto ponto simples.",
                                    "Ignorar a normalização das funções."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as funções harmônicas básicas e o período fundamental",
                                  "subSteps": [
                                    "Estabeleça ω₀ = 2π/T como frequência fundamental.",
                                    "Liste o conjunto: {1, cos(nω₀t), sin(nω₀t)} para n=1,2,...",
                                    "Desenhe gráficos de 1, cos(ω₀t), sin(ω₀t), cos(2ω₀t) sobre [0,T].",
                                    "Explique por que essas funções formam uma base harmônica para sinais periódicos.",
                                    "Verifique a periodicidade: f(t+T) = f(t) para todas."
                                  ],
                                  "verification": "Desenhe e rotule corretamente os gráficos de pelo menos três funções sobre T.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Octave/Python Matplotlib), papel milimetrado"
                                  ],
                                  "tips": "Comece com n=1 e n=2 para visualizar sobreposições mínimas.",
                                  "learningObjective": "Reconhecer e representar o conjunto ortogonal de funções harmônicas.",
                                  "commonMistakes": [
                                    "Usar ω em vez de ω₀.",
                                    "Esquecer a constante 1 como função harmônica de ordem 0."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar ortogonalidade via cálculo de integrais",
                                  "subSteps": [
                                    "Calcule ∫₀ᴵ 1 * cos(nω₀t) dt e mostre =0.",
                                    "Compute ∫₀ᴵ cos(nω₀t) cos(mω₀t) dt para n≠m e prove =0.",
                                    "Calcule ∫₀ᴵ sin(nω₀t) sin(mω₀t) dt para n≠m =0.",
                                    "Verifique casos n=m para normas (não zero).",
                                    "Use identidades trigonométricas: cosA cosB = [cos(A+B)+cos(A-B)]/2."
                                  ],
                                  "verification": "Resolva três integrais específicas e confirme resultados nulos para n≠m.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela de integrais trigonométricas, Wolfram Alpha para verificação, caderno"
                                  ],
                                  "tips": "Aplique simetria da cosseno/seno sobre período completo para simplificar.",
                                  "learningObjective": "Calcular e provar matematicamente a ortogonalidade.",
                                  "commonMistakes": [
                                    "Erros em limites de integração (0 a T, não -T/2 a T/2 sem ajuste).",
                                    "Confundir sen e cos em identidades."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e conectar à série de Fourier",
                                  "subSteps": [
                                    "Explique como integrais nulas permitem coeficientes independentes na Fourier.",
                                    "Escreva a série de Fourier: a₀/2 + Σ [aₙ cos(nω₀t) + bₙ sen(nω₀t)].",
                                    "Mostre como aₙ = (2/T) ∫ f(t) cos(nω₀t) dt devido à ortogonalidade.",
                                    "Discuta normalização e base ortonormal.",
                                    "Resolva um exemplo simples de decomposição."
                                  ],
                                  "verification": "Derive a fórmula de um coeficiente Fourier usando ortogonalidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos resolvidos de livro, MATLAB para simulação de série"
                                  ],
                                  "tips": "Pense na ortogonalidade como 'canais independentes' em comunicação.",
                                  "learningObjective": "Ligar ortogonalidade à prática da análise de Fourier.",
                                  "commonMistakes": [
                                    "Esquecer fator 2/T na normalização.",
                                    "Não reconhecer impacto em sinais não periódicos."
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule ∫₀^{2π} cos(t) cos(2t) dt usando identidade trigonométrica: resulta em 0, provando ortogonalidade para ω₀=1, n=1,m=2. Plote as funções para visualizar não sobreposição efetiva.",
                              "finalVerifications": [
                                "Calcula corretamente ∫ cos(nω₀t) sen(mω₀t) dt =0 para todos n,m.",
                                "Explica verbalmente por que o conjunto é uma base ortogonal.",
                                "Deriva fórmula de coeficiente aₙ da série de Fourier.",
                                "Identifica erros em cálculos de integrais comuns.",
                                "Aplica conceito a um sinal periódico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de integrais (100% correto).",
                                "Clareza na explicação conceitual de ortogonalidade.",
                                "Uso correto de identidades trigonométricas.",
                                "Conexão explícita com série de Fourier.",
                                "Criatividade em exemplos práticos.",
                                "Identificação de erros comuns e prevenção."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Bases ortogonais e produto interno.",
                                "Física: Ondas e vibrações harmônicas em estruturas aeronáuticas.",
                                "Processamento de Sinais: Filtros e análise espectral.",
                                "Matemática Computacional: Implementação numérica em MATLAB."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, reconhece vibrações de asas como soma de harmônicos ortogonais, permitindo decomposição Fourier para análise de fadiga estrutural e balanceamento de rotores via monitoramento de sinais dinâmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Visualizar aproximações parciais de Fourier",
                            "description": "Analisar como somas parciais de harmônicos reconstróem um sinal periódico, identificando o fenômeno de Gibbs em descontinuidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Séries de Fourier para Sinais Periódicos",
                                  "subSteps": [
                                    "Estude a representação de um sinal periódico x(t) com período T como soma de senos e cossenos harmônicos: x(t) ≈ Σ [a_n cos(2π n f_0 t) + b_n sin(2π n f_0 t)]",
                                    "Revise fórmulas para coeficientes a_0, a_n e b_n usando integrais sobre um período",
                                    "Entenda o conceito de soma parcial S_N(t) = soma de n=0 a N dos termos harmônicos",
                                    "Discuta convergência pontual e como somas parciais aproximam o sinal original",
                                    "Identifique condições para convergência uniforme (sinais contínuos e suaves)"
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de coeficientes para uma onda senoidal pura",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), notas de aula, calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Comece com sinais simples como seno puro para construir intuição antes de sinais complexos",
                                  "learningObjective": "Compreender a base matemática das séries de Fourier e somas parciais",
                                  "commonMistakes": [
                                    "Confundir frequência fundamental f_0 = 1/T com harmônicos n f_0",
                                    "Esquecer o termo DC (a_0/2)",
                                    "Ignorar normalização nas integrais de coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Analisar um Sinal Periódico com Descontinuidade",
                                  "subSteps": [
                                    "Escolha uma onda quadrada periódica: x(t) = 1 para 0 < t < T/2, -1 para T/2 < t < T",
                                    "Calcule manualmente os primeiros coeficientes a_n e b_n para n=1 a 5",
                                    "Desenhe o sinal original e discuta pontos de descontinuidade em t=0, T/2",
                                    "Preveja comportamento de aproximação em regiões contínuas vs. descontinuidades",
                                    "Compare com sinal suave como seno para contrastar convergência"
                                  ],
                                  "verification": "Liste coeficientes calculados e esboce S_1(t), S_3(t) à mão em papel",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel milimetrado, lápis, tabela de integrais, software como MATLAB ou Python para verificação rápida"
                                  ],
                                  "tips": "Use simetria ímpar da onda quadrada para simplificar: a_n=0, b_n = 4/(π n) para n ímpar",
                                  "learningObjective": "Preparar um exemplo concreto que destaque limitações da convergência de Fourier",
                                  "commonMistakes": [
                                    "Erro em limites de integração (sempre um período completo)",
                                    "Calcular coeficientes errados por esquecer fator 2/T",
                                    "Não reconhecer simetria que zera coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar e Visualizar Somas Parciais Usando Software",
                                  "subSteps": [
                                    "Implemente função em Python/MATLAB para calcular coeficientes numéricos",
                                    "Gere plots de S_N(t) para N=1,3,5,10,20,50 sobre vários períodos",
                                    "Sobreponha todos os plots com o sinal original para comparar",
                                    "Ajuste resolução temporal para visualização suave (dt=0.001*T)",
                                    "Anote como o sinal melhora em regiões suaves mas oscila em descontinuidades"
                                  ],
                                  "verification": "Produza pelo menos 5 plots de somas parciais e salve como imagens com legendas",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy, Matplotlib ou MATLAB, Jupyter Notebook"
                                  ],
                                  "tips": "Use loop para somar harmônicos incrementalmente e plotar em subplots para comparação fácil",
                                  "learningObjective": "Dominar visualização numérica de aproximações parciais de Fourier",
                                  "commonMistakes": [
                                    "Resolução temporal baixa causando aliasing visual",
                                    "Erro em fase dos harmônicos",
                                    "Não normalizar eixo de tempo corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Explicar o Fenômeno de Gibbs",
                                  "subSteps": [
                                    "Observe overshoot (oscilação >9% do salto) perto de descontinuidades em S_N para N grande",
                                    "Meça amplitude do overshoot em plots para N=10,50 e confirme ~9% do valor de salto (2 para onda quadrada)",
                                    "Explique causa: truncamento abrupto da série infinita causa ringing",
                                    "Discuta mitigação: usar janelas ou séries de Walsh, mas note que Gibbs é inerente",
                                    "Relacione com aplicações: impacto em filtros e processamento de áudio/imagem"
                                  ],
                                  "verification": "Escreva relatório curto com medições de overshoot e explicação física/matemática",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Plots gerados no step 3, referências online sobre Gibbs (Wikipedia, artigos acadêmicos)"
                                  ],
                                  "tips": "Zoom nos plots perto da descontinuidade para medir overshoot precisamente com cursor",
                                  "learningObjective": "Reconhecer e quantificar o fenômeno de Gibbs em aproximações de Fourier",
                                  "commonMistakes": [
                                    "Confundir Gibbs com aliasing",
                                    "Achar que overshoot diminui com N (ele persiste)",
                                    "Não medir corretamente o percentual relativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python, gere uma onda quadrada com T=1s, plote S_1(t) (apenas 1º harmônico, seno aproximado), S_5(t) (mais definição mas ringing inicial), até S_50(t) mostrando Gibbs claro perto de t=0.5s com overshoot de ~1.18 (9% de 2).",
                              "finalVerifications": [
                                "Pode calcular coeficientes de Fourier corretamente para onda quadrada até N=5",
                                "Gera plots precisos de somas parciais mostrando convergência progressiva",
                                "Identifica overshoot de Gibbs em descontinuidades com medição quantitativa",
                                "Explica verbalmente como somas parciais reconstróem sinal em regiões suaves vs. jump",
                                "Compara visualmente com sinal suave sem Gibbs",
                                "Discute limitações da série de Fourier truncada"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes calculados (erro <1%)",
                                "Qualidade visual dos plots (resolução, legendas, sobreposições claras)",
                                "Correta identificação e quantificação do fenômeno de Gibbs (>8.9% overshoot)",
                                "Explicação coerente da convergência e limitações",
                                "Uso apropriado de software sem erros de implementação",
                                "Relatório final estruturado com análise quantitativa"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações em estruturas aeronáuticas",
                                "Computação: Programação numérica e visualização de dados (Python/MATLAB)",
                                "Matemática: Análise harmônica e convergência de séries",
                                "Engenharia de Sinais: Processamento em aeroacústica e controle dinâmico",
                                "Processamento de Imagens: Similaridades com artefatos em DCT/JPEG"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, visualizar aproximações de Fourier é essencial para analisar vibrações de asas ou fuselagem (sinais periódicos de telemetria), detectar ressonâncias via espectros harmônicos, e mitigar ruído em sistemas de controle de voo, evitando falhas por overshoots não modelados como no fenômeno de Gibbs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Cálculo dos Coeficientes de Fourier",
                        "description": "Determinação dos coeficientes da série trigonométrica de Fourier para sinais periódicos contínuos, utilizando integrais sobre o período fundamental.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Calcular o coeficiente a0 (componente DC)",
                            "description": "Aplicar a fórmula a0 = (1/T) ∫_T x(t) dt para encontrar a média do sinal sobre um período, representando a componente contínua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de componente DC e a fórmula de a0",
                                  "subSteps": [
                                    "Explicar o que é a componente DC: valor médio do sinal x(t) ao longo de um período completo T.",
                                    "Memorizar e derivar a fórmula a0 = (1/T) ∫_0^T x(t) dt, onde a integral é sobre um período.",
                                    "Entender que a0 representa a parte contínua (constante) da série de Fourier.",
                                    "Diferenciar componente DC de componentes AC (harmônicos variáveis).",
                                    "Visualizar graficamente: a0 é a altura da linha reta que minimiza o erro médio quadrático."
                                  ],
                                  "verification": "Capaz de explicar verbalmente ou por escrito o significado físico de a0 e reescrever a fórmula corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas",
                                    "Gráficos de sinais periódicos",
                                    "Vídeo introdutório sobre Séries de Fourier"
                                  ],
                                  "tips": "Pense na DC como o 'valor médio' que você leria em um multímetro em modo DC.",
                                  "learningObjective": "Compreender o significado matemático e físico do coeficiente a0 como componente contínua.",
                                  "commonMistakes": [
                                    "Confundir a0 com a amplitude total do sinal",
                                    "Esquecer que a integral é sobre exatamente um período T",
                                    "Ignorar o fator 1/T na normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o período T e representar o sinal x(t)",
                                  "subSteps": [
                                    "Analisar o sinal x(t) para determinar seu período fundamental T (ex: para sen(ωt), T=2π/ω).",
                                    "Confirmar que o sinal é periódico: x(t+T) = x(t) para todo t.",
                                    "Esboçar o gráfico de x(t) sobre pelo menos um período para visualização.",
                                    "Definir os limites de integração: tipicamente de 0 a T ou -T/2 a T/2.",
                                    "Verificar simetrias (par/impar) que possam simplificar cálculos futuros."
                                  ],
                                  "verification": "Esboçar corretamente o sinal e anotar o valor exato de T com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software como MATLAB/Octave",
                                    "Exemplos de sinais periódicos comuns"
                                  ],
                                  "tips": "Sempre verifique T multiplicando frequência fundamental por 2π.",
                                  "learningObjective": "Identificar com precisão o período T de um sinal periódico dado.",
                                  "commonMistakes": [
                                    "Escolher intervalo errado para T (ex: meio período)",
                                    "Assumir periodicidade sem verificar",
                                    "Confundir período com frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a integral ∫_T x(t) dt",
                                  "subSteps": [
                                    "Configurar a integral definida ∫_0^T x(t) dt usando primitiva antiderivada F(t).",
                                    "Computar F(T) - F(0), avaliando nos limites.",
                                    "Aplicar propriedades de integração para sinais compostos (ex: constante + seno).",
                                    "Usar simetrias: para funções ímpares sobre período simétrico, integral pode ser zero.",
                                    "Verificar numericamente se possível, aproximando por somas de Riemann."
                                  ],
                                  "verification": "Obter o valor numérico ou simbólico da integral e confirmar com gráfico de área sob a curva.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy)",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Divida sinais complexos em termos simples: integre cada um separadamente.",
                                  "learningObjective": "Dominar o cálculo da integral definida de sinais periódicos sobre um período.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Esquecer sinal negativo em integrais",
                                    "Não simplificar expressões trigonométricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar a0, verificar e interpretar o resultado",
                                  "subSteps": [
                                    "Aplicar a0 = (1/T) * valor da integral obtida no passo anterior.",
                                    "Simplificar a expressão algébricamente para forma final.",
                                    "Interpretar: a0 é a média temporal; para senos puros, a0=0.",
                                    "Verificar consistência: para sinal constante c, a0=c.",
                                    "Plotar a aproximação DC (linha horizontal y=a0) sobre x(t)."
                                  ],
                                  "verification": "Comparar a0 calculado com média numérica de pontos amostrados do sinal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib)",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Sempre normalize dividindo por T para obter a média real.",
                                  "learningObjective": "Calcular e interpretar corretamente o coeficiente a0 como componente DC.",
                                  "commonMistakes": [
                                    "Esquecer o 1/T",
                                    "Arredondar prematuramente",
                                    "Interpretar a0 como amplitude AC"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sinal periódico x(t) = 3 + 2*cos(2πt/T) com T=2s. Calcule ∫_0^2 x(t) dt = ∫_0^2 3 dt + 2∫_0^2 cos(πt) dt = 6 + 0 = 6. Então a0 = 6/2 = 3, que é o valor médio (offset constante).",
                              "finalVerifications": [
                                "Calcular a0 corretamente para 3 sinais diferentes fornecidos.",
                                "Explicar por que a0=0 para sinais senoidais puros sem offset.",
                                "Verificar que a soma de áreas positivas e negativas equilibra para média zero em sinais simétricos.",
                                "Plotar e sobrepor a linha y=a0 ao sinal original.",
                                "Comparar resultado analítico com simulação numérica (média de 100 pontos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do período T (erro <1%).",
                                "Correção no cálculo da integral (valor exato ou com erro <0.01).",
                                "Aplicação correta do fator 1/T na normalização.",
                                "Interpretação física adequada do resultado como componente DC.",
                                "Uso apropriado de simetrias para simplificação.",
                                "Clareza na documentação dos passos e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral definido e propriedades de integrais.",
                                "Física: Análise de sinais periódicos em oscilações mecânicas e elétricas.",
                                "Processamento de Sinais: Filtragem passa-baixa para extração de DC em DSP.",
                                "Engenharia de Controle: Modelagem de sistemas lineares com offsets DC."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, calcular a0 é crucial para analisar sinais de sensores de vibração em estruturas de aeronaves, identificando o nível médio de deslocamento (offset DC) que indica desalinhamentos ou fadiga material, permitindo manutenção preditiva em sistemas de controle de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Calcular os coeficientes an e bn",
                            "description": "Utilizar as fórmulas an = (2/T) ∫_T x(t) cos(nω0 t) dt e bn = (2/T) ∫_T x(t) sen(nω0 t) dt para sinais como onda quadrada, triangular e dente de serra.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sinal periódico e identificar parâmetros fundamentais",
                                  "subSteps": [
                                    "Descreva a forma do sinal (ex: quadrada, triangular ou dente de serra) e defina x(t) em um período T.",
                                    "Determine o período fundamental T a partir da descrição do sinal.",
                                    "Calcule a frequência angular fundamental ω₀ = 2π/T.",
                                    "Defina os limites de integração sobre um período T (geralmente de -T/2 a T/2 ou 0 a T).",
                                    "Esboce graficamente x(t) para visualizar simetrias (par, ímpar) que simplificam cálculos."
                                  ],
                                  "verification": "Verifique se T, ω₀ e o esboço de x(t) estão corretos comparando com referências padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Calculadora",
                                    "Tabelas de sinais periódicos comuns"
                                  ],
                                  "tips": "Use simetria: sinais pares têm bn=0, ímpares têm an=0 (exceto a0).",
                                  "learningObjective": "Identificar corretamente os parâmetros T, ω₀ e x(t) para qualquer sinal periódico dado.",
                                  "commonMistakes": [
                                    "Confundir período fundamental com período de harmônicos",
                                    "Escolher limites de integração incorretos",
                                    "Ignorar simetrias do sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e calcular os coeficientes an",
                                  "subSteps": [
                                    "Escreva a fórmula an = (2/T) ∫_T x(t) cos(nω₀ t) dt para n=0,1,2,...",
                                    "Substitua x(t) piecewise nos intervalos apropriados dentro de T.",
                                    "Compute a integral analiticamente, resolvendo cada peça separadamente.",
                                    "Avalie os limites e simplifique o resultado para an em função de n.",
                                    "Identifique padrões, como an=0 para certos n devido a simetria."
                                  ],
                                  "verification": "Confira o resultado para n=1 com uma fórmula conhecida (ex: onda quadrada an = 4/(nπ) para n ímpar).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Tabelas de integrais trigonométricas",
                                    "Software simbólico como Wolfram Alpha para verificação opcional"
                                  ],
                                  "tips": "Para n=0, an simplifica para a0 = (2/T) ∫ x(t) dt, o termo DC.",
                                  "learningObjective": "Aplicar e resolver a integral para an corretamente para sinais dados.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2/T",
                                    "Erros em integrais de produtos trigonométricos",
                                    "Não considerar piecewise corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e calcular os coeficientes bn",
                                  "subSteps": [
                                    "Escreva a fórmula bn = (2/T) ∫_T x(t) sin(nω₀ t) dt para n=1,2,...",
                                    "Substitua x(t) piecewise e configure a integral similar a an.",
                                    "Resolva a integral analiticamente, prestando atenção a identidades trigonométricas.",
                                    "Simplifique bn em função de n e verifique simetrias (bn=0 para sinais pares).",
                                    "Calcule para os primeiros harmônicos (n=1 a 5) para observar decaimento."
                                  ],
                                  "verification": "Compare bn para onda triangular com fórmula padrão: bn = (-1)^{n+1} * 8/(n²π²) para n ímpar.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do step 2",
                                    "Gráficos de referência para comparação"
                                  ],
                                  "tips": "Use integração por partes se necessário para funções como rampa em dente de serra.",
                                  "learningObjective": "Resolver integral para bn com precisão e reconhecer padrões harmônicos.",
                                  "commonMistakes": [
                                    "Confundir sin com cos nas simetrias",
                                    "Sinais errados em limites de integração",
                                    "Não simplificar frações trigonométricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultados e sintetizar a série de Fourier",
                                  "subSteps": [
                                    "Liste an e bn para n=0 a 5 e verifique se somam a x(t) aproximado.",
                                    "Reconstrua parcialmente a série: x(t) ≈ a0/2 + Σ (an cos + bn sin).",
                                    "Compare gráfico da soma parcial com x(t) original.",
                                    "Analise convergência (decaimento de coeficientes).",
                                    "Teste com outro sinal para generalizar."
                                  ],
                                  "verification": "A soma de 5 harmônicos deve aproximar x(t) com erro <5% em pontos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB/Octave ou Python (Matplotlib)",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Plote somas parciais para visualizar Gibbs phenomenon.",
                                  "learningObjective": "Validar coeficientes através de síntese e análise de convergência.",
                                  "commonMistakes": [
                                    "Esquecer a0/2 no termo constante",
                                    "Índices errados em harmônicos",
                                    "Ignorar overshoot perto de descontinuidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma onda quadrada x(t) = 1 (0 < t < T/2), x(t) = -1 (T/2 < t < T): an = 0 para n par, an = 4/(nπ) para n ímpar; bn = 0. Para triangular x(t) = (2A/tp)|t - tp/2| ajustado, bn dominam.",
                              "finalVerifications": [
                                "Calcula corretamente an e bn para onda quadrada, obtendo an=4/(nπ) (n ímpar).",
                                "Identifica simetrias corretamente para triangular (an=0).",
                                "Reconstrói série parcial que converge visualmente a x(t).",
                                "Explica papel de ω₀ nos argumentos trigonométricos.",
                                "Aplica a dente de serra sem erros em piecewise.",
                                "Verifica decaimento 1/n ou 1/n² conforme sinal."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais (sem erros algébricos).",
                                "Correta identificação de simetrias e simplificações.",
                                "Qualidade do esboço e reconstrução gráfica.",
                                "Explicação clara de passos e justificativas.",
                                "Generalização para diferentes sinais sem prompts.",
                                "Tempo de execução dentro dos estimados com acurácia."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações harmônicas.",
                                "Programação: Implementação numérica via FFT em Python/MATLAB.",
                                "Engenharia Mecânica: Modelagem de sinais em estruturas dinâmicas.",
                                "Matemática Computacional: Integração numérica para casos complexos.",
                                "Processamento de Sinais: Pré-processamento para transformadas discretas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcula coeficientes de Fourier para analisar vibrações em asas ou hélices, detectando modos de flutter ou fadiga estrutural a partir de dados de acelerômetros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Determinar o espectro de amplitudes e fases",
                            "description": "Calcular as amplitudes Cn = √(an² + bn²) e fases φn = atan2(bn, an) a partir dos coeficientes, plotando o espectro de linhas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e organizar os coeficientes de Fourier an e bn",
                                  "subSteps": [
                                    "Liste todos os coeficientes an e bn calculados previamente para os harmônicos relevantes (n=1 a N).",
                                    "Verifique a simetria do sinal: se par, bn=0; se ímpar, an=0.",
                                    "Crie uma tabela com colunas para n, an, bn.",
                                    "Identifique o número de harmônicos significativos (onde |an| ou |bn| > threshold, ex: 0.01).",
                                    "Documente o período T e frequência fundamental ω0 do sinal."
                                  ],
                                  "verification": "Confirme que a tabela está completa e sem erros de transcrição dos coeficientes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis ou planilha Excel/Google Sheets",
                                    "Coeficientes an e bn do passo anterior"
                                  ],
                                  "tips": "Use uma planilha para facilitar cálculos posteriores e visualização.",
                                  "learningObjective": "Organizar dados de coeficientes para análise espectral eficiente.",
                                  "commonMistakes": "Esquecer harmônicos pares ou ímpares desnecessários; copiar valores errados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as amplitudes Cn para cada harmônico n",
                                  "subSteps": [
                                    "Para cada n, compute Cn = √(an² + bn²) usando calculadora ou software.",
                                    "Arredonde Cn para 4 casas decimais para precisão.",
                                    "Calcule a amplitude total C0 se aplicável (DC component).",
                                    "Adicione coluna 'Cn' à tabela de coeficientes.",
                                    "Verifique unidades: Cn deve ter as mesmas unidades do sinal x(t)."
                                  ],
                                  "verification": "Compare Cn calculado com √(an² + bn²) manualmente para pelo menos 2 valores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica ou Python (numpy.sqrt)",
                                    "Tabela de coeficientes"
                                  ],
                                  "tips": "Use a função sqrt diretamente; evite calcular manualmente para n altos.",
                                  "learningObjective": "Dominar o cálculo da magnitude espectral a partir de componentes reais e imaginários.",
                                  "commonMistakes": "Confundir √(an + bn²) em vez de √(an² + bn²); esquecer sinal negativo em bn."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as fases φn para cada harmônico n",
                                  "subSteps": [
                                    "Para cada n, compute φn = atan2(bn, an) em radianos ou graus (especifique).",
                                    "Use atan2 para determinar o quadrante correto (diferente de atan).",
                                    "Adicione coluna 'φn' à tabela, normalizando fases para [-π, π].",
                                    "Calcule fases em graus se preferido para plotagem (φ_deg = φ_rad * 180/π).",
                                    "Verifique consistência: para an>0, bn=0 → φn=0."
                                  ],
                                  "verification": "Teste com caso conhecido: an=1, bn=0 → φn=0; an=0, bn=1 → φn=π/2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com atan2 ou Python (numpy.arctan2)",
                                    "Tabela atualizada com Cn"
                                  ],
                                  "tips": "Sempre use atan2(bn, an), não atan(bn/an), para evitar erros de quadrante.",
                                  "learningObjective": "Compreender e aplicar cálculo de fase corretamente considerando o plano complexo.",
                                  "commonMistakes": "Usar atan em vez de atan2; inverter argumentos (atan2(an,bn))."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar o espectro de linhas de amplitudes e fases",
                                  "subSteps": [
                                    "Crie gráfico de amplitudes: eixo x = n ou f=n/T, y=Cn (linha com marcadores).",
                                    "Crie gráfico de fases: eixo x = n ou f, y=φn (linha com marcadores).",
                                    "Use software para plotagem: label eixos, título 'Espectro de Amplitudes/Fases'.",
                                    "Inclua linha de frequência fundamental e múltiplos.",
                                    "Salve/exporte os plots como imagem ou PDF."
                                  ],
                                  "verification": "O plot mostra picos nos harmônicos esperados? Fases coerentes com sinal?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python (matplotlib, numpy) ou MATLAB/Octave",
                                    "Tabela completa com Cn e φn"
                                  ],
                                  "tips": "Use stem plot para espectro de linhas: plt.stem(n, Cn).",
                                  "learningObjective": "Visualizar e interpretar o espectro de Fourier graficamente.",
                                  "commonMistakes": "Plotar Cn vs tempo em vez de frequência; esquecer normalizar fases."
                                }
                              ],
                              "practicalExample": "Dado sinal x(t) = cos(2πt) + 0.5 sin(4πt), T=1s. Coeficientes: n=1 a1=1 b1=0; n=2 a2=0 b2=0.5. Calcule: C1=√(1+0)=1, φ1=atan2(0,1)=0; C2=√(0+0.25)=0.5, φ2=atan2(0.5,0)=π/2. Plot: stems em n=1 (C=1,φ=0), n=2 (C=0.5,φ=90°).",
                              "finalVerifications": [
                                "Todas Cn = √(an² + bn²) com precisão <0.01.",
                                "Fases φn corretas via atan2, verificadas em quadrantes.",
                                "Plots mostram espectro de linhas com labels corretos (frequência em Hz).",
                                "Soma de potências: ∑ Cn²/2 ≈ variância do sinal.",
                                "Nenhum harmônico zero plotado desnecessariamente.",
                                "Fases normalizadas consistentemente (radianos ou graus)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Cn e φn (erro <1%).",
                                "Correto uso de atan2 para fases.",
                                "Qualidade dos plots: eixos labelados, escalas apropriadas.",
                                "Interpretação: identificar harmônicos dominantes.",
                                "Eficiência: tempo dentro do estimado, sem erros comuns.",
                                "Documentação: tabela e plots salvos corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações em estruturas aeronáuticas.",
                                "Programação: Uso de NumPy/Matplotlib para processamento de sinais.",
                                "Matemática: Trigonometria e funções hiperbólicas/inversas.",
                                "Engenharia de Controle: Espectros em análise de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, determinar espectros de amplitudes e fases de sinais de vibração de asas ou fuselagem para detectar modos de flutter ou fadiga, permitindo manutenção preditiva e design otimizado de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.4",
                            "name": "Aplicar simplificações para sinais pares e ímpares",
                            "description": "Reconhecer simetrias: para sinais pares bn=0 e an simplificado; para ímpares an=0 e bn simplificado; para meias-ondas, usar fórmulas otimizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender definições e identificação de funções pares e ímpares",
                                  "subSteps": [
                                    "Defina função par: f(-t) = f(t) para todo t no período T",
                                    "Defina função ímpar: f(-t) = -f(t) para todo t no período T",
                                    "Identifique exemplos clássicos: cos(ωt) é par, sin(ωt) é ímpar",
                                    "Desenhe o gráfico de um sinal periódico dado e verifique simetria em torno do eixo y (par) ou origem (ímpar)",
                                    "Classifique 3 sinais de exemplo (onda quadrada simétrica, triangular ímpar, sawtooth)"
                                  ],
                                  "verification": "Classificar corretamente a paridade de pelo menos 3 sinais fornecidos, justificando com gráficos ou equações",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora gráfica ou software como MATLAB/Octave",
                                    "Tabelas de funções trigonométricas"
                                  ],
                                  "tips": "Verifique simetria sempre em relação ao ponto médio do período T/2",
                                  "learningObjective": "Identificar com precisão a paridade de sinais periódicos",
                                  "commonMistakes": [
                                    "Confundir simetria com periodicidade",
                                    "Verificar paridade fora do intervalo [-T/2, T/2]",
                                    "Ignorar sinais nem pares nem ímpares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar propriedades dos coeficientes de Fourier para sinais pares e ímpares",
                                  "subSteps": [
                                    "Lembre a fórmula geral: an = (2/T) ∫_{-T/2}^{T/2} f(t) cos(nωt) dt; bn similar com sin",
                                    "Para sinal par: bn = 0 (senos ímpares integram a zero); an = (4/T) ∫_0^{T/2} f(t) cos(nωt) dt",
                                    "Para sinal ímpar: an = 0 (cossenos pares integram a zero); bn = (4/T) ∫_0^{T/2} f(t) sin(nωt) dt",
                                    "Derive brevemente por que as integrais se dobram no intervalo positivo",
                                    "Compare computacionalmente: calcule integral geral vs. simplificada para um exemplo"
                                  ],
                                  "verification": "Derivar e escrever corretamente as fórmulas simplificadas para an e bn em sinais pares e ímpares",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de Fourier",
                                    "Software de integração simbólica (SymPy ou Mathematica)",
                                    "Exemplos impressos de sinais"
                                  ],
                                  "tips": "O fator 4/T surge porque ∫_{-a}^a g_par(t) dt = 2 ∫_0^a g_par(t) dt",
                                  "learningObjective": "Aplicar propriedades de ortogonalidade para simplificar integrais de Fourier",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 ou 4 nas integrais dobradas",
                                    "Aplicar fórmula par a sinal ímpar",
                                    "Confundir an com bn"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar simplificações na prática para calcular coeficientes",
                                  "subSteps": [
                                    "Escolha um sinal par (ex: onda quadrada simétrica) e identifique bn=0",
                                    "Calcule an usando integral de 0 a T/2 para n=1,3,5 (harmônicos ímpares típicos)",
                                    "Para sinal ímpar (ex: onda triangular ímpar), defina an=0 e calcule bn similarmente",
                                    "Implemente numericamente em código ou à mão para os primeiros 5 coeficientes",
                                    "Compare resultado com expansão completa para validar economia computacional"
                                  ],
                                  "verification": "Calcular corretamente os primeiros 4 coeficientes não-nulos para um sinal par e um ímpar dado",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Python/MATLAB com scripts de integração numérica",
                                    "Gráficos de sinais de teste"
                                  ],
                                  "tips": "Comece com n=1 para validar antes de harmônicos altos",
                                  "learningObjective": "Executar cálculos simplificados com precisão numérica",
                                  "commonMistakes": [
                                    "Erro nos limites de integração (usar 0 a T em vez de T/2)",
                                    "Não zerar os coeficientes corretos",
                                    "Arredondamento prematuro em integrais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar simplificações para simetria de meia-onda e verificação final",
                                  "subSteps": [
                                    "Defina simetria de meia-onda: f(t + T/2) = -f(t), implica só harmônicos ímpares (n=1,3,5...)",
                                    "Aplique: an,bn = 0 para n pares; fórmulas dobradas para n ímpares",
                                    "Calcule para um sinal de meia-onda (ex: onda quadrada assimétrica)",
                                    "Verifique reconstrução da série truncada e compare convergência",
                                    "Otimize: liste passos para automação em software de análise de sinais"
                                  ],
                                  "verification": "Simplificar e calcular coeficientes para um sinal de meia-onda, confirmando zeros em n pares",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB ou Python Matplotlib)",
                                    "Exemplos de sinais de meia-onda",
                                    "Tabela de harmônicos"
                                  ],
                                  "tips": "Meia-onda combina paridade com antiperiodicidade, acelerando 50% dos cálculos",
                                  "learningObjective": "Estender simplificações a simetrias avançadas como meia-onda",
                                  "commonMistakes": [
                                    "Incluir harmônicos pares em meia-onda",
                                    "Confundir meia-onda com ímpar pura",
                                    "Erro na condição f(t+T/2)=-f(t)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma onda quadrada par f(t) = 1 (|t| < T/4), -1 (T/4 < |t| < T/2), periódica: bn=0; an = (8/(nπ)) para n ímpares, 0 para pares. Calcule a1 = 8/π ≈ 2.546 e reconstrua série parcial.",
                              "finalVerifications": [
                                "Identificar paridade corretamente em 5 sinais aleatórios",
                                "Derivar fórmulas simplificadas sem consulta",
                                "Calcular an/bn para sinal par/ímpar com erro <1%",
                                "Aplicar meia-onda e zerar n pares",
                                "Reconstruir sinal com 5 harmônicos e validar visualmente",
                                "Explicar economia: redução de integrais pela metade"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de simetrias (100%)",
                                "Correção das fórmulas simplificadas (sem erros de fator 2/4)",
                                "Eficiência computacional demonstrada (tempo reduzido >50%)",
                                "Qualidade da reconstrução da série de Fourier",
                                "Explicação clara de propriedades ortogonais",
                                "Aplicação correta a meia-onda"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de vibrações e modos normais em estruturas aeronáuticas",
                                "Processamento de Sinais Digitais: FFT otimizada para simetrias",
                                "Matemática: Teoria de grupos e simetrias em funções periódicas",
                                "Engenharia de Controle: Modelagem de sistemas lineares invariantes",
                                "Eletrônica: Análise harmônica em circuitos não-lineares"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, sensores em asas detectam vibrações simétricas (pares) ou anti-simétricas (ímpares); simplificações aceleram análise em tempo real para detecção de flutter, reduzindo carga computacional em flight control systems."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Síntese, Forma Complexa e Propriedades",
                        "description": "Reconstrução do sinal original via soma infinita de harmônicos, introdução à forma exponencial complexa e principais propriedades das séries de Fourier.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Escrever e sintetizar a série trigonométrica",
                            "description": "Escrever x(t) = a0/2 + Σ [an cos(nω0 t) + bn sen(nω0 t)] e aproximar com N termos finitos para reconstruir sinais periódicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula da série trigonométrica de Fourier",
                                  "subSteps": [
                                    "Estudar a forma geral: x(t) = a0/2 + Σ [an cos(nω0 t) + bn sin(nω0 t)] de n=1 a ∞",
                                    "Identificar ω0 = 2π/T, onde T é o período fundamental",
                                    "Explicar o significado físico: decompõe sinal periódico em harmônicos",
                                    "Memorizar fórmulas dos coeficientes: a0 = (2/T)∫x(t)dt, an = (2/T)∫x(t)cos(nω0 t)dt, bn = (2/T)∫x(t)sin(nω0 t)dt",
                                    "Resolver exercício simples de identificação de termos"
                                  ],
                                  "verification": "Escrever corretamente a fórmula completa e definir ω0 para um sinal dado",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Sinais e Sistemas",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize a soma como sobreposição de ondas senoidais de frequências múltiplas",
                                  "learningObjective": "Dominar a estrutura matemática da série trigonométrica",
                                  "commonMistakes": [
                                    "Confundir a0/2 com a0",
                                    "Esquecer os limites de integração de 0 a T"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os coeficientes a0, an e bn",
                                  "subSteps": [
                                    "Determinar o período T do sinal periódico dado",
                                    "Calcular a0 integrando x(t) sobre um período",
                                    "Computar an para n=1 a 5, usando integrais analíticas ou numéricas",
                                    "Calcular bn de forma similar, prestando atenção em sinais pares/ímpares",
                                    "Verificar se soma dos quadrados dos coeficientes converge (energia de Parseval)"
                                  ],
                                  "verification": "Listar valores numéricos corretos de a0, a1, b1, a2, b2 para um sinal exemplo",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy/NumPy)",
                                    "Tabela de integrais trigonométricas"
                                  ],
                                  "tips": "Para funções pares, bn=0; para ímpares, an=0. Use isso para simplificar",
                                  "learningObjective": "Aplicar integrais para extrair componentes harmônicos",
                                  "commonMistakes": [
                                    "Erro no fator 2/T",
                                    "Limites de integração errados (deve ser um período completo)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a série trigonométrica infinita",
                                  "subSteps": [
                                    "Montar a expressão x(t) ≈ a0/2 + Σ [an cos(nω0 t) + bn sin(nω0 t)] com coeficientes calculados",
                                    "Identificar termos dominantes (maiores coeficientes)",
                                    "Escrever a série em forma simbólica para t genérico",
                                    "Discutir convergência: ponto a ponto para funções contínuas com derivadas",
                                    "Comparar com sinal original qualitativamente"
                                  ],
                                  "verification": "Escrever a série infinita corretamente para o sinal exemplo",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para fórmulas (LaTeX online)"
                                  ],
                                  "tips": "Agrupe termos por frequência para clareza",
                                  "learningObjective": "Sintetizar a representação harmônica infinita do sinal",
                                  "commonMistakes": [
                                    "Omitir sen ou cos em termos",
                                    "Índice n começando em 0 incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aproximar com N termos finitos e sintetizar o sinal",
                                  "subSteps": [
                                    "Escolher N (ex: 5, 10) e truncar a soma até n=N",
                                    "Implementar numericamente em software para plotar x_N(t) vs x(t)",
                                    "Analisar erro de aproximação (MSE ou visual)",
                                    "Aumentar N e observar Gibbs phenomenon em descontinuidades",
                                    "Reconstruir sinal e validar periodicidade"
                                  ],
                                  "verification": "Gerar gráfico mostrando boa aproximação para N=10",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "MATLAB, Python (Matplotlib/NumPy) ou Octave",
                                    "Sinal de teste periódico"
                                  ],
                                  "tips": "Use loop for n=1 to N para somar termos eficientemente",
                                  "learningObjective": "Implementar síntese finita e avaliar qualidade da reconstrução",
                                  "commonMistakes": [
                                    "Escala errada no plot (normalizar tempo)",
                                    "Não truncar corretamente a soma"
                                  ]
                                }
                              ],
                              "practicalExample": "Para x(t) = |sen(2π t)| com T=1 (onda triangular plena), calcule a0=2/π, an=(8/-π(4n²-1)) para n ímpar, bn=0. Escreva série e aproxime com N=5, plotando em [0,2] para ver overshoot de Gibbs.",
                              "finalVerifications": [
                                "Escreve fórmula trigonométrica sem erros",
                                "Calcula coeficientes corretos para sinal par/ímpar",
                                "Implementa síntese finita em código e plota",
                                "Identifica harmônicos dominantes",
                                "Explica convergência e limitações",
                                "Aplica Parseval para verificar energia"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de integrais (erro <1%)",
                                "Correção na escrita da série (todos termos presentes)",
                                "Qualidade da aproximação visual (erro RMS <5% para N=10)",
                                "Análise de erros comuns como Gibbs",
                                "Clareza na implementação computacional",
                                "Conexão com propriedades físicas do sinal"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e séries infinitas",
                                "Física: Análise de ondas e vibrações harmônicas",
                                "Computação: Programação numérica e visualização de dados",
                                "Engenharia: Processamento de sinais em controle dinâmico"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, sintetiza séries de Fourier para analisar vibrações periódicas em hélices ou asas, permitindo detecção de ressonâncias e design de sistemas de amortecimento em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Converter para forma exponencial complexa",
                            "description": "Expressar x(t) = Σ_{n=-∞}^∞ cn e^{j n ω0 t}, com cn = (1/T) ∫_T x(t) e^{-j n ω0 t} dt, relacionando cn = (an - j bn)/2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma trigonométrica da Série de Fourier",
                                  "subSteps": [
                                    "Identifique a forma geral da série trigonométrica: x(t) = a0/2 + Σ_{n=1}^∞ (an cos(n ω0 t) + bn sin(n ω0 t)).",
                                    "Calcule ou liste os coeficientes an e bn para um sinal periódico dado x(t) com período T.",
                                    "Verifique as propriedades de an (pares) e bn (ímpares) para sinais pares/ímpares.",
                                    "Plote ou esboce x(t) usando os coeficientes trigonométricos para visualização.",
                                    "Confirme o período fundamental ω0 = 2π/T."
                                  ],
                                  "verification": "Coeficientes an e bn calculados corretamente e coincidem com valores conhecidos para o sinal exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), calculadora científica, papel e lápis para cálculos manuais"
                                  ],
                                  "tips": "Comece com sinais simples como onda quadrada para praticar cálculos de an e bn.",
                                  "learningObjective": "Compreender e calcular coeficientes da forma trigonométrica como base para conversão.",
                                  "commonMistakes": [
                                    "Confundir limites de integração (deve ser sobre um período T), esquecer fator 1/T em bn para alguns casos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a forma exponencial complexa da Série de Fourier",
                                  "subSteps": [
                                    "Estude a representação: x(t) = Σ_{n=-∞}^∞ cn e^{j n ω0 t}, onde cn são coeficientes complexos.",
                                    "Derive ou memorize a fórmula de cn: cn = (1/T) ∫_T x(t) e^{-j n ω0 t} dt.",
                                    "Discuta simetria: c_{-n} = c_n^* para sinais reais (conjugado complexo).",
                                    "Compare visualmente as duas formas usando um diagrama de Euler.",
                                    "Calcule cn diretamente via integral para n=0,1,-1 em um sinal simples."
                                  ],
                                  "verification": "Escreva corretamente as fórmulas de x(t) exponencial e cn, com limites corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivadas de Euler (e^{jθ} = cosθ + j sinθ), software MATLAB ou Python para plotar exponenciais"
                                  ],
                                  "tips": "Use a identidade de Euler para ligar exponenciais a seno e cosseno intuitivamente.",
                                  "learningObjective": "Dominar a notação e fórmula da forma exponencial complexa.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo no expoente de cn, ou limites de n de -∞ a ∞."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer e aplicar a relação entre coeficientes trigonométricos e complexos",
                                  "subSteps": [
                                    "Derive cn a partir de an e bn: cn = (an - j bn)/2 para n > 0; c_{-n} = (an + j bn)/2; c0 = a0/2.",
                                    "Para n=0: confirme c0 = a0/2.",
                                    "Aplique a relação em um exemplo numérico: liste an, bn e compute cn, c_{-n}.",
                                    "Verifique que Σ cn e^{j n ω0 t} reconstrói a forma trigonométrica.",
                                    "Use propriedades para sinais pares (bn=0, cn reais) ou ímpares (an=0, cn imaginários).",
                                    "Calcule para pelo menos 3 harmônicos (n=1,2,3)."
                                  ],
                                  "verification": "Relação cn = (an - j bn)/2 aplicada corretamente, com valores complexos conjugados para ±n.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela de identidades trigonométricas, calculadora complexa ou app (Wolfram Alpha), exemplos resolvidos de livro"
                                  ],
                                  "tips": "Escreva an e bn em termos de integrais e substitua para derivar a relação passo a passo.",
                                  "learningObjective": "Converter coeficientes entre formas usando a relação exata.",
                                  "commonMistakes": [
                                    "Inverter o sinal de j em cn vs c_{-n}, esquecer divisão por 2."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e verificar a forma exponencial completa",
                                  "subSteps": [
                                    "Escreva x(t) = Σ_{n=-∞}^∞ cn e^{j n ω0 t} usando todos cn calculados.",
                                    "Some termos para n=0, ±1, ±2 e compare com a forma original.",
                                    "Plote ou simule a soma parcial para validar convergência.",
                                    "Teste propriedades como lineariedade ou shift de tempo na forma complexa.",
                                    "Resolva um problema completo: dado x(t) trigonométrica, converta para exponencial."
                                  ],
                                  "verification": "Sinal reconstruído na forma exponencial equivale à original em pelo menos 3 pontos de amostragem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib), sinal exemplo periódico"
                                  ],
                                  "tips": "Comece somando poucos termos (N=2) e aumente para ver Gibbs phenomenon se aplicável.",
                                  "learningObjective": "Aplicar a conversão completa e validar equivalência.",
                                  "commonMistakes": [
                                    "Não incluir termos negativos n, ou erros de fase em e^{j n ω0 t}."
                                  ]
                                }
                              ],
                              "practicalExample": "Para x(t) = (4/π) Σ_{k=1,3,5...} (1/k) sin(k ω0 t) (onda quadrada), compute a1=0, b1=4/π, etc., então c1 = -j (2/π), c_{-1} = j (2/π), e escreva x(t) = Σ c_n e^{j n ω0 t}.",
                              "finalVerifications": [
                                "Calcula cn corretamente para n=0,1,-1 usando relação com an,bn.",
                                "Reconstrói x(t) exponencial que matches a trigonométrica numericamente.",
                                "Identifica simetria cn = c_{-n}^* para sinal real.",
                                "Aplica conversão em novo sinal sem erros aritméticos.",
                                "Explica verbalmente por que a forma complexa é útil (ex: filtros digitais)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação cn = (an - j bn)/2 (100% correto).",
                                "Cálculos numéricos de cn sem erros complexos (>95% acurácia).",
                                "Validação de equivalência via soma de termos (erro <1%).",
                                "Uso correto de propriedades (simetria, período).",
                                "Clareza na escrita da série final exponencial.",
                                "Tempo de resolução eficiente (<3h para exemplo completo)."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais: FFT usa forma complexa para análise rápida.",
                                "Física Quântica: Estados de onda em mecânica quântica semelhantes a expansões exponenciais.",
                                "Engenharia de Controle: Análise de estabilidade via polos complexos em domínio frequência.",
                                "Matemática Avançada: Análise Complexa e resíduos para integrais de cn."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, converte séries de Fourier de vibrações de asas (medidas como senos/cossenos) para forma complexa, permitindo análise eficiente via FFT em MATLAB para detecção de falhas estruturais em aeronaves durante testes de fadiga dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Aplicar propriedades das séries de Fourier",
                            "description": "Utilizar propriedades como linearidade, deslocamento temporal (fase), diferenciação (multiplicação por jnω0), Parseval e simetria dos coeficientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e demonstrar a propriedade de linearidade e simetria nos coeficientes de Fourier",
                                  "subSteps": [
                                    "Revise a definição de linearidade: se x(t) tem coeficientes c_n e y(t) tem d_n, então a(sx + by)(t) tem a c_n + b d_n.",
                                    "Estude simetria: para sinais pares, c_n reais; ímpares, imaginários puros; verifique com fórmulas matemáticas.",
                                    "Resolva exercícios simples somando dois sinais periódicos conhecidos e comparando coeficientes diretos vs. via linearidade.",
                                    "Analise simetria em sinais comuns como onda quadrada e triangular, plotando coeficientes.",
                                    "Verifique simetria usando propriedades para sinais reais: c_{-n} = conj(c_n)."
                                  ],
                                  "verification": "Calcule coeficientes de uma soma de dois sinais usando linearidade e confirme igualando ao cálculo direto; plote para visual simetria.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim ou similar)",
                                    "Caderno de exercícios",
                                    "Software como MATLAB ou Python (numpy, matplotlib)"
                                  ],
                                  "tips": "Sempre normalize o período fundamental para evitar erros em ω0; use tabelas de séries conhecidas como base.",
                                  "learningObjective": "Dominar linearidade para decomposição aditiva e simetria para simplificação de cálculos.",
                                  "commonMistakes": [
                                    "Esquecer fator de escala no período",
                                    "Confundir simetria par/ímpar com coeficientes complexos",
                                    "Não conjugar corretamente para sinais reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar propriedades de deslocamento temporal e mudança de fase",
                                  "subSteps": [
                                    "Lembre a propriedade: deslocamento τ em x(t) multiplica c_n por e^{-j n ω0 τ}.",
                                    "Derive intuitivamente o efeito de fase em espectro de amplitude constante.",
                                    "Aplique a uma onda senoidal pura, calculando série deslocada analiticamente.",
                                    "Estenda para sinal arbitrário: use série conhecida, aplique deslocamento e verifique reconstrução.",
                                    "Simule numericamente em software, comparando sinal original e deslocado."
                                  ],
                                  "verification": "Desloque um sinal periódico por τ= T/4, compute c_n via propriedade e reconstrua via síntese para matching exato.",
                                  "estimatedTime": "1.5-2.5 horas",
                                  "materials": [
                                    "Folhas de derivadas de Fourier",
                                    "MATLAB/Python para plotagem de fase",
                                    "Exercícios de livro-texto"
                                  ],
                                  "tips": "Mantenha ângulo em radianos; teste com τ múltiplo de T para ver rotação nula.",
                                  "learningObjective": "Usar deslocamento para modelar delays em sistemas dinâmicos sem recalcular integrais.",
                                  "commonMistakes": [
                                    "Sinal do expoente (use -j para delay)",
                                    "Ignorar wrap-around em fase >2π",
                                    "Não ajustar ω0 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar diferenciação (multiplicação por j n ω0) e teorema de Parseval",
                                  "subSteps": [
                                    "Estude diferenciação: derivada de x(t) tem coeficientes j n ω0 c_n.",
                                    "Aplique a sinais suaves vs. discontinuos, notando amplificação de harmônicos altos.",
                                    "Revise Parseval: energia temporal = soma |c_n|^2 / T, prove conservação.",
                                    "Calcule energia de sinal via Parseval vs. integral direto para validação.",
                                    "Combine diferenciação com Parseval em sinal derivado."
                                  ],
                                  "verification": "Derive uma rampa periódica, multiplique c_n por j n ω0, aplique Parseval e confirme energia igual.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy)",
                                    "Tabelas de energias de sinais",
                                    "Simulador de Fourier (online ou local)"
                                  ],
                                  "tips": "Para sinais com saltos, adicione termo de Gibbs na verificação; integre Parseval para normalização.",
                                  "learningObjective": "Aplicar para análise de taxas de mudança e verificação de energia em sinais dinâmicos.",
                                  "commonMistakes": [
                                    "Fator j vs. -j dependendo da convenção",
                                    "Esquecer normalização 1/T em Parseval",
                                    "Diferenciar termo DC incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar todas as propriedades em problemas complexos de síntese e análise",
                                  "subSteps": [
                                    "Selecione sinal composto: soma de quadrada + senoide deslocada e derivada.",
                                    "Use linearidade para somar, deslocamento para phase shift, diferenciação para derivada.",
                                    "Aplique simetria/Parseval para verificação final de resultados.",
                                    "Resolva sem propriedades (integral direta) para comparar eficiência.",
                                    "Analise em contexto aeronáutico: vibração modelada como série deslocada."
                                  ],
                                  "verification": "Reconstrua sinal completo via síntese, compare erro RMS com original; valide Parseval.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Projeto prático em Python/MATLAB",
                                    "Dados de vibração real (dataset online)",
                                    "Checklist de propriedades"
                                  ],
                                  "tips": "Combine propriedades em sequência lógica: linearidade primeiro, depois modulações; documente cada aplicação.",
                                  "learningObjective": "Resolver problemas reais eficientemente combinando propriedades sem computação pesada.",
                                  "commonMistakes": [
                                    "Ordem errada de aplicação (ex: diferenciar antes de deslocar)",
                                    "Perder DC ou harmônicos pares",
                                    "Erro acumulado em fases múltiplas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de asa de aeronave, modelada como x(t) = onda quadrada + senoide harmônica. Para simular delay de propagação (deslocamento τ), use propriedade de fase em c_n; derive para aceleração (j n ω0 c_n); verifique energia via Parseval para validar modelo físico.",
                              "finalVerifications": [
                                "Aplicar linearidade corretamente em soma de 3+ sinais com erro <1%.",
                                "Calcular deslocamento e fase para τ arbitrário, reconstruindo com fidelidade >99%.",
                                "Usar diferenciação em sinal com Gibbs, prevendo amplificação harmônica.",
                                "Validar Parseval com desvio <0.5% vs. integral temporal.",
                                "Combinar 3+ propriedades em problema novo, justificando cada passo.",
                                "Analisar simetria em sinal real, listando c_n conjugaados corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas e cálculos sem erros algébricos (90%+).",
                                "Eficiência: uso de propriedades reduz tempo vs. integral direta (>50%).",
                                "Justificativa: explicar por que cada propriedade se aplica.",
                                "Verificação: incluir Parseval e síntese para todos exemplos.",
                                "Criatividade: aplicar a contexto aeronáutico real.",
                                "Clareza: diagramas/plots de espectro fase/amplitude."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações em estruturas aeronáuticas.",
                                "Programação: Implementação numérica de séries em Python/MATLAB para simulações.",
                                "Controle de Sistemas: Modelagem de delays e derivadas em laços de feedback.",
                                "Matemática: Complexos, integrais e teoremas de energia.",
                                "Engenharia Mecânica: Análise modal e ressonância harmônica."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, propriedades de Fourier aceleram análise de sinais de sensores em testes de fadiga de asas, prevendo ressonâncias, otimizando controle de flaps via modelagem de delays de fase, e validando consumo de energia em sistemas dinâmicos sem simulações full-integração custosas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Transformada de Fourier",
                    "description": "Transformada integral para decomposição de sinais contínuos aperiódicos em espectro de frequências.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Definição e Fórmula da Transformada de Fourier",
                        "description": "Conceito fundamental da transformada integral que decompõe um sinal contínuo aperiódico em suas componentes de frequência complexas exponenciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Reconhecer a fórmula da Transformada de Fourier direta",
                            "description": "Identificar e reproduzir a integral definida da Transformada de Fourier para um sinal x(t): X(ω) = ∫_{-∞}^{∞} x(t) e^{-jωt} dt, explicando o papel de cada termo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de sinais e análise espectral",
                                  "subSteps": [
                                    "Estude a definição de um sinal contínuo x(t) como uma função do tempo.",
                                    "Revise o conceito de domínio da frequência ω (rad/s) e sua relação com frequência f (Hz).",
                                    "Entenda o papel da exponencial complexa e^{-jωt} como base ortonormal para decomposição espectral.",
                                    "Discuta a necessidade de integrar de -∞ a ∞ para capturar todo o espectro do sinal.",
                                    "Identifique pré-requisitos como números complexos e integrais definidas."
                                  ],
                                  "verification": "Resuma em suas palavras o que é um sinal no tempo e no domínio da frequência, e liste 3 razões para usar transformadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), notas de aula sobre números complexos, calculadora científica"
                                  ],
                                  "tips": "Use diagramas de tempo vs. frequência para visualizar conceitos abstratos.",
                                  "learningObjective": "Compreender os blocos de construção teóricos por trás da Transformada de Fourier.",
                                  "commonMistakes": [
                                    "Confundir ω (rad/s) com f (Hz)",
                                    "Ignorar o sinal negativo no expoente",
                                    "Esquecer que x(t) é função do tempo real"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e reproduzir a fórmula da Transformada de Fourier direta",
                                  "subSteps": [
                                    "Escreva a fórmula completa: X(ω) = ∫_{-∞}^{∞} x(t) e^{-jωt} dt.",
                                    "Pratique copiando a fórmula 10 vezes, focando em cada símbolo.",
                                    "Cubra a fórmula e tente reproduzi-la do zero em papel.",
                                    "Verifique a notação: maiúscula X(ω) para domínio frequência, minúscula x(t) para tempo.",
                                    "Repita com variações: substitua t por τ se necessário para convoltução futura."
                                  ],
                                  "verification": "Reproduza a fórmula corretamente 5 vezes consecutivas sem olhar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta, quadro branco, flashcards com a fórmula"
                                  ],
                                  "tips": "Use mnemônicos: 'X de ω integra x de t vezes e ao menos j ω t dt' para lembrar a ordem.",
                                  "learningObjective": "Reproduzir com precisão a integral definida da transformada.",
                                  "commonMistakes": [
                                    "Escrever e^{jωt} em vez de e^{-jωt}",
                                    "Limites errados (0 a ∞)",
                                    "Faltar o dt no final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dissecar e explicar o papel de cada termo na fórmula",
                                  "subSteps": [
                                    "Explique X(ω): função complexa representando amplitude e fase em frequência ω.",
                                    "Descreva x(t): sinal de entrada no domínio do tempo.",
                                    "Detalhe e^{-jωt}: kernel de correlação, com parte real cos(ωt) e imaginária -sin(ωt).",
                                    "Justifique ∫_{-∞}^{∞}: soma ponderada sobre todo o tempo para espectro completo.",
                                    "Discuta dt: elemento infinitesimal de integração."
                                  ],
                                  "verification": "Escreva um parágrafo explicando cada termo e grave-se lendo para autoavaliação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre Transformada de Fourier (Khan Academy ou YouTube), software como MATLAB para plotar e^{-jωt}"
                                  ],
                                  "tips": "Pense na transformada como 'projeção' do sinal em bases sinusoidais complexas.",
                                  "learningObjective": "Articular o significado físico e matemático de cada componente.",
                                  "commonMistakes": [
                                    "Atribuir 'frequência' a t em vez de ω",
                                    "Confundir kernel com o sinal",
                                    "Ignorar natureza complexa de X(ω)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar compreensão com derivação simplificada e exemplos",
                                  "subSteps": [
                                    "Derive intuitivamente: multiplique x(t) por e^{-jωt} e integre para extrair componente em ω.",
                                    "Aplique a um sinal delta: X(ω) = 1 para todo ω.",
                                    "Teste com seno: discuta picos em ±ω0.",
                                    "Compare com Transformada de Laplace (s = jω).",
                                    "Resolva exercícios: identifique fórmulas erradas em múltipla escolha."
                                  ],
                                  "verification": "Resolva 3 problemas: reproduza fórmula, corrija versão errada, explique para 'aluno fictício'.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online (ex: MIT OCW), Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Visualize com animações de decomposição em Fourier no YouTube.",
                                  "learningObjective": "Aplicar a fórmula em contextos simples para reforçar reconhecimento.",
                                  "commonMistakes": [
                                    "Confundir direta com inversa (sinal + no expoente)",
                                    "Esquecer normalização 1/(2π)",
                                    "Aplicar limites finitos sem justificativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sinal x(t) = cos(2π f0 t), a Transformada de Fourier direta produz picos em X(ω) = π [δ(ω - 2π f0) + δ(ω + 2π f0)], revelando componentes de frequência ±f0, útil para análise de vibrações em asas de aeronaves.",
                              "finalVerifications": [
                                "Reproduz a fórmula exata sem erros em menos de 10 segundos.",
                                "Explica corretamente o papel do expoente negativo e dos limites de integração.",
                                "Identifica e corrige variações incorretas da fórmula (ex: sinal positivo no expoente).",
                                "Aplica a fórmula a um sinal simples como delta ou constante.",
                                "Discute diferenças entre transformada direta e inversa.",
                                "Desenha diagrama tempo-frequência ilustrando a transformada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução da fórmula (100% dos símbolos corretos).",
                                "Profundidade na explicação de cada termo (física e matemática).",
                                "Capacidade de identificar erros comuns em fórmulas semelhantes.",
                                "Aplicação correta em exemplos básicos sem consulta.",
                                "Clareza na comunicação oral ou escrita da explicação.",
                                "Integração com conceitos prévios como números complexos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integrais improprias e funções complexas.",
                                "Física: Análise de ondas e vibrações em estruturas aeronáuticas.",
                                "Engenharia Elétrica: Processamento de sinais em radares e comunicações.",
                                "Computação: Implementação numérica via FFT em software como MATLAB.",
                                "Análise de Dados: Espectroscopia em testes de materiais."
                              ],
                              "realWorldApplication": "Na Engenharia Aeronáutica, reconhecer a fórmula da Transformada de Fourier é essencial para analisar vibrações em turbinas ou asas durante testes de voo, decompondo sinais de sensores em frequências para detectar ressonâncias perigosas e otimizar designs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Calcular a Transformada de Fourier para funções elementares",
                            "description": "Aplicar a fórmula para calcular X(ω) de sinais como retangular, triangular, exponencial decrescente e senoide, resolvendo as integrais passo a passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula da Transformada de Fourier e definir funções elementares",
                                  "subSteps": [
                                    "Escreva a fórmula da T.F. contínua: X(ω) = ∫_{-∞}^{∞} x(t) e^{-jωt} dt",
                                    "Identifique os componentes: sinal temporal x(t), frequência angular ω e exponencial complexa e^{-jωt}",
                                    "Defina as funções elementares: retangular (pulso de amplitude A e largura τ), triangular, exponencial decrescente (e^{-at} u(t)) e senoide (sen(ω₀t))",
                                    "Normalize as funções para simplificar cálculos (ex.: τ=1 para retangular)",
                                    "Configure ferramentas de cálculo simbólico ou numérico"
                                  ],
                                  "verification": "Escrever corretamente a fórmula e esboçar as funções elementares em gráficos",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Software SymPy (Python) ou Wolfram Alpha"
                                  ],
                                  "tips": "Use convenções padrão para o sinal do expoente (-jωt) e verifique simetria das funções pares/ímpares.",
                                  "learningObjective": "Dominar a fórmula da T.F. e preparar definições precisas das funções para integração.",
                                  "commonMistakes": [
                                    "Confundir o expoente com +jωt",
                                    "Esquecer a função degrau u(t) na exponencial",
                                    "Definir funções sem limites claros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a T.F. do pulso retangular",
                                  "subSteps": [
                                    "Defina x(t) = A para |t| < τ/2, 0 caso contrário",
                                    "Escreva a integral: X(ω) = ∫_{-τ/2}^{τ/2} A e^{-jωt} dt",
                                    "Resolva a integral: fatorize A e integre e^{-jωt} = [ -1/(jω) e^{-jωt} ] de -τ/2 a τ/2",
                                    "Simplifique para X(ω) = A τ sinc(ω τ / π) ou forma equivalente",
                                    "Verifique para ω=0: X(0) = A τ (área total)"
                                  ],
                                  "verification": "Obter X(ω) = A τ [sen(ω τ / 2) / (ω τ / 2)] e plotar o espectro",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora com funções trigonométricas",
                                    "SymPy para verificação simbólica"
                                  ],
                                  "tips": "Use a identidade sen(x)/x para sinc e normalize ω para facilitar.",
                                  "learningObjective": "Executar integral indefinida e limites para função par simétrica.",
                                  "commonMistakes": [
                                    "Erros nos limites de integração",
                                    "Esquecer fator A ou τ",
                                    "Confundir sinc normalizado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a T.F. da função triangular e exponencial decrescente",
                                  "subSteps": [
                                    "Para triangular: defina x(t) = 1 - |t|/τ para |t|<τ, 0 caso contrário; divida em duas retas e integre",
                                    "Resolva integral piecewise: X(ω) leva a [sinc(ωτ/π)]² após simplificação",
                                    "Para exponencial: x(t) = e^{-at} u(t), a>0; integre X(ω) = ∫_{0}^{∞} e^{-at} e^{-jωt} dt = 1/(a + jω)",
                                    "Verifique convergência (Re(a)>0) e magnitude |X(ω)| = 1/√(a² + ω²)",
                                    "Compare os espectros: triangular mais suave que retangular"
                                  ],
                                  "verification": "Derivar X(ω) triangular como (τ sinc²(ωτ/(2π))) e exponencial como 1/(a+jω)",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha para integrais piecewise",
                                    "Software MATLAB para plotar"
                                  ],
                                  "tips": "Para triangular, convolução de retangulares acelera verificação; exponencial é Laplace com s=jω.",
                                  "learningObjective": "Lidar com funções assimétricas e piecewise via integração direta.",
                                  "commonMistakes": [
                                    "Ignorar u(t) na exponencial",
                                    "Erro em piecewise para triangular",
                                    "Falta de fator de escala"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a T.F. da senoide e sintetizar resultados",
                                  "subSteps": [
                                    "Defina x(t) = sen(ω₀ t); note que é eterna, T.F. é distribuição: X(ω) = (π/j) [δ(ω + ω₀) - δ(ω - ω₀)]",
                                    "Para prática, use senoide finita ou cos(ω₀ t): similar com deltas em ±ω₀",
                                    "Resolva integral formal ou use propriedades (derivada temporal → jω X(ω))",
                                    "Tabule os resultados: retangular→sinc, triangular→sinc², exp→1/(a+jω), sen→deltas",
                                    "Plote todos espectros e discuta largura de banda"
                                  ],
                                  "verification": "Escrever expressões corretas e identificar picos/deltas nos espectros",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de T.F. padrão (opcional)",
                                    "Ferramenta de plotagem como Desmos"
                                  ],
                                  "tips": "Senoides eternas usam deltas; para finitas, aproxime com janelas.",
                                  "learningObjective": "Aplicar T.F. a harmônicos e sintetizar conhecimento para funções elementares.",
                                  "commonMistakes": [
                                    "Tratar senoide como função L1 integrável",
                                    "Esquecer fatores π/j em deltas",
                                    "Não normalizar amplitudes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar cálculos e explorar propriedades",
                                  "subSteps": [
                                    "Use software para validar integrais numéricas/simbolicamente",
                                    "Aplique propriedades: lineariedade, escalamento temporal, convolução",
                                    "Compare com tabelas padrão de T.F.",
                                    "Analise simetria: funções reais → X(-ω)=X*(ω)",
                                    "Discuta limitações: convergência absoluta para funções L1"
                                  ],
                                  "verification": "Todos X(ω) coincidem com referências padrão em pelo menos 3 pontos chave",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "SymPy/MATLAB",
                                    "Tabela de Transformadas de Fourier"
                                  ],
                                  "tips": "Sempre cheque X(0) = ∫ x(t) dt para validação rápida.",
                                  "learningObjective": "Consolidar cálculos via verificação e propriedades.",
                                  "commonMistakes": [
                                    "Não verificar simetria complexa",
                                    "Ignorar condições de convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a T.F. de um pulso retangular x(t) = 1 para |t| < 1s, 0 caso contrário. Resultado esperado: X(ω) = 2 sen(ω)/ω = 2 sinc(ω/π). Plote o lóbulo principal e zeros.",
                              "finalVerifications": [
                                "Resolver integral retangular corretamente para sinc",
                                "Obter X(ω) = 1/(a + jω) para exponencial decrescente",
                                "Derivar sinc² para triangular via piecewise ou convolução",
                                "Identificar deltas para senoide eterna",
                                "Validar numericamente com software em ω=0, π/τ",
                                "Plotar e interpretar 4 espectros elementares"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais e simplificações (80% peso)",
                                "Passos lógicos e detalhados em subSteps",
                                "Correta aplicação de limites e funções degrau",
                                "Uso apropriado de propriedades da T.F.",
                                "Interpretação física dos espectros (largura, picos)",
                                "Validação cruzada com tabelas ou software"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Complexa e Integrais de Contorno",
                                "Física: Análise de Ondas e Vibrações Estruturais",
                                "Engenharia de Controle: Estabilidade via Polos no Plano jω",
                                "Processamento Digital de Sinais: Pré-requisito para DFT/FFT",
                                "Engenharia Aeronáutica: Espectros de Turbulência e Ruído"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular T.F. de sinais de vibração em asas ou fuselagem permite análise espectral para detecção de ressonâncias, fadiga estrutural e otimização de controle ativo de flutter, usando sensores acelerométricos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Interpretar o espectro de frequências resultante",
                            "description": "Analisar o espectro X(ω), identificando magnitude |X(ω)| e fase ∠X(ω), e relacionando com as características do sinal no domínio do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o sinal no domínio do tempo e obter a Transformada de Fourier",
                                  "subSteps": [
                                    "Examine o sinal x(t) dado, identificando suas características principais como amplitude, frequência dominante e forma (ex: senoidal, pulso).",
                                    "Aplique a fórmula da Transformada de Fourier: X(ω) = ∫_{-∞}^{∞} x(t) e^{-jωt} dt, ou use ferramentas computacionais para calcular.",
                                    "Represente X(ω) em forma polar: X(ω) = |X(ω)| e^{j∠X(ω)}.",
                                    "Verifique se o espectro é simétrico para sinais reais (magnitude par, fase ímpar).",
                                    "Documente valores em frequências chave (ω=0, ω fundamental)."
                                  ],
                                  "verification": "Confirme que X(ω) foi calculada corretamente comparando com sinal conhecido (ex: seno puro tem picos em ±ω0).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Sinal x(t) exemplo, calculadora simbólica (MATLAB/SymPy), papel e lápis para esboços.",
                                  "tips": "Comece com sinais simples como senos para validar o cálculo antes de sinais complexos.",
                                  "learningObjective": "Compreender como o sinal temporal se transforma no domínio da frequência.",
                                  "commonMistakes": "Esquecer o fator -j na exponencial ou normalizar incorretamente a integral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o espectro de magnitude |X(ω)|",
                                  "subSteps": [
                                    "Plote |X(ω)| vs. ω, destacando picos, largura de banda e decaimento.",
                                    "Identifique a frequência dominante (pico máximo) e harmônicos.",
                                    "Calcule energia total: ∫ |X(ω)|^2 dω / 2π = energia de x(t).",
                                    "Compare com propriedades do sinal: ex: pulso estreito tem largura de banda ampla.",
                                    "Anote o valor DC (em ω=0) para componente contínua."
                                  ],
                                  "verification": "O plot mostra picos corretos e simetria; energia preservada pelo teorema de Parseval.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python Matplotlib), exemplos de espectros conhecidos.",
                                  "tips": "Use escala logarítmica para |X(ω)| em sinais com decaimento rápido.",
                                  "learningObjective": "Interpretar magnitude como distribuição de energia por frequência.",
                                  "commonMistakes": "Confundir magnitude com potência; ignorar normalização em plots."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o espectro de fase ∠X(ω)",
                                  "subSteps": [
                                    "Plote ∠X(ω) vs. ω, unwrap para continuidade (evite saltos de 2π).",
                                    "Identifique saltos de fase em zeros do sinal ou descontinuidades.",
                                    "Relacione fase linear com delay temporal: φ(ω) = -ω τ.",
                                    "Verifique continuidade e simetria ímpar para sinais reais.",
                                    "Combine com magnitude para reconstruir X(ω) em pontos chave."
                                  ],
                                  "verification": "Fase unwrapped é contínua; reconstrução via IFFT aproxima x(t) original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de unwrap phase (MATLAB angle/unwrap), espectro complexo calculado.",
                                  "tips": "Sempre unwrap a fase para análise; ignore jumps de ±π inicialmente.",
                                  "learningObjective": "Entender fase como shift temporal dependente da frequência.",
                                  "commonMistakes": "Não unwrap levando a interpretações erradas; confundir com magnitude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar espectro de frequências com características do sinal temporal",
                                  "subSteps": [
                                    "Mapeie picos de |X(ω)| para componentes senoidais em x(t).",
                                    "Use fase para prever alinhamento temporal de componentes.",
                                    "Simule IFFT parcial: some 2-3 termos dominantes para aproximar x(t).",
                                    "Analise efeitos: ex: fase zero = cosseno; delay altera fase.",
                                    "Valide reconstruindo x(t) ≈ (1/2π) ∫ X(ω) e^{jωt} dω."
                                  ],
                                  "verification": "Reconstrução via termos dominantes matches >90% com x(t) original.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de FFT/IFFT (Python NumPy/SciPy), sinal original para comparação.",
                                  "tips": "Comece com poucos harmônicos para visualizar contribuição individual.",
                                  "learningObjective": "Conectar domínio frequência ao tempo via síntese.",
                                  "commonMistakes": "Ignorar fator 1/2π na inversa; somar termos sem fase correta."
                                }
                              ],
                              "practicalExample": "Considere x(t) = cos(2π t) + 0.5 cos(4π t), um sinal com fundamental 1 Hz e harmônico 2 Hz. X(ω) tem picos em |X(±2π)|=1 e |X(±4π)|=0.5, fase 0 em todos (cossenos). Relação: soma de cossenos puros reconstructs x(t) perfeitamente.",
                              "finalVerifications": [
                                "Pode plotar |X(ω)| e ∠X(ω)| corretamente para sinal dado.",
                                "Identifica corretamente frequências dominantes e sua contribuição em x(t).",
                                "Reconstrói x(t) aproximado usando 3 termos de Fourier.",
                                "Explica impacto de shift temporal no espectro de fase.",
                                "Verifica teorema de Parseval numericamente.",
                                "Discute largura de banda vs. duração do pulso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de picos de magnitude (>95% match).",
                                "Correta interpretação de fase unwrapped e delays.",
                                "Qualidade da reconstrução temporal (erro RMSE <5%).",
                                "Explicação clara de relações tempo-frequência.",
                                "Uso adequado de simetrias espectrais.",
                                "Aplicação de teoremas (Parseval, dualidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções exponenciais.",
                                "Física: Ondas e vibrações em estruturas aeronáuticas.",
                                "Processamento de Sinais: Filtros em radares e telemetria.",
                                "Controle de Sistemas: Análise de estabilidade via frequência."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, interpretar espectros de vibrações de asas ou fuselagem detecta ressonâncias (ex: fadiga por flutter), permitindo design de dampers; em telemetria de voo, analisa sinais de sensores para falhas em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Propriedades da Transformada de Fourier",
                        "description": "Conjunto de propriedades algébricas e operacionais que facilitam o cálculo e a análise de transformadas sem computar integrais diretamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Aplicar propriedades de linearidade e escalamento",
                            "description": "Usar linearidade: FT{ax(t) + by(t)} = aX(ω) + bY(ω); e escalamento temporal: FT{x(at)} = (1/|a|) X(ω/a), verificando com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e memorizar as propriedades de linearidade e escalamento da Transformada de Fourier",
                                  "subSteps": [
                                    "Estude a fórmula de linearidade: FT{ax(t) + by(t)} = aX(ω) + bY(ω), onde X(ω) = FT{x(t)} e Y(ω) = FT{y(t)}",
                                    "Analise a propriedade de escalamento temporal: FT{x(at)} = (1/|a|) X(ω/a), considerando a > 0 e a < 0",
                                    "Derive intuitivamente cada propriedade a partir da definição integral da FT: X(ω) = ∫ x(t) e^{-jωt} dt",
                                    "Anote exemplos simples de funções como retangular ou seno para fixar",
                                    "Resolva exercícios básicos de identificação de propriedades em expressões dadas"
                                  ],
                                  "verification": "Recite as fórmulas corretamente sem consultar notas e explique o impacto do escalamento no domínio da frequência",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro-texto de Sinais e Sistemas",
                                    "Notas de aula sobre FT"
                                  ],
                                  "tips": "Use mnemônicos: linearidade é como distribuir soma e multiplicação por escalares no domínio do tempo para o da frequência",
                                  "learningObjective": "Compreender conceitualmente as propriedades para aplicação direta sem derivação completa",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/|a| no escalamento",
                                    "Confundir escalamento temporal com frequência",
                                    "Ignorar o sinal de a no domínio da frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar propriedade de linearidade em sinais compostos",
                                  "subSteps": [
                                    "Escolha dois sinais simples, ex: x(t) = e^{-t}u(t), y(t) = δ(t), com FT conhecidas: X(ω) = 1/(1+jω), Y(ω)=1",
                                    "Forme sinal linear: z(t) = 2x(t) + 3y(t)",
                                    "Calcule FT{z(t)} diretamente via linearidade: Z(ω) = 2X(ω) + 3Y(ω)",
                                    "Compare com cálculo integral direto para um ω específico (ex: ω=0)",
                                    "Teste com variação de coeficientes a e b"
                                  ],
                                  "verification": "Os resultados da FT via propriedade coincidem com cálculo direto em pelo menos 3 pontos de ω",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software MATLAB ou Python (SymPy/NumPy para FT)",
                                    "Tabelas de FT comuns"
                                  ],
                                  "tips": "Sempre verifique no domínio do tempo: integre z(t) e veja se soma ponderada bate",
                                  "learningObjective": "Aplicar linearidade para decompor sinais complexos em componentes simples",
                                  "commonMistakes": [
                                    "Aplicar linearidade incorretamente a produtos não-lineares",
                                    "Esquecer de multiplicar os coeficientes a e b nas FT individuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar propriedade de escalamento temporal",
                                  "subSteps": [
                                    "Selecione sinal base x(t) com FT conhecida, ex: x(t) = rect(t), X(ω) = sinc(ω/(2π))",
                                    "Crie x(at) para a=2 e a=0.5, calculando FT via fórmula: (1/|a|) X(ω/a)",
                                    "Plote X(ω) e as FT escaladas para visualizar dilatação temporal = compressão/espaçamento em frequência",
                                    "Calcule numericamente para ω discretos e compare",
                                    "Experimente a<0 para inverter o espectro"
                                  ],
                                  "verification": "Gráficos das FT mostram compressão/dilatação correta e fator de escala 1/|a| aplicado",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python com bibliotecas FFT",
                                    "Papel milimetrado para plot manual",
                                    "Tabela de FT de funções padrão"
                                  ],
                                  "tips": "Lembre: a>1 acelera o sinal (comprime tempo, expande frequência); normalize plots para comparar amplitudes",
                                  "learningObjective": "Manipular escalas temporais e prever efeitos no espectro de frequência",
                                  "commonMistakes": [
                                    "Omitir 1/|a| causando amplitude errada",
                                    "Não inverter ω para a<0",
                                    "Confundir com escalamento em frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar linearidade e escalamento com verificação numérica",
                                  "subSteps": [
                                    "Forme sinal complexo: z(t) = 2 x(3t) + 0.5 y(0.5t), usando x(t) e y(t) anteriores",
                                    "Aplique propriedades sequencialmente: primeiro escalamento, depois linearidade",
                                    "Calcule Z(ω) analiticamente e numéricamente via FFT em software",
                                    "Compare erros em múltiplos ω (ex: DC, picos)",
                                    "Analise sensibilidade a valores de a e coeficientes"
                                  ],
                                  "verification": "Erro RMS entre FT analítica (propriedades) e numérica < 1% em intervalo de ω relevante",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python/MATLAB com FFT",
                                    "Calculadora para pontos manuais",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use amostragem alta (N>1024) na FFT para precisão; normalize sinais para unidade de energia",
                                  "learningObjective": "Integrar propriedades em problemas reais, validando com computação",
                                  "commonMistakes": [
                                    "Erro de propagação ao combinar propriedades",
                                    "Amostragem insuficiente na validação numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibração de asa de aeronave, sinal z(t) = 2 v(3t) + 0.5 a(0.5t), onde v(t) é vibração nominal e a(t) aceleração; use linearidade e escalamento para obter espectro Z(ω) rapidamente sem FT integral completa, prevendo modos de flutter escalados.",
                              "finalVerifications": [
                                "Cálculo manual de FT via propriedades bate com tabela/FFT em 5 ω's",
                                "Explicação correta do efeito de 'a' na largura do espectro",
                                "Aplicação bem-sucedida em sinal composto sem erros aritméticos",
                                "Gráficos mostram dilatação correta e amplitudes escaladas",
                                "Resolução de 2 problemas variados independentes",
                                "Discussão de limitações (ex: não-linearidades reais)"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas e cálculos (90% correto)",
                                "Compreensão conceitual demonstrada em explicações",
                                "Uso correto e sequencial das propriedades",
                                "Validação numérica com erro <5%",
                                "Criatividade em exemplos aeronáuticos",
                                "Clareza em plots e documentação"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (combinações lineares de vetores espectrais)",
                                "Física: Ondas e vibrações (escalamento em sinais mecânicos)",
                                "Programação: Implementação numérica de FT em Python/MATLAB",
                                "Engenharia de Controle: Análise de sistemas LTI via domínio frequência"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, aplica-se para analisar sinais de sensores em testes de flutter: escalar tempos de vibração medida para modelos teóricos e combinar linearmente com ruído/aceleração, acelerando detecção de instabilidades dinâmicas sem simulações full FFT custosas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Utilizar propriedades de deslocamento e convolução",
                            "description": "Aplicar deslocamento temporal: FT{x(t - t0)} = X(ω) e^{-jω t0}; e teorema da convolução: FT{x(t)*h(t)} = X(ω) H(ω), demonstrando em sinais simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a propriedade de deslocamento temporal na Transformada de Fourier",
                                  "subSteps": [
                                    "Revise a definição da Transformada de Fourier (FT): X(ω) = ∫ x(t) e^{-jωt} dt",
                                    "Analise o efeito matemático de um deslocamento x(t - t0) na integral da FT",
                                    "Derive passo a passo a fórmula FT{x(t - t0)} = X(ω) e^{-jω t0}",
                                    "Discuta o significado físico: magnitude inalterada, fase alterada linearmente",
                                    "Compare com deslocamento na frequência"
                                  ],
                                  "verification": "Derivação correta da fórmula e explicação do impacto na magnitude e fase",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), caderno para derivações, calculadora científica"
                                  ],
                                  "tips": "Use substituição u = t - t0 na integral para simplificar a derivação",
                                  "learningObjective": "Derivar e interpretar a propriedade de deslocamento temporal na FT",
                                  "commonMistakes": [
                                    "Confundir deslocamento temporal com frequência",
                                    "Esquecer o sinal negativo no expoente",
                                    "Ignorar o fator de fase"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar propriedade de deslocamento em cálculos simples",
                                  "subSteps": [
                                    "Escolha um sinal simples: x(t) = rect(t), compute sua FT X(ω) = sinc(ω/(2π))",
                                    "Aplique deslocamento: x(t - t0) com t0 = 0.5, encontre FT usando a propriedade",
                                    "Verifique numericamente plotando magnitude e fase de X(ω) e da FT deslocada",
                                    "Repita com sinal senoidal: x(t) = cos(ω0 t), observe deltas deslocados em fase",
                                    "Use software para validar (ex: MATLAB fftshift)"
                                  ],
                                  "verification": "Cálculos coincidem com verificação gráfica ou numérica em pelo menos 2 exemplos",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software MATLAB/Octave/Python (SciPy), exemplos de sinais pré-definidos"
                                  ],
                                  "tips": "Sempre normalize frequências para evitar erros de escala",
                                  "learningObjective": "Calcular FT de sinais deslocados sem re-integrar",
                                  "commonMistakes": [
                                    "Erro no sinal do expoente de fase",
                                    "Não plotar fase unwrap para visualização clara",
                                    "Confundir t0 positivo/negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o teorema da convolução na Transformada de Fourier",
                                  "subSteps": [
                                    "Revise definição de convolução no tempo: x(t) * h(t) = ∫ x(τ) h(t - τ) dτ",
                                    "Demonstre matematicamente por que FT{x(t)*h(t)} = X(ω) H(ω) via propriedades da FT",
                                    "Explique dualidade: multiplicação no tempo ↔ convolução na frequência",
                                    "Discuta aplicações: sistemas LTI onde resposta = entrada * impulso",
                                    "Compare convolução direta vs. multiplicação na FT (eficiência)"
                                  ],
                                  "verification": "Prova matemática completa do teorema e distinção clara entre domínios",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Notas de aula sobre sistemas LTI, quadro branco ou papel para prova"
                                  ],
                                  "tips": "Use a propriedade de deslocamento dentro da prova da convolução",
                                  "learningObjective": "Provar e interpretar o teorema da convolução na FT",
                                  "commonMistakes": [
                                    "Confundir convolução com correlação",
                                    "Esquecer limites da integral na prova",
                                    "Ignorar normalização da FT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar teorema da convolução em sinais simples",
                                  "subSteps": [
                                    "Compute FT de x(t) = rect(t) e h(t) = rect(t), então X(ω) H(ω) = sinc²(ω/(2π))",
                                    "Verifique no tempo: convolução de dois rects dá triângulo, FT deve ser sinc²",
                                    "Aplique a sistemas: h(t) resposta ao impulso, x(t) entrada, y(t) = x*h",
                                    "Use software para plotar tempo e frequência antes/depois",
                                    "Teste com sinais não-simétricos: exponencial * gaussiana"
                                  ],
                                  "verification": "Resultados no tempo e frequência coincidem para 2 pares de sinais",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB/Octave para conv() e fft(), tabelas de FT conhecidas"
                                  ],
                                  "tips": "Para verificação rápida, use fft/ifft para domínio duplo",
                                  "learningObjective": "Calcular saídas de sistemas via multiplicação na FT",
                                  "commonMistakes": [
                                    "Erro na orientação da convolução (h*x vs x*h)",
                                    "Não usar fftshift em plots de frequência",
                                    "Escala errada em plots"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar propriedades de deslocamento e convolução em demonstrações",
                                  "subSteps": [
                                    "Combine: convolução de sinal deslocado, ou deslocamento após convolução",
                                    "Exemplo: y(t) = [x(t - t0) * h(t)], FT = X(ω) e^{-jω t0} H(ω)",
                                    "Analise sinal de vibração aeronáutica simples: pulso deslocado convolvido com resposta",
                                    "Simule em software e discuta eficiência computacional",
                                    "Resolva problema: encontre y(t) dado X(ω), H(ω) com fase deslocada"
                                  ],
                                  "verification": "Solução integrada correta para exemplo composto com plots validados",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Software de simulação, problemas de exercícios resolvidos"
                                  ],
                                  "tips": "Sempre verifique simetria e propriedades de paridade dos sinais",
                                  "learningObjective": "Aplicar ambas propriedades simultaneamente em análises de sinais",
                                  "commonMistakes": [
                                    "Perder track do deslocamento na cadeia de operações",
                                    "Confundir ordem das operações em domínios mistos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sinal de entrada x(t) = cos(2π*5 t) deslocado por t0=0.2s, convolvido com um filtro h(t)=rect(t/1). Compute FT{x(t-0.2)} = X(ω) e^{-jω*0.2}, então Y(ω)=FT{x(t-0.2)} * H(ω). No tempo, simule vibração de hélice com delay e filtragem em MATLAB, verificando atenuação de harmônicos.",
                              "finalVerifications": [
                                "Derivação correta das duas propriedades sem consulta",
                                "Cálculo exato de FT para 3 sinais deslocados e 2 convoluções",
                                "Simulação numérica em software com erro <1% vs. analítico",
                                "Explicação física de magnitude/fase em deslocamento e multiplicação em convolução",
                                "Resolução de problema integrado: sistema com delay e filtro",
                                "Identificação de quando usar cada propriedade para otimização"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações e cálculos (90%+ correto)",
                                "Profundidade conceitual: distinção clara entre tempo/frequência",
                                "Habilidade em simulações: plots corretos e interpretados",
                                "Criatividade em exemplos aeronáuticos relevantes",
                                "Eficiência: uso correto de propriedades para evitar integrações pesadas",
                                "Comunicação: explicações claras com gráficos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções exponenciais",
                                "Física: Ondas e propagação em meios (atraso de fase em aeroacústica)",
                                "Computação: Algoritmos FFT para processamento eficiente",
                                "Engenharia de Controle: Análise de sistemas LTI em dinâmica de voo",
                                "Processamento de Imagens: Filtros convolucionais em visão computacional para drones"
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, modela atrasos em sinais de radar (deslocamento) e respostas de filtros em sistemas de controle de vibrações (convolução), permitindo análise eficiente de ruído de motores e estabilidade dinâmica via FFT em softwares como Simulink."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Explorar propriedades de diferenciação e simetria",
                            "description": "Verificar diferenciação no tempo: FT{dx/dt} = jω X(ω); e simetria para sinais reais: X(-ω) = X*(ω), aplicando em problemas práticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Propriedade de Diferenciação na Transformada de Fourier",
                                  "subSteps": [
                                    "Revise a definição da Transformada de Fourier (FT): X(ω) = ∫ x(t) e^{-jωt} dt.",
                                    "Derive a propriedade de diferenciação: FT{dx/dt} = jω X(ω), integrando por partes.",
                                    "Analise o impacto multiplicativo de jω no domínio da frequência.",
                                    "Estude exemplos simples, como FT de uma rampa ou exponencial.",
                                    "Verifique matematicamente com sinal conhecido, como x(t) = e^{-at} u(t)."
                                  ],
                                  "verification": "Derive corretamente a propriedade e aplique a um sinal simples, obtendo FT conhecida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Caderno de anotações",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Sempre normalize a FT para evitar fatores de escala; pratique derivação por partes repetidamente.",
                                  "learningObjective": "Dominar a derivação e interpretação da propriedade FT{dx/dt} = jω X(ω).",
                                  "commonMistakes": [
                                    "Esquecer o sinal de jω",
                                    "Não considerar condições de convergência",
                                    "Confundir com propriedade de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Propriedade de Simetria para Sinais Reais",
                                  "subSteps": [
                                    "Defina simetria para sinais reais: X(-ω) = X*(ω), onde * é conjugado complexo.",
                                    "Prove a propriedade usando a definição de FT e propriedades de exponenciais complexas.",
                                    "Interprete: Parte real par, imaginária ímpar em ω.",
                                    "Aplique a sinais cos e sen: verifique simetria em espectros conhecidos.",
                                    "Discuta implicações para processamento: espectro hermitiano."
                                  ],
                                  "verification": "Prove a propriedade e esboce espectro simétrico para x(t) = cos(ω0 t).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folhas de papel milimetrado",
                                    "Software MATLAB ou Python (SymPy)",
                                    "Notas de aula sobre números complexos"
                                  ],
                                  "tips": "Visualize no plano complexo: e^{-jωt} para -ω é conjugado de ω.",
                                  "learningObjective": "Entender e provar X(-ω) = X*(ω) para sinais reais.",
                                  "commonMistakes": [
                                    "Confundir com simetria temporal",
                                    "Ignorar que vale só para reais",
                                    "Erro em conjugado complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Propriedades em Sinais Simples",
                                  "subSteps": [
                                    "Escolha sinal x(t) = cos(ω0 t) e compute FT manualmente.",
                                    "Aplique diferenciação: encontre FT de dx/dt = -ω0 sin(ω0 t) usando jω X(ω).",
                                    "Verifique simetria do resultado: confirme X(-ω) = X*(ω).",
                                    "Compare com FT direta para validar.",
                                    "Repita com sinal composto, como x(t) = e^{-a|t|}."
                                  ],
                                  "verification": "Calcule FT de derivada e confirme simetria numérica/analítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Octave para plotar espectros",
                                    "Tabelas de FT pares",
                                    "Caderno para cálculos"
                                  ],
                                  "tips": "Use deltas de Dirac para impulsos; plote magnitude e fase para ver simetria.",
                                  "learningObjective": "Aplicar ambas propriedades em conjunto para validação.",
                                  "commonMistakes": [
                                    "Erro de sinal em seno derivada",
                                    "Não plotar para visualizar simetria",
                                    "Escala errada em ω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Problemas Práticos em Contexto Aeronáutico",
                                  "subSteps": [
                                    "Modele vibração de asa: x(t) = A cos(ω t + φ), compute FT de velocidade (dx/dt).",
                                    "Use simetria para simplificar filtro passa-faixa em análise de fadiga.",
                                    "Simule ruído em sinal de sensor: aplique propriedades para extrair aceleração.",
                                    "Avalie estabilidade: verifique picos em ω críticos via jω X(ω).",
                                    "Gere relatório com plots e conclusões."
                                  ],
                                  "verification": "Resolva 3 problemas, com FT corretas e simetria verificada.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com Signal Processing Toolbox",
                                    "Dados simulados de vibrações aeronáuticas",
                                    "Artigo sobre análise FFT em asas"
                                  ],
                                  "tips": "Comece com sinais periódicos; use fft() no domínio discreto para aproximação.",
                                  "learningObjective": "Integrar propriedades em aplicações reais de engenharia.",
                                  "commonMistakes": [
                                    "Não considerar jω amplificando altas frequências",
                                    "Ignorar simetria em otimização computacional",
                                    "Dados não normalizados"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado x(t) = cos(2π t), compute FT: X(ω) = π [δ(ω-2π) + δ(ω+2π)]. Derivada dx/dt = -2π sin(2π t), FT = jω X(ω) = j2π² [-j δ(ω-2π) + j δ(ω+2π)], confirmando simetria X(-ω) = X*(ω).",
                              "finalVerifications": [
                                "Deriva corretamente FT{dx/dt} = jω X(ω) sem erros.",
                                "Prova simetria para sinal real qualquer.",
                                "Aplica propriedades em sinal composto com precisão.",
                                "Identifica simetria em plots de espectro.",
                                "Resolve problema aeronáutico com FT correta.",
                                "Explica implicações físicas de jω (ganho em altas freq.)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (90% correto).",
                                "Correta aplicação em exemplos numéricos/analíticos.",
                                "Visualização adequada de simetria via plots.",
                                "Integração contextual em engenharia aeronáutica.",
                                "Identificação de erros comuns e correções.",
                                "Criatividade em extensão para problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções conjugadas.",
                                "Física: Dinâmica de vibrações e ondas em estruturas aeronáuticas.",
                                "Computação: Implementação de FFT em MATLAB/Python para simulações.",
                                "Engenharia Mecânica: Análise modal de componentes.",
                                "Processamento de Sinais: Filtros baseados em propriedades de FT."
                              ],
                              "realWorldApplication": "Em manutenção preditiva de aeronaves, analisa sinais de acelerômetros em asas para detectar vibrações anômalas: usa diferenciação para obter acelerações de velocidades e simetria para otimizar processamento em tempo real, previndo falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.4",
                            "name": "Aplicar teorema de Parseval",
                            "description": "Demonstrar conservação de energia: ∫ |x(t)|^2 dt = (1/2π) ∫ |X(ω)|^2 dω, calculando para sinais conhecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a energia de sinais no domínio do tempo",
                                  "subSteps": [
                                    "Defina a energia de um sinal contínuo como E = ∫_{-∞}^{∞} |x(t)|^2 dt.",
                                    "Calcule a energia para sinais simples como impulso, senoide e pulso retangular.",
                                    "Interprete fisicamente a energia como medida de potência total do sinal.",
                                    "Discuta a importância da conservação de energia em sistemas lineares.",
                                    "Pratique com integrais analíticas para sinais conhecidos."
                                  ],
                                  "verification": "Calcule corretamente a energia de pelo menos três sinais exemplo e explique seu significado físico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Sempre normalize os limites de integração para evitar erros em sinais com suporte finito.",
                                  "learningObjective": "Dominar o cálculo e interpretação da energia no domínio do tempo.",
                                  "commonMistakes": [
                                    "Esquecer o módulo quadrado |x(t)|^2",
                                    "Ignorar limites de integração infinitos",
                                    "Confundir energia com potência média"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a Transformada de Fourier e densidade espectral de energia",
                                  "subSteps": [
                                    "Lembre a definição da Transformada de Fourier: X(ω) = ∫_{-∞}^{∞} x(t) e^{-jωt} dt.",
                                    "Calcule |X(ω)|^2, a densidade espectral de potência.",
                                    "Integre (1/2π) ∫ |X(ω)|^2 dω e relacione conceitualmente à energia temporal.",
                                    "Examine exemplos onde X(ω) é conhecida, como para pulsos retangulares.",
                                    "Use propriedades da Fourier para simplificar cálculos."
                                  ],
                                  "verification": "Derive |X(ω)|^2 para um sinal retangular e compute sua integral normalizada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy/NumPy)",
                                    "Livro de referência em Sinais e Sistemas"
                                  ],
                                  "tips": "Plote |X(ω)|^2 para visualizar a distribuição de energia no domínio da frequência.",
                                  "learningObjective": "Entender como a energia é representada no domínio da frequência.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2π na normalização",
                                    "Confundir X(ω) com X(f)",
                                    "Não usar simetria par de |X(ω)|^2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar e provar o Teorema de Parseval",
                                  "subSteps": [
                                    "Enuncie o teorema: ∫ |x(t)|^2 dt = (1/2π) ∫ |X(ω)|^2 dω.",
                                    "Derive a prova usando a definição da Fourier e integral de Plancherel.",
                                    "Discuta o significado: Parseval mostra Parseval preserva a norma L2 (energia).",
                                    "Verifique com sinal delta de Dirac ou funções ortogonais.",
                                    "Analise variações para Fourier discreta (DFT)."
                                  ],
                                  "verification": "Escreva a prova passo a passo e aplique a um sinal trivial como x(t)=1 (constante finita).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Quadro branco ou software de anotações (LaTeX/Overleaf)",
                                    "Notas de aula sobre Fourier"
                                  ],
                                  "tips": "Use a identidade |∫ f g^*|² ≤ ∫|f|² ∫|g|² para insight na prova.",
                                  "learningObjective": "Provar e interpretar a conservação de energia via Parseval.",
                                  "commonMistakes": [
                                    "Erro na conjugação complexa na prova",
                                    "Confundir com teorema de Plancherel para bases ortonormais",
                                    "Ignorar fator de escala 1/2π"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o teorema a sinais conhecidos e verificar numericamente",
                                  "subSteps": [
                                    "Escolha sinal x(t) = rect(t/T), compute energia temporal analiticamente.",
                                    "Calcule X(ω) = T sinc(ωT/2π), então energia espectral.",
                                    "Compare ambos os lados numericamente usando integração numérica.",
                                    "Teste com sinal senoidal amortecido e analise discrepâncias.",
                                    "Gere relatório com tabelas e gráficos de comparação."
                                  ],
                                  "verification": "Mostre que |erro| < 1% entre energias temporal e espectral para dois sinais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB/Python com SciPy para FFT/integração",
                                    "Gráficos de |x(t)|^2 e |X(ω)|^2"
                                  ],
                                  "tips": "Use quad() no MATLAB ou integrate.quad() no Python para precisão numérica.",
                                  "learningObjective": "Aplicar Parseval computacionalmente e validar conservação de energia.",
                                  "commonMistakes": [
                                    "Amostragem inadequada em simulações numéricas",
                                    "Escala errada em eixos de frequência",
                                    "Não truncar integrais infinitas adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para x(t) = 1 se |t| < 1, 0 caso contrário: Energia temporal E_t = ∫_{-1}^1 1 dt = 2. X(ω) = 2 sinc(ω/π), então E_f = (1/2π) ∫ |2 sinc(ω/π)|^2 dω = 2, confirmando igualdade.",
                              "finalVerifications": [
                                "Energia calculada no tempo e frequência coincidem dentro de 0.1%.",
                                "Prova do teorema escrita corretamente sem erros algébricos.",
                                "Exemplos numéricos para 2+ sinais validados com código.",
                                "Interpretação física da conservação de energia explicada.",
                                "Gráficos de |x(t)|^2 e |X(ω)|^2 plotados e analisados.",
                                "Variações discretas (Parseval para DFT) compreendidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (100% correto).",
                                "Clareza na derivação e prova do teorema.",
                                "Uso correto de ferramentas numéricas e análise de erros.",
                                "Profundidade na interpretação física e limitações.",
                                "Criatividade em escolher e aplicar a sinais relevantes.",
                                "Relatório estruturado com verificações explícitas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de energia em ondas e vibrações mecânicas.",
                                "Processamento Digital de Sinais: Validação em DFT para filtros digitais.",
                                "Engenharia de Controle: Análise de estabilidade via espectros.",
                                "Matemática: Espaços de Hilbert e normas L2.",
                                "Estatística: Densidade espectral em análise de séries temporais."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, aplica-se para validar análises espectrais de vibrações em estruturas de asas ou fuselagens, garantindo que a energia total de vibrações medidas por acelerômetros seja preservada na transformada de Fourier, auxiliando na detecção de falhas e otimização de design contra fadiga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Transformada de Fourier Inversa e Aplicações",
                        "description": "Processo de reconstrução do sinal original a partir do espectro e aplicações em análise de sistemas lineares contínuos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Derivar e aplicar a fórmula da Transformada Inversa",
                            "description": "Reproduzir x(t) = (1/2π) ∫_{-∞}^{∞} X(ω) e^{jωt} dω e calcular para espectros simples como delta e retangular no domínio da frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Derivar a Fórmula da Transformada de Fourier Inversa",
                                  "subSteps": [
                                    "Revise a Transformada de Fourier direta: X(ω) = ∫_{-∞}^{∞} x(t) e^{-jωt} dt.",
                                    "Analise a ortogonalidade das funções exponenciais complexas e^{jωt}.",
                                    "Derive a inversa multiplicando X(ω) por e^{jω't} / (2π) e integrando sobre ω, usando o fato de que ∫ e^{j(ω-ω')t} dt = 2π δ(ω-ω').",
                                    "Simplifique para obter x(t) = (1/2π) ∫_{-∞}^{∞} X(ω) e^{jωt} dω.",
                                    "Verifique a consistência dimensional e as convenções de normalização."
                                  ],
                                  "verification": "Reproduzir a derivação completa em um papel ou software, confirmando que resulta na fórmula exata.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Caderno para derivações",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": [
                                    "Use a identidade do delta de Dirac para justificar a inversa.",
                                    "Desenhe diagramas de blocos para visualizar forward e inverse.",
                                    "Pratique com limites finitos antes de ir ao infinito."
                                  ],
                                  "learningObjective": "Derivar a fórmula da transformada inversa a partir dos princípios fundamentais da análise de Fourier.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/(2π)",
                                    "Confundir o sinal do expoente (jωt vs -jωt)",
                                    "Ignorar a assimetria na normalização."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Transformada Inversa ao Espectro Delta de Dirac",
                                  "subSteps": [
                                    "Defina X(ω) = 2π δ(ω), que corresponde a uma constante no tempo.",
                                    "Substitua na fórmula: x(t) = (1/2π) ∫ 2π δ(ω) e^{jωt} dω = ∫ δ(ω) e^{jωt} dω = e^{j0 t} = 1.",
                                    "Generalize para X(ω) = 2π δ(ω - ω0), resultando em x(t) = e^{jω0 t}.",
                                    "Verifique a propriedade da transformada direta para consistência.",
                                    "Discuta implicações físicas: sinal constante ou senoidal puro."
                                  ],
                                  "verification": "Calcular e plotar x(t) para δ(ω) e confirmar que é uma constante unitária.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (MATLAB ou Python com NumPy/SciPy)",
                                    "Tabela de pares Fourier"
                                  ],
                                  "tips": [
                                    "A propriedade do sifting do delta simplifica a integral imediatamente.",
                                    "Sempre normalize corretamente para evitar fatores de escala errados.",
                                    "Plote o espectro e o sinal no tempo para visualização."
                                  ],
                                  "learningObjective": "Calcular e interpretar a inversa para impulsos no domínio da frequência.",
                                  "commonMistakes": [
                                    "Esquecer que δ(ω) inverso é 1, não 1/(2π) sem normalização",
                                    "Não reconhecer o tom puro para delta deslocado",
                                    "Confundir domínio do tempo e frequência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Transformada Inversa a um Espectro Retangular",
                                  "subSteps": [
                                    "Defina o espectro retangular: X(ω) = 2π A rect(ω / (2W)) para |ω| < W, 0 caso contrário.",
                                    "Escreva a integral: x(t) = (A / π) ∫_{-W}^{W} cos(ω t) dω, usando a simetria (parte imaginária cancela).",
                                    "Integre para obter x(t) = A (sin(W t) / t) = A W sinc(W t / π), dependendo da convenção de sinc.",
                                    "Normalize e plote a função sinc resultante.",
                                    "Analise o lóbulo principal e sidelobes."
                                  ],
                                  "verification": "Resolver a integral analiticamente e comparar com plot numérico em software.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB para integração numérica e plot",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": [
                                    "Use simetria para reduzir a integral a cosseno.",
                                    "Defina rect e sinc claramente para evitar confusões de normalização.",
                                    "Aumente W para ver o efeito de banda larga."
                                  ],
                                  "learningObjective": "Executar o cálculo analítico da inversa para espectro retangular e obter a função sinc.",
                                  "commonMistakes": [
                                    "Erro na integração de sin(ωt)/t (use d(sin(Wt)/t)/dW)",
                                    "Normalização errada do rect levando a amplitude incorreta",
                                    "Ignorar que sinc tem zeros em t = kπ/W."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades e Sintetizar Aplicações",
                                  "subSteps": [
                                    "Verifique a inversibilidade: aplique forward na inversa e confirme recuperação de X(ω).",
                                    "Teste lineariedade e escalamento em combinações de delta e retangular.",
                                    "Discuta teorema da convolução no domínio da frequência.",
                                    "Aplique a um sinal composto: soma de delta e retangular.",
                                    "Reflita sobre limitações computacionais (ex: FFT aproximada)."
                                  ],
                                  "verification": "Realizar ciclo completo forward-inverse para um espectro simples e medir erro < 1%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Python com fft/ifft",
                                    "Exemplos de código online para Fourier"
                                  ],
                                  "tips": [
                                    "Use FFT para validação numérica rápida.",
                                    "Sempre cheque Parseval para energia.",
                                    "Considere truncamento para integrais numéricas."
                                  ],
                                  "learningObjective": "Validar a transformada inversa através de propriedades e ciclos completos.",
                                  "commonMistakes": [
                                    "Não verificar simetria hermitiana para sinais reais",
                                    "Erro numérico por sampling inadequado",
                                    "Confundir convolução com multiplicação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma asa de aeronave, um espectro retangular X(ω) = rect(ω/(2*10)) representa frequências até 10 rad/s. A inversa dá x(t) = sinc(10 t / π), modelando um sinal band-limited usado para filtrar ruído em dados de sensores acelerométricos.",
                              "finalVerifications": [
                                "Reproduzir a fórmula exata sem consulta.",
                                "Calcular inversa de δ(ω) resultando em 1.",
                                "Derivar sinc para espectro retangular com amplitude e largura corretas.",
                                "Validar ciclo forward-inverse numericamente com erro mínimo.",
                                "Explicar o papel físico de cada exemplo.",
                                "Aplicar a um espectro composto simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e cálculos (100% correto).",
                                "Compreensão conceitual: explicar por que a inversa recupera o sinal original.",
                                "Habilidade em visualização: plots corretos de tempo e frequência.",
                                "Aplicação correta de propriedades (lineariedade, simetria).",
                                "Identificação e correção de erros comuns.",
                                "Criatividade em estender a exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Complexa e Integrais de Contorno.",
                                "Física: Teoria de Ondas e Espectroscopia.",
                                "Engenharia de Controle: Análise de Resposta em Frequência.",
                                "Processamento de Sinais Digitais: Transição para DFT/FFT."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a transformada inversa é usada para reconstruir sinais de vibração a partir de espectros de dados de telemetria em testes de voo, permitindo simulações de fadiga estrutural e design de filtros para sistemas de controle de voo estável."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Analisar resposta em frequência de sistemas LTI",
                            "description": "Relacionar função de transferência H(ω) = Y(ω)/X(ω) com resposta ao impulso h(t), usando pares Fourier conhecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas LTI e Transformada de Fourier",
                                  "subSteps": [
                                    "Defina sistema LTI (Linear Time-Invariant) e suas propriedades principais: linearidade e invariância temporal.",
                                    "Explique a Transformada de Fourier contínua: X(ω) = ∫ x(t) e^{-jωt} dt.",
                                    "Liste pares Fourier conhecidos comuns: delta(t), step(u(t)), seno, cosseno, exponencial.",
                                    "Discuta a convolução no tempo como multiplicação no domínio da frequência para LTI.",
                                    "Verifique compreensão com um exemplo simples de entrada seno e saída."
                                  ],
                                  "verification": "Resolva um problema simples: encontre X(ω) para x(t) = δ(t).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Sinais e Sistemas (Oppenheim), calculadora científica, notas de aula.",
                                  "tips": "Use tabelas de pares Fourier para memorização rápida.",
                                  "learningObjective": "Compreender bases teóricas para análise em frequência.",
                                  "commonMistakes": "Confundir transformada direta com inversa; ignorar fator 2π em algumas convenções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Função de Transferência em Frequência H(ω)",
                                  "subSteps": [
                                    "Defina H(ω) = Y(ω)/X(ω) para sistemas LTI estáveis.",
                                    "Calcule H(ω) a partir da função de transferência em s: H(s) com s = jω.",
                                    "Plote magnitude |H(ω)| e fase ∠H(ω) para um sistema dado.",
                                    "Interprete resposta em frequência: passa-baixa, passa-alta, etc.",
                                    "Analise estabilidade via |H(ω)| finita para todos ω."
                                  ],
                                  "verification": "Dado H(s) = 1/(s+1), encontre e plote |H(ω)|.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB ou Python (SciPy), papel milimetrado.",
                                  "tips": "Use Bode plot para visualização intuitiva.",
                                  "learningObjective": "Dominar cálculo e interpretação de H(ω).",
                                  "commonMistakes": "Esquecer substituição s = jω; normalizar ω incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar H(ω) com Resposta ao Impulso h(t)",
                                  "subSteps": [
                                    "Estabeleça h(t) = (1/2π) ∫ H(ω) e^{jωt} dω (transformada inversa).",
                                    "Demonstre que y(t) = h(t) * x(t) implica Y(ω) = H(ω) X(ω).",
                                    "Use pares Fourier para encontrar h(t) diretamente de H(ω) conhecida.",
                                    "Exemplo: H(ω) retangular → h(t) = sinc(t).",
                                    "Verifique simetria: H(ω) real e par implica h(t) real e par."
                                  ],
                                  "verification": "Derive h(t) para H(ω) = 1 (sistema identidade).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Tabela de pares Fourier, MATLAB para integral numérica.",
                                  "tips": "Comece com H(ω) simétricas para simplificar.",
                                  "learningObjective": "Conectar domínios tempo e frequência via h(t).",
                                  "commonMistakes": "Inverter fórmula de inversa; esquecer normalização 1/2π."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Pares Fourier para Análise Completa",
                                  "subSteps": [
                                    "Selecione pares conhecidos para decompor H(ω).",
                                    "Calcule h(t) somando contribuições de pares (ex: retas, deltas).",
                                    "Analise resposta a entradas específicas: seno, ruído branco.",
                                    "Compare simulações tempo vs. frequência.",
                                    "Otimize: use propriedades de simetria para acelerar."
                                  ],
                                  "verification": "Para H(ω) = e^{-|ω|}, encontre h(t) e verifique convolução.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Simulink, exemplos de problemas resolvidos.",
                                  "tips": "Pratique com H(ω) ideais antes de reais.",
                                  "learningObjective": "Aplicar relações para análise prática de sistemas.",
                                  "commonMistakes": "Usar pares errados; não verificar causalidade de h(t)."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de flap de aeronave modelado como H(s) = ω_n^2 / (s^2 + 2ζω_n s + ω_n^2), com ω_n=10 rad/s, ζ=0.5: Calcule H(ω), plote Bode, derive h(t) via pares aproximados e simule resposta a entrada seno de 5 rad/s.",
                              "finalVerifications": [
                                "Deriva corretamente h(t) de H(ω) usando inversa de Fourier.",
                                "Calcula Y(ω) = H(ω) X(ω) para entrada arbitrária.",
                                "Interpreta magnitude e fase de H(ω) em termos de ganho e atraso.",
                                "Verifica consistência via simulação tempo-frequência.",
                                "Identifica tipo de filtro (baixa/alta passa) corretamente.",
                                "Aplica a pelo menos dois pares Fourier conhecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em cálculos de H(ω) e h(t) (>95%).",
                                "Qualidade de plots de resposta em frequência.",
                                "Correta interpretação física da análise.",
                                "Uso adequado de pares Fourier sem erros.",
                                "Capacidade de generalizar para sistemas reais.",
                                "Eficiência no tempo de resolução de problemas.",
                                "Documentação clara de passos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações em estruturas aeronáuticas.",
                                "Controle Automático: Projeto de controladores via Bode plots.",
                                "Processamento de Sinais: Filtros em telemetria de voo.",
                                "Matemática: Integração complexa e séries de Fourier."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, analisar H(ω) de sistemas de controle de estabilidade (ex: fly-by-wire) para prever resposta a turbulências, otimizando filtros que relacionam aceleração medida (X(ω)) à correção de atitude (Y(ω)), garantindo segurança em voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Aplicar em sinais aperiódicos de sistemas dinâmicos",
                            "description": "Decompor e analisar sinais contínuos aperiódicos em contextos mecânicos ou eletromecânicos, identificando componentes dominantes de frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e representar o sinal aperiódico",
                                  "subSteps": [
                                    "Identifique o sinal contínuo aperiódico de um sistema dinâmico mecânico ou eletromecânico, como vibração de uma estrutura aeronáutica.",
                                    "Colete ou simule dados do sinal usando sensores ou software de modelagem.",
                                    "Discretize o sinal contínuo em uma sequência discreta adequada para processamento numérico.",
                                    "Normalize o sinal para remover offsets e escalar amplitudes adequadamente.",
                                    "Plote o sinal no domínio do tempo para visualização inicial."
                                  ],
                                  "verification": "Confirme que o sinal está plotado corretamente no domínio do tempo sem distorções visíveis e que os dados estão normalizados (média zero, variância unitária).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (SciPy/NumPy), dados de sinal real ou simulado, osciloscópio virtual.",
                                  "tips": "Use janelas de Hann para reduzir vazamento espectral ao discretizar.",
                                  "learningObjective": "Compreender a representação temporal de sinais aperiódicos em sistemas dinâmicos.",
                                  "commonMistakes": "Ignorar ruído DC no sinal, levando a picos falsos no espectro; não discretizar com taxa de Nyquist adequada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Transformada de Fourier ao sinal",
                                  "subSteps": [
                                    "Selecione o algoritmo apropriado: FFT para sinais discretos ou FT analítica para casos simples.",
                                    "Configure parâmetros: comprimento da FFT (próximo de 2^N), resolução de frequência.",
                                    "Compute a transformada para obter o espectro de magnitude e fase.",
                                    "Aplique janelamento se necessário para minimizar artefatos.",
                                    "Plote o espectro de frequência (magnitude vs. frequência)."
                                  ],
                                  "verification": "Verifique se o espectro mostra picos coerentes com eventos conhecidos no sinal temporal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Bibliotecas FFT (fft() no MATLAB, np.fft no Python), script de processamento.",
                                  "tips": "Escolha NFFT maior que o comprimento do sinal para melhor resolução, mas equilibre com tempo de computação.",
                                  "learningObjective": "Executar a decomposição em componentes de frequência de sinais aperiódicos.",
                                  "commonMistakes": "Usar FFT sem padding zero, causando resolução espectral pobre; confundir magnitude com potência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar componentes dominantes de frequência",
                                  "subSteps": [
                                    "Analise o espectro para localizar picos acima de um limiar (ex: 10% do máximo).",
                                    "Classifique componentes por amplitude e frequência: fundamentais, harmônicos, sub-harmônicos.",
                                    "Compare com modelo físico do sistema (ex: modos naturais de vibração).",
                                    "Filtre ruído usando threshold ou suavização.",
                                    "Documente as top 3-5 frequências dominantes com suas amplitudes."
                                  ],
                                  "verification": "Liste componentes com frequências, amplitudes e justificativa física para dominância.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de plotagem (Matplotlib/Plotly), tabela de modos naturais do sistema.",
                                  "tips": "Use escala logarítmica para visualizar tanto baixas quanto altas frequências.",
                                  "learningObjective": "Discernir sinais relevantes de ruído em espectros complexos.",
                                  "commonMistakes": "Atribuir picos de vazamento como componentes reais; ignorar largura de banda dos picos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar no contexto do sistema dinâmico",
                                  "subSteps": [
                                    "Relacione componentes dominantes a fenômenos físicos (ex: ressonância em asas).",
                                    "Aplique Transformada de Fourier Inversa para reconstruir sinal aproximado com componentes selecionados.",
                                    "Compare sinal original e reconstruído para validar decomposição.",
                                    "Avalie implicações: fadiga, estabilidade, controle.",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "A reconstrução inversa deve capturar >85% da energia do sinal original.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Funções ifft(), modelo físico do sistema (equações diferenciais).",
                                  "tips": "Meça erro com MSE ou correlação entre original e reconstruído.",
                                  "learningObjective": "Integrar análise espectral com dinâmica de sistemas reais.",
                                  "commonMistakes": "Não validar reconstrução, levando a interpretações errôneas; desconectar análise de contexto físico."
                                }
                              ],
                              "practicalExample": "Analisar vibrações aperiódicas em uma asa de aeronave durante teste de flutter: decompor sinal de acelerômetro para identificar frequências dominantes associadas a modos de flexão e torção, prevendo risco de instabilidade.",
                              "finalVerifications": [
                                "Espectro de frequência corretamente computado e plotado.",
                                "Componentes dominantes identificados com amplitudes e frequências precisas.",
                                "Reconstrução inversa valida a decomposição (erro <15%).",
                                "Interpretação alinhada ao contexto mecânico/eletromecânico.",
                                "Relatório inclui gráficos e conclusões acionáveis.",
                                "Análise considera ruído e artefatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação da FT/FFT (resolução e escala corretas).",
                                "Correta identificação de pelo menos 80% dos componentes dominantes.",
                                "Qualidade da interpretação física e ligação com sistema dinâmico.",
                                "Uso adequado de ferramentas e tratamento de erros.",
                                "Clareza e completude do relatório com visualizações.",
                                "Eficiência temporal e aderência aos passos."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica dos Sólidos: Modos de vibração e ressonância.",
                                "Controle Automático: Análise de estabilidade via espectro.",
                                "Processamento de Sinais Digitais: Filtragem e janelamento.",
                                "Engenharia Aeronáutica: Monitoramento estrutural (SHM).",
                                "Matemática Aplicada: Análise de Fourier e séries."
                              ],
                              "realWorldApplication": "Em manutenção preditiva de aeronaves, decompor sinais de vibração de turbinas ou fuselagens para detectar desgaste precoce, falhas em rolamentos ou onset de flutter, permitindo intervenções antes de falhas catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Janelamento",
                    "description": "Multiplicação de sinais por funções janela para minimizar artefatos espectrais em análises finitas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Artefatos Espectrais em Análises Finitas",
                        "description": "Compreensão dos artefatos espectrais, como o leakage espectral, que surgem ao truncar sinais infinitos para análises finitas na transformada de Fourier, motivando a necessidade de janelamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar leakage espectral",
                            "description": "Reconhecer e explicar o fenômeno de leakage espectral na transformada de Fourier de um sinal truncado, comparando com o espectro ideal de um sinal infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Teóricos do Leakage Espectral",
                                  "subSteps": [
                                    "Estude a definição de transformada de Fourier para sinais infinitos e truncados.",
                                    "Revise a propriedade de truncamento no domínio do tempo e seu impacto no domínio da frequência.",
                                    "Analise a convolução com a função sinc resultante do truncamento.",
                                    "Compare o espectro ideal (delta de Dirac) com o espectro real de um sinal retangular truncado.",
                                    "Identifique os componentes principais do leakage: lóbulos principais e laterais."
                                  ],
                                  "verification": "Resuma em suas palavras o que causa o leakage espectral e desenhe um diagrama comparativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim)",
                                    "Notas de aula sobre Fourier",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como 'vazar energia para frequências vizinhas' para fixar o conceito.",
                                  "learningObjective": "Explicar matematicamente por que o truncamento causa leakage espectral.",
                                  "commonMistakes": [
                                    "Confundir leakage com aliasing",
                                    "Ignorar o papel da função sinc",
                                    "Achar que apenas sinais ruidosos causam leakage"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar Sinais Infinitos versus Truncados",
                                  "subSteps": [
                                    "Gere um sinal senoidal puro infinito teoricamente.",
                                    "Trunque o sinal no tempo (ex: multiplique por uma janela retangular).",
                                    "Plote o sinal no domínio do tempo para ambos os casos.",
                                    "Discuta como a truncagem introduz discontinuidades nas bordas.",
                                    "Antecipe o efeito no espectro de frequência."
                                  ],
                                  "verification": "Crie plots manuais ou digitais mostrando as diferenças no domínio do tempo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (Matplotlib/Scipy)",
                                    "Tutoriais online sobre plotting de sinais"
                                  ],
                                  "tips": "Comece com períodos inteiros de senoide para minimizar leakage inicialmente.",
                                  "learningObjective": "Visualizar o impacto do truncamento no sinal temporal.",
                                  "commonMistakes": [
                                    "Escolher janelas muito curtas sem resolução suficiente",
                                    "Não normalizar os plots para comparação",
                                    "Ignorar a escala de amplitude"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar e Comparar Transformadas de Fourier",
                                  "subSteps": [
                                    "Calcule analiticamente a DFT do sinal truncado.",
                                    "Implemente numericamente a FFT em software para o sinal truncado e ideal.",
                                    "Plote os espectros: magnitude e fase para ambos.",
                                    "Identifique os lóbulos laterais e a atenuação da energia principal.",
                                    "Meça quantitativamente o leakage (ex: integral de energia em lóbulos laterais)."
                                  ],
                                  "verification": "Gere plots lado a lado dos espectros e anote as diferenças chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy/FFT",
                                    "Exemplos de código para FFT"
                                  ],
                                  "tips": "Use N=1024 pontos para boa resolução; zero-pad se necessário.",
                                  "learningObjective": "Aplicar FFT para demonstrar leakage espectral empiricamente.",
                                  "commonMistakes": [
                                    "Não usar janela retangular explicitamente",
                                    "Confundir escala logarítmica vs linear",
                                    "Esquecer de comparar com o espectro teórico ideal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Explicar o Leakage em Contextos Práticos",
                                  "subSteps": [
                                    "Aplique o conceito a um sinal real de vibração aeronáutica truncado.",
                                    "Compare espectros com e sem truncamento.",
                                    "Explique como identificar leakage: espalhamento de energia, lóbulos laterais.",
                                    "Discuta mitigação básica (ex: introduzir janelas não-retangulares).",
                                    "Documente observações em um relatório curto."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o leakage observado nos plots.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dados de vibração de aeronave (dataset público)",
                                    "Software de análise"
                                  ],
                                  "tips": "Foque em frequências próximas à fundamental para ver leakage claro.",
                                  "learningObjective": "Reconhecer leakage em espectros reais e diferenciá-lo de outros artefatos.",
                                  "commonMistakes": [
                                    "Atribuir leakage a ruído em vez de truncamento",
                                    "Não quantificar o impacto",
                                    "Generalizar sem contexto específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em testes de vibração de uma asa de aeronave, um sinal de aceleração é registrado por 10 segundos (truncado). Ao computar a FFT, observa-se leakage espectral ao redor da frequência de ressonância (50 Hz), onde energia 'vaza' para 48-52 Hz, mascarando modos próximos e levando a diagnósticos errados de fadiga estrutural.",
                              "finalVerifications": [
                                "Explica corretamente a causa matemática do leakage (convolução com sinc).",
                                "Identifica lóbulos laterais em um espectro dado.",
                                "Compara visualmente espectros truncados vs ideais.",
                                "Sugere pelo menos uma técnica de mitigação (ex: janelamento).",
                                "Aplica o conceito a um exemplo aeronáutico real.",
                                "Quantifica leakage via energia em bandas laterais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação teórica (80%+ correto).",
                                "Qualidade dos plots e análises visuais (rótulos claros, escalas adequadas).",
                                "Capacidade de identificação em espectros desconhecidos.",
                                "Uso correto de terminologia (DFT, sinc, lóbulos).",
                                "Conexão com aplicações práticas em engenharia.",
                                "Relatório lógico e conciso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e convolução.",
                                "Programação: Implementação de FFT em Python/MATLAB.",
                                "Física: Dinâmica de vibrações e ondas em estruturas aeronáuticas.",
                                "Estatística: Análise espectral de dados ruidosos.",
                                "Engenharia de Controle: Processamento de sinais em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Na manutenção preditiva de aeronaves, identificar leakage espectral em análises de FFT de dados de sensores vibração evita falsos alarmes em detecção de falhas, otimizando inspeções e reduzindo custos operacionais em frotas comerciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Analisar efeitos da truncagem abrupta",
                            "description": "Demonstrar, por meio de exemplos gráficos, como a multiplicação por uma janela retangular causa sidelobes no espectro e distorce a análise de frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Truncagem Abrupta e Janela Retangular",
                                  "subSteps": [
                                    "Estudar a Transformada de Fourier (FT) para sinais infinitos e sua relação com sinais finitos truncados.",
                                    "Explicar a multiplicação temporal por uma janela retangular como truncagem abrupta.",
                                    "Analisar a convolução no domínio da frequência: janela retangular gera sinc() com sidelobes.",
                                    "Discutir leakagem espectral e distorção na resolução de frequências próximas.",
                                    "Revisar propriedades da FT da janela retangular (lóbulo principal largo e sidelobes altos)."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando por que a truncagem causa sidelobes, com equações básicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas (ex: Oppenheim), notas de aula, calculadora simbólica (SymPy ou MATLAB Symbolic).",
                                  "tips": "Visualize a convolução: sidelobes surgem da forma da sinc() da FT da janela retangular.",
                                  "learningObjective": "Dominar o conceito matemático da truncagem como multiplicação por janela retangular e seus efeitos espectrais.",
                                  "commonMistakes": "Confundir truncagem com amostragem; ignorar que sidelobes são devidos à descontinuidade nas bordas do sinal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e Discretizar um Sinal de Teste para Simulação",
                                  "subSteps": [
                                    "Escolher um sinal senoidal puro multifrequencial (ex: soma de senos em 10Hz e 20Hz) com duração longa para simular 'infinito'.",
                                    "Discretizar o sinal com taxa de amostragem alta (Fs > 10x freq máxima, ex: Fs=1000Hz).",
                                    "Gerar N amostras longas (ex: N=4096) para sinal 'ideal' sem truncagem.",
                                    "Plotar o sinal temporal para verificar continuidade e ausência de artefatos.",
                                    "Salvar dados em arrays para uso posterior (NumPy array)."
                                  ],
                                  "verification": "Gerar e exibir gráfico do sinal temporal contínuo, confirmando picos corretos nas frequências escolhidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com bibliotecas NumPy, SciPy e Matplotlib; ou MATLAB.",
                                  "tips": "Use N potência de 2 para eficiência na FFT; normalize o sinal para amplitude unitária.",
                                  "learningObjective": "Preparar dados realistas para demonstrar efeitos de truncagem em análise numérica.",
                                  "commonMistakes": "Taxa de amostragem baixa causando aliasing; N muito pequeno mascarando efeitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Truncagem Abrupta e Computar Espectros Gráficos",
                                  "subSteps": [
                                    "Truncar o sinal para M << N amostras (ex: M=128) multiplicando por janela retangular (zeros fora de M).",
                                    "Computar DFT/FFT do sinal truncado e do sinal original longo.",
                                    "Plotar magnitude do espectro em escala dB vs frequência normalizada.",
                                    "Sobrepor espectros: original (picos Dirac-like) vs truncado (sidelobes visíveis).",
                                    "Ajustar eixos para destacar sidelobes (zoom em região de interesse)."
                                  ],
                                  "verification": "Exibir gráficos comparativos mostrando sidelobes proeminentes no espectro truncado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (numpy.fft.fft, matplotlib.pyplot); código-fonte pronto para FFT.",
                                  "tips": "Use plt.semilogy() para escala logarítmica, realçando sidelobes fracos (~-13dB para retangular).",
                                  "learningObjective": "Demonstrar visualmente a distorção espectral causada pela truncagem.",
                                  "commonMistakes": "Não normalizar FFT (divida por M); esquecer shift fftshift() para frequência centrada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Efeitos, Distorções e Implicações",
                                  "subSteps": [
                                    "Medir amplitudes de sidelobes principais e compará-las com teoria (-13dB para janela retangular).",
                                    "Explicar como sidelobes mascaram componentes fracas ou próximas (ex: freq 20Hz 'vazando' para 10Hz).",
                                    "Simular cenário real: adicionar ruído e mostrar piora na detecção.",
                                    "Discutir soluções qualitativas (janelas suaves como Hann) via comparação rápida.",
                                    "Redigir relatório com conclusões sobre distorções na análise de frequência."
                                  ],
                                  "verification": "Produzir relatório com gráficos anotados e explicação quantitativa de pelo menos 3 sidelobes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto/Jupyter Notebook para relatório; gráficos gerados anteriormente.",
                                  "tips": "Quantifique distorção: erro em amplitude de pico devido a leakagem de vizinhos.",
                                  "learningObjective": "Interpretar gráficos para analisar impactos práticos da truncagem abrupta.",
                                  "commonMistakes": "Atribuir sidelobes a ruído numérico; ignorar normalização entre espectros."
                                }
                              ],
                              "practicalExample": "Em testes de vibração de uma asa de aeronave, um sinal de vibração senoidal (fundo harmônico a 50Hz + falha a 55Hz) é truncado abruptamente para 1s de dados. O espectro mostra sidelobes do 50Hz invadindo o 55Hz, levando a diagnóstico falso de ressonância crítica, potencialmente atrasando manutenção.",
                              "finalVerifications": [
                                "Gráficos comparativos mostram sidelobes claros (~-13dB) ausentes no sinal longo.",
                                "Explicação correta liga sidelobes à convolução com sinc() da janela retangular.",
                                "Medição quantitativa de pelo menos 2 sidelobes com valores próximos à teoria.",
                                "Identificação de distorção: leakagem mascara componentes espectrais fracos.",
                                "Relatório resume implicações para análise finita em sinais aeronáuticos.",
                                "Código reproduzível gera resultados consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação matemática da causa dos sidelobes (80% peso).",
                                "Qualidade gráfica: plots claros, escalas adequadas, anotações (15% peso).",
                                "Análise quantitativa: medições de amplitudes e erros de distorção (5% peso).",
                                "Relatório estruturado: introdução, métodos, resultados, conclusões.",
                                "Reprodutibilidade: código comentado e executável sem erros.",
                                "Criatividade: extensão a cenário aeronáutico real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries e Transformadas de Fourier, convolução.",
                                "Programação: Processamento de sinais com Python/NumPy/SciPy.",
                                "Física: Análise de vibrações e ondas em estruturas aeronáuticas.",
                                "Estatística: Efeitos de ruído e detecção de sinais fracos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, durante análise espectral de dados de sensores em turbinas ou fuselagens (ex: SHM - Structural Health Monitoring), truncagem abrupta em gravações finitas causa sidelobes que distorcem detecção de falhas, levando a falsos alarmes ou omissões em manutenção preditiva, com impactos em segurança e custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Comparar espectros com e sem janelamento",
                            "description": "Plotar e comparar o espectro de um sinal senoidal truncado com e sem janelamento para visualizar a redução de artefatos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar o sinal senoidal truncado",
                                  "subSteps": [
                                    "Instale e importe as bibliotecas necessárias: numpy, scipy.signal e matplotlib.pyplot.",
                                    "Defina os parâmetros do sinal: frequência fundamental (ex: 50 Hz), taxa de amostragem (fs = 1000 Hz), duração total (ex: 1 segundo) e comprimento da janela finita (N = 256 pontos).",
                                    "Gere o sinal senoidal completo usando np.sin(2 * np.pi * f * t).",
                                    "Trunque o sinal para N pontos, simulando uma aquisição finita.",
                                    "Plote o sinal truncado no domínio do tempo para visualização inicial."
                                  ],
                                  "verification": "Verifique se o sinal plotado mostra exatamente N pontos e exibe a forma senoidal truncada abruptamente nas bordas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: numpy, scipy, matplotlib"
                                  ],
                                  "tips": "Use N como potência de 2 (ex: 256) para otimizar a FFT.",
                                  "learningObjective": "Compreender como truncar um sinal contínuo para análise discreta finita.",
                                  "commonMistakes": [
                                    "Definir fs menor que 2*f para violar teorema de Nyquist",
                                    "Não truncar corretamente, gerando sinal infinito",
                                    "Ignorar normalização do tempo t"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e plotar o espectro sem janelamento",
                                  "subSteps": [
                                    "Aplique a Transformada Discreta de Fourier (DFT) usando np.fft.fft(sinal_truncado).",
                                    "Calcule a magnitude do espectro: 20 * np.log10(np.abs(fft)) para escala dB.",
                                    "Gere o eixo de frequência: f = np.fft.fftfreq(N, 1/fs).",
                                    "Plote o espectro de magnitude vs. frequência, focando na metade positiva.",
                                    "Identifique visualmente os artefatos: leakage espectral como lóbulos laterais (sidelobes) ao redor do pico principal."
                                  ],
                                  "verification": "O plot deve mostrar um pico principal em 50 Hz com sidelobes elevados e oscilações, indicando leakage.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python do Step 1"
                                  ],
                                  "tips": "Use np.fft.fftshift() se quiser espectro centrado em zero, mas foque em positivo para simplicidade.",
                                  "learningObjective": "Visualizar os efeitos do truncamento abrupto no domínio da frequência.",
                                  "commonMistakes": [
                                    "Plotar todo o espectro sem focar em positivo",
                                    "Esquecer log10 para escala dB",
                                    "Não rotacionar fase com fftfreq"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar janelamento e calcular o espectro correspondente",
                                  "subSteps": [
                                    "Gere uma janela Hamming: janela = scipy.signal.windows.hamming(N).",
                                    "Multiplique o sinal truncado pela janela: sinal_janelado = sinal_truncado * janela.",
                                    "Plote o sinal janelado no tempo para ver a suavização nas bordas.",
                                    "Aplique FFT no sinal janelado e calcule magnitude em dB como no Step 2.",
                                    "Plote o novo espectro e compare qualitativamente com o anterior."
                                  ],
                                  "verification": "O sinal janelado deve mostrar amplitude reduzida nas bordas; espectro com sidelobes atenuados (~-40 dB vs. ~-13 dB sem janela).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "scipy.signal"
                                  ],
                                  "tips": "Hamming reduz sidelobes principais; experimente Hann para variação.",
                                  "learningObjective": "Entender como a multiplicação por janela reduz discontinuidades nas bordas.",
                                  "commonMistakes": [
                                    "Aplicar janela após FFT",
                                    "Não normalizar janela (use soma(janela)/N)",
                                    "Confundir ordem de multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar espectros e analisar redução de artefatos",
                                  "subSteps": [
                                    "Sobreponha os dois espectros (com e sem janela) no mesmo plot usando matplotlib.",
                                    "Meça quantitativamente: pico principal, altura dos primeiros sidelobes e largura de banda.",
                                    "Documente diferenças: redução de leakage, preservação do pico fundamental.",
                                    "Salve os plots e anote observações em um relatório curto.",
                                    "Teste com frequência não-inteira de N*fs para piorar leakage e demonstrar benefício."
                                  ],
                                  "verification": "Relatório mostra sidelobes reduzidos em pelo menos 25-30 dB com janelamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Todos os códigos anteriores"
                                  ],
                                  "tips": "Use subplot para plots lado a lado; adicione legendas claras.",
                                  "learningObjective": "Analisar quantitativamente a eficácia do janelamento na redução de artefatos espectrais.",
                                  "commonMistakes": [
                                    "Não alinhar eixos de frequência",
                                    "Ignorar normalização entre espectros",
                                    "Concluir sem medições numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em testes de vibração de uma asa de aeronave, um sinal senoidal de 50 Hz simula ressonância. Truncado sem janela, o espectro mostra leakage mascarando harmônicos reais; com Hamming, o pico fundamental destaca-se, permitindo detecção precisa de falhas estruturais.",
                              "finalVerifications": [
                                "Plots sobrepostos mostram sidelobes atenuados com janelamento.",
                                "Pico principal preservado em amplitude e frequência exata.",
                                "Sinal janelado suavizado nas bordas no domínio do tempo.",
                                "Medições numéricas confirmam redução >25 dB em sidelobes.",
                                "Análise escrita identifica leakage como artefato do truncamento.",
                                "Código reproduzível gera resultados consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e truncamento do sinal (Nyquist respeitado).",
                                "Correta implementação de FFT e plotagem em dB vs. Hz.",
                                "Aplicação adequada da janela Hamming e comparação visual/numérica.",
                                "Identificação clara de artefatos e benefícios do janelamento.",
                                "Relatório com plots limpos, legendas e conclusões fundamentadas.",
                                "Eficiência: tempo total <90 min, código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e propriedades da DFT.",
                                "Programação: Manipulação de arrays NumPy e visualização Matplotlib.",
                                "Física: Análise de vibrações e ondas em estruturas aeronáuticas.",
                                "Estatística: Redução de ruído espectral e estimação de parâmetros."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, janelamento é essencial em análises FFT de dados de acelerômetros em testes de fadiga de asas ou hélices, reduzindo falsos positivos em detecção de ressonâncias e falhas, conforme normas FAA para monitoramento estrutural."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Definição e Aplicação de Janelamento",
                        "description": "Definição do janelamento como multiplicação temporal de um sinal por uma função janela suave, que atenua as bordas e minimiza artefatos espectrais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Definir função janela",
                            "description": "Explicar matematicamente o janelamento como s(t) * w(t), onde s(t) é o sinal e w(t) a função janela com w(t)=1 no centro e decaimento nas bordas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Janelamento",
                                  "subSteps": [
                                    "Revise a definição de um sinal contínuo s(t) em sistemas dinâmicos.",
                                    "Identifique problemas de truncamento abrupto em sinais finitos, como leakage espectral.",
                                    "Explique a necessidade de suavizar as bordas do sinal para análise precisa.",
                                    "Defina janelamento como uma técnica de modulação temporal do sinal.",
                                    "Discuta aplicações iniciais em análise de vibrações aeronáuticas."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a motivação para o janelamento, citando pelo menos dois problemas resolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas",
                                    "Notas de aula sobre análise espectral",
                                    "Gráfico de sinal truncado vs janelado"
                                  ],
                                  "tips": "Visualize um sinal senoidal cortado abruptamente e observe artefatos no espectro.",
                                  "learningObjective": "Entender a motivação e o propósito fundamental do janelamento em sinais.",
                                  "commonMistakes": "Confundir janelamento com filtragem passa-baixa ou normalização de amplitude."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Operação Matemática do Janelamento",
                                  "subSteps": [
                                    "Escreva a fórmula matemática: y(t) = s(t) · w(t), onde y(t) é o sinal janelado.",
                                    "Identifique s(t) como o sinal original contínuo ou discreto.",
                                    "Descreva w(t) como a função janela multiplicativa.",
                                    "Especifique que a operação é ponto a ponto (multiplicação temporal).",
                                    "Pratique derivando a fórmula para um sinal senoidal simples s(t) = sin(2πft)."
                                  ],
                                  "verification": "Escreva e explique a equação y(t) = s(t) · w(t) corretamente em um papel ou software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora simbólica como SymPy ou MATLAB"
                                  ],
                                  "tips": "Lembre-se: é multiplicação, não convolução (que é no domínio da frequência).",
                                  "learningObjective": "Dominar a representação matemática exata da operação de janelamento.",
                                  "commonMistakes": "Escrever adição em vez de multiplicação ou inverter s(t) e w(t)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as Propriedades da Função Janela w(t)",
                                  "subSteps": [
                                    "Defina que w(t) = 1 no centro da janela (região principal).",
                                    "Descreva o decaimento suave para w(t) = 0 nas bordas transitórias.",
                                    "Compare janelas comuns: retangular (sem decaimento), triangular, Hann (w(t) = 0.5(1 - cos(2πt/T))).",
                                    "Analise impactos: largura do lobo principal vs lobos laterais no espectro.",
                                    "Plote qualitativamente w(t) para uma janela de duração T."
                                  ],
                                  "verification": "Desenhe e rotule o gráfico de w(t), destacando centro e bordas, e liste 3 propriedades.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de plotagem (Python Matplotlib ou MATLAB)",
                                    "Tabelas de funções janela"
                                  ],
                                  "tips": "Comece com a janela Hann para ver o decaimento cosinusoidal suave.",
                                  "learningObjective": "Compreender e descrever as características essenciais da função janela.",
                                  "commonMistakes": "Achar que todas as janelas têm w(t)=1 nas bordas ou decaimento abrupto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Sintetizar o Conceito de Função Janela",
                                  "subSteps": [
                                    "Combine conceitos: aplique y(t) = s(t) · w(t) a um exemplo numérico simples.",
                                    "Calcule y(t) para pontos discretos e observe o efeito nas bordas.",
                                    "Compare o espectro de s(t) truncado vs y(t) janelado (usando FFT conceitual).",
                                    "Resuma vantagens em contextos aeronáuticos como análise de vibrações.",
                                    "Crie um fluxograma do processo de janelamento."
                                  ],
                                  "verification": "Responda a um quiz com 5 perguntas sobre fórmula, propriedades e aplicação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python Jupyter Notebook",
                                    "Exemplos de sinais de vibração"
                                  ],
                                  "tips": "Use valores numéricos pequenos (T=10 pontos) para cálculos manuais.",
                                  "learningObjective": "Integrar todos os elementos para definir completamente a função janela.",
                                  "commonMistakes": "Ignorar o domínio temporal ou confundir com domínio da frequência."
                                }
                              ],
                              "practicalExample": "Em testes de vibração de uma turbina aeronáutica, capture s(t) de um acelerômetro por 1 segundo (T=1s). Aplique w(t) Hann: w(t)=0.5(1-cos(2πt/T)) para y(t)=s(t)·w(t), reduzindo leakage e revelando frequências de ressonância precisas.",
                              "finalVerifications": [
                                "Escreve corretamente y(t) = s(t) · w(t).",
                                "Descreve w(t)=1 no centro e decaimento nas bordas.",
                                "Explica leakage espectral evitado pelo janelamento.",
                                "Plota qualitativamente uma função janela.",
                                "Aplica o conceito a um sinal senoidal simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula matemática (correta e completa).",
                                "Descrição detalhada das propriedades de w(t) (centro e bordas).",
                                "Explicação clara da motivação (leakage e análise finita).",
                                "Uso correto de terminologia (sinal, janela, multiplicação temporal).",
                                "Exemplo prático relevante ao contexto aeronáutico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Multiplicação de funções e análise trigonométrica (ex: Hann).",
                                "Programação: Implementação em Python/Scipy.signal para plotar e aplicar janelas.",
                                "Física: Dinâmica de vibrações em estruturas aeronáuticas.",
                                "Processamento Digital de Sinais: Preparação para FFT e análise espectral.",
                                "Estatística: Redução de artefatos em estimativas espectrais."
                              ],
                              "realWorldApplication": "Na manutenção preditiva de aeronaves, o janelamento é essencial para processar sinais de sensores em asas e fuselagens, permitindo detectar microfissuras via análise espectral precisa sem distorções de borda, otimizando segurança e reduzindo downtime."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Aplicar janelamento a sinal contínuo",
                            "description": "Calcular e plotar um sinal contínuo multiplicado por uma função janela genérica, analisando o impacto no domínio do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Definir o Sinal Contínuo",
                                  "subSteps": [
                                    "Escolha um sinal contínuo simples, como uma senoide ou soma de senoides, com frequência conhecida.",
                                    "Defina o intervalo de tempo t (ex: t de 0 a T segundos).",
                                    "Escreva a equação matemática do sinal x(t).",
                                    "Discuta propriedades do sinal no domínio do tempo (amplitude, período, duração).",
                                    "Prepare uma representação numérica discreta para simulação (amostragem fina)."
                                  ],
                                  "verification": "Confirme que a equação x(t) está corretamente definida e pode ser plotada manualmente para alguns pontos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de plotagem (MATLAB, Python com Matplotlib, Octave)"
                                  ],
                                  "tips": "Comece com um sinal periódico para facilitar a visualização do impacto da janela.",
                                  "learningObjective": "Compreender e representar um sinal contínuo no domínio do tempo.",
                                  "commonMistakes": [
                                    "Escolher intervalo de tempo muito curto que não capture ciclos completos",
                                    "Ignorar a normalização da amplitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e Definir a Função Janela",
                                  "subSteps": [
                                    "Estude funções janela comuns: retangular, Hamming, Hanning, Blackman.",
                                    "Selecione uma janela genérica (ex: Hamming: w(n) = 0.54 - 0.46*cos(2πn/(N-1))).",
                                    "Defina o comprimento da janela igual ao sinal (duração T).",
                                    "Calcule e plote a função janela w(t) no mesmo intervalo de t.",
                                    "Analise as propriedades da janela (largura da lóbulo principal, atenuação de sidelobes)."
                                  ],
                                  "verification": "Plote w(t) e verifique se ela vai de 1 no centro a valores próximos de 0 nas bordas.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Documentação de funções janela",
                                    "Software de plotagem"
                                  ],
                                  "tips": "Use a Hamming para um bom equilíbrio entre vazamento espectral e resolução de frequência.",
                                  "learningObjective": "Identificar e parametrizar funções janela adequadas para janelamento.",
                                  "commonMistakes": [
                                    "Definir janela com comprimento diferente do sinal",
                                    "Confundir domínio contínuo com discreto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Sinal Janelado",
                                  "subSteps": [
                                    "Aplique a fórmula y(t) = x(t) * w(t) para todo t no intervalo.",
                                    "Implemente numericamente usando amostragem (ex: 1000 pontos).",
                                    "Calcule pontos chave: valores no início, meio e fim.",
                                    "Compare amplitudes: y(t) deve ser atenuado nas bordas.",
                                    "Verifique continuidade e suavidade do sinal resultante."
                                  ],
                                  "verification": "Calcule y(t) para t=0, t=T/2, t=T e confirme atenuação nas extremidades.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Calculadora ou software numérico (Python/NumPy, MATLAB)"
                                  ],
                                  "tips": "Use vetores para multiplicação elemento a elemento em software.",
                                  "learningObjective": "Executar a multiplicação ponto a ponto entre sinal e janela.",
                                  "commonMistakes": [
                                    "Multiplicar por soma em vez de produto",
                                    "Esquecer de alinhar os intervalos de t"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e Analisar o Impacto no Domínio do Tempo",
                                  "subSteps": [
                                    "Gere plots: x(t), w(t) e y(t) em subfiguras.",
                                    "Sobreponha x(t) e y(t) para visual comparação.",
                                    "Descreva mudanças: redução de amplitude nas bordas, preservação no centro.",
                                    "Quantifique impacto: calcule energia ou norma L2 antes/depois.",
                                    "Discuta efeitos: minimização de transientes de borda para análise espectral futura."
                                  ],
                                  "verification": "O plot mostra y(t) igual a x(t) no centro e zerado nas bordas.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Software de plotagem avançada"
                                  ],
                                  "tips": "Use escalas logarítmicas para visualizar atenuação fina.",
                                  "learningObjective": "Visualizar e interpretar os efeitos do janelamento temporal.",
                                  "commonMistakes": [
                                    "Escalas de eixo inadequadas que mascaram o efeito",
                                    "Não normalizar plots para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Documentar Resultados",
                                  "subSteps": [
                                    "Compare y(t) com x(t) sem janela em termos de características temporais.",
                                    "Documente observações em um relatório curto.",
                                    "Teste com diferentes janelas para o mesmo sinal.",
                                    "Registre métricas: fator de atenuação máxima nas bordas.",
                                    "Conclua sobre quando usar janelamento."
                                  ],
                                  "verification": "Relatório inclui plots, cálculos e análise qualitativa/quantitativa.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de texto ou notebook Jupyter"
                                  ],
                                  "tips": "Salve plots com legendas claras para reutilização.",
                                  "learningObjective": "Sintetizar o impacto do janelamento e suas implicações.",
                                  "commonMistakes": [
                                    "Ignorar comparação quantitativa",
                                    "Generalizar de um exemplo só"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere x(t) = sin(2π*5t) + 0.5*sin(2π*50t) para t ∈ [0,1] s. Aplique janela Hamming w(t) = 0.54 - 0.46*cos(2πt). Plote x(t), w(t) e y(t) = x(t)*w(t). Observe atenuação das componentes nas bordas, reduzindo discontinuities.",
                              "finalVerifications": [
                                "Capacidade de definir corretamente x(t) e w(t) com equações precisas.",
                                "Cálculo numérico de y(t) sem erros em pelo menos 5 pontos chave.",
                                "Plots gerados mostram claramente o efeito de suavização nas bordas.",
                                "Análise escrita descreve redução de transientes temporais.",
                                "Comparação com sinal original destaca preservação da forma central.",
                                "Seleção justificada de janela baseada em propriedades espectrais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e cálculo (90%+ acurácia).",
                                "Qualidade visual dos plots (legendas, escalas, clareza).",
                                "Profundidade da análise de impacto temporal (qualitativa e quantitativa).",
                                "Correta identificação de propriedades da janela escolhida.",
                                "Documentação completa e organizada.",
                                "Criatividade em testes adicionais (diferentes sinais/janelas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Multiplicação de funções e análise de produtos.",
                                "Física: Modelagem de ondas e modulação em sistemas dinâmicos.",
                                "Programação: Implementação numérica e visualização de dados.",
                                "Engenharia de Controle: Preparação de sinais para análise em malhas de feedback.",
                                "Processamento de Imagens: Analogia com máscaras em filtros 2D."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, aplica-se janelamento a sinais de acelerômetros em testes de vibração de asas ou fuselagem, evitando artefatos de borda em análises FFT para detecção de ressonâncias e fadiga estrutural durante telemetria de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Interpretar propriedades da janela",
                            "description": "Descrever propriedades como largura principal do lóbulo, altura de sidelobes e resolução espectral em termos da função janela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais das propriedades espectrais da função janela",
                                  "subSteps": [
                                    "Defina o que é uma função janela e sua importância no janelamento de sinais.",
                                    "Explique a Transformada de Fourier (TF) da função janela e como ela determina o espectro de frequência.",
                                    "Identifique as componentes principais do espectro: lóbulo principal (main lobe), sidelobes e largura de resolução.",
                                    "Diferencie propriedades no domínio do tempo e frequência.",
                                    "Estude exemplos de janelas comuns como retangular, Hamming e Blackman."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre main lobe e sidelobes, com diagrama simples desenhado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de processamento de sinais (ex: Oppenheim), software MATLAB ou Python (SciPy) para plots iniciais.",
                                  "tips": "Sempre relacione o domínio do tempo com o da frequência: janelas mais longas tendem a ter main lobes mais estreitos.",
                                  "learningObjective": "Entender as bases teóricas das propriedades espectrais para interpretação posterior.",
                                  "commonMistakes": "Confundir sidelobes com ruído aleatório; lembrar que sidelobes são determinísticos da janela."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar a largura principal do lóbulo (main lobe)",
                                  "subSteps": [
                                    "Calcule a largura do main lobe como a distância entre os primeiros zeros da TF da janela.",
                                    "Relacione a largura com o comprimento N da janela: para retangular, largura ≈ 4π/N.",
                                    "Compare larguras entre janelas: retangular tem a menor, mas sidelobes altos.",
                                    "Plote o espectro de uma janela retangular e meça a largura no gráfico.",
                                    "Discuta impacto: main lobe estreito melhora resolução de frequência próxima."
                                  ],
                                  "verification": "Compute e anote a largura do main lobe para uma janela Hamming de N=64.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python com FFT, tabelas de propriedades de janelas.",
                                  "tips": "Use normalização em frequência (0 a 2π) para comparações padronizadas.",
                                  "learningObjective": "Calcular e interpretar quantitativamente a largura do main lobe em termos da função janela.",
                                  "commonMistakes": "Ignorar normalização; largura é em radianos ou Hz, especifique unidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a altura dos sidelobes",
                                  "subSteps": [
                                    "Meça a atenuação dos sidelobes como pico sidelobe / pico main lobe (em dB).",
                                    "Compare: retangular (-13 dB), Hamming (-43 dB), Blackman (-58 dB).",
                                    "Entenda o trade-off: sidelobes baixos reduzem vazamento espectral, mas alargam main lobe.",
                                    "Gere plots logarítmicos (dB) para visualizar melhor os sidelobes.",
                                    "Discuta supressão de sidelobes via design de janela."
                                  ],
                                  "verification": "Identifique e quantifique o pico do primeiro sidelobe em um plot de janela Hann.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de plotagem (MATLAB signal toolbox ou Python matplotlib + numpy).",
                                  "tips": "Escala dB facilita visualização: 20*log10(|TF|).",
                                  "learningObjective": "Avaliar e descrever a altura dos sidelobes e seu impacto no vazamento espectral.",
                                  "commonMistakes": "Medir sidelobes em escala linear; sempre use dB para atenuação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a resolução espectral e integrar propriedades",
                                  "subSteps": [
                                    "Defina resolução espectral como largura equivalente do main lobe (ex: 0.89/N para Hamming).",
                                    "Relacione com distância mínima entre picos detectáveis sem sobreposição.",
                                    "Integre propriedades: trade-off entre resolução, sidelobes e duração da janela.",
                                    "Aplique em sinal simulado: janela um sinal com duas frequências próximas e observe resolução.",
                                    "Resuma tabela comparativa de propriedades para 3 janelas."
                                  ],
                                  "verification": "Crie uma tabela resumindo largura main lobe, pico sidelobe e resolução para retangular e Hamming.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Scripts Python/MATLAB prontos para simulação de janelamento.",
                                  "tips": "Teste com N variando para ver escalonamento: propriedades ∝ 1/N.",
                                  "learningObjective": "Sintetizar todas as propriedades para escolhas de janela em aplicações reais.",
                                  "commonMistakes": "Confundir resolução com largura do bin FFT; resolução é propriedade da janela."
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma asa de aeronave, aplique janela Hamming a um sinal de aceleração (N=1024). Meça: main lobe ~0.006 rad/amostra (boa resolução para modos próximos), sidelobes -43 dB (baixo vazamento em harmônicos). Compare com retangular: sidelobes altos mascaram modos fracos.",
                              "finalVerifications": [
                                "Pode descrever verbalmente a largura do main lobe de uma janela retangular em termos de N?",
                                "Identifica corretamente o trade-off entre largura main lobe e altura sidelobes?",
                                "Calcula com precisão a resolução espectral para Hamming (≈0.89/N)?",
                                "Explica impacto de sidelobes altos em análise de sinais reais?",
                                "Cria plot comparativo de espectros de duas janelas?",
                                "Resume propriedades em tabela para pelo menos 3 janelas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas e valores numéricos das propriedades (ex: -13 dB para retangular).",
                                "Correta interpretação de trade-offs (resolução vs. vazamento).",
                                "Qualidade dos plots e medições (precisão <5% erro).",
                                "Capacidade de relacionar propriedades à função janela específica.",
                                "Clareza na descrição escrita/oral das propriedades.",
                                "Aplicação correta em exemplo prático com sinal simulado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Fourier e análise assintótica.",
                                "Física: Análise de vibrações e ondas em sistemas dinâmicos aeronáuticos.",
                                "Programação: Implementação numérica em Python/MATLAB para simulações.",
                                "Estatística: Redução de vazamento espectral como controle de bias em estimativas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, interpretar propriedades de janelas é crucial para análise espectral de sinais de telemetria em voos, detectando modos de flutter em asas ou hélices com mínima distorção espectral, evitando falsos alarmes em monitoramento estrutural."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Funções Janela Comuns e Suas Propriedades",
                        "description": "Estudo de funções janela específicas como retangular, Hamming, Hanning e Blackman, com suas fórmulas, vantagens e trade-offs em aplicações práticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Descrever janela retangular",
                            "description": "Explicar a janela retangular w(n)=1, seus efeitos (alto leakage) e quando usá-la, com cálculo de sua transformada de Fourier.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Janela Retangular e Sua Representação Matemática",
                                  "subSteps": [
                                    "Estude a definição: w[n] = 1 para |n| ≤ (N-1)/2 e w[n] = 0 caso contrário, onde N é o comprimento da janela.",
                                    "Esboce graficamente a forma da janela para N=8 e N=16, destacando sua forma 'retangular'.",
                                    "Compare com sinal sem janelamento, entendendo que w[n]=1 não altera o sinal dentro da janela.",
                                    "Anote as propriedades básicas: soma finita, simetria e valor constante."
                                  ],
                                  "verification": "Desenhe ou plote a janela corretamente e explique verbalmente sua definição sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software como MATLAB/Python (Matplotlib/NumPy)",
                                  "tips": "Use N ímpar para simetria perfeita em torno de n=0.",
                                  "learningObjective": "Compreender a definição matemática e visual da janela retangular discreta.",
                                  "commonMistakes": "Confundir com janela contínua ou assumir w[n]=1 para todo n sem limites."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Transformada de Fourier Discreta-Tempo (DTFT) da Janela Retangular",
                                  "subSteps": [
                                    "Lembre a fórmula da DTFT: W(ω) = ∑ w[n] e^{-jωn} de n=-(N-1)/2 a (N-1)/2.",
                                    "Derive analiticamente: W(ω) = [sin(ωN/2) / sin(ω/2)] * e^{-jω(N-1)/2}.",
                                    "Plote |W(ω)| para N=32, identificando o lóbulo principal e laterais.",
                                    "Calcule numericamente usando FFT para validar a fórmula.",
                                    "Normalize W(ω) para comparar ganhos."
                                  ],
                                  "verification": "Obtenha a fórmula correta e plote que coincida com simulação numérica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou MATLAB), software de plotagem",
                                  "tips": "Use a identidade da soma geométrica para derivar a fórmula.",
                                  "learningObjective": "Derivar e visualizar a resposta em frequência da janela retangular.",
                                  "commonMistakes": "Erros na fase exponencial ou ignorar o delay (N-1)/2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os Efeitos da Janela Retangular (Leakage Espectral)",
                                  "subSteps": [
                                    "Explique spectral leakage: lóbulos laterais causam vazamento de energia para bins adjacentes.",
                                    "Compare com sinal delta: leakage é máximo devido aos sidelobes altos (~-13 dB).",
                                    "Simule um sinal senoidal com frequência não-binária e aplique janelamento retangular vs. sem.",
                                    "Meça o leakage quantitativamente (largura do lóbulo principal e atenuação de sidelobes).",
                                    "Discuta impacto em resolução espectral."
                                  ],
                                  "verification": "Gere plots mostrando leakage e quantifique sidelobe peak em dB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Python com FFT, exemplos de sinais sinusoidais",
                                  "tips": "Use freq=0.15 fs para demonstrar leakage visível.",
                                  "learningObjective": "Identificar e quantificar os efeitos negativos do alto leakage.",
                                  "commonMistakes": "Confundir leakage com scalloping loss ou ignorar normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Aplicações e Quando Usar a Janela Retangular",
                                  "subSteps": [
                                    "Liste cenários: processamento em tempo real, N pequeno, ou quando simplicidade > precisão.",
                                    "Compare com janelas como Hamming (menor leakage, mas mainlobe mais largo).",
                                    "Aplique em exemplo aeronáutico: análise rápida de vibrações sem correção de leakage.",
                                    "Discuta trade-offs: zero processamento adicional, mas alta distorção espectral.",
                                    "Conclua guidelines: use para DTFT/FFT com freqs bin-centradas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo prós/contras e um caso de uso específico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela comparativa de janelas, referências de livros (Oppenheim)",
                                  "tips": "Memorize: ideal para 'zero padding' em FFT sem preocupação com leakage.",
                                  "learningObjective": "Saber contextos práticos e limitações da janela retangular.",
                                  "commonMistakes": "Recomendar para alta precisão espectral onde janelas suaves são melhores."
                                }
                              ],
                              "practicalExample": "Em MATLAB, gere w = ones(1,64); W = fftshift(fft(w,512)); plot(abs(W)); adicione um tom senoidal x=sin(2*pi*0.15*n); aplique w.*x e FFT para ver leakage nos bins vizinhos.",
                              "finalVerifications": [
                                "Derivar corretamente a DTFT da janela retangular.",
                                "Plotar e identificar sidelobes em -13 dB.",
                                "Explicar leakage com exemplo numérico.",
                                "Listar 3 cenários onde usá-la e 2 onde evitar.",
                                "Comparar visualmente com janela sem janelamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula DTFT (100% match).",
                                "Qualidade dos plots (rótulos, escalas corretas).",
                                "Explicação clara de leakage com evidências quantitativas.",
                                "Identificação correta de trade-offs e aplicações.",
                                "Demonstração prática via simulação funcional.",
                                "Ausência de erros conceituais comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e somas geométricas.",
                                "Processamento Digital de Sinais: FFT e análise espectral.",
                                "Engenharia Aeronáutica: Análise de vibrações e telemetria.",
                                "Física: Ondas e espectroscopia."
                              ],
                              "realWorldApplication": "Na análise de sinais de vibração em asas de aeronaves via acelerômetros, a janela retangular permite FFT rápida para detecção inicial de falhas em tempo real, aceitando leakage quando N é grande e frequências são bin-centradas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Implementar janelas Hamming e Hanning",
                            "description": "Derivar e aplicar as fórmulas das janelas Hamming (w(n)=0.54 - 0.46 cos) e Hanning, comparando seus espectros e redução de sidelobes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar as fórmulas das janelas Hamming e Hanning",
                                  "subSteps": [
                                    "Revise a fórmula geral de janelas: w(n) para n=0 a N-1.",
                                    "Derive a janela Hanning: w(n) = 0.5 - 0.5 cos(2πn/(N-1)).",
                                    "Derive a janela Hamming: w(n) = 0.54 - 0.46 cos(2πn/(N-1)).",
                                    "Explique a origem dos coeficientes (Hanning de média de 1 e cos, Hamming otimizado para sidelobes).",
                                    "Compare graficamente as formas das funções para N=64."
                                  ],
                                  "verification": "Escreva as fórmulas derivadas em um documento e plote as curvas usando software para confirmar similaridades e diferenças.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Software de plotagem (MATLAB/Python com Matplotlib)",
                                    "Referências teóricas sobre janelamento"
                                  ],
                                  "tips": "Use a identidade trigonométrica cos(θ) = (1 + cos(2θ))/2 para simplificar derivações.",
                                  "learningObjective": "Compreender a base matemática e diferenças entre janelas Hamming e Hanning.",
                                  "commonMistakes": [
                                    "Confundir coeficientes (0.54 vs 0.5)",
                                    "Esquecer o denominador (N-1)",
                                    "Plotar sem normalizar o eixo de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar funções de janela em código",
                                  "subSteps": [
                                    "Crie uma função para gerar vetor Hamming: hamm = 0.54 - 0.46*cos(2*pi*(0:N-1)'/(N-1)).",
                                    "Crie função similar para Hanning: hann = 0.5 - 0.5*cos(2*pi*(0:N-1)'/(N-1)).",
                                    "Teste com N=64 e plote as janelas.",
                                    "Normalize as janelas para soma unitária e compare.",
                                    "Adicione tratamento de erro para N<2."
                                  ],
                                  "verification": "Execute o código e verifique se os plots coincidem com gráficos teóricos padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Editor de código (VS Code/Jupyter)"
                                  ],
                                  "tips": "Use vetores coluna para compatibilidade com FFT; vetorize operações para eficiência.",
                                  "learningObjective": "Implementar numericamente as janelas de forma precisa e reutilizável.",
                                  "commonMistakes": [
                                    "Usar N em vez de N-1 no denominador",
                                    "Não transpor vetor para plotagem",
                                    "Ignorar normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar janelas a um sinal de teste e computar espectros",
                                  "subSteps": [
                                    "Gere um sinal de teste: senoide + ruído, ex. x = sin(2*pi*0.1*t) + 0.1*randn(size(t)).",
                                    "Aplique janelas: x_hamm = x .* hamm; x_hann = x .* hann; x_raw = x.",
                                    "Compute FFT: X_raw = fft(x_raw); X_hamm = fft(x_hamm); etc.",
                                    "Plote magnitude do espectro |X| em dB vs frequência normalizada.",
                                    "Inclua caso sem janela para baseline."
                                  ],
                                  "verification": "Plots mostram leakagem espectral reduzida nas janelas vs sinal cru.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmo software do Step 2",
                                    "Funções fft/ifft built-in"
                                  ],
                                  "tips": "Use freq = (0:N-1)*(fs/N) para eixo de frequência; plote apenas metade positiva.",
                                  "learningObjective": "Aplicar janelas na prática e observar efeitos iniciais no domínio da frequência.",
                                  "commonMistakes": [
                                    "Não zerar padding",
                                    "Plotar fase em vez de magnitude",
                                    "Escala linear em vez de dB"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar espectros e analisar redução de sidelobes",
                                  "subSteps": [
                                    "Meça altura dos sidelobes principais: encontre picos laterais em dB.",
                                    "Compare atenuação: Hamming ~43 dB, Hanning ~32 dB vs mainlobe.",
                                    "Calcule largura do mainlobe em bins de frequência.",
                                    "Plote sobrepostos e anote diferenças quantitativas.",
                                    "Teste com sinal multibanda para validar generalidade."
                                  ],
                                  "verification": "Relatório com métricas numéricas confirma redução esperada de sidelobes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software anterior",
                                    "Ferramentas de análise (findpeaks em MATLAB)"
                                  ],
                                  "tips": "Foquem em sidelobes próximos ao mainlobe; use zoom nos plots.",
                                  "learningObjective": "Quantificar vantagens de cada janela em termos de sidelobe suppression.",
                                  "commonMistakes": [
                                    "Medir mainlobe como sidelobe",
                                    "Ignorar normalização de energia",
                                    "Não considerar resolução espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e otimizar para contexto aeronáutico",
                                  "subSteps": [
                                    "Aplique a sinal de vibração simulada (ex. flutter em asas).",
                                    "Compare escolhas de janela para detecção de frequências baixas.",
                                    "Documente trade-offs: Hamming melhor para sidelobes, Hanning mainlobe mais estreito.",
                                    "Crie função unificada para seleção automática.",
                                    "Salve relatório com plots e conclusões."
                                  ],
                                  "verification": "Função aplicada a novo sinal produz espectros corretos com análise escrita.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados simulados de vibração",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Em aeronáutica, priorize Hamming para ruído em radares/vibrações.",
                                  "learningObjective": "Integrar conhecimento em aplicação contextual e decidir uso ótimo.",
                                  "commonMistakes": [
                                    "Generalizar sem contexto",
                                    "Omitir trade-offs",
                                    "Código não modular"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma asa de aeronave, aplique janela Hamming a sinal de acelerômetro para reduzir leakagem espectral e detectar modos de flutter abaixo de 10 Hz com sidelobes suprimidos em 43 dB, evitando falsos alarmes em monitoramento estrutural.",
                              "finalVerifications": [
                                "Fórmulas derivadas corretamente com plots validados.",
                                "Código gera janelas idênticas a funções built-in (hamming/hanning).",
                                "Espectros mostram redução de sidelobes: Hanning >20 dB, Hamming >40 dB vs raw.",
                                "Análise quantitativa de mainlobe e sidelobes documentada.",
                                "Aplicação a sinal real/simulado com escolha justificada.",
                                "Relatório completo com todos plots e métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas e implementações (20%)",
                                "Qualidade dos plots e visualizações (20%)",
                                "Análise quantitativa de sidelobes/mainlobe (25%)",
                                "Correção na aplicação e trade-offs (20%)",
                                "Clareza do relatório e código comentado (10%)",
                                "Criatividade na extensão aeronáutica (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Trigonometria, séries de Fourier.",
                                "Programação: Vetorização, funções modulares em MATLAB/Python.",
                                "Física: Análise de vibrações e sinais dinâmicos em engenharia.",
                                "Estatística: Análise espectral de ruído.",
                                "Engenharia de Controle: Filtragem em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, janelas Hamming/Hanning são usadas em análise de sinais de sensores (acelerômetros, strain gauges) para processar dados de testes de fadiga estrutural, reduzindo artefatos espectrais e melhorando detecção de ressonâncias críticas em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Escolher janela adequada",
                            "description": "Avaliar trade-offs entre resolução espectral e supressão de sidelobes para selecionar a janela ideal em cenários como análise de vibrações mecânicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções janela comuns e suas propriedades principais",
                                  "subSteps": [
                                    "Liste as janelas comuns: Rectangular, Hanning, Hamming, Blackman e Kaiser.",
                                    "Calcule e compare a largura principal do lóbulo e a atenuação dos sidelobes para cada uma usando fórmulas ou tabelas padrão.",
                                    "Plote as funções janela no domínio do tempo e sua transformada de Fourier no domínio da frequência.",
                                    "Registre os valores numéricos chave: resolução espectral (largura do mainlobe) e supressão de sidelobes (dB).",
                                    "Compare visualmente os trade-offs iniciais entre as janelas."
                                  ],
                                  "verification": "Tabela comparativa completa com plots gerados e valores anotados corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (SciPy), tabelas de propriedades de janelas (ex: documentação SciPy.signal.windows).",
                                  "tips": "Use log scale para sidelobes nos plots de magnitude para melhor visualização.",
                                  "learningObjective": "Identificar propriedades quantitativas de janelas comuns.",
                                  "commonMistakes": "Confundir resolução espectral com largura do mainlobe sem normalizar pela frequência de amostragem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender trade-offs entre resolução espectral e supressão de sidelobes",
                                  "subSteps": [
                                    "Defina resolução espectral como a capacidade de distinguir frequências próximas (inversamente proporcional à largura do mainlobe).",
                                    "Explique supressão de sidelobes como redução de vazamento espectral para evitar interferência em componentes fracos.",
                                    "Analise como janelas com melhor supressão (ex: Blackman) sacrificam resolução.",
                                    "Calcule exemplos numéricos: para N=1024, compare largura mainlobe em bins de frequência.",
                                    "Discuta impacto em cenários ruidosos vs. sinais puros."
                                  ],
                                  "verification": "Explicação escrita com cálculos e gráficos mostrando trade-offs quantitativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou script Python/MATLAB para simulações de FFT.",
                                  "tips": "Lembre-se: trade-off é fundamental; nenhuma janela é 'perfeita'.",
                                  "learningObjective": "Avaliar quantitativamente os trade-offs inerentes às janelas.",
                                  "commonMistakes": "Ignorar o comprimento da janela N, que afeta ambos os trade-offs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar requisitos do cenário específico",
                                  "subSteps": [
                                    "Descreva o cenário: análise de vibrações mecânicas em hélices aeronáuticas (frequências baixas dominantes, ruído de sidelobes crítico).",
                                    "Determine prioridades: alta resolução para harmônicos próximos ou forte supressão para detectar vibrações fracas?",
                                    "Estime faixa de frequências de interesse e nível de ruído esperado.",
                                    "Classifique o sinal: estacionário ou não, comprimento de dados disponível.",
                                    "Crie uma matriz de requisitos: resolução mínima (bins), supressão mínima (dB)."
                                  ],
                                  "verification": "Matriz de requisitos documentada e justificada para o cenário.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Dados reais ou simulados de vibrações (ex: datasets públicos de NASA).",
                                  "tips": "Priorize supressão se sidelobes mascaram sinais fracos em vibrações.",
                                  "learningObjective": "Mapear necessidades do problema para métricas de janelas.",
                                  "commonMistakes": "Subestimar ruído real em aplicações aeronáuticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar janelas e selecionar a ideal",
                                  "subSteps": [
                                    "Pontue cada janela com base na matriz de requisitos (ex: score = w1*resolução + w2*supressão).",
                                    "Simule aplicação em sinal de vibração: aplique janelas e compare espectros.",
                                    "Selecione a melhor (ex: Hanning para equilíbrio em vibrações).",
                                    "Justifique escolha com métricas numéricas e visual.",
                                    "Teste sensibilidade variando parâmetros como N."
                                  ],
                                  "verification": "Relatório com simulações, scores e justificativa da escolha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Script de simulação completo em Python/MATLAB com sinal de vibração sintético.",
                                  "tips": "Use Hamming para bom equilíbrio em análises mecânicas.",
                                  "learningObjective": "Selecionar e justificar janela otimizada para cenário.",
                                  "commonMistakes": "Escolher baseado em intuição sem simulação quantitativa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a escolha",
                                  "subSteps": [
                                    "Aplique a janela selecionada em dados reais de vibrações.",
                                    "Compare com outras janelas em métricas como SNR melhorado.",
                                    "Ajuste parâmetros (ex: beta para Kaiser) se necessário.",
                                    "Documente limitações e quando trocar de janela.",
                                    "Crie um fluxograma de decisão para seleção futura."
                                  ],
                                  "verification": "Fluxograma e resultados de validação com dados reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dados reais de vibrações aeronáuticas (ex: repositórios Kaggle ou NASA).",
                                  "tips": "Sempre valide com dados reais, não só sintéticos.",
                                  "learningObjective": "Validar decisão e criar processo reutilizável.",
                                  "commonMistakes": "Não considerar efeitos de padding zero na FFT."
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma hélice de turbina aeronáutica com dados de acelerômetro (fs=10kHz, N=2048), sidelobes da Rectangular mascaram harmônicos fracos a 1.2kHz; selecionar Hanning reduz sidelobes em 30dB mantendo resolução para separar 950Hz e 1050Hz.",
                              "finalVerifications": [
                                "Pode listar propriedades de 4 janelas comuns com valores numéricos exatos?",
                                "Explica trade-offs com exemplo gráfico?",
                                "Justifica escolha para cenário de vibrações com simulação?",
                                "Identifica quando usar Kaiser vs. Hanning?",
                                "Cria matriz de decisão personalizada?",
                                "Valida com dados reais mostrando melhoria em SNR?"
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa nas propriedades de janelas (90%+ correto).",
                                "Análise de trade-offs com cálculos e plots claros.",
                                "Justificativa contextualizada ao cenário aeronáutico.",
                                "Simulações reproduzíveis demonstrando seleção ótima.",
                                "Fluxograma de decisão abrangente e prático.",
                                "Identificação correta de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Fourier Discreta (FFT) e análise assintótica.",
                                "Física: Dinâmica de vibrações mecânicas e análise modal.",
                                "Programação: Implementação em Python (NumPy/SciPy) ou MATLAB.",
                                "Estatística: Avaliação de ruído e estimação de SNR."
                              ],
                              "realWorldApplication": "Na manutenção preditiva de aeronaves, selecionar Hanning para análise de vibrações em rotores detecta falhas precoces em rolamentos, evitando downtimes caros e melhorando segurança de voo."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1",
                              "10.1.6.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Simular janelamento em software",
                            "description": "Usar ferramentas como MATLAB ou Python para aplicar diferentes janelas a um sinal e analisar o espectro resultante via FFT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Ambiente e Geração do Sinal de Teste",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: numpy, scipy e matplotlib via pip.",
                                    "Crie um sinal de teste sinusoidal com frequência conhecida (ex: 50 Hz), taxa de amostragem fs=1000 Hz e comprimento N=1024.",
                                    "Adicione ruído gaussiano leve para simular sinal real.",
                                    "Plote o sinal no domínio do tempo para visualização inicial.",
                                    "Defina parâmetros globais como variáveis para reutilização."
                                  ],
                                  "verification": "Sinal gerado e plotado corretamente no domínio do tempo sem erros de execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: numpy, scipy, matplotlib",
                                    "Jupyter Notebook ou script .py"
                                  ],
                                  "tips": "Escolha N como potência de 2 para eficiência na FFT; normalize o sinal para amplitude unitária.",
                                  "learningObjective": "Preparar um ambiente de simulação e sinal representativo para análise de janelamento.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas",
                                    "Taxa de amostragem insuficiente causando aliasing",
                                    "Comprimento N inadequado para resolução espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicação da Janela Retangular e Cálculo da FFT",
                                  "subSteps": [
                                    "Aplique a janela retangular (sem multiplicação, sinal original).",
                                    "Calcule a Transformada Rápida de Fourier (FFT) usando np.fft.fft().",
                                    "Calcule o espectro de magnitude com np.fft.fftshift() para centralizar DC.",
                                    "Plote o espectro de frequência (eixo em Hz) com labels adequados.",
                                    "Identifique leakage espectral nos sidelobes."
                                  ],
                                  "verification": "Espectro plotado mostra pico principal em 50 Hz com sidelobes proeminentes devido ao leakage.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Funções numpy.fft"
                                  ],
                                  "tips": "Use freqs = np.fft.fftfreq(N, 1/fs) para eixo de frequência correto; aplique 20*log10 para escala dB.",
                                  "learningObjective": "Implementar FFT básica e observar efeitos de não-janelamento em sinais finitos.",
                                  "commonMistakes": [
                                    "Não centralizar o espectro com fftshift",
                                    "Eixo de frequência incorreto",
                                    "Escala linear em vez de dB para espectro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação de Janelas Não-Retangulares e Comparação Inicial",
                                  "subSteps": [
                                    "Gere janelas Hann e Hamming usando scipy.signal.get_window('hann', N) e 'hamming'.",
                                    "Multiplique cada janela pelo sinal e calcule FFT para cada uma.",
                                    "Plote espectros lado a lado: retangular, Hann e Hamming.",
                                    "Meça largura do mainlobe e amplitude dos primeiros sidelobes.",
                                    "Observe redução de leakage nas janelas suavizadas."
                                  ],
                                  "verification": "Gráficos comparativos mostram redução de sidelobes em Hann/Hamming vs. retangular.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "scipy.signal"
                                  ],
                                  "tips": "Normalize janelas para preservar energia (divida pela norma); compare em escala dB para melhor visualização.",
                                  "learningObjective": "Aplicar funções janela comuns e quantificar seus efeitos iniciais no espectro.",
                                  "commonMistakes": [
                                    "Não normalizar janelas causando discrepância de amplitude",
                                    "Janelas com comprimento errado",
                                    "Plots sobrepostos ilegíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise Avançada, Experimentação e Interpretação",
                                  "subSteps": [
                                    "Teste Blackman window e compare com as anteriores.",
                                    "Varie parâmetros: N, frequência do sinal e ruído; observe impactos.",
                                    "Calcule métricas: largura mainlobe (-3dB), atenuação sidelobe máxima.",
                                    "Documente trade-offs (resolução vs. leakage) em tabela ou comentários.",
                                    "Interprete resultados para diferentes cenários de análise de sinais."
                                  ],
                                  "verification": "Relatório ou comentários explicam propriedades de cada janela com evidências gráficas e métricas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Códigos anteriores",
                                    "Ferramentas de plotagem avançada como subplots"
                                  ],
                                  "tips": "Use loops para automatizar múltiplas janelas; salve figuras para relatório.",
                                  "learningObjective": "Analisar criticamente propriedades de janelas e suas aplicações práticas.",
                                  "commonMistakes": [
                                    "Ignorar normalização entre janelas",
                                    "Conclusões sem métricas quantitativas",
                                    "Não testar variações de parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere sinal x(t) = sin(2*pi*50*t) + 0.1*randn, fs=1000 Hz, N=1024. Aplique Hann: w = get_window('hann', N); y = x * w. Compute FFTs e plote: retangular mostra sidelobes ~ -13 dB, Hann ~ -32 dB, revelando redução de leakage.",
                              "finalVerifications": [
                                "Espectros de múltiplas janelas plotados e comparados corretamente.",
                                "Leakage reduzido visível em janelas não-retangulares.",
                                "Métricas quantitativas (mainlobe, sidelobes) calculadas e reportadas.",
                                "Código executável e reproduzível sem erros.",
                                "Interpretação discute trade-offs entre resolução e dynamic range.",
                                "Parâmetros variados testados com conclusões derivadas."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta de janelas e FFT (sem erros numéricos).",
                                "Gráficos claros, legíveis com eixos rotulados e escalas dB.",
                                "Análise quantitativa e qualitativa precisa das propriedades.",
                                "Código modular, comentado e eficiente.",
                                "Demonstração de experimentação com variações de parâmetros.",
                                "Conclusões alinhadas com teoria de janelamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada Discreta de Fourier e séries de Fourier.",
                                "Programação: Manipulação de arrays NumPy e visualização Matplotlib.",
                                "Física: Processamento de sinais vibracionais e acústicos.",
                                "Estatística: Efeitos de ruído e estimativa espectral.",
                                "Engenharia de Software: Boas práticas em simulações numéricas."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, simulações de janelamento processam dados de sensores em testes de vibração de estruturas (ex: asas em flutter), reduzindo leakage espectral para detectar modos ressonantes precisos e prevenir falhas estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Amostragem",
                    "description": "Conversão de sinais contínuos em sequências discretas por extração de valores em instantes regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Processo de Amostragem",
                        "description": "Definição e representação da conversão de um sinal contínuo x(t) em uma sequência discreta x[n] por extração de valores em instantes regulares T_s.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir amostragem",
                            "description": "Explicar o processo de amostragem como a extração de valores de um sinal contínuo em intervalos regulares de tempo T_s, resultando em x[n] = x(n T_s), e identificar componentes como sinal contínuo, taxa de amostragem e sinal discreto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Sinal Contínuo",
                                  "subSteps": [
                                    "Defina um sinal contínuo como uma função x(t) onde t varia continuamente no tempo.",
                                    "Identifique exemplos reais, como tensão de um sensor de pressão em uma asa de aeronave.",
                                    "Desenhe um gráfico simples de um sinal contínuo senoidal.",
                                    "Explique por que sinais contínuos não podem ser processados diretamente por computadores.",
                                    "Discuta limitações físicas de medição contínua em sistemas aeronáuticos."
                                  ],
                                  "verification": "Desenhe e rotule um gráfico de sinal contínuo com eixo t contínuo e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, software de plotagem como MATLAB ou Python (Matplotlib)",
                                  "tips": "Use exemplos de aeronáutica para fixar o conceito, como vibrações em hélices.",
                                  "learningObjective": "Entender a natureza temporal contínua de sinais analógicos.",
                                  "commonMistakes": "Confundir sinal contínuo com discreto; assumir que todos os sinais são digitais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Processo de Amostragem",
                                  "subSteps": [
                                    "Descreva amostragem como a extração de valores instantâneos de x(t) em intervalos regulares.",
                                    "Defina o intervalo de amostragem T_s como o tempo entre amostras consecutivas.",
                                    "Explique a taxa de amostragem f_s = 1/T_s em Hz.",
                                    "Ilustre com um diagrama: sinal contínuo com pontos de amostragem marcados.",
                                    "Calcule exemplos simples: para T_s = 0.1s, f_s = 10 Hz."
                                  ],
                                  "verification": "Crie um diagrama manual ou digital mostrando amostragem de um sinal senoidal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos impressos de sinais, calculadora, MATLAB para simulação básica",
                                  "tips": "Comece com T_s grandes para visualizar facilmente, depois diminua.",
                                  "learningObjective": "Graspar o mecanismo básico de conversão temporal contínua para discreta.",
                                  "commonMistakes": "Ignorar que amostragem é pontual, não intervalar; confundir T_s com duração total."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Notação Matemática da Amostragem",
                                  "subSteps": [
                                    "Escreva a fórmula x[n] = x(n T_s), onde n é inteiro.",
                                    "Explique que x[n] é o sinal discreto resultante.",
                                    "Gere uma sequência x[n] para um sinal x(t) = sin(2π f t) com f_s dado.",
                                    "Compare sequências para diferentes T_s, observando aliasing básico.",
                                    "Pratique notação em exemplos numéricos com tabela de valores."
                                  ],
                                  "verification": "Escreva e compute x[n] para n=0 a 5, dado x(t)=cos(2π t) e T_s=0.2s.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de cálculo Excel ou Python Jupyter Notebook, tabela de funções trigonométricas",
                                  "tips": "Use calculadora para valores exatos antes de generalizar.",
                                  "learningObjective": "Dominar a representação matemática precisa da amostragem.",
                                  "commonMistakes": "Escrever x[n] = x(t_n) sem especificar T_s; erros em índices n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Diferenciar Componentes Chave",
                                  "subSteps": [
                                    "Liste componentes: sinal contínuo x(t), intervalo T_s, taxa f_s, sinal discreto x[n].",
                                    "Crie uma tabela comparativa: contínuo vs discreto (domínio, representação, processamento).",
                                    "Discuta implicações em aeronáutica: perda de informação se f_s baixa.",
                                    "Identifique em um fluxograma: entrada analógica → amostrador → saída digital.",
                                    "Resuma definições em uma frase coesa."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e recite definições sem consultar notas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela modelo impressa, fluxograma em software como Draw.io",
                                  "tips": "Relacione com ADC (Conversor Analógico-Digital) em aviônicos.",
                                  "learningObjective": "Distinguir e nomear todos os elementos do processo de amostragem.",
                                  "commonMistakes": "Confundir taxa de amostragem com frequência do sinal; omitir x(t) como origem."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de voo de uma aeronave, amostre a velocidade angular de rotação da hélice x(t) a cada T_s = 0.01s (f_s = 100 Hz), gerando x[n] = x(n*0.01) para monitoramento digital em tempo real.",
                              "finalVerifications": [
                                "Defina amostragem usando a fórmula x[n] = x(n T_s) corretamente.",
                                "Identifique sinal contínuo, T_s e sinal discreto em um diagrama.",
                                "Calcule f_s dado T_s e vice-versa.",
                                "Diferencie x(t) de x[n] em termos de domínio temporal.",
                                "Explique o propósito da amostragem em processamento digital.",
                                "Gere uma sequência simples de amostras manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (x[n] = x(n T_s)) - 30%.",
                                "Clareza na identificação de componentes (x(t), T_s, f_s, x[n]) - 25%.",
                                "Capacidade de ilustrar com diagrama ou exemplo - 20%.",
                                "Compreensão de diferenças contínuo/discreto - 15%.",
                                "Aplicação contextual em aeronáutica - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências discretas e funções contínuas.",
                                "Física: Sinais analógicos em dinâmica de sistemas aeronáuticos.",
                                "Programação: Implementação de amostragem em Python/MATLAB para DSP.",
                                "Eletrônica: Conversores A/D em aviônicos."
                              ],
                              "realWorldApplication": "Na telemetria de voo, amostragem de sensores de aceleração e pressão permite análise digital de vibrações estruturais em aeronaves, prevenindo falhas e otimizando desempenho em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Representar sinal amostrado",
                            "description": "Representar graficamente e matematicamente um sinal contínuo amostrado, destacando a perda de informação entre os pontos de amostragem e a notação x[n].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Sinais Contínuos e Amostragem",
                                  "subSteps": [
                                    "Defina sinal contínuo x(t) como uma função do tempo contínuo.",
                                    "Explique o processo de amostragem: multiplicação por pente de Dirac ou seleção em intervalos T_s.",
                                    "Identifique a frequência de amostragem f_s = 1/T_s e o teorema de Nyquist.",
                                    "Discuta aliasing como consequência de amostragem inadequada.",
                                    "Esboce intuitivamente a perda de informação entre amostras."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo coerente e responda corretamente a 3 perguntas de revisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Sinais e Sistemas (ex: Oppenheim), papel e caneta para esboços"
                                  ],
                                  "tips": "Use analogias como fotos de um carro em movimento para ilustrar perda de informação.",
                                  "learningObjective": "Compreender os princípios teóricos da amostragem para basear representações.",
                                  "commonMistakes": [
                                    "Confundir sinal discreto com contínuo desde o início",
                                    "Ignorar o papel da frequência de amostragem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Graficamente o Sinal Contínuo e os Pontos de Amostragem",
                                  "subSteps": [
                                    "Escolha um sinal contínuo simples, como x(t) = sin(2πf t).",
                                    "Plote x(t) em um eixo de tempo contínuo usando software ou papel milimetrado.",
                                    "Marque os pontos de amostragem em t = n T_s, para n inteiro.",
                                    "Conecte os pontos com linhas retas ou círculos para destacar amostras.",
                                    "Rotule eixos: tempo (s) e amplitude."
                                  ],
                                  "verification": "Gere um gráfico onde os pontos de amostragem sejam claramente visíveis e escalados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python com Matplotlib, ou Desmos), exemplos de sinais"
                                  ],
                                  "tips": "Use cores diferentes: linha sólida para contínuo, pontos para amostrados.",
                                  "learningObjective": "Visualizar a transição de contínuo para discreto graficamente.",
                                  "commonMistakes": [
                                    "Escala de tempo incorreta, fazendo amostras parecerem contínuas",
                                    "Não destacar gaps entre amostras"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter para Representação Matemática Discreta x[n]",
                                  "subSteps": [
                                    "Defina x[n] = x(n T_s) para n = ..., -1, 0, 1, ...",
                                    "Escreva a notação matemática: x[n] = sin(2π f n T_s).",
                                    "Liste valores numéricos para n = 0 a 10, calculando explicitamente.",
                                    "Compare x[n] com x(t) em uma tabela lado a lado.",
                                    "Verifique periodicidade discreta se aplicável."
                                  ],
                                  "verification": "Escreva a fórmula x[n] correta e compute 5 valores que combinem com o gráfico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora, planilha (Excel ou Python para tabulação)",
                                    "Fórmulas de referência"
                                  ],
                                  "tips": "Sempre normalize T_s = 1 para simplificar cálculos iniciais.",
                                  "learningObjective": "Dominar a notação discreta x[n] e sua relação com x(t).",
                                  "commonMistakes": [
                                    "Escrever x[n] sem referência a T_s",
                                    "Confundir índices n com tempo t"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar e Analisar a Perda de Informação na Amostragem",
                                  "subSteps": [
                                    "Compare o gráfico contínuo com os pontos amostrados, sombreando áreas 'perdidas'.",
                                    "Calcule e plote um sinal reconstruído via interpolação linear.",
                                    "Discuta como frequência alta causa aliasing, simulando com f_s baixa.",
                                    "Quantifique perda: número de amostras vs. resolução temporal.",
                                    "Conclua com condições para amostragem fiel (Nyquist)."
                                  ],
                                  "verification": "Explique em 2-3 frases a perda observada e proponha f_s maior para mitigar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem para simulações de aliasing",
                                    "Exemplos de sinais com diferentes f_s"
                                  ],
                                  "tips": "Anime o gráfico se possível para mostrar 'preenchimento' das lacunas.",
                                  "learningObjective": "Identificar e quantificar impactos da amostragem no mundo real.",
                                  "commonMistakes": [
                                    "Subestimar aliasing como mera 'perda visual'",
                                    "Não relacionar a Nyquist"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python com Matplotlib: Plote x(t) = sin(2π*5*t) para t em [0,1]; amostre com T_s=0.1 (f_s=10Hz > Nyquist 10Hz), marcando pontos x[n]; reduza f_s para 6Hz e observe aliasing. Código: import numpy as np; import matplotlib.pyplot as plt; t=np.linspace(0,1,1000); x=np.sin(2*np.pi*5*t); plt.plot(t,x); t_s=np.arange(0,1,0.1); x_n=np.sin(2*np.pi*5*t_s); plt.plot(t_s,x_n,'ro'); plt.show().",
                              "finalVerifications": [
                                "Gráfico mostra sinal contínuo e pontos amostrados corretamente escalados.",
                                "Fórmula x[n] = x(n T_s) está escrita e valores numéricos batem.",
                                "Explicação clara da perda de informação entre amostras.",
                                "Simulação de aliasing com f_s inadequada é demonstrada.",
                                "Notação x[n] usada consistentemente sem erros de indexação.",
                                "Condições de Nyquist mencionadas para amostragem fiel."
                              ],
                              "assessmentCriteria": [
                                "Precisão gráfica: eixos rotulados, escalas corretas (90%).",
                                "Correção matemática: x[n] derivado corretamente (80%).",
                                "Análise de perda: identificação qualitativa e quantitativa (85%).",
                                "Uso de notação: x[n] vs x(t) distinguido claramente (95%).",
                                "Criatividade: inclusão de interpolação ou animação (bônus).",
                                "Clareza: explicações concisas e visualmente intuitivas (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e séries discretas, funções trigonométricas.",
                                "Programação: Plotagem de dados com Python/MATLAB, arrays numéricos.",
                                "Física: Ondas e vibrações em sistemas aeronáuticos.",
                                "Engenharia de Controle: Sensores digitais em aviônicos."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, sensores de voo (acelerômetros, giroscópios) amostram sinais contínuos de vibrações para sistemas de controle fly-by-wire; representação x[n] permite processamento digital em flight computers, evitando aliasing para estabilidade de voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Calcular sequência discreta",
                            "description": "Dado um sinal contínuo x(t) e intervalo T_s, calcular os primeiros termos da sequência discreta x[n] para n = 0,1,2,...",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o sinal contínuo e parâmetros de amostragem",
                                  "subSteps": [
                                    "Leia a definição do sinal contínuo x(t) fornecida no problema.",
                                    "Identifique o intervalo de amostragem T_s e confirme suas unidades (ex: segundos).",
                                    "Determine o número de termos da sequência a calcular (ex: n=0 a n=5).",
                                    "Anote a fórmula geral da sequência discreta: x[n] = x(n * T_s).",
                                    "Verifique se x(t) está definida para t ≥ 0."
                                  ],
                                  "verification": "Lista anotada com x(t), T_s, número de termos e fórmula x[n].",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Exemplo de sinal contínuo impresso"
                                  ],
                                  "tips": "Sempre confira as unidades de t e T_s para evitar erros dimensionais.",
                                  "learningObjective": "Identificar corretamente os componentes essenciais do processo de amostragem.",
                                  "commonMistakes": [
                                    "Confundir T_s com frequência de amostragem",
                                    "Ignorar o domínio de x(t)",
                                    "Esquecer n inicia em 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o primeiro termo x[0]",
                                  "subSteps": [
                                    "Substitua n=0 na fórmula: x[0] = x(0 * T_s) = x(0).",
                                    "Avalie x(0) usando a expressão de x(t).",
                                    "Simplifique o resultado numericamente ou simbolicamente.",
                                    "Registre o valor com precisão adequada (ex: 4 casas decimais).",
                                    "Confirme se o cálculo é consistente com propriedades conhecidas de x(t)."
                                  ],
                                  "verification": "Valor de x[0] calculado e anotado corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de rascunho"
                                  ],
                                  "tips": "Para funções trigonométricas ou exponenciais, use identidades para simplificar.",
                                  "learningObjective": "Executar substituição precisa para n=0 e avaliar x(0).",
                                  "commonMistakes": [
                                    "Erro aritmético básico",
                                    "Esquecer parênteses em funções compostas",
                                    "Não simplificar frações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os termos subsequentes x[1], x[2], ...",
                                  "subSteps": [
                                    "Para cada n=1,2,... até o limite: calcule t_n = n * T_s.",
                                    "Substitua t_n em x(t) para obter x[n].",
                                    "Realize os cálculos passo a passo, mostrando operações intermediárias.",
                                    "Registre cada x[n] em uma tabela com n, t_n e x[n].",
                                    "Verifique numericamente um termo aleatório para consistência."
                                  ],
                                  "verification": "Tabela completa com pelo menos 3-5 termos calculados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela em papel ou Excel"
                                  ],
                                  "tips": "Use uma tabela para organizar: evita confusão entre termos.",
                                  "learningObjective": "Aplicar repetidamente a fórmula de amostragem para múltiplos n.",
                                  "commonMistakes": [
                                    "Erro no cálculo de t_n (multiplicação)",
                                    "Perder sinal em funções pares/ímpares",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a sequência e preparar para análise",
                                  "subSteps": [
                                    "Liste a sequência discreta: x[0], x[1], x[2], ...",
                                    "Compare com valores esperados ou gráfico mental de x(t).",
                                    "Calcule diferenças entre termos consecutivos se aplicável.",
                                    "Discuta potenciais efeitos de aliasing se T_s for grande.",
                                    "Prepare um resumo com a sequência final."
                                  ],
                                  "verification": "Sequência listada e validada sem erros evidentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico de x(t) opcional",
                                    "Software de plotagem como Desmos (opcional)"
                                  ],
                                  "tips": "Plote pontos discretos vs. contínuo para visualização intuitiva.",
                                  "learningObjective": "Validar a sequência gerada e relacioná-la ao sinal original.",
                                  "commonMistakes": [
                                    "Ignorar aliasing em amostragem inadequada",
                                    "Erro de transcrição na lista final",
                                    "Não verificar consistência"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado x(t) = sin(2π * 5 t) + 0.5 * cos(2π * 10 t), T_s = 0.1 s, calcule x[0], x[1], x[2], x[3]. Resultado esperado: x[0]=0.5, x[1]=0.5878, x[2]=0.8090, x[3]=0.5878 (aprox.).",
                              "finalVerifications": [
                                "x[0] = x(0) corretamente avaliado.",
                                "Todos t_n = n * T_s calculados sem erros aritméticos.",
                                "Sequência listada em ordem correta para n=0,1,2,...",
                                "Precisão numérica consistente (ex: 4 decimais).",
                                "Sem discrepâncias com sinal original em pontos amostrados.",
                                "Tabela ou lista organizada e legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos (100% correto: excelente; 80-99%: bom; <80%: insatisfatório).",
                                "Organização da tabela/sequência (clara e completa).",
                                "Demonstração de passos intermediários (mostra entendimento).",
                                "Identificação de erros comuns evitados.",
                                "Validação final coerente com x(t).",
                                "Eficiência temporal (dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Avaliação de funções trigonométricas e exponenciais.",
                                "Programação: Implementar amostragem em Python/MATLAB com loops.",
                                "Física: Sinais de sensores em dinâmica de aeronaves.",
                                "Estatística: Análise de variância em sequências amostradas."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, amostragem de sinais de sensores (ex: acelerômetros em asas) para sistemas de controle de voo digital, onde T_s determina a precisão do monitoramento de vibrações e estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Taxa de Amostragem e Teorema de Nyquist-Shannon",
                        "description": "Determinação da frequência de amostragem mínima necessária para reconstruir fielmente o sinal original, baseada na frequência máxima do sinal.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Explicar teorema de Nyquist-Shannon",
                            "description": "Descrever o teorema que estabelece f_s > 2 f_max para evitar perda de informação, onde f_s = 1/T_s é a taxa de amostragem e f_max é a frequência máxima do sinal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Sinais e Frequências",
                                  "subSteps": [
                                    "Definir sinal contínuo e sinal discreto, com exemplos de cada um.",
                                    "Explicar frequência (f), período (T) e taxa de amostragem (fs = 1/Ts).",
                                    "Descrever o espectro de frequência e identificar f_max como a maior frequência componente.",
                                    "Analisar como a amostragem converte sinal contínuo em discreto.",
                                    "Usar gráficos para visualizar sinal senoidal e seu espectro."
                                  ],
                                  "verification": "Resumir em um parágrafo os conceitos e desenhar um gráfico simples de espectro de frequência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Vídeos Khan Academy sobre Fourier"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas como som e ondas de rádio para fixar conceitos.",
                                    "Pratique convertendo unidades de fs para Ts."
                                  ],
                                  "learningObjective": "Dominar a terminologia essencial para amostragem de sinais.",
                                  "commonMistakes": [
                                    "Confundir frequência do sinal (f) com taxa de amostragem (fs)",
                                    "Ignorar componentes de alta frequência em sinais reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Fenômeno do Aliasing",
                                  "subSteps": [
                                    "Observar aliasing em exemplos visuais, como rodas de carro girando em vídeos.",
                                    "Simular amostragem de um sinal senoidal com fs < 2f usando software.",
                                    "Analisar graficamente como frequências altas 'dobram' para baixas (aliasing).",
                                    "Calcular o erro de reconstrução para fs insuficiente.",
                                    "Diferenciar aliasing de ruído e distorção harmônica."
                                  ],
                                  "verification": "Gerar e plotar um gráfico mostrando aliasing para um sinal de 10 Hz amostrado a 15 Hz.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "MATLAB Signal Processing Toolbox",
                                    "Vídeo demonstrativo de aliasing"
                                  ],
                                  "tips": [
                                    "Sempre plote o sinal original vs. amostrado para visualizar o problema.",
                                    "Experimente diferentes valores de fs para ver o limiar."
                                  ],
                                  "learningObjective": "Identificar e quantificar os efeitos negativos da subamostragem.",
                                  "commonMistakes": [
                                    "Achar que aliasing só ocorre em áudio, ignorando vibrações mecânicas",
                                    "Não normalizar frequências normalizadas (f/fs)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação e Prova Intuitiva do Teorema de Nyquist-Shannon",
                                  "subSteps": [
                                    "Enunciar o teorema: Para reconstruir sinal sem perda, fs > 2 f_max.",
                                    "Explicar intuitivamente usando réplicas espectrais na transformada de Fourier.",
                                    "Derivar a condição usando expansão em séries de Fourier.",
                                    "Discutir o caso ideal (sinal bandlimitado) e fs = 2 f_max (Nyquist rate).",
                                    "Apresentar prova matemática simplificada com sinc interpolation."
                                  ],
                                  "verification": "Escrever e explicar a derivação passo a passo em um documento ou quadro.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Notas de aula sobre Transformada de Fourier",
                                    "Artigo original de Nyquist/Shannon (resumo)",
                                    "Wolfram Alpha para verificações"
                                  ],
                                  "tips": [
                                    "Comece com intuição antes da matemática pesada.",
                                    "Desenhe espectros antes e depois da amostragem."
                                  ],
                                  "learningObjective": "Enunciar e derivar o teorema com precisão matemática.",
                                  "commonMistakes": [
                                    "Usar fs >= 2 f_max em vez de > (estrito para prática)",
                                    "Esquecer que teorema assume sinal perfeitamente bandlimitado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema em Contextos Práticos e Verificações",
                                  "subSteps": [
                                    "Calcular fs mínima para um sinal aeronáutico (ex: vibração de motor com f_max = 500 Hz).",
                                    "Implementar simulação de amostragem com e sem filtro anti-aliasing.",
                                    "Reconstruir sinal usando interpolação sinc e comparar com original.",
                                    "Analisar impacto de fs subótima em sistemas de controle de voo.",
                                    "Discutir oversampling e suas vantagens."
                                  ],
                                  "verification": "Executar simulação em software e relatar taxa de erro de reconstrução.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (SciPy.signal para resample)",
                                    "MATLAB",
                                    "Dados reais de sensores aeronáuticos (dataset público)"
                                  ],
                                  "tips": [
                                    "Use fs = 2.5 f_max na prática para margem de segurança.",
                                    "Salve plots para portfólio."
                                  ],
                                  "learningObjective": "Aplicar o teorema em cenários reais de engenharia.",
                                  "commonMistakes": [
                                    "Não considerar filtros reais (roll-off finito)",
                                    "Ignorar jitter ou ruído na amostragem prática"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de monitoramento de vibrações de turbina em aeronave, com f_max = 400 Hz das vibrações, calcule fs > 800 Hz. Simule em Python: gere sinal senoidal de 350 Hz, amostre a 900 Hz, aplique filtro low-pass e reconstrua, verificando MSE < 0.01 comparado ao original.",
                              "finalVerifications": [
                                "Explicar verbalmente o teorema incluindo fórmula fs > 2 f_max.",
                                "Identificar aliasing em um gráfico de sinal amostrado fornecido.",
                                "Calcular corretamente fs mínima para sinal com f_max dado.",
                                "Simular e demonstrar reconstrução sem perda.",
                                "Discutir limitações em sinais não bandlimitados.",
                                "Relacionar a aplicações aeronáuticas como sensores de aceleração."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação e derivação do teorema (30%)",
                                "Clareza na explicação de aliasing com exemplos visuais (25%)",
                                "Corretude em simulações e cálculos numéricos (20%)",
                                "Profundidade nas conexões práticas e limitações (15%)",
                                "Uso adequado de terminologia técnica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries e Transformadas de Fourier",
                                "Física: Teoria de ondas e vibrações mecânicas",
                                "Programação: Simulações numéricas em Python/MATLAB",
                                "Engenharia de Controle: Sistemas de aquisição de dados em feedback",
                                "Eletrônica: Projeto de A/D converters e filtros"
                              ],
                              "realWorldApplication": "No design de sistemas de controle de voo autônomo, o teorema garante que dados de sensores de IMU (Inertial Measurement Unit) capturem dinâmicas de alta frequência de turbulências sem aliasing, evitando decisões errôneas que poderiam comprometer a segurança da aeronave."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Calcular taxa mínima de amostragem",
                            "description": "Dada a largura de banda B de um sinal (f_max = B), calcular a taxa de amostragem mínima f_s,min = 2B e o intervalo T_s,max = 1/(2B).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema de Nyquist-Shannon",
                                  "subSteps": [
                                    "Defina a largura de banda B como a frequência máxima f_max do sinal.",
                                    "Explique o conceito de aliasing: sobreposição de frequências causada por amostragem insuficiente.",
                                    "Enuncie o teorema: para reconstruir o sinal sem aliasing, a taxa de amostragem fs deve ser pelo menos 2B.",
                                    "Discuta as consequências de violar o teorema, como distorção irrecuperável.",
                                    "Visualize o espectro de frequência de um sinal bandlimitado."
                                  ],
                                  "verification": "Explique em suas próprias palavras o teorema e dê um exemplo simples de aliasing.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre Nyquist-Shannon (ex: Khan Academy)",
                                    "Papel e caneta para esboçar espectros"
                                  ],
                                  "tips": "Use analogia de filme: frames insuficientes criam ilusão de movimento errado.",
                                  "learningObjective": "Entender a base teórica da taxa mínima de amostragem para evitar aliasing.",
                                  "commonMistakes": [
                                    "Confundir B com a frequência central em vez de máxima",
                                    "Achar que fs = B é suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Largura de Banda B do Sinal",
                                  "subSteps": [
                                    "Leia o problema e localize o valor de B ou f_max fornecido.",
                                    "Confirme as unidades de B (geralmente Hz ou kHz).",
                                    "Converta unidades se necessário (ex: MHz para Hz).",
                                    "Anote B claramente, separando de outras frequências no sinal.",
                                    "Verifique se o sinal é bandlimitado (assumido no teorema)."
                                  ],
                                  "verification": "Registre o valor exato de B com unidades em um caderno.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Enunciado do problema",
                                    "Calculadora para conversões unitárias"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual é a frequência mais alta no sinal?'",
                                  "learningObjective": "Extrair corretamente o parâmetro chave B de descrições de sinais.",
                                  "commonMistakes": [
                                    "Usar frequência média em vez de máxima",
                                    "Ignorar prefixos como kHz ou MHz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Taxa de Amostragem Mínima fs,min = 2B",
                                  "subSteps": [
                                    "Multiplique B por 2 para obter fs,min.",
                                    "Mantenha as unidades consistentes (ex: se B em kHz, fs em kHz).",
                                    "Arredonde para cima se necessário para valores práticos.",
                                    "Escreva a equação explicitamente: fs,min = 2 × B.",
                                    "Teste com um valor numérico simples para validar."
                                  ],
                                  "verification": "Compare seu cálculo com fs,min = 2B para B=1 kHz (deve ser 2 kHz).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de fórmulas de amostragem"
                                  ],
                                  "tips": "Lembre-se: o fator 2 vem das duas amostras por ciclo (seno e cosseno).",
                                  "learningObjective": "Aplicar a fórmula principal do teorema com precisão numérica.",
                                  "commonMistakes": [
                                    "Dividir em vez de multiplicar",
                                    "Esquecer o fator 2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Intervalo de Amostragem Máximo Ts,max = 1/(2B)",
                                  "subSteps": [
                                    "Use fs,min calculado para Ts,max = 1 / fs,min.",
                                    "Converta para unidades apropriadas (s, ms ou μs).",
                                    "Verifique dimensionalmente: 1/Hz = s.",
                                    "Compare Ts,max com período do sinal (1/B).",
                                    "Interprete: Ts,max é o maior intervalo sem aliasing."
                                  ],
                                  "verification": "Para B=5 kHz, confirme Ts,max=100 μs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de prefixos SI"
                                  ],
                                  "tips": "Use 1/fs para evitar erros de inversão.",
                                  "learningObjective": "Calcular e interpretar o intervalo temporal correspondente à taxa mínima.",
                                  "commonMistakes": [
                                    "Calcular 1/B em vez de 1/(2B)",
                                    "Erros em conversões de unidades (ex: ms vs μs)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar os Resultados",
                                  "subSteps": [
                                    "Verifique se fs,min > 2B (igualdade teórica).",
                                    "Confirme Ts,max = 1/fs,min.",
                                    "Discuta oversampling: fs > 2B para margem de segurança.",
                                    "Relacione ao contexto aeronáutico (ex: sensores de vibração).",
                                    "Documente todos os passos em um relatório curto."
                                  ],
                                  "verification": "Responda: 'Por que fs deve ser exatamente 2B ou maior?'",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo prático resolvido",
                                    "Checklist de verificação"
                                  ],
                                  "tips": "Sempre inclua uma margem de 10-20% em aplicações reais.",
                                  "learningObjective": "Garantir cálculos corretos e compreensões práticas.",
                                  "commonMistakes": [
                                    "Aceitar fs < 2B",
                                    "Ignorar implicações práticas como ruído"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de radar aeronáutico, um sinal de eco tem largura de banda B = 10 kHz (f_max = 10 kHz). Calcule: fs,min = 2 × 10 kHz = 20 kHz; Ts,max = 1 / 20 kHz = 50 μs. Isso garante captura sem aliasing para detecção precisa de obstáculos.",
                              "finalVerifications": [
                                "Identifica corretamente B do sinal.",
                                "Calcula fs,min = 2B com unidades precisas.",
                                "Calcula Ts,max = 1/(2B) corretamente.",
                                "Explica o risco de aliasing se fs < 2B.",
                                "Aplica oversampling em cenários reais.",
                                "Verifica dimensionalmente as unidades.",
                                "Documenta passos lógicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 1%).",
                                "Unidades corretas e consistentes (Hz, s).",
                                "Justificativa teórica baseada no teorema.",
                                "Interpretação correta de fs,min e Ts,max.",
                                "Identificação de erros potenciais.",
                                "Aplicação contextual em engenharia.",
                                "Clareza na documentação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e análise dimensional.",
                                "Física: Teoria de ondas e espectros de frequência.",
                                "Informática: Programação de DSP em Python/MATLAB.",
                                "Engenharia de Controle: Sistemas de feedback discretos.",
                                "Estatística: Análise de ruído em sinais amostrados."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, calcular a taxa mínima de amostragem é essencial para processar sinais de sensores em aviões, como vibrações de motores ou dados de radar, evitando aliasing que poderia levar a falhas em sistemas de navegação ou detecção de colisões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Analisar espectro de frequência",
                            "description": "Identificar a frequência máxima f_max no espectro de um sinal contínuo e determinar se uma dada f_s satisfaz o teorema de Nyquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sinal contínuo e computar seu espectro de frequência",
                                  "subSteps": [
                                    "Obtenha o sinal contínuo de exemplo (ex: vibração simulada de uma estrutura aeronáutica).",
                                    "Aplique a Transformada de Fourier Rápida (FFT) usando software apropriado.",
                                    "Plote o espectro de magnitude versus frequência, normalizando o eixo de frequência.",
                                    "Aplique uma janela (ex: Hamming) para reduzir vazamento espectral.",
                                    "Identifique o intervalo de frequências relevantes (0 a f_Nyquist preliminar)."
                                  ],
                                  "verification": "Espetro de frequência plotado corretamente com picos visíveis e eixos rotulados.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Software MATLAB, Python (numpy, scipy, matplotlib)",
                                    "Arquivo de sinal de exemplo (.mat ou .csv)"
                                  ],
                                  "tips": "Sempre normalize a frequência pela taxa de amostragem para obter Hz reais; use resolução espectral adequada (N/2 pontos).",
                                  "learningObjective": "Dominar o processo de obtenção do espectro de frequência de um sinal contínuo.",
                                  "commonMistakes": [
                                    "Não aplicar janela, causando leakage",
                                    "Confundir domínio do tempo com frequência",
                                    "Escala errada no eixo de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar componentes do espectro de frequência",
                                  "subSteps": [
                                    "Examine o espectro para identificar picos principais de magnitude.",
                                    "Diferencie harmônicos, ruído e componentes fundamentais.",
                                    "Meça largura de banda do sinal analisando a energia espectral.",
                                    "Ignore artefatos de DC ou baixas frequências irrelevantes.",
                                    "Anote frequências de picos significativos (acima de threshold de 10% do máximo)."
                                  ],
                                  "verification": "Lista de componentes principais anotada com frequências e magnitudes aproximadas.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Gráfico do espectro gerado no Step 1",
                                    "Ferramentas de zoom e medição no software"
                                  ],
                                  "tips": "Use escala logarítmica para visualizar ruído de fundo; foque em picos acima de -20 dB.",
                                  "learningObjective": "Desenvolver habilidade em leitura e interpretação de espectros.",
                                  "commonMistakes": [
                                    "Confundir ruído com sinal real",
                                    "Ignorar harmônicos de alta ordem",
                                    "Não considerar simetria do espectro bilateral"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a frequência máxima f_max",
                                  "subSteps": [
                                    "Localize o pico de maior frequência com magnitude significativa.",
                                    "Confirme se é o limite superior do conteúdo espectral (ex: 95% da energia).",
                                    "Calcule f_max como a frequência onde o espectro cai abaixo de um threshold.",
                                    "Registre f_max com precisão (ex: 450 Hz).",
                                    "Valide com integral de energia para confirmar largura de banda."
                                  ],
                                  "verification": "Valor de f_max determinado e justificado com evidência do gráfico.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Espetro plotado e anotado dos steps anteriores"
                                  ],
                                  "tips": "f_max é a frequência onde o espectro tem energia desprezível além dela; use cursor de medição.",
                                  "learningObjective": "Precisamente determinar f_max a partir de análise espectral.",
                                  "commonMistakes": [
                                    "Escolher pico isolado como f_max ignorando banda",
                                    "Usar frequência de Nyquist como f_max",
                                    "Arredondar incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar satisfação do teorema de Nyquist com f_s dada",
                                  "subSteps": [
                                    "Lembre o teorema: f_s > 2 * f_max para evitar aliasing.",
                                    "Calcule taxa de Nyquist mínima: 2 * f_max.",
                                    "Compare com f_s fornecida (ex: f_s = 1000 Hz).",
                                    "Conclua se satisfaz (sim/não) e calcule margem de segurança.",
                                    "Discuta implicações se não satisfizer (aliasing)."
                                  ],
                                  "verification": "Conclusão clara com cálculo: f_s > 2*f_max ? Sim/Não, com valor numérico.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Valores de f_max e f_s anotados"
                                  ],
                                  "tips": "Sempre use > 2.2-2.5 * f_max na prática para margem anti-aliasing.",
                                  "learningObjective": "Aplicar teorema de Nyquist-Shannon para validar taxa de amostragem.",
                                  "commonMistakes": [
                                    "Usar f_s >= 2*f_max em vez de >",
                                    "Confundir f_max com largura de banda total",
                                    "Ignorar unidades (Hz vs rad/s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de vibração de asa de aeronave, um sinal contínuo de acelerômetro mostra espectro com picos em 50 Hz (fundamental), 150 Hz (harmônico) e 420 Hz (modo torsional). Identifique f_max = 420 Hz e verifique se f_s = 1000 Hz satisfaz Nyquist (sim, pois 1000 > 840 Hz).",
                              "finalVerifications": [
                                "Espetro corretamente plotado e interpretado.",
                                "f_max identificado com precisão (±5 Hz).",
                                "Cálculo de Nyquist rate exato (2*f_max).",
                                "Conclusão correta sobre adequação de f_s.",
                                "Explicação de implicações de aliasing se falhar.",
                                "Documentação completa com gráficos e cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de f_max (90%+ correção).",
                                "Correta aplicação do teorema de Nyquist (f_s vs 2*f_max).",
                                "Qualidade da interpretação espectral (picos/harmônicos).",
                                "Uso adequado de ferramentas e janelamento.",
                                "Clareza na documentação e justificativas.",
                                "Tratamento de erros comuns e dicas aplicadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Fourier e análise harmônica.",
                                "Física: Dinâmica de vibrações e ressonância estrutural.",
                                "Programação: Implementação de FFT em Python/MATLAB.",
                                "Engenharia Mecânica: Análise modal de componentes aeronáuticos.",
                                "Processamento de Sinais: Filtros anti-aliasing."
                              ],
                              "realWorldApplication": "Em sistemas de monitoramento de saúde estrutural (SHM) de aeronaves, análise de espectro garante que dados de sensores MEMS capturem vibrações sem aliasing, prevenindo detecção falha de fadiga e falhas em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Fenômeno de Aliasing e Prevenção",
                        "description": "Efeito da subamostragem que causa sobreposição de espectros e distorção do sinal, e técnicas para mitigá-lo como filtros anti-aliasing.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Identificar aliasing",
                            "description": "Explicar o aliasing como a interpretação errônea de frequências acima de f_s/2 como frequências mais baixas, ilustrando com réplicas espectrais periódicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Amostragem e Teorema de Nyquist",
                                  "subSteps": [
                                    "Defina frequência de amostragem (f_s) como o número de amostras por segundo.",
                                    "Explique o teorema de Nyquist-Shannon: para reconstruir um sinal sem distorção, f_s deve ser pelo menos 2 vezes a frequência máxima do sinal (f_max < f_s/2).",
                                    "Calcule a frequência de Nyquist (f_N = f_s/2) para exemplos simples, como f_s = 100 Hz.",
                                    "Discuta o impacto de violar o teorema: perda de informação ou distorção.",
                                    "Desenhe um diagrama simples de um sinal senoidal sendo amostrado corretamente vs. subamostrado."
                                  ],
                                  "verification": "Responda corretamente a perguntas: Qual é f_N para f_s=200 Hz? O que acontece se f > f_N?",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Gráficos de referência de amostragem (online ou livro-texto)"
                                  ],
                                  "tips": "Use analogias como 'fotografar um carro em movimento': poucas fotos distorcem a velocidade.",
                                  "learningObjective": "Compreender os limites da amostragem para prevenir aliasing.",
                                  "commonMistakes": [
                                    "Confundir f_s com f_N",
                                    "Achar que f_s > f_max é suficiente sem o fator 2",
                                    "Ignorar componentes harmônicos no sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Mecanismo do Aliasing",
                                  "subSteps": [
                                    "Defina aliasing como a interpretação de frequências f > f_s/2 como frequências falsas f_alias = |f - k*f_s| onde k é inteiro para minimizar f_alias.",
                                    "Explique o 'folding' em torno de f_N: frequências entre f_N e f_s aparecem como f_s - f.",
                                    "Calcule exemplos: para f_s=100 Hz, f=70 Hz → f_alias=30 Hz; f=130 Hz → f_alias=30 Hz.",
                                    "Discuta por que isso ocorre: amostragem cria ambiguidade espectral.",
                                    "Compare sinal original vs. amostrado em software ou por mão."
                                  ],
                                  "verification": "Calcule f_alias para 3 cenários dados e explique o erro de interpretação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel para cálculos",
                                    "Vídeo tutorial sobre aliasing (YouTube: 3Blue1Brown ou similar)"
                                  ],
                                  "tips": "Lembre-se: aliasing é como espelhos em uma sala de espelhos – múltiplas imagens falsas.",
                                  "learningObjective": "Explicar matematicamente como aliasing distorce frequências altas.",
                                  "commonMistakes": [
                                    "Esquecer o valor absoluto no cálculo de f_alias",
                                    "Confundir com ruído branco",
                                    "Achar que aliasing só afeta áudio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Réplicas Espectrais Periódicas",
                                  "subSteps": [
                                    "Descreva o espectro do sinal amostrado como réplicas do espectro contínuo centradas em k*f_s (k=0, ±1, ±2...).",
                                    "Desenhe o espectro: sinal base (-f_N a f_N) + réplicas sobrepostas causando aliasing.",
                                    "Identifique sobreposição: se largura do espectro > f_s, réplicas vazam para a base.",
                                    "Use ferramenta para plotar: sinal sen(2π*60t) com f_s=100 Hz mostrando réplicas.",
                                    "Compare com filtro anti-aliasing: corta frequências > f_N antes da amostragem."
                                  ],
                                  "verification": "Esboce espectro com réplicas para f_s=50 Hz e sinal de 40 Hz + 70 Hz.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB/Octave/Python (Matplotlib)",
                                    "Papel milimetrado",
                                    "Templates de espectro online"
                                  ],
                                  "tips": "Pense no espectro como um trem infinito de cópias espaçadas por f_s.",
                                  "learningObjective": "Visualizar graficamente como réplicas causam aliasing.",
                                  "commonMistakes": [
                                    "Desenhar réplicas só para k>0",
                                    "Ignorar simetria espectral negativa",
                                    "Confundir espectro de amplitude com potência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação de Aliasing em Exemplos Práticos",
                                  "subSteps": [
                                    "Analise dados: dado f_s e picos no espectro amostrado, identifique se são reais ou aliases.",
                                    "Exemplo: Pico a 20 Hz com f_s=50 Hz – verifique possíveis f reais (20, 30, 70, 80 Hz...).",
                                    "Simule em software: gere sinal com f> f_N e observe FFT do amostrado.",
                                    "Discuta prevenção: upsampling ou filtro passa-baixa.",
                                    "Aplique a contexto aeronáutico: vibração em hélice detectada erroneamente."
                                  ],
                                  "verification": "Identifique aliasing em 5 cenários fornecidos e proponha f_s mínimo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook com NumPy/SciPy",
                                    "Datasets de sinais amostrados",
                                    "Simulador online de aliasing (ex: falstad.com)"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa frequência observada poderia vir de uma mais alta?'",
                                  "learningObjective": "Aplicar conhecimento para detectar aliasing em dados reais.",
                                  "commonMistakes": [
                                    "Assumir todos picos são reais",
                                    "Não considerar múltiplas réplicas",
                                    "Esquecer unidades (Hz vs. rad/s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de monitoramento de vibrações de uma turbina aeronáutica com f_s=200 Hz, uma vibração real de 150 Hz (acima de f_N=100 Hz) aparece como 50 Hz no espectro amostrado, levando a diagnóstico errado de desbalanceamento baixo-frequência. Identificando o alias (f_alias = 200 - 150 = 50 Hz), engenheiros aumentam f_s ou adicionam filtro.",
                              "finalVerifications": [
                                "Explique aliasing em 2 frases próprias.",
                                "Calcule f_alias para f=300 Hz, f_s=200 Hz.",
                                "Desenhe espectro com réplicas mostrando aliasing.",
                                "Identifique aliasing em gráfico fornecido.",
                                "Proponha prevenção para f_max=80 Hz.",
                                "Diferencie aliasing de ruído."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (Nyquist, folding, réplicas): 30%",
                                "Correção em cálculos de f_alias: 25%",
                                "Qualidade de diagramas espectrais: 20%",
                                "Identificação correta em exemplos: 15%",
                                "Explicações claras e concisas: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Imagens: Aliasing em digitalização de fotos aéreas.",
                                "Física de Ondas: Analogia com difração em antenas de radar.",
                                "Estatística: Análise espectral em dados de sensores IoT aeronáuticos.",
                                "Programação: Implementação de FFT em Python para análise de sinais."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, identificar aliasing em telemetria de voo (ex: acelerômetros em asas) previne falhas estruturais por diagnósticos errôneos de vibrações, otimizando design de filtros em sistemas de controle fly-by-wire."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Simular aliasing",
                            "description": "Dado um sinal senoidal com frequência f > f_s/2, calcular e representar a frequência alias f_alias = |f - k f_s| para k adequado, mostrando distorção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Aliasing e Critério de Nyquist",
                                  "subSteps": [
                                    "Revise a definição de aliasing: quando uma frequência f > f_s/2 é amostrada a f_s, aparece como f_alias < f_s/2.",
                                    "Estude o teorema de Nyquist-Shannon: f_s deve ser > 2*f_max para evitar aliasing.",
                                    "Identifique a fórmula f_alias = |f - k*f_s| onde k é o inteiro que minimiza f_alias para 0 < f_alias < f_s/2.",
                                    "Analise exemplos numéricos simples, como f=100Hz, f_s=150Hz.",
                                    "Discuta impactos da distorção em sinais reais."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e resolva um exemplo manual de cálculo de f_alias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre amostragem",
                                    "Calculadora",
                                    "Artigo sobre Nyquist"
                                  ],
                                  "tips": "Use diagramas de espectro de frequência para visualizar o folding.",
                                  "learningObjective": "Explicar o aliasing e calcular f_alias manualmente.",
                                  "commonMistakes": [
                                    "Confundir f_alias com f - f_s diretamente sem módulo absoluto",
                                    "Escolher k incorreto",
                                    "Ignorar que f_alias deve estar entre 0 e f_s/2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Simulação",
                                  "subSteps": [
                                    "Instale ou abra software como Python (com NumPy, Matplotlib) ou MATLAB.",
                                    "Defina parâmetros: f = 100 Hz (acima de f_s/2), f_s = 150 Hz, duração T=1s, N=1024 amostras.",
                                    "Gere o sinal senoidal contínuo: x(t) = sin(2*pi*f*t).",
                                    "Crie o vetor tempo contínuo e discreto.",
                                    "Planeje plots: sinal original, amostrado e alias reconstruído."
                                  ],
                                  "verification": "Execute código inicial que plota o sinal contínuo sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python/MATLAB instalado",
                                    "Bibliotecas: numpy, matplotlib ou equivalente"
                                  ],
                                  "tips": "Use t = linspace(0, T, 10000) para sinal contínuo suave.",
                                  "learningObjective": "Preparar dados e ambiente para simulação precisa.",
                                  "commonMistakes": [
                                    "Escolher f_s muito alta acidentalmente",
                                    "Número insuficiente de pontos causando aliasing visual falso",
                                    "Unidades erradas em frequência (rad/s vs Hz)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Amostragem e Cálculo de Frequência Alias",
                                  "subSteps": [
                                    "Amostre o sinal: x[n] = sin(2*pi*f*n/f_s).",
                                    "Calcule k = round(f / f_s), então f_alias = abs(f - k*f_s).",
                                    "Gere sinal alias teórico: y[n] = sin(2*pi*f_alias*n/f_s).",
                                    "Aplique filtro de reconstrução simples (ex: sinc ou plot conectando pontos).",
                                    "Compare espectros via FFT para confirmar f_alias dominante."
                                  ],
                                  "verification": "Verifique se f_alias calculado matches o pico na FFT do sinal amostrado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python/MATLAB do step anterior",
                                    "Funções FFT: np.fft ou fft()"
                                  ],
                                  "tips": "Normalize FFT para visualizar picos claramente; use abs(fft).",
                                  "learningObjective": "Simular amostragem e validar fórmula de aliasing computacionalmente.",
                                  "commonMistakes": [
                                    "Erro em k (use floor ou round baseado em f mod f_s)",
                                    "FFT sem shift causando picos errados",
                                    "Não plotar tempo discreto corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar Distorção e Analisar Resultados",
                                  "subSteps": [
                                    "Plote: sinal original, pontos amostrados, curva alias interpolada.",
                                    "Mostre espectro original vs amostrado destacando f_alias.",
                                    "Varie f ou f_s e observe mudanças em f_alias.",
                                    "Quantifique distorção: erro RMS entre sinal original baixo-pass e alias.",
                                    "Documente observações em relatório curto."
                                  ],
                                  "verification": "Gere plots mostrando distorção clara e f_alias correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Ferramenta de plotagem"
                                  ],
                                  "tips": "Use subplots para comparações lado a lado; adicione legendas e labels.",
                                  "learningObjective": "Interpretar visualmente o aliasing e sua distorção.",
                                  "commonMistakes": [
                                    "Plots sem zoom em períodos",
                                    "Confundir alias com ruído",
                                    "Não validar com múltiplos k"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: f=100Hz, f_s=150Hz → k=1, f_alias=|100-150|=50Hz. Plote sin(2*pi*100*t) contínuo, amostre a 150Hz, e mostre como parece sin(2*pi*50*t), com FFT confirmando pico em 50Hz.",
                              "finalVerifications": [
                                "Cálculo manual de f_alias coincide com simulação.",
                                "Plots mostram sinal amostrado indistinguível do alias teórico.",
                                "FFT do sinal amostrado tem pico dominante em f_alias.",
                                "Variação de parâmetros produz f_alias esperados.",
                                "Relatório explica distorção observada.",
                                "Sem erros de indexação ou overflow no código."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de f_alias (erro <1%).",
                                "Qualidade dos plots (clareza, labels, escalas corretas).",
                                "Correção da implementação de amostragem e FFT.",
                                "Análise qualitativa/quantitativa da distorção.",
                                "Completude do relatório com insights.",
                                "Eficiência do código e reprodutibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas e módulo absoluto.",
                                "Programação: Manipulação de arrays e visualização de dados.",
                                "Física: Ondas e vibrações em sistemas dinâmicos aeronáuticos.",
                                "Estatística: Análise espectral via FFT."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, simular aliasing previne erros em sensores de vibração de turbinas ou radares, garantindo que frequências altas de ruído não sejam interpretadas como sinais falsos de falha estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1",
                              "10.1.6.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Aplicar filtro anti-aliasing",
                            "description": "Descrever o uso de um filtro passa-baixa com corte em f_s/2 antes da amostragem para remover componentes acima de f_max e prevenir aliasing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Fenômeno de Aliasing e a Necessidade do Filtro Anti-Aliasing",
                                  "subSteps": [
                                    "Revise o teorema de Nyquist-Shannon: f_s > 2 f_max para evitar aliasing.",
                                    "Analise um sinal com componentes acima de f_max e simule amostragem sem filtro para observar distorção.",
                                    "Identifique que o filtro passa-baixa remove frequências acima de f_s/2 antes da amostragem.",
                                    "Estude tipos de filtros: FIR vs IIR, e características ideais para anti-aliasing.",
                                    "Calcule f_c = f_s/2 como frequência de corte padrão."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o filtro é essencial e desenhe o espectro de frequência antes/depois.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Sinais e Sistemas, simulador online como Falstad ou MATLAB/Octave básico.",
                                  "tips": "Use gráficos de espectro para visualizar o aliasing; foque em exemplos reais de vibrações em aeronaves.",
                                  "learningObjective": "Entender teoricamente o aliasing e o papel do filtro passa-baixa.",
                                  "commonMistakes": "Confundir f_s/2 com f_max; ignorar atenuação insuficiente no filtro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar os Parâmetros do Filtro Passa-Baixa",
                                  "subSteps": [
                                    "Defina f_s baseada na aplicação (ex: 1000 Hz para sinais de vibração).",
                                    "Estabeleça f_c = f_s/2 e escolha roll-off (ex: 60 dB/decade).",
                                    "Selecione ordem do filtro (ex: 4ª ordem Butterworth para bom compromisso).",
                                    "Calcule coeficientes do filtro usando fórmulas ou toolbox.",
                                    "Avalie resposta em frequência para garantir atenuação >40 dB acima de f_c."
                                  ],
                                  "verification": "Gere e plote a resposta em magnitude/fase do filtro projetado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB (filter design toolbox) ou Python (SciPy signal.butter).",
                                  "tips": "Comece com filtros Butterworth para simetria em fase; teste variações de ordem.",
                                  "learningObjective": "Selecionar e calcular parâmetros ótimos para o filtro anti-aliasing.",
                                  "commonMistakes": "Escolher f_c > f_s/2, causando aliasing; ordem muito baixa sem atenuação adequada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Aplicar o Filtro no Sinal Antes da Amostragem",
                                  "subSteps": [
                                    "Gere ou carregue um sinal contínuo com ruído de alta frequência (ex: senoide + harmônicos).",
                                    "Aplique o filtro passa-baixa ao sinal usando função filtfilt() para zero-phase.",
                                    "Amostre o sinal filtrado com taxa f_s.",
                                    "Compare espectros: sinal original, filtrado e amostrado.",
                                    "Ajuste parâmetros se aliasing residual for detectado."
                                  ],
                                  "verification": "Plote espectros lado a lado mostrando remoção de componentes acima de f_max.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python com bibliotecas signal e matplotlib; sinal de teste (.wav ou gerado).",
                                  "tips": "Use filtfilt para evitar distorção de fase em sinais de aeronáutica como vibrações.",
                                  "learningObjective": "Implementar o filtro digitalmente e integrá-lo ao pipeline de amostragem.",
                                  "commonMistakes": "Aplicar filtro após amostragem; não usar zero-phase filtering."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Otimizar a Prevenção de Aliasing",
                                  "subSteps": [
                                    "Simule cenários com diferentes f_s e ruídos variáveis.",
                                    "Meça SNR antes/depois e verifique ausência de picos espúrios no espectro amostrado.",
                                    "Otimize ordem/roll-off para trade-off computacional.",
                                    "Documente o design em relatório com gráficos.",
                                    "Teste com sinal real de sensores aeronáuticos se disponível."
                                  ],
                                  "verification": "Confirme SNR melhorado e ausência de aliasing em múltiplos testes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo software anterior; dados reais opcionais (ex: vibração de motor via Kaggle).",
                                  "tips": "Automatize testes com loops para varrer parâmetros; priorize eficiência para sistemas embarcados.",
                                  "learningObjective": "Validar eficácia e iterar no design do filtro.",
                                  "commonMistakes": "Não testar com harmônicos fortes; ignorar custo computacional em hardware real."
                                }
                              ],
                              "practicalExample": "Em um sistema de monitoramento de vibrações de asas de aeronave, aplique um filtro Butterworth de 4ª ordem com f_c=500 Hz (f_s=1000 Hz) a um sinal de acelerômetro contendo vibrações até 300 Hz + ruído de motor >600 Hz. Filtre antes de amostrar, resultando em espectro limpo sem aliases.",
                              "finalVerifications": [
                                "Espectro amostrado sem componentes acima de f_s/2.",
                                "SNR pós-filtro > 20 dB superior ao sem filtro.",
                                "Resposta do filtro atenua >40 dB em f_s/2 + margem.",
                                "Explicação correta do teorema de Nyquist aplicada.",
                                "Código executável e reproduzível fornecido.",
                                "Relatório com gráficos e conclusões."
                              ],
                              "assessmentCriteria": [
                                "Precisão no design: f_c exato e atenuação adequada (30%).",
                                "Implementação correta: zero-phase e integração (25%).",
                                "Validação quantitativa: métricas SNR/espectro (20%).",
                                "Análise de erros e otimizações (15%).",
                                "Documentação clara e exemplos aeronáuticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais em Controle Automático (estabilidade de sistemas discretos).",
                                "Eletrônica e Sensores (condicionamento de sinais em aviônicos).",
                                "Matemática Aplicada (Transformada de Fourier e Z).",
                                "Engenharia de Software (implementação em C para embedded systems)."
                              ],
                              "realWorldApplication": "Em telemetria de voo, filtros anti-aliasing previnem distorções em dados de IMU/gyroscópios, garantindo precisos controles de atitude e detecção precoce de falhas estruturais em aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Reconstruir sinal contínuo",
                            "description": "Explicar a interpolação ideal com filtro passa-baixa sinc para reconstruir x(t) a partir de x[n], relacionando com o teorema de Nyquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Amostragem e Teorema de Nyquist-Shannon",
                                  "subSteps": [
                                    "Estude o teorema de Nyquist-Shannon: frequência de amostragem deve ser pelo menos 2 vezes a frequência máxima do sinal.",
                                    "Analise o processo de amostragem: conversão de x(t) para x[n] = x(nT), onde T é o período de amostragem.",
                                    "Identifique o espectro de frequência do sinal discreto e o impacto do aliasing se fs < 2f_max.",
                                    "Discuta a necessidade de reconstrução para recuperar x(t) fielmente do domínio discreto.",
                                    "Calcule exemplos numéricos de fs mínima para sinais típicos em aeronáutica, como vibrações (até 100 Hz)."
                                  ],
                                  "verification": "Resuma em um diagrama o processo de amostragem e reconstrução, confirmando fs >= 2f_max.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim), calculadora, papel para diagramas"
                                  ],
                                  "tips": "Use analogias como fotos de um trem em movimento para explicar aliasing.",
                                  "learningObjective": "Compreender por que a reconstrução é essencial e sua relação com Nyquist.",
                                  "commonMistakes": [
                                    "Confundir frequência de Nyquist com frequência de amostragem",
                                    "Ignorar o fator 2 no teorema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Interpolação Ideal com Função Sinc",
                                  "subSteps": [
                                    "Derive a fórmula de reconstrução: x(t) = sum_{n=-∞}^∞ x[n] * sinc((t - nT)/T), onde sinc(u) = sin(πu)/(πu).",
                                    "Explique o significado físico: cada amostra x[n] contribui com um lóbulo sinc centrado em nT.",
                                    "Analise o espectro: a soma de sincs equivale a um filtro passa-baixa ideal com corte em fs/2.",
                                    "Compare com interpolação linear: destaque a distorção introduzida pela linear vs. sinc ideal.",
                                    "Plote manualmente sinc para t próximo a 0 e n=0,1 para visualização."
                                  ],
                                  "verification": "Escreva e prove a fórmula de interpolação sinc a partir da transformada de Fourier.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy), notas de aula sobre Fourier"
                                  ],
                                  "tips": "Lembre-se: sinc normalizada garante ganho unitário em DC.",
                                  "learningObjective": "Dominar a fórmula matemática e intuição da interpolação sinc.",
                                  "commonMistakes": [
                                    "Usar sinc não normalizada",
                                    "Limitar soma a n finito sem justificar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e Implementar Filtro Passa-Baixa Sinc",
                                  "subSteps": [
                                    "Defina o filtro ideal H(f) = T para |f| < fs/2, 0 caso contrário.",
                                    "Implemente numericamente: trunque a soma sinc para N amostras (ex: N=50).",
                                    "Ajuste janela (ex: Hamming) para reduzir ringing nos lóbulos laterais.",
                                    "Codifique em Python/MATLAB: função que recebe x[n], T e gera x(t) em malha fina.",
                                    "Teste com sinal senoidal: verifique se amplitude e fase são preservadas."
                                  ],
                                  "verification": "Execute código e plote x(t) reconstruído vs. original; erro MSE < 1%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib, ou MATLAB"
                                  ],
                                  "tips": "Use dt << T na malha de tempo para precisão.",
                                  "learningObjective": "Aplicar filtro sinc digitalmente para reconstrução prática.",
                                  "commonMistakes": [
                                    "Truncagem abrupta causando Gibbs phenomenon",
                                    "Escala errada em sinc"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Reconstrução e Relacionar com Prevenção de Aliasing",
                                  "subSteps": [
                                    "Simule subamostragem (fs < 2f_max) e reconstrua: observe aliasing residual.",
                                    "Compare espectros: FFT de x[n] vs. x(t) reconstruído para validar filtro LPF.",
                                    "Analise impacto em sistemas aeronáuticos: ex. sensores de aceleração.",
                                    "Discuta limitações reais: filtros não-ideais (FIR/IIR aproximando sinc).",
                                    "Otimize N e janela para trade-off computacional vs. precisão."
                                  ],
                                  "verification": "Gere relatório com plots e métricas (SNR, erro) para casos com/sem aliasing.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 3, exemplos de dados de vibração aeronáutica"
                                  ],
                                  "tips": "Meça SNR para quantificar qualidade da reconstrução.",
                                  "learningObjective": "Verificar fidelidade e ligar à prevenção de aliasing via Nyquist.",
                                  "commonMistakes": [
                                    "Não normalizar espectros para comparação",
                                    "Ignorar fase no erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de monitoramento de vibrações em hélices de aeronaves, amostre aceleração a fs=1000 Hz (f_max=400 Hz). Use interpolação sinc para reconstruir x(t) e detectar modos de vibração ressonantes, evitando aliasing que mascararia falhas estruturais.",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula de interpolação sinc a partir do teorema de Nyquist.",
                                "Implementa código que reconstrói sinal com erro MSE < 0.5%.",
                                "Explica o papel do filtro passa-baixa ideal na eliminação de aliasing.",
                                "Compara reconstrução sinc vs. zero-order hold em plots.",
                                "Identifica limitações práticas e sugere aproximações FIR."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (20%)",
                                "Qualidade da implementação numérica e plots (30%)",
                                "Explicação clara da relação com Nyquist e aliasing (25%)",
                                "Análise de erros e limitações (15%)",
                                "Aplicação contextual em aeronáutica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Processamento Digital de Sinais em Controle Automático de Voo",
                                "Análise de Vibrações em Engenharia Mecânica Aeronáutica",
                                "Comunicações em Radares e Sensores Aviação",
                                "Simulações em Dinâmica de Veículos Aéreos"
                              ],
                              "realWorldApplication": "Na aviação, reconstrução sinc é usada em telemetria de voo para processar dados de sensores inerciais, permitindo análise precisa de manobras e detecção precoce de instabilidades aerodinâmicas a partir de amostras discretas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1",
                              "10.1.6.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Transformada de Fourier Discreta (DFT)",
                    "description": "Algoritmo para análise espectral de sequências discretas finitas, base da FFT.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Definição e Fórmula da Transformada de Fourier Discreta (DFT)",
                        "description": "A DFT é uma ferramenta matemática que transforma uma sequência finita discreta x(n) de N amostras do domínio do tempo discreto para o domínio da frequência discreta, dada pela fórmula X(k) = ∑_{n=0}^{N-1} x(n) e^{-j 2π k n / N}, para k = 0, 1, ..., N-1, permitindo análise espectral de sinais discretos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Entender a fórmula da DFT e sua interpretação",
                            "description": "Explicar os componentes da fórmula da DFT, incluindo o somatório finito, o expoente complexo e o papel das frequências normalizadas k/N, relacionando com a decomposição em exponenciais complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes principais da fórmula da DFT",
                                  "subSteps": [
                                    "Escreva a fórmula padrão da DFT: X[k] = ∑_{n=0}^{N-1} x[n] · exp(-j · 2π · k · n / N).",
                                    "Identifique o somatório finito de n=0 a N-1 como a soma sobre os N amostras do sinal discreto.",
                                    "Localize o termo x[n] como a amostra de entrada no tempo discreto.",
                                    "Destaque X[k] como o coeficiente de frequência no domínio da frequência.",
                                    "Anote os elementos: k (índice de frequência), N (tamanho da sequência)."
                                  ],
                                  "verification": "Liste corretamente todos os 5 componentes principais da fórmula em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Fórmula da DFT impressa"
                                  ],
                                  "tips": "Use cores diferentes para destacar cada componente na fórmula para melhor visualização.",
                                  "learningObjective": "Reconhecer e nomear todos os elementos fundamentais da equação da DFT.",
                                  "commonMistakes": [
                                    "Confundir X[k] com x[n]",
                                    "Esquecer o sinal negativo no expoente",
                                    "Ignorar os limites do somatório (0 a N-1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o somatório finito e seu significado",
                                  "subSteps": [
                                    "Explique que o somatório ∑_{n=0}^{N-1} computa a contribuição ponderada de cada amostra x[n] para a frequência k.",
                                    "Calcule manualmente o somatório para N=2 com x[0]=1, x[1]=0, mostrando que é uma soma finita.",
                                    "Discuta como N finito diferencia a DFT da FT contínua (aproximação para sinais periódicos).",
                                    "Compare com uma média ponderada onde os pesos são os exponenciais complexos.",
                                    "Verifique com um exemplo numérico simples: DFT de [1, 1] para k=0."
                                  ],
                                  "verification": "Compute o somatório para um sinal de N=4 e explique o resultado em palavras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python (numpy) para somatórios simples",
                                    "Exemplos de sinais discretos"
                                  ],
                                  "tips": "Comece com N pequeno (2-4) para evitar cálculos tediosos e focar no conceito.",
                                  "learningObjective": "Interpretar o somatório como uma projeção finita do sinal no domínio da frequência.",
                                  "commonMistakes": [
                                    "Tratar como integral contínua",
                                    "Esquecer que n vai de 0 a N-1",
                                    "Não normalizar por N inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o expoente complexo e as frequências normalizadas k/N",
                                  "subSteps": [
                                    "Descomplique exp(-j · 2π · k · n / N) como uma rotação no plano complexo (fase -2π k n / N radianos).",
                                    "Explique k/N como frequência normalizada (k=0: DC, k=N/2: frequência Nyquist).",
                                    "Plote o fasor para k=1, N=8, n=0 a 7, mostrando o círculo unitário.",
                                    "Calcule o expoente para casos específicos: k=0 (1 real), k=N/2 (alternância).",
                                    "Relacione com cis(θ) = cos(θ) + j sin(θ) para visualização."
                                  ],
                                  "verification": "Desenhe e rotule o fasor para pelo menos 3 valores de n em um k fixo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python matplotlib)",
                                    "Papel milimetrado para fasores",
                                    "Tabela de valores trigonométricos"
                                  ],
                                  "tips": "Use animações online de fasores DFT para intuição visual.",
                                  "learningObjective": "Entender o expoente como base ortonormal para análise harmônica discreta.",
                                  "commonMistakes": [
                                    "Confundir k/N com frequência absoluta",
                                    "Ignorar o -j (direção da rotação)",
                                    "Tratar como seno simples sem parte imaginária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a DFT como decomposição em exponenciais complexas",
                                  "subSteps": [
                                    "Reconstrua o sinal: x[n] ≈ (1/N) ∑_{k=0}^{N-1} X[k] · exp(j · 2π · k · n / N) (IDFT).",
                                    "Explique que X[k] é o peso da base exponencial exp(-j · 2π · k · n / N).",
                                    "Mostre ortogonalidade: bases são ortogonais para diferentes k.",
                                    "Aplique a um sinal senoidal: DFT deve ter picos em frequências correspondentes.",
                                    "Discuta periodicidade: espectro repete a cada N."
                                  ],
                                  "verification": "Escreva a relação entre DFT e IDFT e explique com um diagrama de blocos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou MATLAB para IDFT de um exemplo",
                                    "Diagrama de decomposição espectral"
                                  ],
                                  "tips": "Pense na DFT como 'projeção' do sinal em um conjunto de vetores exponenciais.",
                                  "learningObjective": "Relacionar a fórmula à ideia de análise harmônica via bases complexas.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/N na reconstrução",
                                    "Não reconhecer ortogonalidade",
                                    "Confundir DFT com série de Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a interpretação completa da fórmula DFT",
                                  "subSteps": [
                                    "Resuma: DFT projeta x[n] em N bases exponenciais complexas via produto interno finito.",
                                    "Discuta simetrias: X[N-k] = conj(X[k]) para sinais reais.",
                                    "Compare com FT contínua: limite N→∞, Δt→0.",
                                    "Aplique a interpretação a um sinal real: ruído + seno.",
                                    "Questione: 'Por que complexos? Para capturar magnitude e fase.'"
                                  ],
                                  "verification": "Explique a fórmula para um colega em 2 minutos sem fórmulas, usando analogia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gravação de áudio para auto-explicação",
                                    "Exemplo de sinal aeronáutico (vibração discreta)"
                                  ],
                                  "tips": "Use analogia de 'orquestra': cada k é um instrumento com amplitude X[k] e fase.",
                                  "learningObjective": "Integrar todos os componentes em uma visão holística da DFT.",
                                  "commonMistakes": [
                                    "Focar só em magnitude, ignorar fase",
                                    "Não ligar à reconstrução",
                                    "Generalizar indevidamente para sinais não-periódicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sinal discreto de vibração em uma asa de aeronave: x[n] = [1, 0.5, 0, -0.5, -1, -0.5, 0, 0.5] (N=8, simulando uma oscilação). Calcule manualmente X[0] (componente DC: média=0), X[1] (frequência fundamental) e interprete: X[1] ≈ 4 exp(jφ) indica pico na frequência normalizada 1/8 com fase φ, útil para detectar ressonância estrutural.",
                              "finalVerifications": [
                                "Escreve a fórmula DFT corretamente de memória.",
                                "Explica o papel de k/N em 1 frase.",
                                "Computa DFT de N=4 manualmente.",
                                "Desenha fasores para k=1, N=4.",
                                "Relaciona DFT à reconstrução via IDFT.",
                                "Identifica pelo menos 3 diferenças da FT contínua."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escrita da fórmula (100% dos componentes).",
                                "Profundidade na explicação do expoente complexo (inclui fasores e normalização).",
                                "Capacidade de computar exemplo simples sem erros aritméticos.",
                                "Uso correto de terminologia (somatório finito, frequências normalizadas, decomposição).",
                                "Integração conceitual (projeção ortogonal em bases exponenciais).",
                                "Criatividade na analogia ou interpretação prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções exponenciais (ortogonalidade de bases).",
                                "Física: Ondas e vibrações harmônicas em estruturas aeronáuticas.",
                                "Computação: Implementação numérica via FFT para processamento eficiente.",
                                "Engenharia de Controle: Análise de espectro para estabilidade dinâmica.",
                                "Estatística: Correlação e projeções em espaços de Hilbert discretos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a DFT é usada para analisar dados de sensores de vibração em testes de fadiga de asas ou fuselagem, identificando frequências ressonantes (ex.: k/N correspondente a modos naturais) para prevenir falhas estruturais em voo, processando sinais discretos de acelerômetros em tempo real via FFT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Calcular a DFT direta para sequências curtas",
                            "description": "Realizar o cálculo manual da DFT para sequências de comprimento N=2 ou N=4, computando cada coeficiente X(k) passo a passo e interpretando o espectro resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Fórmula da DFT",
                                  "subSteps": [
                                    "Estudar a fórmula da DFT: X(k) = ∑_{n=0}^{N-1} x(n) ⋅ e^{-j 2π k n / N} para k = 0, 1, ..., N-1.",
                                    "Identificar os componentes: soma sobre n, twiddle factor W_N^{kn} = e^{-j 2π k n / N}.",
                                    "Explicar o significado: X(k) representa a componente de frequência k.",
                                    "Praticar decompondo o expoente complexo em cosseno e seno usando Euler.",
                                    "Verificar compreensão calculando W_N para N=2 manualmente."
                                  ],
                                  "verification": "Explicar a fórmula e calcular W_2^0 e W_2^1 corretamente em uma folha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fórmula da DFT impressa",
                                    "Calculadora científica com funções complexas"
                                  ],
                                  "tips": "Visualize o expoente como rotação no plano complexo; use ângulos em radianos.",
                                  "learningObjective": "Dominar a fórmula matemática da DFT e interpretar seus termos.",
                                  "commonMistakes": [
                                    "Usar expoente positivo em vez de negativo",
                                    "Confundir índices k e n",
                                    "Esquecer que a soma é de 0 a N-1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a Sequência de Entrada Curta",
                                  "subSteps": [
                                    "Escolher N=2 ou N=4; iniciar com N=2 para simplicidade.",
                                    "Definir uma sequência simples, ex: x[n] = [1, 0] para N=2.",
                                    "Listar explicitamente x(0), x(1), ..., x(N-1) em uma tabela.",
                                    "Verificar se a sequência é real ou complexa e preparar para multiplicação.",
                                    "Desenhar o sinal no tempo para visualização intuitiva."
                                  ],
                                  "verification": "Tabela completa da sequência sem erros e sinal plotado corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Comece com sequências reais e simétricas para facilitar interpretação.",
                                  "learningObjective": "Preparar dados de entrada de forma organizada para cálculo DFT.",
                                  "commonMistakes": [
                                    "Índices fora de 0 a N-1",
                                    "Confundir sequência periódica com aperiódica",
                                    "Usar valores complexos desnecessariamente no início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Cada Coeficiente X(k) Passo a Passo",
                                  "subSteps": [
                                    "Para cada k de 0 a N-1: calcular W_N^{kn} para cada n.",
                                    "Multiplicar x(n) por W_N^{kn} e somar os termos complexos.",
                                    "Exemplo para N=2, k=0: X(0) = x(0) + x(1); k=1: X(1) = x(0) - x(1).",
                                    "Registrar partes real e imaginária separadamente.",
                                    "Verificar cálculos intermediários com uma calculadora."
                                  ],
                                  "verification": "Todos X(k) calculados com precisão decimal de 4 casas e partes real/imaginária separadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora complexa ou app (ex: MATLAB mobile)",
                                    "Tabela de twiddle factors pré-calculados"
                                  ],
                                  "tips": "Calcule expoentes primeiro; use identidade para N=2/4 para simplificar.",
                                  "learningObjective": "Executar o cálculo direto da DFT manualmente com exatidão.",
                                  "commonMistakes": [
                                    "Erro em cálculo de ângulo: 2π/N radianos",
                                    "Soma incorreta de complexos (real+real, imag+imag)",
                                    "Esquecer fator j no imaginário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Espectro de Frequências Resultante",
                                  "subSteps": [
                                    "Calcular magnitude |X(k)| = sqrt(Re^2 + Im^2) e fase arg(X(k)).",
                                    "Identificar X(0) como componente DC (média).",
                                    "Plotar espectro de magnitude e discutir simetria para sinais reais.",
                                    "Comparar com sinal original: como frequências compõem o tempo.",
                                    "Discutir resolução espectral para N pequeno."
                                  ],
                                  "verification": "Gráfico de magnitude/fase plotado e interpretação escrita em 3-5 frases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico polar ou cartesiano",
                                    "Software de plot simples (ex: Desmos)"
                                  ],
                                  "tips": "Para sinais reais, |X(k)| = |X(N-k)|; foque nisso para validação.",
                                  "learningObjective": "Interpretar o espectro DFT como decomposição em frequências.",
                                  "commonMistakes": [
                                    "Ignorar conjugação para sinais reais",
                                    "Confundir magnitude com amplitude sem normalização",
                                    "Interpretar fase sem contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=2, x[n] = [1, 1]: X(0) = 2 (DC), X(1) = 0 (sem frequência Nyquist). Magnitude: [2, 0]. Interpretação: sinal constante, sem oscilação.",
                              "finalVerifications": [
                                "Todos coeficientes X(k) coincidem com cálculo verificado por software.",
                                "Magnitude e fase calculadas corretamente para todos k.",
                                "Interpretação explica relação tempo-frequência.",
                                "Simetria do espectro respeitada para sinal real.",
                                "Gráfico do espectro desenhado com legendas.",
                                "Sem erros aritméticos em qualquer passo intermediário."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos complexos (tolerância 0.01).",
                                "Documentação completa de todos sub-passos e verificações.",
                                "Interpretação física coerente do espectro.",
                                "Tempo total dentro do estimado (±20%).",
                                "Uso correto de twiddle factors e propriedades DFT.",
                                "Identificação de pelo menos 2 insights do exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e séries de Fourier.",
                                "Física: Análise harmônica de vibrações em estruturas aeronáuticas.",
                                "Programação: Implementação de DFT em Python/MATLAB para validação.",
                                "Engenharia de Controle: Detecção de frequências em sistemas dinâmicos.",
                                "Estatística: Espectral density para análise de ruído."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, calcular DFT manual para sequências curtas de sensores de vibração em hélices permite detectar desbalanceamento inicial sem software, validando dados para manutenção preditiva de aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Interpretar o espectro de frequência da DFT",
                            "description": "Analisar o módulo e fase de X(k), identificando componentes de frequência dominante, simetria para sinais reais e periodicidade da DFT no domínio da frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação do espectro de frequência da DFT",
                                  "subSteps": [
                                    "Definir X(k) como a soma de x[n] * exp(-j*2*pi*k*n/N).",
                                    "Explicar o módulo |X(k)| como amplitude da componente de frequência k.",
                                    "Descrever a fase arg(X(k)) como o deslocamento angular da componente.",
                                    "Relacionar índice k à frequência normalizada f_k = k/(N*Ts).",
                                    "Visualizar plots de magnitude e fase usando ferramentas computacionais."
                                  ],
                                  "verification": "Gerar e plotar corretamente magnitude e fase da DFT de um sinal senoidal simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "MATLAB ou Octave",
                                    "Sinal teste: x[n] = cos(2*pi*0.1*n) para n=0 a 63"
                                  ],
                                  "tips": "Use escala logarítmica para magnitude em sinais com ruído para melhor visualização.",
                                  "learningObjective": "Identificar e interpretar magnitude e fase no espectro DFT.",
                                  "commonMistakes": [
                                    "Confundir |X(k)|^2 com potência espectral",
                                    "Ignorar normalização por N",
                                    "Plotar fase sem unwrap"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes de frequência dominantes",
                                  "subSteps": [
                                    "Localizar picos no plot de magnitude |X(k)|.",
                                    "Calcular frequência correspondente: f = k * fs / N.",
                                    "Comparar amplitudes para determinar dominância.",
                                    "Filtrar ruído de fundo visualmente.",
                                    "Quantificar dominância usando threshold de amplitude."
                                  ],
                                  "verification": "Listar as 3 frequências dominantes e suas amplitudes para um sinal composto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook Jupyter",
                                    "Sinal composto: x[n] = 2*cos(2*pi*0.1*n) + cos(2*pi*0.3*n) + 0.5*randn(N)"
                                  ],
                                  "tips": "Ordene bins por magnitude decrescente para análise rápida.",
                                  "learningObjective": "Detectar e quantificar componentes espectrais principais.",
                                  "commonMistakes": [
                                    "Atribuir picos de ruído como dominantes",
                                    "Esquecer vazamento espectral em janelas retangulares",
                                    "Erro em mapeamento k para f"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar simetria para sinais reais",
                                  "subSteps": [
                                    "Verificar |X(k)| = |X(N-k)| e arg(X(k)) = -arg(X(N-k)).",
                                    "Explicar conjugação X(k) = X*(N-k).",
                                    "Plotar apenas k=0 a N/2 para espectro de sinal real.",
                                    "Identificar DC em k=0 e Nyquist em k=N/2.",
                                    "Testar propriedade em sinal real vs. complexo."
                                  ],
                                  "verification": "Confirmar simetria plotando espectro simétrico de um sinal real.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de plotagem FFT",
                                    "Sinal real: vibração senoidal",
                                    "Sinal complexo para comparação"
                                  ],
                                  "tips": "Use fftshift para centralizar o espectro zero-frequency.",
                                  "learningObjective": "Aplicar propriedades de simetria para otimizar análise.",
                                  "commonMistakes": [
                                    "Aplicar simetria a sinais complexos",
                                    "Confundir simetria de magnitude e fase",
                                    "Ignorar k=0 e k=N/2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer periodicidade e interpretação global",
                                  "subSteps": [
                                    "Entender periodicidade: X(k+N) = X(k).",
                                    "Discutir aliasing se fs insuficiente.",
                                    "Interpretar espectro completo: harmônicos, modulações.",
                                    "Relacionar de volta ao sinal temporal via IDFT parcial.",
                                    "Documentar insights: fontes de frequências observadas."
                                  ],
                                  "verification": "Explicar periodicidade demonstrando X(k+ N) == X(k) numericamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python para DFT periódica",
                                    "Sinal com múltiplos harmônicos"
                                  ],
                                  "tips": "Aumente N para melhor resolução espectral.",
                                  "learningObjective": "Interpretar periodicidade e limitações da DFT.",
                                  "commonMistakes": [
                                    "Confundir periodicidade com repetição temporal",
                                    "Ignorar efeitos de janelamento",
                                    "Sobreinterpretar resolução além de fs/N"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de vibração de hélice aeronáutica, compute DFT de acelerômetro: x[n] = 10*cos(2*pi*50*n/1000) + 5*cos(2*pi*150*n/1000) + ruído (fs=1000Hz, N=1024). Identifique picos em 50Hz e 150Hz (RPM da hélice e harmônico), confirme simetria, note periodicidade a cada 1024 bins.",
                              "finalVerifications": [
                                "Plotar e rotular corretamente magnitude/fase de DFT.",
                                "Identificar todas frequências dominantes com erro <1%.",
                                "Demonstrar simetria para sinal real.",
                                "Explicar impacto de periodicidade em análise.",
                                "Reconstruir sinal aproximado via picos dominantes.",
                                "Discutir limitações como vazamento espectral."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de picos (amplitude e frequência).",
                                "Correta aplicação de simetria e periodicidade.",
                                "Qualidade dos plots (rótulos, escalas adequadas).",
                                "Interpretação física coerente com contexto.",
                                "Tratamento de ruído e artefatos.",
                                "Eficiência computacional no código."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações mecânicas.",
                                "Processamento de Sinais: Aplicações em filtros digitais.",
                                "Engenharia de Controle: Diagramas de Bode via DFT.",
                                "Processamento de Imagens: FFT 2D para análise espectral.",
                                "Estatística: Detecção de sinais em ruído."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, interpretar espectros DFT de sensores de vibração em turbinas ou estruturas de aeronaves para detectar desbalanceamento de hélices (frequências múltiplas de RPM), falhas em rolamentos (harmônicos altos) ou flutter aerodinâmico, permitindo manutenção preditiva e segurança de voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Propriedades da Transformada de Fourier Discreta (DFT)",
                        "description": "Propriedades fundamentais da DFT, como linearidade, simetria (para sinais reais, X(N-k) = conj(X(k))), periodicidade com período N, shift circular e multiplicação por exponenciais, que facilitam simplificações em cálculos e análises.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Aplicar a propriedade de linearidade da DFT",
                            "description": "Demonstrar que DFT{ a x(n) + b y(n) } = a X(k) + b Y(k), verificando com exemplos numéricos e explicando sua utilidade em superposição de sinais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição da DFT e o conceito de linearidade",
                                  "subSteps": [
                                    "Defina a Transformada de Fourier Discreta (DFT) como X(k) = ∑_{n=0}^{N-1} x(n) e^{-j 2π k n / N} para k=0 a N-1.",
                                    "Explique linearidade: uma transformada T é linear se T{a x + b y} = a T{x} + b T{y}, onde a e b são escalares.",
                                    "Identifique por que propriedades lineares são fundamentais em análise de sinais.",
                                    "Esboce sequências de exemplo x(n) e y(n) simples, como impulsos ou senoides discretos.",
                                    "Calcule manualmente DFT de x(n) e y(n) para sequências curtas (N=4)."
                                  ],
                                  "verification": "Liste corretamente a fórmula da DFT e demonstre linearidade com um exemplo trivial (a=1, b=0).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora científica",
                                    "Referência: Livro de Oppenheim 'Sinais e Sistemas' capítulo DFT"
                                  ],
                                  "tips": "Comece com N pequeno (4 pontos) para evitar cálculos tediosos; use tabelas para organizar somas complexas.",
                                  "learningObjective": "Compreender a base matemática da DFT para preparar a derivação da linearidade.",
                                  "commonMistakes": [
                                    "Confundir DFT com DTFT (contínua)",
                                    "Esquecer o expoente negativo na fórmula da DFT",
                                    "Ignorar normalização por N em algumas definições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar matematicamente a propriedade de linearidade da DFT",
                                  "subSteps": [
                                    "Parta da definição: DFT{a x(n) + b y(n)} = ∑ [a x(n) + b y(n)] e^{-j 2π k n / N}.",
                                    "Distribua a soma: a ∑ x(n) e^{-j 2π k n / N} + b ∑ y(n) e^{-j 2π k n / N}.",
                                    "Reconheça que isso é a DFT{x} * a + DFT{y} * b, provando linearidade.",
                                    "Discuta generalidade: válida para qualquer N finito e escalares complexos.",
                                    "Anote a prova em um quadro ou documento para referência futura."
                                  ],
                                  "verification": "Escreva a derivação passo a passo sem erros e identifique onde a distributividade da soma é usada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou software como LaTeX/Overleaf para equações",
                                    "Notas do Step 1"
                                  ],
                                  "tips": "Use cores diferentes para termos de a x(n) e b y(n) na soma para visualizar a separação.",
                                  "learningObjective": "Dominar a prova analítica da linearidade da DFT.",
                                  "commonMistakes": [
                                    "Não distribuir corretamente a soma exponencial",
                                    "Assumir linearidade sem prova",
                                    "Confundir com propriedade de convolução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar numericamente com exemplos concretos",
                                  "subSteps": [
                                    "Escolha x(n) = [1, 0, 0, 0] e y(n) = [0, 1, 0, 0] para N=4.",
                                    "Calcule DFT{x}, DFT{y}, então DFT{2x + 3y} e verifique se = 2 DFT{x} + 3 DFT{y}.",
                                    "Use Python/MATLAB com numpy.fft.fft para automatizar e comparar.",
                                    "Teste com senoides: x(n) = cos(2π n /8), y(n) = sin(2π n /8), aplique a=1, b=1.",
                                    "Plote espectros para visualização qualitativa da superposição."
                                  ],
                                  "verification": "Mostre tabelas numéricas onde DFT linear combina com precisão de 1e-10 ou melhor.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "Ou MATLAB/Octave",
                                    "Sequências de teste pré-definidas"
                                  ],
                                  "tips": "Sempre normalize erros como |computed - expected| / |expected|; use N=8 para mais realismo.",
                                  "learningObjective": "Validar teoricamente através de computação numérica.",
                                  "commonMistakes": [
                                    "Erro de indexação em arrays (0 vs 1-based)",
                                    "Não usar fftshift para plotar espectro centrado",
                                    "Ignorar parte imaginária em comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar utilidade em superposição de sinais e aplicações",
                                  "subSteps": [
                                    "Descreva superposição: sinais reais são soma de componentes (ruído + sinal útil).",
                                    "Explique: analise DFT total = soma ponderada de DFTs individuais, facilitando decomposição.",
                                    "Aplique em aero: vibrações de asas como superposição de modos modais.",
                                    "Discuta eficiência computacional em FFT para grandes N.",
                                    "Crie um relatório resumindo prova, exemplo e aplicação."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como linearidade permite análise de sinal composto sem calcular DFT total.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de Step 3",
                                    "Artigos sobre análise vibracional em aeronáutica"
                                  ],
                                  "tips": "Relacione com princípio de superposição em equações diferenciais para reforço conceitual.",
                                  "learningObjective": "Conectar propriedade teórica a cenários práticos em engenharia.",
                                  "commonMistakes": [
                                    "Limitar a sinais simples, ignorar não-linearidades reais",
                                    "Não mencionar impacto computacional da FFT"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vibrações em uma asa de aeronave: sinal x(n) de flutter modal e y(n) de turbulência. Calcule DFT{0.7 x(n) + 1.2 y(n)} = 0.7 DFT{x} + 1.2 DFT{y} usando dados N=1024 amostrados a 1kHz, identificando picos de frequência sem recomputar soma total.",
                              "finalVerifications": [
                                "Derivação matemática completa sem erros.",
                                "Exemplo numérico com erro <1e-10.",
                                "Plot de espectros mostrando superposição exata.",
                                "Explicação verbal da utilidade em 1 minuto.",
                                "Identificação de 2 aplicações em engenharia aeronáutica.",
                                "Código Python reproduzível para verificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão da prova matemática (30%)",
                                "Correção numérica e visualização (25%)",
                                "Profundidade da explicação de utilidade (20%)",
                                "Clareza de plots e tabelas (15%)",
                                "Conexões com aplicações reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (espaços vetoriais e transformadas).",
                                "Programação: Implementação de FFT em Python/MATLAB.",
                                "Física: Princípio de superposição em ondas e vibrações.",
                                "Engenharia Mecânica: Análise modal de estruturas aeronáuticas.",
                                "Processamento de Sinais: Filtros lineares e decomposição espectral."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, permite decompor vibrações de aeronaves em componentes (ex.: motor + aerodinâmica) via DFT superposta, otimizando detecção de falhas em testes de solo ou voo, reduzindo tempo de análise em sistemas de monitoramento estrutural como SHM (Structural Health Monitoring)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Utilizar simetria e periodicidade da DFT",
                            "description": "Explorar a simetria conjugada para sinais reais e a periodicidade X(k + N) = X(k), reduzindo cálculos e interpretando o espectro único em [0, N/2].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Periodicidade da DFT",
                                  "subSteps": [
                                    "Revise a definição matemática da DFT: X(k) = ∑_{n=0}^{N-1} x(n) e^{-j2πkn/N} para k=0 a N-1.",
                                    "Demonstre que X(k + N) = X(k) derivando a igualdade passo a passo.",
                                    "Plote o espectro de um sinal simples (ex: senoide) para N=8 e observe a repetição a cada N pontos.",
                                    "Explique como isso implica que apenas um período [0, N-1] é único.",
                                    "Calcule manualmente DFT de um sinal de comprimento 4 e estenda para k=4,5 mostrando igualdade."
                                  ],
                                  "verification": "Você pode derivar e provar X(k+N)=X(k) e plotar um espectro periódico corretamente.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de plotagem como MATLAB ou Python (matplotlib)"
                                  ],
                                  "tips": "Use ângulos em radianos e reduza expoentes mod 2π para simplificar cálculos.",
                                  "learningObjective": "Dominar a propriedade de periodicidade da DFT e sua implicação na representação única do espectro.",
                                  "commonMistakes": [
                                    "Confundir periodicidade no domínio do tempo com o da frequência",
                                    "Esquecer o fator e^{-j2π} na derivação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Simetria Conjugada para Sinais Reais",
                                  "subSteps": [
                                    "Lembre que para x(n) real, X(k) = X*(N-k) onde * denota conjugado complexo.",
                                    "Derive essa simetria a partir da definição da DFT, separando partes real e imaginária.",
                                    "Calcule DFT manualmente de um sinal real simples (ex: impulso) e verifique X(k) = conj(X(N-k)).",
                                    "Plote magnitude e fase para k=0 a N-1 e destaque simetria em |X(k)| = |X(N-k)| e fase anti-simétrica.",
                                    "Discuta implicações: metade do espectro é redundante para sinais reais."
                                  ],
                                  "verification": "Você consegue provar a simetria e verificar em um exemplo numérico com precisão.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Calculadora complexa ou Python (numpy.fft)",
                                    "Folha de exercícios com sinais reais"
                                  ],
                                  "tips": "Sempre verifique se Im{X(k)} = -Im{X(N-k)} e Re{X(k)} = Re{X(N-k)}.",
                                  "learningObjective": "Entender e provar a simetria conjugada da DFT para sinais reais.",
                                  "commonMistakes": [
                                    "Aplicar simetria a sinais complexos",
                                    "Confundir N-k com k-N modular"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Simetria e Periodicidade para Reduzir Cálculos",
                                  "subSteps": [
                                    "Identifique como simetria permite computar apenas k=0 a floor(N/2), dobrando eficiência.",
                                    "Implemente uma função em Python/MATLAB que calcula DFT só para [0, N/2] usando simetria.",
                                    "Compare tempo de computação de DFT full vs reduzida para N=1024.",
                                    "Aplique periodicidade para lidar com espectros maiores que N, truncando a N pontos.",
                                    "Teste com sinal real de vibração (ex: seno + ruído) e valide resultados."
                                  ],
                                  "verification": "Sua implementação reduzida produz o mesmo espectro full com metade dos cálculos.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Python com numpy.fft e timeit",
                                    "MATLAB ou Octave"
                                  ],
                                  "tips": "Use np.conj para simetria e evite loops desnecessários.",
                                  "learningObjective": "Implementar redução computacional usando propriedades da DFT.",
                                  "commonMistakes": [
                                    "Não lidar com N par/ímpar corretamente em N/2",
                                    "Ignorar DC e Nyquist em simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Espectro Único em [0, N/2]",
                                  "subSteps": [
                                    "Defina o espectro único: k=0 (DC), k=1 a floor((N-1)/2) (frequências positivas), k=N/2 se N par (Nyquist).",
                                    "Analise um sinal real: magnitude simétrica, fase anti-simétrica → foque em [0, N/2].",
                                    "Interprete picos: ex: pico em k=2 significa frequência 2/N do sampling.",
                                    "Gere relatório de espectro reduzido para um sinal de teste.",
                                    "Compare interpretação full vs reduzida, destacando economia."
                                  ],
                                  "verification": "Você pode gerar e interpretar corretamente o espectro único de um sinal dado.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Exemplos de sinais (numpy gerar)",
                                    "Ferramenta de plotagem espectral"
                                  ],
                                  "tips": "Normalize frequência por fs/N para unidades físicas.",
                                  "learningObjective": "Interpretar eficientemente o espectro DFT usando simetria e periodicidade.",
                                  "commonMistakes": [
                                    "Interpretar frequências negativas sem simetria",
                                    "Esquecer fator de escala na magnitude"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma hélice aeronáutica, amostre aceleração em N=1024 pontos (fs=1000Hz). Calcule DFT reduzida usando simetria (apenas [0,512]), identifique pico em k=50 (f=48.8Hz, harmônica de rotação), ignorando redundâncias periódicas e simétricas para processamento rápido em flight data recorder.",
                              "finalVerifications": [
                                "Provar X(k+N)=X(k) e X(k)=X*(N-k) para sinal real arbitrário.",
                                "Implementar DFT reduzida que matches full spectrum.",
                                "Interpretar corretamente 3 frequências dominantes em espectro [0,N/2].",
                                "Reduzir tempo de cálculo em >40% para N>512.",
                                "Aplicar a sinal real de vibração e relatar insights.",
                                "Explicar economia computacional em contexto de FFT."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (100% correto).",
                                "Correção da implementação reduzida (erro <1e-10).",
                                "Qualidade de plots e interpretações (clareza e labels).",
                                "Eficiência demonstrada (tempo reduzido mensurável).",
                                "Relatório completo com exemplos e verificações.",
                                "Compreensão verbal de propriedades em quiz."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grupos cíclicos e funções periódicas.",
                                "Programação: Otimização de algoritmos (pré-FFT).",
                                "Física: Análise harmônica de vibrações mecânicas.",
                                "Engenharia de Computação: Processamento de sinal eficiente."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, otimiza análise em tempo real de sinais de telemetria (vibrações, radar Doppler), reduzindo carga computacional em sistemas embarcados como black boxes ou controle de flight, permitindo detecção rápida de falhas em hélices ou estruturas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Aplicar propriedades de shift circular e convolução",
                            "description": "Verificar que um shift circular no tempo multiplica por exponenciais na frequência e que a convolução circular corresponde a multiplicação no domínio da frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Shift Circular no Domínio do Tempo",
                                  "subSteps": [
                                    "Defina shift circular como uma rotação periódica de uma sequência discreta finita de comprimento N.",
                                    "Ilustre com um exemplo: para x[n] = [1, 2, 3, 0] e shift de 1 posição, resulta em [0, 1, 2, 3].",
                                    "Compare com shift linear, destacando que o circular 'enrola' os elementos perdidos para o início.",
                                    "Represente matematicamente: y[n] = x[(n - n₀) mod N].",
                                    "Visualize graficamente como uma sequência em um círculo."
                                  ],
                                  "verification": "Reproduza manualmente o shift circular de uma sequência de 4 elementos dada, confirmando periodicidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Tabela de exemplos de sequências"
                                  ],
                                  "tips": "Sempre reduza o índice módulo N para simular o 'loop' circular.",
                                  "learningObjective": "Explicar e calcular shifts circulares em sequências discretas.",
                                  "commonMistakes": [
                                    "Confundir com shift linear (perda de elementos)",
                                    "Esquecer o módulo N",
                                    "Índices negativos sem wrap-around"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Propriedade do Shift Circular na DFT",
                                  "subSteps": [
                                    "Lembre a fórmula da DFT: X[k] = ∑ x[n] e^{-j2πkn/N}.",
                                    "Derive ou memorize que DFT{y[n]} = X[k] ⋅ e^{-j2πk n₀ / N}, onde y[n] é shift circular de x[n].",
                                    "Compute DFT de uma sequência original e seu shift circular manualmente para N=4.",
                                    "Verifique numericamente: multiplique X[k] pela exponencial e compare com DFT direta do shift.",
                                    "Analise o efeito: magnitude preservada, fase alterada linearmente."
                                  ],
                                  "verification": "Calcule DFT antes e depois de um shift de 1 posição em [1,0,0,0]; confirme multiplicação por exponenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de raízes da unidade (W_N)",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Use ângulos em radianos e pré-calcule e^{-j2πk/N} para facilitar.",
                                  "learningObjective": "Demonstrar que shift circular no tempo multiplica o espectro por exponenciais complexas.",
                                  "commonMistakes": [
                                    "Erro no sinal do expoente (use -j para shift à direita)",
                                    "Ignorar normalização da DFT",
                                    "Confundir domínio tempo/frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a Convolução Circular no Domínio do Tempo",
                                  "subSteps": [
                                    "Defina convolução circular: y[n] = ∑_{m=0}^{N-1} x[m] h[(n - m) mod N].",
                                    "Exemplo: convolução de [1,0,0,0] com [1,1,0,0] resulta em soma circular.",
                                    "Compare com convolução linear, notando zero-padding vs. periodicidade.",
                                    "Compute manualmente para sequências curtas (N=4).",
                                    "Interprete como filtragem circular em sinais periódicos."
                                  ],
                                  "verification": "Calcule convolução circular de duas sequências de 4 elementos e valide somando linhas de uma matriz circular.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Matriz Toeplitz para visualização",
                                    "Calculadora"
                                  ],
                                  "tips": "Use uma tabela circular para somar produtos sem erros de índice.",
                                  "learningObjective": "Calcular e interpretar convolução circular em sequências discretas.",
                                  "commonMistakes": [
                                    "Usar soma linear em vez de modular",
                                    "Índices fora de 0 a N-1",
                                    "Confundir ordem dos operandos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Propriedade da Convolução Circular na DFT",
                                  "subSteps": [
                                    "Lembre que DFT{y[n]} = X[k] ⋅ H[k], onde y é convolução circular de x e h.",
                                    "Compute DFTs de x e h, multiplique ponto a ponto, inverta DFT e compare com convolução direta.",
                                    "Exemplo prático: filtre um sinal com resposta impulsiva via multiplicação espectral.",
                                    "Verifique simetria: multiplicação na frequência equivale a convolução circular no tempo.",
                                    "Discuta eficiência: FFT para convolução rápida (overlap-add implícito)."
                                  ],
                                  "verification": "Para x=[1,2,3,0] e h=[1,0,0,1], compute convolução direta vs. via DFT; resultados iguais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software DFT/FFT (Python/NumPy ou MATLAB)",
                                    "Tabela de DFT para N=4"
                                  ],
                                  "tips": "Normalize DFT/ IDFT por 1/N na inversa para precisão numérica.",
                                  "learningObjective": "Verificar que convolução circular no tempo é multiplicação na frequência via DFT.",
                                  "commonMistakes": [
                                    "Esquecer IDFT após multiplicação",
                                    "Erro de escala na IDFT",
                                    "Não usar circular (padding incorreto)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de hélices aeronáuticas, considere sinal discreto de 4 amostras [1, 0.5, 0.2, 0]. Aplique shift circular de 1 (simulando delay de fase) e verifique na DFT que o espectro é multiplicado por e^{-j2πk/N}. Para filtragem de ruído, convolvua circularmente com filtro passa-baixa [0.25, 0.5, 0.25, 0] e confirme equivalência à multiplicação das DFTs.",
                              "finalVerifications": [
                                "Calcule corretamente DFT de shift circular e valide multiplicação por exponenciais.",
                                "Execute convolução circular manual e via domínio da frequência sem discrepâncias.",
                                "Explique verbalmente as propriedades em termos de magnitude e fase.",
                                "Implemente em código (Python/MATLAB) e plote espectros antes/depois.",
                                "Resolva problema inverso: dado espectro modificado, identifique shift ou filtro.",
                                "Aplique a propriedades em sinal periódico de vibração (N=8)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de DFT e operações circulares (erro <1%).",
                                "Compreensão conceitual: explique dualidade tempo-frequência corretamente.",
                                "Eficiência: use propriedades para evitar computação direta longa.",
                                "Aplicação prática: adapte a exemplo real em aeronáutica.",
                                "Identificação de erros: detecte e corrija common mistakes em exemplos.",
                                "Criatividade: proponha extensão para sinais reais (e.g., FFT em vibrações)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes circulares) e análise complexa.",
                                "Programação: Implementação de DFT/FFT em Python/NumPy ou MATLAB.",
                                "Física: Sinais vibracionais e ondas em sistemas dinâmicos aeronáuticos.",
                                "Engenharia de Controle: Filtragem e processamento em laços de feedback.",
                                "Processamento de Imagens: Extensão 2D para análise de imagens de sensores."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, essas propriedades aceleram o processamento de sinais de sensores (vibrações, radar Doppler) usando FFT para filtragem rápida de ruído em sistemas de controle de voo, detecção de falhas em hélices e correção de fase em comunicações via satélite, reduzindo latência computacional em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Computação da DFT e Relação com a FFT",
                        "description": "A DFT possui complexidade O(N²), tornando-a ineficiente para N grande; serve de base para o Algoritmo de Transformada Rápida de Fourier (FFT), que reduz a complexidade para O(N log N) via decomposição em DFTs menores, essencial para análise espectral prática.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Analisar a complexidade computacional da DFT direta",
                            "description": "Calcular o número de operações (multiplicações e somas) necessárias para DFT de tamanho N, demonstrando o crescimento quadrático e limitações para N grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Matemática da DFT",
                                  "subSteps": [
                                    "Estude a fórmula da DFT: X[k] = ∑_{n=0}^{N-1} x[n] ⋅ exp(-j ⋅ 2π ⋅ k ⋅ n / N) para k = 0 a N-1.",
                                    "Identifique os componentes computacionais: soma acumulada, multiplicação por fator twiddle (exp(...)) e indexação.",
                                    "Represente o twiddle factor como W_N^{kn} = exp(-j ⋅ 2π ⋅ k ⋅ n / N).",
                                    "Discuta representações complexas: real e imaginário para multiplicações e somas.",
                                    "Anote o número de termos na soma: exatamente N termos por cada saída X[k]."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula da DFT e liste os 3 principais componentes computacionais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre Transformada de Fourier Discreta",
                                    "Calculadora científica ou software como MATLAB/Python para exp complexa",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Visualize o twiddle factor como uma rotação no plano complexo para melhor compreensão.",
                                  "learningObjective": "Compreender os elementos matemáticos fundamentais da DFT que impactam a contagem de operações.",
                                  "commonMistakes": [
                                    "Confundir DFT com DTFT (contínua)",
                                    "Ignorar que exp é computacionalmente custoso",
                                    "Esquecer que há N saídas X[k]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Algoritmo Direto em Pseudocódigo",
                                  "subSteps": [
                                    "Escreva pseudocódigo com loops duplos: para k=0 até N-1, inicialize X[k]=0; para n=0 até N-1, X[k] += x[n] * W^{k*n}.",
                                    "Especifique o cálculo do twiddle: W = exp(-j * 2*pi * k * n / N), usando funções complexas.",
                                    "Inclua inicialização de vetores x e X como complexos.",
                                    "Teste com N=2: execute manualmente e verifique saídas.",
                                    "Otimize ligeiramente: pré-calcule W se possível, mas mantenha a forma direta."
                                  ],
                                  "verification": "Implemente e execute o pseudocódigo para N=4, confirmando saídas corretas com uma DFT conhecida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto ou IDE como Jupyter Notebook",
                                    "Biblioteca NumPy (Python) para testes",
                                    "Exemplos de sinais simples (senoide discreta)"
                                  ],
                                  "tips": "Use funções prontas para exp complexa inicialmente para focar na estrutura de loops.",
                                  "learningObjective": "Representar a computação direta da DFT para identificar padrões de operações repetidas.",
                                  "commonMistakes": [
                                    "Índices fora de limite nos loops",
                                    "Não inicializar X[k] a zero",
                                    "Confundir ordem dos loops (k externo ou n)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar Operações Computacionais (Multiplicações e Somas)",
                                  "subSteps": [
                                    "Para cada iteração interna (n-loop): 1 multiplicação complexa (x[n] * W) e 1 soma complexa (X[k] += ...).",
                                    "Multiplicação complexa: 4 mults reais + 2 somas reais; Soma complexa: 2 somas reais.",
                                    "Conte total: N loops k * N loops n = N² iterações; por iteração: ~6 mults + 4 somas reais.",
                                    "Some operações totais: aproximadamente 4N² multiplicações reais e 2N² adições reais.",
                                    "Ignore pré-computações menores para foco em dominante."
                                  ],
                                  "verification": "Calcule e tabule número exato de mults e somas para N=4, N=8 e N=16.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado para contagem",
                                    "Pseudocódigo do Step 2"
                                  ],
                                  "tips": "Conte operações reais vs complexas separadamente para precisão.",
                                  "learningObjective": "Quantificar precisamente o custo computacional da DFT direta.",
                                  "commonMistakes": [
                                    "Contar apenas operações complexas sem expandir para reais",
                                    "Esquecer somas na acumulação",
                                    "Incluir operações de indexação como dominantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade Assintótica e Limitações",
                                  "subSteps": [
                                    "Derive notação Big O: O(N²) devido aos loops duplos.",
                                    "Plote gráfico de operações vs N (ex: N de 1 a 1000) mostrando crescimento quadrático.",
                                    "Calcule tempo para N=1024 (1M ops) vs N=1M (1T ops) assumindo 1GHz CPU.",
                                    "Discuta limitações: inviável para N>10^4 em tempo real; motiva FFT O(N log N).",
                                    "Compare com requisitos de processamento de sinais em aeronáutica."
                                  ],
                                  "verification": "Gere gráfico de ops(N) e explique por que DFT direta falha para N grande.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (Matplotlib/Python ou Excel)",
                                    "Dados de benchmarks de CPU"
                                  ],
                                  "tips": "Use log-log plot para visualizar quadraticidade claramente.",
                                  "learningObjective": "Interpretar implicações práticas da complexidade O(N²) para aplicações reais.",
                                  "commonMistakes": [
                                    "Confundir O(N²) com linear",
                                    "Ignorar overhead de twiddles pré-calculados",
                                    "Subestimar tempo real em hardware limitado"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sinal discreto de vibração de asa de aeronave com N=8 amostras. Implemente DFT direta em Python: conte 4*64=256 mults reais e 128 somas reais. Execute e compare tempo com N=64, observando explosão quadrática.",
                              "finalVerifications": [
                                "Calcular corretamente número de operações para N arbitrário (ex: N=16: 1024 mults complexas).",
                                "Explicar e demonstrar O(N²) com gráfico ou tabela.",
                                "Identificar limitações para N=1024 (milhões de ops) em sistemas embarcados.",
                                "Comparar qualitativamente com FFT para motivação.",
                                "Aplicar contagem a um sinal real simples e verificar.",
                                "Discutir impacto em processamento de sinais dinâmicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações reais/complexas (erro <5%).",
                                "Correta derivação de complexidade assintótica O(N²).",
                                "Qualidade do gráfico análise vs N, com interpretação.",
                                "Identificação clara de limitações práticas e motivação para FFT.",
                                "Implementação funcional de pseudocódigo/teste.",
                                "Conexão com contexto de sinais em engenharia aeronáutica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação Big O e análise assintótica de algoritmos.",
                                "Programação: Otimização de loops e contagem de FLOPs em código.",
                                "Física: Processamento de sinais vibracionais em estruturas aeronáuticas.",
                                "Engenharia de Computação: Complexidade em hardware embarcado limitado."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, análise de sinais de sensores (vibrações, telemetria) usa DFT para frequência; complexidade quadrática da DFT direta limita a N pequeno em voo real-time, justificando FFT para monitoramento de fadiga estrutural em aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Compreender os princípios da FFT como aceleração da DFT",
                            "description": "Explicar a decomposição da DFT em produtos de DFTs menores (ex: algoritmo Cooley-Tukey para N potência de 2), ilustrando com diagrama de fluxo de sinal para N=4 ou N=8.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e computação direta da DFT",
                                  "subSteps": [
                                    "Estude a fórmula da DFT: X[k] = sum_{n=0}^{N-1} x[n] * exp(-j*2*pi*k*n/N).",
                                    "Calcule manualmente a DFT direta para um sinal de N=2 pontos (ex: x=[1,1]).",
                                    "Identifique a complexidade computacional O(N^2) contando multiplicações e somas.",
                                    "Compare com DFT para N=4 para visualizar o crescimento quadrático.",
                                    "Anote o número exato de operações complexas necessárias."
                                  ],
                                  "verification": "Conseguir calcular corretamente a DFT para N=2 e N=4 e listar o número de operações (ex: 8 para N=2, 16 para N=4).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Referência: Livro de Oppenheim sobre Sinais e Sistemas"
                                  ],
                                  "tips": "Use twiddle factors (W_N^{kn}) explicitamente para clareza; desenhe tabelas de cálculo.",
                                  "learningObjective": "Compreender a base computacional ineficiente da DFT direta.",
                                  "commonMistakes": [
                                    "Confundir índices k e n",
                                    "Esquecer o fator -j na exponencial",
                                    "Subestimar somas vs multiplicações complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o princípio de decomposição divide-and-conquer da FFT",
                                  "subSteps": [
                                    "Explique o conceito de dividir a DFT de N pontos em duas DFTs de N/2 pontos quando N é par.",
                                    "Derive a equação para even e odd índices: X[k] = DFT_even[k] + W_N^k * DFT_odd[k].",
                                    "Aplique para N=2: mostre que DFT(N=2) = DFT(1) + W*DFT(1), ilustrando recursão.",
                                    "Discuta pré-computação de twiddle factors para eficiência.",
                                    "Verifique com exemplo numérico simples para N=2."
                                  ],
                                  "verification": "Derivar e verificar a decomposição para N=2 com cálculo manual correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software Python com NumPy para verificação rápida"
                                  ],
                                  "tips": "Pense na FFT como uma árvore binária de divisões; foque em simetrias dos twiddle factors.",
                                  "learningObjective": "Dominar o núcleo recursivo do algoritmo Cooley-Tukey.",
                                  "commonMistakes": [
                                    "Ignorar o fator W_N^k para índices ímpares",
                                    "Confundir DFT par/ímpar com índices de entrada",
                                    "Não normalizar twiddles (W_N^0=1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo Cooley-Tukey para N=4 com diagrama",
                                  "subSteps": [
                                    "Divida DFT(N=4) em duas DFTs(N=2): even [x0,x2], odd [x1,x3].",
                                    "Calcule as duas DFTs de N=2 usando o step anterior.",
                                    "Aplique twiddles: para k=0,1: X[k]=even[k]+W_4^k*odd[k]; para k=2,3: ajuste com W_4^{k}.",
                                    "Desenhe o diagrama de fluxo de sinal (butterfly) mostrando entradas, twiddles e saídas.",
                                    "Valide com um sinal exemplo: x=[1,0,0,0] e compare com DFT direta."
                                  ],
                                  "verification": "Desenhar diagrama correto para N=4 e calcular saída matching DFT direta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel quadriculado para diagrama",
                                    "Ferramenta online como FFT explorer ou MATLAB"
                                  ],
                                  "tips": "Use setas para fluxo de sinal e labels para twiddles (W4^0=1, W4^1=-j); cor-code butterflies.",
                                  "learningObjective": "Visualizar e computar FFT para N=4, reduzindo de 16 para 4 operações principais.",
                                  "commonMistakes": [
                                    "Erro no twiddle para k=1 (W4^1=-j)",
                                    "Não bit-reversar entradas (radix-2 decimation-in-time)",
                                    "Confundir ordem de saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para N=8 e analisar aceleração computacional",
                                  "subSteps": [
                                    "Estenda recursivamente: DFT(8) -> duas DFT(4) -> quatro DFT(2).",
                                    "Desenhe diagrama completo de fluxo para N=8 mostrando 3 estágios de butterflies.",
                                    "Conte operações: N=8 direta=64, FFT=24 (3N log2 N).",
                                    "Compare tempos: discuta por que FFT é O(N log N).",
                                    "Implemente em código simples (Python) para validar."
                                  ],
                                  "verification": "Diagrama para N=8 correto e fórmula de complexidade explicada com números.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/NumPy ou Octave",
                                    "Papel para diagrama expandido"
                                  ],
                                  "tips": "Use bit-reversal para ordenação de entrada; foque em reutilização de twiddles simétricos.",
                                  "learningObjective": "Compreender a aceleração geral e preparar para implementações maiores.",
                                  "commonMistakes": [
                                    "Perder estágios no diagrama (log2 N=3 para N=8)",
                                    "Calcular complexidade errada (não  N log2 N multiplications)",
                                    "Ignorar overhead de recursão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sinal discreto de vibração de uma hélice (N=4: [1.0, 0.5, -0.5, -1.0]). Calcule DFT direta (16 ops), depois FFT via Cooley-Tukey (4 ops principais), desenhando o butterfly diagram e verificando espectro idêntico para análise de harmônicos em aeronáutica.",
                              "finalVerifications": [
                                "Desenhar diagramas de fluxo precisos para N=4 e N=8.",
                                "Calcular manualmente FFT para N=4 e matching com DFT direta.",
                                "Explicar decomposição recursiva verbalmente.",
                                "Listar contagem de operações: O(N^2) vs O(N log N).",
                                "Implementar FFT simples em código e comparar tempos.",
                                "Identificar twiddle factors chave para N=4/8."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e cálculos (90% correto).",
                                "Clareza e completude dos diagramas de fluxo.",
                                "Compreensão demonstrada na explicação da aceleração.",
                                "Correção na contagem de complexidade computacional.",
                                "Aplicação correta de twiddle factors em exemplos.",
                                "Capacidade de generalizar para potências de 2 maiores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios cíclicos e raízes de unidade.",
                                "Computação: Algoritmos recursivos e divide-and-conquer (ex: merge sort).",
                                "Física: Análise espectral em vibrações e ondas acústicas.",
                                "Engenharia de Software: Otimização de DSP em embedded systems."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, FFT acelera o processamento em tempo real de sinais de radar Doppler para detecção de turbulência ou análise de vibrações estruturais em asas, reduzindo latência em sistemas de controle de voo autônomo de O(N^2) para O(N log N)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Aplicar DFT/FFT em análise espectral de sequências discretas",
                            "description": "Usar DFT ou FFT para analisar o espectro de um sinal discreto finito (ex: sinal senoidal com ruído), identificando frequências e aplicando em contextos como sistemas dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sequência discreta para análise espectral",
                                  "subSteps": [
                                    "Definir parâmetros do sinal: frequência fundamental (ex: 100 Hz), taxa de amostragem fs (ex: 1000 Hz), número de pontos N (potência de 2, ex: 1024).",
                                    "Gerar sinal senoidal puro: x[n] = sin(2π f t[n]), onde t[n] = n/fs.",
                                    "Adicionar ruído branco gaussiano: x_ruido[n] = x[n] + σ * randn(N), com σ adequado.",
                                    "Visualizar sinal no domínio do tempo usando plotagem.",
                                    "Aplicar janelamento (ex: Hamming) se necessário para reduzir vazamento espectral."
                                  ],
                                  "verification": "Sinal plotado corretamente no tempo, com amplitude e frequência visíveis apesar do ruído.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy, SciPy e Matplotlib",
                                    "ou MATLAB",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Escolha N como potência de 2 para eficiência da FFT; verifique Nyquist (fs > 2*f_max).",
                                  "learningObjective": "Compreender a discretização de sinais contínuos e preparação para transformadas.",
                                  "commonMistakes": [
                                    "Taxa de amostragem insuficiente causando aliasing",
                                    "N não potência de 2 degradando performance",
                                    "Ruído com σ muito alto mascarando sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a DFT/FFT do sinal discreto",
                                  "subSteps": [
                                    "Importar função FFT: np.fft.fft() em Python ou fft() em MATLAB.",
                                    "Calcular X[k] = FFT(x_ruido), obtendo array complexo de tamanho N.",
                                    "Calcular frequências correspondentes: f[k] = k * fs / N, para k=0 a N/2-1 (parte positiva).",
                                    "Comparar com DFT manual para poucos pontos (ex: N=8) para validação conceitual.",
                                    "Armazenar magnitude |X[k]| e fase arg(X[k])."
                                  ],
                                  "verification": "Array FFT computado sem erros, magnitude soma energia total próxima à do sinal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Bibliotecas NumPy/SciPy ou MATLAB Signal Processing Toolbox"
                                  ],
                                  "tips": "Use fftshift() para centralizar DC em zero; normalize por N para DFT.",
                                  "learningObjective": "Executar eficientemente a transformada discreta via FFT.",
                                  "commonMistakes": [
                                    "Confundir índices de frequência (k vs. f)",
                                    "Não considerar simetria para sinais reais",
                                    "Esquecer divisão por N na magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar e visualizar o espectro de frequências",
                                  "subSteps": [
                                    "Calcular magnitude espectral: mag[k] = 2 * |X[k]| / N para k=1 a N/2-1.",
                                    "Plotar espectro de magnitude vs. frequência (0 a fs/2).",
                                    "Identificar picos: usar find_peaks() ou visualmente localizar máximo.",
                                    "Plotar espectro de fase se relevante.",
                                    "Aplicar filtro passa-baixa no espectro para demonstrar processamento."
                                  ],
                                  "verification": "Gráfico de espectro mostra pico dominante na frequência conhecida do sinal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib/Plotly para gráficos",
                                    "SciPy.signal para picos"
                                  ],
                                  "tips": "Use escala log para melhor visualização de ruído; limite eixo x a fs/2.",
                                  "learningObjective": "Visualizar e extrair componentes frecuenciais do sinal.",
                                  "commonMistakes": [
                                    "Plotar todo espectro sem simetria (redundante)",
                                    "Escala linear escondendo picos fracos",
                                    "Ignorar vazamento espectral sem janelamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar em contexto de sistemas dinâmicos",
                                  "subSteps": [
                                    "Comparar frequência pico detectada com frequência real do sinal.",
                                    "Quantificar SNR: relação sinal-ruído via potência espectral.",
                                    "Simular contexto aeronáutico: adicionar harmônicos para modos de vibração.",
                                    "Validar com IFFT: ifft(X) deve recuperar sinal original.",
                                    "Documentar relatório com plots e conclusões."
                                  ],
                                  "verification": "Frequência identificada com erro <1%, IFFT reconstrói sinal com erro baixo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy para IFFT e métricas",
                                    "Template de relatório LaTeX/Markdown"
                                  ],
                                  "tips": "Use resolução espectral Δf = fs/N; aumente N para melhor resolução.",
                                  "learningObjective": "Aplicar análise espectral para diagnóstico em sistemas reais.",
                                  "commonMistakes": [
                                    "Atribuir picos errados a ruído",
                                    "Não validar com IFFT",
                                    "Ignorar unidades de frequência (Hz vs. rad/s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere um sinal discreto senoidal de 100 Hz com ruído gaussiano (σ=0.2), fs=1000 Hz, N=1024. Compute FFT, plote espectro e identifique o pico em ~100 Hz, quantificando sua magnitude e suprimindo ruído.",
                              "finalVerifications": [
                                "Espectro mostra pico claro na frequência conhecida apesar do ruído.",
                                "IFFT reconstrói sinal original com erro RMSE < 0.05.",
                                "Frequências resolvidas corretamente até fs/2.",
                                "Relatório documenta parâmetros, plots e interpretações.",
                                "Código executável e reproduzível.",
                                "SNR calculado matches expectativa teórica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de frequência (erro <1%).",
                                "Correta implementação e normalização da FFT.",
                                "Qualidade dos gráficos e análise visual.",
                                "Validação via IFFT e métricas quantitativas.",
                                "Interpretação contextual em sistemas dinâmicos.",
                                "Eficiência computacional e boas práticas de código."
                              ],
                              "crossCurricularConnections": [
                                "Processamento Digital de Sinais em Eletrônica.",
                                "Análise de Vibrações e Modos em Mecânica Estrutural.",
                                "Estatística e Modelagem de Ruído.",
                                "Programação Numérica e Otimização.",
                                "Física de Ondas e Acústica."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, aplica-se DFT/FFT para análise espectral de vibrações em componentes como asas ou hélices, detectando frequências de flutter, fadiga estrutural ou desbalanceamento em sistemas dinâmicos de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2.3",
                              "10.1.6.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Aplicações em Sistemas Físicos",
                "description": "Aplica conceitos em sistemas mecânicos, eletromecânicos, térmicos e hidráulicos.",
                "totalSkills": 37,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Modelagem de Sistemas Mecânicos",
                    "description": "Aplicação de funções de transferência e espaço de estados em massas-molas-amortecedores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Equações de Movimento em Sistemas Massa-Mola-Amortecedor",
                        "description": "Derivação das equações diferenciais que governam o comportamento dinâmico de sistemas mecânicos compostos por massa, mola e amortecedor, considerando forças externas e linearização para pequenos deslocamentos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Derivar a equação diferencial de segundo ordem para um sistema MSS simples",
                            "description": "Aplicar a Segunda Lei de Newton para obter a equação mẍ + bẋ + kx = f(t), identificando os termos de inércia, amortecimento e rigidez, e explicando o significado físico de cada coeficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do sistema Massa-Mola-Amortecedor (MSS)",
                                  "subSteps": [
                                    "Identifique a massa (m) como o corpo rígido sujeito a movimento.",
                                    "Descreva a mola (k) como o elemento que fornece força restauradora proporcional ao deslocamento.",
                                    "Explique o amortecedor (b) como o elemento que dissipa energia proporcional à velocidade.",
                                    "Note a força externa f(t) que pode atuar sobre o sistema.",
                                    "Desenhe um diagrama esquemático simples do sistema MSS em equilíbrio e deslocado."
                                  ],
                                  "verification": "Crie um diagrama rotulado dos componentes MSS e liste suas funções físicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de desenho como Draw.io",
                                    "Referência: diagrama padrão de MSS"
                                  ],
                                  "tips": "Visualize o sistema como a suspensão de um veículo para fixar conceitos.",
                                  "learningObjective": "Entender o papel físico de cada componente no sistema MSS.",
                                  "commonMistakes": [
                                    "Confundir rigidez (k) com amortecimento (b)",
                                    "Ignorar a dependência temporal de f(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar o diagrama de corpo livre (DCL) do sistema",
                                  "subSteps": [
                                    "Isolar a massa, representando-a como uma partícula ou bloco.",
                                    "Desenhar setas para forças: peso (se aplicável), força da mola -kx, força do amortecedor -bẋ, força externa f(t).",
                                    "Definir o sistema de coordenadas: x positivo para baixo ou conforme convenção.",
                                    "Indicar o deslocamento x(t), velocidade ẋ(t) e aceleração ẍ(t).",
                                    "Verificar equilíbrio estático quando ẍ = ẋ = 0 e f(t)=0."
                                  ],
                                  "verification": "Produza um DCL completo com todas as forças rotuladas e equações de força associadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Livro-texto de dinâmica com exemplos de DCL"
                                  ],
                                  "tips": "Use convenções consistentes de sinal para forças opostas ao deslocamento.",
                                  "learningObjective": "Construir corretamente o DCL para visualizar forças atuantes.",
                                  "commonMistakes": [
                                    "Esquecer sinal negativo nas forças restauradoras",
                                    "Incluir peso sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Segunda Lei de Newton e derivar a equação diferencial",
                                  "subSteps": [
                                    "Escreva ΣF = mẍ, somando todas as forças no DCL.",
                                    "Some forças: f_mola = -kx, f_amortecedor = -bẋ, f_externa = f(t).",
                                    "Forme a equação: mẍ + bẋ + kx = f(t).",
                                    "Reorganize em forma padrão de equação diferencial de segundo ordem.",
                                    "Teste com f(t)=0 para verificar equilíbrio."
                                  ],
                                  "verification": "Derive a equação mẍ + bẋ + kx = f(t) a partir do DCL e resolva para um caso simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy ou papel para álgebra",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Mantenha consistência nos sinais: forças restauradoras negativas.",
                                  "learningObjective": "Derivar matematicamente a EDO usando princípios newtonianos.",
                                  "commonMistakes": [
                                    "Invertar sinais de forças",
                                    "Confundir derivadas: ẍ é aceleração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar os coeficientes e significado físico da equação",
                                  "subSteps": [
                                    "Explique m como coeficiente de inércia (resistência à aceleração).",
                                    "Descreva b como coeficiente de amortecimento (dissipação de energia).",
                                    "Identifique k como coeficiente de rigidez (força restauradora).",
                                    "Discuta f(t) como entrada de excitação externa.",
                                    "Classifique o sistema como subamortecido, crítico ou superamortecido baseado em parâmetros."
                                  ],
                                  "verification": "Escreva uma tabela com cada termo, coeficiente e significado físico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Gráficos de resposta ao degrau para MSS"
                                  ],
                                  "tips": "Relacione coeficientes a unidades: m[kg], b[Ns/m], k[N/m].",
                                  "learningObjective": "Associar termos matemáticos a fenômenos físicos no sistema.",
                                  "commonMistakes": [
                                    "Confundir b com k",
                                    "Ignorar unidades para checagem dimensional"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um carro com massa de suspensão m=1000kg, amortecedor b=2000 Ns/m e mola k=20000 N/m. Desenhe o DCL para uma irregularidade na estrada f(t)=1000 sen(ωt) N, derive mẍ + bẋ + kx = f(t) e interprete: inércia resiste buracos, amortecedor suaviza oscilações, mola retorna à posição.",
                              "finalVerifications": [
                                "Derive corretamente a EDO mẍ + bẋ + kx = f(t) de um DCL dado.",
                                "Identifique e explique os três termos principais e seus coeficientes físicos.",
                                "Verifique dimensionalmente a equação (unidades consistentes).",
                                "Classifique o tipo de amortecimento para valores numéricos dados.",
                                "Resolva para equilíbrio estático (f(t)=0).",
                                "Compare com sistema sem amortecedor (b=0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da EDO (100% dos termos corretos).",
                                "Correção do DCL com sinais apropriados.",
                                "Explicação física clara de cada coeficiente.",
                                "Uso consistente de notação diferencial (ẋ, ẍ).",
                                "Aplicação correta da Segunda Lei de Newton.",
                                "Identificação de erros comuns evitados.",
                                "Profundidade na interpretação (ex.: regimes de amortecimento)."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Aplicação direta da mecânica newtoniana.",
                                "Engenharia de Controle: Base para análise de estabilidade e projeto de controladores PID.",
                                "Matemática: Resolução de EDOs lineares com coeficientes constantes.",
                                "Engenharia Mecânica: Modelagem de vibrações em estruturas aeronáuticas.",
                                "Programação: Simulação numérica em MATLAB/Simulink para validação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, modela a suspensão de trem de pouso de aviões, onde m é a massa da aeronave, b o amortecedor oleoso e k a mola pneumática; a EDO prevê oscilações durante pouso, otimizando conforto e segurança contra fadiga estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Linearizar modelos não lineares de sistemas mecânicos",
                            "description": "Utilizar a expansão em série de Taylor ao redor de um ponto de equilíbrio para linearizar equações diferenciais não lineares em sistemas massa-mola-amortecedor com folgas ou atrito não linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o sistema mecânico não linear e determinar o ponto de equilíbrio",
                                  "subSteps": [
                                    "Descreva o sistema massa-mola-amortecedor, incluindo forças não lineares como folgas (play) ou atrito Coulomb.",
                                    "Escreva as equações diferenciais não lineares completas do movimento.",
                                    "Defina as variáveis de estado (posição x, velocidade v) e encontre o ponto de equilíbrio estático (x_eq, v_eq = 0).",
                                    "Verifique se no equilíbrio as forças se cancelam (∑F = 0).",
                                    "Linearize conceitualmente: explique por que a linearização é válida perto do equilíbrio."
                                  ],
                                  "verification": "Confirme que o ponto de equilíbrio satisfaz dx/dt = 0 e d²x/dt² = 0, com cálculos numéricos ou simbólicos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Lápis e papel",
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Referência: Livro de Dinâmica de Sistemas (ex: Ogata)"
                                  ],
                                  "tips": "Escolha um exemplo simples primeiro, como mẍ + c|ẋ| + k(x - play) = 0 para folga.",
                                  "learningObjective": "Compreender a estrutura de sistemas mecânicos não lineares e localizar pontos de equilíbrio estáveis.",
                                  "commonMistakes": [
                                    "Confundir equilíbrio estático com dinâmico",
                                    "Ignorar termos de folga ou atrito nas equações iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular expansões em série de Taylor das funções não lineares ao redor do equilíbrio",
                                  "subSteps": [
                                    "Identifique funções não lineares f(x, ẋ) como atrito sign(ẋ) ou folga Heaviside(x).",
                                    "Compute derivadas parciais: ∂f/∂x e ∂f/∂ẋ no ponto (x_eq, 0).",
                                    "Aplique expansão de Taylor de primeira ordem: f ≈ f_eq + (∂f/∂x)(x - x_eq) + (∂f/∂ẋ)ẋ.",
                                    "Ignore termos de ordem superior (quadráticos ou mais) para linearização.",
                                    "Simplifique expressões, notando que f_eq = 0 no equilíbrio."
                                  ],
                                  "verification": "Verifique que a aproximação de Taylor coincide com a função original no ponto de equilíbrio e derivadas coincidem.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy/MATLAB)",
                                    "Folha de derivadas de funções comuns (sign, Heaviside)",
                                    "Exemplos resolvidos de livros de controle não linear"
                                  ],
                                  "tips": "Use a regra da cadeia para derivadas compostas; teste com valores numéricos próximos ao equilíbrio.",
                                  "learningObjective": "Dominar o cálculo de expansões de Taylor multivariáveis para linearização.",
                                  "commonMistakes": [
                                    "Esquecer derivadas parciais",
                                    "Incluir termos de segunda ordem acidentalmente",
                                    "Não avaliar no ponto exato de equilíbrio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar e escrever as equações diferenciais lineares aproximadas",
                                  "subSteps": [
                                    "Substitua as aproximações de Taylor nas equações de movimento originais.",
                                    "Obtenha a forma padrão: m δẍ + c_eq δẋ + k_eq δx ≈ 0, onde δx = x - x_eq.",
                                    "Converta para forma de espaço de estados: ẋ = A x, com x = [δx, δẋ]^T.",
                                    "Calcule autovalores de A para verificar estabilidade.",
                                    "Compare com o modelo linear sem não-linearidades."
                                  ],
                                  "verification": "Simule numericamente o modelo não linear e linearizado; plote trajetórias para pequenas perturbações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy odeint)",
                                    "Templates de matrizes de estado para sistemas de 2ª ordem"
                                  ],
                                  "tips": "Defina δx explicitamente para evitar confusão; use plot para visualizar validade.",
                                  "learningObjective": "Construir modelos lineares em espaço de estados a partir de aproximações de Taylor.",
                                  "commonMistakes": [
                                    "Não definir variáveis desviadas δx",
                                    "Erros de sinal nas derivadas lineares",
                                    "Confundir coeficientes de amortecimento/amortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a linearização e analisar limitações",
                                  "subSteps": [
                                    "Simule respostas a entradas pequenas (passo unitário em força) nos dois modelos.",
                                    "Calcule erro de aproximação: ||x_nl - x_lin|| para diferentes amplitudes iniciais.",
                                    "Discuta região de validade (linearidade local).",
                                    "Aplique em um caso com folga: ajuste play e observe efeitos.",
                                    "Documente passos em relatório com gráficos."
                                  ],
                                  "verification": "Gráficos mostram sobreposição boa para perturbações <10% do equilíbrio; erro <5%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (MATLAB/Python)",
                                    "Templates de relatórios LaTeX ou Jupyter Notebook"
                                  ],
                                  "tips": "Varie amplitude inicial de 1% a 20% para ver quebra de linearidade.",
                                  "learningObjective": "Avaliar precisão e aplicabilidade prática da linearização.",
                                  "commonMistakes": [
                                    "Simular apenas no equilíbrio (trivial)",
                                    "Ignorar efeitos de folga em simulações",
                                    "Não quantificar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola com folga: mẍ + b ẋ + k (x - 0.01 * sign(x)) = u(t), equilíbrio em x_eq=0. Linearize ao redor de x=0: derive ∂/∂x da mola com folga → k_eq = k, mas note assimetria para grandes deslocamentos. Simule resposta a u(t)=1N passo.",
                              "finalVerifications": [
                                "Derivações de Taylor coincidem com função e inclinação no equilíbrio.",
                                "Matriz A do espaço de estados tem autovalores corretos (estáveis).",
                                "Simulações mostram matching para pequenas entradas (<5% erro).",
                                "Relatório explica limitações para grandes amplitudes.",
                                "Pode aplicar a novo sistema com atrito |ẋ|.",
                                "Identifica corretamente coeficientes lineares k_lin, c_lin."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivadas parciais e Taylor (90% correto).",
                                "Correta formação da matriz A e análise de estabilidade.",
                                "Qualidade de simulações e gráficos comparativos.",
                                "Explicação clara de validade e erros comuns evitados.",
                                "Relatório estruturado com todos os passos documentados.",
                                "Criatividade em extensão a variações (folga vs. atrito)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Taylor e análise assintótica.",
                                "Controle Automático: Projeto de controladores lineares (PID, LQR).",
                                "Física: Dinâmica não linear e bifurcações.",
                                "Programação: Simulação numérica (ODE solvers em Python/MATLAB).",
                                "Engenharia Aeronáutica: Modelagem de atuadores com folgas em flaps."
                              ],
                              "realWorldApplication": "Em aeronáutica, lineariza modelos de superfícies de controle (elevons) com folgas mecânicas para design de controladores de voo estável, permitindo análise de modos de flutter ou estabilidade em manobras pequenas perto do trim."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Interpretar os parâmetros físicos na equação de movimento",
                            "description": "Relacionar os coeficientes m (massa), b (coeficiente de amortecimento) e k (constante de mola) com propriedades físicas mensuráveis e prever comportamentos qualitativos como sobreamortecido, crítico ou subamortecido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os significados físicos dos parâmetros m, b e k",
                                  "subSteps": [
                                    "Defina massa (m) como a inércia do corpo, medida em kg via balança ou sensor de força.",
                                    "Explique o coeficiente de amortecimento (b) como resistência viscosa, relacionado à velocidade, medido em Ns/m via testes de arrasto.",
                                    "Descreva a constante de mola (k) como rigidez elástica, força proporcional ao deslocamento, medida em N/m via deformação controlada.",
                                    "Compare unidades e dimensões para reforçar conexões físicas.",
                                    "Visualize com diagramas livres de corpo ilustrando forças em cada parâmetro."
                                  ],
                                  "verification": "Escreva definições curtas e unidades para m, b e k, e desenhe um diagrama de forças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de dinâmica (cap. massa-mola), calculadora, papel e lápis para diagramas"
                                  ],
                                  "tips": "Use analogias cotidianas: m como peso de uma mala, k como elástico de cabelo, b como freio de bicicleta.",
                                  "learningObjective": "Identificar e descrever as propriedades físicas representadas por cada parâmetro na equação.",
                                  "commonMistakes": [
                                    "Confundir b com atrito seco (é viscoso), ignorar unidades SI, tratar k como massa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar parâmetros com grandezas mensuráveis experimentais",
                                  "subSteps": [
                                    "Planeje experimento: meça m pendurando massa conhecida em mola.",
                                    "Meça k: aplique deslocamentos conhecidos e registre forças com dinamômetro.",
                                    "Meça b: observe decaimento oscilatório livre e ajuste via software ou gráfico logarítmico.",
                                    "Registre dados em tabela: valores medidos vs. teóricos.",
                                    "Calcule incertezas de medição para validar mensurabilidade."
                                  ],
                                  "verification": "Compile tabela de medições reais ou simuladas com valores numéricos para m, b, k.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mola real, massas calibradas, cronômetro, dinamômetro, software como Python/MATLAB para fit de curvas"
                                  ],
                                  "tips": "Grave vídeo do experimento para análise posterior; use amortecedor de fluido para b realista.",
                                  "learningObjective": "Conectar parâmetros abstratos a procedimentos experimentais quantificáveis.",
                                  "commonMistakes": [
                                    "Não linearizar dados para b, ignorar efeitos gravitacionais em k, medições imprecisas sem repetições."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar regimes de amortecimento via discriminante",
                                  "subSteps": [
                                    "Escreva equação característica: r² + (b/m)r + k/m = 0.",
                                    "Defina discriminante δ = (b/m)² - 4(k/m); calcule para casos variados.",
                                    "Classifique: subamortecido (δ<0, oscilações), crítico (δ=0, retorno mais rápido), sobreamortecido (δ>0, sem oscilação).",
                                    "Plote gráfico de δ vs. b para fixar fronteiras.",
                                    "Simule numericamente raízes reais/complexas para cada regime."
                                  ],
                                  "verification": "Calcule δ e classifique regime para 3 conjuntos de valores (m=1, k=1; b=0.5, 2, 3).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou Python (biblioteca numpy para raízes), planilha Excel para gráficos"
                                  ],
                                  "tips": "Normalize por m: use ζ = b/(2√(km)) para simplificar classificações.",
                                  "learningObjective": "Determinar regime de amortecimento com base no discriminante δ.",
                                  "commonMistakes": [
                                    "Esquecer divisão por m nas raízes, confundir δ>0 com oscilação, erros algébricos na equação característica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever e interpretar comportamentos qualitativos dos regimes",
                                  "subSteps": [
                                    "Descreva subamortecido: oscilações decaindo (b pequeno).",
                                    "Criticamente amortecido: retorno ao equilíbrio sem oscilar (b ideal).",
                                    "Sobreamortecido: retorno lento sem oscilar (b grande).",
                                    "Compare trajetórias em gráficos x(t) para os três regimes.",
                                    "Discuta impactos: ex., conforto em suspensão (evitar sobreamortecido)."
                                  ],
                                  "verification": "Esboce curvas qualitativas x(t) para os três regimes e explique diferenças.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink ou Python scipy.integrate), papel milimetrado"
                                  ],
                                  "tips": "Simule com valores fixos: m=1kg, k=100N/m, varie b de 0 a 30.",
                                  "learningObjective": "Prever dinâmicas qualitativas baseadas nos parâmetros e regime.",
                                  "commonMistakes": [
                                    "Invertir sub/sobreamortecido, ignorar dependência em √(k/m), superestimar crítico como 'melhor' sempre."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um trem de pouso de aeronave, interprete m=500kg (massa da roda), k=10^5 N/m (rigidez do amortecedor), b=5000 Ns/m: calcule δ para prever se o pouso oscila (subamortecido, desconforto) ou retorna suavemente (crítico). Simule em Python para validar.",
                              "finalVerifications": [
                                "Explica corretamente m, b, k com unidades e analogias físicas.",
                                "Meça ou simula valores reais para os três parâmetros.",
                                "Classifica regime corretamente para valores dados via discriminante.",
                                "Desenha e descreve curvas x(t) qualitativas para os três regimes.",
                                "Preve impacto qualitativo de alterar um parâmetro (ex., aumentar b).",
                                "Integra medições experimentais em previsão de comportamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições físicas e unidades (80% correto).",
                                "Correta derivação e uso do discriminante δ (com cálculos numéricos).",
                                "Qualidade dos gráficos e descrições qualitativas de regimes.",
                                "Conexão explícita entre parâmetros mensuráveis e previsões.",
                                "Criatividade em analogias e aplicações aeronáuticas.",
                                "Ausência de erros comuns como confusão de regimes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares de 2ª ordem.",
                                "Física: Leis de Newton e energia dissipada por amortecimento.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Engenharia de Controle: Projeto de amortecedores via ζ.",
                                "Estatística: Análise de incertezas em medições experimentais."
                              ],
                              "realWorldApplication": "Projeto de amortecedores em trens de pouso de aeronaves: otimizar b/k para amortecimento crítico, evitando oscilações perigosas pós-pouso e garantindo durabilidade estrutural."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Representação por Função de Transferência",
                        "description": "Conversão das equações diferenciais em funções de transferência no domínio de Laplace para análise de sistemas mecânicos massa-mola-amortecedor.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Obter a função de transferência G(s) = X(s)/F(s)",
                            "description": "Aplicar a transformada de Laplace na equação diferencial mẍ + bẋ + kx = f(t), assumindo condições iniciais nulas, para derivar G(s) = 1/(ms² + bs + k) e identificar polos e zeros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a equação diferencial do sistema massa-mola-amortecedor",
                                  "subSteps": [
                                    "Identifique os parâmetros do sistema: massa m, amortecimento b e rigidez k.",
                                    "Escreva a equação diferencial no domínio do tempo: mẍ + bẋ + kx = f(t).",
                                    "Confirme que as condições iniciais são nulas: x(0) = 0 e ẋ(0) = 0.",
                                    "Verifique as unidades dos parâmetros para consistência (kg, N·s/m, N/m).",
                                    "Anote a equação em uma forma padrão para facilitar a transformada."
                                  ],
                                  "verification": "Equação escrita corretamente com todos os termos e condições iniciais especificadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou software como MATLAB/SymPy",
                                    "Tabela de propriedades de sistemas mecânicos"
                                  ],
                                  "tips": "Sempre use notação consistente para derivadas (ẋ para primeira derivada).",
                                  "learningObjective": "Entender a representação matemática do sistema físico no domínio do tempo.",
                                  "commonMistakes": [
                                    "Esquecer o sinal dos termos de amortecimento ou rigidez",
                                    "Não especificar condições iniciais zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a transformada de Laplace à equação diferencial",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace L{} a cada termo da equação: L{mẍ} = m(s²X(s) - s x(0) - ẋ(0)).",
                                    "Simplifique usando condições iniciais nulas: L{mẍ} = m s² X(s), L{bẋ} = b s X(s), L{kx} = k X(s).",
                                    "Transforme o termo de entrada: L{f(t)} = F(s).",
                                    "Escreva a equação no domínio s: m s² X(s) + b s X(s) + k X(s) = F(s).",
                                    "Fatore X(s) no lado esquerdo para preparar a derivação de G(s)."
                                  ],
                                  "verification": "Equação transformada correta no domínio de Laplace, sem termos de condições iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora simbólica ou software como Mathematica"
                                  ],
                                  "tips": "Lembre-se: Laplace de derivada segunda é s²X(s) - s x(0) - ẋ(0), que simplifica para s²X(s).",
                                  "learningObjective": "Dominar a aplicação da transformada de Laplace a equações diferenciais lineares.",
                                  "commonMistakes": [
                                    "Erros nos termos de inicialização da Laplace",
                                    "Confundir L{ẋ} com s X(s) sem subtrair inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a função de transferência G(s) = X(s)/F(s)",
                                  "subSteps": [
                                    "Isolar X(s)/F(s) da equação: X(s) (m s² + b s + k) = F(s).",
                                    "Divida ambos os lados por F(s): G(s) = X(s)/F(s) = 1 / (m s² + b s + k).",
                                    "Escreva G(s) na forma padrão de segundo ordem.",
                                    "Verifique se o numerador é 1 (sem zeros no numerador para este sistema).",
                                    "Substitua valores numéricos exemplo se aplicável para validar."
                                  ],
                                  "verification": "G(s) expressa corretamente como 1/(ms² + bs + k).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de exercícios com equações semelhantes",
                                    "Software de álgebra simbólica"
                                  ],
                                  "tips": "Mantenha o denominador no formato polinomial padrão ms² + bs + k.",
                                  "learningObjective": "Capacitar a extração da função de transferência de equações no domínio s.",
                                  "commonMistakes": [
                                    "Inverter numerador e denominador",
                                    "Esquecer de fatorar X(s) corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar polos e zeros da função de transferência",
                                  "subSteps": [
                                    "Localize os zeros: raízes do numerador (1 = 0, nenhum zero finito).",
                                    "Encontre os polos: resolva ms² + bs + k = 0, polos em [-b ± sqrt(b² - 4mk)] / (2m).",
                                    "Classifique os polos: reais distintos, reais repetidos ou complexos conjugados baseados no discriminante.",
                                    "Plote os polos no plano s para visualização.",
                                    "Discuta implicações: estabilidade (polos no semiplano esquerdo)."
                                  ],
                                  "verification": "Lista correta de polos e zeros, com classificação e análise de estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico do plano complexo",
                                    "Solver quadrático online ou calculadora"
                                  ],
                                  "tips": "Use fórmula quadrática: s = [-b ± sqrt(b² - 4mk)] / (2m).",
                                  "learningObjective": "Analisar a estrutura de polos e zeros para caracterizar o comportamento dinâmico.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Erro no sinal da fórmula quadrática"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema com m=1 kg, b=2 N·s/m, k=1 N/m: G(s) = 1/(s² + 2s + 1). Polos em s=-1 (repetido), sem zeros. Simule resposta ao degrau em MATLAB para verificar.",
                              "finalVerifications": [
                                "Derivação correta de G(s) a partir da EDO usando Laplace.",
                                "Identificação precisa de polos e ausência de zeros.",
                                "Classificação correta do tipo de polos (ex: subamortecido).",
                                "Análise de estabilidade baseada na localização dos polos.",
                                "Validação numérica com exemplo específico.",
                                "Explicação verbal do processo passo a passo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na aplicação de Laplace (90% correto).",
                                "Correta derivação e simplificação de G(s).",
                                "Identificação e cálculo exato de polos/zeros.",
                                "Interpretação física dos resultados (estabilidade, amortecimento).",
                                "Clareza na documentação e passos intermediários.",
                                "Tempo de execução dentro do estimado total (70 min)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Uso de G(s) em diagramas de bloco e controladores PID.",
                                "Matemática Avançada: Análise de raízes e estabilidade de sistemas lineares.",
                                "Física: Modelagem de osciladores harmônicos e vibrações.",
                                "Engenharia Elétrica: Analogia com circuitos RLC (R↔b, L↔m, C↔1/k).",
                                "Programação: Implementação em Python/MATLAB para simulação."
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, modela vibrações de asas ou fuselagem sob forças aerodinâmicas, permitindo design de amortecedores para estabilidade de voo e prevenção de flutter."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Analisar propriedades da função de transferência em sistemas MSS",
                            "description": "Determinar ganho estático, constantes de tempo, frequência natural e fator de amortecimento a partir da forma padrão ω_n² / (s² + 2ζω_n s + ω_n²), relacionando com estabilidade e resposta transitória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a forma padrão da função de transferência de segunda ordem",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) = K ω_n² / (s² + 2 ζ ω_n s + ω_n²) em sua forma geral.",
                                    "Confirme que o numerador é K ω_n² e o denominador é o polinômio característico de segunda ordem.",
                                    "Identifique os coeficientes: a2=1, a1=2 ζ ω_n, a0=ω_n² para o denominador s² + a1 s + a0.",
                                    "Verifique se a FT está normalizada (K=1) ou possui ganho K explícito.",
                                    "Compare com exemplos de sistemas MSS para validar a estrutura."
                                  ],
                                  "verification": "A FT foi reescrita corretamente na forma padrão com todos os termos identificados.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Folha de papel ou software como MATLAB/SymPy",
                                    "Tabela de formas padrão de FT"
                                  ],
                                  "tips": "Sempre normalize dividindo pelo coeficiente líder do denominador para a=1.",
                                  "learningObjective": "Reconhecer e padronizar funções de transferência de sistemas mecânicos de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir numerador com denominador",
                                    "Ignorar o ganho K inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair frequência natural ω_n e fator de amortecimento ζ",
                                  "subSteps": [
                                    "Do denominador s² + 2 ζ ω_n s + ω_n², isole ω_n = sqrt(a0) onde a0 é o termo constante.",
                                    "Calcule ζ = a1 / (2 ω_n), onde a1 é o coeficiente de s.",
                                    "Verifique se ζ está entre 0 e 1 para subamortecido (comum em MSS).",
                                    "Calcule os polos: s = -ζ ω_n ± ω_n sqrt(1 - ζ²) j.",
                                    "Plote os polos no plano s para visualização inicial."
                                  ],
                                  "verification": "Valores de ω_n e ζ calculados coincidem com raízes do denominador.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software de plotagem como MATLAB ou Python (matplotlib)"
                                  ],
                                  "tips": "Use sqrt(a0) diretamente para ω_n para evitar erros de aproximação.",
                                  "learningObjective": "Determinar parâmetros dinâmicos fundamentais a partir dos coeficientes da FT.",
                                  "commonMistakes": [
                                    "Erro em sqrt(1 - ζ²) levando a polos reais incorretos",
                                    "Confundir ζ com damping ratio diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar ganho estático e constantes de tempo",
                                  "subSteps": [
                                    "Calcule ganho estático K_static = G(0) = K ω_n² / ω_n² = K.",
                                    "Para aproximação de primeira ordem, identifique τ ≈ 1/(ζ ω_n) como constante de tempo dominante.",
                                    "Calcule constantes de tempo dos polos reais: τ1, τ2 = 1/|Re(polo)|.",
                                    "Compare com resposta em regime permanente para MSS (ex: posição final).",
                                    "Registre valores numéricos para uma FT exemplo."
                                  ],
                                  "verification": "Ganho estático avaliado corretamente em s=0 e τ condiz com decaimento exponencial.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Folha de exercícios com FT numéricas",
                                    "Simulador como Simulink"
                                  ],
                                  "tips": "Para sistemas unit gain, K_static=1; sempre avalie lim s->0 G(s).",
                                  "learningObjective": "Quantificar ganho DC e dinâmicas de decaimento temporal.",
                                  "commonMistakes": [
                                    "Esquecer K no numerador",
                                    "Usar ω_n como τ diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar parâmetros com estabilidade e resposta transitória",
                                  "subSteps": [
                                    "Avalie estabilidade: polos no LHP se ζ > 0 e ω_n > 0.",
                                    "Para resposta transitória: overshoot Mp ≈ e^(-π ζ / sqrt(1-ζ²)), tempo de assentamento Ts ≈ 4/(ζ ω_n).",
                                    "Classifique regime: subamortecido (ζ<1), crítico (ζ=1), sobreamortecido (ζ>1).",
                                    "Simule ou esboce resposta ao degrau unitário.",
                                    "Discuta impacto em vibrações de MSS (ex: amortecedor insuficiente causa oscilações)."
                                  ],
                                  "verification": "Gráficos ou fórmulas de Mp e Ts calculados corretamente para valores de ζ e ω_n.",
                                  "estimatedTime": "40-60 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Tabelas de resposta transitória"
                                  ],
                                  "tips": "Use fórmulas aproximadas para ζ<0.7; simule para validação.",
                                  "learningObjective": "Interpretar propriedades dinâmicas em termos de performance do sistema.",
                                  "commonMistakes": [
                                    "Ignorar estabilidade para ζ negativo",
                                    "Confundir Mp com tempo de pico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar análise com simulação e interpretação",
                                  "subSteps": [
                                    "Implemente G(s) em software e simule resposta ao degrau.",
                                    "Meça Mp, Tp, Ts dos gráficos e compare com fórmulas teóricas.",
                                    "Ajuste ζ ou ω_n e observe mudanças na resposta.",
                                    "Relacione com parâmetros físicos de MSS: m, c, k (ω_n=sqrt(k/m), ζ=c/(2 sqrt(k m))).",
                                    "Documente relatório com valores extraídos e conclusões."
                                  ],
                                  "verification": "Simulação reproduz propriedades teóricas com erro <5%.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "MATLAB, Python (control library) ou Octave"
                                  ],
                                  "tips": "Comece com ζ=0.5, ω_n=1 para visualização clara.",
                                  "learningObjective": "Integrar análise teórica com validação numérica.",
                                  "commonMistakes": [
                                    "Escala errada no gráfico",
                                    "Não linearizar modelo não-linear"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema MSS de suspensão de aeronave com FT G(s) = 25 / (s² + 5s + 25), extraia ω_n=5 rad/s, ζ=0.5, K_static=1. Simule resposta a distúrbio de turbulência: overshoot ~16%, Ts~8s, garantindo estabilidade em voo.",
                              "finalVerifications": [
                                "ω_n e ζ extraídos corretamente dos coeficientes.",
                                "Ganho estático G(0) calculado precisamente.",
                                "Constantes de tempo τ aproximadas com base em polos.",
                                "Classificação de amortecimento e estabilidade confirmadas.",
                                "Fórmulas de Mp e Ts aplicadas sem erros.",
                                "Simulação valida análise teórica."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de parâmetros (ω_n, ζ, K) - 30%.",
                                "Correta interpretação de estabilidade e transitória - 25%.",
                                "Uso adequado de simulações para validação - 20%.",
                                "Relacionamento com física de MSS - 15%.",
                                "Clareza na documentação e gráficos - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Projeto de controladores PID baseados em ζ e ω_n.",
                                "Engenharia Mecânica: Dimensionamento de amortecedores em veículos aéreos.",
                                "Matemática: Análise de polinômios e raízes complexas.",
                                "Física: Dinâmica de osciladores amortecidos."
                              ],
                              "realWorldApplication": "Em aeronáutica, análise de FT de sistemas de controle de flutter ou suspensão de trem de pouso garante estabilidade vibracional, prevenindo falhas estruturais durante decolagem e turbulências, otimizando conforto e segurança de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Construir diagrama de blocos para sistema mecânico",
                            "description": "Representar o sistema massa-mola-amortecedor em diagrama de blocos no domínio s, mostrando somadores, ganhos integradores e realimentações inerentes ao modelo físico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo físico do sistema massa-mola-amortecedor",
                                  "subSteps": [
                                    "Identifique os componentes principais: massa (m), constante da mola (k) e coeficiente de amortecimento (c).",
                                    "Escreva a equação diferencial de segunda ordem: m * ÿ + c * ẏ + k * y = F(t), onde y é a posição, ẏ a velocidade e ÿ a aceleração.",
                                    "Defina as variáveis de entrada (força F(t)) e saída (posição y(t)).",
                                    "Desenhe um esquema físico simples do sistema para visualização.",
                                    "Anote as relações físicas: força elástica (-k y), força de amortecimento (-c ẏ) e força inercial (m ÿ)."
                                  ],
                                  "verification": "Confirme que a equação diferencial está corretamente escrita e balanceada com todas as forças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho (ex: Draw.io)",
                                    "Referência de dinâmica clássica (livro ou PDF)"
                                  ],
                                  "tips": "Use setas para indicar direções das forças e mantenha consistência nas notações.",
                                  "learningObjective": "Compreender as leis físicas subjacentes ao sistema mecânico.",
                                  "commonMistakes": [
                                    "Confundir os sinais das forças restauradoras (devem ser negativas)",
                                    "Esquecer o termo inercial da massa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter o modelo para o domínio de Laplace (s)",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace à equação diferencial, assumindo condições iniciais zero: M(s) s² Y(s) + C(s) s Y(s) + K Y(s) = F(s).",
                                    "Divida ambos os lados por m para obter a forma padrão: s² Y(s) + (c/m) s Y(s) + (k/m) Y(s) = F(s)/m.",
                                    "Identifique os parâmetros: ω_n² = k/m (frequência natural ao quadrado), 2ζω_n = c/m (termo de amortecimento).",
                                    "Escreva a função de transferência G(s) = Y(s)/F(s) = 1 / (m s² + c s + k).",
                                    "Verifique a dimensionalidade: G(s) deve ter unidades de posição/força (m/N)."
                                  ],
                                  "verification": "A função de transferência G(s) deve ser corretamente derivada e simplificada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: MATLAB, SymPy) ou papel para álgebra",
                                    "Tabela de transformadas de Laplace"
                                  ],
                                  "tips": "Sempre assuma condições iniciais zero para simplificação inicial; anote exceções se necessário.",
                                  "learningObjective": "Dominar a transição de equações diferenciais para funções de transferência no domínio s.",
                                  "commonMistakes": [
                                    "Erro nos fatores de Laplace para derivadas (s Y(s) para ẏ)",
                                    "Dividir incorretamente os termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar os elementos básicos do diagrama de blocos",
                                  "subSteps": [
                                    "Liste os blocos necessários: integrador 1/s (duas vezes, para velocidade e posição), ganhos constantes (1/m, -c/m, -k/m).",
                                    "Identifique somadores: um para soma das forças na massa (F - c ẏ - k y).",
                                    "Planeje realimentações: velocidade ẏ = ∫ aceleração, posição y = ∫ ẏ.",
                                    "Desenhe blocos isolados: ganho 1/m para aceleração, integrador para ẏ, ganho -c para força de amortecimento, etc.",
                                    "Marque pontos de sinal: aceleração (ÿ), velocidade (ẏ), posição (y)."
                                  ],
                                  "verification": "Todos os elementos (somadores, ganhos, integradores) estão listados com valores corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de diagrama de blocos (ex: Simulink, ou papel quadriculado)",
                                    "Modelos de referência de diagramas de blocos"
                                  ],
                                  "tips": "Use símbolos padrão: círculo para somador, retângulo para ganho, 1/s para integrador.",
                                  "learningObjective": "Reconhecer componentes canônicos em representações de sistemas lineares.",
                                  "commonMistakes": [
                                    "Esquecer os sinais negativos nas realimentações",
                                    "Confundir ordem dos integradores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e conectar o diagrama de blocos completo",
                                  "subSteps": [
                                    "Inicie com entrada F(s) conectada a somador principal via ganho 1/m.",
                                    "Adicione realimentação da posição y através de ganho -k/m de volta ao somador.",
                                    "Adicione realimentação da velocidade ẏ (saída do primeiro integrador) através de ganho -c/m.",
                                    "Conecte integradores em cascata: aceleração -> ẏ (1/s) -> y (1/s).",
                                    "Rotule todas as conexões e verifique fluxo de sinal da entrada à saída."
                                  ],
                                  "verification": "O diagrama reproduz exatamente G(s) = Y(s)/F(s) quando reduzido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (ex: Lucidchart, Visio)",
                                    "Papel para rascunho"
                                  ],
                                  "tips": "Construa modularmente: teste cada ramo separadamente antes de conectar.",
                                  "learningObjective": "Montar diagramas de blocos a partir de equações físicas.",
                                  "commonMistakes": [
                                    "Conexões cruzadas erradas",
                                    "Falta de somador para forças opostas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refinar o diagrama",
                                  "subSteps": [
                                    "Reduza o diagrama manualmente para confirmar que equivale a G(s).",
                                    "Simule numericamente com valores exemplo (ex: m=1, c=0.5, k=1) usando software.",
                                    "Identifique realimentações inerentes: loops negativos para estabilidade.",
                                    "Adicione legendas e unidades aos blocos.",
                                    "Compare com diagramas padrão de sistemas massa-mola."
                                  ],
                                  "verification": "Simulação ou redução algébrica matches a função de transferência original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de simulação (ex: MATLAB/Simulink)",
                                    "Valores numéricos de exemplo"
                                  ],
                                  "tips": "Use blocos de redução de diagrama para validação rápida.",
                                  "learningObjective": "Garantir precisão e validade do modelo representado.",
                                  "commonMistakes": [
                                    "Ignorar polaridades nos somadores",
                                    "Erro em unidades ou escalas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de suspensão de aeronave com m=1000 kg, c=200 Ns/m, k=50000 N/m: Construa o diagrama mostrando F(t) de turbulência aerodinâmica levando a deslocamento y da fuselagem. Simule resposta a degrau para verificar amortecimento.",
                              "finalVerifications": [
                                "Equação diferencial corretamente mapeada para blocos.",
                                "Todos os ganhos têm valores corretos (1/m, -c/m, -k/m).",
                                "Dois integradores em cascata presentes (ÿ -> ẏ -> y).",
                                "Somadores corretamente posicionados para forças.",
                                "Função de transferência reduzida matches 1/(ms² + cs + k).",
                                "Sinais negativos nas realimentações confirmados.",
                                "Diagrama legível com rótulos completos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes físicos (90% dos elementos corretos).",
                                "Correção na transformada de Laplace e G(s) (sem erros algébricos).",
                                "Fluxo lógico e conexões sem loops espúrios (100% conectividade válida).",
                                "Uso correto de símbolos padrão IEEE para blocos.",
                                "Validação por redução ou simulação bem-sucedida.",
                                "Clareza visual e documentação (rótulos, legendas).",
                                "Criatividade em anotações de realimentações inerentes."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso em controladores PID para estabilização.",
                                "Eletrônica Analógica: Analogia com circuitos RLC (resistência=amortecedor).",
                                "Programação: Implementação em Python/MATLAB para simulação.",
                                "Física Geral: Leis de Newton aplicadas a vibrações.",
                                "Engenharia de Materiais: Seleção de k e c baseados em propriedades."
                              ],
                              "realWorldApplication": "Em aeronáutica, diagramas de blocos modelam sistemas de controle de flaps ou amortecedores de trem de pouso, permitindo análise de estabilidade em voo e design de atuadores para resposta dinâmica sob cargas variáveis."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Modelagem no Espaço de Estados",
                        "description": "Representação matricial das dinâmicas de sistemas mecânicos massa-mola-amortecedor no formato ẋ = Ax + Bu, y = Cx + Du para análise moderna de controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Derivar o modelo de espaço de estados para sistema MSS de segunda ordem",
                            "description": "Escolher estado x = [x, ẋ]^T, construir matrizes A = [[0,1],[-k/m,-b/m]], B = [[0],[1/m]], C = [1,0] e D=0, verificando a equivalência com a função de transferência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o sistema Massa-Mola-Amortecedor (MSS) e sua equação diferencial",
                                  "subSteps": [
                                    "Identifique os componentes: massa (m), constante da mola (k) e coeficiente de amortecimento (b).",
                                    "Escreva a equação de movimento no domínio do tempo: m ÿ + b ẏ + k y = u(t), onde y é a posição e u(t) é a força de entrada.",
                                    "Explique os termos: ÿ é aceleração, ẏ é velocidade e y é deslocamento.",
                                    "Confirme que é um sistema de segunda ordem linear invariante no tempo (LTI).",
                                    "Discuta as condições de contorno iniciais y(0) e ẏ(0)."
                                  ],
                                  "verification": "Escreva corretamente a equação diferencial e identifique todos os parâmetros com suas unidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama esquemático de MSS (impresso ou desenhado)",
                                    "Referência: Livro de Dinâmica (ex: Ogata)"
                                  ],
                                  "tips": "Visualize o sistema como uma massa suspensa por mola e amortecedor para intuitividade.",
                                  "learningObjective": "Compreender a física subjacente e a forma canônica da equação diferencial de segunda ordem.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo nos termos de restauração e amortecimento",
                                    "Confundir y com velocidade em vez de posição",
                                    "Ignorar que u(t) é a entrada de força"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar as variáveis de estado apropriadas",
                                  "subSteps": [
                                    "Escolha o vetor de estado x = [x1, x2]^T, onde x1 = y (posição) e x2 = ẏ (velocidade).",
                                    "Justifique a escolha: as derivadas devem formar um conjunto completo e mínimo de primeira ordem.",
                                    "Escreva as derivadas: ẋ1 = x2 e ẋ2 = (u - b x2 - k x1)/m.",
                                    "Verifique independência: o estado captura toda a informação dinâmica necessária.",
                                    "Considere alternativas como fase-espaço para confirmação."
                                  ],
                                  "verification": "Defina x explicitamente e escreva ẋ1 e ẋ2 em termos de x e u.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para simulações iniciais",
                                    "Software como MATLAB para plotar trajetórias de fase (opcional)"
                                  ],
                                  "tips": "Sempre priorize estados físico-intuitivos como posição e velocidade para sistemas mecânicos.",
                                  "learningObjective": "Dominar a escolha de variáveis de estado para converter EDOs de ordem superior em primeira ordem.",
                                  "commonMistakes": [
                                    "Escolher x = [ẏ, ÿ]^T, que não é canônico",
                                    "Usar apenas posição sem velocidade",
                                    "Esquecer normalização pelo massa m"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as matrizes de espaço de estados A, B, C e D",
                                  "subSteps": [
                                    "Formule ẋ = A x + B u a partir das equações: A = [[0, 1], [-k/m, -b/m]].",
                                    "Defina B = [[0], [1/m]] para entrada de força na aceleração.",
                                    "Especifique a saída y = C x + D u, com C = [1, 0] e D = 0 (saída é posição).",
                                    "Escreva o modelo completo em forma matricial.",
                                    "Verifique dimensionalidade: A (2x2), B (2x1), C (1x2), D (1x1)."
                                  ],
                                  "verification": "Monte e escreva todas as matrizes com elementos corretos em termos de m, b, k.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz em branco (papel)",
                                    "Tabela de símbolos físicos",
                                    "Ferramenta online de álgebra linear (opcional)"
                                  ],
                                  "tips": "Lembre-se: primeira linha de A é sempre [0,1] para posição-velocidade.",
                                  "learningObjective": "Construir precisamente o modelo de espaço de estados em forma canônica para sistemas mecânicos.",
                                  "commonMistakes": [
                                    "Invertar os elementos de A (ex: colocar -k/m na diagonal superior)",
                                    "Esquecer 1/m em B",
                                    "Definir C incorretamente para saída de velocidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência com a função de transferência",
                                  "subSteps": [
                                    "Calcule a função de transferência clássica: G(s) = 1 / (m s^2 + b s + k).",
                                    "Use a fórmula para TF de espaço de estados: G(s) = C (sI - A)^(-1) B + D.",
                                    "Compute det(sI - A) = s^2 + (b/m)s + k/m e adjunta para confirmar igualdade.",
                                    "Substitua valores numéricos simples (ex: m=1, b=1, k=1) para validação numérica.",
                                    "Discuta propriedades: polos iguais, minimalidade do modelo."
                                  ],
                                  "verification": "Mostre que G(s) derivada das matrizes coincide com a TF física.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou MATLAB)",
                                    "Papel para expansão de determinantes",
                                    "Tabela de identidades matriciais"
                                  ],
                                  "tips": "Use expansão cofatora para (sI - A)^(-1) em sistemas 2x2 para simplicidade.",
                                  "learningObjective": "Validar o modelo de espaço de estados comparando com representação em frequência.",
                                  "commonMistakes": [
                                    "Erro no cálculo de (sI - A)",
                                    "Ignorar D=0 na verificação",
                                    "Confundir numerador/denominador da TF"
                                  ]
                                }
                              ],
                              "practicalExample": "Para m=1 kg, b=2 Ns/m, k=10 N/m: x=[y,ẏ]^T, A=[[0,1],[-10,-2]], B=[[0],[1]], C=[1,0], D=0. TF: 1/(s^2 + 2s + 10). Verifique computando C(sI-A)^(-1)B = 1/(s^2 + 2s + 10).",
                              "finalVerifications": [
                                "Matrizes A, B, C, D corretas em termos simbólicos de m,b,k.",
                                "Equações ẋ e y escritas explicitamente sem erros.",
                                "Função de transferência derivada das matrizes coincide com a física.",
                                "Escolha de estado x=[y,ẏ]^T justificada e mínima.",
                                "Simulação numérica simples (ex: em MATLAB) reproduz resposta esperada.",
                                "Identificação correta de polos e zeros do sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação diferencial (100% dos termos corretos).",
                                "Correta seleção e justificativa das variáveis de estado (diminuição de ordem exata).",
                                "Construção impecável das matrizes A,B,C,D (sem erros algébricos).",
                                "Validação completa da TF com cálculo matricial.",
                                "Clareza na explicação e ausência de erros comuns.",
                                "Capacidade de aplicar a valores numéricos e interpretar resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de matrizes e determinantes.",
                                "Física Clássica: Leis de Newton para sistemas dinâmicos.",
                                "Controle Automático: Representações equivalentes de sistemas LTI.",
                                "Programação Numérica: Simulação em MATLAB/Simulink ou Python (SciPy).",
                                "Engenharia Aeronáutica: Modelagem de flutter em asas."
                              ],
                              "realWorldApplication": "Modelagem de vibrações em estruturas aeronáuticas, como amortecedores de trem de pouso ou controle de oscilações em hélices, permitindo simulações de estabilidade e design de controladores PID."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1",
                              "10.1.7.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Converter função de transferência para espaço de estados",
                            "description": "Utilizar formas canônicas (controlável ou observável) para transformar G(s) = 1/(ms² + bs + k) em representação de estado, comparando diferentes realizações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Função de Transferência e Conceitos de Espaço de Estados",
                                  "subSteps": [
                                    "Identifique a função de transferência G(s) = 1/(m s² + b s + k) como um sistema mecânico de segunda ordem (massa-mola-amortecedor).",
                                    "Lembre as equações de estado: ẋ = A x + B u, y = C x + D u.",
                                    "Defina estados x1 (posição), x2 (velocidade) para representação física.",
                                    "Explique formas canônicas: controlável (Companion) e observável."
                                  ],
                                  "verification": "Escreva as definições corretas de G(s), estados e formas canônicas em um papel ou ferramenta digital.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Livro ou notas de Sinais e Sistemas Dinâmicos"
                                  ],
                                  "tips": "Use diagramas para visualizar o sistema massa-mola-amortecedor.",
                                  "learningObjective": "Compreender a estrutura da FT e sua relação com modelos de estado.",
                                  "commonMistakes": [
                                    "Confundir ordem do sistema",
                                    "Ignorar D=0 para sistemas próprios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e Preparar Parâmetros para Forma Controlável Canônica",
                                  "subSteps": [
                                    "Atribua valores simbólicos: a2 = b/m, a1 = k/m para G(s) = 1/(s² + a2 s + a1).",
                                    "Defina matriz A na forma Companion controlável: [[0,1], [-a1, -a2]].",
                                    "Defina B = [[0],[1]], C = [1,0] para saída como posição, D=0.",
                                    "Verifique minimalidade: rank([B, AB]) = 2 para controlabilidade."
                                  ],
                                  "verification": "Escreva as matrizes A, B, C, D simbólicas e compute AB para confirmar controlabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy ou MATLAB",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Normalize dividindo por m para simplificar coeficientes.",
                                  "learningObjective": "Preparar matrizes na forma controlável canônica.",
                                  "commonMistakes": [
                                    "Erro nos sinais dos polos",
                                    "Esquecer normalização por m"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Representação na Forma Observável Canônica",
                                  "subSteps": [
                                    "Defina A na forma observável: [[-a2,1], [-a1,0]].",
                                    "Defina C = [1,0], B = [[0],[1]] para entrada em velocidade.",
                                    "Verifique observabilidade: rank([C; CA]) = 2.",
                                    "Compare com forma controlável: transposta em alguns casos."
                                  ],
                                  "verification": "Escreva matrizes para forma observável e compute CA para observabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SymPy ou MATLAB para matrizes",
                                    "Tabela comparativa em Excel"
                                  ],
                                  "tips": "Use transposta de Companion para alternar entre formas.",
                                  "learningObjective": "Construir e diferenciar formas observável e controlável.",
                                  "commonMistakes": [
                                    "Confundir B e C entre formas",
                                    "Erros em off-diagonais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Realizações e Verificar Equivalência",
                                  "subSteps": [
                                    "Simule resposta ao degrau para ambas formas usando software.",
                                    "Compare eigenvalores de A: devem ser raízes de s² + a2 s + a1 = 0.",
                                    "Analise vantagens: controlável para síntese de controladores, observável para estimadores.",
                                    "Teste com valores numéricos: m=1, b=2, k=1."
                                  ],
                                  "verification": "Plot das respostas coincidem e eigenvalores iguais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Gráficos de resposta"
                                  ],
                                  "tips": "Use ss() no MATLAB para criar sistemas de estado.",
                                  "learningObjective": "Comparar realizações e validar equivalência.",
                                  "commonMistakes": [
                                    "Escala errada em simulações",
                                    "Ignorar condições iniciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema com m=1 kg, b=1.4 Ns/m, k=1 N/m: G(s)=1/(s² + 1.4s +1). Forma controlável: A=[0 1; -1 -1.4], B=[0;1], C=[1 0]. Forma observável: A=[-1.4 1; -1 0], B=[0;1], C=[1 0]. Simule resposta ao degrau unitário e confirme picos idênticos.",
                              "finalVerifications": [
                                "Matrizes A têm os mesmos eigenvalores em ambas formas.",
                                "Respostas ao degrau simuladas coincidem graficamente.",
                                "Rank de controllability/observability matrix é 2.",
                                "Cálculo manual de ẋ e y bate com FT invertida.",
                                "Comparação tabular de coeficientes está correta."
                              ],
                              "assessmentCriteria": [
                                "Precisão simbólica nas matrizes (sem erros de sinal).",
                                "Correta identificação de formas canônicas.",
                                "Validação numérica via simulação.",
                                "Análise comparativa clara e fundamentada.",
                                "Uso adequado de ferramentas computacionais.",
                                "Explicação de minimalidade e propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Síntese de LQR na forma controlável.",
                                "Simulações Computacionais: Uso de MATLAB/Python para análise.",
                                "Mecânica Aeronáutica: Modelagem de flutter em asas.",
                                "Matemática Avançada: Teoria de Jordan para decomposição."
                              ],
                              "realWorldApplication": "Em Engenharia Aeronáutica, converte funções de transferência de vibrações em asas de aeronaves (modelo massa-mola para flutter) para espaço de estados, permitindo design de controladores ativos de estabilidade via LQR ou observadores Kalman em sistemas de fly-by-wire."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Analisar controllabilidade e observabilidade do modelo",
                            "description": "Calcular matrizes de controllabilidade [B, AB] e observabilidade [C; CA] para o sistema MSS, determinando se é possível controlar ou observar todos os modos dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Controllabilidade e Observabilidade",
                                  "subSteps": [
                                    "Recordar que um sistema é controlável se o vetor de controle pode levar o estado de qualquer ponto inicial para qualquer ponto desejado em tempo finito.",
                                    "Entender que observabilidade permite reconstruir o estado completo a partir das saídas medidas.",
                                    "Estudar as matrizes: Controllability matrix ℂ = [B, AB, A²B, ..., A^{n-1}B] e Observability matrix 𝒪 = [C; CA; CA²; ...; CA^{n-1}].",
                                    "Verificar condições: rank(ℂ) = n e rank(𝒪) = n para sistema de ordem n.",
                                    "Discutir modos dinâmicos e decomposição em Jordan para análise de controlabilidade/observabilidade por modo."
                                  ],
                                  "verification": "Resumir em um parágrafo as definições e condições de rank, confirmando com fórmulas escritas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de controle (ex: Ogata), notas de aula, calculadora simbólica.",
                                  "tips": "Use blocos de anotações para derivar as matrizes de um exemplo 2x2 simples.",
                                  "learningObjective": "Compreender conceitualmente controllabilidade e observabilidade em sistemas lineares invariantes no tempo (LTI).",
                                  "commonMistakes": "Confundir controllabilidade com estabilizabilidade; ignorar que rank deve ser exatamente n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Matriz de Controllabilidade",
                                  "subSteps": [
                                    "Identificar as matrizes A (n x n), B (n x m) do modelo state-space dado.",
                                    "Computar potências de A: AB, A²B, ..., até A^{n-1}B.",
                                    "Construir ℂ = [B | AB | ... | A^{n-1}B], uma matriz n x (n*m).",
                                    "Calcular o rank de ℂ usando decomposição em valores singulares (SVD) ou redução de linha.",
                                    "Identificar subespaços controláveis se rank < n."
                                  ],
                                  "verification": "Verificar se as dimensões de ℂ estão corretas e rank computado matches com ferramentas como MATLAB rank().",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software MATLAB/Python (control toolbox ou numpy/scipy), papel quadriculado.",
                                  "tips": "Para sistemas pequenos (n≤4), calcule manualmente; use ctrb() no MATLAB para validação.",
                                  "learningObjective": "Construir e computar rank da matriz de controllabilidade para um sistema MSS dado.",
                                  "commonMistakes": "Erro na multiplicação matricial AB; esquecer termos até A^{n-1}B."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Controllabilidade dos Modos Dinâmicos",
                                  "subSteps": [
                                    "Calcular autovalores e autovetores de A para identificar modos.",
                                    "Verificar se todos os autovetores estão no subespaço controlável (imagem de ℂ).",
                                    "Usar forma canônica de controllabilidade para decompor o sistema.",
                                    "Determinar quais modos são controláveis e propor ações se não for.",
                                    "Documentar conclusão: sistema totalmente controlável ou não."
                                  ],
                                  "verification": "Listar modos controláveis/não controláveis com justificativa baseada em rank e autovalores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "MATLAB eig() ou sympy para autovalores, planilha para tracking.",
                                  "tips": "Se rank(ℂ)=n, todos os modos são controláveis; foque em casos marginais.",
                                  "learningObjective": "Interpretar resultados de controllabilidade em termos de modos dinâmicos do sistema.",
                                  "commonMistakes": "Assumir controlabilidade sem checar rank; confundir autovalores com modos observáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Matriz de Observabilidade e Analisar",
                                  "subSteps": [
                                    "Identificar matriz C (p x n) do modelo state-space.",
                                    "Computar CA, CA², ..., CA^{n-1}.",
                                    "Construir 𝒪 = [C; CA; ...; CA^{n-1}], matriz (p*n) x n.",
                                    "Calcular rank(𝒪) e verificar se = n.",
                                    "Analisar modos observáveis via autovetores no kernel de 𝒪."
                                  ],
                                  "verification": "Confirmar rank(𝒪)=n e listar modos observáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB obsv(), Python control.obsv, calculadora matricial.",
                                  "tips": "Transposta de controllabilidade é observabilidade do dual; valide com software.",
                                  "learningObjective": "Construir, computar rank e interpretar matriz de observabilidade.",
                                  "commonMistakes": "Erro na transposição implícita; multiplicações CA incorretas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir Análise Geral e Implicações",
                                  "subSteps": [
                                    "Resumir: controlável? observável? totalmente? parcialmente?",
                                    "Discutir implicações para design de controladores/observadores.",
                                    "Propor testes adicionais (ex: PBH test para modos específicos).",
                                    "Aplicar a um exemplo aeronáutico simples.",
                                    "Documentar relatório com matrizes, ranks e conclusões."
                                  ],
                                  "verification": "Gerar relatório de 1 página com todas as matrizes, ranks e conclusões corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto/LaTeX, exemplos de sistemas aeronáuticos.",
                                  "tips": "Use PBH: rank([λI-A, B])=n para modo λ controlável.",
                                  "learningObjective": "Integrar análises para avaliar viabilidade de controle/observação em MSS.",
                                  "commonMistakes": "Ignorar casos multi-input/multi-output (MIMO); generalizar SISO para MIMO."
                                }
                              ],
                              "practicalExample": "Considere um modelo state-space de um elevador de aeronave: A = [[0,1];[-1,-1.5]], B=[[0];[1]], C=[1,0]. Calcule ℂ = [B, AB] = [[0,1];[1,-0.5]], rank=2=n (controlável). 𝒪=[C;CA]=[[1,0];[0,1]], rank=2 (observável). Todos os modos são controláveis/observáveis, permitindo design de LQR.",
                              "finalVerifications": [
                                "Matrizes ℂ e 𝒪 construídas com dimensões corretas e cálculos precisos.",
                                "Rank de ℂ e 𝒪 computados corretamente (igual a n).",
                                "Identificação precisa de modos controláveis/observáveis.",
                                "Conclusões alinhadas com teoremas de Kalman.",
                                "Relatório documenta implicações para o sistema físico.",
                                "Validação cruzada com software (ex: MATLAB ctrb/obsv)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (sem erros aritméticos).",
                                "Correta interpretação de ranks e subespaços.",
                                "Análise de modos dinâmicos com autovalores.",
                                "Clareza no relatório e uso de notação padrão.",
                                "Aplicação conceitual a contextos reais.",
                                "Eficiência temporal e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Design de LQR/LQG requer controllabilidade/observabilidade.",
                                "Matemática Aplicada: Álgebra linear (rank, SVD, formas canônicas).",
                                "Engenharia Mecânica: Vibrações em estruturas aeronáuticas.",
                                "Processamento de Sinais: Reconstrução de estados via observadores."
                              ],
                              "realWorldApplication": "Em aeronaves, análise garante que atuadores (ex: superfícies de controle) possam estabilizar modos de flutter ou phugoid, e sensores reconstruam estados para autopilotos, evitando instabilidades catastróficas em flight control systems."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Modelagem de Sistemas Eletromecânicos",
                    "description": "Análise de motores e transformadores usando resposta ao impulso e convolução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Modelagem Matemática de Motores Eletromecânicos",
                        "description": "Derivação das equações diferenciais lineares que descrevem o comportamento dinâmico de motores DC, considerando acoplamento eletromecânico entre circuito elétrico e sistema mecânico.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Derivação das equações elétricas do motor DC",
                            "description": "Obter a equação diferencial do circuito de armadura do motor DC, incluindo tensão aplicada, resistência, indutância, constante de retro-força eletromotriz e corrente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes elétricos do circuito de armadura do motor DC",
                                  "subSteps": [
                                    "Desenhe o diagrama esquemático do circuito de armadura, incluindo a fonte de tensão aplicada (V_a)",
                                    "Marque a resistência da armadura (R_a) e a indutância da armadura (L_a)",
                                    "Inclua a força eletromotriz de retroação (e_b = K_e * ω), onde ω é a velocidade angular",
                                    "Identifique a corrente da armadura (i_a) como a variável principal",
                                    "Revise as unidades de cada componente (V em volts, R em ohms, L em henrys, etc.)"
                                  ],
                                  "verification": "Confirme que o diagrama inclui todos os quatro elementos principais e que as polaridades estão corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de desenho como Draw.io",
                                    "Diagrama de referência de motor DC de um livro-texto de eletromecânica"
                                  ],
                                  "tips": "Sempre desenhe o circuito com setas para corrente e polaridades positivas para tensões para evitar confusões de sinal.",
                                  "learningObjective": "Compreender a topologia elétrica do circuito de armadura e seus componentes fundamentais.",
                                  "commonMistakes": [
                                    "Esquecer a indutância L_a",
                                    "Confundir a direção da fem de retroação",
                                    "Ignorar a dependência da fem em ω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as tensões no circuito usando a Lei de Kirchhoff das Tensões (KVL)",
                                  "subSteps": [
                                    "Percorra o loop do circuito no sentido horário ou anti-horário, definindo uma direção consistente",
                                    "Some as quedas de tensão: tensão aplicada V_a menos queda em R_a (R_a * i_a), menos taxa de variação da corrente através de L_a (L_a * di_a/dt), menos fem de retroação e_b",
                                    "Escreva a soma das tensões ao redor do loop igual a zero: V_a - R_a i_a - L_a di_a/dt - e_b = 0",
                                    "Substitua e_b por K_e * ω para expressar em termos conhecidos",
                                    "Verifique a equação estática (di/dt=0 e ω=0) para validar: V_a = R_a i_a"
                                  ],
                                  "verification": "A equação KVL resultante deve balancear todas as tensões corretamente, sem erros de sinal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como MATLAB/SymPy",
                                    "Folha de exercícios com circuitos semelhantes"
                                  ],
                                  "tips": "Escolha uma direção de percurso e seja consistente; use a regra da mão direita para polaridades.",
                                  "learningObjective": "Aplicar corretamente a Lei de Kirchhoff das Tensões em um circuito com elementos dinâmicos.",
                                  "commonMistakes": [
                                    "Sinal errado na fem de retroação (deve se opor à tensão aplicada)",
                                    "Esquecer o sinal negativo nas quedas de tensão",
                                    "Confundir KVL com KCL"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a equação diferencial completa do circuito de armadura",
                                  "subSteps": [
                                    "Reorganize a equação KVL para isolar os termos dinâmicos: L_a di_a/dt + R_a i_a + K_e ω = V_a",
                                    "Identifique isso como uma equação diferencial de primeira ordem em i_a, com ω como entrada (ou forçamento)",
                                    "Discuta os coeficientes: L_a (inércia elétrica), R_a (resistência), K_e ω (acoplamento eletromecânico)",
                                    "Escreva a forma padrão: di_a/dt = (V_a - R_a i_a - K_e ω)/L_a",
                                    "Simule numericamente um caso simples com valores fixos para V_a e ω constantes"
                                  ],
                                  "verification": "A equação final deve ser L_a di_a/dt + R_a i_a + K_e ω = V_a, com todos os termos presentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação como LTSpice ou Python com SciPy",
                                    "Tabela de parâmetros típicos de motores DC"
                                  ],
                                  "tips": "Normalize a equação dividindo por L_a para destacar o termo di/dt.",
                                  "learningObjective": "Derivar e expressar a equação diferencial governante do circuito elétrico do motor DC.",
                                  "commonMistakes": [
                                    "Ordem errada dos termos",
                                    "Confundir constante de fem K_e com torque K_t",
                                    "Ignorar o acoplamento com ω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a equação derivada",
                                  "subSteps": [
                                    "Explique o significado físico de cada termo: tensão aplicada (entrada), resistiva (dissipação), indutiva (armazenamento), retroativa (feedback)",
                                    "Calcule o regime permanente (di/dt=0): i_a = (V_a - K_e ω)/R_a",
                                    "Compare com dados experimentais ou simulações de motores reais",
                                    "Discuta simplificações comuns (ex: negligenciar L_a para baixas frequências)",
                                    "Resolva analiticamente para ω constante usando método de fatores integrantes"
                                  ],
                                  "verification": "Capacidade de prever comportamento em regime permanente e transiente corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de simulação de corrente vs. tempo",
                                    "Referências bibliográficas como 'Electric Machinery' de Fitzgerald"
                                  ],
                                  "tips": "Sempre valide com casos limite: motor em parado (ω=0), velocidade constante.",
                                  "learningObjective": "Interpretar a equação diferencial no contexto físico e validar sua precisão.",
                                  "commonMistakes": [
                                    "Interpretar ω como velocidade linear em vez de angular",
                                    "Negligar efeitos de saturação em aplicações reais",
                                    "Confundir análise linear com não-linearidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone de vigilância aeronáutica, derive a equação para o motor DC que aciona as hélices. Com V_a = 12V, R_a = 2Ω, L_a = 0.01H, K_e = 0.05 V.s/rad, e ω = 100 rad/s em regime, calcule i_a permanente e simule a resposta transitória à aplicação súbita de V_a.",
                              "finalVerifications": [
                                "Pode desenhar corretamente o circuito de armadura com todos os componentes.",
                                "Escreve a equação KVL sem erros de sinal.",
                                "Formula a equação diferencial L_a di_a/dt + R_a i_a + K_e ω = V_a.",
                                "Calcula corretamente o regime permanente para valores dados.",
                                "Explica o papel da fem de retroação no controle de velocidade.",
                                "Simula e interpreta uma resposta transitória básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes e diagrama (30%)",
                                "Correção na aplicação de KVL e derivação da EDO (40%)",
                                "Interpretação física e validação com casos limite (20%)",
                                "Clareza na documentação e simulações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais lineares de primeira ordem e métodos de solução.",
                                "Física: Leis de circuitos elétricos (Ohm, Faraday) e eletromagnetismo.",
                                "Engenharia Mecânica: Acoplamento eletromecânico com equações de torque.",
                                "Controle Automático: Uso da equação em modelagem de laços de feedback.",
                                "Programação: Simulação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Modelagem de motores DC em sistemas de propulsão de aeronaves não tripuladas (drones), atuadores de flaps em aviões comerciais e sistemas de controle de atitude em satélites, permitindo simulações precisas para design de controladores PID e previsão de eficiência energética."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Derivação das equações mecânicas do motor DC",
                            "description": "Formular a equação de torque e movimento rotacional, relacionando torque eletromagnético, inércia, atrito viscoso, carga e velocidade angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão dos Princípios Fundamentais de Dinâmica Rotacional",
                                  "subSteps": [
                                    "Estude a segunda lei de Newton para rotação: τ = J α, onde τ é torque, J é momento de inércia e α é aceleração angular.",
                                    "Revise o conceito de velocidade angular ω = dθ/dt e aceleração angular α = dω/dt.",
                                    "Entenda os efeitos de atrito viscoso (B ω) e torque de carga (TL) como termos dissipativos.",
                                    "Desenhe um diagrama esquemático de um rotor rotacional destacando J, B e TL.",
                                    "Calcule exemplos simples de torque líquido em sistemas rotacionais ideais."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito os três princípios chave da dinâmica rotacional e forneça um exemplo numérico resolvido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Dinâmica (ex: Beer & Johnston)",
                                    "Folha de papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogias lineares (F=ma) para visualizar rotação (τ=Jα) para fixar conceitos.",
                                  "learningObjective": "Compreender as equações básicas de movimento rotacional e seus componentes.",
                                  "commonMistakes": [
                                    "Confundir velocidade angular ω com rotação θ",
                                    "Esquecer unidades consistentes (Nm para torque, rad/s para ω)",
                                    "Ignorar o sinal de termos dissipativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação dos Componentes Mecânicos no Motor DC",
                                  "subSteps": [
                                    "Descreva o rotor do motor DC como um corpo rígido com momento de inércia J.",
                                    "Identifique o atrito viscoso B, modelado como torque proporcional à velocidade ω.",
                                    "Defina o torque de carga TL como resistência externa aplicada ao eixo.",
                                    "Liste parâmetros típicos: J (kg m²), B (Nm s/rad), TL (Nm).",
                                    "Desenhe o diagrama de corpo livre (free-body diagram) do rotor destacando todos os torques."
                                  ],
                                  "verification": "Crie e rotule corretamente um diagrama de corpo livre do rotor com todos os torques envolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de motor DC impresso ou digital",
                                    "Software de desenho (ex: Draw.io)",
                                    "Notas de aula sobre motores DC"
                                  ],
                                  "tips": "Pense no rotor como uma roda de carro: J é massa/inércia, B é resistência do ar/óleo, TL é carga na estrada.",
                                  "learningObjective": "Mapear os elementos físicos do motor DC aos parâmetros mecânicos.",
                                  "commonMistakes": [
                                    "Confundir J com massa linear m",
                                    "Omitir o torque de carga TL no diagrama",
                                    "Usar unidades erradas para B (deve ser Nm/(rad/s))"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definição e Modelagem do Torque Eletromagnético",
                                  "subSteps": [
                                    "Explique o torque eletromagnético Te gerado pela interação corrente i e campo magnético: Te = Kt i, onde Kt é constante de torque.",
                                    "Discuta como Kt relaciona-se com parâmetros do motor (fluxo magnético, número de espiras).",
                                    "Compare Te com torques opostos: atrito e carga.",
                                    "Derive qualitativamente o equilíbrio: Te impulsiona, Bω e TL freiam.",
                                    "Calcule Kt a partir de dados de datasheet de um motor DC real."
                                  ],
                                  "verification": "Escreva a fórmula Te = Kt i e explique seu sinal positivo como torque motor.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Datasheet de motor DC (ex: modelo Maxon ou Faulhaber)",
                                    "Tabela de constantes de motor"
                                  ],
                                  "tips": "Kt é análogo à força em motores lineares; verifique consistência com Ke (constante de fem).",
                                  "learningObjective": "Relacionar o torque de entrada elétrica ao domínio mecânico.",
                                  "commonMistakes": [
                                    "Esquecer o sinal de Te (geralmente positivo)",
                                    "Confundir Kt com Ke sem notar Kt = Ke em SI",
                                    "Assumir Te constante independentemente de i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formulação da Equação Diferencial de Movimento Rotacional",
                                  "subSteps": [
                                    "Aplique a lei de Newton rotacional: soma de torques = J dω/dt.",
                                    "Escreva: J dω/dt = Te - B ω - TL.",
                                    "Substitua Te = Kt i: J dω/dt + B ω + TL = Kt i.",
                                    "Reorganize na forma padrão: J dω/dt + B ω = Kt i - TL.",
                                    "Verifique dimensionalmente todos os termos (todos em Nm)."
                                  ],
                                  "verification": "Derive e escreva a equação completa J \frac{dω}{dt} = K_t i - B ω - T_L a partir do diagrama de corpo livre.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha para derivações",
                                    "Software simbólico opcional (ex: SymPy online)"
                                  ],
                                  "tips": "Sempre equilibre torques motores (+) vs. dissipativos (-); teste com ω=0 (aceleração máxima).",
                                  "learningObjective": "Derivar a equação mecânica completa relacionando domínios elétrico e mecânico.",
                                  "commonMistakes": [
                                    "Erro de sinal nos torques (ex: +Bω)",
                                    "Esquecer dω/dt multiplicado por J",
                                    "Não isolar o termo derivativo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise, Linearização e Verificação da Equação",
                                  "subSteps": [
                                    "Analise o regime permanente: dω/dt=0 → ω = (Kt i - TL)/B.",
                                    "Discuta linearidade e condições para aproximações.",
                                    "Simule numericamente a resposta transitória com valores reais.",
                                    "Compare com equações elétricas para modelo completo.",
                                    "Teste sensibilidade a variações em J, B, Kt."
                                  ],
                                  "verification": "Resolva para ω_ss (estado estacionário) e plote uma simulação simples de ω(t).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy)",
                                    "Valores típicos: J=0.01 kgm², B=0.1 Nms/rad, Kt=0.05 Nm/A"
                                  ],
                                  "tips": "Use solvers numéricos para validar; comece com TL=0 para simplificar.",
                                  "learningObjective": "Validar e interpretar a equação em contextos dinâmicos.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades em TL",
                                    "Erro em unidades angulares (graus vs. radianos)",
                                    "Não verificar equilíbrio em t→∞"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone de vigilância aeronáutica, derive as equações para o motor DC que aciona as hélices. Use J=0.005 kgm² (rotor leve), B=0.02 Nms/rad (rolamentos), Kt=0.1 Nm/A. Simule a aceleração de ω de 0 a 1000 rpm sob i=2A e TL=0.01Nm (arrasto do ar), verificando tempo de subida.",
                              "finalVerifications": [
                                "Escreve corretamente a equação J dω/dt = Kt i - B ω - TL.",
                                "Identifica todos os parâmetros físicos e suas unidades.",
                                "Desenha diagrama de corpo livre preciso.",
                                "Calcula ω estacionária para valores dados.",
                                "Explica relação com equações elétricas.",
                                "Simula resposta transitória sem erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação (100% dos termos corretos com sinais).",
                                "Compreensão conceitual (explicação clara de cada torque).",
                                "Uso correto de unidades e dimensionalidade.",
                                "Criatividade no diagrama e análise qualitativa.",
                                "Aplicação prática via simulação ou cálculo numérico.",
                                "Identificação de erros comuns e limitações do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Integração com equação elétrica v = R i + L di/dt + Ke ω.",
                                "Controle Automático: Uso em laços de feedback para estabilização angular.",
                                "Programação: Implementação em Python/MATLAB para simulação dinâmica.",
                                "Física Geral: Analogia com circuitos RLC (mecânico-elétrico).",
                                "Engenharia de Materiais: Influência de J em designs de rotor leves."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, essa modelagem é essencial para o controle de atuadores em UAVs e aviões, permitindo simulações de estabilidade de voo, otimização de eficiência energética e design de controladores PID para resposta rápida em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Acoplamento eletromecânico no modelo do motor",
                            "description": "Estabelecer as relações de acoplamento entre variáveis elétricas (corrente e retro-força) e mecânicas (torque e velocidade), linearizando para pequenos sinais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações fundamentais do motor DC",
                                  "subSteps": [
                                    "Estude a equação do circuito elétrico: V = R i + L di/dt + e, onde e é a retro-força eletromotriz.",
                                    "Analise a equação mecânica: J dω/dt = T - T_l - B ω, onde T é o torque eletromagnético.",
                                    "Identifique as relações físicas: e = K_e ω e T = K_t i.",
                                    "Desenhe o diagrama esquemático do motor destacando variáveis elétricas e mecânicas.",
                                    "Calcule exemplos numéricos simples para constantes K_e e K_t."
                                  ],
                                  "verification": "Capacidade de escrever e explicar as quatro equações principais com suas variáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de referência em eletromecânica (ex: Fitzgerald)",
                                    "Caderno para anotações",
                                    "Calculadora"
                                  ],
                                  "tips": "Use convenções de sinal consistentes para evitar erros de sinal nas equações.",
                                  "learningObjective": "Compreender as equações constitutivas elétricas e mecânicas isoladas do motor DC.",
                                  "commonMistakes": [
                                    "Confundir K_e com K_t",
                                    "Ignorar o sinal da retro-força",
                                    "Esquecer o termo de inércia J"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer os termos de acoplamento eletromecânico",
                                  "subSteps": [
                                    "Substitua e = K_e ω na equação elétrica para mostrar acoplamento velocidade-corrente.",
                                    "Substitua T = K_t i na equação mecânica para mostrar acoplamento corrente-torque.",
                                    "Discuta o princípio físico: lei de Faraday para back-emf e interação Lorentz para torque.",
                                    "Escreva o sistema de equações acopladas em forma matricial.",
                                    "Verifique dimensionalmente as constantes de acoplamento (K_e em V*s/rad, K_t em N*m/A)."
                                  ],
                                  "verification": "Derivação correta das equações acopladas a partir das isoladas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de edição LaTeX ou MathType para equações",
                                    "Artigos sobre motores DC",
                                    "Vídeos tutoriais no YouTube sobre back-emf"
                                  ],
                                  "tips": "Lembre-se que em motores DC ideais, K_e = K_t em unidades SI.",
                                  "learningObjective": "Identificar e formular matematicamente os acoplamentos bidirecionais entre domínios elétrico e mecânico.",
                                  "commonMistakes": [
                                    "Omitir o acoplamento bidirecional",
                                    "Usar unidades inconsistentes",
                                    "Confundir torque com força"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o modelo não-linear completo",
                                  "subSteps": [
                                    "Combine todas as equações em um sistema diferencial não-linear: estado x = [i, ω].",
                                    "Escreva dx/dt = f(x, u), com u = V (tensão de entrada) e perturbações como T_l.",
                                    "Simule numericamente o modelo não-linear usando MATLAB/Simulink ou Python (SciPy).",
                                    "Plote respostas transitórias para entrada degrau em V.",
                                    "Analise estabilidade qualitativa do equilíbrio."
                                  ],
                                  "verification": "Implementação e simulação funcional do modelo não-linear com plots corretos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Python com bibliotecas NumPy/SciPy/Matplotlib",
                                    "Dados de um motor DC real (ex: datasheet)"
                                  ],
                                  "tips": "Escolha valores realistas: R=1Ω, L=0.01H, J=0.01kg*m², K_t=0.05.",
                                  "learningObjective": "Construir o modelo dinâmico completo destacando não-linearidades implícitas.",
                                  "commonMistakes": [
                                    "Linearizar prematuramente",
                                    "Erros em dx/dt",
                                    "Escala errada nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Linearizar o modelo para pequenos sinais",
                                  "subSteps": [
                                    "Defina ponto de operação (i_0, ω_0) resolvendo equações de estado estacionário.",
                                    "Compute a matriz Jacobiana A = df/dx |_{x0} e B = df/du |_{x0}.",
                                    "Escreva o modelo linearizado: δẋ = A δx + B δu.",
                                    "Calcule autovalores de A para analisar pólos do sistema.",
                                    "Compare simulações linear vs. não-linear para pequenos sinais."
                                  ],
                                  "verification": "Matrizes A e B corretas e análise de pólos realizada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Symbolic Toolbox ou SymPy",
                                    "Ferramenta de controle linear (ex: control toolbox)"
                                  ],
                                  "tips": "Use linearização em torno de ω_0 ≠ 0 para capturar acoplamento.",
                                  "learningObjective": "Aplicar linearização para pequenos sinais e obter modelo de estado linear.",
                                  "commonMistakes": [
                                    "Jacobiana errada nos termos de acoplamento",
                                    "Ponto de operação instável",
                                    "Ignorar B"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar o modelo linearizado",
                                  "subSteps": [
                                    "Implemente controlador simples (ex: PI) no modelo linear.",
                                    "Compare desempenho com modelo não-linear.",
                                    "Discuta impactos do acoplamento nos pólos (ex: damping via back-emf).",
                                    "Documente o modelo em relatório com equações e plots.",
                                    "Resolva exercício: ajuste parâmetros para matching com dados reais."
                                  ],
                                  "verification": "Relatório com validação numérica e interpretação física.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para controle",
                                    "Datasheet de motor aeronáutico"
                                  ],
                                  "tips": "Foque em aplicações aeronáuticas como atuadores de flaps.",
                                  "learningObjective": "Interpretar efeitos do acoplamento no comportamento dinâmico linearizado.",
                                  "commonMistakes": [
                                    "Sobrestimar validade da linearização",
                                    "Ignorar ruído",
                                    "Plots sem legendas"
                                  ]
                                }
                              ],
                              "practicalExample": "No contexto de um drone aeronáutico, modele o motor DC de um rotor principal: aplique tensão variável para controle de velocidade, observe como a back-emf limita a corrente em altas rotações e o torque acelera a hélice, linearize para sintetizar um controlador de atitude.",
                              "finalVerifications": [
                                "Deriva corretamente as equações de acoplamento e = K_e ω e T = K_t i.",
                                "Formula o modelo de estado não-linear dx/dt = f(x,u).",
                                "Computa com precisão a linearização A e B em ponto de operação.",
                                "Simula e compara respostas linear vs. não-linear para sinal pequeno.",
                                "Interpreta pólos: back-emf adiciona damping mecânico.",
                                "Aplica a um exemplo aeronáutico real."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das equações (100% correto).",
                                "Corretude da linearização (Jacobiana exata).",
                                "Qualidade das simulações (plots claros, escalas adequadas).",
                                "Profundidade da interpretação física do acoplamento.",
                                "Criatividade na aplicação prática.",
                                "Clareza do relatório (equações formatadas, estrutura lógica)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Faraday e Lorentz.",
                                "Controle Automático: Modelos de estado para síntese de controladores.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Engenharia Mecânica: Dinâmica rotacional.",
                                "Eletrônica: Circuitos RL com fontes dependentes."
                              ],
                              "realWorldApplication": "Em aeronáutica, modelagem de motores elétricos em UAVs/drones para controle de estabilidade, atuadores de superfícies de controle em aviões elétricos, e sistemas de propulsão híbrida, onde o acoplamento afeta eficiência e resposta dinâmica."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1",
                              "10.1.7.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Modelagem Matemática de Transformadores",
                        "description": "Desenvolvimento das equações lineares que modelam transformadores ideais e reais, focando em relações entre tensões, correntes e fluxos magnéticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Equações do circuito equivalente de transformadores",
                            "description": "Derivar o modelo em diagrama de blocos ou equações diferenciais para enrolamentos primário e secundário, incluindo resistências, indutâncias de fuga e magnetizante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão dos Princípios Básicos do Transformador",
                                  "subSteps": [
                                    "Estude o funcionamento físico do transformador: enrolamentos primário e secundário, núcleo ferromagnético e acoplamento magnético.",
                                    "Revise a lei de Faraday da indução eletromagnética e a relação entre tensões nos enrolamentos (V2/V1 ≈ n2/n1).",
                                    "Identifique perdas principais: perdas em cobre (resistências) e perdas no ferro (histerese e Foucault).",
                                    "Desenhe um diagrama esquemático simples do transformador ideal versus real.",
                                    "Calcule o coeficiente de acoplamento k entre os enrolamentos."
                                  ],
                                  "verification": "Desenhe e explique corretamente o diagrama básico do transformador, incluindo relações de tensão e fluxo magnético.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Eletrônica de Potência (ex: Erickson ou Mohan)",
                                    "Papel e caneta para diagramas",
                                    "Vídeos introdutórios sobre transformadores no YouTube ou Khan Academy"
                                  ],
                                  "tips": "Comece com o modelo ideal para construir intuição antes de adicionar realidades.",
                                  "learningObjective": "Compreender os fundamentos físicos que justificam o circuito equivalente.",
                                  "commonMistakes": [
                                    "Ignorar o acoplamento imperfeito (k<1)",
                                    "Confundir tensão induzida com tensão aplicada",
                                    "Esquecer perdas no núcleo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição dos Parâmetros do Circuito Equivalente",
                                  "subSteps": [
                                    "Defina os parâmetros primário: R1 (resistência do enrolamento primário), Lf1 (indutância de fuga primária), Lm (indutância magnetizante).",
                                    "Defina parâmetros secundário: R2, Lf2, e referencie ao primário usando o fator de transformação a = N1/N2 (R2' = R2 / a²).",
                                    "Inclua resistência do núcleo Rc em paralelo com Lm para modelar perdas ferromagnéticas.",
                                    "Desenhe o circuito equivalente aproximado T ou Π, mostrando ramais série e paralelo.",
                                    "Calcule valores típicos para um transformador de 1kVA, 220V/110V."
                                  ],
                                  "verification": "Liste e desenhe todos os componentes do circuito equivalente com símbolos corretos e relações de referência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação como LTSpice ou MATLAB/Simulink",
                                    "Folhas de cálculo para parâmetros",
                                    "Tabelas de dados de transformadores reais"
                                  ],
                                  "tips": "Use a aproximação de circuito referido ao primário para simplificar cálculos iniciais.",
                                  "learningObjective": "Identificar e quantificar todos os elementos parasitas no modelo equivalente.",
                                  "commonMistakes": [
                                    "Esquecer de referenciar o secundário ao primário",
                                    "Confundir Lf (fuga) com Lm (magnetizante)",
                                    "Ignorar Rc nas perdas do núcleo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação das Equações para o Enrolamento Primário",
                                  "subSteps": [
                                    "Escreva a equação de tensão no primário: V1(t) = R1 i1(t) + Lf1 di1/dt + dφ/dt, onde φ é o fluxo no magnetizante.",
                                    "Modele a corrente magnetizante im(t) ≈ V1 / (jωLm) no domínio da frequência, ou diferencial no tempo.",
                                    "Some a queda na indutância de fuga: V1 = i1 R1 + Lf1 di1/dt + Lm dim/dt.",
                                    "Inclua Rc: im = ic + if, onde ic = vm / Rc e if para Foucault.",
                                    "Transforme para domínio de Laplace: V1(s) = I1(s) (R1 + s Lf1) + s Lm Im(s)."
                                  ],
                                  "verification": "Derive e resolva as equações diferenciais para i1(t) e im(t) dadas V1(t) senoidal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SymPy para simbólico)",
                                    "Quadro branco para derivações",
                                    "Referência: 'Power Electronics' de Rashid"
                                  ],
                                  "tips": "Use a aproximação de baixa frequência onde Lm >> Lf para validar.",
                                  "learningObjective": "Derivar equações precisas para tensões e correntes no primário.",
                                  "commonMistakes": [
                                    "Negligar termos derivados di/dt",
                                    "Confundir correntes de fuga e magnetizante",
                                    "Erros em transformadas de Laplace"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivação das Equações para o Enrolamento Secundário e Modelo Completo",
                                  "subSteps": [
                                    "Escreva equações secundário: V2(t) = -R2 i2(t) - Lf2 di2/dt - dφ/dt (sinal oposto pela direção).",
                                    "Relacione fluxos: φ = Lm (i1 - i2') onde i2' = a i2.",
                                    "Combine primário e secundário: i1 = i_fuga1 + im + i2'.",
                                    "Obtenha equações acopladas diferenciais para i1 e i2.",
                                    "Valide com circuito T-equivalente completo."
                                  ],
                                  "verification": "Resolva o sistema de equações para um transformador carregado com R_L no secundário.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para modelagem dinâmica",
                                    "Exercícios resolvidos de livros de máquinas elétricas",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Teste com carga resistiva pura para comparar com modelo ideal.",
                                  "learningObjective": "Integrar modelos de ambos os enrolamentos em um sistema coeso.",
                                  "commonMistakes": [
                                    "Sinal errado na tensão secundária",
                                    "Fator de escala incorreto para referência",
                                    "Não acoplar corretamente os fluxos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Representação em Diagrama de Blocos e Equações Diferenciais",
                                  "subSteps": [
                                    "Converta o circuito equivalente para diagrama de blocos no domínio s: blocos para R, sL, soma de correntes.",
                                    "Desenhe blocos em série para impedâncias e paralelo para magnetizante.",
                                    "Escreva equações diferenciais de estado: defina estados como i1, i2, φ.",
                                    "Simule resposta transitória a uma entrada degrau em V1.",
                                    "Compare simulação com medidas teóricas de regime permanente."
                                  ],
                                  "verification": "Construa e simule o diagrama de blocos, obtendo gráficos de correntes que batem com equações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Simulink ou Python Control Systems Library",
                                    "Templates de diagramas de blocos",
                                    "Dados experimentais de transformadores"
                                  ],
                                  "tips": "Use feedback negativo para o acoplamento mutuo nos blocos.",
                                  "learningObjective": "Transformar o modelo elétrico em forma adequada para análise de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Blocos invertidos para secundário",
                                    "Esquecer ganhos de transformação",
                                    "Instabilidade numérica em simulações"
                                  ]
                                }
                              ],
                              "practicalExample": "Modele um transformador de distribuição aeronáutico de 400Hz, 115V/26V usado em aviões: R1=0.5Ω, Lf1=1mH, Lm=100mH, R2'=1Ω, Lf2'=2mH. Simule em Simulink a resposta a uma falha de curto no secundário, derivando equações para prever correntes de pico e diagramas de blocos para controle de proteção.",
                              "finalVerifications": [
                                "Deriva corretamente as equações diferenciais acopladas para i1(t) e i2(t).",
                                "Desenha o circuito equivalente T com todos os parâmetros referenciados.",
                                "Constrói diagrama de blocos funcional no domínio s.",
                                "Simula e interpreta resposta transitória corretamente.",
                                "Calcula eficiência e regulação de tensão para um caso dado.",
                                "Explica impacto de variações em Lm ou Lf."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de equações (sem erros algébricos).",
                                "Correção dos diagramas esquemáticos e de blocos.",
                                "Profundidade dos subpassos e justificativas físicas.",
                                "Validação numérica via simulação (erros <5%).",
                                "Identificação de erros comuns e mitigações.",
                                "Integração com contexto de sistemas dinâmicos."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica de Potência: Simulação em conversores DC-DC.",
                                "Controle de Sistemas: Uso do modelo para loops de realimentação em servos.",
                                "Engenharia Aeronáutica: Modelagem de atuadores eletromecânicos em flight controls.",
                                "Matemática Aplicada: Solução de EDOs lineares acopladas.",
                                "Física: Eletromagnetismo avançado e leis de Maxwell."
                              ],
                              "realWorldApplication": "Em aeronáutica, esses modelos são usados para projetar sistemas de potência em aviões (ex: TRUs - Transformer Rectifier Units), prever surtos em falhas elétricas, otimizar eficiência em geradores de bordo e integrar com controles fly-by-wire, garantindo segurança em ambientes de alta vibração e temperatura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Linearização do modelo de transformadores reais",
                            "description": "Aplicar linearização em torno de um ponto de operação para obter modelo linear invariante no tempo, considerando saturação magnética aproximada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo não-linear do transformador real",
                                  "subSteps": [
                                    "Identificar as equações diferenciais não-lineares que descrevem o transformador, incluindo o fluxo magnético φ(i) e a saturação.",
                                    "Derivar a relação entre tensão, corrente e fluxo considerando perdas no núcleo e enrolamentos.",
                                    "Expressar o modelo em termos de variáveis de estado, como correntes i1, i2 e fluxos φ1, φ2.",
                                    "Analisar a dependência não-linear da permeabilidade μ devido à saturação magnética.",
                                    "Esboçar curvas B-H para visualizar a saturação aproximada."
                                  ],
                                  "verification": "Capacidade de escrever e explicar as equações não-lineares completas do transformador em um ponto genérico.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Equações de referência de transformadores",
                                    "Gráficos B-H de materiais magnéticos",
                                    "Software de plotagem como MATLAB ou Python"
                                  ],
                                  "tips": "Comece com o modelo ideal e adicione não-linearidades gradualmente para evitar confusão.",
                                  "learningObjective": "Dominar as equações não-lineares fundamentais do transformador real com saturação magnética.",
                                  "commonMistakes": [
                                    "Ignorar acoplamento mútuo entre enrolamentos",
                                    "Confundir tensão induzida com tensão de alimentação",
                                    "Negligenciar resistências parasitas desde o início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e definir o ponto de operação (bias point)",
                                  "subSteps": [
                                    "Escolher correntes de bias I1q, I2q e fluxos Φ1q, Φ2q baseados em condições de operação típicas (ex: 50% da corrente nominal).",
                                    "Calcular o ponto de operação considerando eficiência e evitar saturação profunda.",
                                    "Linearizar a curva de saturação magnética localmente em torno do ponto Φq usando uma reta tangente.",
                                    "Determinar parâmetros pequenos como Δi1, Δi2, Δφ1, Δφ2 para perturbações.",
                                    "Verificar estabilidade do ponto com simulações iniciais."
                                  ],
                                  "verification": "O ponto de operação é definido com valores numéricos realistas e a tangente à curva B-H é plotada corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados de folha de transformador real",
                                    "Ferramentas de cálculo numérico (Excel ou Python)",
                                    "Curvas de saturação do fabricante"
                                  ],
                                  "tips": "Escolha um ponto onde a saturação é moderada para melhor precisão linear.",
                                  "learningObjective": "Selecionar adequadamente um ponto de operação que equilibre linearidade e realismo.",
                                  "commonMistakes": [
                                    "Escolher ponto em saturação total, invalidando linearização",
                                    "Usar correntes DC sem considerar ripple AC",
                                    "Ignorar assimetrias entre enrolamentos primário e secundário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar linearização em torno do ponto de operação",
                                  "subSteps": [
                                    "Realizar expansão de Taylor de primeira ordem das funções não-lineares em torno do bias point.",
                                    "Derivar as equações lineares small-signal: dφ/dt = L_eq * di/dt + termos de acoplamento.",
                                    "Obter matrizes de estado A, B, C, D para o modelo linear invariante no tempo.",
                                    "Incorporar aproximação linear da saturação: μ_eq = dB/dH no ponto q.",
                                    "Simplificar para modelo equivalente com indutâncias lineares L1q, L2q, Mq."
                                  ],
                                  "verification": "Equações lineares derivadas coincidem com simulações small-signal e são independentes do tempo.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "MATLAB/Simulink para validação simbólica",
                                    "Referências de teoria de linearização (ex: Ogata Systems)"
                                  ],
                                  "tips": "Use notação small-signal (minúsculas) consistentemente para evitar erros de sinal.",
                                  "learningObjective": "Executar linearização matemática precisa para converter modelo não-linear em linear.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais da expansão de Taylor",
                                    "Confundir variáveis de estado quiescentes com small-signal",
                                    "Omitir termos de acoplamento mútuo na matriz A"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar o modelo linearizado considerando saturação aproximada",
                                  "subSteps": [
                                    "Simular o modelo não-linear e linear em resposta a pequenas perturbações e comparar.",
                                    "Ajustar parâmetros para matching em frequência (ganho e fase).",
                                    "Analisar limites de validade da linearização (amplitude máxima de sinal).",
                                    "Incorporar efeitos de saturação aproximada via indutâncias variáveis.",
                                    "Documentar o modelo final com equações e diagrama de blocos."
                                  ],
                                  "verification": "Simulações mostram erro <5% em regime small-signal por pelo menos 3 ciclos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Simulink ou PSpice para simulação",
                                    "Dados experimentais de transformador",
                                    "Ferramentas de análise de Bode"
                                  ],
                                  "tips": "Teste com senoides de baixa amplitude primeiro para confirmar linearidade.",
                                  "learningObjective": "Validar e documentar o modelo linear para uso em análise de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Validar com sinais grandes que violam hipótese small-signal",
                                    "Ignorar discrepâncias em altas frequências",
                                    "Não quantificar o range de validade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um conversor DC-DC boost para alimentação de atuadores em aeronaves, linearize o transformador de alta frequência em torno de I1q=2A, Φ1q=0.5Wb, obtendo L1q=10mH e Mq=8mH, permitindo análise de estabilidade via diagrama de Bode.",
                              "finalVerifications": [
                                "Modelo linear é invariante no tempo e depende apenas do bias point.",
                                "Simulações small-signal coincidem com não-linear em <10% erro.",
                                "Matrizes A, B derivadas corretamente das parciais jacobianas.",
                                "Aproximação de saturação incorporada via μ_eq tangente.",
                                "Limites de validade documentados (ex: |Δi| < 20% I_q).",
                                "Diagrama equivalente linear desenhado e funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas (sem erros algébricos).",
                                "Escolha adequada do ponto de operação (evitando saturação extrema).",
                                "Qualidade da validação via simulação (gráficos comparativos).",
                                "Documentação clara com unidades e suposições.",
                                "Incorporação correta da saturação aproximada.",
                                "Capacidade de explicar limitações do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansão de Taylor e análise de linearização multivariable.",
                                "Eletrônica de Potência: Modelos small-signal em conversores.",
                                "Controle Automático: Uso em análise de laços de realimentação.",
                                "Física: Propriedades magnéticas e curvas B-H.",
                                "Programação: Simulações numéricas em MATLAB/Python."
                              ],
                              "realWorldApplication": "Na aviação, modelagem linearizada de transformadores em fontes de alimentação de aviônicos permite design de controladores estáveis para gerenciar flutuações de carga em motores elétricos ou sistemas de fly-by-wire, garantindo segurança e eficiência energética."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Representação em espaço de estados para transformadores",
                            "description": "Converter o modelo em forma de espaço de estados, definindo vetor de estado com correntes e fluxos, matrizes A, B, C e D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo elétrico equivalente do transformador",
                                  "subSteps": [
                                    "Desenhe o circuito equivalente do transformador com enrolamentos primário e secundário, incluindo resistências R1, R2, indutâncias de fuga L1σ, L2σ e indutância mútua Lm.",
                                    "Identifique as tensões de entrada v1(t) e saída v2(t), correntes i1(t) e i2(t), e fluxos de ligação ψ1 e ψ2.",
                                    "Escreva as equações de tensão para cada enrolamento: v1 = R1 i1 + dψ1/dt, v2 = R2 i2 + dψ2/dt.",
                                    "Expresse os fluxos em termos de correntes: ψ1 = L1σ i1 + Lm i2, ψ2 = Lm i1 + L2σ i2.",
                                    "Confirme as relações constitutivas assumindo acoplamento ideal ou com perdas."
                                  ],
                                  "verification": "Circuito desenhado corretamente com todas as componentes e equações de tensão anotadas sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software de diagramação como Draw.io",
                                    "Referência: Livro de Eletrônica de Potência ou notas de aula sobre transformadores"
                                  ],
                                  "tips": "Comece pelo lado primário e adicione o secundário gradualmente para evitar confusão.",
                                  "learningObjective": "Compreender a topologia elétrica e as equações básicas do transformador.",
                                  "commonMistakes": [
                                    "Esquecer indutâncias de fuga",
                                    "Confundir polaridades dos enrolamentos",
                                    "Ignorar resistências parasitas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o vetor de estado apropriado",
                                  "subSteps": [
                                    "Escolha variáveis de estado: tipicamente x = [i1, i2, ψm]^T ou x = [ψ1, ψ2]^T, dependendo do modelo (use correntes e fluxo mútuo para simplicidade).",
                                    "Justifique a escolha: variáveis que capturam a dinâmica interna (correntes nos enrolamentos e fluxo de ligação).",
                                    "Defina entradas u = [v1, v2]^T e saídas y = [i1, v2]^T ou similar.",
                                    "Escreva o vetor x explicitamente com dimensões (ex: 3x1 para dois enrolamentos + fluxo).",
                                    "Verifique independência das variáveis de estado."
                                  ],
                                  "verification": "Vetor x definido com 2-3 elementos relevantes e justificado em termos de minimalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de cálculo ou MATLAB/Simulink para prototipagem",
                                    "Tabela de parâmetros do transformador exemplo"
                                  ],
                                  "tips": "Prefira estados mínimos; evite redundâncias como usar ambas correntes e fluxos se linearmente dependentes.",
                                  "learningObjective": "Selecionar variáveis de estado que representem fielmente a dinâmica do sistema.",
                                  "commonMistakes": [
                                    "Escolher tensão como estado em vez de corrente/fluxo",
                                    "Usar mais estados que o necessário",
                                    "Ignorar acoplamento mútua"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as equações diferenciais do sistema",
                                  "subSteps": [
                                    "Substitua os fluxos nas equações de tensão para obter dψ1/dt e dψ2/dt em termos de i1, i2, v1, v2.",
                                    "Resolva para as derivadas dos estados: dx/dt = f(x, u).",
                                    "Para x = [i1, i2]^T, derive di1/dt e di2/dt considerando inversa da matriz de indutância.",
                                    "Inclua termos resistivos: di/dt = L^{-1} (-R i + v).",
                                    "Escreva explicitamente as equações lineares: dx/dt = A x + B u."
                                  ],
                                  "verification": "Equações dx/dt derivadas corretamente, balanceadas e lineares.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica como SymPy ou MATLAB Symbolic Toolbox",
                                    "Parâmetros numéricos para validação"
                                  ],
                                  "tips": "Use matriz de indutância L = [[L1σ + Lm, Lm], [Lm, L2σ + Lm]] e inverta-a manualmente primeiro.",
                                  "learningObjective": "Transformar equações físicas em forma diferencial linear.",
                                  "commonMistakes": [
                                    "Erro na inversão da matriz de indutância",
                                    "Sinal errado nos termos resistivos",
                                    "Confundir v1 e v2 nas derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e identificar as matrizes A, B, C e D",
                                  "subSteps": [
                                    "Extraia coeficientes de dx/dt = A x + B u para formar matriz A (dinâmica interna) e B (controle).",
                                    "Defina equações de saída: y = C x + D u (ex: y = i1 para medição de corrente primária).",
                                    "Para transformador ideal, D=0; inclua se houver alimentação direta.",
                                    "Escreva as matrizes explicitamente com símbolos ou valores numéricos.",
                                    "Verifiche dimensões: A (nxn), B (nxm), C (pyxn), D (pym)."
                                  ],
                                  "verification": "Matrizes A, B, C, D com dimensões corretas e coeficientes matching as equações derivadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de álgebra linear como MATLAB ou Python NumPy",
                                    "Template de matrizes vazias"
                                  ],
                                  "tips": "Teste com u=0: eigenvalues de A devem refletir frequências naturais do transformador.",
                                  "learningObjective": "Construir representação padrão de espaço de estados a partir de equações.",
                                  "commonMistakes": [
                                    "Transpor linhas/colunas nas matrizes",
                                    "Esquecer termos de acoplamento em A",
                                    "D não zero indevidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e simular a representação",
                                  "subSteps": [
                                    "Implemente o modelo em software: dx/dt = A x + B u; integre numericamente.",
                                    "Aplique entrada degrau em v1 e compare resposta transitória com simulação circuito.",
                                    "Calcule polos via eig(A) e verifique estabilidade.",
                                    "Teste observabilidade e controlabilidade se aplicável.",
                                    "Ajuste parâmetros se discrepâncias >5%."
                                  ],
                                  "verification": "Simulação converge e matches modelo original em pelo menos 3 cenários.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy odeint)",
                                    "Dados experimentais ou modelo SPICE de referência"
                                  ],
                                  "tips": "Use solver rígido para dinâmicas rápidas; plote i1(t), i2(t) vs tempo.",
                                  "learningObjective": "Verificar fidelidade da representação de espaço de estados.",
                                  "commonMistakes": [
                                    "Escala errada no tempo de simulação",
                                    "Condições iniciais x0=0 inadequadas",
                                    "Ignorar numérica instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um transformador com R1=0.1Ω, R2=0.2Ω, L1σ=1mH, L2σ=1mH, Lm=100mH, aplique v1=10V degrau, v2=0. Vetor x=[i1,i2]^T, A = L^{-1} [-R + acoplamentos], simule e verifique i1 estabiliza em ~100A.",
                              "finalVerifications": [
                                "Vetor de estado inclui correntes e/ou fluxos corretos (dimensão mínima).",
                                "Matriz A captura acoplamento mútuo via off-diagonais não-zero.",
                                "Equações de saída y=Cx+Du matches grandezas físicas mensuráveis.",
                                "Simulação numérica reproduz resposta esperada do circuito equivalente.",
                                "Sistema é estável (polos reais negativos ou complexos com parte real negativa).",
                                "Dimensões das matrizes são consistentes (A: nxn, etc.)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas (sem erros algébricos >1%).",
                                "Correção na escolha e justificativa do vetor de estado.",
                                "Matrizes A,B,C,D explicitamente corretas e dimensionalmente consistentes.",
                                "Validação via simulação com erro <5% vs modelo referência.",
                                "Explicação clara de cada passo com avoidance de erros comuns.",
                                "Uso adequado de ferramentas e materiais listados."
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso das matrizes para síntese de controladores LQR ou observadores.",
                                "Eletrônica de Potência: Modelagem para conversores DC-DC com transformadores.",
                                "Física Eletromagnetismo: Relação com leis de Faraday e Ampère.",
                                "Programação Numérica: Implementação em MATLAB/Python para análise dinâmica.",
                                "Engenharia Aeronáutica: Simulação de sistemas de potência em aeronaves."
                              ],
                              "realWorldApplication": "Em aeronaves, modela transformadores em fontes de alimentação de aviônicos, permitindo simulações de falhas transitórias, design de proteções e integração com sistemas de controle de voo para estabilidade em condições de turbulência ou falhas elétricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1",
                              "10.1.7.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Análise via Resposta ao Impulso e Convolução",
                        "description": "Aplicação da resposta ao impulso h(t) e integral de convolução para determinar a resposta de sistemas eletromecânicos a entradas arbitrárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Cálculo da resposta ao impulso de motores e transformadores",
                            "description": "Determinar h(t) resolvendo as equações diferenciais com entrada delta de Dirac, usando função de transferência ou Laplace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelagem Matemática de Motores e Transformadores",
                                  "subSteps": [
                                    "Identifique as variáveis principais: tensão de entrada v(t), corrente i(t), velocidade angular ω(t), torque T(t).",
                                    "Escreva as equações diferenciais do circuito elétrico: L di/dt + R i = v(t) - K ω.",
                                    "Escreva a equação mecânica: J dω/dt + b ω = K i.",
                                    "Combine em uma equação diferencial de segunda ordem para o sistema eletromecânico.",
                                    "Verifique linearidade e condições iniciais zero para análise em regime."
                                  ],
                                  "verification": "Confirme que a equação diferencial de segunda ordem está correta comparando com modelos padrão de motores DC ou transformadores.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Sistemas Dinâmicos (ex: Ogata)",
                                    "Papel e calculadora",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": [
                                    "Comece com diagrama de corpo livre para visualizar forças/torques.",
                                    "Use convenções de sinal consistentes para K (constante de contrapropulsão)."
                                  ],
                                  "learningObjective": "Derivar com precisão as equações diferenciais que modelam o comportamento dinâmico de motores e transformadores.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na contrapropulsão Kω.",
                                    "Confundir parâmetros mecânicos (J, b) com elétricos (L, R).",
                                    "Não considerar condições iniciais zero."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição da Função de Transferência H(s)",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace às equações diferenciais assumindo condições iniciais zero.",
                                    "Expresse a saída desejada (ex: ω(s)) em termos da entrada V(s).",
                                    "Elimine variáveis intermediárias (ex: I(s)) para obter H(s) = ω(s)/V(s).",
                                    "Simplifique a fração racional H(s) = K / (s² + a s + b).",
                                    "Identifique polos e zeros para análise de estabilidade."
                                  ],
                                  "verification": "Calcule H(s) e verifique se o ganho em DC (s=0) corresponde ao estado estacionário esperado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas de Laplace",
                                    "MATLAB ou Python (control library)",
                                    "Folha de exercícios de ED"
                                  ],
                                  "tips": [
                                    "Use o método de eliminação sistemática de variáveis.",
                                    "Fatore o denominador para identificar frequências naturais."
                                  ],
                                  "learningObjective": "Obter a função de transferência H(s) a partir das equações diferenciais do sistema.",
                                  "commonMistakes": [
                                    "Erro de sinal ao aplicar Laplace em di/dt.",
                                    "Dividir incorretamente por V(s) ao invés de isolar.",
                                    "Ignorar termos de contrapropulsão no numerador."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo da Resposta ao Impulso h(t) via Transformada de Laplace",
                                  "subSteps": [
                                    "A resposta ao impulso é h(t) = L⁻¹ {H(s)}, onde a entrada é δ(t) e L{δ(t)}=1.",
                                    "Expanda H(s) em frações parciais: H(s) = A/s + (Bs + C)/(s² + 2ζω s + ω²).",
                                    "Aplique a transformada inversa de Laplace usando tabelas padrão.",
                                    "Expresse h(t) em termos de exponenciais e senos/cossenos para sistemas subamortecidos.",
                                    "Plote h(t) numericamente para visualização."
                                  ],
                                  "verification": "Integre h(t) de 0 a ∞ e confirme que ∫h(t)dt = H(0), pelo teorema do valor final.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de transformadas de Laplace",
                                    "MATLAB/Simulink para plotar h(t)",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": [
                                    "Para frações parciais, cubra termos adequadamente.",
                                    "Use resíduos para polos complexos se avançado."
                                  ],
                                  "learningObjective": "Calcular explicitamente h(t) como a inversa Laplace de H(s).",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/(2π) em alguns contextos (não para Laplace unilateral).",
                                    "Erro em frações parciais com polos repetidos.",
                                    "Não multiplicar por u(t), a função degrau unitário."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação Alternativa e Análise via Equação Diferencial Direta",
                                  "subSteps": [
                                    "Resolva a ED diretamente com entrada δ(t): y'' + a y' + b y = δ(t).",
                                    "Use condições de salto: y(0⁺)=0, y'(0⁺)=1 para sistemas de segunda ordem.",
                                    "Compare a solução h(t) com a obtida via Laplace.",
                                    "Analise propriedades: tempo de subida, overshoot via h(t).",
                                    "Simule em software para validar."
                                  ],
                                  "verification": "As duas soluções h(t) (Laplace vs. ED direta) coincidem numericamente em pontos chave.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Simulador como Simulink ou Python (scipy.signal)",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": [
                                    "Lembre que δ(t) causa salto na derivada mais alta.",
                                    "Use simulação para depurar erros analíticos."
                                  ],
                                  "learningObjective": "Validar o cálculo de h(t) por métodos alternativos e analisar suas propriedades dinâmicas.",
                                  "commonMistakes": [
                                    "Condições iniciais erradas pós-impulso.",
                                    "Confundir resposta ao impulso com resposta ao degrau.",
                                    "Ignorar amortecimento na forma analítica."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com L=0.1 H, R=1 Ω, K=0.1 Nm/A, J=0.01 kgm², b=0.1 Nms/rad: derive H(s) = ω(s)/V(s) ≈ 1/(s² + 20s + 1000), então h(t) = L⁻¹{H(s)} ≈ 31.6 e^{-10t} sin(30t) u(t). Simule em MATLAB para verificar picos e decaimento.",
                              "finalVerifications": [
                                "h(t) possui unidades corretas (ex: rad/s por Volt).",
                                "∫h(t)dt de 0 a ∞ = H(0), ganho estático.",
                                "Solução converge para zero (estável).",
                                "Simulação numérica coincide com analítica em 95%.",
                                "Análise de polos confirma amortecimento e frequência natural.",
                                "Resposta ao degrau é convolução com u(t), verificada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de H(s) e h(t) (sem erros algébricos).",
                                "Correta aplicação de Laplace e frações parciais.",
                                "Análise qualitativa de propriedades dinâmicas (overshoot, tempo de assentamento).",
                                "Validação cruzada entre métodos analítico e numérico.",
                                "Clareza na apresentação de passos e justificativas.",
                                "Correção de unidades e condições iniciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e resolução de ED lineares.",
                                "Física: Leis de Kirchhoff e Newton para sistemas eletromecânicos.",
                                "Engenharia de Controle: Uso de h(t) em convolução para respostas arbitrárias.",
                                "Processamento de Sinais: Resposta ao impulso como base para filtros.",
                                "Engenharia Aeronáutica: Modelagem de atuadores em sistemas de voo."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a resposta ao impulso h(t) de motores elétricos em atuadores de superfícies de controle permite prever respostas a comandos rápidos (impulsos), essencial para design de sistemas de controle fly-by-wire estáveis e certificados pela FAA, evitando oscilações em manobras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.3",
                              "10.1.7.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Aplicação da convolução para resposta a entradas arbitrárias",
                            "description": "Calcular y(t) = x(t) * h(t) para entradas como degrau ou rampa em modelos de motores e transformadores, interpretando transientes e estacionário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Conceitos Fundamentais de Convolução e Resposta ao Impulso",
                                  "subSteps": [
                                    "Defina a convolução contínua: y(t) = ∫_{-∞}^{∞} x(τ) h(t - τ) dτ",
                                    "Explique o significado físico de h(t) como resposta ao impulso do sistema",
                                    "Identifique entradas básicas: degrau unitário u(t) e rampa t u(t)",
                                    "Discuta propriedades da convolução: comutatividade, associatividade",
                                    "Relacione com decomposição de x(t) em impulsos infinitésimos"
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito as propriedades da convolução e forneça um diagrama de blocos de um sistema LTI",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Calculadora simbólica (MATLAB/SymPy)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use tabelas de Laplace para validar convoluções simples antes de prosseguir",
                                  "learningObjective": "Compreender a base teórica da convolução para sistemas LTI e suas entradas arbitrárias",
                                  "commonMistakes": [
                                    "Confundir limites de integração",
                                    "Ignorar a causalidade do sistema h(t)=0 para t<0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representação de Entradas Arbitrárias como Degrau e Rampa",
                                  "subSteps": [
                                    "Expresse o degrau unitário u(t) como convolução de impulso com si mesmo",
                                    "Derive a rampa r(t) = t u(t) via integração do degrau: r(t) = ∫_{-∞}^t u(σ) dσ",
                                    "Desenhe gráficos de x(t) (degrau/rampa) e h(t) para um modelo de motor RL",
                                    "Calcule convolução para casos simples usando tabelas de transformadas",
                                    "Verifique dimensionalidade: y(t) deve ter unidades consistentes com x*h"
                                  ],
                                  "verification": "Plote manualmente ou via software x(t), h(t) e y(t) para degrau em circuito RL",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Octave/Python Matplotlib)",
                                    "Modelos de motores/transformadores (equações RL/RC)"
                                  ],
                                  "tips": "Comece com sistemas de primeira ordem para intuitionar o transiente",
                                  "learningObjective": "Representar entradas comuns em termos de impulsos e preparar para convolução",
                                  "commonMistakes": [
                                    "Erro nos gráficos de rampa (não linear)",
                                    "Esquecer fator de escala em rampas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo Explícito da Convolução y(t) = x(t) * h(t)",
                                  "subSteps": [
                                    "Escolha um modelo: motor DC com h(t) = (1/τ) e^{-t/τ} u(t)",
                                    "Para degrau x(t)=u(t): compute ∫_0^t h(τ) dτ = 1 - e^{-t/τ}",
                                    "Para rampa x(t)=t u(t): use propriedades ou integre por partes",
                                    "Implemente numericamente se analítico complexo (simulação discreta)",
                                    "Compare com solução diferencial para validação"
                                  ],
                                  "verification": "Obtenha y(t) analítica e numérica coincidente com erro <1%",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SymPy ou Wolfram Alpha para integrais",
                                    "Código MATLAB para simulação"
                                  ],
                                  "tips": "Mude variável para σ = t - τ para simplificar limites",
                                  "learningObjective": "Executar cálculo de convolução para entradas específicas em sistemas eletromecânicos",
                                  "commonMistakes": [
                                    "Limites errados na integral (de 0 a ∞ ao invés de 0 a t)",
                                    "Sinal errado em h(t-τ)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação de Transientes e Regime Estacionário",
                                  "subSteps": [
                                    "Identifique transiente: termos decrescentes e^{-t/τ}",
                                    "Regime estacionário: para degrau → ganho DC *1; para rampa → ganho velocidade",
                                    "Analise em contexto de motor/transformador: aceleração vs velocidade constante",
                                    "Discuta estabilidade e sobreamortecimento/subamortecimento",
                                    "Gere relatório com gráficos de y(t), transiente destacado"
                                  ],
                                  "verification": "Explique fisicamente o porquê do estacionário em um parágrafo",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos gerados no passo anterior",
                                    "Referências de engenharia aeronáutica"
                                  ],
                                  "tips": "Use zoom em gráficos para destacar transientes curtos",
                                  "learningObjective": "Interpretar resultados da convolução em termos físicos de sistemas reais",
                                  "commonMistakes": [
                                    "Confundir transiente com ruído",
                                    "Ignorar unidades no estacionário"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um motor DC de aeronave modelado como RL com τ=0.1s e h(t)=(10)e^{-10t}u(t), aplique entrada rampa x(t)=5t u(t) V. Calcule y(t), plote e interprete: transiente de ~0.3s até velocidade constante de 50 rad/s.",
                              "finalVerifications": [
                                "Calcula corretamente y(t) para degrau em sistema RL",
                                "Identifica transiente e estacionário em gráfico de rampa",
                                "Valida resultado via Laplace ou simulação diferencial",
                                "Explica impacto em motor/transformador aeronáutico",
                                "Discute limitações da convolução para não-lineares"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo da integral de convolução (90%+ correto)",
                                "Correta identificação de componentes transiente/estacionário",
                                "Qualidade dos gráficos e interpretações físicas",
                                "Uso adequado de ferramentas computacionais",
                                "Conexão clara com aplicações eletromecânicas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e transformadas de Laplace",
                                "Física: Eletromagnetismo em indutores/motores",
                                "Engenharia de Controle: Análise de sistemas LTI",
                                "Programação: Simulações numéricas em Python/MATLAB"
                              ],
                              "realWorldApplication": "No controle de motores elétricos de drones ou atuadores de flaps em aeronaves, prever resposta a comandos de rampa (aceleração gradual) garante estabilidade de voo e evita oscilações perigosas durante manobras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Interpretação de propriedades dinâmicas via h(t) e convolução",
                            "description": "Analisar estabilidade, tempo de subida e sobressinal a partir de h(t) e convolução em exemplos numéricos de motores e transformadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Resposta ao Impulso h(t) e sua Significação",
                                  "subSteps": [
                                    "Defina h(t) como a saída de um sistema LTI para uma entrada delta de Dirac.",
                                    "Interprete h(t) como a 'assinatura dinâmica' do sistema, revelando modos naturais.",
                                    "Identifique características chave: duração, picos, decaimento e oscilações em h(t).",
                                    "Classifique sistemas baseados em h(t): estável (h(t)→0), instável ou marginal.",
                                    "Pratique esboçando h(t) para sistemas de 1ª e 2ª ordem conhecidos."
                                  ],
                                  "verification": "Esboce h(t) para um sistema de 2ª ordem sobreamortecido e rotule estabilidade e tempo de decaimento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (Oppenheim)",
                                    "Software MATLAB ou Python (SciPy) para plotar h(t)",
                                    "Folhas de papel e calculadora"
                                  ],
                                  "tips": "Sempre normalize h(t) para entrada unitária; foque em assimptotas para análise qualitativa.",
                                  "learningObjective": "Explicar como h(t) encapsula todas as propriedades dinâmicas de um sistema LTI.",
                                  "commonMistakes": [
                                    "Confundir h(t) com função de transferência",
                                    "Ignorar normalização da entrada impulso",
                                    "Não verificar integral de h(t) para ganho estático"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Resposta Geral via Convolução y(t) = x(t) * h(t)",
                                  "subSteps": [
                                    "Lembre a fórmula de convolução: y(t) = ∫ x(τ) h(t-τ) dτ de 0 a ∞.",
                                    "Implemente convolução numérica usando soma de Riemann ou FFT em software.",
                                    "Escolha entradas típicas: degrau, rampa, senoide para motores/transformadores.",
                                    "Compute y(t) para x(t) = degrau unitário e compare com resposta de estado estacionário.",
                                    "Valide resultados plotando x(t), h(t) e y(t) em gráficos sobrepostos.",
                                    "Otimize computação dividindo em intervalos discretos para exemplos numéricos."
                                  ],
                                  "verification": "Calcule y(t) para h(t)=e^{-t} e x(t)=u(t), confirmando y(t)=1-e^{-t}.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/SciPy com funções conv() ou fftconvolve()",
                                    "Exemplos numéricos de motores DC",
                                    "Planilha Excel para discretização simples"
                                  ],
                                  "tips": "Use FFT para eficiência em sinais longos; verifique simetria h(t)*x(t)=x(t)*h(t).",
                                  "learningObjective": "Dominar cálculo de convolução analítica e numérica para entradas arbitrárias.",
                                  "commonMistakes": [
                                    "Limites errados na integral (não de -∞ a ∞ para causais)",
                                    "Erro de indexação em loops discretos",
                                    "Esquecer fator de escala em aproximações numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair Propriedades Dinâmicas: Estabilidade, Tempo de Subida e Sobressinal",
                                  "subSteps": [
                                    "Avalie estabilidade: verifique se ∫|h(t)|dt < ∞ ou h(t)→0 para t→∞.",
                                    "Meça tempo de subida (tr): tempo de 10% a 90% do valor final em y(t) para degrau.",
                                    "Calcule sobressinal (Mp): (pico máximo - final)/final * 100% em y(t).",
                                    "Identifique tempo de pico (tp) e frequência de oscilação de picos sucessivos.",
                                    "Compare propriedades de h(t) vs y(t) para diferentes x(t).",
                                    "Automatize medições com scripts que detectam picos e cruzamentos."
                                  ],
                                  "verification": "Para h(t) oscilatória, reporte tr=1.2s, Mp=15%, estável=True.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software com peakfind() (MATLAB findpeaks(), Python scipy.signal)",
                                    "Gráficos de h(t)/y(t) de exemplos prévios",
                                    "Tabelas de referência para sistemas padrão"
                                  ],
                                  "tips": "Use zoom em plots para precisão; considere ruído numérico em picos.",
                                  "learningObjective": "Quantificar precisamente estabilidade, tr e Mp a partir de h(t) e y(t).",
                                  "commonMistakes": [
                                    "Medir tr do zero em vez de 10-90%",
                                    "Confundir sobressinal com tempo de estabilização",
                                    "Classificar estável sem verificar decaimento absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Exemplos Numéricos de Motores e Transformadores",
                                  "subSteps": [
                                    "Obtenha h(t) modelada para motor DC: h(t) ≈ (K/τ) e^{-t/τ} sin(ω t).",
                                    "Para transformador: modele h(t) considerando indutância e resistência.",
                                    "Convolua com entradas reais: tensão rampa para aceleração de motor.",
                                    "Analise: estabilidade (sim para RL), tr curta para resposta rápida, Mp baixo.",
                                    "Compare simulações numéricas com dados experimentais ou catálogos.",
                                    "Gere relatório resumindo propriedades para design aeronáutico.",
                                    "Teste sensibilidade variando parâmetros como τ ou ζ."
                                  ],
                                  "verification": "Relatório com tr=0.8s, Mp=5% para motor DC sob rampa de 10V/s.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Modelos Simulink ou Python para motores/transformadores",
                                    "Dados de catálogos (ex: motor brushless drone)",
                                    "Referências: 'Dynamic Systems' Dorf"
                                  ],
                                  "tips": "Comece com parâmetros realistas (τ=0.1s para motores aero); valide com stepinfo().",
                                  "learningObjective": "Interpretar propriedades dinâmicas em contextos eletromecânicos reais.",
                                  "commonMistakes": [
                                    "Usar h(t) não causal",
                                    "Ignorar não-linearidades em altos níveis",
                                    "Não escalar unidades de tempo/entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC em drone (τ=0.2s, ζ=0.7): h(t)=(1/0.2)e^{-t/0.2}sin(5t)/5. Convolua com rampa x(t)=5t u(t). Resultado: y(t) sobe em tr=0.15s, Mp=8%, estável. Ideal para controle de altitude estável.",
                              "finalVerifications": [
                                "Calcule corretamente convolução numérica com erro <1%.",
                                "Identifique estabilidade corretamente em 3 h(t) diferentes.",
                                "Meça tr e Mp com precisão de 0.01s e 1% em plots.",
                                "Explique impacto de ζ em sobressinal via h(t).",
                                "Aplique a motor/transformador com relatório coerente.",
                                "Valide com stepinfo() ou equivalente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de convolução (90%+ match analítico).",
                                "Correta interpretação de estabilidade (baseada em decaimento).",
                                "Medições exatas de tr (10-90%) e Mp (pico relativo).",
                                "Análise contextual para eletromecânica (unidades consistentes).",
                                "Relatório claro com plots e conclusões acionáveis.",
                                "Tratamento de erros numéricos e sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integrais improprias e transformadas de Laplace.",
                                "Física: Leis de Kirchhoff em transformadores e dinâmica rotacional em motores.",
                                "Controle Automático: Especificações de desempenho (tr, Mp) para PID.",
                                "Engenharia Mecânica: Modelagem de inércia em sistemas eletromecânicos.",
                                "Programação: Numéricos em Python/MATLAB para simulação."
                              ],
                              "realWorldApplication": "Em aeronáutica, analisar h(t) de atuadores de flaps em aviões garante resposta rápida sem oscilações perigosas durante pousos, otimizando segurança e eficiência em sistemas fly-by-wire."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1",
                              "10.1.7.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Modelagem de Sistemas Térmicos",
                    "description": "Modelos lineares de transferência de calor com linearização e diagramas de blocos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Modelos Lineares de Transferência de Calor",
                        "description": "Desenvolvimento de equações diferenciais lineares para sistemas térmicos utilizando as leis de conservação de energia, considerando condução, convecção e radiação em condições lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Derivar equação diferencial para tanque térmico",
                            "description": "Obter a equação diferencial de primeiro ordem para um tanque com transferência de calor por convecção, identificando capacitância térmica e resistência térmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e identificar variáveis chave",
                                  "subSteps": [
                                    "Descreva o tanque térmico como um volume com fluido de massa constante m e capacidade calorífica específica c.",
                                    "Identifique a temperatura do fluido T(t) como variável de estado principal.",
                                    "Defina a temperatura ambiente T_a como constante externa.",
                                    "Liste parâmetros: coeficiente de transferência de calor por convecção h e área de superfície exposta A.",
                                    "Esboce um diagrama esquemático do tanque com setas indicando fluxo de calor por convecção."
                                  ],
                                  "verification": "Verifique se todas as variáveis (T(t), T_a, m, c, h, A) estão claramente definidas e o diagrama está desenhado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Livro-texto de termodinâmica ou dinâmica de sistemas"
                                  ],
                                  "tips": "Comece sempre com um diagrama para visualizar o sistema e evitar confusões com variáveis.",
                                  "learningObjective": "Compreender os elementos físicos do tanque térmico e suas interações térmicas.",
                                  "commonMistakes": [
                                    "Confundir capacidade calorífica c com calor específico",
                                    "Esquecer de considerar massa constante",
                                    "Não diferenciar T(t) da T_a"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o balanço de energia térmica",
                                  "subSteps": [
                                    "Escreva a lei de conservação de energia: taxa de variação da energia interna = fluxo de calor líquido.",
                                    "Expresse a energia interna como Q(t) = m c T(t), logo dQ/dt = m c dT/dt.",
                                    "Identifique o fluxo de calor por convecção: q = -h A (T(t) - T_a).",
                                    "Iguale: m c dT/dt = -h A (T(t) - T_a).",
                                    "Confirme que não há outras fontes de calor (ex: sem entrada de fluido quente)."
                                  ],
                                  "verification": "A equação m c dT/dt + h A (T - T_a) = 0 está escrita corretamente sem erros de sinal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios com balanços energéticos"
                                  ],
                                  "tips": "Lembre-se do sinal negativo para perda de calor quando T > T_a; teste com valores numéricos simples.",
                                  "learningObjective": "Dominar o balanço de energia para sistemas térmicos com convecção.",
                                  "commonMistakes": [
                                    "Inverter o sinal do fluxo convectivo",
                                    "Usar dT/dt em vez de m c dT/dt",
                                    "Incluir termos desnecessários como radiação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir capacitância térmica e resistência térmica",
                                  "subSteps": [
                                    "Defina capacitância térmica C = m c (analogia com capacitância elétrica).",
                                    "Defina resistência térmica R = 1 / (h A) (analogia com resistor).",
                                    "Reescreva a equação como C dT/dt = - (T - T_a) / R.",
                                    "Ou equivalentemente: C dT/dt + (T - T_a)/R = 0.",
                                    "Compare com a forma padrão de EDO de primeiro ordem: τ dT/dt + (T - T_a) = 0, onde τ = R C."
                                  ],
                                  "verification": "Substitua C e R na equação e confirme que retorna à forma original do passo 2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de analogias elétrico-térmicas",
                                    "Software de simulação como MATLAB (opcional)"
                                  ],
                                  "tips": "Use analogias elétricas (C como capacitor, 1/R como condutância) para memorizar as definições.",
                                  "learningObjective": "Relacionar parâmetros físicos com constantes de tempo em modelos lineares.",
                                  "commonMistakes": [
                                    "Confundir C = m c com R = h A",
                                    "Esquecer o inverso em R",
                                    "Não normalizar para forma τ dT/dt"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e validar a equação diferencial",
                                  "subSteps": [
                                    "Escreva a EDO final: dT/dt = - (1/(R C)) (T - T_a).",
                                    "Verifique linearidade: a equação é linear em T(t).",
                                    "Discuta condições iniciais: T(0) = T_0.",
                                    "Teste dimensional: confirme que unidades de dT/dt são consistentes (K/s).",
                                    "Derive a constante de tempo τ = R C e interprete fisicamente."
                                  ],
                                  "verification": "Resolva analiticamente para T_a = 0 e confirme decaimento exponencial T(t) = T_0 e^{-t/τ}.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para derivação analítica",
                                    "Exemplos resolvidos de EDOs térmicas"
                                  ],
                                  "tips": "Sempre verifique dimensões e solução analítica para validar o modelo.",
                                  "learningObjective": "Consolidar a derivação da EDO e sua interpretação dinâmica.",
                                  "commonMistakes": [
                                    "Não identificar o ponto de equilíbrio T_ss = T_a",
                                    "Erros em unidades",
                                    "Omitir constante de tempo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aeronave, modele um tanque de combustível com m = 100 kg, c = 2000 J/kg·K, h = 10 W/m²·K, A = 2 m², T_a = 25°C. Derive a EDO para prever como T(t) evolui após aquecimento inicial a 50°C, calculando τ ≈ 4000 s.",
                              "finalVerifications": [
                                "Pode derivar corretamente C = m c e R = 1/(h A)?",
                                "Escreve a EDO como C dT/dt + (T - T_a)/R = 0 sem erros?",
                                "Identifica a constante de tempo τ = R C e seu significado?",
                                "Valida dimensionalmente e com solução analítica?",
                                "Explica o papel da convecção no modelo?",
                                "Aplica a um exemplo numérico simples?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis e parâmetros (30%)",
                                "Correção no balanço de energia e derivação da EDO (40%)",
                                "Uso correto de C e R com analogias (15%)",
                                "Validação e interpretação física (10%)",
                                "Clareza no diagrama e explicações (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de EDOs lineares de primeiro ordem.",
                                "Física: Leis de termodinâmica e transferência de calor.",
                                "Engenharia de Controle: Modelos lineares para análise de estabilidade.",
                                "Eletrônica: Analogias entre circuitos RC e sistemas térmicos.",
                                "Computação: Simulação numérica em MATLAB/Simulink."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, essa modelagem é essencial para sistemas de controle térmico em tanques de combustível ou óleo, prevenindo congelamento em voos de alta altitude ou superaquecimento em decolagens, integrando-se a controladores PID para manter temperaturas seguras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Identificar parâmetros térmicos em modelos",
                            "description": "Determinar constantes como coeficiente de transferência de calor h, área A e massa m a partir de dados físicos de um sistema térmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo teórico de transferência de calor",
                                  "subSteps": [
                                    "Estude a equação diferencial do modelo linear: m * C * dT/dt = -h * A * (T - T_amb)",
                                    "Identifique os parâmetros chave: massa m, capacidade térmica C (se aplicável), coeficiente h e área A",
                                    "Derive a forma linearizada ou adimensional para facilitar a identificação",
                                    "Liste suposições do modelo, como regime estacionário ou transitório",
                                    "Desenhe um diagrama esquemático do sistema térmico"
                                  ],
                                  "verification": "Capacidade de escrever corretamente a equação e listar todos os parâmetros com suas unidades",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de transferência de calor, notas de aula, software de edição de equações (ex: LaTeX ou MathType)",
                                  "tips": "Use unidades consistentes (SI) desde o início para evitar erros de conversão",
                                  "learningObjective": "Compreender a estrutura matemática do modelo e o papel físico de cada parâmetro",
                                  "commonMistakes": "Confundir h com condutividade térmica k ou ignorar a dependência de T_amb"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar e coletar dados experimentais do sistema",
                                  "subSteps": [
                                    "Defina condições iniciais: temperatura ambiente T_amb e inicial T_0",
                                    "Configure sensores para medir T(t) em intervalos regulares (ex: termopares a cada 10s)",
                                    "Realize experimentos variando um parâmetro por vez (ex: mudar fluxo de ar para variar h)",
                                    "Registre dados em planilha com tempo, temperatura e condições ambientais",
                                    "Repita medições para calcular médias e desvios padrão"
                                  ],
                                  "verification": "Planilha preenchida com pelo menos 3 séries de dados consistentes e gráficos preliminares de T vs t",
                                  "estimatedTime": "1 hora",
                                  "materials": "Termômetro ou termopar, cronômetro, planilha Excel/Google Sheets, sistema físico (ex: bloco metálico aquecido)",
                                  "tips": "Minimize perdas parasitas isolando o sistema termicamente",
                                  "learningObjective": "Adquirir dados empíricos relevantes para identificação de parâmetros",
                                  "commonMistakes": "Medições em regime não linear ou com ruído excessivo sem filtragem"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar dados e estimar parâmetros via ajuste",
                                  "subSteps": [
                                    "Linearize a equação: ln((T - T_amb)/(T_0 - T_amb)) = - (h A / (m C)) t",
                                    "Plote ln((T - T_amb)/(T_0 - T_amb)) vs t e ajuste reta para obter tau = m C / (h A)",
                                    "Meça m e A diretamente ou estime via dimensões; isole h se C conhecido",
                                    "Use método dos mínimos quadrados (Excel ou Python) para otimizar parâmetros",
                                    "Calcule intervalos de confiança baseados em erros de medição"
                                  ],
                                  "verification": "Valores numéricos para h, A, m com unidades corretas e gráfico de ajuste com R² > 0.95",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de análise (Excel, MATLAB, Python com SciPy), dados da planilha",
                                  "tips": "Verifique linearidade no plot semilogarítmico antes de ajustar",
                                  "learningObjective": "Aplicar técnicas de identificação de sistemas para extrair parâmetros",
                                  "commonMistakes": "Não subtrair T_amb corretamente ou usar escala errada no plot"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a identificação dos parâmetros",
                                  "subSteps": [
                                    "Simule o modelo com parâmetros estimados e compare com dados reais",
                                    "Calcule erro médio quadrático (RMSE) entre simulação e medição",
                                    "Teste sensibilidade variando ±10% em cada parâmetro e observe impacto",
                                    "Ajuste iterativamente se RMSE > 5% (ex: corrigir suposições do modelo)",
                                    "Documente valores finais com justificativa física"
                                  ],
                                  "verification": "Simulação reproduz dados com RMSE < 5% e relatório de sensibilidade",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de simulação (MATLAB Simulink ou Python ODE solver), dados processados",
                                  "tips": "Use validação cruzada com conjunto de dados separado",
                                  "learningObjective": "Garantir robustez e confiabilidade dos parâmetros identificados",
                                  "commonMistakes": "Sobreajuste (overfitting) ignorando ruído ou suposições inválidas"
                                }
                              ],
                              "practicalExample": "Em um dissipador de calor de uma asa de aeronave, meça a temperatura de um bloco de alumínio (m=0.5kg, A=0.1m²) resfriando de 80°C para 25°C ambiente com vento simulando voo. Plote T(t), ajuste para encontrar h≈50 W/m²K.",
                              "finalVerifications": [
                                "Parâmetros h, A, m têm unidades corretas e valores fisicamente plausíveis",
                                "Gráfico de ajuste linearizado mostra R² > 0.95",
                                "Simulação com parâmetros reproduz dados experimentais com RMSE < 5%",
                                "Análise de sensibilidade confirma estabilidade dos valores",
                                "Documentação inclui suposições e limites do modelo",
                                "Teste com condição inicial diferente valida generalização"
                              ],
                              "assessmentCriteria": [
                                "Precisão do ajuste: R² > 0.95 e RMSE < 5%",
                                "Consistência física: valores de h entre 10-100 W/m²K para convecção forçada",
                                "Qualidade dos dados: pelo menos 20 pontos por série com desvio < 2%",
                                "Documentação completa: equações, plots e justificativas",
                                "Tratamento de erros: intervalos de confiança reportados",
                                "Criatividade na validação: uso de múltiplos experimentos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ajuste de curvas e mínimos quadrados",
                                "Física: Leis de Newton e Fourier em termodinâmica",
                                "Programação: Scripts em Python/MATLAB para análise de dados",
                                "Estatística: Análise de incertezas e regressão linear"
                              ],
                              "realWorldApplication": "Identificar parâmetros térmicos em trocadores de calor de motores a jato para otimizar controle de temperatura durante voo, prevenindo sobreaquecimento e melhorando eficiência energética em aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Representar modelo térmico em forma padrão",
                            "description": "Escrever o modelo na forma τ dy/dt + y = K u, onde τ é constante de tempo térmica e K é ganho estático.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Físicos do Sistema Térmico",
                                  "subSteps": [
                                    "Descreva o sistema térmico, como um bloco metálico em convecção com ar ambiente.",
                                    "Identifique variáveis chave: y(t) como temperatura do corpo, u(t) como entrada de potência térmica, T_a como temperatura ambiente constante.",
                                    "Lembre a lei de resfriamento/aquecimento de Newton: taxa de transferência de calor Q = h A (T_a - y).",
                                    "Estabeleça o balanço de energia: capacidade térmica C dy/dt = P u + h A (T_a - y), onde C = m c_p e P é fator de eficiência da entrada.",
                                    "Defina variáveis de desvio em torno do estado estacionário para linearização: y = T - T_ss."
                                  ],
                                  "verification": "Escreva corretamente o balanço de energia inicial e identifique todas as variáveis físicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Termodinâmica ou referência online sobre transferência de calor"
                                  ],
                                  "tips": "Desenhe um diagrama esquemático do sistema para visualizar fluxos de calor.",
                                  "learningObjective": "Dominar a base física que leva à modelagem linear de primeiro ordem.",
                                  "commonMistakes": "Confundir a entrada u (potência) com temperatura ambiente T_a ou ignorar o sinal na lei de Newton."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Equação Diferencial Linearizada",
                                  "subSteps": [
                                    "No estado estacionário (dy/dt=0), resolva para T_ss: 0 = P u_ss + h A (T_a - T_ss), obtendo T_ss = T_a + (P u_ss)/(h A).",
                                    "Defina y(t) = T(t) - T_ss e assuma u(t) = u_ss + \tilde{u}(t), com entradas de desvio pequenas.",
                                    "Substitua no balanço: C d(y + T_ss)/dt = P (u_ss + \tilde{u}) + h A (T_a - y - T_ss).",
                                    "Simplifique usando estado estacionário: C dy/dt = P \tilde{u} - h A y.",
                                    "Divida por h A: (C / h A) dy/dt + y = (P / h A) \tilde{u}."
                                  ],
                                  "verification": "A equação deve estar na forma τ dy/dt + y = K u, com τ = C / h A e K = P / h A.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de papel quadriculado para derivações"
                                  ],
                                  "tips": "Sempre normalize em torno do estado estacionário para garantir linearidade.",
                                  "learningObjective": "Capacitar a derivação da equação diferencial a partir do balanço físico.",
                                  "commonMistakes": "Esquecer de linearizar em torno de T_ss ou inverter o sinal do termo de convecção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Calcular as Constantes τ e K",
                                  "subSteps": [
                                    "Defina τ como a constante de tempo térmica: τ = C / (h A), com unidades de tempo (segundos).",
                                    "Calcule K, o ganho estático: K = P / (h A), com unidades de temperatura por potência (K/W).",
                                    "Verifique dimensionalmente: τ dy/dt tem unidades de temperatura, y também, K u temperatura.",
                                    "Substitua valores numéricos se fornecidos ou mantenha simbólico.",
                                    "Confirme que τ > 0 e K consistente com o sistema físico."
                                  ],
                                  "verification": "Liste explicitamente τ e K com suas expressões e unidades corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de propriedades térmicas (h, c_p, etc.)",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre que τ representa o tempo para 63% da resposta ao degrau.",
                                  "learningObjective": "Extrair parâmetros físicos chave para a forma padrão.",
                                  "commonMistakes": "Confundir τ com 1/(h A / C) ou ignorar P na definição de K."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever e Verificar a Forma Padrão do Modelo",
                                  "subSteps": [
                                    "Escreva a equação final: τ dy/dt + y = K u.",
                                    "Teste com condição inicial y(0)=0 e entrada degrau u=1, verificando solução y(t) = K (1 - e^{-t/τ}).",
                                    "Compare com simulação numérica simples ou gráfico mental da resposta.",
                                    "Documente suposições: modelo lump, linearidade válida para pequenas perturbações.",
                                    "Prepare para uso em função de transferência G(s) = K / (τ s + 1)."
                                  ],
                                  "verification": "A equação final corresponde exatamente à forma τ dy/dt + y = K u sem erros algébricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação como MATLAB/Simulink (opcional)",
                                    "Papel para esboço de resposta temporal"
                                  ],
                                  "tips": "Sempre teste com um caso numérico simples para validar.",
                                  "learningObjective": "Finalizar o modelo na forma padrão pronta para análise dinâmica.",
                                  "commonMistakes": "Deixar coeficientes não padronizados ou esquecer o termo dy/dt."
                                }
                              ],
                              "practicalExample": "Em um dissipador de calor de motor de aeronave: C = 200 J/K, h A = 20 W/K, P = 1. Calcule τ = 10 s, K = 0.05 K/W. Modelo: 10 dy/dt + y = 0.05 u, onde y é variação de temperatura (°C), u potência extra (W).",
                              "finalVerifications": [
                                "Equação escrita exatamente como τ dy/dt + y = K u.",
                                "τ e K expressos corretamente em termos físicos (τ = C/(h A), K = P/(h A)).",
                                "Unidades consistentes em todos os termos.",
                                "Estado estacionário verificado: y_ss = K u_ss.",
                                "Resposta ao degrau qualitativamente correta (assintótica a K, tempo τ).",
                                "Suposições documentadas (linearidade, lump model)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do balanço de energia (sem erros de sinal).",
                                "Correta linearização e identificação de variáveis de desvio.",
                                "Cálculo exato de τ e K com análise dimensional.",
                                "Forma final padronizada sem coeficientes extras.",
                                "Verificação através de exemplo numérico ou qualitativo.",
                                "Clareza na documentação de passos e suposições."
                              ],
                              "crossCurricularConnections": [
                                "Física/Termodinâmica: Lei de Newton e balanço de energia.",
                                "Engenharia de Controle: Funções de transferência de primeiro ordem.",
                                "Matemática: Equações diferenciais lineares e Laplace.",
                                "Engenharia Mecânica: Dimensionamento de dissipadores de calor."
                              ],
                              "realWorldApplication": "No controle térmico de componentes eletrônicos em aeronaves, como aviônicos, onde o modelo permite projetar controladores PID para manter temperaturas estáveis sob variações de potência e ambiente, evitando falhas por superaquecimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Linearização de Modelos Térmicos Não-Lineares",
                        "description": "Aplicação do método de linearização em torno de um ponto de operação para aproximar modelos não-lineares de transferência de calor por equações lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Calcular Jacobiano para linearização",
                            "description": "Computar as derivadas parciais ∂f/∂x e ∂f/∂u em um ponto de equilíbrio para um modelo não-linear como m c dT/dt = h A (T_amb - T).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o modelo não-linear e o ponto de equilíbrio",
                                  "subSteps": [
                                    "Analise a equação diferencial não-linear dada: m c dT/dt = h A (T_amb - T).",
                                    "Defina as variáveis: x = T (estado), u = T_amb (entrada), parâmetros constantes (m, c, h, A).",
                                    "Encontre o ponto de equilíbrio (x_eq, u_eq) resolvendo f(x_eq, u_eq) = 0, tipicamente T_eq = T_amb_eq.",
                                    "Atribua valores numéricos aos parâmetros para o exemplo prático.",
                                    "Documente todas as variáveis em uma tabela para referência."
                                  ],
                                  "verification": "Confirme que f(x_eq, u_eq) = 0 e liste todas as variáveis corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Folha de referência do modelo"
                                  ],
                                  "tips": "Sempre normalize unidades (ex: Kelvin ou Celsius) para evitar erros.",
                                  "learningObjective": "Compreender a estrutura do sistema não-linear e localizar o equilíbrio.",
                                  "commonMistakes": [
                                    "Confundir estado x com entrada u",
                                    "Esquecer de resolver f(x_eq, u_eq)=0",
                                    "Ignorar unidades nos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar a função f(x, u) em forma explícita",
                                  "subSteps": [
                                    "Reescreva a equação como ẛ/dt = f(x, u) = (h A / (m c)) * (u - x).",
                                    "Identifique f como um vetor coluna [f1] para sistema SISO.",
                                    "Verifique dimensionalmente: f deve ter unidades de temperatura por tempo.",
                                    "Substitua parâmetros para simplificar: defina k = h A / (m c), então f = k (u - x).",
                                    "Escreva f(x,u) = k (u - x)."
                                  ],
                                  "verification": "A função f está escrita corretamente e matches a equação original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou SymPy/MATLAB",
                                    "Papel para derivações"
                                  ],
                                  "tips": "Use símbolos para parâmetros antes de numerizar.",
                                  "learningObjective": "Representar o modelo dinâmico na forma padrão ẛ = f(x,u).",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo no termo -T",
                                    "Confundir dT/dt com T diretamente",
                                    "Não definir k corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a derivada parcial ∂f/∂x",
                                  "subSteps": [
                                    "Diferencie f em relação a x: ∂f/∂x = d/dx [k (u - x)] = -k.",
                                    "Como é escalar, ∂f/∂x é um escalar -k.",
                                    "Para sistemas multivariáveis, seria uma matriz linha.",
                                    "Mantenha simbólico: ∂f/∂x = - (h A)/(m c).",
                                    "Verifique com limite: lim Δx→0 [f(x+Δx,u) - f(x,u)] / Δx."
                                  ],
                                  "verification": "∂f/∂x = -k, independente de u.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de cálculo simbólico (ex: Wolfram Alpha)",
                                    "Papel para derivadas"
                                  ],
                                  "tips": "Lembre que x aparece linearmente, mas em modelos gerais pode ser não-linear.",
                                  "learningObjective": "Dominar cálculo de derivadas parciais para linearização.",
                                  "commonMistakes": [
                                    "Sinal errado no -k",
                                    "Tratar como derivada total",
                                    "Esquecer chain rule em casos complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a derivada parcial ∂f/∂u",
                                  "subSteps": [
                                    "Diferencie f em relação a u: ∂f/∂u = d/du [k (u - x)] = k.",
                                    "∂f/∂u é escalar k.",
                                    "Simbólico: ∂f/∂u = (h A)/(m c).",
                                    "Confirme independência de x.",
                                    "Anote como coluna para matriz B."
                                  ],
                                  "verification": "∂f/∂u = k, positivo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmos da step 3"
                                  ],
                                  "tips": "Entrada u afeta positivamente a taxa de mudança.",
                                  "learningObjective": "Calcular corretamente a sensibilidade à entrada.",
                                  "commonMistakes": [
                                    "Sinal invertido",
                                    "Confundir com ∂f/∂x",
                                    "Não manter consistência simbólica"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar no equilíbrio e formar as matrizes Jacobianas A e B",
                                  "subSteps": [
                                    "Substitua (x_eq, u_eq): A = ∂f/∂x |_{eq} = -k.",
                                    "B = ∂f/∂u |_{eq} = k.",
                                    "Monte matrizes: A = [-k], B = [k] (escalares efetivos).",
                                    "Verifique estabilidade: autovalor de A é -k < 0.",
                                    "Escreva o modelo linearizado: δẛ = A δx + B δu."
                                  ],
                                  "verification": "Matrizes A e B corretas numericamente e simbolicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para matrizes (MATLAB ou Python NumPy)",
                                    "Exemplo numérico"
                                  ],
                                  "tips": "Sempre avalie no eq, mesmo se derivadas constantes.",
                                  "learningObjective": "Completar a linearização formando o Jacobiano.",
                                  "commonMistakes": [
                                    "Não avaliar no eq",
                                    "Erros de transposição em matrizes",
                                    "Ignorar δ em variáveis desviadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para m=1 kg, c=1000 J/kgK, h=10 W/m²K, A=0.1 m², T_amb_eq=293 K, T_eq=293 K. Então k = (10*0.1)/(1*1000) = 0.001. A = -0.001, B=0.001. Modelo linear: dδT/dt = -0.001 δT + 0.001 δT_amb.",
                              "finalVerifications": [
                                "f(x_eq, u_eq) = 0 confirmado.",
                                "∂f/∂x = -k e ∂f/∂u = k corretos.",
                                "Matrizes A e B avaliadas no equilíbrio.",
                                "Modelo linearizado escrito corretamente.",
                                "Verificação numérica com valores de exemplo coincide.",
                                "Autovalores de A indicam estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivadas parciais (100% simbólico correto).",
                                "Correta identificação do ponto de equilíbrio.",
                                "Formato correto das matrizes Jacobianas.",
                                "Uso adequado de símbolos vs. numérico.",
                                "Explicação clara das verificações.",
                                "Ausência de erros dimensionais ou de sinal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e matrizes.",
                                "Física: Transferência de calor e dinâmica térmica.",
                                "Engenharia de Controle: Linearização para controle PID/LQR.",
                                "Programação: Implementação em MATLAB/Simulink para simulação.",
                                "Engenharia Aeronáutica: Controle térmico de aviônicos."
                              ],
                              "realWorldApplication": "Em aeronaves, linearizar modelos térmicos para projetar controladores que mantêm temperatura estável em eletrônicos durante voo, prevenindo falhas por superaquecimento ou congelamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Obter modelo linearizado em variáveis de desvio",
                            "description": "Expressar o modelo linearizado como δẋ = A δx + B δu e δy = C δx, definindo variáveis de desvio δx = x - x0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Ponto de Equilíbrio de Operação",
                                  "subSteps": [
                                    "Revise o modelo não-linear dado: ẋ = f(x, u) e y = g(x).",
                                    "Defina o ponto de operação constante x₀ e u₀ tal que o sistema esteja em equilíbrio: f(x₀, u₀) = 0.",
                                    "Resolva algebraicamente para x₀ em função de u₀ ou valores nominais relevantes para o contexto térmico.",
                                    "Calcule y₀ = g(x₀) para consistência.",
                                    "Verifique numericamente se f(x₀, u₀) ≈ 0 dentro de tolerância numérica."
                                  ],
                                  "verification": "Confirme que ẋ₀ = f(x₀, u₀) = 0 e anote os valores de x₀, u₀, y₀.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Modelo não-linear do sistema térmico",
                                    "Software simbólico (SymPy ou MATLAB)",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Escolha u₀ representativo do regime operacional, como potência nominal em um trocador de calor aeronáutico.",
                                  "learningObjective": "Compreender a importância do ponto de equilíbrio para linearização local.",
                                  "commonMistakes": [
                                    "Não verificar se f(x₀, u₀) = 0 exatamente",
                                    "Escolher u₀ arbitrário sem contexto físico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Variáveis de Desvio",
                                  "subSteps": [
                                    "Introduza δx = x - x₀, δu = u - u₀ e δy = y - y₀.",
                                    "Expresse o estado dinâmico em termos de desvios: ẋ = δẋ + ẋ₀, mas como ẋ₀ = 0, então δẋ = f(x₀ + δx, u₀ + δu).",
                                    "Faça o mesmo para a saída: δy = g(x₀ + δx).",
                                    "Verifique dimensionalmente que δx, δu e δy são pequenas perturbações.",
                                    "Documente as definições em notação matricial para sistemas MIMO se aplicável."
                                  ],
                                  "verification": "Escreva explicitamente δẋ = f(x₀ + δx, u₀ + δu) e confirme que em δx=0, δu=0 resulta em 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas do Step 1",
                                    "Folha de anotações",
                                    "Editor de equações (LaTeX ou Word)"
                                  ],
                                  "tips": "Use subscritos claros (ex: x_0) para evitar confusão entre variáveis originais e de desvio.",
                                  "learningObjective": "Dominar a transformação para coordenadas de desvio centradas no equilíbrio.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair x₀ nas definições",
                                    "Confundir δẋ com ẋ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as Matrizes Jacobianas (A, B, C)",
                                  "subSteps": [
                                    "Expanda f em série de Taylor de primeira ordem: f ≈ f(x₀,u₀) + (∂f/∂x)|₀ δx + (∂f/∂u)|₀ δu.",
                                    "Como f(x₀,u₀)=0, isole A = ∂f/∂x |_{(x₀,u₀)} e B = ∂f/∂u |_{(x₀,u₀)}.",
                                    "Calcule C = ∂g/∂x |_{(x₀)} para a saída.",
                                    "Compute as derivadas parciais analiticamente ou numericamente para o modelo térmico.",
                                    "Armazene A, B, C como matrizes numéricas ou simbólicas."
                                  ],
                                  "verification": "Verifique se as dimensões de A (n×n), B (n×m), C (p×n) estão corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SymPy/MATLAB para derivadas simbólicas",
                                    "Modelo não-linear",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Para modelos térmicos, derivadas de termos como perda por convecção (proporcional a T) são comuns.",
                                  "learningObjective": "Aplicar expansão de Taylor multivariable para linearização.",
                                  "commonMistakes": [
                                    "Avaliar Jacobiana em ponto errado",
                                    "Negligenciar termos de segunda ordem acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e Validar o Modelo Linearizado",
                                  "subSteps": [
                                    "Escreva o modelo: δẋ = A δx + B δu e δy = C δx.",
                                    "Substitua as matrizes calculadas e simplifique expressões.",
                                    "Simule numericamente o modelo linear vs. não-linear em torno de x₀ para pequenas perturbações.",
                                    "Analise autovalores de A para estabilidade inicial.",
                                    "Documente o modelo final com unidades e contexto."
                                  ],
                                  "verification": "Compare trajetórias de simulação: erro <5% para ||δx|| < 10% de x₀.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (SciPy)",
                                    "Dados do Step 3"
                                  ],
                                  "tips": "Use plotagens para visualizar a boa aproximação local.",
                                  "learningObjective": "Montar e validar o modelo linearizado completo.",
                                  "commonMistakes": [
                                    "Inverter ordem das equações de estado/saída",
                                    "Esquecer validação por simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um modelo térmico não-linear de um dissipador de calor em eletrônicos aeronáuticos: Ṫ = - (k/ρc) T³ + (P/ρc) u, onde T é temperatura, u é potência de entrada. Para u₀=1, resolva T₀ = (P u₀ / k)^{1/3}. Então A = ∂f/∂T|_0 = -3 (k/ρc) T₀², B = P/ρc, C=1. Resultado: δṪ = A δT + B δu.",
                              "finalVerifications": [
                                "Definições de δx, δu corretas e centradas em x₀, u₀.",
                                "Matrizes A, B, C derivadas corretamente com Jacobianas.",
                                "Modelo escrito como δẋ = A δx + B δu e δy = C δx.",
                                "Simulação confirma aproximação válida para pequenas perturbações.",
                                "Autovalores de A indicam comportamento dinâmico coerente.",
                                "Unidades consistentes em todas as equações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha e verificação do ponto de equilíbrio (20%).",
                                "Correção das derivadas parciais e matrizes Jacobianas (30%).",
                                "Clareza na expressão final do modelo linearizado (20%).",
                                "Validação por simulação ou análise qualitativa (20%).",
                                "Documentação completa com contexto térmico (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansões em série de Taylor e cálculo multivariable.",
                                "Controle Automático: Análise de linearidade para síntese de controladores.",
                                "Física/Termodinâmica: Modelos de transferência de calor não-lineares.",
                                "Programação: Uso de ferramentas numéricas para Jacobianas.",
                                "Engenharia de Controle Aeronáutico: Estabilização de regimes térmicos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, usado para linearizar modelos térmicos de motores ou aviônicos em torno de condições de cruzeiro, permitindo design de controladores PID ou LQR para regulação de temperatura sob perturbações como variações de altitude."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Validar linearização por simulação",
                            "description": "Comparar respostas do modelo não-linear e linearizado para entradas pequenas em torno do ponto de operação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo não-linear e o ponto de operação",
                                  "subSteps": [
                                    "Identifique as equações diferenciais não-lineares do sistema térmico.",
                                    "Escolha um ponto de operação realista (ex: temperatura de equilíbrio T₀ e entrada u₀).",
                                    "Calcule as condições de equilíbrio no ponto de operação.",
                                    "Documente os parâmetros do modelo (constantes físicas como coeficientes de transferência de calor).",
                                    "Verifique se o ponto de operação satisfaz as equações em estado estacionário."
                                  ],
                                  "verification": "Confirme que f(T₀, u₀) = 0, onde f é a dinâmica não-linear.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Equações do modelo térmico, calculadora ou software simbólico (MATLAB Symbolic).",
                                  "tips": "Use valores realistas de sistemas aeronáuticos, como T₀ = 300K para um dissipador de calor.",
                                  "learningObjective": "Compreender a seleção de pontos de operação relevantes para linearização.",
                                  "commonMistakes": "Escolher ponto de operação fora do domínio físico válido ou ignorar dependências não-lineares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação linearizada",
                                  "subSteps": [
                                    "Calcule as derivadas parciais da função não-linear em relação ao estado e entrada no ponto de operação.",
                                    "Forme as matrizes Jacobianas A = ∂f/∂x |_{x₀,u₀} e B = ∂f/∂u |_{x₀,u₀}.",
                                    "Escreva o modelo linearizado: δẋ = A δx + B δu.",
                                    "Implemente as matrizes em código ou simbólico.",
                                    "Verifique dimensionalidade e unidades das matrizes."
                                  ],
                                  "verification": "Matrizes A e B devem ser consistentes com as dimensões do sistema (ex: 1x1 para SISO).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Python (SymPy), equações do Step 1.",
                                  "tips": "Use syms no MATLAB para derivação automática e evite erros de cálculo manual.",
                                  "learningObjective": "Dominar o processo matemático de linearização via expansão de Taylor.",
                                  "commonMistakes": "Esquecer o sinal negativo nas derivadas ou confundir δx com x absoluto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar simulações numéricas para ambos os modelos",
                                  "subSteps": [
                                    "Implemente o integrador numérico para o modelo não-linear (ex: ode45 no MATLAB).",
                                    "Configure o modelo linear como δẋ = A δx + B δu com condições iniciais zero.",
                                    "Defina entradas pequenas: perturbações δu = 0.1 u₀ sen(t) em torno de u₀.",
                                    "Estabeleça tempo de simulação curto (ex: 10 segundos) e passo de tempo pequeno.",
                                    "Prepare scripts para rodar múltiplas simulações."
                                  ],
                                  "verification": "Teste simulação em estado estacionário: respostas devem convergir para zero em δx.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink ou Python (scipy.integrate.odeint), scripts de simulação.",
                                  "tips": "Use funções anônimas para modelos não-lineares e ss() para lineares no MATLAB.",
                                  "learningObjective": "Aprender a simular sistemas dinâmicos numericamente com precisão.",
                                  "commonMistakes": "Usar passos de tempo grandes causando instabilidade numérica ou entradas grandes violando 'pequenas perturbações'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações e visualizar respostas",
                                  "subSteps": [
                                    "Rode simulações para não-linear e linear com as mesmas condições iniciais e entradas.",
                                    "Plote respostas δx(t) para ambos os modelos no mesmo gráfico.",
                                    "Gere múltiplos cenários variando amplitude de δu (0.05u₀, 0.1u₀, 0.2u₀).",
                                    "Calcule métricas iniciais como tempo de sobreposição das curvas.",
                                    "Salve figuras e dados para análise."
                                  ],
                                  "verification": "Gráficos mostram sobreposição inicial das respostas para δu pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB plot(), Python matplotlib, dados das simulações.",
                                  "tips": "Use hold on e legend para comparar múltiplas curvas; normalize erros por escala.",
                                  "learningObjective": "Visualizar e interpretar comportamentos dinâmicos comparativos.",
                                  "commonMistakes": "Plotar variáveis absolutas em vez de desviadas ou escalas inadequadas escondendo diferenças."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e validar a linearização",
                                  "subSteps": [
                                    "Calcule erros quantitativos: RMSE entre respostas não-linear e linear.",
                                    "Verifique se erro diminui com amplitude de perturbação menor.",
                                    "Analise espectro de frequência ou pólos para concordância.",
                                    "Conclua sobre validade: 'boa para δu < 10%'.",
                                    "Documente relatório com gráficos e métricas."
                                  ],
                                  "verification": "RMSE < 5% para perturbações pequenas confirma validação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Dados plotados, funções de erro (norm() no MATLAB).",
                                  "tips": "Use loglog para erro vs amplitude para ver tendência quadrática esperada.",
                                  "learningObjective": "Avaliar quantitativamente a precisão da aproximação linear.",
                                  "commonMistakes": "Ignorar regime transitório ou declarar validade sem métricas quantitativas."
                                }
                              ],
                              "practicalExample": "Para um dissipador térmico de motor aeronáutico: dT/dt = - (h/A)(T - T_amb) + Q/m c_p, com h não-linear em T. Ponto: T₀=350K, u₀=fluxo nominal. Simule δu=0.05 sen(ωt), compare T(t) não-linear vs δT linear; respostas coincidem nos primeiros 2s.",
                              "finalVerifications": [
                                "Respostas coincidem visualmente nos primeiros 20% do tempo de simulação.",
                                "RMSE < 3% para perturbações δu ≤ 5% de u₀.",
                                "Erro aumenta monotonicamente com amplitude de δu.",
                                "Pólos do modelo linear aproximam os do não-linear.",
                                "Simulações em múltiplas frequências de entrada validam.",
                                "Relatório documenta todas métricas e gráficos."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação das matrizes A e B (verificação simbólica).",
                                "Implementação precisa das simulações sem erros numéricos evidentes.",
                                "Gráficos claros com legendas e escalas apropriadas.",
                                "Análise quantitativa de erros com thresholds definidos.",
                                "Conclusão fundamentada sobre domínio de validade da linearização.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansão de Taylor e cálculo de Jacobianas.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Física: Modelagem de transferência térmica em sistemas aeronáuticos.",
                                "Engenharia de Controle: Validação para síntese de controladores.",
                                "Análise de Dados: Métricas de erro e visualização."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, validar linearizações por simulação é essencial para projetar controladores PID ou LQR em sistemas térmicos de motores, garantindo regulação precisa de temperaturas durante manobras, otimizando eficiência de combustível e prevenindo falhas térmicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Diagrama de Blocos para Sistemas Térmicos",
                        "description": "Representação gráfica de modelos lineares térmicos utilizando diagramas de blocos, incluindo função de transferência e operações de soma e ganho.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Converter equação diferencial em função de transferência",
                            "description": "Aplicar transformada de Laplace para obter G(s) = Y(s)/U(s) = K / (τ s + 1) a partir da equação diferencial linearizada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Equação Diferencial Linearizada",
                                  "subSteps": [
                                    "Identifique a equação diferencial do sistema térmico, como τ dy/dt + y = K u(t).",
                                    "Defina claramente y(t) como saída (ex: desvio de temperatura θ(t)) e u(t) como entrada (ex: potência de aquecimento).",
                                    "Extraia as constantes K (ganho estático) e τ (constante de tempo) da equação física.",
                                    "Confirme que a equação está linearizada em torno do ponto de operação e escreva na forma padrão de primeira ordem.",
                                    "Anote condições iniciais, assumindo y(0) = 0 para função de transferência."
                                  ],
                                  "verification": "Equação escrita corretamente na forma τ dy/dt + y = K u(t), com variáveis e constantes identificadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Equação diferencial do sistema térmico",
                                    "Tabela de parâmetros físicos (K, τ)"
                                  ],
                                  "tips": "Sempre verifique unidades: τ em segundos, K adimensional ou com unidades consistentes.",
                                  "learningObjective": "Compreender a estrutura matemática de equações diferenciais lineares de primeira ordem para sistemas térmicos.",
                                  "commonMistakes": [
                                    "Confundir coeficientes de y e dy/dt",
                                    "Não linearizar equações não lineares",
                                    "Esquecer de definir y(0)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Transformada de Laplace",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace bilateral em ambos os lados da equação: L{τ dy/dt + y} = L{K u}.",
                                    "Transforme o termo derivativo: L{dy/dt} = s Y(s) - y(0), com y(0)=0 resulta em s Y(s).",
                                    "Transforme os termos integrais: L{y} = Y(s), L{u} = U(s), L{K u} = K U(s).",
                                    "Combine: τ s Y(s) + Y(s) = K U(s).",
                                    "Fatore Y(s) do lado esquerdo para preparar o isolamento."
                                  ],
                                  "verification": "Equação no domínio s: Y(s) (τ s + 1) = K U(s), sem erros nas transformadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora simbólica opcional (ex: MATLAB, SymPy)"
                                  ],
                                  "tips": "Use condições iniciais zero para funções de transferência; memorize L{dy/dt} = s Y(s) - y(0).",
                                  "learningObjective": "Dominar a aplicação da transformada de Laplace a equações diferenciais lineares.",
                                  "commonMistakes": [
                                    "Esquecer o termo -y(0)",
                                    "Aplicar Laplace unilateral incorretamente",
                                    "Confundir Y(s) e U(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar e Simplificar a Função de Transferência G(s)",
                                  "subSteps": [
                                    "Divida ambos os lados por U(s): Y(s)/U(s) = K / (τ s + 1).",
                                    "Defina G(s) = Y(s)/U(s) = K / (τ s + 1).",
                                    "Verifique se o denominador está no formato polo único (τ s + 1).",
                                    "Simplifique algebricamente se houver termos extras.",
                                    "Escreva G(s) explicitamente com valores numéricos de K e τ se fornecidos."
                                  ],
                                  "verification": "G(s) = K / (τ s + 1) isolado corretamente, com ganho DC G(0) = K.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de álgebra simbólica (opcional)"
                                  ],
                                  "tips": "G(s) deve ser própria (grau numerador < grau denominador) para sistemas físicos causais.",
                                  "learningObjective": "Aprender a extrair a função de transferência diretamente da equação em s.",
                                  "commonMistakes": [
                                    "Dividir incorretamente por U(s)",
                                    "Esquecer o fator K",
                                    "Deixar termo s no numerador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar a Função de Transferência",
                                  "subSteps": [
                                    "Calcule G(0) = K para confirmar ganho estático.",
                                    "Identifique o polo em s = -1/τ e discuta estabilidade (polo negativo).",
                                    "Compare com diagrama de blocos: ganho K e tempo constante 1/τ.",
                                    "Teste com entrada unitária passo para validar resposta.",
                                    "Documente limitações (linearidade, primeira ordem)."
                                  ],
                                  "verification": "Interpretação física coerente, com G(0)=K e polo correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de funções de transferência padrão",
                                    "Simulador (ex: MATLAB Simulink)"
                                  ],
                                  "tips": "Simule numericamente para validar se possível.",
                                  "learningObjective": "Interpretar propriedades dinâmicas da G(s) em contexto térmico.",
                                  "commonMistakes": [
                                    "Interpretar polo positivo como instável incorretamente",
                                    "Ignorar limitações da linearização"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um dissipador térmico linearizado: τ dθ/dt + θ = K q(t), onde θ(t) é desvio de temperatura, q(t) é potência de aquecimento. Aplicando Laplace: θ(s) (τ s + 1) = K Q(s), logo G(s) = θ(s)/Q(s) = K / (τ s + 1), com τ = C / (h A), K=1/(h A).",
                              "finalVerifications": [
                                "G(s) exata: K / (τ s + 1)",
                                "K e τ extraídos corretamente da equação original",
                                "Condições iniciais zero assumidas explicitamente",
                                "Sem erros algébricos na manipulação",
                                "Ganho estático G(0) = K verificado",
                                "Polo em -1/τ identificado"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da transformada de Laplace (sem erros em derivadas)",
                                "Correção algébrica ao isolar G(s)",
                                "Identificação correta de K e τ",
                                "Interpretação física da função de transferência",
                                "Eficiência temporal e clareza na documentação",
                                "Validação com ganho DC e polo"
                              ],
                              "crossCurricularConnections": [
                                "Controle Automático: Uso de G(s) em laços de feedback PID para estabilização térmica",
                                "Termodinâmica: Modelagem de balanço de energia em trocadores de calor aeronáuticos",
                                "Engenharia Mecânica: Análise de sistemas de refrigeração em aviões",
                                "Matemática Aplicada: Resolução de EDOs lineares invariantes no tempo",
                                "Eletrônica: Analogia com filtros RC de primeira ordem"
                              ],
                              "realWorldApplication": "Em aeronaves, converte equações de dinâmica térmica de aviônicos ou cabines em G(s) para projetar controladores que mantêm temperaturas estáveis durante voo, prevenindo falhas por superaquecimento ou congelamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Construir diagrama de blocos simples",
                            "description": "Desenhar diagrama com bloco integrador 1/s, realimentação e soma para representar o modelo térmico de primeiro ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Modelo Matemático do Sistema Térmico de Primeira Ordem",
                                  "subSteps": [
                                    "Revise a equação diferencial básica: C * dT/dt = Q_in + hA*(T_amb - T), onde C é capacitância térmica, Q_in é fluxo de calor de entrada, hA é coeficiente de perda térmica, T é temperatura do sistema e T_amb é temperatura ambiente.",
                                    "Transforme para o domínio de Laplace: T(s) = [Q_in(s) + hA*T_amb(s)] / (C s + hA).",
                                    "Identifique os elementos chave: soma das entradas efetivas, integrador (1/(C s)) e realimentação negativa (hA).",
                                    "Esboce esquematicamente o fluxo físico: entrada de calor → soma com perda → integração para temperatura.",
                                    "Anote os parâmetros numéricos de exemplo para fixação (ex: C=100 J/K, hA=10 W/K)."
                                  ],
                                  "verification": "Escreva a equação em forma de diagrama de blocos conceitual simples e explique cada termo para um colega.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência de modelagem térmica (livro ou PDF)"
                                  ],
                                  "tips": "Pense em termos físicos: o integrador representa armazenamento de calor, realimentação é perda por convecção.",
                                  "learningObjective": "Dominar a representação matemática e identificar componentes blocos do modelo térmico.",
                                  "commonMistakes": [
                                    "Confundir sinal da realimentação (deve ser negativa para perda)",
                                    "Esquecer o termo T_amb na soma"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Preparar os Blocos Funcionais",
                                  "subSteps": [
                                    "Liste os blocos necessários: Somador (sinal + para Q_in e hA*T_amb, - para hA*T), Integrador (1/(C s)), Ganho de realimentação (hA).",
                                    "Desenhe símbolos padrão: círculo para soma, retângulo para integrador e ganho, setas para conexões.",
                                    "Defina entradas/saídas: Entrada principal Q_in(s), perturbação T_amb(s), saída T(s).",
                                    "Calcule ganhos normalizados se aplicável (ex: divida por C para tau = C/hA).",
                                    "Crie rascunho dos blocos isolados com rótulos preliminares."
                                  ],
                                  "verification": "Confira se todos os 3 blocos principais (soma, integrador, feedback) estão listados com funções corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Símbolos de diagrama de blocos impressos ou digitais (ex: Draw.io)"
                                  ],
                                  "tips": "Use convenções padrão IEEE para símbolos para profissionalismo.",
                                  "learningObjective": "Reconhecer e preparar blocos funcionais equivalentes à equação diferencial.",
                                  "commonMistakes": [
                                    "Usar integrador 1/s sem escalar por 1/C",
                                    "Omitir entrada de T_amb"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Conectar o Diagrama de Blocos",
                                  "subSteps": [
                                    "Posicione o somador à esquerda: entradas Q_in e hA*T_amb no +, saída do feedback hA*T no -.",
                                    "Conecte saída do somador ao integrador 1/(C s), com saída T(s).",
                                    "Adicione loop de realimentação: de T(s) → ganho hA → de volta ao somador (-).",
                                    "Inclua entrada direta hA*T_amb ao somador (+).",
                                    "Desenhe setas claras indicando direção do sinal e rótulos em cada conexão."
                                  ],
                                  "verification": "Trace o caminho do sinal de Q_in até T(s) e confirme que corresponde à equação de Laplace.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (papel, lápis, borracha ou software como MATLAB Simulink ou Lucidchart)"
                                  ],
                                  "tips": "Mantenha o diagrama limpo: use linhas retas e espaçamento uniforme entre blocos.",
                                  "learningObjective": "Montar conexões precisas para representar dinâmicas do sistema.",
                                  "commonMistakes": [
                                    "Conexão errada do feedback (deve ser negativa)",
                                    "Inverter entradas do somador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Rotular, Validar e Refinar o Diagrama",
                                  "subSteps": [
                                    "Rotule todos os blocos com funções exatas (ex: '1/(C s)', 'hA') e variáveis (Q_in(s), T(s)).",
                                    "Simule mentalmente ou derive a função de transferência do diagrama e compare com a equação original.",
                                    "Verifique equilíbrio em estado estacionário: para Q_in constante, T_ss = Q_in / hA + T_amb.",
                                    "Adicione notas sobre suposições (ex: lineares, lumpadas).",
                                    "Limpe o diagrama final e prepare para apresentação."
                                  ],
                                  "verification": "Derive a função de transferência do diagrama e confirme igualdade com T(s)/Q_in(s) = 1/(C s + hA).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmos do passo anterior",
                                    "Folha de verificação de equações"
                                  ],
                                  "tips": "Use cores diferentes para entradas, saídas e feedbacks para clareza.",
                                  "learningObjective": "Garantir precisão e completude do diagrama através de validação.",
                                  "commonMistakes": [
                                    "Rótulos inconsistentes (s vs tempo)",
                                    "Não validar função de transferência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um dissipador de calor em um motor de aeronave com C=200 J/K, hA=20 W/K: desenhe o diagrama com Q_in como calor gerado pelo motor, T_amb=300K ambiente, resultando em T(s) = [Q_in(s) + 20*300] / (200 s + 20).",
                              "finalVerifications": [
                                "O somador tem três entradas: +Q_in, +hA*T_amb, -hA*T?",
                                "O integrador é corretamente 1/(C s) após o somador?",
                                "O loop de realimentação conecta T → hA → somador(-)?",
                                "Função de transferência derivada do diagrama matches a equação original?",
                                "Todos os blocos e conexões estão rotulados claramente?",
                                "Diagrama representa corretamente equilíbrio em regime permanente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e representação dos blocos funcionais (30%)",
                                "Correção das conexões e sinais (realimentação negativa) (25%)",
                                "Rótulos completos e unidades consistentes (20%)",
                                "Validação via função de transferência (15%)",
                                "Clareza visual e profissionalismo do diagrama (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e funções de transferência",
                                "Física: Leis de conservação de energia e transferência de calor",
                                "Engenharia de Controle: Análise de laços de realimentação",
                                "Engenharia Mecânica: Modelagem termodinâmica de fluidos",
                                "Programação: Simulação em MATLAB/Simulink"
                              ],
                              "realWorldApplication": "Em engenharia aeronáutica, usado para projetar sistemas de controle térmico de eletrônicos de bordo ou motores, prevendo respostas térmicas a cargas variáveis e integrando em controladores PID para manter temperaturas operacionais seguras durante voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Simplificar diagramas de blocos em cascata",
                            "description": "Aplicar regras de simplificação (soma em série, realimentação) para diagramas de sistemas térmicos com múltiplos tanques.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar estrutura de diagramas de blocos em cascata para sistemas térmicos",
                                  "subSteps": [
                                    "Desenhe ou examine um diagrama de blocos representando múltiplos tanques em cascata, onde a saída de um tanque é a entrada do próximo.",
                                    "Identifique blocos individuais (ganhos, somadores) e conexões em série.",
                                    "Escreva as equações diferenciais simplificadas para cada tanque térmico (ex: dT/dt = (Qin - Qout)/C).",
                                    "Marque pontos de soma em série e potenciais loops de realimentação.",
                                    "Converta equações em funções de transferência (G(s) = 1/(τs + 1) para cada tanque)."
                                  ],
                                  "verification": "Confirme que todos os blocos e conexões estão corretamente rotulados com funções de transferência e que as equações correspondem ao diagrama.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, software de diagramação (ex: Draw.io ou MATLAB Simulink), notas de aula sobre modelagem térmica.",
                                  "tips": "Comece sempre pela entrada e saída para mapear o fluxo de sinal térmico.",
                                  "learningObjective": "Compreender a topologia de diagramas em cascata e representar sistemas térmicos em domínio Laplace.",
                                  "commonMistakes": "Confundir soma em série com paralelo; ignorar constantes de tempo específicas de cada tanque."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar regra de simplificação por soma em série",
                                  "subSteps": [
                                    "Selecione blocos consecutivos sem ramificações (em série).",
                                    "Multiplique as funções de transferência: G_total(s) = G1(s) * G2(s) * ... * Gn(s).",
                                    "Substitua os blocos em série por um único bloco equivalente.",
                                    "Verifique se o numerador e denominador estão corretamente expandidos.",
                                    "Redesenhe o diagrama removendo os blocos originais e inserindo o novo."
                                  ],
                                  "verification": "O diagrama atualizado deve ter um bloco único no lugar da cadeia em série, com G_total(s) igual ao produto verificado algebricamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, calculadora simbólica (ex: SymPy ou MATLAB), exemplos de funções de transferência de tanques.",
                                  "tips": "Use fatoração para simplificar polinômios resultantes e manter legibilidade.",
                                  "learningObjective": "Executar simplificação algébrica de blocos em série com precisão.",
                                  "commonMistakes": "Erros em multiplicação de frações racionais; esquecer de normalizar o ganho DC."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar simplificação de realimentação e outras regras",
                                  "subSteps": [
                                    "Identifique loops de realimentação unitária ou com ganho H(s).",
                                    "Aplique fórmula: G_eq(s) = G(s) / (1 + G(s)H(s)) para realimentação negativa.",
                                    "Combine com simplificações anteriores se houver blocos em série no forward path.",
                                    "Trate somadores e divisores adequadamente (ex: para realimentação positiva, 1 - G H).",
                                    "Atualize o diagrama iterativamente até não haver mais simplificações óbvias."
                                  ],
                                  "verification": "Simule ou calcule resposta ao degrau no diagrama original e simplificado; devem coincidir em regime permanente e transitório inicial.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de simulação (MATLAB/Simulink ou Python Control Systems Library), diagramas de exemplo.",
                                  "tips": "Desenhe setas de sinal claramente para distinguir forward e feedback paths.",
                                  "learningObjective": "Manipular estruturas de realimentação em contextos térmicos.",
                                  "commonMistakes": "Confundir sinal positivo/negativo no somador; não cancelar polos/zeros comuns."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar o diagrama simplificado",
                                  "subSteps": [
                                    "Compare função de transferência final com a original expandida.",
                                    "Teste com entradas específicas (degrau, rampa) para validar numericamente.",
                                    "Identifique e elimine redundâncias adicionais (ex: ganhos constantes).",
                                    "Documente o processo de simplificação em um relatório curto.",
                                    "Pratique com variação: adicione ruído térmico e simplifique novamente."
                                  ],
                                  "verification": "Diagrama final tem ≤ 3 blocos principais e simulações coincidem com erro < 1%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Simulador (Simulink), planilha para cálculos numéricos.",
                                  "tips": "Sempre verifique o ganho estático (s=0) para conservação de massa/energia térmica.",
                                  "learningObjective": "Garantir robustez da simplificação através de validação.",
                                  "commonMistakes": "Sobresimplificação levando a perda de dinâmica; erros numéricos em simulações."
                                }
                              ],
                              "practicalExample": "Considere dois tanques em cascata: Tanque 1 (τ1=2s, K1=1) recebe Qin, saída T1 alimenta Tanque 2 (τ2=3s, K2=1). Diagrama: Qin → [1/(2s+1)] → [+] → [1/(3s+1)] → T2, com realimentação de T2 para o somador com H(s)=0.5. Simplifique: Série dá G(s)=1/((2s+1)(3s+1)), então com feedback: G_eq= G/(1+0.5G). Resultado final: bloco único com polinômio de 3ª ordem.",
                              "finalVerifications": [
                                "Função de transferência simplificada é idêntica à original quando expandida.",
                                "Resposta ao degrau simula com erro máximo <2% em todos os pontos.",
                                "Diagrama final possui no máximo 2-3 blocos conectados.",
                                "Conservação de energia térmica no regime permanente (ganho DC=1).",
                                "Processo documentado identifica cada regra aplicada.",
                                "Teste com variação de parâmetros (ex: τ alterado) mantém validade."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica: 100% corretude em multiplicações e divisões.",
                                "Eficiência: Simplificação completa em ≤4 iterações.",
                                "Validação: Simulações coincidem com métricas de erro definidas.",
                                "Clareza: Diagrama final legível com legendas e equações.",
                                "Compreensão: Explicação verbal correta das regras usadas.",
                                "Criatividade: Aplicação correta a diagrama não-trivial com realimentação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de funções racionais e análise de polinômios.",
                                "Física: Leis de conservação de energia em transferência de calor.",
                                "Engenharia de Controle: Teoria de diagramas de blocos e estabilidade.",
                                "Programação: Simulação numérica em MATLAB/Python para validação.",
                                "Modelagem Computacional: Uso de ferramentas como Simulink para sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em aeronaves, simplificar modelos de sistemas de refrigeração com múltiplos trocadores de calor (tanques) em cascata permite otimizar controle de temperatura de eletrônicos e cabines, reduzindo peso e consumo de combustível via controladores PID eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Modelagem de Sistemas Hidráulicos",
                    "description": "Aplicação de transformadas de Fourier e funções de frequência em tubulações e reservatórios.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Modelagem Linear de Tubulações Hidráulicas",
                        "description": "Derivação e linearização das equações diferenciais que descrevem o fluxo em tubulações hidráulicas, utilizando princípios de conservação de massa e momento, para obter modelos lineares adequados à análise em domínio da frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Derivar equações de continuidade e momentum para tubulações",
                            "description": "Aplicar as leis de conservação de massa e quantidade de movimento para formular as equações diferenciais parciais que governam o comportamento dinâmico do fluido em tubulações rígidas ou flexíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer o Modelo Físico Unidimensional e Volume de Controle",
                                  "subSteps": [
                                    "Defina a tubulação como um domínio 1D ao longo do eixo x, com seção transversal A(x,t) variável para tubulações flexíveis.",
                                    "Escolha um volume de controle diferencial dx, considerando propriedades como densidade ρ(x,t), velocidade média u(x,t) e pressão p(x,t).",
                                    "Identifique fluxos de massa na entrada (ρ u A)|_x e saída (ρ u A)|_{x+dx}, e taxa de acumulação ∂(ρ A)/∂t dx.",
                                    "Liste assunções iniciais: fluxo unidimensional, incompressibilidade aproximada (ρ constante), sem fontes/sumidouros de massa.",
                                    "Desenhe um diagrama esquemático do volume de controle destacando termos de fluxo e forças."
                                  ],
                                  "verification": "Construa um diagrama do volume de controle com todos os fluxos e propriedades anotados corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Livro-texto de mecânica dos fluidos (ex: White ou Munson)",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Sempre normalize pelo comprimento dx para obter formas diferenciais; visualize o fluido como 'pacotes' movendo-se ao longo da tubulação.",
                                  "learningObjective": "Compreender a redução do problema 3D para 1D e setup do balanceamento de conservação.",
                                  "commonMistakes": [
                                    "Ignorar variação de A(x,t) em tubulações flexíveis",
                                    "Confundir velocidade axial u com velocidade local",
                                    "Esquecer de dividir pela área A nos fluxos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Equação de Continuidade (Conservação de Massa)",
                                  "subSteps": [
                                    "Aplique a lei de conservação de massa: taxa de mudança dentro do CV = fluxo netto.",
                                    "Escreva a forma integral: d/dt ∫ ρ A dx = [ρ u A]_x - [ρ u A]_{x+dx}.",
                                    "Expanda para diferencial: ∂(ρ A)/∂t + ∂(ρ u A)/∂x = 0.",
                                    "Simplifique para ρ constante (incompressível): ∂A/∂t + ∂Q/∂x = 0, onde Q = u A é a vazão.",
                                    "Relacione com pressão para tubulações elásticas: ∂p/∂t = (B/A) ∂Q/∂x, introduzindo módulo de bulk B."
                                  ],
                                  "verification": "Derive e escreva a equação ∂A/∂t + ∂Q/∂x = 0 a partir do balanceamento, verificando unidades (m²/s).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Caderno de equações",
                                    "Referência: Notas de dinâmica de fluidos ou livro de sistemas hidráulicos",
                                    "Calculadora simbólica como SymPy online"
                                  ],
                                  "tips": "Use o teorema da divergência em 1D para justificar a forma ∂/∂x; teste com A constante (rígida): ∂Q/∂x=0.",
                                  "learningObjective": "Formular a equação diferencial parcial de continuidade para fluxo em tubulações.",
                                  "commonMistakes": [
                                    "Esquecer o termo ∂A/∂t para tubulações flexíveis",
                                    "Tratar ρ como variável sem justificativa",
                                    "Confundir Q (vazão volumétrica) com ρ Q (vazão mássica)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Equação de Momentum (Conservação de Quantidade de Movimento)",
                                  "subSteps": [
                                    "Defina forças atuantes no CV: pressão diferencial (p A)|_x - (p A)|_{x+dx}, cisalhamento parietal τ π D dx (fricção), gravidade ρ g A dx sinθ.",
                                    "Aplique conservação de momentum: ∂(ρ u A)/∂t dx + ∂(ρ u² A)/∂x dx = soma de forças.",
                                    "Simplifique para ρ constante e u médio: ∂Q/∂t + ∂(α Q² / A)/∂x + g A ∂h/∂x + (f Q |Q|)/(2 D A) = - ∂p/∂x A, onde α é coeficiente de correção.",
                                    "Para linearização (pequenas perturbações): ∂u/∂t + u₀ ∂u/∂x + (1/ρ) ∂p/∂x = - (f u₀ |u₀|)/(2 D).",
                                    "Integre assunções como fluxo laminar/turbulento e geometria (D diâmetro)."
                                  ],
                                  "verification": "Escreva a forma linearizada ∂u/∂t + (1/ρ) ∂p/∂x = 0 (sem fricção) e confirme dimensionalidade.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Tabelas de fatores de fricção (Moody chart PDF)",
                                    "Software MATLAB/Simulink para verificação numérica"
                                  ],
                                  "tips": "Comece sem fricção para capturar dinâmica inercial; adicione termos dissipativos depois; use notação consistente para Q vs u.",
                                  "learningObjective": "Obter a equação de momentum 1D acoplada à continuidade para tubulações.",
                                  "commonMistakes": [
                                    "Negligenciar o termo convectivo ∂(u²)/∂x inicialmente",
                                    "Erro de sinal nas forças de pressão",
                                    "Confundir coeficiente de perda Darcy-Weisbach"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Simplificar e Integrar as Equações para Modelagem Linear",
                                  "subSteps": [
                                    "Acople as equações: sistema hiperbólico de PDEs {continuidade, momentum}.",
                                    "Linearize em torno de estado estacionário (u=U₀, p=P₀): perturbações ũ, p̃.",
                                    "Obtenha formas finais: ∂p̃/∂t + (B/A₀) ∂Q̃/∂x = 0; ∂Q̃/∂t + (A₀/ρ) ∂p̃/∂x = 0 (sem perdas).",
                                    "Verifique consistência: ondas sonoras c=√(B/ρ), tempo característico L/c.",
                                    "Discuta limites: rígida (B→∞, ∂Q/∂x=0), inviscida (f=0)."
                                  ],
                                  "verification": "Escreva o sistema linearizado em matriz e resolva para velocidades de onda características.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de verificação de unidades",
                                    "Exemplos resolvidos de livros de controle (ex: Ogata)",
                                    "Python com NumPy para eigenvalues"
                                  ],
                                  "tips": "Use expansão em série de Taylor para linearização; teste com caso simples de tubo rígido infinito.",
                                  "learningObjective": "Finalizar equações prontas para simulação e análise de sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Linearizar incorretamente termos quadráticos",
                                    "Esquecer normalização pelas áreas/velocidades de equilíbrio",
                                    "Ignorar efeitos de compressibilidade em altas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um atuador hidráulico de flap de aeronave, derive as equações para uma tubulação de 5m de comprimento, D=2cm, B=2GPa, modelando pulsos de pressão devido a comandos rápidos de controle.",
                              "finalVerifications": [
                                "Equação de continuidade derivada corretamente como ∂A/∂t + ∂Q/∂x = 0 ou equivalente linearizada.",
                                "Equação de momentum inclui termos inercial, pressão e fricção com sinais corretos.",
                                "Sistema acoplado em forma matricial para linearizado, com velocidades de onda √(A B / (ρ L²)) consistentes.",
                                "Unidades verificadas: continuidade [m²/s], momentum [m/s²].",
                                "Limites especiais (rígida/flexível, inviscida) reproduzidos corretamente.",
                                "Diagrama de volume de controle completo e anotado."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (equações exatas, sem erros algébricos).",
                                "Correta identificação e justificativa de assunções (1D, incompressível, etc.).",
                                "Consistência dimensional e de unidades em todos os termos.",
                                "Capacidade de linearizar e obter forma hiperbólica padrão.",
                                "Explicação clara de termos físicos (ex: significado de B, f).",
                                "Aplicação correta a exemplo numérico simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais hiperbólicas e método de características.",
                                "Física: Mecânica dos fluidos e acústica de tubos (ondas de pressão).",
                                "Engenharia de Controle: Modelagem state-space para simulação em Simulink.",
                                "Computação: Implementação numérica via método de diferenças finitas ou FVM.",
                                "Engenharia Mecânica: Análise de perdas por fricção em tubulações."
                              ],
                              "realWorldApplication": "Modelagem de circuitos hidráulicos em aeronaves para prever oscilações de pressão em sistemas de controle de voo, freios antibloqueio (ABS) automotivos ou linhas de combustível em motores, permitindo design de amortecedores e controladores estáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Linearizar modelos de tubulações em torno de pontos de operação",
                            "description": "Realizar a linearização das equações não lineares de fluxo hidráulico utilizando expansões de Taylor, definindo variáveis de desvio para preparar o modelo para análise de sinais e sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e compreender o modelo não linear de tubulações hidráulicas",
                                  "subSteps": [
                                    "Identifique as equações diferenciais não lineares governantes do fluxo hidráulico em tubulações, como a equação de Darcy-Weisbach para perdas de carga.",
                                    "Descreva as variáveis principais: pressão (P), vazão (Q), comprimento (L), diâmetro (D), rugosidade (ε) e fluido (ρ, μ).",
                                    "Analise dependências não lineares, como o fator de fricção f(Q) ou termos quadráticos em Q².",
                                    "Esboce um diagrama esquemático de uma tubulação simples com entrada/saída.",
                                    "Derive ou recite a forma geral das equações de continuidade e momento para o sistema."
                                  ],
                                  "verification": "O aluno pode listar todas as equações não lineares e explicar cada termo não linear verbalmente ou em um diagrama.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de dinâmica de fluidos",
                                    "Folha de papel e caneta para esboços",
                                    "Software MATLAB/Simulink para visualização opcional"
                                  ],
                                  "tips": "Comece com equações 1D simplificadas para tubos retos; ignore efeitos transientes inicialmente.",
                                  "learningObjective": "Compreender a estrutura matemática do modelo não linear para identificar pontos de linearização.",
                                  "commonMistakes": [
                                    "Confundir equações de continuidade com momentum",
                                    "Ignorar dependência não linear do fator de fricção em Reynolds"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e calcular o ponto de operação (steady-state)",
                                  "subSteps": [
                                    "Escolha condições de operação nominal: valores constantes de P₀, Q₀, etc., resolvendo equações em regime permanente.",
                                    "Resolva numericamente ou analiticamente para steady-state: defina dP/dt = 0 e dQ/dt = 0 nas equações.",
                                    "Calcule parâmetros derivados como número de Reynolds (Re₀) e fator de fricção f₀.",
                                    "Documente o vetor de estado em steady-state: x₀ = [P₀, Q₀].",
                                    "Valide o ponto com simulação simples ou verificação dimensional."
                                  ],
                                  "verification": "Apresente valores numéricos corretos para x₀ em um exemplo dado e justifique cálculos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou MATLAB para resolução numérica",
                                    "Tabelas de propriedades de fluidos",
                                    "Planilha Excel para iterações"
                                  ],
                                  "tips": "Use método de bisseção ou fsolve no MATLAB para soluções não lineares em steady-state.",
                                  "learningObjective": "Selecionar e computar precisamente o ponto de equilíbrio em torno do qual linearizar.",
                                  "commonMistakes": [
                                    "Escolher ponto instável ou fora do domínio físico",
                                    "Erros em unidades ao calcular Re"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar expansão de Taylor de primeira ordem em torno do ponto de operação",
                                  "subSteps": [
                                    "Defina variáveis de desvio: x = x₀ + δx, u = u₀ + δu, onde δx são pequenas perturbações.",
                                    "Expanda cada equação não linear f(x,u) ≈ f(x₀,u₀) + (∂f/∂x)|₀ δx + (∂f/∂u)|₀ δu, descartando termos de ordem superior.",
                                    "Calcule as matrizes Jacobianas A = ∂f/∂x|₀ e B = ∂f/∂u|₀ simbolicamente ou numericamente.",
                                    "Simplifique para obter δẋ = A δx + B δu.",
                                    "Verifique linearidade testando com pequenas perturbações."
                                  ],
                                  "verification": "Derive corretamente as matrizes A e B para um modelo dado e mostre que f(x₀,u₀)=0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software SymPy ou MATLAB Symbolic Toolbox",
                                    "Papel para derivações manuais",
                                    "Exemplos resolvidos de livros de controle"
                                  ],
                                  "tips": "Use aproximação simbólica para evitar erros numéricos; foque em termos dominantes.",
                                  "learningObjective": "Executar a linearização matemática via Taylor, obtendo o modelo linearizado.",
                                  "commonMistakes": [
                                    "Esquecer o termo zero-ordem f(x₀,u₀)=0",
                                    "Erros de sinal nas derivadas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, simular e interpretar o modelo linearizado",
                                  "subSteps": [
                                    "Simule o modelo linearizado vs. original com perturbações pequenas (e.g., 5-10% de x₀).",
                                    "Compare respostas em tempo: plote δP(t) e δQ(t) para entrada degrau em δu.",
                                    "Analise estabilidade via autovalores de A.",
                                    "Discuta limites de validade (regime linear: ||δx|| << ||x₀||).",
                                    "Prepare o modelo para análise de sinais e sistemas (e.g., função de transferência)."
                                  ],
                                  "verification": "Gráficos de simulação mostram sobreposição >95% para perturbações pequenas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Ferramenta de plotagem (Python Matplotlib)",
                                    "Computador com software instalado"
                                  ],
                                  "tips": "Use linearize() no Simulink para verificação rápida.",
                                  "learningObjective": "Confirmar precisão da linearização e preparar para controle.",
                                  "commonMistakes": [
                                    "Simular perturbações grandes invalidando linearidade",
                                    "Ignorar efeitos de atraso em tubos longos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema hidráulico de freios de aeronave, linearize o modelo de uma tubulação de 5m de comprimento (D=0.02m, ε=0.0001m) em operação nominal Q₀=0.001 m³/s, P₀=10 bar. Aplique degrau de 10% na vazão de entrada e compare respostas linear vs. não linear.",
                              "finalVerifications": [
                                "Derivação correta das matrizes A e B para modelo dado.",
                                "Simulações mostram erro <5% em regime linear.",
                                "Explicação verbal das variáveis de desvio e seu significado físico.",
                                "Identificação correta de autovalores e estabilidade.",
                                "Discussão de aplicações em controle de sistemas hidráulicos.",
                                "Preparação da função de transferência G(s) = C(sI-A)⁻¹B."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na expansão de Taylor (100% das derivadas corretas).",
                                "Qualidade das simulações e comparações (gráficos claros, métricas de erro).",
                                "Compreensão conceitual (explicação de desvio vs. total).",
                                "Validação física (unidades consistentes, regime válido).",
                                "Criatividade na interpretação (limites, melhorias).",
                                "Documentação completa (equações, códigos, plots)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Taylor e Jacobianas multivariáveis.",
                                "Controle Automático: Modelos lineares para análise de Bode e Nyquist.",
                                "Mecânica dos Fluidos: Equações de Navier-Stokes simplificadas.",
                                "Programação: Uso de ferramentas numéricas/simuladoras.",
                                "Engenharia de Controle: Projeto de controladores para atuadores hidráulicos."
                              ],
                              "realWorldApplication": "Linearização é essencial para projetar controladores em sistemas hidráulicos de aeronaves, como atuadores de flaps ou freios, permitindo análise de estabilidade e desempenho via ferramentas lineares em Simulink, otimizando resposta dinâmica sob variações de carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Obter função de transferência de tubulações hidráulicas",
                            "description": "Converter o modelo linearizado em espaço de estados ou equações diferenciais em função de transferência no domínio de Laplace, identificando polos e zeros associados ao comportamento dinâmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo linearizado da tubulação hidráulica",
                                  "subSteps": [
                                    "Identifique as equações diferenciais ou representação em espaço de estados do modelo linearizado.",
                                    "Defina as variáveis de entrada (u, ex: pressão de entrada) e saída (y, ex: vazão).",
                                    "Verifique as condições de linearização (pequenas perturbações em torno do ponto de operação).",
                                    "Anote os parâmetros físicos da tubulação (comprimento L, diâmetro D, viscosidade μ, densidade ρ).",
                                    "Desenhe um diagrama esquemático da tubulação destacando os elementos dinâmicos."
                                  ],
                                  "verification": "O modelo está claramente documentado com variáveis, parâmetros e equações prontas para transformação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre modelagem hidráulica",
                                    "Folha de papel ou software de diagramação (ex: Draw.io)",
                                    "Referência: Livro de Dinâmica de Fluidos"
                                  ],
                                  "tips": "Sempre relacione os parâmetros físicos aos coeficientes das equações para manter o contexto prático.",
                                  "learningObjective": "Compreender a estrutura do modelo linearizado e suas variáveis chave.",
                                  "commonMistakes": [
                                    "Confundir variáveis de estado com entradas/saídas",
                                    "Ignorar condições de linearização",
                                    "Esquecer unidades dos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a transformada de Laplace ao modelo",
                                  "subSteps": [
                                    "Aplique condições iniciais nulas (típico para funções de transferência).",
                                    "Transforme as equações diferenciais em álgebraicas no domínio s.",
                                    "Para espaço de estados: converta \\dot{x} = Ax + Bu em (sI - A)X(s) = Bu(s).",
                                    "Obtenha expressões para X(s), Y(s) em termos de U(s).",
                                    "Simplifique as expressões algébricas eliminando variáveis intermediárias."
                                  ],
                                  "verification": "Todas as equações estão no domínio de Laplace sem derivadas, apenas em s.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Software simbólico como MATLAB Symbolic ou Mathematica",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use a propriedade da derivada: L{ḟ} = sF(s) - f(0), e assuma f(0)=0.",
                                  "learningObjective": "Dominar a conversão de modelos diferenciais para o domínio de Laplace.",
                                  "commonMistakes": [
                                    "Esquecer o termo inicial f(0)",
                                    "Erros em fatoração de matrizes (sI - A)",
                                    "Não simplificar frações algébricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a função de transferência G(s)",
                                  "subSteps": [
                                    "Para EDOs: isole Y(s)/U(s) da equação transformada.",
                                    "Para espaço de estados: compute G(s) = C(sI - A)^{-1}B + D.",
                                    "Expanda o adjunto ou use fórmula de Cayley-Hamilton se necessário.",
                                    "Simplifique G(s) para forma pólos-zeros: G(s) = K (s-z1)... / (s-p1)...",
                                    "Verifique o ganho estático G(0) e compatibilidade física."
                                  ],
                                  "verification": "G(s) está expressa como quociente de polinômios em s, com grau do denominador >= numerador.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "MATLAB ou Python (control library)",
                                    "Papel para cálculos matriciais",
                                    "Exemplo resolvido de livro de Controle"
                                  ],
                                  "tips": "Use comandos como tf(ss(A,B,C,D)) no MATLAB para validação numérica.",
                                  "learningObjective": "Construir G(s) corretamente a partir de modelos lineares.",
                                  "commonMistakes": [
                                    "Inversão incorreta de (sI - A)",
                                    "Erros de sinal em B ou C",
                                    "Não cancelar polos/zeros comuns"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar polos, zeros e analisar comportamento dinâmico",
                                  "subSteps": [
                                    "Encontre raízes do numerador (zeros) e denominador (polos) usando fatoração ou roots().",
                                    "Classifique polos: reais negativos (estável), complexos (oscilatório), positivos (instável).",
                                    "Calcule tempo de assentamento, overshoot e frequência natural de polos dominantes.",
                                    "Plote o lugar das raízes ou diagrama de Bode para visualização.",
                                    "Relacione polos/zeros aos fenômenos físicos (ex: polo real lento = atrito viscoso)."
                                  ],
                                  "verification": "Lista completa de polos/zeros com classificações e análise qualitativa do comportamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (rlocus, bode)",
                                    "Python (control.matlab)",
                                    "Gráficos impressos de respostas típicas"
                                  ],
                                  "tips": "Foco em polos dominantes (mais próximos do imaginário) para previsão de resposta.",
                                  "learningObjective": "Interpretar polos e zeros em termos de dinâmica física da tubulação.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar multiplicidade de raízes",
                                    "Análise qualitativa sem relação física"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma tubulação hidráulica linearizada com equação de momentum: L/A ρ ḣ = -R h + p_in, onde h é altura, p_in pressão entrada. Aplicando Laplace: s H(s) = - (R A ρ / L) H(s) + P_in(s). Então G(s) = H(s)/P_in(s) = 1 / (τ s + 1), τ = L/(A ρ R). Polos: s=-1/τ (estável, 1ª ordem). Use MATLAB: A=[-1/τ]; B=1; C=1; D=0; tf(ss(A,B,C,D)).",
                              "finalVerifications": [
                                "Derivação correta de G(s) para o exemplo prático.",
                                "Identificação precisa de todos polos e zeros.",
                                "Análise qualitativa do comportamento dinâmico (ex: tempo constante).",
                                "Validação numérica via software sem erros.",
                                "Relacionamento explícito de polos com parâmetros físicos.",
                                "Plot de resposta ao degrau coerente com análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de G(s) (sem erros algébricos).",
                                "Correta identificação e classificação de polos/zeros.",
                                "Profundidade na interpretação física do comportamento dinâmico.",
                                "Uso adequado de ferramentas computacionais para verificação.",
                                "Clareza na documentação e diagramas.",
                                "Capacidade de generalizar para outros modelos hidráulicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e álgebra linear (espaço de estados).",
                                "Controle Automático: Análise de estabilidade e projeto de controladores.",
                                "Mecânica dos Fluidos: Linearização de equações de Navier-Stokes.",
                                "Engenharia de Controle Aeronáutico: Modelagem de atuadores hidráulicos.",
                                "Programação Numérica: Uso de MATLAB/Simulink para simulações."
                              ],
                              "realWorldApplication": "Em aeronaves, funções de transferência de tubulações hidráulicas são usadas para modelar sistemas de controle de superfícies (flaps, lemes), prevendo atrasos e oscilações na resposta hidráulica para design de controladores estáveis em manobras de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Modelagem Linear de Reservatórios Hidráulicos",
                        "description": "Formulação de modelos matemáticos para reservatórios interconectados, considerando níveis de fluido e vazões, com linearização para aplicação de técnicas de análise de frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Modelar dinâmica de níveis em reservatórios acoplados",
                            "description": "Estabelecer equações de balanço de massa para reservatórios hidráulicos, incorporando relações lineares ou linearizadas entre níveis de fluido e vazões de entrada/saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o balanço de massa para reservatório único",
                                  "subSteps": [
                                    "Revise a lei de conservação de massa para fluidos incompressíveis.",
                                    "Identifique vazões de entrada (Qin) e saída (Qout) em função do nível h.",
                                    "Escreva a equação diferencial dh/dt = (A)^{-1} (Qin - Qout(h)).",
                                    "Relacione Qout com h usando lei de Torricelli: Qout = C sqrt(2gh).",
                                    "Discuta linearização básica em torno de um ponto de equilíbrio h0."
                                  ],
                                  "verification": "Derive corretamente a EDO não-linear para um reservatório e verifique dimensionalmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de dinâmica de fluidos",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre verifique unidades: vazão em m³/s, área A em m², h em m.",
                                  "learningObjective": "Dominar o princípio de balanço de massa aplicado a reservatórios hidráulicos isolados.",
                                  "commonMistakes": [
                                    "Confundir sinal de vazões (entrada positiva, saída negativa)",
                                    "Esquecer o inverso da área A",
                                    "Ignorar incompressibilidade do fluido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e diagramar reservatórios acoplados",
                                  "subSteps": [
                                    "Desenhe dois reservatórios com níveis h1 e h2 conectados por tubo.",
                                    "Defina vazões: Qin1, Qout1(h1), Q12(h1 - h2), Qin2, Qout2(h2), Q21(h2 - h1).",
                                    "Especifique parâmetros: áreas A1, A2, coeficientes de vazão C1, C2, C12.",
                                    "Identifique pontos de operação estacionários (h1s, h2s).",
                                    "Liste suposições: fluido incompressível, conexões lineares ou não-lineares."
                                  ],
                                  "verification": "Crie um diagrama esquemático claro com todas as vazões rotuladas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de desenho (Draw.io ou papel)",
                                    "Referências de sistemas hidráulicos"
                                  ],
                                  "tips": "Use setas direcionais para vazões e indique dependências (ex: Q12 >0 se h1>h2).",
                                  "learningObjective": "Visualizar e parametrizar sistemas hidráulicos acoplados.",
                                  "commonMistakes": [
                                    "Invertar direção de vazões de ligação",
                                    "Esquecer vazões de entrada/saída externas",
                                    "Não definir pontos de equilíbrio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar equações de balanço de massa não-lineares",
                                  "subSteps": [
                                    "Escreva dh1/dt = (A1)^{-1} [Qin1 - Qout1(h1) - Q12(h1-h2)].",
                                    "Escreva dh2/dt = (A2)^{-1} [Qin2 + Q12(h1-h2) - Qout2(h2)].",
                                    "Expresse vazões não-lineares: Q12 = C12 sqrt(|h1-h2|) * sign(h1-h2).",
                                    "Verifique equilíbrio: dh/dt=0 implica Qin = somatória de saídas.",
                                    "Forme vetor de estados x = [h1 h2]^T e funções f(x,u)."
                                  ],
                                  "verification": "Substitua valores numéricos simples e confira se equilíbrio é satisfeito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de cálculo (Excel ou MATLAB para testes)",
                                    "Textbook de modelagem de sistemas"
                                  ],
                                  "tips": "Use notação vetorial para generalizar a n reservatórios.",
                                  "learningObjective": "Estabelecer o modelo dinâmico não-linear completo para reservatórios acoplados.",
                                  "commonMistakes": [
                                    "Erros de sinal nas vazões de ligação entre reservatórios",
                                    "Confundir Q12 e Q21 (são opostas)",
                                    "Omitir dependência mútua h1-h2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Linearizar o modelo e formar equações de estado",
                                  "subSteps": [
                                    "Defina desvios: δh1 = h1 - h1s, δh2 = h2 - h2s, δQin, etc.",
                                    "Calcule Jacobiano: ∂f/∂x em equilíbrio para matriz A.",
                                    "Obtenha ∂f/∂u para matriz B (ex: entradas afetam diretamente dh/dt).",
                                    "Escreva δx_dot = A δx + B δu.",
                                    "Verifique estabilidade qualitativa (autovalores de A)."
                                  ],
                                  "verification": "Implemente em MATLAB/Simulink e compare resposta linear vs. não-linear.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SymPy para simbólico)",
                                    "Template de espaço de estados"
                                  ],
                                  "tips": "Use aproximação de Taylor de primeira ordem apenas.",
                                  "learningObjective": "Obter modelo linearizado pronto para análise de controle.",
                                  "commonMistakes": [
                                    "Calcular derivadas parciais incorretamente em sqrt",
                                    "Não zerar termos constantes no equilíbrio",
                                    "Esquecer chain rule em vazões compostas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema hidráulico de aeronave, modele dois tanques de fluido acoplados por uma válvula: tanque principal (A1=0.5m², h1s=2m) alimenta tanque auxiliar (A2=0.3m², h2s=1.5m) via tubo com C12=0.1m²/s. Vazões externas Qin1=0.02m³/s, Qout2=0.01m³/s no equilíbrio. Derive e linearize para simular oscilações de nível durante manobras.",
                              "finalVerifications": [
                                "Equações de balanço de massa não-lineares derivadas corretamente para ambos reservatórios.",
                                "Matriz A de linearização com derivadas parciais precisas e sinais corretos.",
                                "Condições de equilíbrio satisfeitas (dh/dt=0 com Qin e vazões nominais).",
                                "Modelo em forma de espaço de estados δẋ = Aδx + Bδu implementável.",
                                "Simulação numérica confirma linearidade local (erro <5% em 10% de desvio).",
                                "Diagrama esquemático completo com parâmetros rotulados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das EDOs (100% correspondência com teoria).",
                                "Correção de sinais e direções nas vazões acopladas.",
                                "Qualidade da linearização (derivadas parciais exatas).",
                                "Clareza e completude do diagrama e parametrização.",
                                "Validação numérica/simulada com resultados coerentes.",
                                "Generalização para mais reservatórios demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais ordinárias não-lineares e linearização.",
                                "Física: Mecânica dos fluidos e lei de Torricelli.",
                                "Engenharia de Controle: Modelos lineares em espaço de estados.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Engenharia Mecânica: Sistemas hidráulicos e pneumáticos."
                              ],
                              "realWorldApplication": "Modelagem de sistemas hidráulicos em aeronaves, como tanques de combustível acoplados ou circuitos de atuadores de flight controls, permitindo análise de estabilidade, projeto de controladores PID e simulações de falhas para certificação FAA/EASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Linearizar equações de reservatórios hidráulicos",
                            "description": "Aplicar linearização em torno de condições estacionárias para reservatórios, obtendo modelos de primeira ou segunda ordem representativos do comportamento dinâmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo não-linear do reservatório hidráulico",
                                  "subSteps": [
                                    "Identifique as equações diferenciais não-lineares típicas para reservatórios hidráulicos, como A dh/dt = q_in - q_out, onde q_out = C √h.",
                                    "Analise os termos não-lineares, focando em funções como √h ou h² que impedem soluções analíticas diretas.",
                                    "Desenhe um diagrama esquemático do reservatório, indicando variáveis de estado (h), entradas (q_in) e saídas (q_out).",
                                    "Estude exemplos de reservatórios em contextos aeronáuticos, como tanques de combustível ou sistemas de frenagem hidráulica.",
                                    "Registre as suposições do modelo, como incompressibilidade do fluido e geometria constante."
                                  ],
                                  "verification": "Confirme que você pode escrever e explicar a equação não-linear completa para um reservatório genérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Livro de dinâmica de fluidos ou referência em sistemas hidráulicos",
                                    "Software de simulação como MATLAB/Simulink"
                                  ],
                                  "tips": "Comece com modelos simples de reservatório toroidal ou cilíndrico para evitar complexidades iniciais.",
                                  "learningObjective": "Compreender a estrutura matemática do modelo não-linear e suas limitações dinâmicas.",
                                  "commonMistakes": [
                                    "Ignorar variações de área A(h)",
                                    "Confundir q_in com q_out sem considerar direção",
                                    "Esquecer unidades consistentes (m³/s para vazões)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar condições de equilíbrio estacionário",
                                  "subSteps": [
                                    "Defina condições estacionárias: dh/dt = 0, resultando em q_in = q_out(h_ss).",
                                    "Resolva para o ponto de equilíbrio h_ss dado q_in constante, ex: h_ss = (q_in / C)².",
                                    "Calcule variáveis associadas no equilíbrio, como q_out_ss e derivadas parciais necessárias para linearização.",
                                    "Verifique estabilidade qualitativa do equilíbrio analisando o sinal de dq_out/dh.",
                                    "Considere múltiplos equilíbrios se o modelo permitir (ex: histerese em reservatórios com outflow não-monotônico)."
                                  ],
                                  "verification": "Liste as equações e valores numéricos para h_ss e q_ss em um exemplo com q_in = 0.1 m³/s e C=0.5.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy/MATLAB",
                                    "Folha de papel para derivações"
                                  ],
                                  "tips": "Use valores numéricos realistas de sistemas aeronáuticos para tornar o equilíbrio tangível.",
                                  "learningObjective": "Identificar e calcular precisamente os pontos de operação estacionária.",
                                  "commonMistakes": [
                                    "Resolver dh/dt=0 incorretamente",
                                    "Não linearizar em torno de um ponto único",
                                    "Esquecer de verificar se q_in é compatível com o range físico de h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar expansão em série de Taylor para linearização",
                                  "subSteps": [
                                    "Defina perturbações: h(t) = h_ss + δh(t), q_in(t) = q_ss + δq_in(t).",
                                    "Expanda f(h, q_in) = A dh/dt = q_in - C √h em série de Taylor de primeira ordem em torno do equilíbrio.",
                                    "Obtenha δḣ = (1/A) [δq_in - (C/(2√h_ss)) δh], simplificando para modelo de 1ª ordem.",
                                    "Para 2ª ordem, inclua termos quadráticos ou estados adicionais como pressão.",
                                    "Implemente numericamente em software para validar a aproximação."
                                  ],
                                  "verification": "Derive a equação linearizada δḣ = a δh + b δq_in e identifique ganho estático e constante de tempo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Referência em linearização de sistemas não-lineares (ex: Ogata ou Khalil)"
                                  ],
                                  "tips": "Mantenha apenas termos de 1ª ordem para simplicidade inicial; teste com pequenas perturbações.",
                                  "learningObjective": "Executar a linearização matemática corretamente, obtendo coeficientes simbólicos.",
                                  "commonMistakes": [
                                    "Erros no cálculo de ∂f/∂h = -C/(2√h_ss)",
                                    "Incluir termos de ordem superior acidentalmente",
                                    "Confundir δḣ com dh/dt"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar o modelo linear de 1ª ou 2ª ordem",
                                  "subSteps": [
                                    "Escreva o modelo em forma de espaço de estados: ẋ = A x + B u, y = C x + D u.",
                                    "Analise resposta dinâmica: pólos, tempo de acomodação, overshoot via simulação.",
                                    "Compare simulações não-linear vs. linear para validar a aproximação (erros <5% em regime transitório).",
                                    "Estenda para 2ª ordem adicionando dinâmica de tubulação ou válvula.",
                                    "Documente limitações: validade para pequenas perturbações apenas."
                                  ],
                                  "verification": "Simule resposta a degrau em q_in e confirme que modelo linear approx. o não-linear.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink ou Python (control library)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use perturbações de 10% de h_ss para testar limites da linearização.",
                                  "learningObjective": "Construir e validar modelos lineares representativos do comportamento dinâmico.",
                                  "commonMistakes": [
                                    "Não normalizar perturbações",
                                    "Ignorar efeitos de atraso em q_out",
                                    "Validação sem comparação quantitativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um reservatório hidráulico em freio de aeronave: A=0.1 m², C=0.3 m^{5/2}/s, q_in_ss=0.05 m³/s → h_ss ≈ 0.278 m. Linearize para δḣ = (1/0.1) [δq_in - (0.3/(2√0.278)) δh], resultando em τ ≈ 13.3 s.",
                              "finalVerifications": [
                                "Derivação correta de condições estacionárias para exemplo dado.",
                                "Equação linearizada em forma padrão com coeficientes numéricos.",
                                "Simulação mostrando erro <10% entre modelos linear e não-linear.",
                                "Identificação de ordem do modelo (1ª ou 2ª) e análise de pólos.",
                                "Documentação de suposições e limitações.",
                                "Resposta qualitativa correta a entradas como degrau ou rampa."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na linearização (sem erros algébricos).",
                                "Validação numérica/simulada com gráficos comparativos.",
                                "Explicação clara de cada coeficiente (ganho, tempo característico).",
                                "Extensão apropriada para 2ª ordem quando relevante.",
                                "Identificação de aplicações aeronáuticas reais.",
                                "Clareza na documentação e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Controle: Uso do modelo linear para design de PID.",
                                "Dinâmica de Fluidos: Fundamentos de equações de continuidade e Bernoulli.",
                                "Engenharia Aeronáutica: Modelagem de atuadores hidráulicos em flight controls.",
                                "Matemática Aplicada: Séries de Taylor e análise assintótica.",
                                "Sistemas Dinâmicos: Representação em espaço de estados e linearização geral."
                              ],
                              "realWorldApplication": "Na aviação, linearização de reservatórios hidráulicos é essencial para modelar sistemas de controle de voo, como servos hidráulicos em flaps e lemes, permitindo simulações rápidas para certificação FAA e design de controladores estáveis sob perturbações dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Representar reservatórios via diagrama de blocos",
                            "description": "Construir diagramas de blocos funcionais para sistemas de reservatórios, facilitando a análise de composição e decomposição de subsistemas hidráulicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes e variáveis do reservatório hidráulico",
                                  "subSteps": [
                                    "Descreva o reservatório como um tanque com área de seção transversal A.",
                                    "Identifique variáveis de entrada (Qin - fluxo de entrada) e saída (h - altura do fluido).",
                                    "Liste parâmetros fixos como resistências hidráulicas R1 (entrada) e R2 (saída).",
                                    "Defina o ponto de operação estacionário (h0, Qin0 = Qout0).",
                                    "Esboce um diagrama esquemático do sistema físico."
                                  ],
                                  "verification": "Verifique se todas as variáveis e parâmetros estão listados corretamente em uma tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Referência de modelo de reservatório hidráulico"
                                  ],
                                  "tips": "Use convenções padrão de nomenclatura para evitar confusão em passos posteriores.",
                                  "learningObjective": "Compreender a estrutura física e variáveis chave do sistema de reservatório.",
                                  "commonMistakes": [
                                    "Confundir fluxo de entrada com saída",
                                    "Esquecer parâmetros como área A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e linearizar as equações de balanceamento de massa",
                                  "subSteps": [
                                    "Escreva a equação não linear: A dh/dt = Qin - Qout, com Qin = (P_in - h)/R1 e Qout = h/R2.",
                                    "Defina variáveis de desvio: ḣ = h - h0, qin = Qin - Qin0, qout = Qout - Qout0.",
                                    "Linearize em torno de h0: A dḣ/dt ≈ qin - qout, com qin ≈ ΔP/R1 - ḣ/R1, qout ≈ ḣ/R2.",
                                    "Simplifique para: A dḣ/dt + ḣ (1/R1 + 1/R2) = ΔP/R1.",
                                    "Verifique dimensionalidade das equações."
                                  ],
                                  "verification": "Resolva para estado estacionário e confirme que ḣ=0 quando qin=qout=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de equações diferenciais"
                                  ],
                                  "tips": "Anote todas as aproximações lineares para referência futura.",
                                  "learningObjective": "Dominar a derivação e linearização de modelos hidráulicos.",
                                  "commonMistakes": [
                                    "Erros em linearização de termos quadráticos",
                                    "Inverter sinais de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter a função de transferência do sistema",
                                  "subSteps": [
                                    "Aplique transformada de Laplace: A s H(s) + H(s) (1/R1 + 1/R2) = ΔP(s)/R1.",
                                    "Isolar H(s): H(s) = [1/(A s + 1/R1 + 1/R2)] * (ΔP(s)/R1).",
                                    "Simplifique o ganho e polo: τ = A / (1/R1 + 1/R2), K = 1/(1 + A R1 / R2) ajustado.",
                                    "Expresse como H(s)/U(s) onde U=ΔP.",
                                    "Confirme que é um sistema de primeira ordem."
                                  ],
                                  "verification": "Substitua valores numéricos exemplo e plote resposta ao degrau.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy)",
                                    "Tabelas de Laplace"
                                  ],
                                  "tips": "Use s como variável de Laplace consistentemente.",
                                  "learningObjective": "Converter equações diferenciais lineares em funções de transferência.",
                                  "commonMistakes": [
                                    "Esquecer o termo s na transformada",
                                    "Erro no coeficiente do ganho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir o diagrama de blocos funcional",
                                  "subSteps": [
                                    "Desenhe bloco de entrada U(s) = ΔP(s).",
                                    "Adicione bloco de ganho 1/R1 conectado à soma.",
                                    "Inclua realimentações -1/R1 e -1/R2 para a altura H(s).",
                                    "Adicione integrador 1/(A s) após a soma.",
                                    "Some os sinais corretamente e rotule todos os blocos."
                                  ],
                                  "verification": "Simule o diagrama em Simulink e compare com função de transferência analítica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software Simulink ou papel para desenho",
                                    "Templates de diagramas de blocos"
                                  ],
                                  "tips": "Use setas direcionais claras e rotule cada sinal.",
                                  "learningObjective": "Representar visualmente o modelo dinâmico via blocos funcionais.",
                                  "commonMistakes": [
                                    "Sinal errado na realimentação",
                                    "Esquecer integrador"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um reservatório com A=0.1 m², R1=10 s/m², R2=20 s/m², h0=1 m, entrada ΔP=1 Pa. Construa o diagrama: função de transferência H(s)/ΔP(s) = (0.1)/(0.1 s + 0.15), diagrama com ganho 0.1, soma, realimentações -0.1 e -0.05, integrador 1/(0.1 s).",
                              "finalVerifications": [
                                "Diagrama reproduz corretamente a função de transferência derivada.",
                                "Resposta simulada ao degrau matches analítica (τ≈0.67 s).",
                                "Todos os blocos estão rotulados com ganhos e variáveis.",
                                "Sistema é estável e causal.",
                                "Pode decompor em subsistemas (entrada, soma, integrador).",
                                "Explicar verbalmente o fluxo de sinal."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das equações e linearização (20%)",
                                "Correta estrutura do diagrama de blocos (30%)",
                                "Uso apropriado de somadores, ganhos e integradores (20%)",
                                "Clareza e legibilidade do diagrama (15%)",
                                "Validação via simulação ou cálculo (10%)",
                                "Identificação de composição/decomposição de subsistemas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e equações diferenciais lineares.",
                                "Física: Mecânica dos fluidos e conservação de massa.",
                                "Engenharia de Controle: Análise em domínio s e diagramas de blocos.",
                                "Engenharia Mecânica: Modelagem de sistemas hidráulicos.",
                                "Informática: Simulação em MATLAB/Simulink."
                              ],
                              "realWorldApplication": "Em aeronaves, diagramas de blocos modelam reservatórios hidráulicos em sistemas de freios, flaps e trem de pouso, permitindo análise de estabilidade, projeto de controladores e simulação de falhas para certificação de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Análise em Frequência de Sistemas Hidráulicos",
                        "description": "Aplicação da transformada de Fourier e funções de resposta em frequência para caracterizar o comportamento dinâmico de tubulações e reservatórios sob excitações sinusoidais ou periódicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Aplicar transformada de Fourier a sinais hidráulicos",
                            "description": "Calcular a transformada de Fourier de sinais de pressão ou vazão em sistemas hidráulicos, identificando componentes espectrais relevantes para tubulações e reservatórios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais da Transformada de Fourier e Sinais Hidráulicos",
                                  "subSteps": [
                                    "Revise a definição matemática da Transformada de Fourier (FT) e sua interpretação como decomposição em componentes sinusoidais.",
                                    "Estude características de sinais hidráulicos: pressão e vazão em tubulações e reservatórios, incluindo ruído, oscilações e transientes.",
                                    "Aprenda sobre domínio do tempo vs. domínio da frequência e relevância para sistemas hidráulicos (ex.: ressonâncias em tubos).",
                                    "Identifique equações chave: FT contínua X(ω) = ∫ x(t) e^{-jωt} dt e sua versão discreta (DFT).",
                                    "Explore exemplos iniciais de FT aplicada a pulsos ou senos hidráulicos."
                                  ],
                                  "verification": "Resuma em um diagrama os conceitos chave e explique verbalmente a relevância para um sinal de pressão hidráulico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Sinais e Sistemas' de Oppenheim",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Vídeos tutoriais sobre FT"
                                  ],
                                  "tips": "Use animações visuais para entender decomposição espectral; comece com sinais simples como seno puro.",
                                  "learningObjective": "Dominar os princípios teóricos da FT e sua aplicação específica a sinais de pressão/vazão hidráulicos.",
                                  "commonMistakes": [
                                    "Confundir FT com série de Fourier",
                                    "Ignorar normalização na DFT",
                                    "Não considerar janelamento para sinais reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adquirir e Pré-processar Dados de Sinais Hidráulicos",
                                  "subSteps": [
                                    "Colete ou simule dados reais: gere sinal de pressão com oscilações (ex.: 1000 amostras a 1kHz) usando equações hidráulicas básicas.",
                                    "Aplique filtros para remover ruído DC ou alta frequência (ex.: filtro passa-banda).",
                                    "Realize janelamento (Hanning ou Hamming) para minimizar vazamento espectral.",
                                    "Normalize o sinal e verifique estacionariedade (teste de média e variância).",
                                    "Plote sinal no tempo e verifique artefatos."
                                  ],
                                  "verification": "Gere e plote um sinal pré-processado limpo, confirmando ausência de distorções visíveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com bibliotecas SciPy e Matplotlib",
                                    "Dados simulados de tubulação hidráulica (ex.: modelo de onda em tubo)",
                                    "Sensores simulados via Simulink"
                                  ],
                                  "tips": "Use fs > 2*f_max (Nyquist) para evitar aliasing; salve dados em .csv para reprodutibilidade.",
                                  "learningObjective": "Preparar dados hidráulicos reais para análise espectral precisa.",
                                  "commonMistakes": [
                                    "Amostragem insuficiente levando a aliasing",
                                    "Não remover offset DC",
                                    "Escolha errada de janela causando vazamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Transformada de Fourier do Sinal Hidráulico",
                                  "subSteps": [
                                    "Implemente DFT/FFT no software: use fft() no MATLAB/Python para o sinal pré-processado.",
                                    "Calcule magnitude e fase: |X(k)| e arg(X(k)), plotando espectro de potência unilateral.",
                                    "Converta índices para frequências: f = k * fs / N.",
                                    "Valide com sinal conhecido (ex.: seno puro deve mostrar pico único).",
                                    "Compare com FT analítica para sinal simples."
                                  ],
                                  "verification": "Obtenha espectro com picos corretos para um sinal de teste e compare com expectativa teórica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB pronto para FFT",
                                    "Documentação SciPy.signal",
                                    "Calculadora simbólica (SymPy) para validação"
                                  ],
                                  "tips": "Plote log-escala para espectros largos; use fftshift() para centralizar DC.",
                                  "learningObjective": "Executar computação precisa da FT para sinais hidráulicos discretos.",
                                  "commonMistakes": [
                                    "Não dividir por N na magnitude",
                                    "Esquecer fftshift",
                                    "Interpretação errada de eixos de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Interpretar Componentes Espectrais Relevantes",
                                  "subSteps": [
                                    "Identifique picos dominantes: associe a ressonâncias de tubulações (fórmula f = c/(4L) para tubo fechado).",
                                    "Diferencie harmônicos de ruído: use limiares de potência (ex.: > -40dB).",
                                    "Relacione componentes a física hidráulica: baixa freq. para reservatórios, alta para turbulência.",
                                    "Gere relatório: anote frequências chave e implicações (ex.: risco de cavitação).",
                                    "Simule remoção de componentes problemáticos via filtro inverso."
                                  ],
                                  "verification": "Interprete espectro de um sinal hidráulico real, listando 3 componentes relevantes com justificativa física.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelos hidráulicos (equações de onda)",
                                    "Tabelas de frequências ressonantes para tubos aeronáuticos",
                                    "Software de plotagem avançada (Matplotlib)"
                                  ],
                                  "tips": "Correlacione com diagramas de tubulação; valide com literatura de vibrações hidráulicas.",
                                  "learningObjective": "Extrair insights acionáveis de espectros para diagnóstico de sistemas hidráulicos.",
                                  "commonMistakes": [
                                    "Atribuir ruído a ressonâncias",
                                    "Ignorar fase para causalidade",
                                    "Não contextualizar com geometria do sistema"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema hidráulico de freios de aeronave, simule um sinal de pressão com oscilação a 50Hz devido a ressonância em tubulação de 2m (velocidade som 1400m/s). Aplique FT para detectar pico em 50Hz, confirmando risco de fadiga e recomendando redimensionamento do tubo.",
                              "finalVerifications": [
                                "Calcule FT de sinal hidráulico simulado e identifique pelo menos 3 picos com frequências corretas.",
                                "Explique impacto de um componente espectral em tubulação vs. reservatório.",
                                "Gere espectro limpo sem artefatos de pré-processamento.",
                                "Compare análise com modelo físico teórico (erro <5%).",
                                "Documente relatório com plots e conclusões acionáveis.",
                                "Aplique filtro baseado no espectro para atenuar problema identificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo da FT (erro <1% em picos conhecidos).",
                                "Qualidade do pré-processamento (sem vazamento ou aliasing visível).",
                                "Interpretação física correta dos componentes espectrais.",
                                "Relatório claro com plots profissionais e justificativas.",
                                "Criatividade em conexões com aplicações hidráulicas reais.",
                                "Eficiência temporal: completar em <7 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Processamento Digital de Sinais (Engenharia Elétrica): Algoritmos FFT avançados.",
                                "Dinâmica de Fluidos (Engenharia Mecânica): Equações de onda em tubos.",
                                "Controle Automático: Análise de frequência para estabilidade de servomecanismos hidráulicos.",
                                "Vibrações e Acústica: Detecção de modos ressonantes em estruturas fluidicas.",
                                "Engenharia de Dados: Machine Learning para classificação espectral de falhas."
                              ],
                              "realWorldApplication": "Na manutenção de aeronaves, engenheiros usam FT em sinais de pressão hidráulicos para diagnosticar vibrações anômalas em sistemas de controle de voo, prevenindo falhas catastróficas como em atuadores de flaps ou trem de pouso, otimizando design de tubulações para evitar ressonâncias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.3",
                              "10.1.7.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Determinar função de resposta em frequência",
                            "description": "Derivar e plotar a função de frequência H(jω) a partir da função de transferência, analisando magnitude e fase para sistemas hidráulicos lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter ou Derivar a Função de Transferência H(s) do Sistema Hidráulico",
                                  "subSteps": [
                                    "Identifique as equações diferenciais lineares do sistema hidráulico (ex.: equação de continuidade e movimento do pistão).",
                                    "Aplique a transformada de Laplace assumindo condições iniciais zero.",
                                    "Expresse a saída Y(s) em termos da entrada U(s) e isole H(s) = Y(s)/U(s).",
                                    "Simplifique a expressão polinomial, verificando pólos e zeros.",
                                    "Valide com parâmetros físicos típicos de sistemas hidráulicos (ex.: rigidez K, viscosidade B)."
                                  ],
                                  "verification": "H(s) está na forma racional padrão (ex.: K / (s^2 + 2ζω_n s + ω_n^2)) e coeficientes correspondem às propriedades hidráulicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de modelagem de sistemas hidráulicos, software simbólico (MATLAB Symbolic ou SymPy), calculadora.",
                                  "tips": "Use blocos funcionais (integradores, ganhos) para visualizar a estrutura do sistema.",
                                  "learningObjective": "Compreender a origem física da função de transferência em sistemas hidráulicos lineares.",
                                  "commonMistakes": "Ignorar termos de vazamento ou compressibilidade no modelo hidráulico; não linearizar corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Função de Resposta em Frequência H(jω)",
                                  "subSteps": [
                                    "Substitua s = jω na função de transferência H(s) para obter H(jω).",
                                    "Expanda H(jω) em parte real e imaginária: H(jω) = Re + j Im.",
                                    "Verifique se H(jω) é uma função complexa bem definida para ω > 0.",
                                    "Identifique frequências de interesse (ex.: ω_n, ω_corte).",
                                    "Normalise se necessário para análise em dB."
                                  ],
                                  "verification": "Expressão H(jω) corretamente substituída e expandida, sem erros algébricos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e lápis ou editor simbólico (MATLAB, Python com SymPy).",
                                  "tips": "Escreva H(jω) como |H(jω)| e^{j φ(ω)} desde o início para clareza.",
                                  "learningObjective": "Dominar a transição de domínio s para domínio da frequência jω.",
                                  "commonMistakes": "Confundir jω com ωj ou esquecer o j na substituição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Magnitude e Fase de H(jω)",
                                  "subSteps": [
                                    "Calcule a magnitude |H(jω)| = sqrt(Re^2 + Im^2), ou 20 log10(|H|) em dB.",
                                    "Determine a fase φ(ω) = atan2(Im, Re) em graus ou radianos.",
                                    "Avalie em pontos chave: baixa frequência (ω→0), alta (ω→∞), ressonância.",
                                    "Crie tabelas numéricas para pelo menos 10 valores de ω log-espacados.",
                                    "Verifique limites assintóticos (ex.: |H| ~ 1/ω^2 para ordem 2)."
                                  ],
                                  "verification": "Tabela de valores numéricos com magnitude em dB e fase precisa até 0.1 dB/grau.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha (Excel) ou script numérico (MATLAB freqresp ou Python control.freqresp).",
                                  "tips": "Use escalas logarítmicas para ω para capturar comportamento dinâmico.",
                                  "learningObjective": "Calcular quantitativamente magnitude e fase para análise de resposta.",
                                  "commonMistakes": "Erro no atan2 (fase errada em quadrantes); esquecer conversão para dB."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar os Diagramas de Bode de Magnitude e Fase",
                                  "subSteps": [
                                    "Gere eixo de frequência logarítmico de 0.1 a 100 rad/s.",
                                    "Plote magnitude em dB vs. log(ω) e fase em graus vs. log(ω).",
                                    "Adicione assíntotas (linhas retas aproximando o comportamento).",
                                    "Marque pontos críticos: corte -3dB, pico de ressonância, fase margem.",
                                    "Exporte ou imprima gráficos com legendas claras."
                                  ],
                                  "verification": "Gráficos de Bode completos com curvas suaves, assíntotas e anotações precisas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (MATLAB bode(), Python matplotlib + control library).",
                                  "tips": "Use comando bode() pronto para validação rápida.",
                                  "learningObjective": "Visualizar e interpretar resposta em frequência via diagramas padrão.",
                                  "commonMistakes": "Escala linear em vez de log; plotar fase sem unwrap (saltos de 360°)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Magnitude e Fase para o Sistema Hidráulico",
                                  "subSteps": [
                                    "Identifique largura de banda, fator de amortecimento via pico de magnitude.",
                                    "Analise estabilidade: margem de fase >45°, ganho <0dB em crossover.",
                                    "Discuta implicações hidráulicas: oscilações em altas frequências devido a rigidez.",
                                    "Compare com requisitos aeronáuticos (ex.: resposta <0.1s sem overshoot >10%).",
                                    "Sugira modificações (ex.: adicionar compensador)."
                                  ],
                                  "verification": "Relatório de análise com conclusões quantitativas e qualitativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de Bode gerados, template de relatório.",
                                  "tips": "Relacione picos a parâmetros físicos como massa do fluido.",
                                  "learningObjective": "Interpretar análises em frequência para design de sistemas hidráulicos.",
                                  "commonMistakes": "Ignorar efeitos não-lineares em altas frequências; análise sem contexto físico."
                                }
                              ],
                              "practicalExample": "Considere um atuador hidráulico linear modelado por H(s) = 50 / (s^2 + 10s + 100). Substitua s=jω para H(jω) = 50 / (-ω^2 + j10ω + 100). Calcule |H(jω)| e φ(ω), plote Bode: magnitude com pico de ressonância em ~10 rad/s (~2dB), fase cruzando -180° em alta ω. Análise: adequando para controle de flaps aeronáuticos com amortecimento moderado.",
                              "finalVerifications": [
                                "H(jω) derivada corretamente de H(s).",
                                "Magnitude e fase calculadas numericamente em tabela.",
                                "Diagramas de Bode plotados com assíntotas e pontos chave.",
                                "Análise identifica largura de banda e margens de estabilidade.",
                                "Conclusões ligadas a performance hidráulica.",
                                "Sem erros algébricos ou de plotagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação H(jω): 25%.",
                                "Correção dos cálculos de mag/fase: 20%.",
                                "Qualidade e completude dos plots Bode: 20%.",
                                "Profundidade da análise (quantitativa/qualitativa): 20%.",
                                "Conexão com contexto hidráulico/aeronáutico: 10%.",
                                "Clareza do relatório e verificações: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções logarítmicas.",
                                "Física: Dinâmica de fluidos e equações de movimento.",
                                "Engenharia de Controle: Estabilidade e compensação.",
                                "Programação: Scripts numéricos e visualização de dados.",
                                "Engenharia Mecânica: Vibrações e modelagem multi-física."
                              ],
                              "realWorldApplication": "Em aeronáutica, essa análise é essencial para sistemas hidráulicos de controle de superfícies (flaps, slats, lemes), garantindo resposta rápida sem oscilações perigosas durante manobras, otimizando estabilidade de voo e eficiência de combustível."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Interpretar respostas em frequência de tubulações e reservatórios",
                            "description": "Analisar diagramas de Bode para identificar ressonâncias, atenuações e larguras de banda em modelos hidráulicos, relacionando com fenômenos físicos como ondas de pressão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise em Frequência e Diagramas de Bode",
                                  "subSteps": [
                                    "Estudar a definição de resposta em frequência e sua importância em sistemas hidráulicos.",
                                    "Aprender a construir e interpretar diagramas de Bode (magnitude e fase vs. frequência logarítmica).",
                                    "Identificar componentes chave: eixo x (frequência), eixo y (magnitude em dB e fase em graus).",
                                    "Exercitar plotagem manual de funções de transferência simples para tubulações.",
                                    "Comparar respostas em frequência com respostas no tempo para sistemas hidráulicos."
                                  ],
                                  "verification": "Plotar corretamente um diagrama de Bode simples e explicar cada curva.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Sinais e Sistemas (ex: Oppenheim), software MATLAB/Simulink, exemplos de funções de transferência hidráulicas"
                                  ],
                                  "tips": "Use escalas logarítmicas para visualizar melhor comportamentos assintóticos.",
                                  "learningObjective": "Compreender a base teórica dos diagramas de Bode aplicados a sistemas hidráulicos.",
                                  "commonMistakes": [
                                    "Confundir magnitude com fase",
                                    "Ignorar o comportamento em baixas e altas frequências",
                                    "Não normalizar frequências em rad/s"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Tubulações e Reservatórios em Domínio da Frequência",
                                  "subSteps": [
                                    "Derivar funções de transferência para tubulações (equação de onda hidráulica) e reservatórios (capacitância hidráulica).",
                                    "Incorporar efeitos de inércia, viscosidade e compressibilidade nos pólos e zeros.",
                                    "Simular modelos em software para gerar diagramas de Bode reais.",
                                    "Analisar como comprimento da tubulação afeta os pólos de ressonância.",
                                    "Diferenciar respostas de tubulações rígidas vs. flexíveis."
                                  ],
                                  "verification": "Gerar e validar um diagrama de Bode para um modelo de tubulação-reservatório simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com toolbox de controle, planilhas com equações hidráulicas, artigos sobre modelagem hidráulica em aeronáutica"
                                  ],
                                  "tips": "Comece com modelos de primeira ordem e evolua para segundos ordem para capturar ressonâncias.",
                                  "learningObjective": "Construir modelos matemáticos precisos de sistemas hidráulicos em frequência.",
                                  "commonMistakes": [
                                    "Negligenciar perdas viscosas em altas frequências",
                                    "Usar unidades erradas (Hz vs. rad/s)",
                                    "Sobre-simplificar reservatórios como infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Ressonâncias, Atenuações e Larguras de Banda",
                                  "subSteps": [
                                    "Localizar picos de magnitude nos diagramas de Bode como ressonâncias (frequência de pico).",
                                    "Medir atenuação em dB fora da banda de ressonância e calcular largura de banda (-3dB).",
                                    "Interpretar mudanças de fase em torno da ressonância (180° shift).",
                                    "Quantificar fator de qualidade (Q) a partir da largura de banda.",
                                    "Comparar múltiplos diagramas para diferentes configurações hidráulicas."
                                  ],
                                  "verification": "Anotar corretamente frequência de ressonância, atenuação e largura de banda em um diagrama dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Diagramas de Bode de exemplo (tubulações aeronáuticas), régua gráfica ou software para medições precisas"
                                  ],
                                  "tips": "Use cursor no software para medições exatas; memorize que Q = f_r / Δf.",
                                  "learningObjective": "Extrair quantitativamente características dinâmicas de diagramas de Bode hidráulicos.",
                                  "commonMistakes": [
                                    "Confundir largura de banda com frequência de corte",
                                    "Medir picos em escala linear",
                                    "Ignorar múltiplas ressonâncias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Respostas em Frequência com Fenômenos Físicos",
                                  "subSteps": [
                                    "Mapear ressonâncias para ondas de pressão estacionárias em tubulações.",
                                    "Explicar atenuações como dissipação de energia por fricção.",
                                    "Correlacionar largura de banda com estabilidade do sistema hidráulico.",
                                    "Simular excitações em frequência e observar respostas transitórias.",
                                    "Discutir implicações em vibrações e fadiga em aeronaves."
                                  ],
                                  "verification": "Escrever um relatório curto relacionando um diagrama específico a um fenômeno físico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Vídeos de ondas de pressão em tubos, simulações CFD básicas, cases de falhas hidráulicas em aviação"
                                  ],
                                  "tips": "Pense em termos físicos: ressonância = amplificação de pressão perigosa.",
                                  "learningObjective": "Conectar análise matemática a interpretações físicas acionáveis.",
                                  "commonMistakes": [
                                    "Desconectar frequência de física real (ex: velocidades do som no fluido)",
                                    "Superestimar rigidez de tubulações",
                                    "Ignorar efeitos não-lineares em altas amplitudes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema hidráulico de freios de aeronave, analise o diagrama de Bode de uma tubulação de 5m conectada a um reservatório. Identifique a ressonância em 10 Hz (pico de 15 dB), atenuação de 20 dB acima de 50 Hz e largura de banda de 2 Hz, relacionando o pico a risco de oscilações de pressão durante frenagem emergencial.",
                              "finalVerifications": [
                                "Identifica corretamente picos de ressonância em diagramas de Bode hidráulicos.",
                                "Calcula largura de banda e fator de qualidade com precisão <5% de erro.",
                                "Explica atenuações em termos de perdas físicas.",
                                "Relaciona características de frequência a ondas de pressão reais.",
                                "Valida interpretações com simulações ou dados experimentais.",
                                "Propõe ajustes no sistema baseados na análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ressonâncias e larguras de banda (80%+ acurácia).",
                                "Profundidade na relação com fenômenos físicos (explicações causais).",
                                "Uso correto de ferramentas de plotagem e medição.",
                                "Criatividade em conexões com aplicações aeronáuticas.",
                                "Clareza na documentação de análises.",
                                "Capacidade de sintetizar insights acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Fourier e funções de transferência.",
                                "Física: Teoria de ondas e acústica em fluidos.",
                                "Engenharia Mecânica: Vibrações e dinâmica de estruturas hidráulicas.",
                                "Controle Automático: Estabilidade via Nyquist/Bode.",
                                "Ciência de Materiais: Efeitos de elasticidade em tubos."
                              ],
                              "realWorldApplication": "Na manutenção de sistemas hidráulicos de aeronaves (ex: atuadores de flaps ou trem de pouso), interpretar respostas em frequência previne falhas por ressonância, otimizando design para evitar vibrações que causam fadiga e acidentes, como visto em incidentes de oscilação em jatos comerciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.4",
                            "name": "Simular análise de Fourier em software para sistemas hidráulicos",
                            "description": "Utilizar ferramentas computacionais como MATLAB para aplicar FFT em sinais simulados de tubulações e reservatórios, validando modelos teóricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação e modelar o sistema hidráulico",
                                  "subSteps": [
                                    "Instalar e abrir o MATLAB com toolboxes necessárias (Signal Processing Toolbox e Control System Toolbox).",
                                    "Definir parâmetros do sistema hidráulico: comprimento da tubulação (L=100m), diâmetro (D=0.1m), módulo de elasticidade do fluido (K=2.2e9 Pa), densidade (ρ=1000 kg/m³).",
                                    "Criar equações diferenciais para ondas de pressão usando a equação de onda hidráulica: ∂²p/∂t² = c² ∂²p/∂x², onde c é a velocidade do som no fluido.",
                                    "Implementar o modelo em MATLAB usando função ode45 para simulação temporal.",
                                    "Plotar o sinal de pressão inicial para visualização."
                                  ],
                                  "verification": "Verificar se o modelo roda sem erros e gera um gráfico de pressão vs. tempo com oscilações realistas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação do Signal Processing Toolbox",
                                    "Referências teóricas de dinâmica de fluidos"
                                  ],
                                  "tips": "Comece com valores simplificados para evitar instabilidades numéricas; use sim() para simulações lineares iniciais.",
                                  "learningObjective": "Compreender e implementar um modelo matemático básico de sistema hidráulico no MATLAB.",
                                  "commonMistakes": [
                                    "Usar passos de tempo muito grandes causando instabilidade",
                                    "Esquecer unidades consistentes (SI)",
                                    "Não linearizar o modelo para frequências baixas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e analisar o sinal temporal simulado",
                                  "subSteps": [
                                    "Aplicar excitação sinusoidal na entrada (ex: vazão Q(t) = Q0 sin(ωt)) com frequências variadas (1-100 Hz).",
                                    "Executar simulação por 10 segundos com passo de tempo dt=0.001s.",
                                    "Extrair sinal de saída de pressão p(t) em pontos de reservatório e tubulação.",
                                    "Aplicar filtros passa-baixa se necessário para remover ruído numérico.",
                                    "Calcular estatísticas básicas: amplitude, frequência dominante via autocorrelação."
                                  ],
                                  "verification": "Sinal p(t) deve mostrar resposta transitória e estacionária coerente com a frequência de entrada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Script MATLAB inicial do Step 1",
                                    "Funções ode45 e sim"
                                  ],
                                  "tips": "Salve o sinal em vetor tempo-domínio para reutilização; use quiver() para visualizações vetoriais se aplicável.",
                                  "learningObjective": "Gerar sinais realistas de sistemas hidráulicos e prepará-los para análise espectral.",
                                  "commonMistakes": [
                                    "Frequências de excitação acima da Nyquist do passo de tempo",
                                    "Não considerar perdas viscosas iniciais",
                                    "Ignorar condições iniciais zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Transformada Rápida de Fourier (FFT) no sinal",
                                  "subSteps": [
                                    "Preparar dados: windowing com Hamming para reduzir leakage espectral.",
                                    "Executar fft(p,t) ou fft(signal, NFFT) com NFFT=2^nextpow2(length(signal)).",
                                    "Calcular espectro de amplitude e fase: abs(Y)/length(Y), angle(Y).",
                                    "Gerar eixo de frequência: f = (0:NFFT/2-1)*(fs/NFFT), onde fs=1/dt.",
                                    "Plotar espectro de potência unilateral (2*abs(Y(1:NFFT/2))/length(Y))."
                                  ],
                                  "verification": "Picos no espectro devem coincidir com frequências de excitação conhecida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Signal Analyzer app no MATLAB",
                                    "Funções fft, fftshift, window"
                                  ],
                                  "tips": "Normalize o espectro pela raiz quadrada de N para amplitude correta; use periodograma para validação.",
                                  "learningObjective": "Implementar corretamente FFT para extrair componentes frecuenciais de sinais hidráulicos.",
                                  "commonMistakes": [
                                    "Não dividir por N na amplitude",
                                    "Plotar espectro bilateral sem shift",
                                    "Windowing inadequado causando sidelobes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar contra teoria",
                                  "subSteps": [
                                    "Comparar picos FFT com função de transferência teórica H(ω) = 1/(1 - (ω/ω_n)^2 + iζω/ω_n).",
                                    "Calcular ressonância hidráulica: f_n = c/(4L) para tubulação aberta.",
                                    "Quantificar erro: RMSE entre espectro simulado e analítico.",
                                    "Simular variação de parâmetros (ex: rigidez) e observar shifts espectrais.",
                                    "Gerar relatório com gráficos superpostos."
                                  ],
                                  "verification": "Erro RMSE < 5% e identificação correta de modos ressonantes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções bode() para comparação teórica",
                                    "Exportar figuras para PDF"
                                  ],
                                  "tips": "Use hold on para sobrepor curvas; valide com dados experimentais públicos se disponíveis.",
                                  "learningObjective": "Validar simulações numéricas contra modelos teóricos em análise de frequência.",
                                  "commonMistakes": [
                                    "Confundir fase com amplitude",
                                    "Não considerar aliasing em altas frequências",
                                    "Ignorar efeitos não-lineares em grandes amplitudes"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma tubulação hidráulica de 50m conectada a um reservatório em um sistema de controle de flaps de aeronave. Aplique excitação de 20 Hz na bomba e use FFT para identificar a frequência ressonante em 15 Hz, validando que não coincide com modos estruturais da asa.",
                              "finalVerifications": [
                                "O espectro FFT mostra picos nítidos nas frequências esperadas sem leakage significativo.",
                                "Validação teórica com erro <10% em amplitudes de pico.",
                                "Gráficos incluem sinal temporal, espectro e comparação Bode.",
                                "Simulação roda em <5 minutos para 10s de sinal.",
                                "Relatório explica pelo menos 3 insights sobre o sistema hidráulico.",
                                "Código é comentado e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação FFT (normalização, windowing: 25%)",
                                "Qualidade do modelo hidráulico e simulação temporal (25%)",
                                "Análise e validação teórica (20%)",
                                "Clareza de visualizações e relatório (15%)",
                                "Eficiência computacional e robustez do código (10%)",
                                "Identificação correta de erros comuns e mitigação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Uso de FFT para síntese de controladores em laços hidráulicos.",
                                "Vibrações e Acústica: Análise de modos em tubulações semelhantes a dutos aéreos.",
                                "Processamento de Sinais: Aplicação em telemetria de voo para detecção de falhas.",
                                "Dinâmica de Aeronaves: Integração com modelagem aeroelástica de superfícies de controle."
                              ],
                              "realWorldApplication": "Em aeronaves, análise FFT de sinais hidráulicos detecta ressonâncias em sistemas de landing gear ou flight controls, prevenindo fadiga e vibrações excessivas durante voo, como validado em testes de certificação FAA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 320
          }
        ],
        "totalSkills": 320,
        "percentage": 0
      }
    ]
  }
}