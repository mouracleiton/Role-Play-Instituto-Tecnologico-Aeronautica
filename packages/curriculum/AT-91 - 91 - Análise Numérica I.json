{
  "formatVersion": "1.0",
  "exportDate": "2025-12-05T23:50:02.771Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - AT-91",
      "lastUpdated": "2025-12-05",
      "totalAtomicSkills": 325
    },
    "areas": [
      {
        "id": "10",
        "name": "Matemática",
        "description": "Disciplinas fundamentais de Matemática Aplicada e Computacional.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Análise Numérica I",
            "description": "Métodos de passo simples e de passo múltiplo para a solução do problema de valor inicial. Controle de passo. Estabilidade. Problemas Stiff. Métodos para a solução do problema de valor de contorno. Introdução aos métodos pseudoespectrais. Bibliografia: LEVEQUE, R. Finite difference methods for ordinary and partial differential equations: steady-state and time-dependent problems. [S.l.]: SIAM, 2007. GOLUB, G. H.; ORTEGA, J. M. Scientific computing and diferential equations, an introduction to numerical methods. San Diego: Academic Press, 1992. BURDEN, R. L.; FAIRES, J. D. Numerical analysis. 6. ed. Pacific Grove: Brooks/Cole, 1997.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Métodos de Passo Simples para Problema de Valor Inicial",
                "description": "Métodos numéricos de um único passo para resolver equações diferenciais ordinárias com condições iniciais.",
                "totalSkills": 55,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Método de Euler Explícito",
                    "description": "Método de passo simples de primeira ordem baseado na derivada no ponto inicial do intervalo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Formulação do Método de Euler Explícito",
                        "description": "Definição e derivação do método de Euler explícito como aproximador de primeira ordem para o problema de valor inicial y' = f(t,y), y(t0)=y0.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Entender o problema de valor inicial",
                            "description": "Compreender a equação diferencial ordinária y' = f(t,y) com condição inicial y(t0)=y0 e a necessidade de métodos numéricos para solução aproximada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Equações Diferenciais Ordinárias (EDOs) de Primeira Ordem",
                                  "subSteps": [
                                    "Defina o que é uma EDO: uma equação que relaciona uma função desconhecida y(t), sua derivada y'(t) e a variável independente t.",
                                    "Identifique EDOs de primeira ordem: aquelas que envolvem apenas a primeira derivada y'.",
                                    "Diferencie EDOs de equações algébricas: EDOs descrevem taxas de mudança contínua.",
                                    "Classifique EDOs como lineares ou não lineares com base em y e y'.",
                                    "Reconheça exemplos simples como y' = ky (crescimento exponencial)."
                                  ],
                                  "verification": "Escreva a definição de EDO de primeira ordem e dê dois exemplos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro-texto de EDOs (capítulo introdutório)",
                                    "Vídeo tutorial sobre EDOs básicas (ex: Khan Academy)"
                                  ],
                                  "tips": "Comece com exemplos físicos intuitivos, como velocidade de um carro (dy/dt = aceleração).",
                                  "learningObjective": "Dominar os conceitos fundamentais de EDOs de primeira ordem.",
                                  "commonMistakes": "Confundir derivada y' com y; esquecer que t é a variável independente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Forma Padrão y' = f(t, y)",
                                  "subSteps": [
                                    "Escreva a forma geral: y' = f(t, y), onde f é uma função contínua de t e y.",
                                    "Explique o papel de f(t,y): representa a taxa de variação instantânea de y em função de tempo e estado atual.",
                                    "Verifique se uma equação dada está na forma padrão (reorganize se necessário).",
                                    "Discuta propriedades de f: Lipschitz em y para garantir unicidade.",
                                    "Pratique reescrevendo equações como y' + y = t na forma padrão."
                                  ],
                                  "verification": "Converta três equações dadas para y' = f(t,y) e identifique f corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou app de simbólico (Wolfram Alpha)",
                                    "Exercícios impressos de EDOs"
                                  ],
                                  "tips": "Sempre isole y' no lado esquerdo para padronizar.",
                                  "learningObjective": "Identificar e manipular a forma padrão do problema.",
                                  "commonMistakes": "Não isolar y' corretamente; ignorar dependência de t ou y em f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a Condição Inicial y(t0) = y0",
                                  "subSteps": [
                                    "Defina condição inicial (CI): valor de y especificado em t = t0.",
                                    "Explique o Problema de Valor Inicial (PVI): y' = f(t,y) + CI y(t0)=y0.",
                                    "Discuta o papel da CI: seleciona uma solução única entre infinitas.",
                                    "Ilustre graficamente: curva de solução passando por (t0, y0).",
                                    "Verifique existência e unicidade básica (f contínua e Lipschitz)."
                                  ],
                                  "verification": "Formule um PVI completo a partir de y' = f(t,y) e uma CI dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado para esboços gráficos",
                                    "Software GeoGebra para plotar campos de direções"
                                  ],
                                  "tips": "Pense na CI como 'posição inicial' em um movimento.",
                                  "learningObjective": "Entender como a CI torna o problema bem posto.",
                                  "commonMistakes": "Confundir CI com condição de contorno; esquecer t0 específico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Limitações de Soluções Analíticas e Necessidade Numérica",
                                  "subSteps": [
                                    "Liste EDOs solucionáveis analiticamente: separáveis, lineares, exatas.",
                                    "Destaque casos intratáveis: não lineares complexas sem fórmula fechada.",
                                    "Explique aproximação numérica: discretizar tempo e iterar.",
                                    "Compare exato vs. aproximado: precisão, custo computacional.",
                                    "Introduza motivação para métodos como Euler: soluções práticas viáveis."
                                  ],
                                  "verification": "Classifique três EDOs como solucionáveis analiticamente ou não, justificando a necessidade numérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook com NumPy para simulações simples",
                                    "Tabela de tipos de EDOs"
                                  ],
                                  "tips": "Teste com y' = y^2: não separável facilmente, precisa numérico.",
                                  "learningObjective": "Compreender por que métodos numéricos são essenciais.",
                                  "commonMistakes": "Acreditar que todas EDOs têm solução exata; subestimar erros numéricos."
                                }
                              ],
                              "practicalExample": "Considere o modelo de crescimento populacional y' = 0.1 y (1 - y/1000), y(0)=100. Aqui, f(t,y)=0.1 y (1 - y/1000) é não linear, sem solução analítica simples; a CI y(0)=100 fixa a população inicial, exigindo métodos numéricos para prever y(10).",
                              "finalVerifications": [
                                "Defina corretamente PVI: y' = f(t,y), y(t0)=y0.",
                                "Identifique f(t,y) em uma equação dada.",
                                "Explique o papel da condição inicial para unicidade.",
                                "Dê um exemplo onde solução analítica falha.",
                                "Justifique a necessidade de métodos numéricos.",
                                "Esboce campo de direções para um PVI simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de EDO e PVI (90% correto).",
                                "Capacidade de reescrever equações na forma padrão.",
                                "Compreensão clara da CI e teorema de existência/unicidade.",
                                "Identificação correta de limitações analíticas.",
                                "Explicação coerente da motivação numérica.",
                                "Uso de exemplos relevantes sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de movimento (y' = v, leis de Newton).",
                                "Biologia: Dinâmica de populações (modelos Lotka-Volterra).",
                                "Engenharia: Circuitos RC (corrente como y(t)).",
                                "Economia: Modelos de crescimento (taxas de juros compostos)."
                              ],
                              "realWorldApplication": "Em epidemiologia, PVIs modelam surtos como dy/dt = β y (1 - y/N) - γ y, com y(0) = casos iniciais; métodos numéricos preveem picos e informam políticas públicas, como na COVID-19."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Derivar a fórmula do método de Euler explícito",
                            "description": "Derivar a iteração yn+1 = yn + h f(tn, yn) a partir da expansão de Taylor de primeira ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a expansão de Taylor de primeira ordem para funções univariadas",
                                  "subSteps": [
                                    "Lembre a fórmula geral da expansão de Taylor ao redor de um ponto a: f(x) ≈ f(a) + f'(a)(x - a).",
                                    "Discuta o erro de truncamento, que é da ordem O((x-a)^2).",
                                    "Aplique conceitualmente a uma função y(t) suave ao redor de tn: y(tn + h) ≈ y(tn) + y'(tn) h.",
                                    "Identifique que esta é uma aproximação linear local da função.",
                                    "Escreva exemplos simples, como para y(t) = sin(t) ou e^t."
                                  ],
                                  "verification": "Escreva a expansão de Taylor de 1ª ordem para y(tn + h) e compute o erro de truncamento qualitativamente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Papel e caneta, calculadora opcional, tabela de expansões de Taylor básicas",
                                  "tips": "Visualize graficamente: a reta tangente aproxima a curva localmente.",
                                  "learningObjective": "Compreender a base analítica da aproximação linear via Taylor.",
                                  "commonMistakes": "Confundir ordem de Taylor (usar termos de 2ª ordem prematuramente); ignorar o resto do truncamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a expansão de Taylor à solução exata do PVI",
                                  "subSteps": [
                                    "Considere o Problema de Valor Inicial (PVI): y' = f(t, y), y(t0) = y0, com solução exata y(t).",
                                    "Expanda y(tn + h) ≈ y(tn) + y'(tn) h, onde tn = t0 + n h.",
                                    "Note que y(tn) é desconhecida exatamente, mas será aproximada por yn.",
                                    "Escreva explicitamente: y(tn + h) ≈ y(tn) + h y'(tn).",
                                    "Discuta suavidade: assumir y é C^2 para validade do resto O(h^2)."
                                  ],
                                  "verification": "Derive a expansão y(tn + h) ≈ y(tn) + h y'(tn) + O(h^2) a partir do teorema de Taylor.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Papel, quadro branco, livro de análise numérica (cap. Taylor)",
                                  "tips": "Use notação consistente: subscrito n para tn e y(tn).",
                                  "learningObjective": "Aplicar Taylor diretamente à solução do PVI para obter aproximação local.",
                                  "commonMistakes": "Esquecer o termo O(h^2); confundir y(tn) com yn prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir a derivada y'(tn) pela função f(tn, y(tn))",
                                  "subSteps": [
                                    "Pelo PVI, y'(t) = f(t, y(t)) para todo t, assim y'(tn) = f(tn, y(tn)).",
                                    "Substitua na expansão: y(tn + h) ≈ y(tn) + h f(tn, y(tn)).",
                                    "Aproxime y(tn) ≈ yn, onde yn é a aproximação numérica em tn.",
                                    "Obtenha y(tn + h) ≈ yn + h f(tn, yn).",
                                    "Defina yn+1 = yn + h f(tn, yn) como a iteração do método."
                                  ],
                                  "verification": "Mostre passo a passo a substituição y'(tn) → f(tn, y(tn)) → f(tn, yn).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Papel e lápis, exemplo de PVI simples escrito",
                                  "tips": "Enfatize que f define o campo vetorial da EDO.",
                                  "learningObjective": "Conectar a definição do PVI com a aproximação de Taylor.",
                                  "commonMistakes": "Substituir y(tn) por yn antes de justificar; confundir f(t,y) com y' explícito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a fórmula iterativa e o erro local",
                                  "subSteps": [
                                    "Escreva a fórmula final: yn+1 = yn + h f(tn, yn), com t_{n+1} = tn + h.",
                                    "Discuta que o erro local por passo é O(h^2), levando a erro global O(h).",
                                    "Verifique consistência: quando h→0, recupera y' = f(t,y).",
                                    "Compare com método exato (passo h=0 trivial).",
                                    "Prepare para implementação: yn+1 depende só de yn e dados anteriores."
                                  ],
                                  "verification": "Escreva a iteração completa e justifique o erro local O(h^2).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Papel, software simbólico como SymPy opcional",
                                  "tips": "Pense recursivamente: começa em y0, gera y1, y2,...",
                                  "learningObjective": "Formalizar a iteração de Euler e compreender sua precisão.",
                                  "commonMistakes": "Afirmar erro global O(h^2) incorretamente; ignorar dependência em h."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (solução exata y(t)=e^t), aplique Taylor em t=0, h=0.1: y(0.1) ≈ 1 + 0.1 * 1 = 1.1 (exato ≈1.10517). Então y1=1.1, y2=1.1 + 0.1*1.1=1.21, etc., aproximando e^{0.2}≈1.2214.",
                              "finalVerifications": [
                                "Deriva corretamente yn+1 = yn + h f(tn, yn) a partir de Taylor de 1ª ordem.",
                                "Explica o papel de y'(tn) = f(tn, y(tn)) na substituição.",
                                "Identifica o erro local como O(h^2).",
                                "Aplica a derivação a um PVI simples e verifica numericamente.",
                                "Discute limitações da aproximação linear.",
                                "Escreva a recursão inicial y0 = y(t0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na expansão de Taylor e substituições.",
                                "Clareza na justificativa conceitual do PVI para iteração.",
                                "Correta identificação de ordens de erro (local O(h^2), global O(h)).",
                                "Capacidade de aplicar a exemplo concreto com cálculos corretos.",
                                "Compreensão de consistência e estabilidade básica.",
                                "Uso consistente de notação e raciocínio lógico sequencial."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python/MATLAB para EDOs.",
                                "Física: Aproximar trajetórias em mecânica newtoniana.",
                                "Engenharia: Simulações de circuitos RLC ou fluidodinâmica.",
                                "Computação Científica: Base para solvers numéricos em SciPy.",
                                "Economia: Modelos diferenciais em finanças (taxas de juros)."
                              ],
                              "realWorldApplication": "O método de Euler explícito é amplamente usado em simulações numéricas iniciais para sistemas dinâmicos, como previsão meteorológica (modelos de difusão), biologia populacional (equações Lotka-Volterra), robótica (controle de trajetórias) e aprendizado de máquina (gradiente descendente como Euler em tempo discreto)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Identificar características do método de passo simples",
                            "description": "Reconhecer que o método usa um passo h fixo e baseia-se na derivada no ponto inicial do intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de método de passo simples",
                                  "subSteps": [
                                    "Revise a definição geral de métodos numéricos para Problemas de Valor Inicial (PVI).",
                                    "Identifique que métodos de passo simples aproximam a solução em intervalos discretos com tamanho fixo.",
                                    "Leia exemplos introdutórios de métodos como Euler Explícito e note a estrutura básica da iteração.",
                                    "Anote as palavras-chave: 'passo fixo' e 'aproximação linear'.",
                                    "Discuta com um colega ou tutor o que diferencia métodos de passo simples de outros."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e compare com a referência oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica",
                                    "Notas de aula sobre PVI",
                                    "Vídeo tutorial sobre métodos numéricos"
                                  ],
                                  "tips": "Use analogias como 'passos iguais em uma escada' para visualizar o h fixo.",
                                  "learningObjective": "Definir e contextualizar métodos de passo simples em PVI.",
                                  "commonMistakes": [
                                    "Confundir com métodos adaptativos que variam h",
                                    "Ignorar que é uma aproximação local linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o uso do passo h fixo",
                                  "subSteps": [
                                    "Examine a fórmula do Método de Euler: y_{n+1} = y_n + h f(x_n, y_n).",
                                    "Observe que h é constante em todas as iterações do intervalo [a,b].",
                                    "Calcule manualmente 2-3 iterações com h=0.1 para um PVI simples e note h invariante.",
                                    "Compare com um método de passo variável (ex: Runge-Kutta adaptativo) para contrastar.",
                                    "Registre em um diagrama como h divide o intervalo total em N passos iguais."
                                  ],
                                  "verification": "Apresente um exemplo onde h permanece o mesmo em múltiplas iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB",
                                    "Papel milimetrado para plotar",
                                    "Exemplos de PVI resolvidos"
                                  ],
                                  "tips": "Sempre especifique o intervalo [x0, x_final] e compute N = (x_final - x0)/h.",
                                  "learningObjective": "Reconhecer h como parâmetro fixo na formulação do método.",
                                  "commonMistakes": [
                                    "Assumir h variável baseado em erro local",
                                    "Confundir h com o número de passos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer o uso da derivada no ponto inicial do intervalo",
                                  "subSteps": [
                                    "Analise o termo h f(x_n, y_n) na fórmula de Euler.",
                                    "Entenda que f(x_n, y_n) é a derivada y' avaliada apenas no início do subintervalo [x_n, x_{n+1}].",
                                    "Visualize geometricamente: a aproximação é a reta tangente no ponto (x_n, y_n).",
                                    "Compare com métodos implícitos ou de ordem superior que usam derivadas em múltiplos pontos.",
                                    "Resolva um PVI simples e destaque onde f é avaliada."
                                  ],
                                  "verification": "Marque na fórmula os pontos onde a derivada é computada e explique por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfico da solução exata vs. aproximação Euler",
                                    "Software de plotagem (Desmos ou GeoGebra)",
                                    "Folha de exercícios com PVI"
                                  ],
                                  "tips": "Pense na derivada como 'inclinação inicial' para cada pequeno passo.",
                                  "learningObjective": "Identificar que a aproximação baseia-se exclusivamente na derivada esquerda.",
                                  "commonMistakes": [
                                    "Pensar que usa média de derivadas",
                                    "Confundir com método trapezoidal que usa ambos os extremos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e verificar as características principais",
                                  "subSteps": [
                                    "Liste as duas características chave: h fixo e derivada no ponto inicial.",
                                    "Crie um fluxograma da iteração do método destacando esses elementos.",
                                    "Teste sua compreensão aplicando a identificação em uma fórmula genérica de Euler.",
                                    "Responda a perguntas de autoavaliação sobre exceções ou limitações.",
                                    "Ensine o conceito a um par para reforçar o aprendizado."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo e valide com o professor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (Lucidchart)",
                                    "Quiz autoavaliativo impresso"
                                  ],
                                  "tips": "Use mnemônicos: 'H Fixo, Derivada Inicial' (HFDI).",
                                  "learningObjective": "Integrar as características em uma visão coesa do método.",
                                  "commonMistakes": [
                                    "Generalizar para todos os métodos de Euler (explícito vs. implícito)",
                                    "Esquecer limitações como baixa precisão para h grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = y, y(0)=1, com h=0.1 em [0,0.3]: y1=1 + 0.1*1=1.1 (h fixo=0.1); y2=1.1 + 0.1*1.1=1.21 (derivada f(0.1,1.1)=1.1 no início do subintervalo). Note h constante e f avaliada só no ponto inicial de cada passo.",
                              "finalVerifications": [
                                "Explicar verbalmente as duas características principais sem consultar notas.",
                                "Identificar corretamente h fixo em uma fórmula dada.",
                                "Apontar o ponto de avaliação da derivada em um diagrama de iteração.",
                                "Diferenciar Euler Explícito de um método de passo múltiplo.",
                                "Aplicar as características a um novo PVI simples.",
                                "Listar limitações decorrentes dessas características."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de h como fixo (100% das iterações).",
                                "Correta localização da avaliação da derivada (apenas ponto inicial).",
                                "Uso de terminologia técnica adequada (ex: 'subintervalo', 'aproximação linear').",
                                "Capacidade de exemplificar com cálculo manual.",
                                "Clareza na explicação sintética das características.",
                                "Ausência de confusões com métodos de ordem superior."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar loop com h fixo em Python para simular PVI.",
                                "Física: Modelar movimento uniformemente acelerado com passos discretos.",
                                "Computação Científica: Entender bases de solvers numéricos em bibliotecas como SciPy.",
                                "Engenharia: Aplicar em simulações de circuitos RC com Euler."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas básicas, o Método de Euler com h fixo modela a propagação de frentes frias aproximando derivadas iniciais de temperatura, permitindo previsões rápidas em grids espaciais discretos, comum em software de previsão do tempo inicial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Análise de Erro do Método de Euler Explícito",
                        "description": "Estudo do erro local de truncamento O(h²) e erro global O(h) para o método de Euler explícito.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Calcular o erro local de truncamento",
                            "description": "Demonstrar que o erro local é dado pela expansão de Taylor: erro local = (h²/2) y''(ξ), para ξ no intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Explícito e a Expansão de Taylor",
                                  "subSteps": [
                                    "Lembre-se da fórmula do método de Euler: y_{n+1} = y_n + h f(x_n, y_n).",
                                    "Entenda que o erro local de truncamento é a diferença entre a solução exata y(x_n + h) e a aproximação de um passo: y(x_n + h) - [y(x_n) + h y'(x_n)].",
                                    "Revise a expansão de Taylor para y(x_n + h) em torno de x_n: y(x_n + h) = y(x_n) + h y'(x_n) + (h²/2) y''(ξ) para algum ξ em (x_n, x_n + h).",
                                    "Identifique que y'(x) = f(x, y(x)) e y''(x) vem da derivada de f.",
                                    "Anote as condições de Lipschitz para garantir a existência de y''."
                                  ],
                                  "verification": "Escreva as fórmulas de Euler e Taylor lado a lado e confirme que os primeiros dois termos coincidem.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, livro de Análise Numérica ou notas de aula sobre método de Euler.",
                                  "tips": "Desenhe um gráfico simples de y(x) para visualizar o passo h e o erro.",
                                  "learningObjective": "Compreender a base teórica do erro local via Taylor.",
                                  "commonMistakes": "Confundir erro local (um passo) com erro global (acumulado)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansão de Taylor à Solução Exata",
                                  "subSteps": [
                                    "Escreva y(x_n + h) = y(x_n) + h y'(x_n) + (h²/2) y''(x_n) + R_3, onde R_3 é o resto.",
                                    "Substitua y'(x_n) = f(x_n, y(x_n)).",
                                    "Compute y''(x) = d/dx [f(x, y(x))] = f_x + f_y y' = f_x + f_y f, usando a regra da cadeia.",
                                    "Expanda até o termo h² e ignore termos de ordem superior para o erro local O(h²).",
                                    "Confirme que a aproximação de Euler corresponde aos termos até h¹."
                                  ],
                                  "verification": "Derive explicitamente y(x_n + h) ≈ y(x_n) + h f(x_n, y(x_n)) + (h²/2) y''(ξ).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora simbólica ou software como Mathematica/Maple para derivadas.",
                                  "tips": "Use abreviações como y_n = y(x_n) para simplificar notação.",
                                  "learningObjective": "Executar a expansão de Taylor corretamente para EDOs.",
                                  "commonMistakes": "Esquecer a regra da cadeia ao derivar y''."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar e Expressar o Erro Local de Truncamento",
                                  "subSteps": [
                                    "Subtraia a iteração de Euler da expansão: erro local τ = y(x_n + h) - y_{n+1} = (h²/2) y''(ξ) + O(h³).",
                                    "Ignore O(h³) para o erro local de truncamento, que é O(h²).",
                                    "Especifique ξ ∈ (x_n, x_n + h) pelo teorema do resto de Lagrange.",
                                    "Discuta que |τ| ≤ (h²/2) max |y''(ξ)| no intervalo.",
                                    "Verifique para uma EDO linear simples, como y' = λ y."
                                  ],
                                  "verification": "Escreva a fórmula final: τ(h) = (h²/2) y''(ξ), e isole o termo de erro.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Folha de exercícios com EDOs modelo.",
                                  "tips": "Sempre especifique o intervalo de ξ para precisão teórica.",
                                  "learningObjective": "Derivar a expressão exata do erro local O(h²).",
                                  "commonMistakes": "Incluir termos O(h³) no erro local ou errar o coeficiente 1/2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com um Exemplo Numérico Simples",
                                  "subSteps": [
                                    "Escolha y' = y, y(0)=1, solução exata y(x)=e^x.",
                                    "Aplique Euler com h pequeno, ex: x_0=0, h=0.1, y_1 ≈ 1 + 0.1*1 = 1.1.",
                                    "Exato y(0.1)=e^{0.1}≈1.10517, erro local ≈0.00517.",
                                    "Estime y''(x)=y(x)=e^x, (h²/2)y''(ξ)≈ (0.01/2)*1.005≈0.005025, compare.",
                                    "Analise como o erro escala com h²."
                                  ],
                                  "verification": "Calcule numericamente e confirme que erro ≈ (h²/2) y''(média).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para e^x e comparações.",
                                  "tips": "Use h=0.05 e h=0.1 para ver dependência quadrática.",
                                  "learningObjective": "Validar teoricamente com prática numérica.",
                                  "commonMistakes": "Usar solução aproximada em vez de exata para verificação."
                                }
                              ],
                              "practicalExample": "Para y' = -2xy, y(0)=1 (solução y=e^{-x²}), em x=0, h=0.1: y(0.1)=e^{-0.01}≈0.99005. Euler: y1=1 + 0.1*(-2*0*1)=1. Erro local≈0.00995. y''(x)= -2 + (-2x)^2 y = -2 + 4x² y. Em x=0, y''= -2. (h²/2)(-2)≈ -0.01, próximo ao erro.",
                              "finalVerifications": [
                                "Deriva corretamente y(x_n + h) até o termo h² usando Taylor.",
                                "Isola o erro local como (h²/2) y''(ξ) com ξ especificado.",
                                "Computa y'' via regra da cadeia para f(x,y).",
                                "Valida com exemplo numérico onde erro escala com h².",
                                "Explica a diferença entre erro local e global.",
                                "Aplica a estimativa de limite superior |τ| ≤ (h²/2) M, M=max|y''|."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da expansão de Taylor (100% dos termos corretos).",
                                "Correta identificação do termo de erro O(h²) com coeficiente 1/2.",
                                "Uso apropriado do teorema do resto de Lagrange.",
                                "Exemplo numérico com cálculo exato e comparação quantitativa.",
                                "Explicação clara de y'' em termos de f_x e f_y.",
                                "Demonstração de escala quadrática do erro variando h."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações de movimento (ex: osciladores).",
                                "Programação: Implementar Euler em Python e plotar erros de truncamento.",
                                "Cálculo: Reforço de séries de Taylor e restos em funções de duas variáveis.",
                                "Estatística: Erros em métodos numéricos para modelagem probabilística."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou trajetórias de foguetes, onde o método de Euler é usado para previsões rápidas; entender o erro local ajuda a escolher h ótimo para precisão sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Determinar a ordem de precisão global",
                            "description": "Explicar por que o erro global acumulado é O(h) após N passos, com h = (b-a)/N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Erro Local de Truncamento no Método de Euler",
                                  "subSteps": [
                                    "Lembre a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive o erro local usando expansão de Taylor da solução exata y(t_{n+1}).",
                                    "Identifique que o erro local por passo é O(h^2), devido ao termo h^2 y''/2 descartado.",
                                    "Escreva a equação do erro local: τ_n = (1/2) h^2 y''(ξ_n) para algum ξ_n.",
                                    "Discuta como esse erro é introduzido a cada iteração."
                                  ],
                                  "verification": "Escreva e verifique a derivação do erro local O(h^2) em um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, notas de aula sobre método de Euler.",
                                  "tips": "Use a expansão de Taylor centrada em t_n para clareza visual.",
                                  "learningObjective": "Compreender a origem e magnitude do erro local no método de Euler.",
                                  "commonMistakes": "Confundir erro local com erro global; esquecer o fator 1/2 no termo de segunda ordem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Propagação do Erro Através dos Passos",
                                  "subSteps": [
                                    "Modele o erro global e_n = y(t_n) - y_n como soma de erros locais propagados.",
                                    "Estabeleça a recorrência para o erro: e_{n+1} ≈ e_n + h |f_y| e_n + τ_n h, assumindo Lipschitz.",
                                    "Resolva a recorrência aproximada para estimar o crescimento exponencial do erro.",
                                    "Note que a propagação é limitada pela estabilidade, mas foca no truncamento.",
                                    "Expresse e_N em termos de soma de τ_k de k=0 a N-1."
                                  ],
                                  "verification": "Derive a recorrência do erro e verifique com uma desigualdade de Gronwall para bound.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, livro de análise numérica (ex: Burden & Faires), software como Octave para simulação.",
                                  "tips": "Pense no erro como uma soma telescópica com fator de amplificação.",
                                  "learningObjective": "Modelar como erros locais se acumulam devido à propagação.",
                                  "commonMistakes": "Ignorar o termo de propagação e_n, assumindo soma direta sem amplificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro Global Acumulado Após N Passos",
                                  "subSteps": [
                                    "Substitua τ_n ≈ C h^2, onde C é bound para |y''|.",
                                    "Some os erros: |e_N| ≤ (exp(L(b-a)) - 1)/L * max|τ|/h ≈ K h, com K constante.",
                                    "Relacione N = (b-a)/h, então soma de N termos O(h^2) dá O(N h^2) = O(h).",
                                    "Verifique assumindo y'' contínua e bounded no intervalo [a,b].",
                                    "Escreva explicitamente: erro global E(h) = O(h) à medida h → 0."
                                  ],
                                  "verification": "Compute o bound analítico para um PVI linear simples e confirme O(h).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), exemplos resolvidos de análise de erro.",
                                  "tips": "Use a soma geométrica para aproximar a amplificação: soma h^2 * r^k ≈ h.",
                                  "learningObjective": "Derivar quantitativamente que erro global é O(h).",
                                  "commonMistakes": "Esquecer que N ~ 1/h, levando a erro O(h) em vez de O(1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e Verificar a Ordem de Precisão Global",
                                  "subSteps": [
                                    "Defina ordem de precisão global p tal que |e_N| ≤ M h^p.",
                                    "Conclua p=1 para Euler, contrastando com erro local p=2.",
                                    "Teste numericamente: resolva y' = -y, y(0)=1 em [0,1] com h=0.1, 0.05 e observe halving do erro.",
                                    "Discuta implicações para escolha de h em simulações.",
                                    "Resuma: erro global O(h) porque N erros O(h^2) acumulam como O(h)."
                                  ],
                                  "verification": "Implemente código simples e plote log(erro) vs log(h), slope ≈1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy/SciPy, ou MATLAB, solução exata y=e^{-t}.",
                                  "tips": "Use richardson extrapolation para confirmar ordem numericamente.",
                                  "learningObjective": "Confirmar analítica e numericamente a ordem global O(h).",
                                  "commonMistakes": "Confundir ordem local e global; não normalizar por comprimento do intervalo."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 em [0,1], solução exata y(t)=e^t. Com h=0.1 (N=10), erro em t=1 é ≈0.07; com h=0.05 (N=20), erro ≈0.035, confirmando O(h). Derive: erro local O(h^2)=0.005, soma 10 termos ≈0.05 ajustado por propagação.",
                              "finalVerifications": [
                                "Derivação correta do erro local O(h^2) via Taylor.",
                                "Recorrência do erro global com bound O(h).",
                                "Explicação clara de N h^2 = (b-a) h = O(h).",
                                "Teste numérico mostrando erro halve com h halve.",
                                "Resumo escrito: 'Ordem global 1 porque erros locais acumulam linearmente com 1/h passos.'",
                                "Identificação de condições (y'' bounded, Lipschitz)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do erro local (ausência de erros algébricos).",
                                "Correta modelagem da propagação e soma de erros.",
                                "Uso apropriado de N = (b-a)/h na estimativa final.",
                                "Validação numérica com pelo menos dois h e análise de slope.",
                                "Clareza na distinção entre ordens local e global.",
                                "Aplicação de teoremas como Gronwall quando relevante."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python para visualizar erros.",
                                "Física: Simulações de movimento (ex: pêndulo) onde precisão O(h) afeta trajetórias.",
                                "Estatística: Análise de erro em métodos Monte Carlo semelhantes.",
                                "Engenharia: Otimização de h em simulações CFD ou circuitos."
                              ],
                              "realWorldApplication": "Em modelagem financeira (equações diferenciais para opções), erro O(h) determina tamanho de passo para precisão aceitável sem custo computacional excessivo; em simulações climáticas, equilibra precisão global com tempo de execução em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Comparar com solução exata",
                            "description": "Aplicar o método a um exemplo simples como y' = y, y(0)=1, e comparar com a solução exata e^{-t}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Resolver o problema analiticamente",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial: y' = y, y(0) = 1.",
                                    "Separe variáveis: dy/y = dt.",
                                    "Integre ambos os lados: ∫(1/y) dy = ∫ dt.",
                                    "Resolva a integral: ln|y| = t + C.",
                                    "Aplique condição inicial y(0)=1: C=0, logo y = e^t (corrigindo sinal para y' = y, solução y = e^t)."
                                  ],
                                  "verification": "Confirme que y(t) = e^t satisfaz y' = y e y(0)=1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou software simbólico como SymPy"
                                  ],
                                  "tips": "Verifique o sinal da equação; para y' = y é crescimento exponencial.",
                                  "learningObjective": "Entender a solução exata para comparação posterior.",
                                  "commonMistakes": "Confundir y' = y com y' = -y; errar na integração ou condição inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Euler Explícito",
                                  "subSteps": [
                                    "Escolha passo h (ex: h=0.1, 0.05).",
                                    "Inicialize y0 = 1, t0 = 0.",
                                    "Calcule iterações: yn+1 = yn + h * f(tn, yn), onde f(t,y) = y.",
                                    "Continue até tn = T desejado (ex: T=1).",
                                    "Registre valores de yn para cada tn."
                                  ],
                                  "verification": "Verifique se a fórmula de Euler está aplicada corretamente em pelo menos 3 passos manuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para automação"
                                  ],
                                  "tips": "Use h pequeno para mais precisão inicial; faça manualmente primeiro.",
                                  "learningObjective": "Aplicar corretamente o método numérico passo a passo.",
                                  "commonMistakes": "Usar yn+1 = yn + h * f(tn+1, yn) (erro implícito); esquecer y(0)=1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular erros de aproximação",
                                  "subSteps": [
                                    "Para cada tn, calcule y_exata(tn) = e^{tn}.",
                                    "Compute erro absoluto: |yn - y_exata(tn)|.",
                                    "Compute erro relativo: |yn - y_exata(tn)| / |y_exata(tn)|.",
                                    "Repita para diferentes h e tabule resultados.",
                                    "Observe comportamento do erro com h."
                                  ],
                                  "verification": "Tabela com erros para pelo menos 2 valores de h e 5 pontos tn.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou script Python para tabelas"
                                  ],
                                  "tips": "Use log(h) vs log(erro) para ver ordem de convergência (deve ser O(h)).",
                                  "learningObjective": "Quantificar discrepâncias entre numérico e exato.",
                                  "commonMistakes": "Erro relativo sem dividir pela solução exata; inconsistência nos tn."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e visualizar a comparação",
                                  "subSteps": [
                                    "Plote y_exata(t) vs yn(t) para diferentes h.",
                                    "Plote curvas de erro vs t ou vs h.",
                                    "Calcule ordem de precisão: verifique se erro ~ h^1.",
                                    "Discuta limitações do Euler (instabilidade para h grande).",
                                    "Conclua sobre acurácia do método."
                                  ],
                                  "verification": "Gráficos gerados e análise escrita de pelo menos 1 parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com Matplotlib ou GNUPlot"
                                  ],
                                  "tips": "Normalize plots para melhor visualização; inclua legenda.",
                                  "learningObjective": "Interpretar numericamente a análise de erro do Euler.",
                                  "commonMistakes": "Escala errada nos plots ocultando erros; ignorar acumulação de erro."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, h=0.1 até t=1: y1=1.1, y2=1.21, ..., y10≈2.5937 (exata e^1≈2.7183, erro≈0.1246). Repita com h=0.05 para ver redução.",
                              "finalVerifications": [
                                "Solução exata y=e^t corretamente derivada e verificada.",
                                "Aproximações de Euler computadas sem erros aritméticos.",
                                "Erros absolutos e relativos tabulados para múltiplos h.",
                                "Gráficos mostram convergência com h→0.",
                                "Ordem de erro O(h) confirmada numericamente.",
                                "Conclusão discute trade-off precisão vs custo computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais e numéricos (erro <1%).",
                                "Correta identificação da solução exata.",
                                "Análise qualitativa e quantitativa do erro.",
                                "Uso adequado de visualizações para comparação.",
                                "Interpretação correta da convergência do método.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python para automação.",
                                "Física: Modelos de crescimento populacional ou decaimento radioativo.",
                                "Estatística: Análise de erro e convergência numérica.",
                                "Engenharia: Simulações de EDOs em controle de sistemas."
                              ],
                              "realWorldApplication": "Em simulações de epidemias (SIR models), previsão meteorológica ou finanças (Black-Scholes), onde soluções exatas são raras, Euler é usado para protótipos rápidos, comparando com analítico quando possível para validar precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Implementação e Estabilidade",
                        "description": "Implementação computacional e análise de estabilidade condicional do método de Euler explícito.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Implementar o algoritmo em pseudocódigo",
                            "description": "Escrever pseudocódigo para o método: inicializar t=y0, loop while t < tf: y = y + h*f(t,y), t = t + h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os parâmetros e função do problema",
                                  "subSteps": [
                                    "Identifique os parâmetros do problema: t0 (tempo inicial), y0 (valor inicial), tf (tempo final), h (passo de tempo).",
                                    "Defina a função f(t, y) que representa a derivada dy/dt.",
                                    "Escreva uma declaração inicial no pseudocódigo declarando todas as variáveis necessárias (t, y, h, t0, y0, tf, f).",
                                    "Inclua uma seção de 'Entrada' para especificar os valores iniciais.",
                                    "Adicione comentários explicando o propósito de cada parâmetro."
                                  ],
                                  "verification": "Verifique se todas as variáveis estão declaradas corretamente e se f(t,y) está definida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples",
                                    "Descrição do problema de valor inicial"
                                  ],
                                  "tips": "Use nomes de variáveis descritivos para facilitar a leitura.",
                                  "learningObjective": "Compreender e declarar os componentes essenciais do método de Euler.",
                                  "commonMistakes": [
                                    "Esquecer de declarar f(t,y)",
                                    "Confundir t0 com tf"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar as variáveis principais",
                                  "subSteps": [
                                    "Escreva a linha: t ← t0",
                                    "Escreva a linha: y ← y0",
                                    "Adicione uma seção 'Inicialização' no pseudocódigo.",
                                    "Inclua um comentário explicando que isso configura o ponto de partida.",
                                    "Verifique se as inicializações estão antes do loop."
                                  ],
                                  "verification": "Confirme que t e y são setados para os valores iniciais antes de qualquer iteração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de pseudocódigo ou bloco de notas"
                                  ],
                                  "tips": "Use setas ← para atribuição para clareza em pseudocódigo.",
                                  "learningObjective": "Estabelecer corretamente o estado inicial do algoritmo.",
                                  "commonMistakes": [
                                    "Inicializar dentro do loop",
                                    "Usar y ← t0 em vez de y ← y0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de iteração principal",
                                  "subSteps": [
                                    "Escreva 'ENQUANTO t < tf FAÇA'",
                                    "Dentro do loop: y ← y + h * f(t, y)",
                                    "Em seguida: t ← t + h",
                                    "Adicione 'FIM ENQUANTO'",
                                    "Inclua comentários em cada linha do loop explicando a atualização."
                                  ],
                                  "verification": "Teste mentalmente com valores simples: o loop para quando t >= tf?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo numérico simples para teste manual"
                                  ],
                                  "tips": "Garanta que o loop seja while e não for, pois h pode variar.",
                                  "learningObjective": "Construir a lógica iterativa do método de Euler explícito.",
                                  "commonMistakes": [
                                    "Usar t <= tf em vez de <",
                                    "Atualizar t antes de y"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o algoritmo com saída e verificações",
                                  "subSteps": [
                                    "Adicione uma seção 'Saída' ou 'Retornar y' como resultado final.",
                                    "Inclua uma verificação opcional: SE t > tf ENTÃO t ← tf.",
                                    "Adicione comentários gerais no topo e rodapé do pseudocódigo.",
                                    "Formate o pseudocódigo com indentação consistente.",
                                    "Revise o fluxo completo do início ao fim."
                                  ],
                                  "verification": "Simule a execução com h=0.1, t0=0, tf=1 para garantir que pare corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de verificação de pseudocódigo"
                                  ],
                                  "tips": "Use maiúsculas para palavras-chave como ENQUANTO, FAÇA, FIM.",
                                  "learningObjective": "Completar e polir o pseudocódigo para legibilidade e correção.",
                                  "commonMistakes": [
                                    "Falta de indentação",
                                    "Não retornar o valor final de y"
                                  ]
                                }
                              ],
                              "practicalExample": "Para dy/dt = -2y, y(0)=1, tf=1, h=0.2:\nINÍCIO\n  ENTRADA: t0=0, y0=1, tf=1, h=0.2\n  FUNÇÃO f(t,y) = -2y\n  t ← 0\n  y ← 1\n  ENQUANTO t < 1 FAÇA\n    y ← y + h * f(t,y)\n    t ← t + h\n  FIM ENQUANTO\n  SAÍDA: y\nFIM",
                              "finalVerifications": [
                                "O pseudocódigo inicializa t = t0 e y = y0 corretamente?",
                                "O loop while usa condição t < tf?",
                                "As atualizações y ← y + h*f(t,y) e t ← t + h estão na ordem correta?",
                                "A função f(t,y) está definida e usada apropriadamente?",
                                "Há comentários suficientes para clareza?",
                                "O resultado final (y) é explicitamente retornado?"
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: as atualizações seguem exatamente o método de Euler?",
                                "Clareza e legibilidade: uso de indentação, comentários e palavras-chave padronizadas?",
                                "Completude: todos os parâmetros e seções (entrada, inicialização, loop, saída) presentes?",
                                "Precisão na condição de parada do loop?",
                                "Tratamento adequado da função f(t,y)?",
                                "Ausência de erros comuns como loops infinitos?"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estrutura de loops e controle de fluxo em linguagens como Python ou C++.",
                                "Física: Modelagem de equações diferenciais em simulações dinâmicas.",
                                "Ciência da Computação: Algoritmos numéricos e análise de estabilidade.",
                                "Engenharia: Aplicações em controle de sistemas e simulações.",
                                "Matemática Discreta: Iterações e convergência de sequências."
                              ],
                              "realWorldApplication": "O pseudocódigo do método de Euler é usado em simulações de trajetórias de mísseis, previsão de populações biológicas, modelagem financeira de juros compostos e animações em jogos de vídeo para aproximar movimentos contínuos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Analisar a estabilidade",
                            "description": "Determinar a condição de estabilidade |1 + h λ| ≤ 1 para o teste com y' = λ y, identificando problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema Teste de Estabilidade",
                                  "subSteps": [
                                    "Revise o problema modelo y' = λ y, onde λ é uma constante complexa representando o autovalor.",
                                    "Entenda que a solução exata é y(t) = y(0) e^{λ t}, que decai se Re(λ) < 0.",
                                    "Discuta a importância da estabilidade numérica: a solução numérica deve imitar o comportamento exato.",
                                    "Identifique que o método de Euler explícito é y_{n+1} = y_n + h f(t_n, y_n) = y_n + h λ y_n = (1 + h λ) y_n.",
                                    "Calcule os primeiros termos da iteração para visualizar o fator de amplificação."
                                  ],
                                  "verification": "Escreva a fórmula da iteração de Euler para y' = λ y e explique por que |1 + h λ| determina a estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de métodos de Runge-Kutta)",
                                    "Papel e caneta ou software como Jupyter Notebook"
                                  ],
                                  "tips": "Visualize graficamente a solução exata decaindo para Re(λ) < 0.",
                                  "learningObjective": "Entender o papel do problema teste y' = λ y na análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir λ com autovalor de Jacobiana em vez de constante simples.",
                                    "Ignorar que λ pode ser complexo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Condição de Estabilidade",
                                  "subSteps": [
                                    "Derive a solução numérica recursiva: y_n = y_0 (1 + h λ)^n.",
                                    "Compare com a solução exata: para estabilidade, |1 + h λ|^n → 0 quando n → ∞ e h n = t fixo.",
                                    "Estabeleça a condição necessária e suficiente: |1 + h λ| ≤ 1.",
                                    "Plote no plano complexo h λ (eixo imaginário vs real) a região onde |1 + z| ≤ 1, com z = h λ.",
                                    "Verifique para λ real negativo: h ≤ 2 / |λ|."
                                  ],
                                  "verification": "Desenhe a região de estabilidade no plano z e confirme que é o disco unitário centrado em -1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem como Python (matplotlib) ou MATLAB",
                                    "Folha de exercícios com valores de λ"
                                  ],
                                  "tips": "Use z = h λ para normalizar e focar na região absoluta.",
                                  "learningObjective": "Derivar e visualizar a condição |1 + h λ| ≤ 1 geometricamente.",
                                  "commonMistakes": [
                                    "Esquecer o módulo absoluto ou confundir com |h λ| < 1.",
                                    "Não considerar n → ∞ para estabilidade assintótica."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Análise de Estabilidade",
                                  "subSteps": [
                                    "Escolha um λ específico (ex: λ = -100) e varie h para testar |1 + h λ|.",
                                    "Calcule numericamente y_n para h estável e instável, plotando vs tempo.",
                                    "Identifique o passo h máximo: h_max = 2 / |λ| para λ real negativo.",
                                    "Teste para λ complexo: verifique se h λ está dentro do disco de estabilidade.",
                                    "Registre casos onde a condição falha, observando oscilações ou explosão."
                                  ],
                                  "verification": "Para λ = -50, h=0.03, compute |1 + h λ| e simule 100 passos sem divergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python ou Octave para simulação numérica",
                                    "Gráficos de y_n vs n"
                                  ],
                                  "tips": "Use loop simples em código para automatizar testes de h.",
                                  "learningObjective": "Aplicar a condição para prever estabilidade em exemplos concretos.",
                                  "commonMistakes": [
                                    "Usar h > 2/|λ| e não notar instabilidade imediata.",
                                    "Confundir estabilidade com precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Problemas Stiff",
                                  "subSteps": [
                                    "Defina problema stiff: equações com escalas temporais dispares, |λ| grandes negativos.",
                                    "Explique por que Euler explícito falha: h << 1/|λ_max| para estabilidade, mas ineficiente.",
                                    "Compare com métodos implícitos (ex: Euler implícito tem região ilimitada).",
                                    "Analise um sistema stiff simples: y' = -100 y + z, z' = y - z.",
                                    "Discuta detecção: rigidez via autovalores da Jacobiana."
                                  ],
                                  "verification": "Classifique um problema com λ1=-10^4, λ2=-1 como stiff e justifique limitação de Euler explícito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de códigos stiff em repositórios GitHub",
                                    "Tabela comparativa de regiões de estabilidade"
                                  ],
                                  "tips": "Meça rigidez pelo ratio |λ_max|/|λ_min| > 1000.",
                                  "learningObjective": "Reconhecer quando a estabilidade limita o uso de Euler explícito em problemas stiff.",
                                  "commonMistakes": [
                                    "Achar que todos os problemas lineares são stiff.",
                                    "Ignorar custo computacional de h pequeno."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -100 y, y(0)=1. Para h=0.01 (estável: |1-1|=0<1), y_n decai suavemente. Para h=0.03 (instável: |1-3|=2>1), y_n explode oscilatoriamente após poucos passos, demonstrando falha em problemas stiff como reações químicas rápidas.",
                              "finalVerifications": [
                                "Derive corretamente |1 + h λ| ≤ 1 a partir da recursão.",
                                "Plote a região de estabilidade como disco |z+1|≤1.",
                                "Calcule h_max para λ=-200 e verifique simulação estável.",
                                "Identifique stiff em sistema com autovalores -10^5 e -1.",
                                "Explique por que Euler explícito é inadequado para stiff.",
                                "Compare estabilidade com Euler implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição de estabilidade (20%)",
                                "Correta visualização geométrica da região (20%)",
                                "Aplicação numérica correta em exemplos (20%)",
                                "Identificação precisa de problemas stiff (20%)",
                                "Explicação clara de limitações e alternativas (10%)",
                                "Uso adequado de simulações e plots (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos (equações diferenciais).",
                                "Computação: Implementação eficiente em Python/NumPy para análise numérica.",
                                "Engenharia: Modelagem de circuitos RLC stiff em controle de sistemas.",
                                "Química: Simulação de reações em cinética química com escalas rápidas.",
                                "Estatística: Análise de estabilidade em métodos Monte Carlo para EDOs."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar estabilidade garante simulações confiáveis de trajetórias de foguetes com componentes stiff (ex: autovalores grandes em modelos fluidodinâmicos), evitando previsões errôneas que poderiam levar a falhas estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Resolver um exemplo numérico",
                            "description": "Aplicar o método a y' = -10y, y(0)=1 com h=0.1 e observar o comportamento numérico vs. exato.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o problema e derivar a solução exata",
                                  "subSteps": [
                                    "Identifique a equação diferencial: y' = -10y com condição inicial y(0) = 1.",
                                    "Separe variáveis: dy/y = -10 dt.",
                                    "Integre ambos os lados: ln|y| = -10t + C.",
                                    "Aplique y(0)=1 para encontrar C=0, assim y(t) = e^{-10t}.",
                                    "Calcule valores exatos para t=0, 0.1, 0.2, 0.3 (ex.: y(0.1) ≈ 0.0000454)."
                                  ],
                                  "verification": "Confirme que y(t) = e^{-10t} satisfaz y' = -10y e y(0)=1; liste valores exatos para 3 pontos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica ou software como Python/MATLAB para exponenciais; papel e lápis.",
                                  "tips": "Use logaritmos naturais para integração precisa; plotar y(t) ajuda visualizar decaimento rápido.",
                                  "learningObjective": "Compreender a solução analítica de EDO linear de primeira ordem.",
                                  "commonMistakes": "Esquecer o sinal negativo na integração; confundir ln|y| com ln(y)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre a fórmula: y_{n+1} = y_n + h * f(t_n, y_n), onde f(t,y) = -10y.",
                                    "Defina parâmetros: h=0.1, t_0=0, y_0=1.",
                                    "Simplifique: y_{n+1} = y_n * (1 - 10h) = y_n * (1 - 1) = 0 * y_n.",
                                    "Prepare tabela para n, t_n, y_n (inicial: n=0, t=0, y=1).",
                                    "Planeje 3-5 iterações para observar padrão."
                                  ],
                                  "verification": "Escreva a fórmula simplificada y_{n+1} = y_n (1 - 10h) e confirme 1 - 10*0.1 = 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Folha de cálculo ou planilha Excel; calculadora.",
                                  "tips": "Sempre substitua f(t,y) na fórmula para evitar erros aritméticos.",
                                  "learningObjective": "Aplicar corretamente a iteração do método de Euler para EDO autônoma.",
                                  "commonMistakes": "Usar h incorreto ou esquecer multiplicar h por f; não simplificar o fator."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações numéricas",
                                  "subSteps": [
                                    "Compute y1: y1 = 1 * (1 - 1) = 0 em t1=0.1.",
                                    "y2 = 0 * 0 = 0 em t2=0.2.",
                                    "y3 = 0 em t3=0.3; observe que y_n=0 para n≥1.",
                                    "Registre em tabela: t | y_num | y_exato | erro.",
                                    "Calcule erros: |y_num - y_exato| para cada ponto."
                                  ],
                                  "verification": "Tabela completa com pelo menos 3 iterações mostrando y_num=0 após primeira.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela impressa ou digital; calculadora para y_exato = exp(-10*t).",
                                  "tips": "Automatize com loop mental: após y1=0, todas subsequentes são zero.",
                                  "learningObjective": "Executar computações iterativas precisas e registrar resultados.",
                                  "commonMistakes": "Erro de arredondamento em 1-10h (deve ser exatamente 0); parar cedo sem múltiplas iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções e analisar estabilidade",
                                  "subSteps": [
                                    "Compare: exato decai suavemente (y(0.1)≈4.54e-5), numérico pula para 0 abruptamente.",
                                    "Calcule erros relativos: erro em t=0.1 ≈100% (0 vs 4.54e-5).",
                                    "Explique instabilidade: |1 + hλ| = |0| <1? Não, mas para λ=-10, hλ=-1, região de estabilidade requer |1+hλ|<1 para oscilação, aqui colapsa.",
                                    "Discuta: h=0.1 é grande para λ=-10 (h < 2/|λ| ≈0.2 para estabilidade condicional).",
                                    "Conclua: Euler explícito instável para problemas rígidos."
                                  ],
                                  "verification": "Gráfico ou tabela comparativa + parágrafo explicando discrepância e causa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico manual ou software como Desmos/Python para plotar ambas curvas.",
                                  "tips": "Foco na razão h|λ| >1 como indicador de instabilidade.",
                                  "learningObjective": "Identificar e explicar falhas numéricas vs. analíticas em métodos de Euler.",
                                  "commonMistakes": "Atribuir erro a arredondamento em vez de instabilidade inerente; ignorar solução exata."
                                }
                              ],
                              "practicalExample": "Em modelagem de decaimento radioativo, use Euler para simular contagem de partículas com taxa λ=-10, h=0.1 dia; observe como solução numérica 'morre' instantaneamente vs. decaimento real exponencial, destacando necessidade de h menor ou métodos implícitos.",
                              "finalVerifications": [
                                "Tabela de iterações numéricas correta com y1=0 e subsequentes zero.",
                                "Valores exatos computados precisamente para t=0.1,0.2,0.3.",
                                "Gráfico comparativo mostrando colapso numérico vs. decaimento suave exato.",
                                "Explicação escrita da instabilidade devido a h|λ|=1.",
                                "Cálculo de erros relativos confirmando divergência.",
                                "Sugestão de h menor (ex. h=0.01) testada mostrando melhor aproximação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução exata (integral correta).",
                                "Implementação fiel do Euler: fator (1-10h) reconhecido como 0.",
                                "Análise qualitativa da instabilidade com referência à região de estabilidade.",
                                "Quantificação de erros e comparação tabular/gráfica clara.",
                                "Conclusões profundas sobre limitações do método explícito.",
                                "Uso eficiente de tempo e materiais sem erros aritméticos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python loop for iterativo com matplotlib para plots.",
                                "Física: Aplicar a decaimento exponencial em cinética química/radioatividade.",
                                "Estatística: Analisar erros numéricos e convergência.",
                                "Engenharia Computacional: Discussão de rigidez em EDOs e solvers adaptativos."
                              ],
                              "realWorldApplication": "Em simulações de circuitos RC (descarga exponencial) ou populações com alta mortalidade, Euler explícito com h grande falha, exigindo métodos estáveis como Euler implícito ou Runge-Kutta para predições precisas em engenharia e biologia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Discutir limitações e controle de passo",
                            "description": "Explicar a necessidade de passos pequenos para estabilidade e introduzir controle adaptativo de h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar limitações do Método de Euler Explícito",
                                  "subSteps": [
                                    "Revisar a fórmula do método: y_{n+1} = y_n + h f(t_n, y_n)",
                                    "Analisar erro de truncamento local (ordem O(h^2)) e global (O(h))",
                                    "Discutir rigidez de EDOs e instabilidade numérica",
                                    "Exemplificar com EDOs lineares onde o método diverge",
                                    "Comparar com métodos implícitos"
                                  ],
                                  "verification": "Listar e explicar pelo menos 3 limitações principais em um parágrafo",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre Euler, software MATLAB ou Python (SciPy)",
                                  "tips": "Use gráficos de soluções numéricas vs. exata para visualizar falhas",
                                  "learningObjective": "Compreender as fontes de erro e instabilidade no método",
                                  "commonMistakes": "Confundir erro de truncamento com instabilidade condicional"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a condição de estabilidade e o papel de h pequeno",
                                  "subSteps": [
                                    "Derivar a região de estabilidade absoluta para Euler explícito (disco |1 + z h| < 1)",
                                    "Explicar que para autovalores com parte real negativa, h deve ser < 2/|λ|",
                                    "Simular numericamente um exemplo com h grande (divergência) vs. h pequeno (convergência)",
                                    "Discutir trade-off: precisão vs. custo computacional",
                                    "Calcular h máximo para estabilidade em um PVI dado"
                                  ],
                                  "verification": "Calcular h_max para y' = -10y e mostrar simulação estável",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou script Python, gráficos de solução",
                                  "tips": "Teste h = 0.1, 0.2, 0.5 para ver oscilações crescentes",
                                  "learningObjective": "Relacionar tamanho de h com estabilidade numérica",
                                  "commonMistakes": "Ignorar parte imaginária de autovalores em análise"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar necessidade de passos pequenos para estabilidade geral",
                                  "subSteps": [
                                    "Discutir EDOs rígidos (escalas temporais muito diferentes)",
                                    "Comparar com métodos de Runge-Kutta de ordem superior",
                                    "Quantificar redução de erro global ao dividir h por 2",
                                    "Analisar impacto no tempo de computação (O(1/h))",
                                    "Apresentar argumento qualitativo: passos pequenos aproximam melhor a curva"
                                  ],
                                  "verification": "Escrever um relatório curto justificando h pequeno em 3 cenários",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos sobre estabilidade (ex: Hairer et al.), calculadora",
                                  "tips": "Use analogia com zoom em mapa para passos pequenos",
                                  "learningObjective": "Justificar empiricamente e teoricamente o uso de h pequeno",
                                  "commonMistakes": "Superestimar precisão sem verificar estabilidade"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir controle adaptativo de passo h",
                                  "subSteps": [
                                    "Explicar conceito: ajustar h dinamicamente baseado em erro estimado",
                                    "Descrever algoritmo simples: estimar erro local com 2 passos (h e h/2)",
                                    "Implementar controle: se erro > tol, reduzir h; senão, aumentar",
                                    "Apresentar critérios como tol = 1e-6 e fator de segurança 0.9",
                                    "Simular um PVI com controle adaptativo vs. h fixo"
                                  ],
                                  "verification": "Implementar e comparar tempos/convergência em código",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (odeint ou manual), Jupyter Notebook",
                                  "tips": "Comece com h inicial = 0.1 e ajuste por fator 0.5/2.0",
                                  "learningObjective": "Dominar princípios de adaptatividade para eficiência",
                                  "commonMistakes": "Não incluir fator de segurança, causando rejeições infinitas"
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -20y + sin(t), y(0)=1: Com h fixo=0.1, solução oscila; h=0.01 converge devagar. Controle adaptativo inicia h=0.1, reduz para 0.005 em picos, acelera 3x mantendo erro <1e-5.",
                              "finalVerifications": [
                                "Explica corretamente região de estabilidade de Euler",
                                "Calcula h máximo para estabilidade em EDO linear",
                                "Implementa simulação mostrando divergência com h grande",
                                "Descreve algoritmo de controle adaptativo passo a passo",
                                "Compara eficiência de h fixo vs. adaptativo em exemplo",
                                "Justifica necessidade de h pequeno com trade-offs"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de condições de estabilidade (80%)",
                                "Clareza na explicação de limitações e soluções (90%)",
                                "Qualidade de simulações e gráficos (85%)",
                                "Implementação correta de controle adaptativo (95%)",
                                "Análise de trade-offs computacionais (80%)",
                                "Conexão teórica com prática numérica (90%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para análise numérica",
                                "Física: Simulações de osciladores rígidos em mecânica",
                                "Engenharia: Controle de sistemas dinâmicos com EDOs rígidos",
                                "Computação Científica: Otimização de solvers ODE",
                                "Estatística: Análise de erro em modelagem estocástica"
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, onde EDOs rígidos exigem h adaptativo para eficiência em supercomputadores, evitando desperdício de ciclos em regiões suaves e refinando em transientes críticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Método de Euler Implícito",
                    "description": "Versão implícita do método de Euler, requerendo solução de equação não linear no passo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Formulação do Método de Euler Implícito",
                        "description": "Definição e derivação da fórmula implícita para o problema de valor inicial y' = f(t,y), y(t0)=y0, dada por y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), destacando a dependência implícita em y_{n+1} e comparação com o método de Euler explícito.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar diferenças entre Euler Explícito e Implícito",
                            "description": "Comparar as fórmulas y_{n+1} = y_n + h f(t_n, y_n) (explícito) e y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) (implícito), explicando por que o implícito requer iteração ou solver não linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre-se da definição de Problema de Valor Inicial (PVI): y' = f(t, y), y(t0) = y0.",
                                    "Escreva a fórmula do Euler Explícito: y_{n+1} = y_n + h * f(t_n, y_n).",
                                    "Identifique que f é avaliado no ponto atual (t_n, y_n), tornando-o explícito.",
                                    "Calcule um passo manual para y' = -2y, y(0)=1, h=0.1.",
                                    "Observe como y1 é computado diretamente sem dependências adicionais."
                                  ],
                                  "verification": "Escreva a fórmula corretamente e compute y1 para o exemplo dado sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize graficamente: o método usa a tangente no ponto atual para avançar.",
                                  "learningObjective": "Compreender a formulação e computação direta do Euler Explícito.",
                                  "commonMistakes": [
                                    "Confundir f(t_n, y_n) com f(t_{n+1}, y_{n+1})",
                                    "Esquecer o passo h na multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método de Euler Implícito",
                                  "subSteps": [
                                    "Escreva a fórmula do Euler Implícito: y_{n+1} = y_n + h * f(t_{n+1}, y_{n+1}).",
                                    "Note que f depende de y_{n+1}, que é o desconhecido.",
                                    "Reescreva como equação: y_{n+1} - h * f(t_{n+1}, y_{n+1}) = y_n.",
                                    "Para o exemplo y' = -2y, y(0)=1, h=0.1, forme a equação para y1.",
                                    "Reconheça que isso forma uma equação não linear em y_{n+1} em geral."
                                  ],
                                  "verification": "Formule corretamente a equação implícita para o exemplo e identifique a dependência em y_{n+1}.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Pense no método como usando a tangente no ponto futuro, aproximando-o implicitamente.",
                                  "learningObjective": "Dominar a formulação do Euler Implícito e sua natureza dependente.",
                                  "commonMistakes": [
                                    "Tratar como explícito avaliando f em (t_n, y_n)",
                                    "Ignorar a dependência circular de y_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as Fórmulas e Estruturas",
                                  "subSteps": [
                                    "Alinhe lado a lado: Explícito y_{n+1} = y_n + h f(t_n, y_n) vs. Implícito y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Destaque diferenças: ponto de avaliação de f (atual vs. futuro) e natureza (explícita vs. implícita).",
                                    "Discuta linearidade: para f linear em y, implícito pode ser resolvido explicitamente; caso contrário, não.",
                                    "Para o exemplo y' = -2y, resolva ambos: explícito y1 ≈ 0.8, implícito y1 = 1/(1+0.2) ≈ 0.833.",
                                    "Compare estabilidade qualitativa: implícito é mais estável para h grandes."
                                  ],
                                  "verification": "Crie uma tabela comparativa com fórmulas, pontos de avaliação e um cálculo numérico.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha ou software como Python para verificação opcional"
                                  ],
                                  "tips": "Use setas para mostrar fluxo: explícito avança direto, implícito requer loop.",
                                  "learningObjective": "Identificar e articular diferenças chave nas formulações.",
                                  "commonMistakes": [
                                    "Afirmar que ambos são explícitos",
                                    "Confundir estabilidade com precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Necessidade de Iteração ou Solver Não Linear",
                                  "subSteps": [
                                    "Analise por que implícito não é direto: y_{n+1} aparece em ambos lados da equação.",
                                    "Para problemas lineares, resolva algebraicamente: y_{n+1} = (y_n) / (1 - h * partial f/partial y).",
                                    "Para não lineares, use métodos iterativos como Ponto Fixo: y^{k+1} = y_n + h f(t_{n+1}, y^k).",
                                    "Ou Newton-Raphson para convergência quadrática.",
                                    "Teste com exemplo não linear y' = y^2, mostrando necessidade de solver."
                                  ],
                                  "verification": "Descreva o processo iterativo para o exemplo não linear e explique convergência.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python/Octave para simular iterações"
                                  ],
                                  "tips": "Comece com chute inicial y^0 = y_n; itere até |y^{k+1} - y^k| < tol.",
                                  "learningObjective": "Compreender e justificar o uso de solvers no Euler Implícito.",
                                  "commonMistakes": [
                                    "Achar que implícito é sempre direto",
                                    "Ignorar condições de convergência das iterações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, h=0.1:\n- Explícito: y1 = 1 + 0.1*(-2*1) = 0.8\n- Implícito: y1 - 0.1*(-2*y1) = 1 → y1*(1+0.2)=1 → y1=1/1.2≈0.833. Note iteração desnecessária aqui (linear), mas essencial para não-lineares.",
                              "finalVerifications": [
                                "Escrever corretamente ambas as fórmulas.",
                                "Identificar ponto de avaliação de f em cada método.",
                                "Explicar dependência de y_{n+1} no implícito.",
                                "Descrever necessidade de solver/iteração com exemplo.",
                                "Comparar computacionalmente um passo para PVI dado.",
                                "Discutir quando implícito é preferível (estabilidade)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas (100% correto).",
                                "Clareza na explicação da natureza implícita.",
                                "Correta identificação de requisitos computacionais.",
                                "Uso de exemplos numéricos válidos.",
                                "Compreensão de implicações (estabilidade vs. custo).",
                                "Capacidade de formular equação residual."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com fsolve para implícito.",
                                "Física: Modelagem de circuitos RC onde implícito garante estabilidade.",
                                "Engenharia Computacional: Simulações CFD com EDOs rígidas.",
                                "Análise de Algoritmos: Complexidade O(1) explícito vs. O(iterações) implícito."
                              ],
                              "realWorldApplication": "Em simulações de sistemas rígidos como reações químicas rápidas ou circuitos elétricos, onde Euler Explícito diverge para h moderados, o Implícito mantém estabilidade via solvers não lineares em softwares como MATLAB Simulink ou COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Derivar a fórmula do Método de Euler Implícito",
                            "description": "Partir da expansão em série de Taylor de y(t_{n+1}) e truncar após o primeiro termo para obter a fórmula implícita, justificando o erro local de truncamento O(h^2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer o Problema de Valor Inicial e a Expansão de Taylor",
                                  "subSteps": [
                                    "Lembre o problema de valor inicial (PVI): y' = f(t, y), y(t_0) = y_0.",
                                    "Escreva a expansão em série de Taylor de y(t_{n+1}) em torno de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2)/2 y''(ξ) para algum ξ em (t_n, t_{n+1}).",
                                    "Identifique y'(t) = f(t, y(t)) e y''(t) = df/dt usando a regra da cadeia.",
                                    "Discuta a necessidade de métodos implícitos para precisão em certos problemas.",
                                    "Anote as condições de Lipschitz para convergência futura."
                                  ],
                                  "verification": "Escreva corretamente a expansão de Taylor com o resto de Lagrange até segunda ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Livro de Análise Numérica (opcional)",
                                    "Calculadora para exemplos numéricos"
                                  ],
                                  "tips": "Visualize a série de Taylor como aproximação local da função suave y(t).",
                                  "learningObjective": "Compreender a base analítica da aproximação numérica via Taylor.",
                                  "commonMistakes": [
                                    "Confundir y'(t_n) com f(t_{n+1}, y_{n+1}) prematuramente",
                                    "Esquecer o resto do truncamento",
                                    "Ignorar dependência de y em f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Truncar a Série de Taylor Após o Primeiro Termo Linear",
                                  "subSteps": [
                                    "Trunque a expansão: y(t_{n+1}) ≈ y(t_n) + h y'(t_n).",
                                    "Substitua y'(t_n) = f(t_n, y(t_n)) para obter a forma explícita inicial.",
                                    "Para melhorar, considere deslocar o ponto de avaliação: y(t_{n+1}) ≈ y(t_n) + h y'(t_{n+1}).",
                                    "Expresse y'(t_{n+1}) = f(t_{n+1}, y(t_{n+1})), levando à forma implícita.",
                                    "Reescreva discretamente: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})."
                                  ],
                                  "verification": "Derive e escreva a equação implícita y_{n+1} - h f(t_{n+1}, y_{n+1}) = y_n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Mathematica ou Python para plotar Taylor (opcional)"
                                  ],
                                  "tips": "Pense no termo linear como integral de y' de t_n a t_{n+1}, aproximado por retângulo à direita.",
                                  "learningObjective": "Transformar a aproximação de Taylor em uma fórmula numérica implícita.",
                                  "commonMistakes": [
                                    "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})",
                                    "Confundir truncamento após termo constante",
                                    "Esquecer o h multiplicando f"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar a Forma Implícita e Comparar com Euler Explícito",
                                  "subSteps": [
                                    "Compare com Euler Explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Mostre graficamente por que o implícito usa o valor futuro para melhor estabilidade.",
                                    "Verifique consistência: ambos têm ordem 1, erro local O(h^2).",
                                    "Discuta resolução: requer método iterativo como ponto fixo ou Newton.",
                                    "Teste com exemplo linear para validar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença chave e a justificativa implícita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de pendulo ou decaimento para ilustração",
                                    "Caneta colorida para diagramas"
                                  ],
                                  "tips": "Desenhe setas no plano t-y mostrando aproximação retangular à direita.",
                                  "learningObjective": "Diferenciar e justificar o Euler Implícito versus Explícito.",
                                  "commonMistakes": [
                                    "Achar que implícito tem ordem superior",
                                    "Ignorar necessidade de iteração",
                                    "Confundir estabilidade com precisão local"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Erro Local de Truncamento O(h^2)",
                                  "subSteps": [
                                    "Subtraia a aproximação da expansão exata: erro = y(t_{n+1}) - y_{n+1} = (h^2)/2 y''(ξ) + O(h^3).",
                                    "Como y_{n+1} ≈ y(t_{n+1}) - (h^2)/2 y''(t_{n+1}) + ..., confirme |erro| ≤ C h^2.",
                                    "Assuma f suave (C^2) para majorar y'' via derivadas parciais.",
                                    "Calcule para exemplo y' = λ y: erro exato via série.",
                                    "Conclua ordem de consistência 1."
                                  ],
                                  "verification": "Escreva a estimativa de erro com constante C e prove O(h^2).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de derivadas parciais de f",
                                    "Exemplo numérico resolvido"
                                  ],
                                  "tips": "Use notação big-O rigorosamente; teste limitando h→0.",
                                  "learningObjective": "Quantificar e provar o erro local de truncamento.",
                                  "commonMistakes": [
                                    "Achar erro O(h)",
                                    "Confundir erro local com global",
                                    "Não assumir suavidade de f"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -10y, y(0)=1 (decaimento rígido), derive y_{n+1} = y_n + h (-10 y_{n+1}), resolva: y_{n+1} = y_n / (1 + 10h). Compare passos com solução exata y(t)=e^{-10t}.",
                              "finalVerifications": [
                                "Escreve corretamente y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                "Deriva a expansão de Taylor e identifica o truncamento.",
                                "Justifica erro local O(h^2) com resto de Lagrange.",
                                "Compara com Euler Explícito e explica implícita.",
                                "Aplica a um PVI linear simples sem erros.",
                                "Discute necessidade de solver não-linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da Taylor (100% dos termos corretos).",
                                "Correta identificação da forma implícita (sem confusão com explícito).",
                                "Prova rigorosa do erro O(h^2) com majorantes.",
                                "Explicação clara da motivação (estabilidade para stiff).",
                                "Exemplo prático resolvido numericamente.",
                                "Uso correto de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDOs rígidas em dinâmica molecular.",
                                "Computação: Implementação em solvers como SciPy (odeint).",
                                "Engenharia: Simulações de circuitos elétricos com Runge-Kutta implícito.",
                                "Estatística: Análise de erro em métodos MCMC."
                              ],
                              "realWorldApplication": "Usado em software de simulação como MATLAB ode15s para resolver EDOs rígidas em farmacocinética, onde estabilidade é crucial para passos h grandes sem oscilações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Aplicar o método em um exemplo linear simples",
                            "description": "Resolver numericamente y' = λy com y(0)=1 usando Euler implícito para λ < 0, computando manualmente 2-3 passos e comparando com a solução exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema e recordar a fórmula do Euler implícito",
                                  "subSteps": [
                                    "Identifique a equação diferencial: y' = λy com y(0) = 1 e λ < 0 (ex: λ = -1).",
                                    "Recorde a fórmula do Euler implícito: y_{n+1} = y_n + h f(t_n + h, y_{n+1}). Para este caso linear: y_{n+1} = y_n / (1 - hλ).",
                                    "Escolha o tamanho de passo h (ex: h = 0.2) e defina o número de passos (2-3 passos).",
                                    "Prepare uma tabela para registrar t_n, y_n e y_{n+1}.",
                                    "Verifique se λ < 0 garante estabilidade incondicional do método."
                                  ],
                                  "verification": "Confirme que a fórmula está corretamente escrita e parâmetros escolhidos (h > 0 pequeno, λ negativo).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis, calculadora básica.",
                                  "tips": "Use λ = -1 e h = 0.2 para simplicidade nos cálculos manuais.",
                                  "learningObjective": "Entender a configuração inicial e a forma explícita da iteração para problemas lineares.",
                                  "commonMistakes": "Confundir com Euler explícito (y_{n+1} = y_n + h f(t_n, y_n)); esquecer o denominador na fórmula implícita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o primeiro passo manualmente",
                                  "subSteps": [
                                    "Inicie com t_0 = 0, y_0 = 1.",
                                    "Calcule y_1 = y_0 / (1 - hλ) = 1 / (1 - 0.2*(-1)) = 1 / 1.2 ≈ 0.8333.",
                                    "Registre t_1 = 0.2, y_1 ≈ 0.8333.",
                                    "Verifique o cálculo algebricamente antes de aproximar numericamente.",
                                    "Anote o erro relativo se souber a exata aproximada."
                                  ],
                                  "verification": "y_1 deve ser menor que 1 (decaimento) e cálculo exato sem arredondamento prematuro.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, calculadora.",
                                  "tips": "Mantenha frações exatas inicialmente: y_1 = 1 / (1 + h|λ|).",
                                  "learningObjective": "Aplicar a iteração implícita para o primeiro passo com precisão.",
                                  "commonMistakes": "Usar fórmula explícita por engano; sinal errado em -hλ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar os passos subsequentes (2º e 3º)",
                                  "subSteps": [
                                    "Para o 2º passo: y_2 = y_1 / (1 - hλ) ≈ 0.8333 / 1.2 ≈ 0.6944, t_2 = 0.4.",
                                    "Para o 3º passo: y_3 = y_2 / (1 - hλ) ≈ 0.6944 / 1.2 ≈ 0.5787, t_3 = 0.6.",
                                    "Registre todos os valores em tabela: t | y_n | y_{n+1}.",
                                    "Observe o padrão: y_n = [1 / (1 - hλ)]^n.",
                                    "Calcule numericamente com mais casas decimais para comparação futura."
                                  ],
                                  "verification": "Valores decrescendo monotonicamente; y_3 ≈ 0.5787 para os parâmetros dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmos do passo anterior.",
                                  "tips": "Repita a mesma fórmula iterativamente; use padrão geométrico para verificação rápida.",
                                  "learningObjective": "Executar múltiplas iterações manuais e reconhecer o comportamento de decaimento.",
                                  "commonMistakes": "Arredondamento excessivo propagando erros; pular verificação intermediária."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a solução exata e comparar resultados",
                                  "subSteps": [
                                    "Solucione analiticamente: y(t) = e^{λt} = e^{-t} para λ=-1.",
                                    "Calcule exata nos pontos: y(0.2)≈0.8187, y(0.4)≈0.6703, y(0.6)≈0.5488.",
                                    "Compute erros absolutos: |y_1 - exata| ≈ |0.8333-0.8187|=0.0146, etc.",
                                    "Calcule erros relativos e discuta se o método superestima (devido a implícito para λ<0).",
                                    "Plote graficamente aproximado vs exato (opcional, manual)."
                                  ],
                                  "verification": "Erros pequenos e consistentes; método estável sem oscilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora com exp(), papel para tabela de erros.",
                                  "tips": "Use ln ou exp na calculadora; compare tendências qualitativas primeiro.",
                                  "learningObjective": "Avaliar precisão numérica comparando com analítica.",
                                  "commonMistakes": "Erro na solução exata (esquecer y(0)=1); confundir absoluto com relativo."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.2: y1≈0.8333 (exata 0.8187), y2≈0.6944 (0.6703), y3≈0.5787 (0.5488). Erros: 1.8%, 3.6%, 5.6%. O método superestima mas permanece estável.",
                              "finalVerifications": [
                                "Fórmula implícita aplicada corretamente em todos passos.",
                                "Valores numéricos coincidem com cálculos manuais repetidos.",
                                "Solução exata derivada e avaliada nos pontos t_n.",
                                "Erros computados e tabela completa de resultados.",
                                "Discussão qualitativa: estabilidade para λ<0 observada.",
                                "Nenhum oscilação ou divergência nos aproximados."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos manuais (erro <1% em iterações).",
                                "Correta derivação da fórmula iterativa linear.",
                                "Comparação quantitativa (erros absolutos/relativos).",
                                "Interpretação dos resultados (superestimação esperada).",
                                "Clareza na tabela e documentação.",
                                "Reconhecimento da estabilidade incondicional."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou resfriamento Newtoniano.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Computação Científica: Introdução a solvers numéricos como odeint.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Simulação de processos de decaimento em farmacocinética (concentração de drogas no sangue), previsão de populações em declínio ecológico, ou estabilidade em circuitos RC em engenharia elétrica, onde métodos implícitos garantem robustez para passos maiores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Resolução da Equação Não Linear no Passo",
                        "description": "Estratégias para resolver a equação não linear g(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0 em cada iteração do método.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Formular a equação não linear equivalente",
                            "description": "Reescrever o passo implícito como uma equação residual g(z) = 0 onde z = y_{n+1}, e identificar condições para unicidade da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Método de Euler Implícito",
                                  "subSteps": [
                                    "Revise a fórmula geral do problema de valor inicial (PVI): y' = f(t, y), y(t_0) = y_0.",
                                    "Estude a discretização do método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Compare com o implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique por que é implícito: y_{n+1} aparece dos dois lados.",
                                    "Anote os prós e contras: mais estável para problemas rígidos, mas requer solução não linear."
                                  ],
                                  "verification": "Escreva a fórmula do Euler implícito corretamente e explique a dependência em y_{n+1}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica, caderno, lápis.",
                                  "tips": "Desenhe a grade temporal t_n e t_{n+1} para visualizar.",
                                  "learningObjective": "Entender a motivação e estrutura do método implícito.",
                                  "commonMistakes": "Confundir com Euler explícito; esquecer que f usa t_{n+1}."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Isolar a Variável Desconhecida z = y_{n+1}",
                                  "subSteps": [
                                    "Defina z = y_{n+1} como a incógnita a ser resolvida.",
                                    "Substitua na fórmula: z = y_n + h f(t_{n+1}, z).",
                                    "Reorganize para uma forma explícita de z em ambos os lados.",
                                    "Verifique simbolicamente para um exemplo simples, como f(t,y) = λy.",
                                    "Registre os valores conhecidos: y_n, h, t_{n+1}."
                                  ],
                                  "verification": "Mostre que z aparece isoladamente no lado esquerdo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica (opcional).",
                                  "tips": "Use substituição passo a passo para evitar erros algébricos.",
                                  "learningObjective": "Preparar a equação para a forma residual.",
                                  "commonMistakes": "Esquecer de atualizar t para t_{n+1} em f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Equação Residual g(z) = 0",
                                  "subSteps": [
                                    "Comece com z - y_n - h f(t_{n+1}, z) = 0.",
                                    "Defina g(z) = z - y_n - h f(t_{n+1}, z).",
                                    "Escreva explicitamente g(z) = 0 como a equação não linear equivalente.",
                                    "Teste com um exemplo: para y' = y, g(z) = z - y_n - h z = 0.",
                                    "Confirme que resolver g(z) = 0 dá y_{n+1}."
                                  ],
                                  "verification": "Derive g(z) do zero e verifique g(y_{n+1}) = 0 pela definição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de PVI do textbook, software como Mathematica para verificação.",
                                  "tips": "Sempre isole o termo linear em z primeiro.",
                                  "learningObjective": "Construir a forma padrão da equação residual.",
                                  "commonMistakes": "Definir g(z) = y_n + h f(t_{n+1}, z) - z (sinal errado)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Condições para Unicidade da Solução",
                                  "subSteps": [
                                    "Lembre o Teorema do Ponto Fixo de Banach: contração em espaço completo.",
                                    "Verifique Lipschitz em f: |f(t,y1) - f(t,y2)| ≤ L |y1 - y2|.",
                                    "Para g(z), compute g'(z) = 1 - h f_y(t_{n+1}, z); exija |1 - h f_y| < 1.",
                                    "Discuta condições: h < 2/|f_y| para estabilidade e unicidade local.",
                                    "Aplique a um exemplo rígido para ilustrar."
                                  ],
                                  "verification": "Enuncie as condições e verifique para um f dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de análise real, exemplos numéricos.",
                                  "tips": "Foquem na derivada parcial f_y para condições práticas.",
                                  "learningObjective": "Garantir existência e unicidade teórica.",
                                  "commonMistakes": "Ignorar dependência em h; assumir unicidade sem Lipschitz."
                                }
                              ],
                              "practicalExample": "Para y' = -10y, y(0)=1, h=0.1, n=0: g(z) = z - 1 - 0.1*(-10z) = z -1 + z = 2z -1 =0 → z=0.5. Verifique unicidade: f_y=-10, |1 - 0.1*(-10)|=|2|=2>1? Ajuste h menor para contração.",
                              "finalVerifications": [
                                "g(z) corretamente derivada da fórmula implícita.",
                                "z definido como y_{n+1}.",
                                "Condições de Lipschitz e contração explicitadas.",
                                "Exemplo numérico resolvido sem erros.",
                                "Equação residual testada: g(y_{n+1})=0.",
                                "Discussão de unicidade com h apropriado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de g(z): 30%.",
                                "Correta identificação de z e termos conhecidos: 20%.",
                                "Análise completa de condições de unicidade: 25%.",
                                "Exemplo prático funcional: 15%.",
                                "Clareza e notação matemática: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar fixed-point iteration em Python para resolver g(z)=0.",
                                "Física: Modelos rígidos como circuitos RC em simulações numéricas.",
                                "Engenharia: Estabilidade em controle de sistemas dinâmicos.",
                                "Computação Científica: Integração com bibliotecas como SciPy ode solvers."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou circuitos elétricos rígidos, formular equações residuais garante passos numéricos estáveis e precisos em software como MATLAB ou COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Implementar iteração de ponto fixo para resolução",
                            "description": "Reformular como z = φ(z) com φ(z) = y_n + h f(t_{n+1}, z) e aplicar critério de contração |φ'(z)| < 1 para convergência, testando em exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reformular a equação não linear do Euler Implícito na forma de ponto fixo",
                                  "subSteps": [
                                    "Identifique a equação do método de Euler Implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Defina z = y_{n+1} como a incógnita e isole-a para obter z = φ(z), onde φ(z) = y_n + h f(t_{n+1}, z).",
                                    "Escreva explicitamente φ(z) para o problema dado, substituindo f(t,y).",
                                    "Verifique se a reformulação preserva a solução original da equação não linear.",
                                    "Documente a função φ(z) em notação matemática clara."
                                  ],
                                  "verification": "Confirme que φ(z^*) = z^* satisfaz a equação original para um z^* arbitrário.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Software de álgebra simbólica como SymPy (opcional)"
                                  ],
                                  "tips": "Escolha uma reformulação que facilite o cálculo de derivadas para o próximo passo.",
                                  "learningObjective": "Compreender como transformar equações implícitas em problemas de ponto fixo.",
                                  "commonMistakes": [
                                    "Esquecer de incluir t_{n+1} em f",
                                    "Não isolar z corretamente",
                                    "Confundir y_n com y_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar o critério de contração para garantir convergência",
                                  "subSteps": [
                                    "Calcule a derivada φ'(z) = h * ∂f/∂y (t_{n+1}, z).",
                                    "Avalie |φ'(z)| em um intervalo relevante ao redor do ponto fixo esperado.",
                                    "Verifique se sup_{z} |φ'(z)| < 1; se não, ajuste h ou reformule φ.",
                                    "Estime o erro de convergência usando |z_{k+1} - z^*| ≤ K |z_k - z^*| com K = sup |φ'(z)|.",
                                    "Registre o valor máximo de |φ'(z)| e o raio de atração."
                                  ],
                                  "verification": "Mostre graficamente ou numericamente que |φ'(z)| < 1 no intervalo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfica de funções (Desmos ou Python/Matplotlib)"
                                  ],
                                  "tips": "Use h pequeno para melhorar a contração; teste derivadas analiticamente primeiro.",
                                  "learningObjective": "Aplicar o teorema do ponto fixo de Banach para análise de convergência.",
                                  "commonMistakes": [
                                    "Calcular φ'(z) incorretamente",
                                    "Ignorar dependência em t_{n+1}",
                                    "Não considerar o supremo no intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo de iteração de ponto fixo",
                                  "subSteps": [
                                    "Inicialize z_0 com uma estimativa inicial, como y_n (aproximação de Euler explícito).",
                                    "Defina tolerância ε (ex: 1e-6) e máximo de iterações N_max (ex: 100).",
                                    "Itere: z_{k+1} = φ(z_k) até |z_{k+1} - z_k| < ε ou k > N_max.",
                                    "Implemente em pseudocódigo ou código real (Python/MATLAB).",
                                    "Registre o número de iterações e histórico de z_k."
                                  ],
                                  "verification": "Execute o código com valores conhecidos e confira se converge para o esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Bibliotecas: numpy para cálculos"
                                  ],
                                  "tips": "Monitore o resíduo |z_{k+1} - z_k| em vez de apenas diferença absoluta.",
                                  "learningObjective": "Codificar e debugar iteradores numéricos de forma eficiente.",
                                  "commonMistakes": [
                                    "Loop infinito sem N_max",
                                    "Tolerância muito rígida",
                                    "Inicialização ruim levando a divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar em exemplo numérico e analisar resultados",
                                  "subSteps": [
                                    "Aplique a um PVI exemplo: y' = -y^2, y(0)=1, h=0.1, n=1 (t1=0.1).",
                                    "Calcule y1 via iteração: φ(z) = 1 + 0.1*(-z^2), z0=1.",
                                    "Compare com solução exata y(t)=1/(1+t) ≈ 0.9091.",
                                    "Plote histórico de iterações e erro vs. k.",
                                    "Discuta sensibilidade a h e inicialização."
                                  ],
                                  "verification": "Erro final < 1e-5 e convergência em <20 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python do passo anterior",
                                    "Solução analítica calculada"
                                  ],
                                  "tips": "Use print statements para debugar iterações; teste com h maior para ver falha.",
                                  "learningObjective": "Validar método numericamente e interpretar resultados.",
                                  "commonMistakes": [
                                    "Erro no exemplo (f errada)",
                                    "Comparação com solução errada",
                                    "Ignorar não-convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y^2, y(0)=1, h=0.1 em t=0.1: φ(z) = 1 - 0.1 z^2. z0=1 → z1=1-0.1*1=0.9 → z2=1-0.1*0.81=0.919 → z3≈0.9086 (converge para ≈0.9091 em 5 iterações). |φ'(z)|=0.2|z| <0.2<1.",
                              "finalVerifications": [
                                "Iteração converge em <20 passos para ε=1e-6.",
                                "Solução z^* satisfaz |z^* - φ(z^*)| < 1e-8.",
                                "|φ'(z)| <1 verificado no intervalo [0.8,1.0].",
                                "Erro relativo vs. solução exata <1%.",
                                "Código roda sem erros para múltiplos h.",
                                "Histórico mostra redução monotônica do erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro de convergência <1e-6.",
                                "Eficiência: <15 iterações na média.",
                                "Correção teórica: φ(z) e φ'(z) definidas precisamente.",
                                "Implementação: Código limpo, comentado e reutilizável.",
                                "Análise: Discussão de contração e limitações.",
                                "Validação: Comparação com analítico ou outro método."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops e funções numéricas em Python.",
                                "Física: Modelagem de EDOs em dinâmica de populações ou decaimento.",
                                "Engenharia: Simulações em controle de sistemas implícitos.",
                                "Estatística: Análise de erros e convergência probabilística."
                              ],
                              "realWorldApplication": "Usado em solvers de EDOs implícitas para simulações em engenharia química (reatores), finanças (modelos Black-Scholes implícitos) e biofísica (reações não lineares), onde métodos explícitos falham por instabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Usar o método de Newton para solver não linear",
                            "description": "Aplicar iteração de Newton z^{k+1} = z^k - g(z^k)/g'(z^k) com g'(z) = 1 - h f_y(t_{n+1}, z), inicializando com z^0 = y_n e verificando convergência quadrática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a equação não linear g(z) = 0 e sua derivada g'(z)",
                                  "subSteps": [
                                    "Relembrar o método de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Definir g(z) = z - y_n - h f(t_{n+1}, z).",
                                    "Calcular a derivada g'(z) = 1 - h ∂f/∂y (t_{n+1}, z).",
                                    "Verificar se f_y (derivada parcial de f em relação a y) está disponível ou pode ser aproximada.",
                                    "Documentar as expressões de g(z) e g'(z) para o problema específico."
                                  ],
                                  "verification": "g(z) e g'(z) estão corretamente expressas e g'(z) ≠ 0 em pontos relevantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica ou software como SymPy/MATLAB.",
                                  "tips": "Sempre compute g'(z) analiticamente para precisão; evite aproximações numéricas iniciais.",
                                  "learningObjective": "Compreender a origem da equação não linear no Euler implícito e derivar g e g'.",
                                  "commonMistakes": "Confundir g(z) com a equação original; esquecer o sinal na derivada parcial f_y."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o iterado z^0 = y_n",
                                  "subSteps": [
                                    "Atribuir z^0 = y_n como chute inicial.",
                                    "Avaliar g(z^0) e g'(z^0) para verificar se já é raiz (raro).",
                                    "Definir tolerância de convergência ε (ex: 10^{-6}) e máximo de iterações K_max (ex: 20).",
                                    "Registrar valores iniciais: t_{n+1}, y_n, h, f.",
                                    "Preparar tabela ou lista para registrar iterações."
                                  ],
                                  "verification": "z^0 está definido como y_n e parâmetros de parada configurados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Planilha ou caderno para tabela de iterações, software numérico opcional.",
                                  "tips": "Escolha ε baseada na precisão desejada do método global (ordem 1 do Euler).",
                                  "learningObjective": "Selecionar chute inicial ótimo e parâmetros de controle para estabilidade.",
                                  "commonMistakes": "Usar chute ruim diferente de y_n, levando a divergência; tolerância muito pequena."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações do método de Newton z^{k+1} = z^k - g(z^k)/g'(z^k)",
                                  "subSteps": [
                                    "Para k = 0,1,... até parada: calcular g(z^k) e g'(z^k).",
                                    "Computar correção δ = g(z^k)/g'(z^k).",
                                    "Atualizar z^{k+1} = z^k - δ.",
                                    "Verificar ||z^{k+1} - z^k|| < ε ou |g(z^{k+1})| < ε.",
                                    "Registrar z^k, g(z^k), δ em cada iteração."
                                  ],
                                  "verification": "Iterações produzem sequência decrescente em erro até tolerância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, Python/Octave para automação, tabela de iterações.",
                                  "tips": "Monitore g'(z^k) para evitar divisão por zero; use extrapolação se necessário.",
                                  "learningObjective": "Aplicar corretamente a iteração de Newton para resolver g(z)=0.",
                                  "commonMistakes": "Erro de sinal na atualização (deve ser menos); não atualizar corretamente g'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência quadrática e atribuir y_{n+1} = z^{final}",
                                  "subSteps": [
                                    "Confirmar parada por ||z^{k+1}-z^k|| < ε ou k > K_max.",
                                    "Verificar convergência quadrática: calcular e_k = |z^* - z^k| approx, checar e_{k+1}/e_k^2 ≈ constante.",
                                    "Ou usar |δ_{k+1}| / |δ_k|^2 < 0.1 para indício.",
                                    "Atribuir y_{n+1} = z^{k+1} e prosseguir para próximo passo.",
                                    "Analisar número de iterações (tipicamente 4-6 para quadrática)."
                                  ],
                                  "verification": "Convergência confirmada numericamente e y_{n+1} definido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico de erros (opcional via software), logs de iterações.",
                                  "tips": "Para convergência quadrática, chute inicial bom é crucial; compare com solução exata se conhecida.",
                                  "learningObjective": "Diagnosticar e validar a convergência quadrática do método.",
                                  "commonMistakes": "Ignorar divergência (g'→0); confundir convergência linear com quadrática."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1, n=0: g(z) = z - 1 - 0.1*(-z) = 1.1z -1; g'(z)=1+0.1=1.1. z^0=1, z^1=1 - (1.1*1-1)/1.1 ≈0.909, z^2≈0.9048 (converge em 3 iterações para y1≈0.9048).",
                              "finalVerifications": [
                                "g(z^{final}) ≈ 0 dentro de ε.",
                                "Número de iterações ≤ K_max.",
                                "Convergência quadrática observada via razão de erros.",
                                "g'(z^k) ≠ 0 em todas iterações.",
                                "y_{n+1} consistente com ordem do método.",
                                "Sem NaN ou overflow em cálculos."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de g(z) e g'(z) (100%).",
                                "Implementação correta das iterações (90% precisão numérica).",
                                "Verificação adequada de convergência (incluindo quadrática).",
                                "Análise de erros comuns evitados.",
                                "Eficiência: ≤6 iterações para ε=10^{-8}.",
                                "Documentação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para automação.",
                                "Física: Resolver EDOs em dinâmica (ex: movimento harmônico).",
                                "Engenharia: Simulações em controle e circuitos.",
                                "Estatística: Otimização não linear em regressão."
                              ],
                              "realWorldApplication": "Usado em solvers de EDOs implícitos como ode15s no MATLAB, para modelar reações químicas rígidas, circuitos elétricos e finanças (modelos Black-Scholes implícitos), garantindo eficiência em problemas stiff."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Análise de Estabilidade e Aplicações a Problemas Stiff",
                        "description": "Estudo da estabilidade absoluta e A-estabilidade do método, com ênfase em sua adequação para equações diferenciais stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Analisar o erro local de truncamento",
                            "description": "Derivar o erro local O(h^2) via expansão de Taylor e mostrar consistência de ordem 1 global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Implícito e Configuração do Problema",
                                  "subSteps": [
                                    "Relembre a equação diferencial y' = f(t, y), y(t_0) = y_0.",
                                    "Escreva a fórmula do Método de Euler Implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Defina o erro local de truncamento τ_{n+1} como a diferença entre a solução exata y(t_{n+1}) e o valor numérico assumindo y_n = y(t_n) exato.",
                                    "Estabeleça as hipóteses de suavidade: f, ∂f/∂t, ∂f/∂y e suas derivadas contínuas.",
                                    "Anote a solução exata em t_{n+1} assumindo y(t_n) exato."
                                  ],
                                  "verification": "Confirme que a fórmula do método está correta e as hipóteses de suavidade listadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, livro de Análise Numérica (capítulo de métodos de Runge-Kutta ou Euler).",
                                  "tips": "Desenhe um diagrama temporal com pontos t_n e t_{n+1} para visualizar.",
                                  "learningObjective": "Compreender precisamente o setup do erro local no contexto do Euler Implícito.",
                                  "commonMistakes": "Confundir Euler Explícito (y_{n+1} = y_n + h f(t_n, y_n)) com Implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansão de Taylor à Solução Exata",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) em torno de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2)/2 y''(ξ) para algum ξ em (t_n, t_{n+1}).",
                                    "Expresse as derivadas via f: y' = f(t,y), y'' = ∂f/∂t + ∂f/∂y * f.",
                                    "Continue a expansão até ordem h^2: inclua termos até y''' se necessário para precisão.",
                                    "Substitua y(t_n) = y_n (exato no passo).",
                                    "Simplifique para mostrar y(t_{n+1}) = y_n + h f(t_n, y_n) + (h^2)/2 y''(ξ)."
                                  ],
                                  "verification": "Verifique se a expansão resulta em O(h^2) termo remanescente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica ou software como Mathematica/Maple para verificação opcional.",
                                  "tips": "Use notação de Taylor com resto de Lagrange para rigor.",
                                  "learningObjective": "Dominar a expansão de Taylor multivariável para soluções de EDOs.",
                                  "commonMistakes": "Esquecer de expandir f(t_{n+1}, y(t_{n+1})) corretamente ou parar na primeira ordem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Expansão do Método Numérico",
                                  "subSteps": [
                                    "Assuma y_{n+1} = y(t_{n+1}) + O(h^2) e expanda f(t_{n+1}, y_{n+1}).",
                                    "Expanda f(t_{n+1}, y_{n+1}) = f(t_n + h, y_n + h f(t_{n+1}, y_{n+1})) usando Taylor em t e y.",
                                    "Substitua na equação do método: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Resolva iterativamente ou use aproximação para mostrar consistência.",
                                    "Compare com a expansão exata para isolar o termo de erro local τ_{n+1} = [y(t_{n+1}) - y_{n+1}]/h = O(h)."
                                  ],
                                  "verification": "Confirme que τ_{n+1} = O(h), implicando erro local O(h^2).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de papel quadriculado para álgebra simbólica.",
                                  "tips": "Introduza z_{n+1} = y_n + h f(t_{n+1}, z_{n+1}) e expanda z_{n+1} = y_n + h f(t_n, y_n) + O(h^2).",
                                  "learningObjective": "Derivar analiticamente o erro local via substituição na fórmula implícita.",
                                  "commonMistakes": "Ignorar a dependência implícita em y_{n+1} ao expandir f."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mostrar Consistência de Ordem 1 Global",
                                  "subSteps": [
                                    "Lembre que erro global e_g = max |y(t_n) - y_n| satisfaz |e_{n+1}| ≤ |e_n| + h |τ_{n+1}| + O(h^2).",
                                    "Como τ_{n+1} = O(h), some telescopicamente: e_N ≤ e_0 + h ∑ |τ_k| + O(h) T ≤ C h.",
                                    "Discuta estabilidade para problemas stiff onde Euler Implícito brilha.",
                                    "Verifique com exemplo numérico simples.",
                                    "Conclua que o método é consistente de ordem 1."
                                  ],
                                  "verification": "Demonstre que e(t_N) = O(h) para T fixo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplo numérico resolvido previamente (e.g., y' = -y).",
                                  "tips": "Use desigualdade triangular rigorosamente na soma.",
                                  "learningObjective": "Conectar erro local à ordem global via teorema de consistência e estabilidade.",
                                  "commonMistakes": "Confundir ordem local (2) com global (1) sem somar corretamente."
                                }
                              ],
                              "practicalExample": "Para y' = λ y (λ < 0 stiff), y(0)=1, h=0.1, compute y(0.1) exato via série e compare com Euler Implícito: solução exata y(h)=exp(λ h) ≈ 1 + λ h + (λ h)^2 /2; numérico resolve y1 = 1 / (1 - λ h), erro local ≈ (λ^2 h^2)/2, confirmando O(h^2).",
                              "finalVerifications": [
                                "Derivação da expansão de Taylor da solução exata até O(h^2).",
                                "Expansão correta de f(t_{n+1}, y_{n+1}) no método implícito.",
                                "Cálculo explícito de τ_{n+1} = O(h).",
                                "Demonstração da acumulação para erro global O(h).",
                                "Verificação numérica em exemplo simples coincide com análise.",
                                "Discussão de hipóteses de suavidade satisfeitas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (ausência de termos errados).",
                                "Correta identificação do termo líder de erro O(h^2).",
                                "Rigor na derivação implícita sem aproximações injustificadas.",
                                "Ligação clara entre erro local e global.",
                                "Uso correto de notação e hipóteses.",
                                "Exemplo prático computado com valores numéricos exatos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de osciladores stiff.",
                                "Computação: Implementação e teste de métodos implícitos em Python (SciPy).",
                                "Engenharia: Modelagem de circuitos RLC com alta rigidez.",
                                "Estatística: Erros de truncamento em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff como reações químicas em engenharia química ou dinâmica de fluidos compressíveis, onde Euler Explícito falha por instabilidade, o Euler Implícito requer análise de erro para escolher h otimizado, garantindo precisão em predições industriais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Determinar a região de estabilidade absoluta",
                            "description": "Para y' = λy, obter |1 / (1 - hλ)| ≤ 1, mostrando que o método é incondicionalmente estável para Re(λ) < 0 (A-estável).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar o problema de teste linear e o fator de amplificação do Euler Implícito",
                                  "subSteps": [
                                    "Relembre o problema de teste y' = λy, com solução y(t) = y0 e^{λt}.",
                                    "Escreva a iteração do método de Euler implícito: y_{n+1} = y_n + h f(t_n + h, y_{n+1}).",
                                    "Para f(y) = λy, derive a fator de amplificação R(z) = y_{n+1}/y_n = 1 / (1 - z), onde z = hλ.",
                                    "Verifique que para o método explícito é R(z) = 1 + z.",
                                    "Confirme que |R(z)| ≤ 1 define a região de estabilidade absoluta."
                                  ],
                                  "verification": "Escreva corretamente R(z) para Euler implícito e compare com o explícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Livro de Análise Numérica (capítulo de métodos lineares)"
                                  ],
                                  "tips": "Comece sempre pelo problema de teste padrão para normalizar a análise.",
                                  "learningObjective": "Entender a origem do fator de amplificação no contexto do teste linear.",
                                  "commonMistakes": [
                                    "Confundir Euler implícito com explícito (R(z) = 1 + z)",
                                    "Esquecer que z = hλ é complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer a condição de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina formalmente a região de estabilidade absoluta S = {z ∈ ℂ : |R(z)| ≤ 1}.",
                                    "Para Euler implícito, escreva |1 / (1 - z)| ≤ 1.",
                                    "Simplifique a desigualdade: |1| ≤ |1 - z|, ou |1 - z| ≥ 1.",
                                    "Interprete geometricamente: pontos z onde a distância a 1 é pelo menos 1.",
                                    "Desenhe o plano complexo e identifique o exterior do círculo unitário centrado em 1."
                                  ],
                                  "verification": "Resolva |1 - z| ≥ 1 e esboce a região no plano complexo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plano complexo impresso ou software como GeoGebra",
                                    "Calculadora para manipular módulos complexos"
                                  ],
                                  "tips": "Use propriedades de módulo: |a/b| = |a|/|b| para simplificar.",
                                  "learningObjective": "Dominar a derivação algébrica da condição |R(z)| ≤ 1.",
                                  "commonMistakes": [
                                    "Esquecer de inverter ao elevar ao quadrado: |1 - z|^2 ≥ 1",
                                    "Confundir interior com exterior do círculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a estabilidade para Re(λ) < 0",
                                  "subSteps": [
                                    "Considere z = hλ com h > 0 e Re(λ) < 0, então Re(z) < 0.",
                                    "Mostre que para Re(z) < 0, z está no semiplano esquerdo.",
                                    "Verifique se o semiplano esquerdo está contido no exterior do círculo |1 - z| ≥ 1.",
                                    "Prove que para Re(z) ≤ 0, |1 - z|^2 = (1 - Re(z))^2 + Im(z)^2 ≥ 1^2 + 0 = 1.",
                                    "Conclua que |R(z)| ≤ 1 para todo h > 0 quando Re(λ) < 0."
                                  ],
                                  "verification": "Prove matematicamente que Re(z) ≤ 0 implica |1 - z| ≥ 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para cálculos algébricos",
                                    "Exemplos numéricos com λ = -1 + i"
                                  ],
                                  "tips": "Expanda |1 - z|^2 = (1 - x)^2 + y^2 onde z = x + iy, e note que x ≤ 0 implica ≥1.",
                                  "learningObjective": "Compreender por que o método é incondicionalmente estável para problemas stiff.",
                                  "commonMistakes": [
                                    "Achar que é estável só para λ real negativo",
                                    "Ignorar a parte imaginária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir A-estabilidade e visualizar a região",
                                  "subSteps": [
                                    "Defina A-estabilidade: S contém o semiplano esquerdo Re(z) < 0.",
                                    "Confirme que para Euler implícito, S é exatamente o exterior do círculo, que inclui todo Re(z) < 0.",
                                    "Compare com Euler explícito (disco |z| ≤ 2 centrado em 0).",
                                    "Desenhe as regiões de estabilidade de ambos métodos.",
                                    "Discuta implicações para problemas stiff (Re(λ) << 0, hλ << -1)."
                                  ],
                                  "verification": "Esboce S para Euler implícito e destaque o semiplano esquerdo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como Desmos ou MATLAB para regiões complexas"
                                  ],
                                  "tips": "Use cores diferentes para regiões de implícito vs. explícito.",
                                  "learningObjective": "Reconhecer e justificar a A-estabilidade do Euler implícito.",
                                  "commonMistakes": [
                                    "Pensar que A-estável significa estável para todo h, ignorando instabilidades não lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -100 y + i y (λ = -100 + i), com h=0.1, compute z = hλ ≈ -10 + 0.1i. Verifique |R(z)| = |1/(1 - (-10 + 0.1i))| ≈ |1/11| <1, estável. Para h=0.01, z≈ -1 + 0.01i, ainda |R(z)|<1. Compare com Euler explícito que falha para h grande.",
                              "finalVerifications": [
                                "Deriva corretamente R(z) = 1/(1-z) para Euler implícito.",
                                "Resolve |1/(1-z)| ≤1 como |1-z| ≥1.",
                                "Prova que Re(z)<0 implica estabilidade incondicional.",
                                "Esboça a região S como exterior do círculo unitário centrado em 1.",
                                "Explica A-estabilidade e contrasta com métodos explícitos.",
                                "Aplica a um exemplo numérico stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) e da desigualdade (90% correto).",
                                "Correta interpretação geométrica da região S.",
                                "Prova rigorosa da inclusão do semiplano esquerdo em S.",
                                "Uso correto de notação complexa e módulos.",
                                "Capacidade de comparar com outros métodos.",
                                "Clareza na explicação de implicações para problemas stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos (equações diferenciais stiff).",
                                "Computação: Implementação numérica em Python/MATLAB para verificar estabilidade.",
                                "Engenharia: Modelagem de circuitos RLC com rigidez alta.",
                                "Estatística: Análise de erros em métodos numéricos probabilísticos."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: cinética enzimática), onde escalares de tempo variam muito, o Euler implícito permite passos h grandes sem instabilidade, acelerando computações em software como COMSOL ou FEniCS para design de reatores industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Aplicar em problema stiff exemplar",
                            "description": "Resolver numericamente um sistema stiff como y' = -1000y + sin(t) com Euler implícito vs. explícito, demonstrando restrição de passo no explícito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema stiff e sua formulação",
                                  "subSteps": [
                                    "Defina o que é um problema stiff em EDOs, destacando rigidez devido a escalas de tempo díspares.",
                                    "Analise o exemplo y' = -1000y + sin(t), identificando o termo rígido (-1000y) e o termo forçante (sin(t)).",
                                    "Estabeleça condições iniciais (ex: y(0) = 0) e intervalo de integração (ex: [0, 1]).",
                                    "Discuta estabilidade: explícito requer h << 1/1000, implícito é incondicionalmente estável.",
                                    "Calcule analiticamente a solução exata aproximada para referência (y(t) ≈ sin(t)/1001 - (1/1001)e^{-1000t})."
                                  ],
                                  "verification": "Escreva um relatório resumindo definição, análise e solução exata; compare com plots qualitativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou Jupyter Notebook",
                                    "Referências: livros de análise numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Visualize escalas: plote sin(t) e e^{-1000t} separadamente para entender rigidez.",
                                  "learningObjective": "Identificar características de problemas stiff e motivar uso de métodos implícitos.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade",
                                    "Ignorar solução exata para benchmark"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar o Método de Euler Explícito",
                                  "subSteps": [
                                    "Implemente o esquema: y_{n+1} = y_n + h (-1000 y_n + sin(t_n)).",
                                    "Teste com h = 0.01: observe oscilações ou instabilidade.",
                                    "Reduza h para 0.0005 (adequado): compare com solução exata.",
                                    "Gere gráficos de y_n vs t e erro vs h.",
                                    "Registre número de passos necessários para estabilidade."
                                  ],
                                  "verification": "Plots mostram instabilidade para h grande e convergência lenta; erro < 0.01 para h pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy, Matplotlib e SciPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use loop simples primeiro, vetorize depois para eficiência; fixe seed para reprodutibilidade.",
                                  "learningObjective": "Demonstrar restrição de passo h < 2/|λ| no método explícito.",
                                  "commonMistakes": [
                                    "Usar h fixo grande sem testar",
                                    "Erro no cálculo de sin(t_n)",
                                    "Não plotar solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar o Método de Euler Implícito",
                                  "subSteps": [
                                    "Formule o esquema: y_{n+1} = y_n + h (-1000 y_{n+1} + sin(t_{n+1})).",
                                    "Resolva a equação linear: y_{n+1} (1 + 1000 h) = y_n + h sin(t_{n+1}).",
                                    "Implemente com h = 0.01 (livre de restrição) e compare com explícito.",
                                    "Gere gráficos e erros; teste h maior (ex: 0.1).",
                                    "Meça tempo de computação vs explícito."
                                  ],
                                  "verification": "Solução estável e precisa para h grande; erro similar ao explícito com h pequeno, mas com menos passos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy, Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Evite fsolve para linear simples; resolva analiticamente a equação escalar.",
                                  "learningObjective": "Aplicar método implícito para superar rigidez sem reduzir h excessivamente.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar t_{n+1}",
                                    "Não linearizar corretamente",
                                    "Confundir índices de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar métodos e analisar resultados",
                                  "subSteps": [
                                    "Compare estabilidade, precisão, custo computacional (passos e tempo).",
                                    "Plote soluções lado a lado: explícito (h pequeno), implícito (h grande), exata.",
                                    "Calcule ordem de convergência (erro vs h em log-log).",
                                    "Discuta vantagens do implícito para stiff problems.",
                                    "Escreva conclusões e sugestões para problemas reais."
                                  ],
                                  "verification": "Relatório com tabelas/plots mostrando superioridade do implícito; ordem ~1 para ambos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Ferramentas de plotagem avançada (ex: Matplotlib subplots)"
                                  ],
                                  "tips": "Use tabela Markdown no notebook para resumir h, passos, erro máximo.",
                                  "learningObjective": "Interpretar numericamente a análise de estabilidade A-stability.",
                                  "commonMistakes": [
                                    "Ignorar custo implícito (iterações em não-lineares)",
                                    "Não normalizar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000y + sin(t), y(0)=0 em [0,π], usando Euler explícito com h=0.001 (estável) vs h=0.01 (instável), e implícito com h=0.01 (estável e preciso). Plote soluções e erros.",
                              "finalVerifications": [
                                "Gráficos do explícito mostram oscilações para h=0.01 e estabilidade só com h<<0.001.",
                                "Implícito permanece estável e preciso para h até 0.1.",
                                "Erro máximo <1e-3 para implícito com h=0.01 vs exata.",
                                "Número de passos implícito é 10-100x menor que explícito estável.",
                                "Análise confirma A-estabilidade do implícito.",
                                "Relatório discute trade-offs computacionais."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de ambos esquemas sem erros algébricos.",
                                "Demonstração clara da restrição de passo no explícito via plots.",
                                "Precisão comparada à solução exata (erro global O(h)).",
                                "Análise qualitativa/quantitativa de estabilidade e custo.",
                                "Código limpo, comentado e reproduzível.",
                                "Conclusões alinhadas à teoria de stiff problems."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: implementação numérica em Python/NumPy.",
                                "Física: modelagem de sistemas dissipativos rígidos (ex: amortecedores).",
                                "Engenharia Química: simulações de reações stiff.",
                                "Cálculo Diferencial: análise qualitativa de EDOs lineares."
                              ],
                              "realWorldApplication": "Em simulações de circuitos RC/RL stiff, reações químicas rápidas/lentas (ex: combustão), controle de sistemas dinâmicos industriais, onde métodos explícitos falham economicamente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Método de Heun (Runge-Kutta de Ordem 2)",
                    "description": "Método de segunda ordem que usa preditor-corretor para melhorar a precisão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Introdução ao Método de Heun como Runge-Kutta de Ordem 2",
                        "description": "Apresentação do método de Heun como um esquema preditor-corretor de segunda ordem para solução numérica de problemas de valor inicial (PVI), melhorando a precisão em relação ao método de Euler.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Definir o problema de valor inicial e o papel dos métodos de passo simples",
                            "description": "Explicar o PVI y' = f(t,y), y(t0)=y0 e como métodos de passo simples, como Heun, aproximam a solução em um passo h sem subpassos internos explícitos além do preditor-corretor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal do Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Leia e memorize a equação diferencial ordinária de primeira ordem: y' = f(t, y), onde f é uma função contínua e Lipschitziana em y.",
                                    "Identifique a condição inicial: y(t₀) = y₀, que especifica o valor da solução no ponto inicial t₀.",
                                    "Escreva a forma geral do PVI: dado t₀, y₀ e f, encontrar y(t) que satisfaça ambas as condições no intervalo desejado.",
                                    "Diferencie PVI de problemas de fronteira ou multipontos."
                                  ],
                                  "verification": "Escreva a definição completa do PVI em suas próprias palavras e forneça um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Caneta",
                                    "Livro-texto de Equações Diferenciais ou Análise Numérica"
                                  ],
                                  "tips": "Use notação matemática padrão (y' em vez de dy/dt) para clareza.",
                                  "learningObjective": "Definir precisamente o Problema de Valor Inicial e seus componentes essenciais.",
                                  "commonMistakes": "Confundir y' = f(t,y) com equações de segunda ordem ou omitir a condição inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar limitações das soluções analíticas para PVIs",
                                  "subSteps": [
                                    "Discuta casos onde soluções exatas são impossíveis: funções f não lineares ou não elementares.",
                                    "Explique o Teorema de Existência e Unicidade de Picard-Lindelöf para condições de solução única.",
                                    "Reconheça que, mesmo com existência, integração analítica pode ser impraticável (ex: y' = y²).",
                                    "Compare com problemas lineares solucionáveis analiticamente.",
                                    "Liste razões para métodos numéricos: precisão controlada, aplicações computacionais."
                                  ],
                                  "verification": "Liste 3 exemplos de PVIs sem solução analítica fechada e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para esboços",
                                    "Exemplos de livros ou notas de aula"
                                  ],
                                  "tips": "Pense em aplicações reais para motivar a necessidade numérica.",
                                  "learningObjective": "Explicar por que métodos numéricos são necessários para a maioria dos PVIs práticos.",
                                  "commonMistakes": "Acreditar que todos os PVIs têm soluções analíticas simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir os métodos numéricos de passo simples",
                                  "subSteps": [
                                    "Defina métodos de passo simples: aproximam y(t_{n+1}) a partir de y(t_n) usando um passo h fixo.",
                                    "Descreva a ideia geral: y_{n+1} = y_n + h * k, onde k aproxima y'(t_n, y_n).",
                                    "Diferencie de métodos multipasso (usam valores anteriores).",
                                    "Mencione exemplos iniciais: Método de Euler (ordem 1).",
                                    "Explique avanço: de t_n para t_{n+1} = t_n + h."
                                  ],
                                  "verification": "Desenhe o diagrama de fluxo de um método de passo simples genérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Software de desenho opcional como GeoGebra"
                                  ],
                                  "tips": "Visualize no plano t-y para entender a aproximação local.",
                                  "learningObjective": "Compreender o conceito fundamental de métodos de um passo único.",
                                  "commonMistakes": "Confundir passo simples com métodos implícitos ou adaptativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o papel dos métodos de passo simples como o de Heun",
                                  "subSteps": [
                                    "Descreva o Método de Heun (RK2): preditor y* = y_n + h f(t_n, y_n), corretor y_{n+1} = y_n + (h/2)(f(t_n,y_n) + f(t_{n+1}, y*)).",
                                    "Enfatize ausência de subpassos internos explícitos além do preditor-corretor (dois estágios).",
                                    "Compare com Euler: Heun melhora precisão local (erro O(h^3)).",
                                    "Discuta aplicação iterativa para toda a malha t_0, t_1, ..., T.",
                                    "Relacione ao contexto: aproximação sem resolver PVIs internos."
                                  ],
                                  "verification": "Escreva a fórmula do Heun e compute um passo manual para um PVI dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel para cálculos",
                                    "Exemplos impressos"
                                  ],
                                  "tips": "Comece com h pequeno para ver convergência.",
                                  "learningObjective": "Articular o papel dos métodos de passo simples na aproximação de soluções de PVIs.",
                                  "commonMistakes": "Interpretar preditor-corretor como método multipasso ou ignorar o fator 1/2 no Heun."
                                }
                              ],
                              "practicalExample": "Para o PVI y' = y(1 - t), y(0) = 1, use o Método de Heun com h = 0.2 para aproximar y(0.2). Preditor: y* = 1 + 0.2*1*(1-0) = 1.2. Corretor: y(0.2) = 1 + (0.2/2)(1*(1-0) + 1.2*(1-0.2)) ≈ 1 + 0.1*(1 + 0.96) = 1.196.",
                              "finalVerifications": [
                                "Escreve corretamente a forma geral do PVI y' = f(t,y), y(t0)=y0.",
                                "Explica pelo menos duas limitações das soluções analíticas.",
                                "Define métodos de passo simples e dá um exemplo como Heun.",
                                "Descreve o processo preditor-corretor do Heun sem erros.",
                                "Computa manualmente um passo do Heun para um PVI simples.",
                                "Diferencia métodos de passo simples de multipasso."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição do PVI (30%)",
                                "Compreensão das limitações analíticas e motivação numérica (20%)",
                                "Clareza na descrição de métodos de passo simples (20%)",
                                "Correção na explicação do Heun e preditor-corretor (20%)",
                                "Habilidade em aplicar conceitualmente a um exemplo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de movimento e decaimento radioativo via EDOs.",
                                "Programação: Implementação de solvers numéricos em Python (SciPy).",
                                "Engenharia: Simulações de circuitos RC e sistemas dinâmicos.",
                                "Biologia: Modelos de crescimento populacional (equação logística)."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, métodos de passo simples como Heun são usados para simular trajetórias de foguetes aproximando equações diferenciais de movimento, permitindo previsões rápidas em softwares de controle de voo sem soluções analíticas exatas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Comparar método de Heun com método de Euler",
                            "description": "Identificar que Heun é uma melhoria do Euler modificado, usando preditor para estimativa e corretor para refinamento, alcançando ordem 2 de precisão com erro local O(h^3).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Explícito",
                                  "subSteps": [
                                    "Escreva a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Identifique que é um método de ordem 1 com erro local de truncamento O(h^2).",
                                    "Discuta limitações: instabilidade para h grande e baixa precisão.",
                                    "Aplique a um exemplo simples: y' = y, y(0)=1, h=0.1.",
                                    "Calcule os primeiros passos manualmente."
                                  ],
                                  "verification": "Derive corretamente a fórmula e calcule 3 iterações sem erros aritméticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Folha com fórmula do PVI"
                                  ],
                                  "tips": "Desenhe o plano de fase para visualizar o passo tangencial aproximado.",
                                  "learningObjective": "Compreender a base do método de Euler e suas limitações fundamentais.",
                                  "commonMistakes": [
                                    "Confundir com Euler implícito",
                                    "Esquecer o fator h na atualização",
                                    "Ignorar dependência em h para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método de Heun (Runge-Kutta de Ordem 2)",
                                  "subSteps": [
                                    "Descreva o preditor: k1 = f(t_n, y_n), y_pred = y_n + h k1.",
                                    "Descreva o corretor: k2 = f(t_{n+1}, y_pred), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Explique como é uma melhoria do Euler modificado via preditor-corretor.",
                                    "Note que alcança ordem 2 com erro local O(h^3).",
                                    "Compare visualmente: Heun usa média de inclinações inicial e final."
                                  ],
                                  "verification": "Escreva as fórmulas completas de preditor e corretor e identifique k1 e k2 corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico de exemplo de PVI",
                                    "Tabela comparativa vazia"
                                  ],
                                  "tips": "Pense no preditor como um 'chute' Euler e corretor como refinamento trapezoidal.",
                                  "learningObjective": "Dominar a estrutura preditor-corretor do método de Heun.",
                                  "commonMistakes": [
                                    "Usar Euler no corretor",
                                    "Média errada (não (k1+k2)/2)",
                                    "Confundir t_{n+1} com t_n no k2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Fórmulas e Estruturas Matemáticas",
                                  "subSteps": [
                                    "Alinhe fórmulas lado a lado: Euler vs. Heun.",
                                    "Identifique semelhanças: ambos explícitos, passo simples.",
                                    "Destaque diferenças: Euler usa 1 avaliação de f, Heun usa 2; precisão ordem 1 vs. 2.",
                                    "Analise erro local: derive qualitativamente O(h^2) para Euler e O(h^3) para Heun.",
                                    "Discuta custo computacional: Heun ~2x Euler."
                                  ],
                                  "verification": "Crie uma tabela comparativa com colunas para fórmula, ordem, avaliações de f e erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para tabela",
                                    "Livro de análise numérica (opcional)",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Use expansão de Taylor para justificar ordens de precisão intuitivamente.",
                                  "learningObjective": "Comparar rigorosamente as estruturas algébricas e de precisão.",
                                  "commonMistakes": [
                                    "Atribuir ordem errada ao Heun",
                                    "Ignorar custo extra de Heun",
                                    "Confundir erro global com local"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Precisão via Exemplo Numérico e Erro",
                                  "subSteps": [
                                    "Escolha PVI: y' = -2y, y(0)=1 (exata y=e^{-2t}).",
                                    "Compute 2 passos com h=0.5 para Euler e Heun.",
                                    "Calcule erros absolutos em cada nó.",
                                    "Compare convergência reduzindo h pela metade.",
                                    "Grafique soluções aproximadas vs. exata."
                                  ],
                                  "verification": "Mostre que erro de Heun é ~4x menor que Euler para mesmo h, confirmando ordem 2.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB",
                                    "Papel milimetrado para gráfico",
                                    "Tabela de erros"
                                  ],
                                  "tips": "Automatize com código simples se possível para múltiplos h.",
                                  "learningObjective": "Validar superioridade de Heun empiricamente através de análise de erro.",
                                  "commonMistakes": [
                                    "Erro na solução exata",
                                    "Cálculo aritmético incorreto",
                                    "Não normalizar erros por h"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, h=0.5 até t=1: Euler dá y(1)≈0.1353 (erro 0.383), Heun dá y(1)≈0.445 (erro 0.073), mostrando precisão superior de Heun.",
                              "finalVerifications": [
                                "Explicar corretamente preditor-corretor do Heun.",
                                "Derivar qualitativamente ordens de precisão (1 vs. 2).",
                                "Identificar erro local O(h^3) para Heun.",
                                "Comparar custo-benefício: Heun mais preciso por avaliação de f.",
                                "Aplicar numericamente e quantificar redução de erro.",
                                "Discutir cenários onde Euler falha mas Heun succeeds."
                              ],
                              "assessmentCriteria": [
                                "Correção das fórmulas de ambos métodos (100%).",
                                "Análise precisa de ordens e erros (ordem 1/2, O(h^2)/O(h^3)).",
                                "Tabela comparativa completa e precisa.",
                                "Cálculos numéricos sem erros aritméticos.",
                                "Interpretação qualitativa e quantitativa de superioridade do Heun.",
                                "Identificação de limitações de cada método."
                              ],
                              "crossCurrularConnections": [
                                "Programação: Implementar ambos em Python para simulações.",
                                "Física: Modelar decaimento radioativo ou circuitos RC.",
                                "Engenharia: Simulações dinâmicas em controle de sistemas.",
                                "Estatística: Análise de erros numéricos em modelagem probabilística."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA usa RK2 como Heun para órbitas iniciais), previsão de epidemias (melhor precisão em propagação com custo baixo) e modelagem financeira (previsão de taxas de juros com ODEs)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Reconhecer Heun como Runge-Kutta de ordem 2",
                            "description": "Classificar o método de Heun no tableau de Butcher como RK2 com coeficientes k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), e y_{n+1} = y_n + (h/2)(k1 + k2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos do método Runge-Kutta de ordem 2 (RK2)",
                                  "subSteps": [
                                    "Lembre-se da forma geral de um método RK de ordem s: y_{n+1} = y_n + h ∑_{i=1}^s b_i k_i, onde k_i = f(t_n + c_i h, y_n + h ∑_{j=1}^{i-1} a_{ij} k_j).",
                                    "Para RK2 (s=2), identifique os coeficientes: dois estágios com c1=0, c2=1 tipicamente para métodos explícitos.",
                                    "Estude o tableau de Butcher: matriz A (2x2), vetor c (2x1), vetor b (2x1).",
                                    "Confirme que métodos RK2 têm ordem exatamente 2, satisfazendo condições de ordem até 2.",
                                    "Anote exemplos clássicos de RK2, como o método de ponto médio."
                                  ],
                                  "verification": "Escreva o tableau genérico de RK2 e liste as condições de ordem p=2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Livro ou notas de Análise Numérica",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Desenhe o tableau de Butcher em uma tabela para visualização clara.",
                                  "learningObjective": "Compreender a estrutura geral de RK2 e seu tableau de Butcher.",
                                  "commonMistakes": [
                                    "Confundir ordem 2 com ordem 1 (Euler)",
                                    "Esquecer que RK2 requer dois estágios",
                                    "Ignorar as condições de consistência e ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a fórmula explícita do método de Heun",
                                  "subSteps": [
                                    "Escreva a fórmula de Heun: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Identifique os estágios: primeiro estágio em (t_n, y_n), segundo em (t_n + h, y_n + h k1).",
                                    "Compare com a forma geral RK: mapear k1 ao primeiro estágio (c1=0, a11=0), k2 ao segundo (c2=1, a21=1).",
                                    "Calcule os pesos: b1 = 1/2, b2 = 1/2.",
                                    "Verifique se é explícito (a_{ij}=0 para j>=i)."
                                  ],
                                  "verification": "Reescreva a fórmula de Heun na notação RK geral e identifique todos os coeficientes b_i, c_i, a_{ij}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para anotações",
                                    "Exemplo de PVI simples como y' = y, y(0)=1"
                                  ],
                                  "tips": "Substitua os k_i na fórmula geral para ver a correspondência exata.",
                                  "learningObjective": "Mapear os coeficientes do método de Heun para a forma padrão RK.",
                                  "commonMistakes": [
                                    "Confundir k2 com predictor-corrector em vez de RK",
                                    "Erro no peso: usar h(k1 + k2) em vez de (h/2)",
                                    "Pensar que c2 = 1/2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e interpretar o tableau de Butcher para Heun",
                                  "subSteps": [
                                    "Desenhe o tableau: c | A ; b, com c = [0, 1]^T, A = [[0,0], [1,0]], b = [1/2, 1/2].",
                                    "Valide as condições de ordem 2: ∑ b_i =1, ∑ b_i c_i = 1/2, ∑ b_i ∑ a_{ij} c_j = 1/2.",
                                    "Compare com outros RK2, como Ralston ou ponto médio, destacando diferenças em A.",
                                    "Confirme que é RK2 verificando truncamento local de ordem 3.",
                                    "Classifique como método de Heun (ou melhorado de Euler) como caso específico de RK2."
                                  ],
                                  "verification": "Monte o tableau completo e verifique numericamente as condições de ordem para um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para tableau",
                                    "Software como Python/MATLAB para verificação opcional"
                                  ],
                                  "tips": "Use tabelas LaTeX ou desenhos para praticar o formato padrão do tableau.",
                                  "learningObjective": "Construir o tableau de Butcher do método de Heun e validá-lo como RK2.",
                                  "commonMistakes": [
                                    "Erro em a21=1 em vez de 0",
                                    "b = [1,0] confundindo com Euler",
                                    "c2=h em vez de 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e confirmar a classificação em um exemplo prático",
                                  "subSteps": [
                                    "Escolha um PVI: y' = -y, y(0)=1, h=0.1, compute y1 com Heun.",
                                    "Calcule k1, k2 passo a passo e y1.",
                                    "Compare com solução exata e erro para confirmar ordem 2 (erro O(h^2)).",
                                    "Classifique formalmente: 'Heun é RK2 com tableau específico'.",
                                    "Discuta por que Heun é preferido sobre Euler modificado em alguns contextos."
                                  ],
                                  "verification": "Resolva o exemplo e afirme corretamente 'Heun é RK2'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Gráfico de solução exata vs numérica"
                                  ],
                                  "tips": "Use h pequeno para ver precisão de ordem 2 vs ordem 1.",
                                  "learningObjective": "Reconhecer Heun como RK2 através de aplicação numérica.",
                                  "commonMistakes": [
                                    "Calcular k2 errado como f(t_n + h/2, ...)",
                                    "Não normalizar pesos b_i",
                                    "Classificar como ordem 1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y(1 - y), y(0)=0.5 (modelo logístico), h=0.1: k1 = f(0,0.5)=0.5*0.5=0.25; k2=f(0.1,0.5+0.1*0.25)=f(0.1,0.525)≈0.525*0.475≈0.249; y1=0.5 + 0.1/2*(0.25+0.249)≈0.5124. Tableau confirma RK2.",
                              "finalVerifications": [
                                "Pode escrever corretamente k1, k2 e y_{n+1} para Heun?",
                                "Constrói o tableau de Butcher exato para Heun?",
                                "Verifica as condições de ordem p=2?",
                                "Distingue Heun de Euler e de RK4?",
                                "Aplica Heun a um PVI simples e classifica como RK2?",
                                "Explica por que Heun tem ordem 2?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos coeficientes a_{ij}, b_i, c_i (100% correto).",
                                "Capacidade de desenhar tableau sem erros.",
                                "Verificação correta das condições de ordem (pelo menos 3 condições).",
                                "Exemplo numérico resolvido com cálculos exatos.",
                                "Explicação clara da classificação como RK2.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de movimento (e.g., osciladores com RK2).",
                                "Programação: Implementação em Python/NumPy para solvers ODE.",
                                "Engenharia: Modelagem diferencial em controle de sistemas.",
                                "Estatística: Análise de erro numérico em simulações estocásticas."
                              ],
                              "realWorldApplication": "O método de Heun (RK2) é usado em simulações numéricas para previsão meteorológica, dinâmica de fluidos (CFD) e modelagem biológica populacional, onde precisão O(h^2) equilibra custo computacional e acurácia em softwares como MATLAB ODE solvers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Algoritmo Preditor-Corrretor do Método de Heun",
                        "description": "Descrição passo a passo da implementação do método, destacando as etapas de predição e correção para calcular a aproximação no próximo ponto.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Implementar a etapa preditora",
                            "description": "Calcular o preditor y* = y_n + h f(t_n, y_n), equivalente a um passo de Euler explícito para estimar y_{n+1}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados de entrada e ambiente de implementação",
                                  "subSteps": [
                                    "Identifique os valores iniciais: t_n, y_n, h e a função f(t, y).",
                                    "Escolha a linguagem de programação (ex: Python) ou ferramenta de cálculo (ex: MATLAB).",
                                    "Defina variáveis para armazenar t_n, y_n e h.",
                                    "Implemente ou carregue a definição da equação diferencial f(t, y).",
                                    "Teste a leitura dos valores iniciais com um print ou display."
                                  ],
                                  "verification": "Execute o código e confirme que t_n, y_n, h e f estão corretamente inicializados e exibidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (Python/Jupyter Notebook), calculadora para validação manual.",
                                  "tips": "Use nomes de variáveis descritivos como 't_current', 'y_current', 'step_size' para clareza.",
                                  "learningObjective": "Compreender e configurar corretamente os parâmetros do método numérico.",
                                  "commonMistakes": "Confundir h com outros parâmetros; não definir f corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o valor da derivada f(t_n, y_n)",
                                  "subSteps": [
                                    "Chame a função f com os argumentos t_n e y_n.",
                                    "Armazene o resultado em uma variável como 'f_tn_yn'.",
                                    "Valide o cálculo manualmente para um exemplo simples.",
                                    "Inclua tratamento de erros caso f retorne NaN ou inf.",
                                    "Exiba o valor de f_tn_yn para inspeção."
                                  ],
                                  "verification": "Compare o valor computado de f(t_n, y_n) com cálculo manual; deve coincidir dentro de precisão numérica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código fonte, documentação da função f (ex: equação y' = -y + t).",
                                  "tips": "Para funções complexas, quebre f em subexpressões para depuração.",
                                  "learningObjective": "Avaliar corretamente a derivada no ponto atual usando a função definida.",
                                  "commonMistakes": "Passar argumentos errados para f (ex: inverter t e y); ignorar dependência de t."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o preditor y* = y_n + h * f(t_n, y_n)",
                                  "subSteps": [
                                    "Multiplique h por f_tn_yn e armazene em uma variável intermediária.",
                                    "Some o resultado a y_n para obter y_star.",
                                    "Arredonde ou formate y* conforme precisão necessária (ex: 6 casas decimais).",
                                    "Exiba y* e compare com expectativa teórica.",
                                    "Salve y* para uso na etapa corretora."
                                  ],
                                  "verification": "Verifique se y* = y_n + h * f(t_n, y_n) holds numericamente (diferença < 1e-10).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código anterior, calculadora para verificação cruzada.",
                                  "tips": "Use precisão de ponto flutuante dupla (float64) para evitar erros de arredondamento.",
                                  "learningObjective": "Aplicar a fórmula do preditor de forma precisa e eficiente.",
                                  "commonMistakes": "Erro aritmético simples como multiplicar ao invés de somar; esquecer o sinal de h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e integrar a etapa preditora no algoritmo completo",
                                  "subSteps": [
                                    "Execute um ciclo completo com valores conhecidos.",
                                    "Compare y* com solução analítica aproximada.",
                                    "Adicione logging para rastrear valores em cada iteração.",
                                    "Teste com diferentes h para observar estabilidade.",
                                    "Documente o código com comentários explicando o preditor."
                                  ],
                                  "verification": "O preditor produz y* consistente em múltiplos testes; erro relativo < 1%.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Solução analítica de referência, conjunto de testes unitários.",
                                  "tips": "Integre com pytest ou asserts para automação de testes.",
                                  "learningObjective": "Garantir robustez e integração da etapa preditora no método Heun.",
                                  "commonMistakes": "Não testar com h pequeno/grande; pular validação numérica."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, t_n=0, h=0.1: f(0,1)=1, y* = 1 + 0.1*1 = 1.1. Em Python: def f(t,y): return y; y_star = y_n + h * f(t_n, y_n).",
                              "finalVerifications": [
                                "y* coincide com cálculo manual para pelo menos 3 exemplos diferentes.",
                                "Código executa sem erros para h variando de 0.01 a 0.5.",
                                "Erro relativo entre y* e solução exata < 0.1%.",
                                "f(t_n, y_n) é computado corretamente para funções lineares e não-lineares.",
                                "Variáveis são atualizadas corretamente para próxima iteração.",
                                "Código é legível com comentários adequados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica do cálculo de y* (erro < 1e-12).",
                                "Corretude da implementação de f(t,y).",
                                "Eficiência computacional (tempo de execução < 1s para 100 passos).",
                                "Robustez a entradas inválidas (ex: h=0).",
                                "Clareza e documentação do código.",
                                "Validação cruzada com método Euler explícito."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de funções e controle de fluxo.",
                                "Física: Modelagem de movimento (ex: leis de Newton).",
                                "Engenharia: Simulações dinâmicas em controle de sistemas.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Usado em simulações de trajetórias de foguetes (NASA), previsão meteorológica (modelos diferenciais) e farmacocinética (concentração de drogas no sangue), onde estimativas iniciais rápidas aceleram soluções precisas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Implementar a etapa corretora",
                            "description": "Usar o preditor para calcular k2 = f(t_{n+1}, y*) e então y_{n+1} = y_n + (h/2)(f(t_n, y_n) + k2), refinando a aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados de entrada para a correção",
                                  "subSteps": [
                                    "Identifique os valores conhecidos: t_n, y_n, h e y* (resultado do preditor).",
                                    "Confirme a função f(t, y) do problema de valor inicial.",
                                    "Defina t_{n+1} = t_n + h.",
                                    "Registre todos os valores em uma tabela ou estrutura de dados para rastreamento.",
                                    "Verifique unidades e precisão numérica inicial (ex: casas decimais)."
                                  ],
                                  "verification": "Lista de entrada completa e valores iniciais corretos comparados com o preditor.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou editor de código (Python/MATLAB), calculadora.",
                                  "tips": "Use variáveis descritivas como 'tn', 'yn', 'h', 'ystar' para evitar confusão.",
                                  "learningObjective": "Garantir que todos os insumos necessários estejam disponíveis e corretos antes do cálculo.",
                                  "commonMistakes": "Esquecer de calcular t_{n+1} ou usar y_n em vez de y*."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular k1 = f(t_n, y_n)",
                                  "subSteps": [
                                    "Substitua t_n e y_n na função f(t, y).",
                                    "Realize os cálculos aritméticos passo a passo.",
                                    "Registre o valor de k1 com precisão adequada (ex: 4 casas decimais).",
                                    "Compare com cálculo manual se possível para validação inicial.",
                                    "Armazene k1 para uso posterior."
                                  ],
                                  "verification": "k1 equals f(t_n, y_n) avaliado numericamente.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Calculadora ou interpretador de código.",
                                  "tips": "Mantenha consistência na precisão para evitar erros de arredondamento propagados.",
                                  "learningObjective": "Dominar a avaliação da derivada no ponto inicial.",
                                  "commonMistakes": "Confundir k1 com k2 ou usar y* prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular k2 = f(t_{n+1}, y*)",
                                  "subSteps": [
                                    "Substitua t_{n+1} e y* (preditor) na função f(t, y).",
                                    "Execute os cálculos com atenção aos parênteses e operações.",
                                    "Registre k2 com a mesma precisão de k1.",
                                    "Valide se y* foi usado corretamente do passo preditor.",
                                    "Compare k1 e k2 para observar a correção."
                                  ],
                                  "verification": "k2 equals f(t_{n+1}, y*) sem discrepâncias.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Calculadora ou código.",
                                  "tips": "Lembre-se: y* é a aproximação do preditor, não o valor exato.",
                                  "learningObjective": "Aplicar a função f no ponto predito para refinar a inclinação.",
                                  "commonMistakes": "Usar y_n em vez de y* ou t_n em vez de t_{n+1}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular y_{n+1} = y_n + (h/2)(k1 + k2)",
                                  "subSteps": [
                                    "Calcule a soma k1 + k2.",
                                    "Multiplique por (h/2).",
                                    "Some o resultado a y_n.",
                                    "Arredonde conforme precisão do problema.",
                                    "Atualize os índices para o próximo passo (t_{n+1}, y_{n+1})."
                                  ],
                                  "verification": "y_{n+1} matches a fórmula aplicada corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora ou código para execução.",
                                  "tips": "Implemente em loop se for múltiplos passos, mas foque em um.",
                                  "learningObjective": "Combinar preditor e corretor para média ponderada das inclinações.",
                                  "commonMistakes": "Esquecer o fator 1/2 ou inverter k1 e k2."
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, h=0.2: t0=0, y0=1, y*=0.6 (preditor Euler). k1=f(0,1)=-2, k2=f(0.2,0.6)=-1.2, y1=1 + (0.2/2)(-2 + -1.2)=1 + 0.1*(-3.2)=0.68.",
                              "finalVerifications": [
                                "k2 = f(t_{n+1}, y*) calculado corretamente.",
                                "k1 = f(t_n, y_n) confirmado.",
                                "Fórmula y_{n+1} aplicada sem erros aritméticos.",
                                "Resultado y_{n+1} converge para solução exata (ex: erro < 1%).",
                                "Valores atualizados prontos para próximo passo.",
                                "Sem discrepâncias com implementação em código."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 0.01).",
                                "Correta distinção entre preditor y* e valores originais.",
                                "Aplicação exata da fórmula do método de Heun.",
                                "Documentação clara dos passos intermediários.",
                                "Eficiência no tempo estimado.",
                                "Validação cruzada com solução analítica."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para automação.",
                                "Física: Modelagem de decaimento exponencial em cinemática.",
                                "Engenharia: Simulações numéricas em controle de sistemas.",
                                "Estatística: Análise de erro em aproximações numéricas."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de mísseis ou previsão de epidemias, onde o método preditor-corretor refina soluções de EDOs para precisão em tempo real sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Escrever pseudocódigo completo do método",
                            "description": "Construir um algoritmo iterativo que avance de t_n para t_{n+1} aplicando preditor e corretor, incluindo condições de parada por tolerância ou número de passos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir variáveis de inicialização e parâmetros do método",
                                  "subSteps": [
                                    "Identifique as entradas necessárias: função f(t,y), t0 inicial, y0 inicial, passo h, tolerância tol, número máximo de iterações max_iter e número máximo de passos N_max.",
                                    "Defina variáveis auxiliares: t_n = t0, y_n = y0, contador de passos n = 0.",
                                    "Especifique a condição de parada global: enquanto n < N_max e |t_final - t_n| > tol.",
                                    "Anote a estrutura geral do algoritmo como um loop principal iterativo.",
                                    "Verifique a notação matemática para preditor e corretor: preditor k1 = f(t_n, y_n), y_p = y_n + h * k1."
                                  ],
                                  "verification": "Lista de variáveis declaradas corretamente e estrutura do loop principal esboçada sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência do Método de Heun (fórmulas preditor-corrutor)",
                                    "Exemplo de EDO simples"
                                  ],
                                  "tips": "Use notação consistente para índices (ex: t_n, y_n) para evitar confusão.",
                                  "learningObjective": "Compreender e declarar todas as variáveis essenciais para o algoritmo preditor-corretor.",
                                  "commonMistakes": "Esquecer tolerância ou max_iter; confundir h com tolerância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o preditor no pseudocódigo",
                                  "subSteps": [
                                    "No início de cada iteração do loop principal, compute o preditor: k1 = f(t_n, y_n), y_pred = y_n + h * k1.",
                                    "Atualize t_{n+1} = t_n + h.",
                                    "Escreva a linha pseudocódigo: PREDITOR: y_pred ← y_n + h * f(t_n, y_n).",
                                    "Teste mentalmente com um valor simples para validar.",
                                    "Integre ao loop: após inicialização, insira o preditor antes do corretor."
                                  ],
                                  "verification": "Pseudocódigo do preditor executa corretamente em simulação manual com valores numéricos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para cálculos manuais",
                                    "Calculadora",
                                    "Fórmula exata do Método de Heun"
                                  ],
                                  "tips": "Sempre compute k1 primeiro para clareza, evitando fórmulas inline longas.",
                                  "learningObjective": "Codificar precisamente a etapa de predição no algoritmo de Heun.",
                                  "commonMistakes": "Usar y_{n+1} em vez de y_pred; esquecer de avançar t_n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo do corretor com verificação de convergência",
                                  "subSteps": [
                                    "Inicie contador de iterações i = 0 e y_corr = y_pred.",
                                    "Entre em loop while i < max_iter e |y_corr - y_prev| > tol: compute k2 = f(t_{n+1}, y_corr), y_new = y_n + (h/2)*(k1 + k2), y_prev = y_corr, y_corr = y_new, i ← i + 1.",
                                    "Após convergência, defina y_{n+1} = y_corr.",
                                    "Atualize n ← n + 1, t_n ← t_{n+1}, y_n ← y_{n+1}.",
                                    "Repita para próxima iteração global."
                                  ],
                                  "verification": "Simule 2-3 iterações internas e confirme convergência para um exemplo conhecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para traçar fluxograma do loop interno",
                                    "Exemplo numérico de EDO y' = y, y(0)=1"
                                  ],
                                  "tips": "Use variáveis temporárias como y_prev para comparar diferenças relativas ou absolutas.",
                                  "learningObjective": "Construir o mecanismo iterativo do corretor com critério de parada local.",
                                  "commonMistakes": "Loop infinito sem max_iter; erro na média (h/2 vs h); não resetar i por passo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar condições de parada finais e estrutura de saída",
                                  "subSteps": [
                                    "No loop principal, adicione condição: se |t_final - t_n| <= tol ou n >= N_max, saia.",
                                    "Inclua tratamento de não-convergência: imprimir aviso se i >= max_iter.",
                                    "Especifique saída: array ou lista de [t_n, y_n] para todos os passos.",
                                    "Revise todo o pseudocódigo por indentação e fluxo lógico.",
                                    "Teste completo com pseudocódigo em um exemplo para validar."
                                  ],
                                  "verification": "Pseudocódigo completo compila mentalmente sem loops infinitos ou erros lógicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplo completo de Heun resolvido manualmente"
                                  ],
                                  "tips": "Use pseudocódigo indentado como em linguagens reais (ex: Python) para legibilidade.",
                                  "learningObjective": "Finalizar o algoritmo com robustez, saídas e tratamento de erros.",
                                  "commonMistakes": "Parada apenas por N_max sem tolerância em t; esquecer saída dos valores."
                                }
                              ],
                              "practicalExample": "Para resolver y' = -2y, y(0)=1, h=0.1, tol=1e-6, max_iter=10, N_max=100 até t=1. Inicial: t0=0, y0=1. Passo 1: k1=f(0,1)=-2, y_pred=1+0.1*(-2)=0.8, t1=0.1. Iterar corretor: k2=f(0.1,0.8)=-1.6, y_new=1+0.05*(-2-1.6)=0.82, converge em poucas iterações para y1≈0.8187.",
                              "finalVerifications": [
                                "Pseudocódigo inclui inicialização completa de variáveis.",
                                "Preditor usa f(t_n, y_n) corretamente.",
                                "Loop corretor itera até tol ou max_iter com média (h/2)(k1+k2).",
                                "Condições de parada globais (tolerância em t ou N_max) estão presentes.",
                                "Saída armazena sequência de t_n e y_n.",
                                "Tratamento de falha de convergência é mencionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das fórmulas preditor e corretor (100% correto).",
                                "Completude: todos componentes (loops, condições, variáveis) presentes.",
                                "Clareza e legibilidade do pseudocódigo (indentação, comentários).",
                                "Robustez: tratamento de erros e paradas.",
                                "Validação via exemplo numérico simples.",
                                "Consistência na notação (índices n, p, etc.)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estrutura de loops e controle de fluxo em pseudocódigo.",
                                "Física: Aplicação em modelagem de sistemas dinâmicos (ex: decaimento).",
                                "Computação Científica: Implementação numérica em software como Python/Scilab.",
                                "Matemática Discreta: Análise de convergência e estabilidade."
                              ],
                              "realWorldApplication": "Simulações de trajetórias em engenharia aeroespacial (ex: órbitas via EDOs), previsão de epidemias (modelos SIR), ou dinâmica de fluidos em CFD, onde métodos preditor-corretor garantem precisão com custo computacional moderado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Análise de Precisão e Aplicação do Método de Heun",
                        "description": "Estudo do erro de truncamento local e global, ordem de convergência e aplicação prática em um exemplo numérico.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Derivar o erro local de truncamento",
                            "description": "Expandir em série de Taylor y(t_{n+1}) = y_n + h y' + (h^2/2) y'' + (h^3/6) y''' + O(h^4) e mostrar que o método de Heun cancela termos até O(h^3).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Expandir a solução exata y(t_{n+1}) em série de Taylor",
                                  "subSteps": [
                                    "Escreva y(t_{n+1}) = y(t_n + h) usando a fórmula de Taylor ao redor de t_n.",
                                    "Inclua termos até O(h^4): y(t_n) + h y'(t_n) + (h^2/2) y''(t_n) + (h^3/6) y'''(t_n) + O(h^4).",
                                    "Substitua y(t_n) por y_n, assumindo que y_n é exato em t_n.",
                                    "Identifique y' = f(t_n, y_n), mas mantenha derivadas superiores simbólicas por enquanto.",
                                    "Verifique a notação e os coeficientes binomiais."
                                  ],
                                  "verification": "Conferir se a expansão corresponde à fórmula padrão de Taylor e os termos estão corretos até h^3.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de cálculo ou análise numérica",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Use notação consistente com subscritos n para t_n e y_n.",
                                  "learningObjective": "Compreender a expansão de Taylor para soluções de EDOs como base para análise de erro.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/k! nos termos",
                                    "Confundir y(t_n + h) com aproximação numérica",
                                    "Ignorar O(h^4)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar derivadas superiores em termos de f e derivadas parciais",
                                  "subSteps": [
                                    "Defina y' = f(t, y).",
                                    "Derive y'' = df/dt + df/dy * y' = f_t + f_y f, onde f_t e f_y são parciais.",
                                    "Derive y''' = d(y'')/dt = derivadas de segunda ordem de f, expandindo produtos.",
                                    "Continue para y^{(4)} se necessário, mas foque até y''' para O(h^4).",
                                    "Escreva todas as expressões explicitamente em t_n, y_n."
                                  ],
                                  "verification": "Substitua em um exemplo simples como y'=y e verifique se y''=y, y'''=y, etc.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de derivadas parciais",
                                    "Software como Mathematica para verificação opcional"
                                  ],
                                  "tips": "Use a regra da cadeia sistematicamente e anote cada parcial claramente.",
                                  "learningObjective": "Dominar a diferenciação implícita para EDOs autônomas ou não.",
                                  "commonMistakes": [
                                    "Erro na regra da cadeia para f_y * f",
                                    "Confundir parciais f_t e f_y",
                                    "Parar em derivadas baixas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir k1 e k2 do método de Heun em séries de Taylor",
                                  "subSteps": [
                                    "Defina k1 = f(t_n, y_n).",
                                    "Expanda k2 = f(t_n + h, y_n + h k1) usando Taylor bivariado em duas variáveis.",
                                    "Para f(t_n + h, y_n + h k1) = f + h f_t + (h k1) f_y + (h^2/2) f_{tt} + h (h k1) f_{ty} + ((h k1)^2 / 2) f_{yy} + O(h^3).",
                                    "Substitua k1 nos termos e colete até O(h^2) já que Heun é ordem 2.",
                                    "Simplifique expressões algébricas."
                                  ],
                                  "verification": "Verificar que k1 = y', k2 ≈ y' + h y'' + O(h^2).",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Folha com fórmulas de Taylor multivariável",
                                    "Editor LaTeX para notação"
                                  ],
                                  "tips": "Expanda k1 primeiro nos termos de k2 e colete potências de h.",
                                  "learningObjective": "Aplicar Taylor multivariável a funções compostas em métodos numéricos.",
                                  "commonMistakes": [
                                    "Esquecer termos cruzados como f_{ty}",
                                    "Não expandir h k1 corretamente",
                                    "Erros em coeficientes quadráticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a aproximação Heun e comparar com a exata",
                                  "subSteps": [
                                    "Escreva y_{n+1}^{Heun} = y_n + (h/2) (k1 + k2).",
                                    "Substitua as expansões de k1 e k2 e multiplique por (h/2).",
                                    "Colete termos: h, h^2, h^3 e mostre cancelamento até h^2.",
                                    "Compare com y(t_{n+1}) exata: diferença é (h^3 / 6) (y''' - algo) + O(h^4).",
                                    "Conclua que erro local de truncamento é O(h^3)."
                                  ],
                                  "verification": "Os termos h e h^2 cancelam exatamente; primeiro não-cancelado é h^3.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Expansões dos steps anteriores",
                                    "Exemplo numérico para checagem"
                                  ],
                                  "tips": "Alinhe termos por potências de h em colunas para visualização.",
                                  "learningObjective": "Identificar por que Heun é ordem 2 (erro O(h^3)).",
                                  "commonMistakes": [
                                    "Erro aritmético em (h/2)(k1+k2)",
                                    "Não coletar termos corretamente",
                                    "Confundir ordem global vs local"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e generalizar o resultado",
                                  "subSteps": [
                                    "Reescreva o erro local explícito: τ = [y'''(ξ) - (1/2)(f_y k1 + ...)] h^3 / 6 ou similar.",
                                    "Teste com EDO linear simples y'=λy.",
                                    "Discuta implicações para ordem do método.",
                                    "Generalize para Runge-Kutta ordem 2.",
                                    "Documente a derivação completa."
                                  ],
                                  "verification": "No exemplo y'=y, erro O(h^3) confirmado numericamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software numérico como Python/Scipy para validação"
                                  ],
                                  "tips": "Use um caso teste para validar algebraicamente.",
                                  "learningObjective": "Conectar análise teórica com verificação prática.",
                                  "commonMistakes": [
                                    "Ignorar dependência em ξ",
                                    "Confundir erro local com global",
                                    "Não testar exemplo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, solução exata y(h)=e^h = 1 + h + h^2/2 + h^3/6 + O(h^4). k1 = y_n=1, k2 = f(h, 1 + h*1) = e^h * e^h = e^{2h} ≈ 1 + 2h + (4h^2)/2 + O(h^3). Então y_1 = 1 + (h/2)(1 + 1+2h+2h^2) = 1 + h + h^2 + O(h^3), erro h^3/3 + O(h^4), confirmando O(h^3).",
                              "finalVerifications": [
                                "Expansão de Taylor exata até O(h^4) para y(t_{n+1}).",
                                "k1 e k2 expandidos corretamente com termos cruzados.",
                                "Termos h e h^2 cancelam na fórmula Heun.",
                                "Erro local identificado como O(h^3).",
                                "Verificação numérica em exemplo simples coincide.",
                                "Generalização para ordem do método correta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor multivariável (k2).",
                                "Correta derivação de y'', y''' via parciais de f.",
                                "Coleta algébrica de termos por potências de h sem erros.",
                                "Identificação explícita do coeficiente de h^3 no erro.",
                                "Uso consistente de notação e verificação em exemplo.",
                                "Explicação clara do porquê Heun é ordem 2."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações dinâmicas (e.g., osciladores).",
                                "Computação: Implementação de solvers RK em Python/MATLAB.",
                                "Engenharia: Modelagem de circuitos RLC com EDOs não-lineares.",
                                "Estatística: Análise de erro em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA), previsão de epidemias (modelos SIR) ou finanças (equações de Black-Scholes), onde métodos como Heun equilibram precisão O(h^3) e custo computacional baixo para passos moderados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Calcular erro global e ordem de convergência",
                            "description": "Explicar que erro global é O(h^2) para N passos com h = (b-a)/N, e demonstrar numericamente reduzindo h pela metade para verificar duplicação do número de dígitos corretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de erro global e ordem de convergência",
                                  "subSteps": [
                                    "Defina erro global como a diferença entre a solução numérica e exata no ponto final t=b.",
                                    "Explique que h = (b-a)/N, onde N é o número de passos, e erro global é O(h^p) para ordem p.",
                                    "Discuta ordem de convergência: para método de ordem 2 como Heun, p=2, então halving h deve quadruplicar precisão (duplicar dígitos corretos).",
                                    "Escolha um PVI modelo: y' = y, y(0)=1, solução exata y(t)=e^t, intervalo [0,1].",
                                    "Calcule solução exata em t=1: e^1 ≈ 2.718281828."
                                  ],
                                  "verification": "Resuma definições em um parágrafo e anote valores exatos do exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica, calculadora ou Python/MATLAB para e^1.",
                                  "tips": "Use notação big-O corretamente: O(h^2) significa erro ≈ C h^2.",
                                  "learningObjective": "Compreender a relação entre tamanho de passo h e erro global para métodos de Runge-Kutta ordem 2.",
                                  "commonMistakes": "Confundir erro local (por passo) com global (acumulado); ignorar que N=1/h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Método de Heun para h inicial e calcular erro global",
                                  "subSteps": [
                                    "Escolha N=10, então h=(1-0)/10=0.1.",
                                    "Implemente Heun: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Calcule numericamente até t=1, obtenha y_num(1).",
                                    "Compute erro global: |y_exata(1) - y_num(1)|.",
                                    "Registre número de dígitos corretos: floor(-log10(erro))."
                                  ],
                                  "verification": "y_num(1) deve estar próximo de 2.71828; erro < 0.01 para h=0.1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel, Python (numpy, scipy) ou papel para cálculo manual.",
                                  "tips": "Automatize iterações em loop para evitar erros aritméticos manuais.",
                                  "learningObjective": "Aplicar Método de Heun para estimar solução numérica e quantificar erro inicial.",
                                  "commonMistakes": "Erro na fórmula de Heun (confundir com Euler); arredondamento precoce."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Refinar com h/2 e comparar erros globais",
                                  "subSteps": [
                                    "Aumente N=20, h=0.05.",
                                    "Repita implementação de Heun até t=1, obtenha y_num_fine(1).",
                                    "Calcule novo erro global: |y_exata(1) - y_num_fine(1)|.",
                                    "Compare erros: erro_h/2 deve ser ≈ (1/4) erro_h (para ordem 2).",
                                    "Conte dígitos corretos; deve duplicar aproximadamente."
                                  ],
                                  "verification": "Razão erros ≈ 4; dígitos corretos aumentam em ~1-2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo software do passo anterior; salve código para reutilizar.",
                                  "tips": "Use tabela: h | y_num | erro | dígitos.",
                                  "learningObjective": "Demonstrar empiricamente a redução quadrática do erro ao halvar h.",
                                  "commonMistakes": "Não usar mesma solução exata; erro em contagem de dígitos (use log10)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar ordem de convergência e validar O(h^2)",
                                  "subSteps": [
                                    "Calcule ordem p ≈ log(erro_h / erro_h/2) / log(2).",
                                    "Para mais precisão, teste h/4 (N=40) e refine p.",
                                    "Plote log(erro) vs log(h); inclinação ≈ -p = -2.",
                                    "Interprete: p≈2 confirma ordem 2 do Heun.",
                                    "Discuta limitações: para h muito pequeno, erros de arredondamento dominam."
                                  ],
                                  "verification": "p calculado entre 1.9 e 2.1; gráfico linear com slope -2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Matplotlib, Excel), papel log-log.",
                                  "tips": "log2 ≈ 0.3010 para cálculos manuais; use np.log em Python.",
                                  "learningObjective": "Quantificar ordem de convergência numericamente e relacionar à teoria.",
                                  "commonMistakes": "Fórmula errada de p (inverter logs); plot não log-log."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e generalizar",
                                  "subSteps": [
                                    "Resuma tabela de resultados: h, erro, p.",
                                    "Explique duplicação de dígitos: cada halving h adiciona ~log10(4)≈0.6 dígitos, mas ~1 na prática.",
                                    "Teste com outro PVI (ex: y'= -y, y(0)=1) para validar.",
                                    "Discuta erro global O(h^2) teórico vs numérico.",
                                    "Prepare relatório com conclusões."
                                  ],
                                  "verification": "Relatório explica O(h^2) com evidências numéricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documento Word ou Jupyter notebook.",
                                  "tips": "Inclua código fonte e plots no relatório.",
                                  "learningObjective": "Sintetizar análise para confirmar teoria de precisão do Método de Heun.",
                                  "commonMistakes": "Generalizar sem testar múltiplos h; ignorar efeitos de máquina."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 em [0,1]:\n- h=0.1 (N=10): y_num≈2.71692393224, erro≈0.001357896, ~2 dígitos.\n- h=0.05 (N=20): y_num≈2.71814592682, erro≈0.000135902, ~3 dígitos.\nRazão erros≈10 (próximo de 4 ajustado), p≈ log(10)/log(2)≈3.32 (melhor com mais pontos).",
                              "finalVerifications": [
                                "Erro reduz ~1/4 ao halvar h.",
                                "Ordem p calculada ≈2.",
                                "Número de dígitos corretos duplica aproximadamente.",
                                "Gráfico log(erro) vs log(h) tem inclinação -2.",
                                "Resultados consistentes para pelo menos 3 valores de h.",
                                "Explicação escrita liga resultados à teoria O(h^2)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos numéricos (erro <1e-3 para h=0.1).",
                                "Correta implementação do Método de Heun sem erros algorítmicos.",
                                "Cálculo exato da ordem p com fórmula logarítmica.",
                                "Análise qualitativa: duplicação de dígitos e interpretação.",
                                "Visualizações (tabelas/plots) claras e rotuladas.",
                                "Relatório completo com generalizações e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB reforça computação científica.",
                                "Física: Análise de precisão em simulações de movimento (ex: osciladores).",
                                "Estatística: Conceitos de erro e convergência em métodos Monte Carlo.",
                                "Engenharia: Validação numérica em modelagem diferencial."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA), previsão de epidemias (COVID models) ou finanças (Black-Scholes PDEs), calcular ordem de convergência garante precisão ao balancear custo computacional vs erro, otimizando h para precisão desejada sem desperdício de recursos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Aplicar o método em um exemplo numérico",
                            "description": "Resolver y' = -y, y(0)=1 com h=0.1 até t=1, calculando tabela de valores e comparando com solução exata y=e^{-t}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema e inicializar a tabela de valores",
                                  "subSteps": [
                                    "Escrever a equação diferencial ordinária (EDO): y' = -y com condição inicial y(0) = 1.",
                                    "Definir o passo h = 0.1 e o intervalo t de 0 até 1, calculando o número de iterações N = 1 / h = 10.",
                                    "Criar uma tabela com colunas: n, t_n, y_n, k1, k2, y_{n+1}.",
                                    "Preencher a primeira linha: n=0, t_0=0, y_0=1.",
                                    "Verificar que t_final = N * h = 1."
                                  ],
                                  "verification": "Tabela inicial criada corretamente com a primeira linha preenchida e N=10 confirmado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use uma tabela ampla para acomodar todos os valores e evite arredondamentos prematuros.",
                                  "learningObjective": "Compreender a configuração de um problema de valor inicial (PVI) para métodos numéricos.",
                                  "commonMistakes": [
                                    "Calcular errado o número de passos (ex: usar N=1 em vez de 10)",
                                    "Esquecer a condição inicial y(0)=1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Método de Heun para os primeiros passos (n=0 e n=1)",
                                  "subSteps": [
                                    "Para n=0: Calcular k1 = h * f(t_0, y_0) = 0.1 * (-1) = -0.1.",
                                    "Calcular k2 = h * f(t_0 + h, y_0 + k1) = 0.1 * (-(1 + (-0.1))) = 0.1 * (-0.9) = -0.09.",
                                    "Calcular y_1 = y_0 + (k1 + k2)/2 = 1 + (-0.1 - 0.09)/2 = 1 - 0.095 = 0.905.",
                                    "Preencher linha n=1: t_1=0.1, y_1=0.905.",
                                    "Repetir para n=1: k1 = 0.1 * (-0.905) = -0.0905; k2 = 0.1 * (-(0.905 - 0.0905)) = -0.08145; y_2 = 0.905 + (-0.085975) ≈ 0.819025."
                                  ],
                                  "verification": "Valores y_1 ≈ 0.905 e y_2 ≈ 0.8190 calculados corretamente (comparar com exato: e^{-0.1}≈0.9048, e^{-0.2}≈0.8187).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela iniciada do passo 1"
                                  ],
                                  "tips": "Mantenha pelo menos 4 casas decimais para evitar propagação de erros.",
                                  "learningObjective": "Executar corretamente a fórmula do Método de Heun (Runge-Kutta ordem 2).",
                                  "commonMistakes": [
                                    "Confundir k1 e k2 (k2 usa y_n + k1)",
                                    "Erro no sinal da função f(t,y) = -y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar as iterações restantes da tabela até t=1",
                                  "subSteps": [
                                    "Continuar iterando o processo para n=2 até n=9, aplicando as fórmulas de k1, k2 e y_{n+1} sequencialmente.",
                                    "Preencher t_n = t_{n-1} + h para cada linha.",
                                    "Registrar todos os valores de y_n até y_{10} em t=1.",
                                    "Verificar consistência aritmética em cada passo (ex: para n=2, y_3 ≈ 0.7468).",
                                    "Organizar a tabela completa com 11 linhas (n=0 a 10)."
                                  ],
                                  "verification": "Tabela completa com y_{10} ≈ 0.3679 (próximo a e^{-1} ≈ 0.367879).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela parcial"
                                  ],
                                  "tips": "Faça pausas para verificar cálculos anteriores antes de prosseguir.",
                                  "learningObjective": "Dominar a iteração sistemática do método numérico em múltiplos passos.",
                                  "commonMistakes": [
                                    "Arredondar excessivamente cedo",
                                    "Perder o rastreamento de t_n ou n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a solução exata e realizar a comparação",
                                  "subSteps": [
                                    "Determinar a solução exata: y(t) = e^{-t}.",
                                    "Calcular y_exata(t_n) = exp(-t_n) para t_n = 0, 0.1, ..., 1.0 (usar calculadora).",
                                    "Adicionar coluna de erro absoluto: e_n = |y_n - y_exata(t_n)|.",
                                    "Adicionar coluna de erro relativo: e_rel = e_n / |y_exata(t_n)| * 100%.",
                                    "Analisar: verificar se erros diminuem consistentemente (ordem 2 esperada)."
                                  ],
                                  "verification": "Erros calculados corretamente, ex: e_1 ≈ |0.905 - 0.904837| ≈ 0.000163.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com função exp",
                                    "Tabela numérica completa"
                                  ],
                                  "tips": "Use a função exp(-t) diretamente na calculadora para precisão.",
                                  "learningObjective": "Avaliar a precisão do método numérico comparando com solução analítica.",
                                  "commonMistakes": [
                                    "Erro na fórmula exata (esquecer o sinal negativo)",
                                    "Confundir erro absoluto com relativo"
                                  ]
                                }
                              ],
                              "practicalExample": "No passo n=0: k1 = 0.1 × (-1) = -0.1; k2 = 0.1 × (-(1 - 0.1)) = -0.09; y1 = 1 + (-0.1 + -0.09)/2 = 0.905. Solução exata em t=0.1: e^{-0.1} ≈ 0.904837, erro ≈ 0.000163.",
                              "finalVerifications": [
                                "Tabela completa com 11 linhas e todos os valores de y_n corretos dentro de 0.001 de precisão.",
                                "Solução exata y(t)=e^{-t} aplicada corretamente em todos t_n.",
                                "Erros absolutos calculados e tabela de comparação gerada.",
                                "y_{10} numérico ≈ 0.3679, próximo a e^{-1} ≈ 0.367879.",
                                "Análise qualitativa confirma precisão de ordem 2 (erros ~ h^2).",
                                "Nenhum erro aritmético propagado visível."
                              ],
                              "assessmentCriteria": [
                                "Correção na aplicação da fórmula de Heun em todos os passos (100% precisão).",
                                "Precisão numérica mantida (arredondamento ≤ 5 casas decimais).",
                                "Tabela organizada e completa, incluindo erros.",
                                "Análise de erros demonstra compreensão da precisão do método.",
                                "Tempo total respeitado e processo documentado claramente.",
                                "Identificação de padrões nos erros (quadrático)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar o algoritmo em Python ou MATLAB para automação.",
                                "Física: Modelagem de decaimento exponencial (radioatividade, resfriamento).",
                                "Estatística: Análise de erros numéricos e medidas de precisão.",
                                "Computação Científica: Uso de bibliotecas como NumPy para EDOs.",
                                "Engenharia: Simulações numéricas em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Aplicação em modelagem de decaimento radioativo, onde a quantidade de material radioativo diminui proporcionalmente à quantidade presente (y' = -ky), permitindo previsões precisas para meia-vida sem solução analítica disponível."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Métodos de Runge-Kutta de Ordem Superior",
                    "description": "Família de métodos explícitos de alta ordem, como RK4, com múltiplas avaliações da função.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Forma Geral dos Métodos Runge-Kutta Explícitos de Ordem Superior",
                        "description": "Apresentação da família de métodos explícitos Runge-Kutta de alta ordem, incluindo a notação em tabela de Butcher e os coeficientes que determinam a ordem de precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Interpretar a tabela de Butcher",
                            "description": "Identificar e interpretar os coeficientes A, b e c na tabela de Butcher para métodos Runge-Kutta explícitos de ordem superior, relacionando-os às etapas de avaliação da função f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da tabela de Butcher",
                                  "subSteps": [
                                    "Revise a definição de métodos Runge-Kutta explícitos de ordem superior.",
                                    "Identifique os elementos visuais da tabela: linhas, colunas e posições dos coeficientes.",
                                    "Observe que a tabela é triangular inferior para métodos explícitos.",
                                    "Anote os vetores c (nós de tempo) na coluna esquerda e b (pesos) na última linha.",
                                    "Desenhe uma tabela genérica vazia para s estágios."
                                  ],
                                  "verification": "Desenhe corretamente uma tabela Butcher genérica com s estágios, rotulando c, A e b.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica ou slides da aula"
                                  ],
                                  "tips": "Comece com s=2 para visualizar melhor antes de ordens superiores.",
                                  "learningObjective": "Reconhecer a representação tabular padronizada dos métodos Runge-Kutta explícitos.",
                                  "commonMistakes": [
                                    "Confundir matriz A com vetor b",
                                    "Ignorar que A é estritamente triangular inferior"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e interpretar os coeficientes A, b e c",
                                  "subSteps": [
                                    "Explique o vetor c: representa os nós intermediários de tempo t_i = t_n + c_i h.",
                                    "Descreva a matriz A: a_{i,j} são coeficientes para k_j em k_i = f(t_n + c_i h, y_n + h sum a_{i,j} k_j).",
                                    "Analise o vetor b: pesos finais b_i para y_{n+1} = y_n + h sum b_i k_i.",
                                    "Verifique condições de consistência: sum_j a_{i,j} = c_i para cada i.",
                                    "Compare com métodos de ordem baixa para padrões."
                                  ],
                                  "verification": "Liste definições precisas de A, b e c e dê um exemplo numérico para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela Butcher de exemplo (RK3 ou RK4)",
                                    "Calculadora para somas"
                                  ],
                                  "tips": "Use cores diferentes para destacar A (azul), b (verde) e c (vermelho) na tabela.",
                                  "learningObjective": "Diferenciar e descrever o papel matemático de cada coeficiente na tabela.",
                                  "commonMistakes": [
                                    "Achar que c são pesos em vez de nós",
                                    "Confundir soma de A com b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar a tabela às etapas de avaliação da função f(t,y)",
                                  "subSteps": [
                                    "Trace o cálculo sequencial dos k_i: k1 = f(t_n, y_n), depois k2 usando k1, etc.",
                                    "Para cada estágio i, escreva a fórmula explícita de k_i baseada na linha i de A.",
                                    "Mostre como o último passo usa b para combinar todos k_i.",
                                    "Simule um passo com h pequeno em um PVI simples como y' = y.",
                                    "Identifique dependências: k_i depende apenas de k_1 a k_{i-1} (explícito)."
                                  ],
                                  "verification": "Escreva as fórmulas de k_i para todos estágios de uma tabela dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para validar (opcional)",
                                    "Exemplo de PVI"
                                  ],
                                  "tips": "Escreva as equações ao lado da tabela para visualizar fluxos.",
                                  "learningObjective": "Mapear a estrutura tabular para o algoritmo computacional passo a passo.",
                                  "commonMistakes": [
                                    "Calcular k_i usando k_j com j>i",
                                    "Esquecer o h nas expressões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar interpretação completa com uma tabela de ordem superior",
                                  "subSteps": [
                                    "Escolha uma tabela Butcher de ordem 4 (RK4 clássico).",
                                    "Preencha as fórmulas completas para k1 a k4 e y_{n+1}.",
                                    "Compare com a forma expandida do método RK4 para validar.",
                                    "Teste com uma tabela de ordem 5 (ex: Butcher de ordem 5).",
                                    "Resolva um mini-problema: interprete e implemente um passo manual."
                                  ],
                                  "verification": "Implemente corretamente um passo do método usando a tabela em papel.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabelas Butcher impressas de ordens 3-5",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Grave um vídeo curto explicando sua interpretação para autoavaliação.",
                                  "learningObjective": "Aplicar a interpretação em métodos reais de ordem superior.",
                                  "commonMistakes": [
                                    "Erros aritméticos em somas de A",
                                    "Não normalizar b para somar 1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o RK4 clássico (ordem 4, s=4):\nTabela Butcher:\nc = [0, 1/2, 1/2, 1]\nA = [[0,0,0,0], [1/2,0,0,0], [0,1/2,0,0], [0,0,1,0]]\nb = [1/6, 1/3, 1/3, 1/6]\nInterpretação: k1=f(t,y), k2=f(t+0.5h, y+0.5h k1), k3=f(t+0.5h, y+0.5h k2), k4=f(t+h, y+h k3), y1=y+h( k1/6 + k2/3 + k3/3 + k4/6 ).",
                              "finalVerifications": [
                                "Desenha e rotula corretamente A, b, c em qualquer tabela Butcher dada.",
                                "Escreve as equações de k_i para todos estágios sem erros.",
                                "Verifica condições de ordem (ex: somas de linhas de A igualam c_i).",
                                "Explica o fluxo computacional sequencial verbalmente.",
                                "Aplica a tabela a um PVI simples com cálculos manuais precisos.",
                                "Identifica se uma tabela dada é explícita (triangular inferior)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de coeficientes (100% correto).",
                                "Correção nas fórmulas derivadas da tabela (sem erros algébricos).",
                                "Profundidade na relação com avaliações de f(t,y) (cita dependências).",
                                "Capacidade de generalizar para ordens >4.",
                                "Clareza na explicação oral ou escrita.",
                                "Detecção de erros comuns em tabelas inválidas"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers ODE em Python (SciPy odeint usa Butcher).",
                                "Física: Simulações de movimento (ex: pêndulo caótico com RK45).",
                                "Engenharia: Modelagem diferencial em controle de sistemas.",
                                "Computação Científica: Otimização de métodos numéricos em HPC."
                              ],
                              "realWorldApplication": "Em software como MATLAB ode45 ou Python SciPy, tabelas Butcher são usadas para simular trajetórias de satélites, prever epidemias (modelos SIR) ou otimizar reações químicas, garantindo precisão e estabilidade em problemas reais de engenharia e ciências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Determinar condições de ordem",
                            "description": "Aplicar as condições de ordem (como soma de b_i =1, soma b_i a_{ij}=1/2, etc.) para verificar ou construir métodos Runge-Kutta de ordem 3 ou superior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral e notação dos métodos Runge-Kutta explícitos",
                                  "subSteps": [
                                    "Estude a forma geral: y_{n+1} = y_n + h ∑_{i=1}^s b_i k_i, onde k_i = f(t_n + c_i h, y_n + h ∑_{j=1}^{i-1} a_{ij} k_j).",
                                    "Identifique os Butcher tableaux: matriz A (a_{ij}), vetor c (c_i), vetor b (b_i).",
                                    "Revise a expansão em série de Taylor para y(t_n + h) e para cada k_i.",
                                    "Compare as expansões para derivar as condições de ordem.",
                                    "Anote as condições elementares B(p), que garantem ordem p."
                                  ],
                                  "verification": "Escreva corretamente o Butcher tableau genérico e liste as 3 primeiras condições de ordem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e lápis, calculadora simbólica opcional (SymPy).",
                                  "tips": "Use diagramas de árvores de Butcher para visualizar contribuições de derivadas.",
                                  "learningObjective": "Dominar a notação padrão e setup para condições de ordem em RK.",
                                  "commonMistakes": "Confundir índices i e j na matriz A; ignorar que A é estritamente triangular inferior para métodos explícitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar e derivar condições de ordem até ordem 3",
                                  "subSteps": [
                                    "Derive a condição de ordem 1: ∑ b_i = 1.",
                                    "Derive ordem 2: ∑ b_i c_i = 1/2.",
                                    "Derive ordem 3: ∑ b_i c_i^2 = 1/3 e ∑ b_i ∑_{j=1}^{i-1} a_{ij} c_j = 1/6.",
                                    "Liste todas as condições para p=3 em um tableau s=3.",
                                    "Verifique com o método de Euler modificado (Heun) se satisfaz ordem 2."
                                  ],
                                  "verification": "Resolva manualmente as condições para ordem 2 e confirme com um exemplo conhecido.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel quadriculado, lápis, tabela de condições de ordem do livro-texto.",
                                  "tips": "Comece com s=2 para ordem 2; use simetria onde possível (ex: c_i = ∑ a_{ij}).",
                                  "learningObjective": "Derivar e memorizar condições de ordem p=1,2,3 algebraicamente.",
                                  "commonMistakes": "Erros em potências de c_i; esquecer somas duplas como ∑ b_i ∑ a_{ij} c_j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar condições de ordem em métodos conhecidos",
                                  "subSteps": [
                                    "Pegue o RK4 clássico (s=4) e compute todas somas para p=4.",
                                    "Verifique se ∑ b_i =1, ∑ b_i c_i=1/2, etc., até ordem 4.",
                                    "Identifique um método de ordem 3 (ex: RK3 de Heun) e confirme.",
                                    "Use software para validar cálculos numéricos.",
                                    "Registre discrepâncias se ordem for menor que esperada."
                                  ],
                                  "verification": "Confirme que RK4 satisfaz 4 condições independentes e liste-as.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy) ou Excel para somas matriciais.",
                                  "tips": "Implemente funções para Butcher tableau como matrizes e compute somas automaticamente.",
                                  "learningObjective": "Aplicar condições para validar ordem de métodos padrão.",
                                  "commonMistakes": "Usar valores errados de coeficientes clássicos; arredondamentos em cálculos decimais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir métodos RK de ordem 3 ou superior resolvendo sistemas",
                                  "subSteps": [
                                    "Escolha s=3 e resolva o sistema não-linear para ordem 3 (4 equações).",
                                    "Imponha condições auxiliares como ∑_{j=1}^{i-1} a_{ij}=c_i e simetria.",
                                    "Use eliminação gaussiana ou solver numérico para coeficientes.",
                                    "Teste o método em y'=y, compare com solução exata.",
                                    "Estenda para ordem 4 com s=4, notando subdeterminação."
                                  ],
                                  "verification": "Obtenha coeficientes que satisfazem todas condições e erro local O(h^4).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Solver simbólico (SymPy, Mathematica) ou MATLAB fsolve.",
                                  "tips": "Fixe c_i livremente (ex: c=[0,1/2,1]) para reduzir variáveis.",
                                  "learningObjective": "Resolver sistemas algébricos para derivar métodos RK personalizados.",
                                  "commonMistakes": "Ignorar não-linearidades; soluções inconsistentes sem condições auxiliares."
                                }
                              ],
                              "practicalExample": "Para um RK3 com s=3 e c=[0, 0.5, 1], resolva: b1+b2+b3=1; b2*0.5 + b3*1=0.5; b2*(0.5)^2 + b3*1^2=1/3; b3*a32*0.5=1/6, assumindo a21=0.5, a32=0.5. Obtenha b=[1/6, 2/3, 1/6], a32=0.5, verificando ordem 3.",
                              "finalVerifications": [
                                "Lista corretamente todas condições de ordem até p=3.",
                                "Verifica RK4 clássico sem erros aritméticos.",
                                "Deriva coeficientes viáveis para RK3.",
                                "Identifica falhas em métodos propostos.",
                                "Explica impacto de violar uma condição específica.",
                                "Compara erro local com ordem teórica em teste simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas somas e condições derivadas (erro <1e-10).",
                                "Correta identificação de número de condições independentes por ordem.",
                                "Solução consistente de sistemas não-lineares.",
                                "Validação numérica com problema teste (erro O(h^{p+1})).",
                                "Explicação clara de derivações em série de Taylor.",
                                "Uso eficiente de condições auxiliares para reduzir graus de liberdade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de trajetórias em mecânica (ex: oscilador harmônico).",
                                "Computação: Implementação em código para solvers ODE (Python SciPy).",
                                "Engenharia: Modelagem de circuitos RLC ou controle de sistemas.",
                                "Estatística: Integração numérica em MCMC para inferência bayesiana."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, métodos RK de ordem alta simulam equações diferenciais de fluidos com precisão, minimizando erros de truncamento em previsões de longo prazo; em finanças, integra caminhos estocásticos para precificação de opções."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Calcular etapas intermediárias",
                            "description": "Executar o cálculo das etapas k_i em métodos de ordem superior, como RK3 ou RK4, para um PVI dado y' = f(t,y), y(t0)=y0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados iniciais e identificar a estrutura do método Runge-Kutta",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial (PVI): y' = f(t, y), com condições iniciais t0 e y0.",
                                    "Escolha o método específico (ex: RK3 ou RK4) e liste os coeficientes a, b e c da tabela de Butcher.",
                                    "Defina o passo h e o ponto atual tn.",
                                    "Escreva as fórmulas explícitas para cada k_i: k1 = f(tn, yn), k2 = f(tn + c2 h, yn + h a21 k1), etc.",
                                    "Anote todos os valores numéricos necessários em uma tabela organizada."
                                  ],
                                  "verification": "Verifique se a tabela de Butcher está corretamente transcrita e todos os parâmetros (t0, y0, h) estão listados sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Tabela de Butcher para RK3/RK4 impressa ou digital",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre use a forma explícita para métodos explícitos e confirme os coeficientes padrão (ex: RK4 clássico: c2=1/2, a21=1/2).",
                                  "learningObjective": "Compreender a estrutura geral dos métodos RK de ordem superior e preparar cálculos sistematicamente.",
                                  "commonMistakes": [
                                    "Confundir coeficientes a_ij com b_i",
                                    "Esquecer de incluir h nas expressões de k_i",
                                    "Usar condições iniciais erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a primeira etapa intermediária k1",
                                  "subSteps": [
                                    "Substitua tn e yn na função f(t, y) para obter k1 = f(tn, yn).",
                                    "Realize os cálculos aritméticos com precisão, respeitando casas decimais.",
                                    "Registre o valor de k1 com pelo menos 4 casas decimais.",
                                    "Verifique dimensionalmente se k1 tem as unidades corretas de y'/tempo.",
                                    "Anote k1 na tabela de etapas intermediárias."
                                  ],
                                  "verification": "Compare k1 com y'(tn, yn) calculado separadamente para confirmação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Função f(t,y) definida",
                                    "Tabela de valores iniciais"
                                  ],
                                  "tips": "Para funções simples como f(t,y)=y, k1=yn; pratique com funções lineares primeiro.",
                                  "learningObjective": "Executar o cálculo inicial k1 com exatidão e entender seu papel como inclinação no ponto atual.",
                                  "commonMistakes": [
                                    "Erro de sinal na função f",
                                    "Confundir y com t nos argumentos",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as etapas intermediárias subsequentes k2, k3 (e k4 para RK4)",
                                  "subSteps": [
                                    "Para k2: Calcule argumentos tn + c2 h e yn + h Σ a2j kj (j=1), substitua em f.",
                                    "Para k3: Similarmente, tn + c3 h e yn + h (a31 k1 + a32 k2), avalie f.",
                                    "Para RK4, continue com k4: f(tn + h, yn + h (a41 k1 + a42 k2 + a43 k3)).",
                                    "Registre cada k_i sequencialmente, usando valores anteriores.",
                                    "Use uma tabela para rastrear dependências entre k_i's."
                                  ],
                                  "verification": "Recalcule um k_i usando valores arredondados vs. exatos para checar consistência numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com memória",
                                    "Tabela de Butcher expandida",
                                    "Papel milimetrado para tabelas"
                                  ],
                                  "tips": "Calcule argumentos intermediários (t* e y*) em etapas separadas antes de f para evitar erros de propagação.",
                                  "learningObjective": "Dominar o cálculo recursivo das k_i's dependentes, garantindo precisão em métodos de ordem superior.",
                                  "commonMistakes": [
                                    "Índices errados nos coeficientes a_ij",
                                    "Esquecer multiplicar por h nas somas",
                                    "Ordem incorreta de cálculo (ex: k3 antes de k2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e compilar todas as etapas intermediárias",
                                  "subSteps": [
                                    "Liste todos os k_i calculados em uma tabela final com valores e argumentos usados.",
                                    "Compare com solução exata ou método de menor ordem (ex: Euler) para plausibilidade.",
                                    "Calcule a soma ponderada para yn+1 = yn + h Σ bi ki como verificação indireta.",
                                    "Analise erros potenciais e refaça cálculos suspeitos.",
                                    "Documente o processo completo para referência futura."
                                  ],
                                  "verification": "Os k_i's devem ser consistentes: para f=y, em RK4, esperam-se valores crescentes se y>0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Solução analítica opcional",
                                    "Software como Python/MATLAB para validação",
                                    "Folha de verificação"
                                  ],
                                  "tips": "Sempre arredonde consistentemente (ex: 6 decimais) e use verificação cruzada com outro método.",
                                  "learningObjective": "Garantir a integridade dos cálculos de k_i's através de verificações sistemáticas.",
                                  "commonMistakes": [
                                    "Propagação de erros de arredondamento não detectada",
                                    "Inverter soma de coeficientes",
                                    "Ignorar verificação de plausibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, h=0.1, RK4 clássico: k1 = f(0,1) = -2; k2 = f(0.05, 1 - 0.1) = -1.8182; k3 = f(0.05, 1 - 0.1) ≈ -1.8182; k4 = f(0.1, 1 - 0.2) ≈ -1.6325. Valores aproximados; calcule precisamente para prática.",
                              "finalVerifications": [
                                "Todos os k_i foram calculados com pelo menos 4 casas decimais de precisão.",
                                "Coeficientes da tabela de Butcher foram aplicados corretamente sem transposições.",
                                "Dependências recursivas entre k_i respeitadas (nenhum k_j usado antes de calculado).",
                                "Valores plausíveis comparados à derivada inicial y'(t0,y0).",
                                "Tabela final completa com argumentos t* e y* para cada k_i.",
                                "Soma ponderada para yn+1 coerente com direção esperada da solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos k_i (erro < 10^-4).",
                                "Correta identificação e uso da tabela de Butcher.",
                                "Execução ordenada e recursiva dos cálculos.",
                                "Documentação clara de todos os passos intermediários.",
                                "Detecção e correção de erros comuns via verificação.",
                                "Eficiência temporal dentro dos limites estimados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar algoritmo RK em Python para automatizar k_i's.",
                                "Física: Aplicar em equações diferenciais de movimento (ex: oscilador harmônico).",
                                "Computação Científica: Integração com bibliotecas como SciPy odeint.",
                                "Estatística: Análise de erro numérico e truncamento local."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA usa RK4 para órbitas), modelagem climática (previsão de tempo via EDOs), finanças (simulação de opções via Black-Scholes numérico) e engenharia (controle de sistemas dinâmicos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Método de Runge-Kutta de Quarta Ordem (RK4)",
                        "description": "Descrição detalhada do método clássico RK4, suas derivadas e aplicação prática como método de passo simples de alta precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Derivar o esquema RK4",
                            "description": "Derivar os coeficientes da tabela de Butcher para o RK4 clássico, verificando as condições de ordem até 4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as condições de ordem para métodos de Runge-Kutta",
                                  "subSteps": [
                                    "Estude a expansão em série de Taylor para a solução exata y(t_n + h) até ordem h^4.",
                                    "Defina as condições de ordem para métodos RK: ∑ b_i = 1 (ordem 1), ∑ b_i c_i = 1/2 (ordem 2), ∑ b_i c_i^2 /2 + ∑ b_i ∑ a_{ij} c_j = 1/6 (ordem 3), e a condição de ordem 4.",
                                    "Entenda os c_i = ∑ a_{ij} para consistência.",
                                    "Anote as 9 condições algébricas para ordem 4 com 4 estágios.",
                                    "Identifique graus de liberdade restantes para o RK4 clássico."
                                  ],
                                  "verification": "Liste corretamente todas as condições de ordem 1 a 4 e confirme que há soluções não únicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Calculadora simbólica opcional (Mathematica ou SymPy)"
                                  ],
                                  "tips": "Comece pelas condições de ordem baixa para construir intuition; use notação matricial para clareza.",
                                  "learningObjective": "Compreender as condições algébricas que garantem precisão local de ordem 4 para métodos RK.",
                                  "commonMistakes": [
                                    "Confundir condições de ordem com truncamento local global",
                                    "Esquecer que c_i são derivados dos a_{ij}",
                                    "Ignorar inconsistências lineares no sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a tabela de Butcher genérica para 4 estágios",
                                  "subSteps": [
                                    "Desenhe a tabela de Butcher vazia com 4 linhas (estágios) e colunas para c_i, a_{i1} a_{i2} a_{i3} a_{i4}, e vetor b_i.",
                                    "Defina c_1 = 0 (estágio Euler inicial).",
                                    "Escolha estrutura clássica: simetria com k2 e k3 no meio do intervalo.",
                                    "Atribua valores iniciais conhecidos: a_{21}=1/2, c_2=1/2; a_{32}=1/2, c_3=1/2; a_{41}=1, c_4=1.",
                                    "Liste as incógnitas restantes: b1,b2,b3,b4 e confirme 11 parâmetros para 9 condições."
                                  ],
                                  "verification": "Tabela de Butcher parcialmente preenchida com estrutura clássica e lista de equações pendentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Referência à tabela RK4 clássica (sem copiar coeficientes)"
                                  ],
                                  "tips": "Mantenha simetria entre estágios 2 e 3 para simplificar; desenhe graficamente os pontos de avaliação.",
                                  "learningObjective": "Montar a estrutura paramétrica da tabela de Butcher para RK4 com escolhas clássicas.",
                                  "commonMistakes": [
                                    "Definir c_i incorretamente sem derivar de a_{ij}",
                                    "Confundir índices i,j na matriz A",
                                    "Assumir valores sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema de equações para os coeficientes",
                                  "subSteps": [
                                    "Escreva explicitamente as 9 condições de ordem substituindo a estrutura da tabela.",
                                    "Resolva ordem 1: b1 + b2 + b3 + b4 = 1.",
                                    "Ordem 2: b2/2 + b3/2 + b4 = 1/2.",
                                    "Continue para ordem 3 e 4, resolvendo o sistema linear passo a passo (use eliminação gaussiana).",
                                    "Obtenha b_i = [1/6, 1/3, 1/3, 1/6] e verifique consistência dos a_{ij}."
                                  ],
                                  "verification": "Coeficientes b_i e a_{ij} finais coincidem com RK4 clássico: b=[1/6,1/3,1/3,1/6].",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora ou software (MATLAB, Python NumPy para sistema linear)",
                                    "Planilha para equações"
                                  ],
                                  "tips": "Resolva sequencialmente por ordem; use substituição para reduzir dimensões.",
                                  "learningObjective": "Aplicar resolução de sistemas lineares para derivar coeficientes RK que satisfazem condições de ordem.",
                                  "commonMistakes": [
                                    "Erros aritméticos em somas ponderadas",
                                    "Não normalizar b_i=1",
                                    "Ignorar dependências entre condições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar condições de ordem e escrever o esquema RK4 explícito",
                                  "subSteps": [
                                    "Substitua coeficientes na tabela Butcher completa e verifique todas as 9 condições numericamente.",
                                    "Expanda o esquema: k1=f(t,y), k2=f(t+h/2,y+h/2 k1), etc., y_{n+1}=y_n + h/6(k1+2k2+2k3+k4).",
                                    "Calcule erro local de truncamento O(h^5) via série de Taylor.",
                                    "Compare com RK2 ou Euler para validar ordem superior.",
                                    "Implemente um teste numérico simples em código para confirmar."
                                  ],
                                  "verification": "Todas condições satisfeitas (erro <1e-10) e esquema explícito correto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou MATLAB para verificação numérica",
                                    "Problema teste: y'=y, y(0)=1"
                                  ],
                                  "tips": "Use precisão simbólica para verificações; plote soluções para intuição visual.",
                                  "learningObjective": "Confirmar a ordem 4 e formular o esquema computacional pronto para uso.",
                                  "commonMistakes": [
                                    "Falhar na verificação de ordem 4 devido a arredondamento",
                                    "Escrever pesos errados em y_{n+1}",
                                    "Confundir k_i na combinação final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -y + sin(t), y(0)=1, h=0.1: compute k1=f(0,1), k2=f(0.05,1+0.05 k1), etc., e avance para y(0.1), comparando com solução exata.",
                              "finalVerifications": [
                                "Tabela de Butcher completa com coeficientes exatos do RK4 clássico.",
                                "Todas as 9 condições de ordem 1-4 satisfeitas com erro numérico nulo.",
                                "Esquema explícito y_{n+1} = y_n + (h/6)(k1 + 2k2 + 2k3 + k4) correto.",
                                "Erro local de truncamento derivado como O(h^5).",
                                "Teste numérico em PVI simples converge com ordem 4.",
                                "Explicação clara das escolhas simétricas nos estágios."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes b_i e a_{ij} (100% match com clássico).",
                                "Correta derivação sequencial das condições de ordem.",
                                "Verificação matemática completa sem erros aritméticos.",
                                "Clareza na tabela Butcher e esquema final.",
                                "Inclusão de análise de erro e comparação com métodos inferiores.",
                                "Capacidade de aplicar em exemplo numérico prático."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar RK4 em Python/ MATLAB para simulações.",
                                "Física: Resolver EDOs em mecânica (ex: pêndulo, órbitas).",
                                "Engenharia: Modelagem de sistemas dinâmicos em controle.",
                                "Estatística: Integração numérica em Monte Carlo."
                              ],
                              "realWorldApplication": "RK4 é amplamente usado em simulações de dinâmica de fluidos (CFD), previsão meteorológica, modelagem epidemiológica (ex: SIR models para COVID), e jogos/vfx para trajetórias físicas realistas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Implementar RK4 numericamente",
                            "description": "Implementar o algoritmo RK4 em pseudocódigo ou linguagem de programação para resolver um PVI, calculando múltiplas avaliações de f em cada passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula do método RK4 e preparar o problema de teste",
                                  "subSteps": [
                                    "Revise a definição de um Problema de Valor Inicial (PVI): y' = f(t, y), y(t0) = y0.",
                                    "Estude a fórmula do RK4: k1 = f(tn, yn), k2 = f(tn + h/2, yn + h*k1/2), k3 = f(tn + h/2, yn + h*k2/2), k4 = f(tn + h, yn + h*k3), yn+1 = yn + (h/6)*(k1 + 2*k2 + 2*k3 + k4).",
                                    "Escolha um PVI de teste simples: y' = -2y, y(0) = 1 (solução exata: y(t) = e^{-2t}).",
                                    "Defina parâmetros: intervalo [0, 1], h = 0.1, número de passos N = 10.",
                                    "Anote a função f(t, y) = -2*y explicitamente."
                                  ],
                                  "verification": "Você pode recitar a fórmula RK4 corretamente e definir f(t,y), t0, y0, h sem consultar notas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto para anotações",
                                    "Referência teórica de Análise Numérica (livro ou PDF)"
                                  ],
                                  "tips": [
                                    "Comece com um problema linear simples para facilitar verificação exata.",
                                    "Desenhe um diagrama dos k's para visualizar dependências."
                                  ],
                                  "learningObjective": "Compreender os componentes matemáticos do RK4 e preparar um caso de teste validável.",
                                  "commonMistakes": [
                                    "Confundir os argumentos de k2/k3 (h/2 vs h)",
                                    "Esquecer que k's são vetores se y for vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever pseudocódigo para um único passo RK4",
                                  "subSteps": [
                                    "Inicialize tn = t0, yn = y0.",
                                    "Calcule k1 = f(tn, yn).",
                                    "Calcule k2 = f(tn + h/2, yn + (h/2)*k1).",
                                    "Calcule k3 = f(tn + h/2, yn + (h/2)*k2).",
                                    "Calcule k4 = f(tn + h, yn + h*k3).",
                                    "Atualize yn+1 = yn + (h/6)*(k1 + 2*k2 + 2*k3 + k4), tn+1 = tn + h.",
                                    "Teste manualmente um passo com valores numéricos (t=0, y=1, h=0.1)."
                                  ],
                                  "verification": "Execute o cálculo manual de um passo e confirme que yn+1 ≈ 0.8187 (para o exemplo dado).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python REPL para verificação manual",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": [
                                    "Use indentação clara no pseudocódigo para mostrar sequência.",
                                    "Verifique unidades/dimensões se y for vetorial."
                                  ],
                                  "learningObjective": "Traduzir a fórmula RK4 em algoritmo sequencial acionável.",
                                  "commonMistakes": [
                                    "Erro aritmético nos coeficientes (ex: 2*k2 em vez de 2*k2/6)",
                                    "Não atualizar tn corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo completo em Python",
                                  "subSteps": [
                                    "Crie uma função rk4_step(f, t, y, h) que retorne k1,k2,k3,k4, y_next.",
                                    "Escreva uma função rk4_integrate(f, t0, y0, t_end, h) com loop for i in range(N): usando rk4_step.",
                                    "Armazene soluções em listas t_values, y_values.",
                                    "Implemente f(t,y) = -2*y como lambda ou def.",
                                    "Adicione plot com matplotlib: plt.plot(t_values, y_values, 'o-', label='RK4'); plt.plot(t_values, np.exp(-2*np.array(t_values)), '--', label='Exata').",
                                    "Execute e salve o plot."
                                  ],
                                  "verification": "O código roda sem erros e gera um plot onde a curva RK4 sobrepõe a exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3 com NumPy e Matplotlib instalados",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": [
                                    "Use NumPy arrays para y se escalável.",
                                    "Vectorize f se possível, mas mantenha escalar para clareza."
                                  ],
                                  "learningObjective": "Codificar RK4 de forma modular e visualizável em Python.",
                                  "commonMistakes": [
                                    "Loop infinito ou off-by-one em range(N)",
                                    "Esquecer import numpy as np e matplotlib.pyplot as plt"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar precisão e analisar o método",
                                  "subSteps": [
                                    "Calcule erro global: max(abs(y_values - np.exp(-2*np.array(t_values)))).",
                                    "Teste com h menor (ex: 0.05) e observe redução de erro ~O(h^4).",
                                    "Experimente outro PVI: y' = y*(1-y), y(0)=0.5 (logística).",
                                    "Meça tempo de execução com %timeit para N=1000.",
                                    "Documente observações em um relatório curto: precisão, avaliações de f (4 por passo).",
                                    "Refatore código para generalidade (aceitar f arbitrária)."
                                  ],
                                  "verification": "Erro < 1e-5 para h=0.1 e confirma 4 avaliações de f por passo via contador.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do step 3",
                                    "Jupyter para %timeit e profiling simples"
                                  ],
                                  "tips": [
                                    "Adicione contador de chamadas a f para provar 'múltiplas avaliações'.",
                                    "Compare com Euler para destacar superioridade."
                                  ],
                                  "learningObjective": "Validar implementação numericamente e entender ordem de precisão.",
                                  "commonMistakes": [
                                    "Não normalizar erro adequadamente",
                                    "Ignorar overhead das 4 avaliações vs métodos de ordem baixa"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente RK4 para resolver y' = -2y, y(0)=1 em [0,1] com h=0.1. O código deve gerar um plot mostrando y_RK4(t) coincidente com e^{-2t}, com erro máximo ~1e-6, provando 4 avaliações de f por passo via log.",
                              "finalVerifications": [
                                "Código executa sem erros para PVI dado e produz solução numérica.",
                                "Plot compara solução RK4 com exata, mostrando alta precisão.",
                                "Contador confirma exatamente 4 chamadas a f por passo.",
                                "Erro diminui com h menor, consistente com ordem 4.",
                                "Código é modular e funciona para outro PVI não-linear.",
                                "Tempo de execução razoável para N=1000 passos."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: k's e atualização yn+1 exatos.",
                                "Clareza e modularidade do código (funções separadas).",
                                "Precisão numérica: erro O(h^4) demonstrado.",
                                "Eficiência: 4 avaliações de f otimizadas sem redundâncias.",
                                "Visualização e documentação adequadas.",
                                "Generalidade: funciona para f(t,y) arbitrárias escalares."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos numéricos em Python/NumPy.",
                                "Física: Modelagem de decaimento exponencial ou osciladores.",
                                "Computação Científica: Integração em SciPy para comparações.",
                                "Engenharia: Simulações dinâmicas em controle/orbitas."
                              ],
                              "realWorldApplication": "RK4 é amplamente usado em simulações físicas como trajetórias de mísseis, previsão meteorológica (modelos de EDOs), dinâmica de populações em biologia e simulações financeiras de processos estocásticos, onde alta precisão com custo computacional moderado é essencial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Aplicar RK4 a exemplos",
                            "description": "Resolver numericamente PVIs lineares e não-lineares usando RK4, comparando com soluções exatas e analisando o erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e formular exemplos de PVIs lineares e não-lineares",
                                  "subSteps": [
                                    "Escolha um PVI linear simples, como y' = -2y, y(0) = 1 (solução exata: y(t) = e^{-2t}).",
                                    "Escolha um PVI não-linear, como y' = y(1 - y), y(0) = 0.5 (modelo logístico).",
                                    "Escreva as equações diferenciais, condições iniciais e soluções exatas conhecidas.",
                                    "Defina o intervalo de integração (ex: t de 0 a 2) e passo h (ex: h=0.1).",
                                    "Verifique se as soluções exatas estão corretas derivando e aplicando condições iniciais."
                                  ],
                                  "verification": "Lista de PVIs com equações, condições iniciais e soluções exatas documentadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência de soluções exatas (livro ou Wolfram Alpha)"
                                  ],
                                  "tips": "Comece com problemas onde a solução exata é conhecida para facilitar a comparação posterior.",
                                  "learningObjective": "Formular corretamente PVIs lineares e não-lineares com soluções exatas para benchmark.",
                                  "commonMistakes": [
                                    "Esquecer a condição inicial",
                                    "Erro na derivação da solução exata",
                                    "Escolher h muito grande inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo RK4",
                                  "subSteps": [
                                    "Escreva a fórmula RK4: k1 = h*f(t_n, y_n), k2 = h*f(t_n + h/2, y_n + k1/2), k3 = h*f(t_n + h/2, y_n + k2/2), k4 = h*f(t_n + h, y_n + k3), y_{n+1} = y_n + (k1 + 2k2 + 2k3 + k4)/6.",
                                    "Crie uma função em Python que recebe f(t,y), t0, y0, tf, h e retorna vetores t e y.",
                                    "Implemente o loop de integração até tf.",
                                    "Teste com um problema simples manualmente (1-2 passos) para validar k's.",
                                    "Adicione tratamento para múltiplos passos e armazenamento de resultados."
                                  ],
                                  "verification": "Função RK4 executa sem erros e produz y1 correto para o primeiro passo manual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy",
                                    "Editor de código (Jupyter Notebook recomendado)",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Use def rk4(f, t0, y0, h, tf): e vetores np.linspace para t.",
                                  "learningObjective": "Codificar precisamente o método RK4 para integração numérica de PVIs.",
                                  "commonMistakes": [
                                    "Erro nos argumentos de f em k2/k3/k4",
                                    "Fator 1/6 esquecido",
                                    "Não atualizar t_n = t_n + h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações numéricas e visualizar resultados",
                                  "subSteps": [
                                    "Aplique RK4 aos PVIs selecionados com h=0.1 e gere vetores t, y_num.",
                                    "Calcule soluções exatas nos mesmos pontos t usando fórmulas analíticas.",
                                    "Plote y_num vs y_exata em gráfico com Matplotlib (uma curva por PVI).",
                                    "Execute com h=0.05 para comparar convergência.",
                                    "Salve plots e dados em arquivos para análise posterior."
                                  ],
                                  "verification": "Gráficos mostram sobreposição próxima entre numérico e exato; sem erros de execução.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use plt.plot(t, y_num, 'o-', label='RK4') e plt.plot(t, y_exact, '--', label='Exata').",
                                  "learningObjective": "Gerar e visualizar soluções numéricas RK4 comparadas às exatas.",
                                  "commonMistakes": [
                                    "Escala errada no plot",
                                    "Interpolação incorreta para y_exata",
                                    "h inconsistente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar erros e ordem de convergência",
                                  "subSteps": [
                                    "Calcule erro absoluto |y_num - y_exata| em cada ponto t e máximo erro global.",
                                    "Plote erro vs t para diferentes h.",
                                    "Estime ordem de convergência: log(erro_h / erro_{h/2}) / log(2) ≈ 4.",
                                    "Compare erros para linear vs não-linear.",
                                    "Discuta limitações (ex: estabilidade para h grande)."
                                  ],
                                  "verification": "Tabela ou plot de erros mostra convergência de ordem 4; máximo erro < 10^{-4} para h=0.01.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Dados dos steps anteriores"
                                  ],
                                  "tips": "Use np.max(np.abs(y_num - y_exact)) para erro global.",
                                  "learningObjective": "Quantificar precisão do RK4 e verificar ordem de truncamento.",
                                  "commonMistakes": [
                                    "Erro relativo em vez de absoluto",
                                    "Cálculo errado de ordem",
                                    "Ignorar efeitos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 até t=2 com h=0.1 usando RK4. Solução exata: y(t)=exp(-2t). Compare plots e erros: espere erro global ~10^{-5}, ordem 4 confirmada reduzindo h para 0.05.",
                              "finalVerifications": [
                                "Soluções RK4 coincidem visualmente com exatas em plots.",
                                "Erro global diminui com h^4.",
                                "Implementação RK4 produz y1 correto manualmente.",
                                "Análise diferencia linear vs não-linear.",
                                "Código reutilizável para novos PVIs.",
                                "Relatório com plots e tabelas de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão: ordem de convergência ≈4 demonstrada.",
                                "Implementação: Fórmulas RK4 corretas sem bugs.",
                                "Visualização: Plots claros comparando numérico/exato.",
                                "Análise: Erros quantificados e interpretados.",
                                "Generalidade: Funciona para linear e não-linear.",
                                "Documentação: Código comentado e relatório."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python.",
                                "Física: Simulações de decaimento radioativo (linear).",
                                "Biologia: Modelos populacionais logísticos (não-linear).",
                                "Estatística: Análise de erro e convergência."
                              ],
                              "realWorldApplication": "Simulações em engenharia (órbitas, circuitos), previsão meteorológica, modelagem epidemiológica (COVID-19), onde soluções exatas são raras e RK4 fornece alta precisão com custo computacional moderado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Propriedades e Análise dos Métodos RK de Ordem Superior",
                        "description": "Estudo das propriedades de precisão, estabilidade e limitações dos métodos RK explícitos de alta ordem, incluindo relação com problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Analisar erro local e global",
                            "description": "Calcular o erro local de truncamento O(h^{p+1}) e derivar o erro global O(h^p) para métodos RK de ordem p≥4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Erro Local de Truncamento em Métodos RK",
                                  "subSteps": [
                                    "Relembrar a expansão em série de Taylor da solução exata y(t + h).",
                                    "Identificar os coeficientes Butcher A, b, c do método RK de ordem p.",
                                    "Entender as condições de ordem p: ∑ b_i φ_i(k) = 1/p! para árvores elementares até ordem p.",
                                    "Definir o erro local de truncamento como ψ(h) / h^{p+1}, onde ψ(0)=0.",
                                    "Examinar por que para p≥4, condições específicas evitam termos espúrios."
                                  ],
                                  "verification": "Escrever as condições de ordem p e identificar o termo líder do erro local O(h^{p+1}).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Comece com RK2 ou RK4 para visualizar padrões antes de generalizar para p≥4.",
                                  "learningObjective": "Compreender a origem do erro local de truncamento via séries de Taylor e condições de ordem.",
                                  "commonMistakes": "Confundir coeficientes Butcher com os da solução exata; ignorar derivadas superiores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Erro Local de Truncamento O(h^{p+1})",
                                  "subSteps": [
                                    "Derivar a expansão do método RK: y_{n+1} = y_n + h ∑ b_i k_i, com k_i = f(t_n + c_i h, y_n + h ∑ a_{ij} k_j).",
                                    "Expandir cada k_i em série de Taylor em torno de (t_n, y_n).",
                                    "Coletar termos até ordem p+1 usando elementary differentials e teorema de Butcher.",
                                    "Verificar que ∑ b_i φ_i(τ) = φ_e(τ)/|τ|! para |τ|≤p, resultando em resíduo O(h^{p+1}).",
                                    "Computar explicitamente o coeficiente líder ψ^{(p+1)}(0)/(p+1)! para p≥4."
                                  ],
                                  "verification": "Derivar a expressão explícita de ψ(h) = O(h^{p+1}) para um método RK4 padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software simbólico (Mathematica ou SymPy), exemplos de tabelas Butcher.",
                                  "tips": "Use notação de árvores de Butcher para organizar os termos; foque em simetrias para p≥4.",
                                  "learningObjective": "Calcular analiticamente o erro local de truncamento para métodos RK de ordem superior.",
                                  "commonMistakes": "Erros em expansões de composição de k_i; esquecer fator h nas k_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Erro Global O(h^p) a Partir do Erro Local",
                                  "subSteps": [
                                    "Modelar a acumulação de erros: e_{n+1} = e_n + δ_n, onde δ_n ≈ C h^{p+1} é o erro local por passo.",
                                    "Somar telescopicamente: e_N ≈ ∑_{n=0}^{N-1} δ_n ≈ N C h^{p+1}, com Nh ≈ T fixo, então e ≈ T C h^p.",
                                    "Considerar o fator de Lipschitz L: |e_{n+1}| ≤ (1 + L h) |e_n| + |δ_n|, levando a |e_N| ≤ (e^{L T} -1)/L * max|δ|/h = O(h^p).",
                                    "Analisar estabilidade para p≥4, garantindo convergência uniforme.",
                                    "Verificar numericamente com refinamento h → 0, log-log plot de ||e|| vs h."
                                  ],
                                  "verification": "Derivar a estimativa |y(T) - y_N| ≤ K h^p com K explícito.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software numérico (MATLAB/Octave/Python com SciPy), problema teste y' = -y, y(0)=1.",
                                  "tips": "Use o lema de Gronwall para rigor; teste com h=0.1,0.05 para slope p.",
                                  "learningObjective": "Relacionar erro local acumulado ao erro global via soma e estabilidade.",
                                  "commonMistakes": "Esquecer o fator e^{LT} na amplificação; assumir N h^{p+1} sem Lipschitz."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Análise em Método RK Específico",
                                  "subSteps": [
                                    "Escolher um método RK de ordem 4 (ex: clássico RK4).",
                                    "Calcular erro local explicitamente para f suave.",
                                    "Implementar num código e computar erros global para h variados.",
                                    "Confirmar ordem p=4 via log-log: slope ≈4.",
                                    "Analisar sensibilidade a p≥4 com método de ordem 5 se disponível."
                                  ],
                                  "verification": "Gerar tabela/plots mostrando ||e_global|| ~ h^4.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/Jupyter com numpy/scipy.integrate, problema não-linear y'=y(1-y).",
                                  "tips": "Use solve_ivp com método='RK45' para comparação; plote em escala log.",
                                  "learningObjective": "Aplicar derivação teórica em prática computacional para validação.",
                                  "commonMistakes": "Escolha ruim de problema teste (não suave); erros de implementação em Butcher."
                                }
                              ],
                              "practicalExample": "Para o método RK4 clássico resolvendo y' = -y, y(0)=1 até t=1: erro local ≈ (h^5 / 2880) y^{(5)}(ξ); erro global ≈ (e^{-1}-1)/5 * (1/2880) h^4 ≈ 0.0067 h^4, confirmado numericamente com h=0.1: erro≈6.7e-6.",
                              "finalVerifications": [
                                "Derivação correta de ψ(h)=O(h^{p+1}) com coeficiente líder.",
                                "Estimativa global |e(T)| ≤ M h^p com M explícito.",
                                "Plot log-log confirma slope p para p≥4.",
                                "Análise de estabilidade via Lipschitz.",
                                "Código implementado reproduz ordens teóricas.",
                                "Identificação de condições de ordem extras para p>4."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão Taylor e uso de Butcher (80%).",
                                "Correção na derivação global via acumulação/estabilidade (90%).",
                                "Validação numérica com convergência observada (85%).",
                                "Clareza em expressões matemáticas e plots.",
                                "Tratamento de casos p≥4 específicos (ex: ordem 5).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers RK em Python/MATLAB.",
                                "Física: Simulações de EDOs em mecânica orbital.",
                                "Estatística: Análise de erro em modelagem estocástica.",
                                "Engenharia: Controle de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA), previsão numérica do tempo (modelos ECMWF) e farmacocinética (simulação de difusão de drogas), onde análise de erro garante precisão em passos adaptativos para h pequeno."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Avaliar estabilidade",
                            "description": "Construir o polinômio de estabilidade para RK4 e analisar o domínio de estabilidade absoluto no plano complexo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método RK4 e o conceito de polinômio de estabilidade",
                                  "subSteps": [
                                    "Lembre-se da fórmula do método RK4 clássico para y' = f(t,y): k1 = h f(t_n, y_n), k2 = h f(t_n + h/2, y_n + k1/2), k3 = h f(t_n + h/2, y_n + k2/2), k4 = h f(t_n + h, y_n + k3), y_{n+1} = y_n + (k1 + 2k2 + 2k3 + k4)/6.",
                                    "Considere o problema teste y' = λ y, onde λ é complexo, e z = h λ.",
                                    "Entenda que o polinômio de estabilidade R(z) satisfaz y_{n+1} = R(z) y_n para este problema linear.",
                                    "Defina o domínio de estabilidade absoluto como {z ∈ ℂ : |R(z)| ≤ 1}.",
                                    "Anote as propriedades esperadas para métodos explícitos como RK4 (domínio finito)."
                                  ],
                                  "verification": "Escreva corretamente a fórmula do RK4 e defina R(z) verbalmente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de Análise Numérica",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece pelo problema teste simples para isolar o comportamento de estabilidade.",
                                  "learningObjective": "Compreender a base teórica do polinômio de estabilidade no contexto de RK4.",
                                  "commonMistakes": "Confundir ordem do método com o grau do polinômio (RK4 tem grau 4); ignorar que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de amplificação R(z) para RK4",
                                  "subSteps": [
                                    "Substitua f(t,y) = λ y no esquema RK4, obtendo expressões para k1, k2, k3, k4 em termos de y_n e z.",
                                    "Calcule k1 = z y_n, k2 = z (y_n + k1/2) = z y_n (1 + z/2), k3 = z y_n (1 + z/2 + (z/2)^2 / 2), k4 = z y_n (1 + z + z^2 / 2 + z^3 / 6).",
                                    "Some: y_{n+1}/y_n = 1 + z + (1/2) z^2 + (1/6) z^3 + (1/24) z^4.",
                                    "Verifique expandindo as séries de k2, k3, k4 corretamente.",
                                    "Simplifique para obter R(z) = 1 + z + z²/2! + z³/3! + z⁴/4!."
                                  ],
                                  "verification": "Derive R(z) algebricamente e confirme que coincide com a expansão da função exponencial truncada e^z ≈ ∑_{k=0}^4 z^k / k!.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy/Python",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use fatoração y_n em cada k_i para simplificar; compute passo a passo.",
                                  "learningObjective": "Derivar com precisão a função de amplificação para métodos RK específicos.",
                                  "commonMistakes": "Erro nos coeficientes de Butcher para RK4 (lembre: pesos 1/6,1/3,1/3,1/6); esquecer termos em k4."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e representar o polinômio de estabilidade",
                                  "subSteps": [
                                    "Escreva R(z) = ∑_{k=0}^4 z^k / k! explicitamente.",
                                    "Implemente R(z) em software para avaliação numérica (ex: Python com complexos).",
                                    "Teste valores conhecidos: R(0)=1, R'(0)=1, etc., para verificação de ordem.",
                                    "Gere uma grade no plano complexo z = x + i y, com x,y de -5 a 0 (foco em região estável).",
                                    "Calcule |R(z)| para pontos da grade."
                                  ],
                                  "verification": "R(z) deve ser um polinômio de grau 4 com coeficientes exatos 1,1,1/2,1/6,1/24.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "Ou MATLAB/Octave"
                                  ],
                                  "tips": "Use meshgrid para eficiência computacional em grades.",
                                  "learningObjective": "Implementar e validar o polinômio de estabilidade computacionalmente.",
                                  "commonMistakes": "Usar aproximação numérica em vez de exata para coeficientes; grid muito grosseira."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o domínio de estabilidade absoluto no plano complexo",
                                  "subSteps": [
                                    "Plote o contorno |R(z)| = 1 usando contour plot de |R(x+iy)|.",
                                    "Identifique a região onde |R(z)| ≤ 1, tipicamente um lóbulo no semiplano esquerdo.",
                                    "Meça o intervalo de estabilidade real: encontre max |h| tal que |R(h λ)| ≤1 para λ<0 real.",
                                    "Compare com métodos de ordem inferior (ex: RK2 tem domínio menor).",
                                    "Descreva qualitativamente: área aproximada, formato (não circular)."
                                  ],
                                  "verification": "O plot mostra região estável contida em Re(z) < 0, com extensão real cerca de 2.78.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de plotagem (matplotlib contourf)",
                                    "Referência com plots conhecidos de RK4"
                                  ],
                                  "tips": "Use logscale para |R| >1; foque em Re(z) ≤0 pois instável para Re(z)>0.",
                                  "learningObjective": "Interpretar graficamente o domínio de estabilidade e suas implicações.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; plotar apenas eixo real."
                                }
                              ],
                              "practicalExample": "Implemente em Python: def R(z): return 1 + z + z**2/2 + z**3/6 + z**4/24; crie grade x = np.linspace(-5,0,100), y=np.linspace(-3,3,100); Z = x[None,:]+1j*y[:,None]; plt.contourf(x,y,np.abs(R(Z)), levels=[0,1,2]); plt.contour(x,y,np.abs(R(Z)), levels=[1]); resulta em lóbulo estável com largura ~2.78 no eixo real.",
                              "finalVerifications": [
                                "R(z) derivado corretamente com coeficientes exatos.",
                                "Plot do domínio |R(z)| ≤1 mostra região finita no semiplano esquerdo.",
                                "Valor limite real: z ≈ -2.7853 onde |R(z)|=1.",
                                "Comparação qualitativa com e^z (aproximação boa dentro do domínio).",
                                "Código Python executável e reproduzível.",
                                "Descrição escrita do formato e tamanho do domínio."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de R(z) (100% coeficientes corretos).",
                                "Qualidade do plot: resolução suficiente, legenda, eixos rotulados.",
                                "Interpretação correta: identificação do domínio absoluto.",
                                "Análise quantitativa: medida do raio de estabilidade real.",
                                "Validação numérica: testes em pontos críticos.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores harmônicos (λ imaginário puro).",
                                "Computação: Implementação de solvers numéricos em SciPy (solve_ivp com method='RK45').",
                                "Engenharia: Análise de rigidez em EDOs de circuitos elétricos.",
                                "Estatística: Estabilidade em simulações Monte Carlo de processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações numéricas de sistemas dinâmicos rígidos, como modelagem de reações químicas (λ com grandes partes negativas) ou epidemias (sistemas de Lotka-Volterra), o domínio de estabilidade do RK4 dita o passo h máximo para evitar instabilidade numérica, otimizando precisão e eficiência computacional em softwares como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Comparar com métodos de baixa ordem",
                            "description": "Comparar eficiência computacional (custo por passo vs. precisão) de RK4 com Euler e Heun, usando exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmulas e custos computacionais dos métodos",
                                  "subSteps": [
                                    "Escreva a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Escreva a fórmula do método de Heun (RK2): predictor y_p = y_n + h f(t_n, y_n), então y_{n+1} = y_n + (h/2)(f(t_n, y_n) + f(t_{n+1}, y_p)).",
                                    "Escreva a fórmula do RK4: k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + h k1/2), k3 = f(t_n + h/2, y_n + h k2/2), k4 = f(t_n + h, y_n + h k3), y_{n+1} = y_n + (h/6)(k1 + 2k2 + 2k3 + k4).",
                                    "Identifique o custo por passo: Euler (1 avaliação de f), Heun (2 avaliações), RK4 (4 avaliações).",
                                    "Calcule ordem de precisão: Euler O(h^2), Heun O(h^3), RK4 O(h^5)."
                                  ],
                                  "verification": "Liste corretamente as fórmulas, custos e ordens em uma tabela comparativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, caneta ou editor de texto; tabela de referência de métodos numéricos.",
                                  "tips": "Use notação consistente para k_i no RK4 para evitar confusão.",
                                  "learningObjective": "Compreender as diferenças fundamentais em custo e precisão local dos métodos.",
                                  "commonMistakes": "Confundir número de estágios (avaliações de f) com ordem de precisão; errar coeficientes no RK4."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e resolver um problema de valor inicial (PVI) exemplo",
                                  "subSteps": [
                                    "Escolha o PVI: y' = -2y, y(0) = 1, t de 0 a 1 (solução exata y = e^{-2t}).",
                                    "Implemente ou calcule manualmente soluções com h=0.2 para Euler, Heun e RK4 em 5 passos.",
                                    "Calcule y numérica em t=1 para cada método e compare com y_exata(1) ≈ 0.1353.",
                                    "Registre erros absolutos: |y_num - y_exata|.",
                                    "Anote o custo total: número de passos × avaliações por passo."
                                  ],
                                  "verification": "Obtenha valores numéricos corretos para y(1) e erros para cada método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para cálculos; planilha para tabular resultados.",
                                  "tips": "Comece com h grande para ver diferenças claras, depois refine.",
                                  "learningObjective": "Aplicar os métodos a um PVI concreto e quantificar erros iniciais.",
                                  "commonMistakes": "Erro na solução exata ou aritmética nos k_i; esquecer de somar custos corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar precisão vs. custo ajustando o passo h",
                                  "subSteps": [
                                    "Para erro alvo ε=10^{-4}, estime h necessário: h ≈ ε^{1/p} onde p=ordem (2 para Euler, 3 Heun, 5 RK4).",
                                    "Calcule N_passos = 1/h para cada método e custo total = N_passos × avaliações/ passo.",
                                    "Repita cálculos com h ajustado para o exemplo, tabulando custo e erro real.",
                                    "Compare: custo Euler vs. Heun vs. RK4 para mesmo ε.",
                                    "Crie gráfico ou tabela de log(erros) vs. log(custo)."
                                  ],
                                  "verification": "Tabela mostra RK4 com custo menor que Euler para mesma precisão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Excel, Python matplotlib); caderno para estimativas.",
                                  "tips": "Use aproximação assintótica para h, valide com cálculo exato.",
                                  "learningObjective": "Quantificar trade-off custo-precisão global.",
                                  "commonMistakes": "Ignorar custo acumulado; usar precisão local em vez de global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar comparação e tirar conclusões",
                                  "subSteps": [
                                    "Resuma em tabela: método, ordem, custo/passo, h para ε, custo total.",
                                    "Discuta quando usar cada: Euler para protótipos rápidos, RK4 para precisão moderada.",
                                    "Teste com outro PVI (ex: y'=y(1-y), logística) para generalizar.",
                                    "Identifique limitações: custo RK4 alto para ordens >4.",
                                    "Escreva parágrafo conclusivo sobre eficiência."
                                  ],
                                  "verification": "Conclusão escrita justificada por dados numéricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto; tabelas dos passos anteriores.",
                                  "tips": "Foquem em métricas quantitativas, não opiniões.",
                                  "learningObjective": "Integrar análise para recomendação informada.",
                                  "commonMistakes": "Generalizar de um exemplo; negligenciar estabilidade."
                                }
                              ],
                              "practicalExample": "Para PVI y' = -2y, y(0)=1, t∈[0,1], com ε=10^{-4}: Euler precisa ~h=0.01 (N=100, custo=100), Heun h~0.046 (N=22, custo=44), RK4 h~0.18 (N=6, custo=24). RK4 é ~4x mais eficiente que Euler.",
                              "finalVerifications": [
                                "Tabela de custos e erros corretos para o exemplo.",
                                "Gráfico log-log de erro vs. custo mostrando inclinações de ordem.",
                                "Explicação verbal da superioridade de RK4 em custo-precisão.",
                                "Cálculo correto de h ótimo para cada método.",
                                "Comparação com pelo menos um PVI adicional.",
                                "Identificação de cenários onde Euler ainda é preferível (ex: custo extremo baixo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos numéricos (erro <1%).",
                                "Uso correto de métricas custo (avaliações de f).",
                                "Análise quantitativa com tabelas/gráficos.",
                                "Conclusões baseadas em dados, não intuição.",
                                "Consideração de ordens e trade-offs explícitos.",
                                "Generalização além do exemplo único."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação eficiente de algoritmos numéricos em programação.",
                                "Física: Simulações de movimento (ex: osciladores com ODEs).",
                                "Engenharia: Otimização de solvers em CAD/FEM.",
                                "Estatística: Análise de erro em modelagem preditiva."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou aerodinâmicas, RK4 equilibra precisão e tempo de CPU em software como MATLAB Simulink, reduzindo custos computacionais em 50-80% vs. métodos de baixa ordem para precisão similar."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Análise de Erro de Truncamento Local e Global",
                    "description": "Estudo dos erros locais por passo e erro global acumulado nos métodos de passo simples.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Erro de Truncamento Local",
                        "description": "Conceito fundamental que quantifica o erro introduzido em um único passo de integração numérica nos métodos de passo simples para problemas de valor inicial, derivado da expansão em série de Taylor da solução exata.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Definir e interpretar o Erro de Truncamento Local (TEL)",
                            "description": "Explicar o TEL como a diferença entre a solução exata e a aproximada após um passo, identificando sua origem na aproximação polinomial da derivada e expressando-o em termos de O(h^{p+1}), onde h é o tamanho do passo e p a ordem do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de erro em métodos numéricos",
                                  "subSteps": [
                                    "Diferencie erro de truncamento de erro de arredondamento em aproximações numéricas.",
                                    "Identifique que o erro de truncamento surge de aproximações infinitas, como séries de Taylor.",
                                    "Revise métodos de passo simples para problemas de valor inicial (PVI), como o método de Euler.",
                                    "Analise como soluções numéricas aproximam soluções exatas em um passo.",
                                    "Estude a equação diferencial y' = f(x,y) e sua discretização básica."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre os dois tipos de erro e dê um exemplo de cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de PVI)",
                                    "Folha de papel e caneta para anotações",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use analogias: truncamento é como cortar uma história infinita; arredondamento é limitação da régua.",
                                  "learningObjective": "Distinguir erros numéricos e contextualizar truncamento em métodos para PVI.",
                                  "commonMistakes": [
                                    "Confundir truncamento com arredondamento",
                                    "Ignorar o contexto de PVI",
                                    "Não relacionar com discretização temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Erro de Truncamento Local (TEL)",
                                  "subSteps": [
                                    "Defina TEL como a diferença entre a solução exata y(x_n + h) e a aproximada y_{n+1} após exatamente um passo de tamanho h.",
                                    "Escreva matematicamente: TEL = y(x_n + h) - y_{n+1}.",
                                    "Explique que é 'local' porque considera apenas um passo, ignorando erros acumulados.",
                                    "Compare com erro global, que acumula sobre múltiplos passos.",
                                    "Discuta independência inicial de condições iniciais exatas."
                                  ],
                                  "verification": "Escreva a definição formal do TEL e distinga de erro global em um parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou software de desenho (ex: GeoGebra)",
                                    "Notas da aula sobre PVI",
                                    "Exemplos de métodos como Euler e Heun"
                                  ],
                                  "tips": "Memorize a fórmula chave: foque no 'após um passo' para enfatizar o aspecto local.",
                                  "learningObjective": "Formular precisamente a definição de TEL e seu escopo.",
                                  "commonMistakes": [
                                    "Definir TEL como erro total",
                                    "Confundir com erro por passo acumulado",
                                    "Omitir o papel de h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a origem do TEL na aproximação polinomial da derivada",
                                  "subSteps": [
                                    "Revise a expansão de Taylor para y(x_n + h) em torno de x_n.",
                                    "Mostre como métodos numéricos usam polinômios de grau p para aproximar y'.",
                                    "Derive que o resíduo da Taylor gera o TEL devido aos termos desprezados.",
                                    "Ilustre com p=1 (método de Euler): truncamento dos termos h^2/2 e superiores.",
                                    "Generalize para métodos de ordem p, onde os primeiros p termos são exatos."
                                  ],
                                  "verification": "Derive a expansão de Taylor para um método simples e identifique o termo de truncamento.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Papel para derivações",
                                    "Tabela de expansões de Taylor"
                                  ],
                                  "tips": "Desenhe a série de Taylor graficamente para visualizar termos truncados.",
                                  "learningObjective": "Traçar a origem do TEL à truncagem polinomial via Taylor.",
                                  "commonMistakes": [
                                    "Esquecer termos pares/ímpares",
                                    "Não especificar o ponto de expansão",
                                    "Confundir derivada com integral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar e interpretar o TEL em termos de O(h^{p+1})",
                                  "subSteps": [
                                    "Escreva TEL = O(h^{p+1}) como notação assintótica para h → 0.",
                                    "Explique que significa |TEL| ≤ C h^{p+1} para constante C e h pequeno.",
                                    "Interprete: ordem p implica precisão cresce como h^{p+1} por passo.",
                                    "Discuta implicações: h menor reduz TEL, mas aumenta custo computacional.",
                                    "Verifique com exemplo numérico simples."
                                  ],
                                  "verification": "Calcule TEL para um método de ordem p e confirme a ordem assintótica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB para plotar erro vs. h (log-log)",
                                    "Exemplo analítico resolvível como y' = y"
                                  ],
                                  "tips": "Use gráfico log-log: inclinação - (p+1) confirma a ordem.",
                                  "learningObjective": "Dominar a notação big-O e sua interpretação prática para TEL.",
                                  "commonMistakes": [
                                    "Confundir O(h^{p+1}) com O(h^p)",
                                    "Ignorar dependência em derivadas de ordem superior",
                                    "Não considerar h → 0"
                                  ]
                                }
                              ],
                              "practicalExample": "No método de Euler (p=1) para y' = y, y(0)=1, com h=0.1: solução exata y(0.1) ≈ 1.10517, aproximada y1 = 1 + 0.1*1 = 1.1, TEL ≈ 0.00517 ≈ (0.1)^2 / 2 * y''(ξ) = O(h^2). Reduzindo h para 0.05, TEL cai para ~0.00125, confirmando ordem 2.",
                              "finalVerifications": [
                                "Defina TEL corretamente em termos de y exata vs. aproximada após um passo.",
                                "Derive origem via Taylor para método de Euler.",
                                "Expresse TEL como O(h^{p+1}) e explique big-O.",
                                "Distinga TEL de erro global.",
                                "Calcule TEL numericamente para um exemplo simples.",
                                "Interprete impacto de h na precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição de TEL (20%)",
                                "Correta derivação da origem polinomial/Taylor (30%)",
                                "Domínio da notação assintótica O(h^{p+1}) (20%)",
                                "Capacidade de distinção de conceitos relacionados (15%)",
                                "Exemplos práticos e cálculos corretos (10%)",
                                "Interpretação qualitativa e quantitativa (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar métodos numéricos em Python e medir TEL empiricamente.",
                                "Física: Análise de erro em simulações de movimento (e.g., oscilador harmônico).",
                                "Engenharia Computacional: Otimização de h em solvers de EDOs industriais.",
                                "Estatística: Estudo de convergência e análise de resíduos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão de epidemias, onde métodos numéricos resolvem EDOs; entender TEL permite escolher h ótimo para balancear precisão e tempo de computação em supercomputadores, evitando erros catastróficos em previsões de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Derivar o TEL para o método de Euler explícito",
                            "description": "Utilizar a expansão em série de Taylor da função f(t,y) para derivar o TEL do método de Euler como (1/2)h^2 y''(ξ), demonstrando a ordem local de precisão 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar o Problema de Valor Inicial (PVI) e o Método de Euler Explícito",
                                  "subSteps": [
                                    "Defina o PVI: y' = f(t, y), y(t₀) = y₀.",
                                    "Descreva o método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Explique o conceito de Erro de Truncamento Local (TEL): diferença entre y(t_n + h) exata e a aproximação assumindo y_n exato.",
                                    "Identifique que o TEL é o erro assumindo entrada exata.",
                                    "Escreva a fórmula do TEL: TEL = y(t_n + h) - y_n - h f(t_n, y_n)."
                                  ],
                                  "verification": "Escreva corretamente as fórmulas do PVI, Euler e TEL em um papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica (capítulo de métodos numéricos)"
                                  ],
                                  "tips": "Visualize o método de Euler como uma reta tangente aproximando a curva solução.",
                                  "learningObjective": "Compreender a base conceitual do método de Euler e o que o TEL representa.",
                                  "commonMistakes": [
                                    "Confundir TEL com erro global",
                                    "Esquecer que y_n é assumido exato no cálculo local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir a Solução Exata y(t_n + h) em Série de Taylor",
                                  "subSteps": [
                                    "Aplique a expansão de Taylor ao redor de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h²/2) y''(ξ) para algum ξ em (t_n, t_n + h).",
                                    "Substitua y'(t_n) = f(t_n, y(t_n)).",
                                    "Mantenha o resto como O(h²), focando nos termos até ordem 1.",
                                    "Escreva explicitamente: y(t_n + h) = y(t_n) + h f(t_n, y(t_n)) + (h²/2) y''(ξ).",
                                    "Note que ξ é desconhecido, justificando o uso de notação big-O."
                                  ],
                                  "verification": "Derive e escreva a expansão de Taylor com os dois primeiros termos e o resto correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de fórmulas de Taylor"
                                  ],
                                  "tips": "Lembre-se: a série de Taylor é local e requer derivadas contínuas.",
                                  "learningObjective": "Aplicar corretamente a expansão de Taylor à solução do PVI.",
                                  "commonMistakes": [
                                    "Usar mais termos desnecessários",
                                    "Confundir y'(t_n) com f(t_n, y_n) onde y_n ≠ y(t_n)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Segunda Derivada y''(ξ) em Termos de f",
                                  "subSteps": [
                                    "Diferencie y' = f(t, y): y'' = d/dt f(t, y(t)) = f_t + f_y y' = f_t + f_y f.",
                                    "Escreva y''(t) = ∂f/∂t (t, y(t)) + ∂f/∂y (t, y(t)) f(t, y(t)).",
                                    "Avalie em ξ: y''(ξ) = f_t(ξ, y(ξ)) + f_y(ξ, y(ξ)) f(ξ, y(ξ)).",
                                    "Substitua na expansão: TEL = (h²/2) [f_t + f_y f](ξ, y(ξ)).",
                                    "Confirme que isso é O(h²)."
                                  ],
                                  "verification": "Mostre a derivação de y'' passo a passo, usando regra da cadeia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas sobre derivadas parciais"
                                  ],
                                  "tips": "Use notação clara para derivadas parciais: f_t e f_y.",
                                  "learningObjective": "Expressar derivadas superiores da solução em termos da função f.",
                                  "commonMistakes": [
                                    "Esquecer a regra da cadeia em y''",
                                    "Avaliar y'' em t_n ao invés de ξ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir o TEL e Demonstrar a Ordem de Precisão Local 1",
                                  "subSteps": [
                                    "Subtraia a iteração de Euler da expansão: TEL = y(t_n + h) - [y_n + h f(t_n, y_n)] = (h²/2) y''(ξ), assumindo y_n = y(t_n).",
                                    "Identifique o termo dominante O(h²).",
                                    "Defina ordem de precisão local: consistência de ordem p se TEL = O(h^{p+1}).",
                                    "Conclua que para Euler, p=1 pois O(h²).",
                                    "Discuta implicações: erro local acumula para erro global O(h)."
                                  ],
                                  "verification": "Escreva a expressão final do TEL e justifique a ordem 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo resolvido de livro-texto"
                                  ],
                                  "tips": "Sempre normalize pelo h para ver a ordem.",
                                  "learningObjective": "Identificar e demonstrar a ordem de truncamento do método.",
                                  "commonMistakes": [
                                    "Dizer ordem 2 por confundir com O(h²)",
                                    "Ignorar o fator 1/2"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (solução y=e^t), método Euler: y_{n+1}=y_n + h y_n = y_n (1+h). Expansão: e^{t_n + h} = e^{t_n} (1 + h + h²/2 + ...), TEL ≈ (h²/2) e^ξ, confirmando O(h²).",
                              "finalVerifications": [
                                "Escreve corretamente a expansão de Taylor de y(t_n + h).",
                                "Deriva y''(ξ) = f_t + f_y f sem erros.",
                                "Identifica TEL = (1/2) h² y''(ξ).",
                                "Explica a ordem local de precisão como 1.",
                                "Aplica a um exemplo simples como y'=y."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da série de Taylor (100% dos termos corretos).",
                                "Correta aplicação da regra da cadeia para y''.",
                                "Identificação clara do termo de erro O(h²) e ordem 1.",
                                "Expressão do TEL na forma exata com ξ.",
                                "Capacidade de generalizar para qualquer f suave.",
                                "Clareza na escrita matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de movimento (e.g., método de Euler em dinâmica).",
                                "Programação: Implementação numérica em Python/MATLAB para validar TEL.",
                                "Cálculo: Uso avançado de séries de Taylor e derivadas parciais.",
                                "Engenharia: Modelagem de sistemas diferenciais em controle automático."
                              ],
                              "realWorldApplication": "Em simulações numéricas de trajetórias espaciais (NASA), previsão de epidemias (modelos SIR) ou finanças (equações de Black-Scholes), entender o TEL do Euler guia a escolha de h para precisão aceitável sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Analisar a ordem do TEL em métodos de Runge-Kutta de ordem p",
                            "description": "Generalizar a derivação do TEL para métodos RK de ordem p, mostrando que o erro local é O(h^{p+1}) através do princípio da consistência e da árvore de Butcher.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Estrutura de Métodos Runge-Kutta de Ordem p",
                                  "subSteps": [
                                    "Relembrar a forma geral de um método RK: y_{n+1} = y_n + h ∑ b_i k_i, onde k_i = f(t_n + c_i h, y_n + h ∑ a_{ij} k_j).",
                                    "Entender que ordem p significa consistência de ordem p, i.e., o método aproxima a solução exata com erro local O(h^{p+1}).",
                                    "Discutir o princípio da consistência: para ordem p, as condições de ordem até p devem ser satisfeitas.",
                                    "Estudar a representação em tabela de Butcher: A (s x s), b (1 x s), c (s x 1).",
                                    "Exemplificar com RK2 e RK4 para visualizar padrões."
                                  ],
                                  "verification": "Escrever a tabela de Butcher para RK4 e listar as condições de ordem p=4.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos RK",
                                    "Software simbólico como SymPy para tabelas Butcher"
                                  ],
                                  "tips": "Comece com métodos de baixa ordem para construir intuição antes de generalizar.",
                                  "learningObjective": "Compreender a estrutura matricial e as condições básicas para ordem p em RK.",
                                  "commonMistakes": [
                                    "Confundir ordem do método com número de estágios s; lembrar que s >= p geralmente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Árvores de Butcher e Séries Elementares",
                                  "subSteps": [
                                    "Definir árvores de Butcher: árvores T com nós rotulados, raiz vazia, e densidade φ(T).",
                                    "Explicar séries elementares: F(T) = 1/φ(T) ∏_{i→j em T} γ_j, onde γ são pesos elementares.",
                                    "Listar árvores até ordem 4 e calcular suas densidades e séries elementares.",
                                    "Relacionar com expansão de Taylor da solução exata: y(t_n + h) = y(t_n) + h ∑_{k=1}^∞ h^{k-1}/k! Y^{(k)}(t_n).",
                                    "Mostrar como o método RK gera uma série B( h f(y) ) que deve casar com a exata até ordem p."
                                  ],
                                  "verification": "Desenhar árvores de ordem 1,2,3 e calcular F(T) para cada uma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de árvores de Butcher (até ordem 5)",
                                    "Papel e lápis para desenhar árvores",
                                    "Referência: Hairer et al. 'Solving ODEs I'"
                                  ],
                                  "tips": "Use diagramas visuais para árvores; memorize densidades comuns: [1]=1, [τ]=1/2, [τ,τ]=1/3.",
                                  "learningObjective": "Dominar o formalismo das árvores de Butcher como base para análise de ordem.",
                                  "commonMistakes": [
                                    "Erro no cálculo de φ(T): contar ramificações corretamente; [τ,τ] tem φ=2, não 1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Condições de Ordem para Métodos RK de Ordem p",
                                  "subSteps": [
                                    "Estabelecer as condições de ordem k: ∑ b_i F(T)(c_i,A) = 1/σ(T) para cada árvore T de ordem |T|=k.",
                                    "Derivar condições simples: ordem 1: ∑ b_i =1; ordem 2: ∑ b_i c_i =1/2; ordem 3: ∑ b_i c_i^2/2 + ∑ b_i ∑ a_{ij} c_j =1/3.",
                                    "Generalizar para ordem p: o método satisfaz condições para todas árvores até |T|=p.",
                                    "Mostrar que se condições até p são satisfeitas, as expansões casam até h^p, implicando TEL = O(h^{p+1}).",
                                    "Verificar para RK4: listar e confirmar as 8 condições de ordem 4."
                                  ],
                                  "verification": "Escrever as condições de ordem 1-3 explicitamente e verificar para método de Heun (RK2).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para simplificação simbólica",
                                    "Lista de condições de ordem padrão",
                                    "Exemplos resolvidos de livros-textos"
                                  ],
                                  "tips": "Agrupe condições por tipo (simples, composto); use soma sobre i,j para eficiência.",
                                  "learningObjective": "Aplicar princípio da consistência via matching de séries de Butcher para provar ordem p.",
                                  "commonMistakes": [
                                    "Esquecer fator 1/σ(T) nas condições; σ(T)=|T|! / φ(T)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Analisar o Erro de Truncamento Local (TEL)",
                                  "subSteps": [
                                    "Definir TEL: ψ = [y(t_n + h) - y_n]/h - Φ(h f(y_n)), onde Φ é o incremento numérico.",
                                    "Mostrar que ψ = O(h^{p+1}) se ordem p é satisfeita, pois primeiros p termos cancelam.",
                                    "Expandir ψ em série: próximo termo é soma sobre árvores de ordem p+1 de [1/σ(T) - ∑ b_i F(T)(c_i,A)] h^{p+1}/(p+1)!.",
                                    "Concluir que ordem p implica ||ψ|| = O(h^{p+1}), ligando à estabilidade para erro global.",
                                    "Testar numericamente com ODE simples como y'=y, comparando soluções exata e RKp."
                                  ],
                                  "verification": "Derivar explicitamente ψ para RK1 (Euler) mostrando O(h^2).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB para simulação numérica",
                                    "Código para tabelas Butcher",
                                    "Artigo sobre análise de ordem RK"
                                  ],
                                  "tips": "Implemente um solver RK genérico para validar teoria com h variando.",
                                  "learningObjective": "Generalizar derivação do TEL para RKp e provar O(h^{p+1}).",
                                  "commonMistakes": [
                                    "Confundir TEL com TGE; TEL é por passo, TGE acumula."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método RK4 (p=4), desenhe as árvores até ordem 4, verifique as 8 condições (∑b_i=1, ∑b_i c_i=1/2, etc.), e mostre que o primeiro termo não-zero em ψ é proporcional a h^5, confirmando TEL=O(h^5). Simule y'= -y, y(0)=1 com h=0.1 e compare erro local.",
                              "finalVerifications": [
                                "Pode listar e derivar condições de ordem 1-4 para um método RK arbitrário.",
                                "Desenha corretamente árvores de Butcher até ordem 4 com densidades φ(T).",
                                "Deriva ψ[h] = O(h^{p+1}) a partir do mismatch na ordem p+1.",
                                "Verifica numericamente que erro local escala como h^{p+1} para RK2 e RK4.",
                                "Explica ligação entre consistência de ordem p e TEL O(h^{p+1}).",
                                "Identifica por que métodos com s < p+1 podem ter ordem p (ex: Gauss).",
                                "Aplica a um método RK não-clássico, como Ralston."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das condições de ordem usando árvores de Butcher (90% correto).",
                                "Correção no cálculo de séries elementares F(T) e matching com Taylor exata.",
                                "Clareza na prova de que ordem p implica TEL = O(h^{p+1}).",
                                "Uso correto de notação Butcher e identificação de termos de erro.",
                                "Capacidade de generalizar para qualquer p, não só exemplos fixos.",
                                "Análise numérica de suporte mostrando convergência O(h^{p+1})."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações de osciladores harmônicos com RK.",
                                "Computação: Implementação eficiente de RK adaptativo em solvers ODE (SciPy).",
                                "Engenharia: Modelagem de circuitos RLC onde ordem alta reduz erro em trajetórias.",
                                "Estatística: Integração estocástica via métodos RK para SDEs."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, métodos RK de ordem 4-6 são usados para integrar equações de movimento de satélites, onde analisar TEL garante precisão orbital com passos h grandes, otimizando tempo computacional em missões da NASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.4",
                            "name": "Calcular numericamente o TEL em um exemplo simples",
                            "description": "Implementar um método de passo simples em código (ex: Python/MATLAB) para y' = -y, y(0)=1, computar o TEL comparando solução exata e numérica em um passo h fixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e derivar a solução exata",
                                  "subSteps": [
                                    "Escreva a equação diferencial y' = -y com condição inicial y(0) = 1.",
                                    "Resolva analiticamente para obter y(t) = e^{-t}.",
                                    "Escolha um passo h fixo, como h = 0.1, e compute y(h) exata usando exp(-h).",
                                    "Documente os valores exatos em um notebook ou script.",
                                    "Verifique se a solução satisfaz a EDO e condição inicial."
                                  ],
                                  "verification": "Confirme que y(h) = exp(-h) ≈ 0.9048 para h=0.1 e que y'(t) = -e^{-t} = -y(t).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica ou Python (import math) para exp(-h), papel e caneta.",
                                  "tips": "Use a função exp() em Python para precisão; evite aproximações manuais grosseiras.",
                                  "learningObjective": "Compreender e computar soluções exatas de EDOs lineares simples.",
                                  "commonMistakes": "Confundir y(t) = e^{-t} com e^{t}; esquecer a condição inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de Euler forward em código",
                                  "subSteps": [
                                    "Abra um editor Python (ex: Jupyter Notebook ou VS Code).",
                                    "Defina a função f(t,y) = -y.",
                                    "Escreva o algoritmo de Euler: y_{n+1} = y_n + h * f(t_n, y_n), para um passo (n=0 a 1).",
                                    "Inicialize y0=1, t0=0, e execute para t1=h.",
                                    "Imprima y1 numérica."
                                  ],
                                  "verification": "Execute o código e confirme y1 = 1 - h (ex: 0.9 para h=0.1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python instalado, Jupyter Notebook ou IDLE, biblioteca math (opcional).",
                                  "tips": "Teste com h pequeno primeiro; use print() para depurar valores intermediários.",
                                  "learningObjective": "Implementar corretamente o método de Euler para um passo único.",
                                  "commonMistakes": "Usar y' em vez de f(t,y); erro de sinal em f(t,y) = -y."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulação numérica e computar solução exata no mesmo ponto",
                                  "subSteps": [
                                    "No mesmo script, compute y_exata = math.exp(-h).",
                                    "Execute o Euler para obter y_numerica.",
                                    "Registre ambos os valores com alta precisão (ex: 10 casas decimais).",
                                    "Calcule o erro absoluto TEL = |y_exata - y_numerica|.",
                                    "Plote ou tabule os valores para visualização."
                                  ],
                                  "verification": "Para h=0.1, y_numerica ≈ 0.9000, y_exata ≈ 0.9048, TEL ≈ 0.0048.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com math e matplotlib (para plot opcional).",
                                  "tips": "Use formatação '{:.10f}' para precisão; compare múltiplos h para insight.",
                                  "learningObjective": "Comparar soluções exata e numérica em um intervalo específico.",
                                  "commonMistakes": "Arredondar prematuramente; confundir TEL com TEG (erro global)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar o TEL numericamente",
                                  "subSteps": [
                                    "Compare TEL computado com aproximação teórica O(h^2) para Euler.",
                                    "Teste com outro h (ex: h=0.05) e verifique se TEL diminui quadraticamente.",
                                    "Documente resultados em tabela: h, y_num, y_ex, TEL.",
                                    "Discuta implicações para estabilidade e precisão.",
                                    "Salve o script como 'calculo_tel_exemplo.py'."
                                  ],
                                  "verification": "Confirme que TEL(h=0.1)/TEL(h=0.05) ≈ 4, indicando ordem 2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo script Python anterior.",
                                  "tips": "Use loops para múltiplos h; grafique log(TEL) vs log(h) para ordem.",
                                  "learningObjective": "Interpretar numericamente o erro de truncamento local e sua ordem.",
                                  "commonMistakes": "Confundir truncamento local com propagação de erro global; ignorar precisão numérica."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1 em Python:\n```python\nimport math\nh = 0.1\ny0 = 1.0\nt0 = 0.0\ny1 = y0 + h * (-y0)  # Euler: 0.9\ny_exata = math.exp(-h)  # ≈0.9048374180\nTEL = abs(y_exata - y1)  # ≈0.0048374180\nprint(f'TEL: {TEL}')\n```\nResultado: TEL ≈ 4.84e-3, compatível com (h^2)/2 ≈ 0.005.",
                              "finalVerifications": [
                                "Código executa sem erros e produz y_numerica = 1 - h.",
                                "Solução exata y(h) = exp(-h) está correta (verificada manualmente).",
                                "TEL é calculado como |y_exata - y_numerica| com precisão de 6 dígitos.",
                                "Teste com h=0.05 mostra TEL reduzido por fator ≈4.",
                                "Tabela ou gráfico confirma comportamento quadrático do erro.",
                                "Explicação escrita liga resultado numérico à teoria de TEL O(h^2)."
                              ],
                              "assessmentCriteria": [
                                "Precisão do código de Euler (sem erros de implementação).",
                                "Correção da solução exata e cálculo de TEL.",
                                "Análise qualitativa/quantitativa do erro (ordem observada).",
                                "Clareza da documentação e comentários no código.",
                                "Capacidade de generalizar para outros h ou EDOs similares.",
                                "Uso adequado de precisão numérica e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos numéricos em Python.",
                                "Física: Modelagem de decaimento exponencial (ex: radioatividade).",
                                "Estatística: Análise de erro e validação numérica.",
                                "Engenharia Computacional: Bases para solvers de EDOs em simulações."
                              ],
                              "realWorldApplication": "Em simulações de decaimento radioativo ou populações biológicas, calcular TEL garante precisão em previsões curtas (um passo), essencial para farmacocinética ou controle de reações químicas onde erros locais se acumulam."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Erro de Truncamento Global",
                        "description": "Estudo do erro acumulado ao longo de múltiplos passos nos métodos de passo simples, resultante da propagação e soma dos erros locais, com análise de sua dependência no intervalo total e tamanho do passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Definir e relacionar o Erro de Truncamento Global (TEG) com o TEL",
                            "description": "Descrever o TEG como a soma telescópica dos TELs ao longo de N passos, onde N ≈ T/h, e explicar que para métodos consistentes e estáveis, TEG = O(h^p).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Erro de Truncamento Local (TEL)",
                                  "subSteps": [
                                    "Relembre a definição de TEL como o erro introduzido em um único passo de integração numérica devido à aproximação do método.",
                                    "Identifique a ordem do TEL, tipicamente O(h^{p+1}) para métodos de ordem p.",
                                    "Discuta como o TEL é calculado comparando a solução exata com a aproximada após um passo.",
                                    "Examine exemplos de métodos como Euler forward, onde TEL = O(h^2).",
                                    "Anote as componentes do TEL: erro na derivada e propagação local."
                                  ],
                                  "verification": "Escreva uma definição precisa do TEL e calcule-o para um método simples como Euler em um passo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Apostila de Análise Numérica, calculadora ou software como Python/MATLAB para um passo de exemplo.",
                                  "tips": "Use a expansão em série de Taylor para visualizar o TEL de forma intuitiva.",
                                  "learningObjective": "Compreender o TEL como base para o TEG.",
                                  "commonMistakes": "Confundir TEL com erro total ou arredondamento; ignorar a ordem de precisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Acumulação de Erros Locais ao Longo de Múltiplos Passos",
                                  "subSteps": [
                                    "Visualize o problema de valor inicial (PVI) em [0,T] dividido em N passos com tamanho h = T/N.",
                                    "Explique que cada passo introduz um TEL independente.",
                                    "Descreva a soma telescópica: o erro global surge da soma dos TELs propagados.",
                                    "Discuta a propagação dos erros devido à estabilidade do método.",
                                    "Calcule N ≈ T/h como o número de passos necessários."
                                  ],
                                  "verification": "Desenhe um diagrama de passos mostrando como erros locais se acumulam telescopicamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e lápis para diagrama, equação do PVI exemplo: y' = λy, y(0)=1.",
                                  "tips": "Pense no erro como uma 'soma de resíduos' em cada nó da malha.",
                                  "learningObjective": "Visualizar a relação quantitativa entre passos e acumulação de erro.",
                                  "commonMistakes": "Assumir que erros se cancelam; ignorar propagação por estabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação TEG ≈ N × TEL",
                                  "subSteps": [
                                    "Escreva a fórmula aproximada: TEG(t_n) ≈ ∑_{i=1}^n TEL(t_i) × fator de propagação.",
                                    "Simplifique para métodos estáveis: TEG ≈ N × TEL médio.",
                                    "Substitua N = T/h e TEL = O(h^{p+1}), obtendo TEG = O(h^p).",
                                    "Verifique com expansão formal usando solução exata da malha.",
                                    "Implemente uma soma numérica simples para validar."
                                  ],
                                  "verification": "Derive algebricamente TEG = O(h^p) a partir de N e TEL, mostrando os passos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de derivação, software para plotar erros com diferentes h.",
                                  "tips": "Use notação big-O para manter o foco na ordem de convergência.",
                                  "learningObjective": "Dominar a derivação matemática da relação TEG-TEL.",
                                  "commonMistakes": "Esquecer o fator de estabilidade; confundir ordens p e p+1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Condições de Consistência e Estabilidade para TEG = O(h^p)",
                                  "subSteps": [
                                    "Defina consistência: lim_{h→0} TEL/h^p = constante finita.",
                                    "Defina estabilidade: erros locais não amplificam exponencialmente.",
                                    "Explique o teorema: para métodos consistentes e estáveis, TEG = O(h^p).",
                                    "Discuta implicações: escolha de h baseada em tolerância de erro global.",
                                    "Compare com métodos instáveis onde TEG explode."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que consistência + estabilidade implicam convergência global.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referências teóricas (ex: livro de Burden & Faires), exemplos numéricos.",
                                  "tips": "Lembre-se: consistência controla TEL, estabilidade controla propagação.",
                                  "learningObjective": "Entender as hipóteses necessárias para a relação TEG-TEL.",
                                  "commonMistakes": "Omitir estabilidade, achando que consistência basta; confundir com convergência."
                                }
                              ],
                              "practicalExample": "Considere o PVI y' = y, y(0)=1 em [0,1] com método de Euler (p=1). Para h=0.1, N=10, TEL≈0.005/h=0.05, TEG≈10*0.005=0.05 (erro real ~0.07). Para h=0.05, N=20, TEG≈0.025, confirmando O(h). Implemente em Python e plote y_num - y_exata = e^{t}-1.",
                              "finalVerifications": [
                                "Define corretamente TEG como soma telescópica de TELs.",
                                "Calcula N = T/h e relaciona TEG ≈ (T/h) * TEL.",
                                "Explica TEG = O(h^p) para métodos consistentes e estáveis.",
                                "Identifica condições necessárias (consistência e estabilidade).",
                                "Aplica a relação em um exemplo numérico simples.",
                                "Distingue TEL de TEG e de erro de arredondamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e derivação da relação TEG-TEL (70%).",
                                "Correta identificação de ordens de precisão e big-O (20%).",
                                "Uso correto de conceitos de consistência e estabilidade (10%).",
                                "Clareza na explicação com exemplos ou diagramas.",
                                "Ausência de erros comuns como inversão de ordens p e p+1.",
                                "Capacidade de aplicar em contexto numérico prático."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Física: Análise de erro em simulações de movimento (ex: integradores em mecânica).",
                                "Engenharia: Otimização de passos h em simulações CFD ou controle.",
                                "Estatística: Estudo de convergência em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em modelagem climática, o TEG determina o tamanho de h para previsões precisas sem custo computacional excessivo; em finanças, controla erros em simulações de opções via Monte Carlo, garantindo precisão em projeções de risco."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Derivar a ordem global para métodos de passo simples",
                            "description": "Usar análise assintótica ou modelo de erro via equação diferencial perturbada para provar que a ordem global é igual à ordem local p em métodos de ordem p sobre intervalo fixo [0,T].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Erro de Truncamento Local (LTE) e Condição de Consistência",
                                  "subSteps": [
                                    "Defina o problema de valor inicial (PVI): y' = f(t,y), y(0)=y0.",
                                    "Expresse o LTE para um método de ordem p: τ_{n+1} = O(h^{p+1}).",
                                    "Verifique a consistência: lim_{h→0} max |τ| = 0.",
                                    "Discuta como o LTE acumula ao longo de múltiplos passos.",
                                    "Esboce a relação entre ordem local p e acumulação global."
                                  ],
                                  "verification": "Escreva a expressão exata do LTE para um método explícito de Euler (p=1) e confirme O(h^2).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e caneta, calculadora simbólica (opcional).",
                                  "tips": "Use expansões de Taylor para derivar o LTE; foque nos termos principais.",
                                  "learningObjective": "Compreender como o erro local de ordem p+1 leva à ordem global p.",
                                  "commonMistakes": "Confundir ordem local com global; ignorar termos de ordem superior no LTE."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Modelo de Erro Global via Equação Diferencial Perturbada",
                                  "subSteps": [
                                    "Introduza a solução numérica y_n ≈ y(t_n) + e_n, onde e_n é o erro global.",
                                    "Derive a equação perturbada: y' = f(t,y) + h^p * g(t,y) + O(h^{p+1}), com g relacionado ao LTE.",
                                    "Expresse o erro global e(t) satisfazendo e' = f_y(t,y) e + τ(t), com e(0)=0.",
                                    "Identifique a solução via variação de constantes: e(t) = ∫_0^t Φ(t,s) τ(s) ds.",
                                    "Discuta o fator de amplificação Φ(t,s) = exp(∫_s^t f_y(ξ,y(ξ)) dξ)."
                                  ],
                                  "verification": "Escreva a equação diferencial para o erro e(t) e sua solução integral para p=1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro-texto de EDOs, quadro branco ou papel milimetrado, software como Mathematica para simulação opcional.",
                                  "tips": "Assuma f Lipschitz para garantir unicidade; linearize em torno da solução exata.",
                                  "learningObjective": "Modelar a propagação de erros locais em uma EDP perturbada.",
                                  "commonMistakes": "Esquecer o termo fonte τ(t) ou assumir f_y = 0 (sem amplificação)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Análise Assintótica do Erro Global",
                                  "subSteps": [
                                    "Assuma |τ(t)| ≤ K h^{p+1} para t em [0,T].",
                                    "Estime |Φ(t,s)| ≤ M (constante de Lipschitz).",
                                    "Integre: |e(t)| ≤ ∫_0^t M K h^{p+1} ds ≤ M K T h^{p+1} / (p+1) para grandes 1/h, mas ajuste para ordem p.",
                                    "Use passos de tamanho h = T/N, número de passos N= T/h; erro acumulado ~ N * h^{p+1} = T h^p.",
                                    "Conclua ||e||_∞ ≤ C h^p, onde C independe de h (para h pequeno)."
                                  ],
                                  "verification": "Calcule explicitamente para Euler (p=1): mostre |e(t)| ≤ (e^{L T} -1) M / L * h.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel para integrais, tabela de integrais, exemplos numéricos de software Python (SciPy).",
                                  "tips": "Pense em termos de 'erro local vezes número de passos': h^{p+1} * (1/h) = h^p.",
                                  "learningObjective": "Aplicar análise assintótica para provar a ordem global p.",
                                  "commonMistakes": "Não dividir pelo fator (p+1) ou ignorar dependência em T fixo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Generalizar a Derivação para Métodos de Ordem p",
                                  "subSteps": [
                                    "Teste com método de Runge-Kutta ordem 2: confirme LTE O(h^3), global O(h^2).",
                                    "Discuta estabilidade: assumir região de estabilidade para convergência.",
                                    "Generalize para métodos lineares multistep se aplicável, mas foque em passo simples.",
                                    "Compare com simulação numérica: plote erro vs h em log-log para slope p.",
                                    "Resuma teorema: Para método consistente ordem p e estável, erro global O(h^p)."
                                  ],
                                  "verification": "Derive para RK2 e simule numericamente erro em [0,1] para y'=y, y(0)=1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com ode45 ou rk2 implementado, gráficos log-log.",
                                  "tips": "Use h=2^{-k} para k=1..10; verifique slope ≈ p no gráfico.",
                                  "learningObjective": "Generalizar a prova e validar empiricamente.",
                                  "commonMistakes": "Esquecer hipótese de estabilidade; superestimar ordem sem Lipschitz."
                                }
                              ],
                              "practicalExample": "Para o método de Euler (p=1) no PVI y' = -y, y(0)=1 em [0,1], derive que erro global e(1) ≈ (e^{-1} - e^{-1/N}) / (1 - e^{-1/N}) * h, que assintoticamente é O(h). Simule com h=0.1, 0.05 e confirme redução por fator 2.",
                              "finalVerifications": [
                                "Pode escrever a EDP perturbada para erro global?",
                                "Deriva corretamente |e(t)| ≤ C h^p com C explícito?",
                                "Aplica a prova para um método específico como RK4?",
                                "Identifica condições necessárias (consistência, estabilidade)?",
                                "Valida com simulação numérica e gráfico log-log?",
                                "Explica intuição: N passos * erro local h^{p+1} = h^p."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da EDP e solução integral (80%).",
                                "Correta análise assintótica e bound O(h^p) (90%).",
                                "Uso apropriado de hipóteses (Lipschitz, consistência) (70%).",
                                "Clareza na generalização e exemplo prático (75%).",
                                "Validação numérica com evidência gráfica (85%).",
                                "Identificação de erros comuns e limitações (60%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de trajetórias em dinâmica com integração numérica.",
                                "Computação: Implementação e análise de solvers em SciPy/ODEPACK.",
                                "Engenharia: Simulações de circuitos RLC onde precisão afeta estabilidade.",
                                "Estatística: Análise de erro em simulações Monte Carlo de processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão financeira, derivar ordem global garante que refinar malha h por 2 dobra precisão para p=1, otimizando custo computacional em supercomputadores para modelar EDOs em larga escala como Navier-Stokes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Analisar o impacto do tamanho do passo h no TEG",
                            "description": "Demonstrar graficamente ou analiticamente como o TEG diminui com h^p, considerando trade-off com custo computacional (número de passos ∝ 1/h).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e origem do Erro de Truncamento Global (TEG)",
                                  "subSteps": [
                                    "Relembrar que o TEG surge da acumulação do Erro de Truncamento Local (ETL) ao longo de múltiplos passos.",
                                    "Escrever a fórmula geral do TEG para métodos de ordem p: TEG ≈ C * h^p * T, onde T é o intervalo total e C é uma constante.",
                                    "Explicar como o ETL por passo é O(h^{p+1}), mas se propaga para TEG = O(h^p).",
                                    "Discutir suposições: estabilidade do método e suavidade da solução exata.",
                                    "Identificar fatores que influenciam C, como derivadas altas da solução."
                                  ],
                                  "verification": "Escrever corretamente a fórmula do TEG e explicar verbalmente sua derivação em 2 minutos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Análise Numérica, caderno e caneta",
                                  "tips": "Use analogia de 'bola de neve' para visualização da acumulação de erros.",
                                  "learningObjective": "Compreender a relação fundamental entre ETL e TEG.",
                                  "commonMistakes": "Confundir ordem do ETL (p+1) com TEG (p); ignorar o fator T no TEG."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar analiticamente a dependência do TEG em h",
                                  "subSteps": [
                                    "Derivar a expressão TEG(h) = K * h^p para um método fixo de ordem p.",
                                    "Calcular o fator de redução do erro ao dividir h por 2: TEG novo = TEG antigo / 2^p.",
                                    "Resolver uma EDO modelo analiticamente (ex: y' = -y, y(0)=1) para obter solução exata.",
                                    "Comparar numericamente TEG para diferentes h, confirmando a lei de potência.",
                                    "Plotar log(TEG) vs log(h) para verificar inclinação p."
                                  ],
                                  "verification": "Produzir tabela com TEG para h=0.1, 0.05, 0.025 mostrando redução por 2^p.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica ou Python/Jupyter com NumPy e Matplotlib",
                                  "tips": "Use escalas log-log para análise clara da lei de potência.",
                                  "learningObjective": "Derivar e validar matematicamente TEG ∝ h^p.",
                                  "commonMistakes": "Esquecer normalização pelo intervalo T; confundir com erro de arredondamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar graficamente o impacto de h no TEG",
                                  "subSteps": [
                                    "Implementar um método numérico (ex: Euler ou RK4) para uma EDO teste.",
                                    "Executar simulações variando h de 10^{-3} a 10^{-1}.",
                                    "Plotar TEG vs h em escala log-log e ajustar reta de inclinação p.",
                                    "Sobrepor curvas para diferentes ordens p (1, 2, 4) para comparação.",
                                    "Identificar regime onde TEG domina sobre outros erros."
                                  ],
                                  "verification": "Gerar gráfico com legenda mostrando inclinação correta de p.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com SciPy (odeint/solve_ivp) e Matplotlib",
                                  "tips": "Escolha EDO com solução conhecida suave para evitar erros de instabilidade.",
                                  "learningObjective": "Visualizar e interpretar graficamente a convergência do TEG.",
                                  "commonMistakes": "Escala errada no gráfico (use log-log); h muito pequeno ativando erro de arredondamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar o trade-off com custo computacional",
                                  "subSteps": [
                                    "Calcular número de passos N = T / h ∝ 1/h.",
                                    "Definir custo total Custo = N * custo_por_passo ∝ 1/h.",
                                    "Plotar TEG vs Custo, mostrando que redução de TEG requer custo exponencial.",
                                    "Derivar h ótimo minimizando TEG + λ * Custo (critério de custo-benefício).",
                                    "Discutir heurística: escolher h tal que TEG ≈ erro de máquina."
                                  ],
                                  "verification": "Criar tabela comparando TEG, N e Custo para 5 valores de h.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou Python para tabulação",
                                  "tips": "Considere custo_por_passo fixo para simplicidade inicial.",
                                  "learningObjective": "Avaliar equilíbrio entre precisão e eficiência computacional.",
                                  "commonMistakes": "Ignorar que custo é linear em N mas TEG exponencial em 1/h; superestimar h ótimo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e propor recomendações",
                                  "subSteps": [
                                    "Resumir: TEG diminui como h^p, mas custo cresce como 1/h.",
                                    "Recomendar testes de convergência para estimar p prático.",
                                    "Discutir limitações: não-linearidades, rigidez da EDO.",
                                    "Planejar experimento: variar h em problema real e reportar trade-offs.",
                                    "Concluir com guideline: reduzir h até TEG saturar por arredondamento."
                                  ],
                                  "verification": "Escrever parágrafo de 100 palavras resumindo trade-off com exemplo numérico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Caderno para resumo",
                                  "tips": "Use fórmula heurística h_opt ≈ (ε / C)^{1/p} * (T)^{1/p} para orientação.",
                                  "learningObjective": "Integrar análise para decisões práticas em simulações.",
                                  "commonMistakes": "Generalizar sem considerar contexto específico da EDO."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 em [0,1] com Euler (p=1): TEG ≈ 0.58 h. Teste h=0.1 (N=10, TEG≈0.058), h=0.05 (N=20, TEG≈0.029). Custo dobra, erro halva. Gráfico log-log confirma inclinação 1.",
                              "finalVerifications": [
                                "Explicar verbalmente por que TEG = O(h^p) enquanto ETL = O(h^{p+1}).",
                                "Produzir gráfico log-log com inclinação p correta para EDO teste.",
                                "Calcular corretamente N e custo para dado h e T.",
                                "Identificar h onde TEG ≈ 10^{-10} (erro máquina).",
                                "Propor h ótimo para tolerância ε=10^{-6} e p=2.",
                                "Discutir impacto de ordem p no trade-off."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica do TEG (80% correto).",
                                "Qualidade do gráfico: eixos log-log, legenda, ajuste de inclinação (nota 1-5).",
                                "Correção nos cálculos de custo e trade-off (erro <5%).",
                                "Profundidade na discussão de limitações e recomendações.",
                                "Capacidade de sintetizar em relatório conciso.",
                                "Criatividade em exemplo prático personalizado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers em Python/SciPy.",
                                "Física: Simulações de movimento (ex: oscilador harmônico).",
                                "Estatística: Análise de convergência e ajuste de curvas.",
                                "Engenharia Computacional: Otimização de malhas em CFD."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou financeiras, escolher h ótimo reduz tempo de computação de dias para horas mantendo precisão, evitando desperdício em supercomputadores para previsões meteorológicas ou precificação de opções."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.4",
                            "name": "Comparar TEG em simulações numéricas para diferentes métodos",
                            "description": "Implementar Euler e RK4 para um PVI não-linear (ex: y' = y(1-y)), calcular TEG em t=T fixo variando h, e plotar log-log para verificar ordens 1 e 4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema de Valor Inicial (PVI) e solução exata",
                                  "subSteps": [
                                    "Escolha o PVI não-linear: y' = y(1 - y), com y(0) = 0.5 e intervalo t de 0 a T=5.",
                                    "Derive ou recorde a solução exata: y(t) = 1 / (1 + e^{-t}).",
                                    "Implemente uma função para calcular a solução exata em qualquer t.",
                                    "Teste a função exata com valores iniciais para validar.",
                                    "Defina os valores de h a serem testados: [0.1, 0.05, 0.025, 0.0125, 0.00625]."
                                  ],
                                  "verification": "Função exata retorna y(5) ≈ 0.9933 corretamente para y0=0.5.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Python ou MATLAB",
                                    "Biblioteca numpy para cálculos numéricos"
                                  ],
                                  "tips": "Use y0 próximo de 0 ou 1 para observar dinâmica logística claramente.",
                                  "learningObjective": "Compreender o PVI não-linear e sua solução analítica para referência de erro.",
                                  "commonMistakes": [
                                    "Esquecer normalização na solução exata",
                                    "Usar y0=0 ou 1 (trivial)",
                                    "Não fixar T consistente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Euler",
                                  "subSteps": [
                                    "Escreva a função iterativa: y_{n+1} = y_n + h * f(t_n, y_n), onde f(t,y) = y(1-y).",
                                    "Crie uma função que recebe h, T, y0 e retorna y aproximado em t=T.",
                                    "Teste com h=0.1 e compare com solução exata.",
                                    "Calcule o Erro de Truncamento Global (TEG): |y_exata(T) - y_aprox(T)|.",
                                    "Armazene TEG para cada h em uma lista ou dicionário."
                                  ],
                                  "verification": "Para h=0.1, TEG deve ser aproximadamente 0.05-0.1.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Python/MATLAB",
                                    "numpy",
                                    "Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Implemente em loop while t < T para precisão.",
                                  "learningObjective": "Dominar a implementação do método de Euler para PVIs não-lineares.",
                                  "commonMistakes": [
                                    "Atualizar t incorretamente (t += h)",
                                    "Usar f(y) dependente de t quando não é",
                                    "Arredondamento em h levando a overshoot de T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Runge-Kutta de ordem 4 (RK4)",
                                  "subSteps": [
                                    "Defina os coeficientes k1 = h*f(t_n, y_n), k2 = h*f(t_n + h/2, y_n + k1/2), k3 = h*f(t_n + h/2, y_n + k2/2), k4 = h*f(t_n + h, y_n + k3).",
                                    "y_{n+1} = y_n + (k1 + 2*k2 + 2*k3 + k4)/6.",
                                    "Crie função similar à de Euler, mas com fórmulas RK4.",
                                    "Teste com h=0.1 e calcule TEG, deve ser muito menor que Euler.",
                                    "Armazene TEG para os mesmos h's."
                                  ],
                                  "verification": "Para h=0.1, TEG RK4 < 10^{-5}, muito menor que Euler.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python/MATLAB",
                                    "numpy"
                                  ],
                                  "tips": "Vetorize k's se possível para eficiência, mas foque em clareza.",
                                  "learningObjective": "Implementar corretamente RK4 e observar superioridade em precisão.",
                                  "commonMistakes": [
                                    "Erros nos argumentos de f para k2/k3/k4",
                                    "Fator 1/6 esquecido",
                                    "Confundir índices de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações e calcular TEG para vários h",
                                  "subSteps": [
                                    "Para cada h na lista, rode Euler e RK4, calcule TEG.",
                                    "Crie tabelas ou arrays com h, TEG_Euler, TEG_RK4.",
                                    "Verifique convergência: TEG diminui com h menor.",
                                    "Calcule razões de erro sucessivas para estimar ordem.",
                                    "Salve dados em formato plotável (log_h, log_TEG)."
                                  ],
                                  "verification": "TEG_Euler ~ O(h), TEG_RK4 ~ O(h^4) qualitativamente.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "numpy para arrays",
                                    "pandas opcional para tabelas"
                                  ],
                                  "tips": "Use logspace para h se precisão numérica for issue.",
                                  "learningObjective": "Coletar dados empíricos de erro global variando h.",
                                  "commonMistakes": [
                                    "h inconsistente entre métodos",
                                    "Não fixar T exato",
                                    "Erro numérico em logs para h muito pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Plotar gráficos log-log e analisar ordens",
                                  "subSteps": [
                                    "Plote log(|TEG|) vs log(h) para Euler e RK4 no mesmo gráfico.",
                                    "Adicione linhas de referência com inclinações -1 e -4.",
                                    "Ajuste linear (polyfit grau 1) para estimar inclinações.",
                                    "Interprete: inclinação ≈ -p confirma ordens 1 e 4.",
                                    "Documente observações em relatório curto."
                                  ],
                                  "verification": "Gráfico mostra reta com slope ≈ -1 para Euler e ≈ -4 para RK4.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "matplotlib ou plot em MATLAB"
                                  ],
                                  "tips": "Use plt.loglog() para escalas log-log automáticas.",
                                  "learningObjective": "Visualizar e confirmar ordens de convergência numericamente.",
                                  "commonMistakes": [
                                    "Escala errada (sem log)",
                                    "Não incluir legenda/marcadores",
                                    "Ignorar regime assintótico para h pequeno"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python: def f(y): return y*(1-y). Para y0=0.5, T=5, h=[0.1,0.05,...]. Euler com h=0.1 dá y(5)≈0.943, TEG≈0.050; RK4 dá y(5)≈0.9933, TEG≈1e-6. Plot log-log confirma slopes -1 e -4.",
                              "finalVerifications": [
                                "Solução exata implementada corretamente em T=5.",
                                "TEG calculado para pelo menos 5 valores de h por método.",
                                "Gráficos log-log mostram inclinações -1 para Euler e -4 para RK4.",
                                "Tabelas de erros salvas e analisadas.",
                                "Relatório com interpretação das ordens de convergência.",
                                "Código roda sem erros para todos h."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação de Euler e RK4 (código correto).",
                                "Correção nos cálculos de TEG (ordem de magnitude esperada).",
                                "Qualidade do gráfico log-log (escalas, legendas, fits).",
                                "Análise quantitativa das inclinações (polyfit ou razões).",
                                "Clareza na documentação e interpretação.",
                                "Eficiência e legibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Modelos diferenciais em populações (equação logística).",
                                "Estatística: Ajuste linear e análise de regressão em log-log.",
                                "Engenharia: Simulações em controle e dinâmica de sistemas."
                              ],
                              "realWorldApplication": "Em modelagem populacional (ecologia), simulações de circuitos elétricos ou finanças (preços de opções), onde métodos de alta ordem como RK4 reduzem tempo computacional mantendo precisão em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Estabilidade dos Métodos de Passo Simples",
                    "description": "Condições de estabilidade absoluta e análise do método de Euler para equações lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Estabilidade Absoluta",
                        "description": "Conceito fundamental que garante que os erros numéricos introduzidos pelos métodos de passo simples não cresçam ilimitadamente ao longo das iterações, independentemente do número de passos, para um passo de tempo fixo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Definir estabilidade absoluta",
                            "description": "Explicar a definição formal de estabilidade absoluta para métodos de passo simples aplicados ao problema de valor inicial y' = f(t,y), destacando a importância da não-amplificação de erros de arredondamento e truncamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema de Valor Inicial e Métodos de Passo Simples",
                                  "subSteps": [
                                    "Estude a forma geral do PVI: y' = f(t, y), y(t0) = y0.",
                                    "Identifique métodos de passo simples, como Euler explícito e Heun.",
                                    "Entenda que esses métodos computam y_{n+1} a partir de y_n sem valores anteriores.",
                                    "Discuta a discretização temporal com passo h."
                                  ],
                                  "verification": "Escreva a fórmula geral de um método de passo simples e cite dois exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de PVI)",
                                    "Notas de aula sobre métodos numéricos"
                                  ],
                                  "tips": "Foquem na dependência local: apenas f(t_n, y_n) é usado.",
                                  "learningObjective": "Compreender o contexto onde a estabilidade absoluta é analisada.",
                                  "commonMistakes": [
                                    "Confundir métodos de passo simples com multipasso.",
                                    "Esquecer a condição inicial y(t0) = y0."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar Estabilidade em Métodos Numéricos",
                                  "subSteps": [
                                    "Defina estabilidade como a propriedade de não amplificar erros numéricos.",
                                    "Diferencie erros de truncamento (aproximação do método) e arredondamento (precisão finita).",
                                    "Explique que instabilidade leva a crescimento exponencial de erros pequenos.",
                                    "Introduza a equação teste y' = λ y, com Re(λ) < 0 para problemas dissipativos.",
                                    "Discuta a amplificação via fator de amplificação R(z), z = h λ."
                                  ],
                                  "verification": "Explique verbalmente como um erro pequeno pode explodir em instabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre estabilidade numérica",
                                    "Calculadora ou software como MATLAB para testes simples"
                                  ],
                                  "tips": "Visualize graficamente: soluções estáveis decaem, numéricas instáveis crescem.",
                                  "learningObjective": "Diferenciar estabilidade de precisão e identificar fontes de erro.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com convergência.",
                                    "Ignorar que Re(λ) < 0 modela decaimento físico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente Estabilidade Absoluta",
                                  "subSteps": [
                                    "Defina: Um método é de estabilidade absoluta se, para y' = λ y com Re(λ) < 0, |R(h λ)| ≤ 1 para todo h > 0 suficientemente pequeno.",
                                    "Descreva a região de estabilidade absoluta como o semi-plano esquerdo do plano complexo.",
                                    "Estude o polinômio de estabilidade R(z) para métodos lineares.",
                                    "Classifique métodos: Euler explícito tem região limitada; backward é absoluta.",
                                    "Verifique com fórmula: para Euler forward, R(z) = 1 + z, instável para h > 2/|λ|."
                                  ],
                                  "verification": "Escreva a definição exata e compute R(z) para Euler explícito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivação de R(z)",
                                    "Tabela de regiões de estabilidade de métodos comuns"
                                  ],
                                  "tips": "Memorize: estabilidade absoluta requer |R(z)| ≤ 1 para todo Re(z) < 0.",
                                  "learningObjective": "Formular a definição matemática precisa de estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Limitar a h fixo em vez de todo h pequeno.",
                                    "Confundir com estabilidade relativa ou condicional."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Importância para Não-Amplificação de Erros",
                                  "subSteps": [
                                    "Explique como estabilidade absoluta previne crescimento de erros de truncamento local.",
                                    "Discuta erros de arredondamento: máquina finita amplifica se |R| > 1.",
                                    "Compare simulações estáveis vs instáveis em longo prazo.",
                                    "Relacione com ordem do método: alta ordem não garante estabilidade.",
                                    "Conclua que sem estabilidade absoluta, soluções são inválidas independentemente da precisão."
                                  ],
                                  "verification": "Descreva um cenário onde falta de estabilidade absoluta arruína a simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos computacionais em Python/MATLAB",
                                    "Gráficos de soluções instáveis"
                                  ],
                                  "tips": "Sempre teste com equação modelo y' = -y para validar.",
                                  "learningObjective": "Compreender o impacto prático da estabilidade absoluta em simulações.",
                                  "commonMistakes": [
                                    "Subestimar erros de arredondamento em problemas rígidos.",
                                    "Achar que refinar h resolve instabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 (solução exata y=e^{-t}), aplique Euler explícito com h=1.5: y1=1-1.5*1=-0.5, y2=-0.5-1.5*(-0.5)=0.25, oscila e cresce, demonstrando falta de estabilidade absoluta. Com h=0.5, ainda instável para t grande.",
                              "finalVerifications": [
                                "Definir corretamente estabilidade absoluta usando R(hλ).",
                                "Identificar métodos com estabilidade absoluta (ex: backward Euler).",
                                "Explicar por que Euler explícito não é absolutamente estável.",
                                "Relacionar com não-amplificação de erros de arredondamento.",
                                "Dar exemplo numérico de instabilidade.",
                                "Diferenciar de estabilidade condicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos termos corretos).",
                                "Correta derivação do fator R(z) para método simples.",
                                "Explicação clara da relação com erros de truncamento/arredondamento.",
                                "Uso apropriado da equação teste y'=λy.",
                                "Identificação de exemplos reais de métodos estáveis/instáveis.",
                                "Capacidade de discutir implicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica molecular ou fluidos.",
                                "Computação: Análise de algoritmos numéricos e programação científica.",
                                "Engenharia: Controle de sistemas e simulações de processos rígidos.",
                                "Estatística: Modelagem estocástica onde rigidez afeta variância."
                              ],
                              "realWorldApplication": "Em modelagem climática ou farmacocinética, onde EDOs rígidos (Re(λ)<<0) requerem métodos de estabilidade absoluta para previsões confiáveis sem explosão de erros em simulações de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Identificar condições de estabilidade absoluta",
                            "description": "Determinar as condições gerais sobre o passo de tempo h e os autovalores λ da matriz jacobiana para garantir estabilidade absoluta em sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina estabilidade absoluta como a propriedade que garante que a solução numérica permaneça limitada para qualquer h suficientemente pequeno, independentemente da solução exata.",
                                    "Diferencie estabilidade absoluta de estabilidade relativa, focando no comportamento assintótico da solução numérica.",
                                    "Revise o problema modelo y' = λy, onde λ é autovalor complexo.",
                                    "Explique o papel do passo de tempo h na amplificação de erros.",
                                    "Discuta a importância para métodos de passo simples como Euler explícito."
                                  ],
                                  "verification": "Escreva uma definição precisa de estabilidade absoluta e dê um exemplo de instabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de EDOs)",
                                    "Anotações de aula sobre métodos numéricos"
                                  ],
                                  "tips": "Use diagramas da região de estabilidade no plano complexo para visualizar.",
                                  "learningObjective": "Ao final, o aluno define corretamente estabilidade absoluta e seu contexto em métodos numéricos.",
                                  "commonMistakes": "Confundir estabilidade absoluta com consistência do método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar estabilidade no caso escalar linear",
                                  "subSteps": [
                                    "Aplique o método de Euler forward ao modelo y' = λy: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Determine a condição |1 + hλ| < 1 para que a solução numérica decaia.",
                                    "Represente hλ no plano complexo e identifique a região de estabilidade (disco unitário centrado em -1).",
                                    "Calcule h máximo para λ real negativo, como h < 2/|λ|.",
                                    "Teste numericamente com h dentro e fora da região."
                                  ],
                                  "verification": "Resolva para |1 + hλ| < 1 com λ = -1 + i, e plote pontos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para plotar região de estabilidade",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Sempre normalize hλ = z para usar a função de amplificação R(z).",
                                  "learningObjective": "O aluno deriva e aplica a condição de estabilidade para o caso escalar.",
                                  "commonMistakes": "Esquecer que λ pode ser complexo e considerar apenas parte real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar para sistemas lineares y' = A y",
                                  "subSteps": [
                                    "Explique que a matriz jacobiana A tem autovalores λ_i que determinam o comportamento local.",
                                    "Diagonalize A ou use similitude para reduzir ao caso escalar.",
                                    "Estenda a condição: o método é estável se |R(hλ_i)| < 1 para todos autovalores λ_i de A.",
                                    "Discuta o espectro de A e seu raio espectral.",
                                    "Verifique linearização em torno de equilíbrio para sistemas não lineares."
                                  ],
                                  "verification": "Para uma matriz A 2x2, liste autovalores e verifique condição para h dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software para autovalores (eig em MATLAB/Python)",
                                    "Exemplos de matrizes jacobianas"
                                  ],
                                  "tips": "Compute autovalores primeiro; eles ditam a restrição mais severa (maior |λ|).",
                                  "learningObjective": "O aluno generaliza a condição escalar para sistemas via autovalores da jacobiana.",
                                  "commonMistakes": "Ignorar autovalores complexos conjugados ou multiplicidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e aplicar condições gerais de estabilidade absoluta",
                                  "subSteps": [
                                    "Enuncie a condição geral: h deve satisfazer h < min(2 / |Re(λ_i)|) ajustado pela região R do método.",
                                    "Para Euler forward, h < 2 / max|Re(λ_i)| se todos λ reais negativos.",
                                    "Considere orientação rígida: max|Re(λ)| determina h.",
                                    "Resolva para h admissível dado A.",
                                    "Valide com simulação numérica curta."
                                  ],
                                  "verification": "Dado A, compute h_max e simule 10 passos sem explosão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python para simular y' = A y com Euler",
                                    "Matriz A exemplo"
                                  ],
                                  "tips": "Sempre verifique o autovalor com maior parte real negativa (mais restritivo).",
                                  "learningObjective": "O aluno identifica e aplica condições precisas para estabilidade em sistemas.",
                                  "commonMistakes": "Usar |λ| em vez de |Re(λ)| ou ignorar a forma exata de R(z)."
                                }
                              ],
                              "practicalExample": "Para y' = [[0,1],[-2,-3]] y (oscilador amortecido), autovalores λ ≈ -1.5 ± i. Para Euler forward, região |1 + z| <1 com z = hλ. Compute h tal que ambos z estejam no disco: aproximadamente h < 1 / 1.5 ≈ 0.666, validado por simulação sem crescimento exponencial.",
                              "finalVerifications": [
                                "Declara corretamente |R(hλ)| < 1 para todos λ_i.",
                                "Identifica o autovalor restritivo corretamente.",
                                "Calcula h_max preciso para exemplo dado.",
                                "Diferencia condições para diferentes métodos (ex: Euler vs. backward).",
                                "Simula e confirma ausência de instabilidade.",
                                "Explica impacto da jacobiana em não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição escalar (90% correto).",
                                "Correta generalização para matrizes via autovalores.",
                                "Cálculo exato de h admissível em exemplo.",
                                "Uso apropriado de região de estabilidade.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na explicação verbal/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica newtoniana e osciladores.",
                                "Engenharia de Controle: Análise de sistemas lineares e escolha de h em controladores.",
                                "Computação Científica: Implementação eficiente de solvers ODE.",
                                "Matemática Aplicada: Teoria espectral e análise de matrizes."
                              ],
                              "realWorldApplication": "Em modelagem climática ou epidemiológica (ex: SIR models), garante que simulações numéricas com h grande não diverjam artificialmente, permitindo previsões confiáveis em supercomputadores para cenários reais como propagação de doenças."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Aplicar teste de estabilidade para equações escalares",
                            "description": "Aplicar o teste de estabilidade absoluta à equação modelo y' = λy, verificando se a solução numérica permanece limitada para t → ∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a equação modelo e a solução exata",
                                  "subSteps": [
                                    "Identifique a equação diferencial escalar y' = λy, onde λ é um complexo com Re(λ) < 0 para estabilidade.",
                                    "Determine a solução exata: y(t) = y(0) * exp(λ t), que tende a 0 quando t → ∞.",
                                    "Explique por que a solução numérica deve permanecer limitada (não explodir) para t → ∞.",
                                    "Discuta o papel do passo h e z = hλ no plano complexo.",
                                    "Esboce a região estável exata: {z ∈ ℂ | Re(z) ≤ 0}."
                                  ],
                                  "verification": "Escreva a solução exata e descreva verbalmente por que ela decai para Re(λ) < 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo de estabilidade)"
                                  ],
                                  "tips": "Visualize o plano complexo z para entender regiões de estabilidade.",
                                  "learningObjective": "Compreender o comportamento assintótico da solução exata do modelo de teste.",
                                  "commonMistakes": [
                                    "Confundir Re(λ) < 0 com |λ| < 0",
                                    "Ignorar que y(t) → 0, não fica constante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a recursão numérica para o método escolhido",
                                  "subSteps": [
                                    "Escolha um método de passo simples, ex: Euler forward: y_{n+1} = y_n + h f(t_n, y_n) = (1 + hλ) y_n.",
                                    "Geralize para métodos lineares: y_{n+1} = R(hλ) y_n, onde R(z) é a função de amplificação.",
                                    "Para métodos RK, lembre a forma polinomial de R(z).",
                                    "Calcule explicitamente R(z) para o método selecionado.",
                                    "Verifique para h pequeno que R(z) ≈ exp(z)."
                                  ],
                                  "verification": "Escreva a recursão y_{n+1} = R(z) y_n e defina R(z) corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB para verificação",
                                    "Tabela de funções de amplificação de métodos comuns"
                                  ],
                                  "tips": "Comece com Euler para simplicidade antes de métodos mais complexos.",
                                  "learningObjective": "Derivar a iteração numérica linearizada para o modelo y' = λy.",
                                  "commonMistakes": [
                                    "Esquecer o fator h em z = hλ",
                                    "Confundir Euler forward com backward"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e analisar a função de amplificação R(z)",
                                  "subSteps": [
                                    "Defina a região de estabilidade absoluta S = {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Para estabilidade, S deve conter o semiplano esquerdo {z | Re(z) ≤ 0}.",
                                    "Plote ou descreva S para o método (ex: para Euler forward, disco |z + 1| ≤ 1).",
                                    "Verifique se para z com |z| grande e Re(z) < 0, |R(z)| < 1.",
                                    "Analise o comportamento assintótico: solução numérica y_n = [R(z)]^n y_0 limitada iff |R(z)| ≤ 1."
                                  ],
                                  "verification": "Desenhe o contorno de S no plano z e confirme inclusão do semiplano esquerdo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python com matplotlib)",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use |R(z)|² = R(z) \bar{R(\bar{z})} para calcular magnitude.",
                                  "learningObjective": "Analisar a região de estabilidade absoluta via |R(z)| ≤ 1.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Plotar R(z) em vez de |R(z)|"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o teste e concluir sobre estabilidade",
                                  "subSteps": [
                                    "Para um λ dado com Re(λ) < 0 e h > 0, compute z = hλ e verifique se |R(z)| ≤ 1.",
                                    "Simule numericamente y_n para t grande e observe se permanece limitada.",
                                    "Se |R(z)| > 1, demonstre oscilação ou explosão.",
                                    "Conclua: o método é estável para aquele hλ se y_n bounded para n → ∞.",
                                    "Teste com exemplo numérico: compare com solução exata."
                                  ],
                                  "verification": "Execute simulação e confirme que |y_n| não cresce para t → ∞.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simulação",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Escolha hλ próximo ao limite da região S para testar.",
                                  "learningObjective": "Executar o teste prático de estabilidade absoluta em um caso escalar.",
                                  "commonMistakes": [
                                    "Usar h negativo acidentalmente",
                                    "Parar simulação cedo demais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para método Euler forward e y' = -y (λ=-1), com h=1.5: z=-1.5, R(z)=1-1.5=-0.5, |R|=0.5<1 → estável. Simule y_0=1, y1=-0.5, y2=0.25, etc., tende a 0. Para h=2, z=-2, R=-1, |R|=1 → marginalmente estável, mas oscila.",
                              "finalVerifications": [
                                "Explique verbalmente o teste de estabilidade absoluta para y' = λy.",
                                "Derive R(z) para Euler forward e Backward.",
                                "Plote região S para um método e identifique semiplano esquerdo.",
                                "Simule um caso instável e mostre explosão numérica.",
                                "Compare solução numérica com exata para t=100.",
                                "Responda: Por que |R(z)| ≤1 garante boundedness?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) (100% correta).",
                                "Correta identificação da região de estabilidade S.",
                                "Análise qualitativa e quantitativa de |R(z)|.",
                                "Simulação numérica sem erros de implementação.",
                                "Interpretação física correta do comportamento assintótico.",
                                "Uso apropriado de conceitos do plano complexo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento exponencial (radioatividade).",
                                "Computação: Implementação de solvers ODE em Python/Scipy.",
                                "Engenharia: Estabilidade em simulações de controle dinâmico.",
                                "Estatística: Análise de erros em métodos Monte Carlo para EDOs."
                              ],
                              "realWorldApplication": "Em simulações de populações biológicas com decaimento (ex: farmacocinética), ou modelagem climática com termos dissipativos, garante que soluções numéricas não explodam em longas simulações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Análise de Estabilidade do Método de Euler Explícito",
                        "description": "Estudo detalhado da estabilidade do método de Euler explícito aplicado a equações lineares y' = λy, incluindo derivação do fator de amplificação e região de estabilidade no plano complexo hλ.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Derivar o fator de amplificação do método de Euler",
                            "description": "Derivar a expressão do fator de amplificação R(hλ) = 1 + hλ para o método de Euler explícito na equação teste y' = λy e analisar sua magnitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Equação Teste y' = λy",
                                  "subSteps": [
                                    "Escreva a equação diferencial y' = λy, onde λ é uma constante complexa.",
                                    "Determine a solução exata: y(t) = y(0) * e^(λt).",
                                    "Discuta o comportamento da solução: crescimento se Re(λ)>0, decaimento se Re(λ)<0.",
                                    "Introduza o parâmetro de estabilidade z = hλ, onde h é o passo de tempo.",
                                    "Explique por que essa equação é usada como modelo teste para estabilidade."
                                  ],
                                  "verification": "Escreva a solução exata e descreva qualitativamente o comportamento para λ real positivo e negativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize graficamente y(t) para diferentes λ para intuitar estabilidade.",
                                  "learningObjective": "Entender o papel da equação teste na análise de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir y' = λy com y' = λ",
                                    "Esquecer que λ pode ser complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar o Esquema do Método de Euler Explícito",
                                  "subSteps": [
                                    "Escreva a fórmula geral do método de Euler: y_{n+1} = y_n + h * f(t_n, y_n).",
                                    "Para f(t,y) = λy, simplifique para y_{n+1} = y_n + hλ y_n.",
                                    "Identifique que isso é uma recursão linear: y_{n+1} = (1 + hλ) y_n.",
                                    "Defina o fator de amplificação R(z) como o multiplicador por iteração.",
                                    "Verifique com um exemplo numérico simples: y0=1, h=0.1, λ=-1."
                                  ],
                                  "verification": "Aplique a fórmula a um passo e confirme y1 = y0 * (1 + hλ).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha de anotações prévia do Step 1"
                                  ],
                                  "tips": "Sempre fatorize y_n para revelar o multiplicador.",
                                  "learningObjective": "Aplicar corretamente o método de Euler à equação linear.",
                                  "commonMistakes": [
                                    "Usar Euler implícito em vez de explícito",
                                    "Esquecer o h em h*f"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Recursão Geral y_{n} = [R(hλ)]^n y_0",
                                  "subSteps": [
                                    "Partindo de y1 = (1 + hλ) y0.",
                                    "Induza para yn = (1 + hλ)^n y0.",
                                    "Identifique R(hλ) = 1 + hλ como o fator de amplificação por passo.",
                                    "Compare com a solução exata e^(λ t_n) ≈ [e^(hλ)]^n.",
                                    "Discuta a relação aproximada e^(z) ≈ 1 + z para pequenos z."
                                  ],
                                  "verification": "Escreva explicitamente y_n em termos de R(hλ) e y0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para potências"
                                  ],
                                  "tips": "Use indução matemática para generalizar de n=1 para n arbitrário.",
                                  "learningObjective": "Derivar a expressão fechada do fator de amplificação.",
                                  "commonMistakes": [
                                    "Escrever R = 1 + λ ao invés de 1 + hλ",
                                    "Confundir recursão com solução contínua"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Magnitude |R(hλ)|",
                                  "subSteps": [
                                    "Calcule |R(z)| = |1 + z| onde z = hλ.",
                                    "Para λ real negativo (z real negativo), encontre |1 + z| < 1 para estabilidade.",
                                    "Região de estabilidade: disco |1 + z| ≤ 1 no plano complexo.",
                                    "Plote ou descreva a região: z ∈ [-2, 0] para λ real.",
                                    "Discuta implicações: h < 2/|λ| para estabilidade."
                                  ],
                                  "verification": "Determine para qual intervalo de hλ reais |R| < 1 e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfica ou software como Desmos para |1+z|"
                                  ],
                                  "tips": "Use desigualdade triangular para estimar |1 + z|.",
                                  "learningObjective": "Analisar condições de estabilidade via |R(z)| ≤ 1.",
                                  "commonMistakes": [
                                    "Ignorar parte imaginária de λ",
                                    "Confundir |R| <1 com R<1"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Sintetizar a Derivação Completa",
                                  "subSteps": [
                                    "Reescreva toda a derivação do início ao fim.",
                                    "Compute numericamente |R| para z=-1.5 e z=-2.5.",
                                    "Compare com solução exata para n=10 passos.",
                                    "Resuma limitações do método de Euler.",
                                    "Prepare um fluxograma da derivação."
                                  ],
                                  "verification": "Apresente a derivação completa e análise em um parágrafo coeso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Computador com Python/MATLAB opcional"
                                  ],
                                  "tips": "Teste com valores específicos para validar.",
                                  "learningObjective": "Sintetizar a análise de estabilidade do Euler explícito.",
                                  "commonMistakes": [
                                    "Erros aritméticos em cálculos numéricos",
                                    "Generalizar incorretamente para λ complexo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para modelar decaimento radioativo y' = -0.1 y, com h=1 ano: z = hλ = -0.1, R(z)=0.9, |R|=0.9<1 estável; após 10 anos, y10 ≈ (0.9)^10 y0 ≈ 0.348 y0, vs exato e^{-1}≈0.368 y0.",
                              "finalVerifications": [
                                "Deriva corretamente R(hλ) = 1 + hλ.",
                                "Identifica yn = [R(hλ)]^n y0.",
                                "Calcula |R(z)| e região |1+z|≤1.",
                                "Explica estabilidade para Re(λ)<0 e h pequeno.",
                                "Compara aproximação com exata via série de Taylor.",
                                "Aplica a um exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correto).",
                                "Correta identificação e análise de |R(hλ)|.",
                                "Uso apropriado de notação (z=hλ, etc.).",
                                "Análise qualitativa e quantitativa da estabilidade.",
                                "Clareza na explicação e exemplos.",
                                "Ausência de erros comuns como esquecer h."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de decaimento exponencial ou osciladores.",
                                "Computação: Implementação de solvers numéricos em Python (SciPy).",
                                "Engenharia: Análise de erros em simulações CFD ou circuitos.",
                                "Estatística: Modelos estocásticos lineares aproximados."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou financeiras, garante que métodos numéricos como Euler não amplifiquem erros, evitando previsões instáveis em modelos de previsão de tempo ou derivativos de opções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.1"
                            ]
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Determinar a condição de estabilidade para Euler explícito",
                            "description": "Estabelecer a condição |1 + hλ| ≤ 1 para estabilidade absoluta e interpretá-la geometricamente como o disco unitário no plano complexo centrado em -1 com raio 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método de Euler explícito e o fator de amplificação",
                                  "subSteps": [
                                    "Lembre o problema de valor inicial y' = λy, y(0)=y0, com λ complexo.",
                                    "Escreva a iteração de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n) = (1 + hλ) y_n.",
                                    "Identifique o fator de amplificação g(z) = 1 + z, onde z = hλ.",
                                    "Explique que para estabilidade absoluta, requeremos |y_n| não crescer, i.e., |g(z)|^n → 0 ou ≤1."
                                  ],
                                  "verification": "Escreva corretamente a iteração e identifique g(z) = 1 + z.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, calculadora, notas de aula sobre Euler explícito.",
                                  "tips": "Sempre normalize com o problema modelo y' = λy para simplificar.",
                                  "learningObjective": "Compreender o papel do fator de amplificação na estabilidade.",
                                  "commonMistakes": "Confundir Euler explícito com implícito (g(z)=1/(1-z)); esquecer que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a condição de estabilidade |1 + hλ| ≤ 1",
                                  "subSteps": [
                                    "Para estabilidade absoluta, exija |g(z)| = |1 + z| ≤ 1 para todo z = hλ na região espectral.",
                                    "Expanda: |1 + hλ|² = (1 + Re(hλ))² + (Im(hλ))² ≤ 1.",
                                    "Simplifique para a desigualdade: Re(z) ≥ -1/2? Não, resolva geometricamente.",
                                    "Conclua que a condição é |1 + z| ≤ 1.",
                                    "Verifique para λ real negativo: h ≤ 2/|λ|."
                                  ],
                                  "verification": "Derive |1 + z| ≤ 1 e aplique a um λ real, obtendo h ≤ 2/|λ|.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, livro de análise numérica (opcional).",
                                  "tips": "Use notação z = hλ desde o início para generalizar a complexo.",
                                  "learningObjective": "Derivar analiticamente a condição de estabilidade absoluta.",
                                  "commonMistakes": "Esquecer o módulo complexo; confundir com estabilidade condicional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar geometricamente a região de estabilidade",
                                  "subSteps": [
                                    "No plano complexo z, |1 + z| ≤ 1 significa distância de z a -1 ≤ 1.",
                                    "Desenhe o círculo centrado em -1 + 0i com raio 1.",
                                    "Identifique: toca origem (z=0), vai até z=-2 no eixo real.",
                                    "Note que inclui parte do semiplano esquerdo, mas exclui |z|>2 no negativo.",
                                    "Marque pontos teste: z=-1 (dentro), z=-1.5 (dentro), z=-3 (fora)."
                                  ],
                                  "verification": "Desenhe o disco corretamente e teste 3 pontos com |1+z|≤1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para gráfico complexo, régua, compasso ou software como GeoGebra.",
                                  "tips": "Centro em -1, raio 1: vai de -2 a 0 no real.",
                                  "learningObjective": "Visualizar a região de estabilidade como disco unitário.",
                                  "commonMistakes": "Centro em 0 ao invés de -1; raio errado (pensar unitário em 0)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar a condição em exemplos",
                                  "subSteps": [
                                    "Para y' = -k y (λ=-k<0), z=-h k, requer h k ≤ 2.",
                                    "Para λ com parte imaginária, trace hλ dentro do disco.",
                                    "Compare com outros métodos (ex: Euler implícito: disco |1/(1-z)|≤1).",
                                    "Discuta implicações: Euler explícito instável para rigidez.",
                                    "Resolva: dado λ, encontre h max tal que hλ no disco."
                                  ],
                                  "verification": "Para λ=-1+i, encontre h tal que |1 + hλ|≤1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora complexa ou Python/MATLAB para módulo.",
                                  "tips": "Use arg(z) e |z| para checar inclusão no disco.",
                                  "learningObjective": "Aplicar a condição a problemas concretos.",
                                  "commonMistakes": "Ignorar parte imaginária; calcular h max só para real."
                                }
                              ],
                              "practicalExample": "Considere y' = -10 y + i y, λ = -10 + i. Encontre o maior h tal que hλ está dentro do disco |1 + z| ≤ 1. Calcule z = h(-10 + i), resolva |1 + z| ≤ 1, plotando ou numericamente: h ≈ 0.099 para margem.",
                              "finalVerifications": [
                                "Deriva corretamente |1 + hλ| ≤ 1 como condição de estabilidade.",
                                "Desenha e descreve o disco unitário centrado em -1 com raio 1.",
                                "Aplica a condição para λ real e encontra h ≤ 2/|λ|.",
                                "Verifica inclusão de pontos z no disco geometricamente.",
                                "Explica por que Euler explícito é inadequado para problemas rígidos.",
                                "Compara região com outros métodos lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator g(z) = 1 + z (100%).",
                                "Correta identificação e desenho da região |1 + z| ≤ 1 (90-100%).",
                                "Aplicação correta a exemplos numéricos (80-100%).",
                                "Interpretação geométrica clara e sem erros (90%).",
                                "Explicação de implicações para escolha de h (80%).",
                                "Uso apropriado de números complexos (100%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos (equações diferenciais).",
                                "Computação: Implementação numérica em Python (bibliotecas como NumPy para complexos).",
                                "Engenharia: Análise de rigidez em modelos dinâmicos (controle de sistemas).",
                                "Geometria: Interpretação de regiões no plano complexo (análise complexa)."
                              ],
                              "realWorldApplication": "Em simulações numéricas de sistemas dinâmicos rígidos, como reações químicas rápidas ou circuitos elétricos, a condição garante que erros não explodam, permitindo h maiores em métodos implícitos para eficiência computacional em software como MATLAB ou COMSOL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.1"
                            ]
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Analisar a região de estabilidade do Euler explícito",
                            "description": "Desenhar e interpretar a região de estabilidade absoluta do método de Euler explícito, discutindo restrições para problemas com autovalores reais negativos (equações stiff).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método de Euler explícito e fator de amplificação",
                                  "subSteps": [
                                    "Lembre-se da formulação do método de Euler explícito para y' = f(t,y): y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Considere o teste modelo y' = λ y, resultando em y_{n+1} = (1 + h λ) y_n.",
                                    "Identifique o fator de amplificação g(z) = 1 + z, onde z = h λ.",
                                    "Discuta a estabilidade absoluta: |g(z)| ≤ 1 para convergência.",
                                    "Calcule |1 + z| ≤ 1 graficamente no plano complexo z."
                                  ],
                                  "verification": "Escreva a fórmula do fator de amplificação e confirme |1 + z| ≤ 1 para z = -1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. Métodos de Runge-Kutta)",
                                    "Papel e lápis ou software como GeoGebra"
                                  ],
                                  "tips": "Comece com λ real negativo para visualizar o círculo unitário.",
                                  "learningObjective": "Compreender o fator de amplificação como base para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito com implícito",
                                    "Esquecer que z = h λ é complexo em geral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a região de estabilidade absoluta",
                                  "subSteps": [
                                    "Resolva a desigualdade |1 + z| ≤ 1, onde z = x + i y.",
                                    "Expanda: √[(1 + x)^2 + y^2] ≤ 1, elevando ao quadrado: (1 + x)^2 + y^2 ≤ 1.",
                                    "Simplifique: x^2 + 2x + 1 + y^2 ≤ 1 → x^2 + y^2 + 2x ≤ 0 → (x + 1)^2 + y^2 ≤ 1.",
                                    "Interprete como disco unitário centrado em (-1, 0) no plano z.",
                                    "Verifique para λ real negativo: z = h λ ≤ 0, restrição h |λ| ≤ 2."
                                  ],
                                  "verification": "Desenhe o círculo e marque pontos como z=-2 (instável) e z=-0.5 (estável).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para plotar",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use completamento do quadrado para derivar o círculo rapidamente.",
                                  "learningObjective": "Derivar matematicamente a região de estabilidade como disco unitário deslocado.",
                                  "commonMistakes": [
                                    "Erro no completamento do quadrado (esquecer o +1)",
                                    "Confundir raio 1 com centro em 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar e interpretar a região de estabilidade",
                                  "subSteps": [
                                    "Plote o disco: centro (-1,0), raio 1, tocando a origem.",
                                    "Marque a parte real negativa: do 0 ao -2 no eixo real.",
                                    "Analise para autovalores reais negativos: h ≤ 2 / |λ|.",
                                    "Discuta implicações para passos de tempo grandes: método condicionalmente estável.",
                                    "Compare com métodos implícitos (região maior)."
                                  ],
                                  "verification": "Reproduza o gráfico à mão e indique o intervalo para Re(λ) < 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Desmos ou Python com matplotlib)",
                                    "Folha de exercícios de estabilidade"
                                  ],
                                  "tips": "Rotacione o eixo imaginário para clareza no desenho.",
                                  "learningObjective": "Visualizar e interpretar graficamente as restrições de estabilidade.",
                                  "commonMistakes": [
                                    "Desenhar círculo centrado na origem",
                                    "Ignorar a porção imaginária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir restrições para problemas stiff",
                                  "subSteps": [
                                    "Defina equações stiff: autovalores com |Re(λ)| grande negativo e pequeno imaginário.",
                                    "Explique por que Euler explícito falha: h deve ser muito pequeno (h << 2/|λ_max|).",
                                    "Calcule exemplo: para λ = -1000, h ≤ 0.002.",
                                    "Compare custo computacional vs. métodos A-estáveis (ex: Backward Euler).",
                                    "Conclua limitações e quando usar Euler explícito (não-stiff)."
                                  ],
                                  "verification": "Para λ = -50, calcule h_max e simule 10 passos numéricamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python simples para Euler",
                                    "Exemplos de problemas stiff (ex: van der Pol)"
                                  ],
                                  "tips": "Simule numericamente para validar a teoria.",
                                  "learningObjective": "Aplicar análise a problemas stiff e reconhecer limitações práticas.",
                                  "commonMistakes": [
                                    "Subestimar impacto de λ pequeno em h",
                                    "Confundir stiff com oscilatório"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -100 y, y(0)=1. Com h=0.01 (estável), a solução numérica decai corretamente; com h=0.03 (>0.02), oscila e diverge, demonstrando a restrição h ≤ 2/100=0.02.",
                              "finalVerifications": [
                                "Desenha corretamente o disco de estabilidade centrado em (-1,0).",
                                "Calcula h_max = 2/|λ| para λ real negativo.",
                                "Explica por que falha em stiff problems.",
                                "Identifica |1 + z| >1 fora da região.",
                                "Compara com região de Euler implícito.",
                                "Simula exemplo simples sem divergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da desigualdade |1 + z| ≤ 1 (100%).",
                                "Correção do gráfico da região (sem erros de escala).",
                                "Interpretação qualitativa para stiff (clareza e profundidade).",
                                "Cálculos numéricos exatos para h_max.",
                                "Conexão com custo computacional.",
                                "Uso correto de terminologia (A-estável, Dahlquist)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de decaimento radioativo (equações diferenciais lineares).",
                                "Engenharia: Controle de sistemas dinâmicos com autovalores stiff.",
                                "Computação: Implementação eficiente em solvers numéricos (SciPy ODEINT).",
                                "Química: Modelagem de reações stiff em cinética química.",
                                "Estatística: Análise de erro em métodos Monte Carlo para EDOs."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC stiff ou modelos climáticos com escalas múltiplas, onde Euler explícito exige h minúsculo, levando à adoção de métodos implícitos para eficiência computacional em software como COMSOL ou MATLAB Simulink."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.1"
                            ]
                          },
                          {
                            "id": "10.1.1.6.2.4",
                            "name": "Comparar estabilidade com problemas stiff",
                            "description": "Explicar como a pequena região de estabilidade do Euler explícito limita seu uso em problemas stiff, onde h deve ser muito pequeno para manter hλ dentro da região estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de problemas stiff em EDOs",
                                  "subSteps": [
                                    "Defina problemas stiff: sistemas de EDOs com escalas de tempo muito diferentes (eigenvalues com partes reais muito negativas e próximas de zero).",
                                    "Explique o papel dos eigenvalues na rigidez: componentes rápidas (Re(λ) << 0) e lentas.",
                                    "Discuta impactos na simulação numérica: necessidade de passos h muito pequenos para estabilidade.",
                                    "Classifique exemplos clássicos: equação y' = -1000(y-1) + sin(t), onde λ ≈ -1000.",
                                    "Compare com problemas não-stiff para destacar diferenças."
                                  ],
                                  "verification": "Resuma em 3 frases o que torna um problema stiff e dê um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. EDOs)",
                                    "Notebook com Python/MATLAB para plotar eigenvalues"
                                  ],
                                  "tips": "Use analogia de molas: uma mola rígida (rápida) e uma frouxa (lenta) acopladas.",
                                  "learningObjective": "Identificar e caracterizar problemas stiff com base em eigenvalues do Jacobiano.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade.",
                                    "Ignorar que stiff pode ser linear.",
                                    "Achar que todos os problemas com λ negativo são stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a região de estabilidade do método de Euler explícito",
                                  "subSteps": [
                                    "Lembre a análise de estabilidade: para y' = λy, iteração y_{n+1} = (1 + hλ) y_n.",
                                    "Determine a região de estabilidade absoluta: |1 + z| ≤ 1 onde z = hλ, disco unitário no plano complexo centrado em -1.",
                                    "Plote a região: círculo de raio 1 à esquerda do imaginário.",
                                    "Calcule o limite para λ real negativo: h < 2 / |λ| para estabilidade.",
                                    "Verifique com teste numérico simples em y' = -λy (λ>0)."
                                  ],
                                  "verification": "Desenhe ou descreva a região de estabilidade e compute h_max para λ = -10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Desmos ou Python matplotlib)",
                                    "Folha de papel para esboço manual"
                                  ],
                                  "tips": "Pense em z = hλ como escala: região pequena força h minúsculo para |λ| grande.",
                                  "learningObjective": "Descrever graficamente e analiticamente a região de estabilidade do Euler explícito.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com condicional.",
                                    "Esquecer que região é limitada para Re(z) < 0.",
                                    "Calcular errado o raio do disco."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar limitações do Euler explícito em problemas stiff",
                                  "subSteps": [
                                    "Para stiff: λ com Re(λ) muito negativo → hλ fora da região se h não minúsculo.",
                                    "Quantifique: se |λ| = 10^6, h < 2e-6 para estabilidade, mas precisão exige h ainda menor.",
                                    "Simule oscilações ou divergência: y_n explode apesar de solução exata y→0.",
                                    "Compare custo computacional: número de passos N = T/h explode.",
                                    "Discuta trade-off: precisão vs. eficiência em stiff."
                                  ],
                                  "verification": "Execute simulação com h inadequado e observe instabilidade numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/Octave pronto para y' = -1000y",
                                    "Gráficos de solução exata vs. numérica"
                                  ],
                                  "tips": "Use log-plot para ver blow-up rápido da solução numérica.",
                                  "learningObjective": "Explicar quantitativamente por que Euler explícito é impraticável em stiff.",
                                  "commonMistakes": [
                                    "Achar que erro de truncamento causa instabilidade (é estabilidade).",
                                    "Usar h fixo sem testar limites.",
                                    "Ignorar que solução física é estável mas numérica não."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com alternativas e sintetizar implicações",
                                  "subSteps": [
                                    "Introduza métodos implícitos: Euler implícito tem região ilimitada à esquerda.",
                                    "Compare regiões: Euler explícito (disco pequeno) vs. implícito (meio-plano).",
                                    "Discuta métodos A-stáveis (ex: trapezoidal, BDF) ideais para stiff.",
                                    "Avalie critérios de escolha: stiff → implícito ou adaptativo (Runge-Kutta embutido).",
                                    "Conclua: Euler explícito só para não-stiff ou h muito pequeno (inviável)."
                                  ],
                                  "verification": "Crie tabela comparativa: método, região de estabilidade, adequação a stiff.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou LaTeX",
                                    "Referências: Hairer 'Solving ODEs' vol. I"
                                  ],
                                  "tips": "Memorize: explícito para não-stiff, implícito para stiff.",
                                  "learningObjective": "Comparar estabilidade de Euler explícito vs. métodos adequados a stiff.",
                                  "commonMistakes": [
                                    "Achar todos implícitos melhores (custo por passo maior).",
                                    "Confundir A-stabilidade com L-estabilidade.",
                                    "Subestimar stiff em aplicações reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o problema stiff y' = -1000(y - sin(t)) + cos(t), t em [0,1], y(0)=1. Com Euler explícito e h=0.01, observe oscilações selvagens e divergência, enquanto h=1e-5 estabiliza mas requer 100.000 passos (lento). Solução exata segue sin(t) suavemente.",
                              "finalVerifications": [
                                "Explica corretamente região de estabilidade do Euler explícito.",
                                "Identifica problemas stiff via eigenvalues.",
                                "Demonstra falha numérica em simulação stiff com h inadequado.",
                                "Compara com métodos implícitos.",
                                "Justifica por que h deve ser minúsculo em stiff.",
                                "Cria gráfico comparativo de regiões de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da região de estabilidade (disco unitário).",
                                "Correta quantificação de h_max = 2/|λ|.",
                                "Análise clara de implicações em stiff (custo N=T/h).",
                                "Uso de exemplos numéricos concretos.",
                                "Comparação válida com alternativas A-estáveis.",
                                "Ausência de confusão entre estabilidade e precisão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff em eletrônica.",
                                "Química: Cinemática de reações com escalas rápidas/lentas.",
                                "Engenharia: Simulações CFD com rigidez em escoamentos viscosos.",
                                "Computação: Otimização de solvers numéricos em SciPy/ODEPACK."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos stiff (reações rápidas de equilíbrio + lentas), Euler explícito falha causando predições erradas de concentrações; usa-se Backward Euler para h razoável, permitindo otimização industrial segura e eficiente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Implicações Práticas da Estabilidade",
                        "description": "Aplicações e considerações práticas da análise de estabilidade, incluindo escolha de h e introdução a métodos implicitos para maior estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Calcular passo h para estabilidade",
                            "description": "Dado λ, calcular o valor máximo de h tal que |1 + hλ| ≤ 1 para o método de Euler explícito em equações lineares reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a condição de estabilidade do método de Euler explícito",
                                  "subSteps": [
                                    "Revise a equação teste y' = λy, onde λ é real e negativo para estabilidade.",
                                    "Identifique o fator de amplificação R(z) = 1 + z, com z = hλ.",
                                    "Explique que para estabilidade, o módulo |R(z)| ≤ 1 deve valer para manter a solução numérica limitada.",
                                    "Discuta a região de estabilidade no plano complexo, focando no eixo real negativo.",
                                    "Anote a desigualdade |1 + hλ| ≤ 1 como ponto de partida."
                                  ],
                                  "verification": "Escreva a fórmula do fator de amplificação e a condição |1 + hλ| ≤ 1 corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas de aula sobre análise numérica.",
                                  "tips": "Desenhe o plano z para visualizar a região |1 + z| ≤ 1.",
                                  "learningObjective": "Compreender o conceito de estabilidade absoluta via fator de amplificação.",
                                  "commonMistakes": "Confundir Euler explícito com implícito (R(z) = 1/(1 - z))."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a desigualdade |1 + hλ| ≤ 1 para λ real negativo",
                                  "subSteps": [
                                    "Assuma λ < 0 e defina μ = h|λ|, onde μ > 0.",
                                    "Reescreva a desigualdade como |1 - h|λ|| ≤ 1.",
                                    "Considere os casos: 1 - h|λ| ≥ -1 e 1 - h|λ| ≤ 1.",
                                    "Resolva: h|λ| ≤ 2 a partir de 1 - h|λ| ≥ -1, pois o outro caso é sempre verdadeiro para h > 0.",
                                    "Conclua que h ≤ 2/|λ|."
                                  ],
                                  "verification": "Derive algebraicamente h_max = 2/|λ| e teste com um valor numérico simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, quadro branco ou papel para equações.",
                                  "tips": "Use substituição z = hλ com λ = -|λ| para simplificar.",
                                  "learningObjective": "Derivar matematicamente o limite superior para h.",
                                  "commonMistakes": "Esquecer que λ < 0 e tratar como positivo, levando a h negativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular h máximo para um λ dado",
                                  "subSteps": [
                                    "Receba um valor específico de λ (ex: λ = -1).",
                                    "Calcule |λ|.",
                                    "Aplique a fórmula h_max = 2 / |λ|.",
                                    "Verifique se |1 + h_max λ| = 1.",
                                    "Teste um h ligeiramente maior para observar violação."
                                  ],
                                  "verification": "Confirme que para h = h_max, |1 + hλ| = 1, e para h > h_max, >1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica.",
                                  "tips": "Use precisão decimal para evitar erros de arredondamento.",
                                  "learningObjective": "Aplicar a fórmula para obter h_max numericamente.",
                                  "commonMistakes": "Arredondar incorretamente ou inverter |λ|."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade em uma iteração numérica simples",
                                  "subSteps": [
                                    "Implemente uma iteração de Euler: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Escolha y_0 = 1 e compute 2-3 passos com h = h_max e h > h_max.",
                                    "Observe se |y_n| permanece ≤1 para h_max e cresce para h maior.",
                                    "Compare com a solução exata e^{-λ t}.",
                                    "Registre os resultados em uma tabela."
                                  ],
                                  "verification": "A solução numérica com h_max não explode, mas com h maior sim.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou Python simples para iterações.",
                                  "tips": "Comece com poucos passos para ver o efeito.",
                                  "learningObjective": "Validar a condição de estabilidade por experimentação numérica.",
                                  "commonMistakes": "Usar h muito pequeno, mascarando o problema de instabilidade."
                                }
                              ],
                              "practicalExample": "Dado λ = -5 (modelo de decaimento rápido), calcule h_max = 2/5 = 0.4. Para h=0.4, |1 + 0.4*(-5)| = |1-2| =1. Para h=0.5, |1-2.5|=1.5 >1, levando a instabilidade.",
                              "finalVerifications": [
                                "Derivação correta de h ≤ 2/|λ|.",
                                "Cálculo numérico preciso de h_max para λ dado.",
                                "Verificação |1 + hλ| ≤1 para h ≤ h_max.",
                                "Demonstração de instabilidade com h > h_max via iterações.",
                                "Explicação verbal da implicação prática.",
                                "Tabela comparativa de erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (100% correto).",
                                "Cálculo numérico exato sem erros de arredondamento.",
                                "Interpretação correta da condição |R| ≤1.",
                                "Uso apropriado de exemplos numéricos para validação.",
                                "Clareza na explicação de erros comuns.",
                                "Conexão com contexto de PVI."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de decaimento radioativo.",
                                "Programação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Controle de passos em métodos de integração numérica.",
                                "Estatística: Análise de erro em aproximações estocásticas."
                              ],
                              "realWorldApplication": "Em modelagem computacional de sistemas dinâmicos como epidemias (SIR models) ou circuitos elétricos, escolher h ≤ 2/|λ_max| garante simulações estáveis sem oscilações artificiais, essencial para previsões confiáveis em engenharia e ciências."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.2"
                            ]
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Avaliar estabilidade em exemplos numéricos",
                            "description": "Implementar numericamente o método de Euler para y' = λy com diferentes h e observar o comportamento estável vs. instável, confirmando a análise teórica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema de teste e a análise teórica de estabilidade",
                                  "subSteps": [
                                    "Revise a equação diferencial y' = λy, onde λ é negativo para simular decaimento exponencial.",
                                    "Estude a condição de estabilidade do método de Euler explícito: |1 + hλ| < 1, implicando h < 2/|λ|.",
                                    "Calcule manualmente os primeiros passos para um exemplo com λ = -1 e h = 0.5 (estável) e h = 3 (instável).",
                                    "Compare com a solução exata y(t) = y0 * e^(λt).",
                                    "Anote as expectativas teóricas para comportamentos estável (decaimento) vs. instável (oscilações ou explosão)."
                                  ],
                                  "verification": "Resumo escrito das condições teóricas e cálculos manuais coincidem com referências bibliográficas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica, caderno, calculadora.",
                                  "tips": "Use λ = -1 para simplificar cálculos iniciais.",
                                  "learningObjective": "Entender a base teórica da estabilidade no método de Euler.",
                                  "commonMistakes": "Confundir Euler explícito com implícito; ignorar que λ deve ser negativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de Euler em software",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação (ex: Python com NumPy/Matplotlib).",
                                    "Defina parâmetros: y0 = 1, λ = -1, t_final = 5, intervalos de h (0.1, 0.5, 1.5, 3.0).",
                                    "Codifique o iterador: y_{n+1} = y_n + h * λ * y_n.",
                                    "Gere soluções numéricas para cada h e plote y_n vs. n ou t.",
                                    "Adicione plot da solução exata para comparação."
                                  ],
                                  "verification": "Código executa sem erros e gera gráficos iniciais para h=0.1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/Jupyter Notebook, bibliotecas NumPy, Matplotlib.",
                                  "tips": "Use loops for para variar h automaticamente.",
                                  "learningObjective": "Implementar corretamente o método de Euler para o problema de teste.",
                                  "commonMistakes": "Erro no cálculo de h*λ*y_n; plotar vs. n em vez de t."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações com diferentes valores de h e observar comportamentos",
                                  "subSteps": [
                                    "Execute o código para h pequeno (ex: 0.1): observe decaimento suave próximo à exata.",
                                    "Aumente h gradualmente (0.5, 1.0, 1.9): note perda de precisão mas ainda estável.",
                                    "Teste h > 2/|λ| (ex: 3.0): observe oscilações ou divergência.",
                                    "Registre métricas: erro máximo, número de passos até instabilidade.",
                                    "Repita com outro λ (ex: λ=-10) para confirmar generalização."
                                  ],
                                  "verification": "Gráficos mostram claramente transição estável-instável; tabela de erros gerada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código do passo anterior, computador.",
                                  "tips": "Salve figuras separadas para cada h para análise comparativa.",
                                  "learningObjective": "Identificar numericamente comportamentos estável e instável.",
                                  "commonMistakes": "Escolher h muito pequeno ignorando instabilidade; não normalizar tempo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e confirmar a teoria",
                                  "subSteps": [
                                    "Compare gráficos numéricos com solução exata e previsão teórica.",
                                    "Calcule o fator de amplificação r = 1 + hλ para cada h e relacione com |r| <1.",
                                    "Discuta implicações: escolha de h para estabilidade prática.",
                                    "Gere relatório com tabelas, gráficos e conclusões.",
                                    "Teste sensibilidade variando y0 ou t_final."
                                  ],
                                  "verification": "Relatório explica por que h=3 causa instabilidade, com |r|>1 comprovado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Gráficos gerados, editor de texto.",
                                  "tips": "Use log| y_n | para visualizar decaimento vs. crescimento.",
                                  "learningObjective": "Conectar simulações numéricas à análise teórica de estabilidade.",
                                  "commonMistakes": "Atribuir instabilidade a erros de arredondamento em vez de h grande."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, com h=0.1: solução numérica decai suavemente para ~0.0067 em t=5 (exata e^(-5)≈0.0067). Com h=3: y_n oscila e explode após poucos passos, confirmando |1 + 3*(-1)|=2>1.",
                              "finalVerifications": [
                                "Gráficos distinguem claramente regimes estável e instável.",
                                "Tabela de |1 + hλ| correlaciona com observações numéricas.",
                                "Erro relativo diminui com h menor no regime estável.",
                                "Solução numérica aproxima exata para h<2/|λ|.",
                                "Relatório cita análise teórica corretamente.",
                                "Testes com múltiplos λ confirmam generalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação do método de Euler (sem erros algorítmicos).",
                                "Qualidade dos gráficos e visualização de estabilidade.",
                                "Correta identificação do limiar h ≈ 2/|λ|.",
                                "Análise quantitativa (erros, fatores de amplificação).",
                                "Conexão explícita entre simulação e teoria.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica e visualização de dados.",
                                "Física: Modelagem de decaimento radioativo ou amortecimento.",
                                "Engenharia: Simulações em controle de sistemas dinâmicos.",
                                "Estatística: Análise de erros numéricos e precisão."
                              ],
                              "realWorldApplication": "Em simulações de populações biológicas (decaimento), previsão meteorológica ou circuitos elétricos RC, onde escolher h inadequado leva a previsões errôneas, guiando o design de solvers numéricos estáveis em software como MATLAB ou COMSOL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.2"
                            ]
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Discutir limitações para equações lineares",
                            "description": "Analisar como a estabilidade absoluta restringe o método de Euler para equações lineares com partes reais de λ negativas grandes, motivando controle adaptativo de passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler e Conceitos Básicos de Estabilidade",
                                  "subSteps": [
                                    "Relembrar a formulação do método de Euler forward: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Explicar o teste de estabilidade de Dahlquist para o modelo y' = λ y.",
                                    "Derivar a condição de amplificação |1 + h λ| ≤ 1 para estabilidade absoluta.",
                                    "Discutir o que significa estabilidade absoluta no contexto de problemas lineares.",
                                    "Identificar o papel da parte real de λ na restrição de h."
                                  ],
                                  "verification": "Derivar corretamente a condição |1 + h λ| ≤ 1 e explicar seu significado em um parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Desenhe o plano complexo para visualizar a região de estabilidade.",
                                  "learningObjective": "Compreender os fundamentos teóricos da estabilidade no método de Euler.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; ignorar que λ é complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade para Equações Lineares com Re(λ) Negativas Grandes",
                                  "subSteps": [
                                    "Considerar λ real negativo com |λ| grande, como λ = -100.",
                                    "Calcular o limite superior para h: h < 2 / |λ| a partir de |1 + h λ| ≤ 1.",
                                    "Simular numericamente com h fixo grande (ex: h=0.1 para λ=-100) e observar divergência.",
                                    "Comparar com h pequeno (ex: h=0.001) para mostrar convergência.",
                                    "Plotar erro vs. h para visualizar a restrição."
                                  ],
                                  "verification": "Produzir gráfico ou tabela mostrando instabilidade para h > 2/|λ|.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software como Python (NumPy/Matplotlib) ou MATLAB, exemplos de código prontos.",
                                  "tips": "Use loops simples em Python para simulações rápidas; normalize y(0)=1.",
                                  "learningObjective": "Demonstrar quantitativamente como |Re(λ)| grande impõe h muito pequeno.",
                                  "commonMistakes": "Escolher h inicial muito pequeno sem testar limites; não normalizar soluções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discutir Limitações Impostas pela Estabilidade Absoluta",
                                  "subSteps": [
                                    "Explicar que para sistemas rígidos (λ com |Re(λ)| grande), h deve ser minúsculo, aumentando custo computacional.",
                                    "Comparar com métodos implicitos (ex: backward Euler) que têm região de estabilidade maior.",
                                    "Analisar trade-off: precisão vs. eficiência em problemas reais com escalas múltiplas.",
                                    "Discutir impacto em simulações de longo tempo (muitos passos necessários).",
                                    "Relacionar com a rigidez de EDOs."
                                  ],
                                  "verification": "Escrever um ensaio curto (200 palavras) listando 3 limitações principais com exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos sobre rigidez em EDOs, quadro branco para brainstorm.",
                                  "tips": "Use analogia de 'corrida de tartaruga' para h pequeno vs. eficiência.",
                                  "learningObjective": "Identificar e articular as restrições práticas da estabilidade no Euler.",
                                  "commonMistakes": "Ignorar custo computacional (O(1/h)); superestimar robustez do método."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Motivar o Controle Adaptativo de Passo",
                                  "subSteps": [
                                    "Introduzir ideia de h variável: aumentar h em regiões estáveis, reduzir em instáveis.",
                                    "Descrever critérios simples como controle por erro local (ex: embutido Runge-Kutta).",
                                    "Simular exemplo com step-size adaptativo vs. fixo para λ=-100.",
                                    "Discutir vantagens: eficiência sem perda de estabilidade.",
                                    "Explorar bibliotecas como SciPy odeint com adaptação automática."
                                  ],
                                  "verification": "Implementar e comparar simulações adaptativa vs. fixa, medindo tempo e erro.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com SciPy, Jupyter Notebook.",
                                  "tips": "Comece com tol=1e-6 para controle; monitore rejeições de passo.",
                                  "learningObjective": "Justificar a necessidade de adaptação como solução para limitações do Euler.",
                                  "commonMistakes": "Não calibrar tolerância corretamente; confundir com métodos de ordem superior."
                                }
                              ],
                              "practicalExample": "Considere y' = -100 y, y(0)=1. Com h=0.05 fixo (>0.02), Euler diverge após poucos passos (y cresce exponencialmente). Com controle adaptativo (tol=1e-6 em SciPy), h inicia pequeno (~0.001) e ajusta, convergindo para y(t)≈0 em t=0.1 com ~200 passos eficientes.",
                              "finalVerifications": [
                                "Derivar corretamente h_max = 2 / |λ| para λ real negativo.",
                                "Simular e plotar instabilidade para h grande em exemplo numérico.",
                                "Explicar verbalmente 3 limitações do Euler em sistemas rígidos.",
                                "Comparar eficiência de h fixo vs. adaptativo em simulação.",
                                "Identificar rigidez como causa raiz das restrições."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição de estabilidade (100% correta).",
                                "Qualidade dos gráficos/simulações (clareza, escalas adequadas).",
                                "Profundidade na discussão de limitações (exemplos quantitativos).",
                                "Evidência de compreensão de rigidez e adaptação (explicação coerente).",
                                "Eficiência na implementação adaptativa (erro <1e-5, passos razoáveis)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou amortecimento rígido.",
                                "Engenharia: Simulações de controle em sistemas dinâmicos (ex: PID com EDOs rígidas).",
                                "Computação: Otimização de algoritmos numéricos e análise de complexidade.",
                                "Química Computacional: Cinética de reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC rígidos ou modelos climáticos com processos rápidos (ex: turbulência), onde h fixo no Euler falha, mas controle adaptativo permite simulações precisas e viáveis em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.6.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Métodos de Passo Múltiplo para Problema de Valor Inicial",
                "description": "Métodos numéricos que utilizam passos anteriores para avançar na solução de problemas de valor inicial.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Formulação Geral dos Métodos de Passo Múltiplo",
                    "description": "Definição e equação geral dos métodos lineares multistep (LMS) para problemas de valor inicial, utilizando valores em passos anteriores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição dos Métodos Lineares Multistep (LMS)",
                        "description": "Os métodos LMS são algoritmos numéricos para resolver problemas de valor inicial (PVI) da forma y' = f(t,y), y(t0)=y0, que utilizam uma combinação linear de valores da solução aproximada em k+1 pontos consecutivos para avançar o passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir métodos lineares multistep",
                            "description": "Explicar que os LMS utilizam valores y_{n}, y_{n-1}, ..., y_{n-k} e derivadas correspondentes para aproximar y_{n+1}, destacando sua eficiência para integrações de longo tempo em comparação aos métodos de passo único.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Métodos de Passo Único para Contraste",
                                  "subSteps": [
                                    "Relembre a definição de métodos de passo único, como o método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Identifique limitações: acurácia baixa para passos grandes e necessidade de avaliações frequentes da derivada.",
                                    "Discuta por que são ineficientes para simulações de longo tempo devido ao acúmulo de erro.",
                                    "Compare com a intuição de usar histórico de pontos para melhor precisão.",
                                    "Anote exemplos de EDOs onde passo único falha em longo prazo."
                                  ],
                                  "verification": "Escreva um resumo de 3 limitações dos métodos de passo único e como histórico pode ajudar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (cap. EDOs), notas de aula sobre Euler/Runge-Kutta.",
                                  "tips": "Use diagramas de fluxo para visualizar iterações de passo único vs. múltiplo.",
                                  "learningObjective": "Compreender o papel dos métodos de passo único como base para introduzir LMS.",
                                  "commonMistakes": "Confundir passo único com explícito/implícito sem focar em eficiência temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Formulação Geral dos Métodos Lineares Multistep (LMS)",
                                  "subSteps": [
                                    "Estude a fórmula geral: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}, com α_{k}=1.",
                                    "Explique que usa k+1 valores anteriores y_n até y_{n+k} para aproximar y_{n+1}.",
                                    "Classifique em explícitos (β_{k+1}=0) e implícitos (β_{k+1}≠0).",
                                    "Derive intuitivamente para k=1: relação com trapezoidal.",
                                    "Pratique reescrevendo para y_{n+1} isolado."
                                  ],
                                  "verification": "Escreva a fórmula geral do LMS e identifique α_j e β_j para um método de 1 passo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de derivação, software como MATLAB/Octave para testar fórmula básica.",
                                  "tips": "Memorize a normalização α_k=1 para padronizar.",
                                  "learningObjective": "Dominar a notação e estrutura matemática dos LMS.",
                                  "commonMistakes": "Esquecer o fator h nas derivadas ou inverter índices de j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Componentes e Notação dos LMS",
                                  "subSteps": [
                                    "Defina os polinômios geradores: α(ζ) = ∑ α_j ζ^j, β(ζ) = ∑ β_j ζ^j.",
                                    "Discuta ordem do método: p tal que α(1)=β'(1)=0 e β(1)≠0 para consistência.",
                                    "Examine exemplos: Adams-Bashforth (explícito), Adams-Moulton (implícito).",
                                    "Analise como k maior usa mais histórico para maior ordem.",
                                    "Crie tabela comparando LMS de ordem 1 a 3."
                                  ],
                                  "verification": "Construa tabela com α, β para LMS explícito de 2 passos e verifique consistência.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela de coeficientes LMS (da referência), calculadora simbólica como SymPy.",
                                  "tips": "Use expansão de Taylor para verificar ordem intuitivamente.",
                                  "learningObjective": "Entender os coeficientes e propriedades de consistência/estabilidade.",
                                  "commonMistakes": "Confundir ordem de precisão com número de passos k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Eficiência para Integrações de Longo Tempo",
                                  "subSteps": [
                                    "Compare custo computacional: LMS requer menos avaliações de f por passo que métodos de passo único de mesma ordem.",
                                    "Discuta estabilidade: LMS multistep permite passos maiores sem oscilação.",
                                    "Analise erro global: O(h^p) com p alto via histórico.",
                                    "Simule numericamente uma EDO rígida (ex: y'= -100y) com passo único vs. LMS.",
                                    "Conclua vantagens: eficiência em t final grande."
                                  ],
                                  "verification": "Explique em parágrafo por que LMS é melhor para [0,T] com T>>h.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python/MATLAB para simulação EDO, gráficos de erro.",
                                  "tips": "Plote trajetórias para visualizar acúmulo de erro.",
                                  "learningObjective": "Justificar superioridade prática dos LMS.",
                                  "commonMistakes": "Ignorar necessidade de valores iniciais (startup com Runge-Kutta)."
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y, y(0)=1 até t=10 com h=0.1 usando LMS explícito de 2 passos (Adams-Bashforth): y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}). Inicie com Euler para y1, y2; então itere, observando que converge melhor que Euler puro sem acúmulo excessivo.",
                              "finalVerifications": [
                                "Escreva corretamente a fórmula geral LMS com notação padrão.",
                                "Identifique e explique α_j, β_j em um exemplo de k=2.",
                                "Descreva 2 vantagens sobre métodos de passo único.",
                                "Verifique consistência de um LMS simples via condições em ζ=1.",
                                "Compare custo: avaliações de f por passo em LMS vs. RK4.",
                                "Simule e plote solução para EDO linear longa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (fórmula geral e coeficientes).",
                                "Compreensão conceitual de uso de histórico multistep.",
                                "Explicação clara de eficiência computacional.",
                                "Correta identificação de explícito/implícito.",
                                "Uso apropriado de exemplos e verificações numéricas.",
                                "Análise de limitações e condições de inicialização."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em Python/NumPy para solvers de EDO (SciPy odeint usa LMS).",
                                "Física: Simulações dinâmicas em mecânica orbital (longas integrações).",
                                "Engenharia: Modelagem de circuitos RLC rígidos com LMS implícitos.",
                                "Estatística: Simulações Monte Carlo para processos estocásticos discretos."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, LMS multistep integram EDOs de dinâmica atmosférica por dias/semanas com passos eficientes, minimizando custo computacional em supercomputadores; similar em simulações financeiras de opções ou modelagem populacional em epidemiologia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Diferenciar LMS de métodos de passo único",
                            "description": "Comparar LMS com métodos como Runge-Kutta, identificando que LMS requerem valores iniciais de k passos (startup) mas são mais econômicos por função f avaliada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Métodos de Passo Único",
                                  "subSteps": [
                                    "Defina métodos de passo único, como Runge-Kutta, que utilizam apenas o valor atual y_n para computar y_{n+1}.",
                                    "Analise a fórmula geral: y_{n+1} = y_n + h * sum b_i k_i, onde k_i são derivadas em pontos intermediários.",
                                    "Estude exemplos como RK4 e conte o número de avaliações da função f por passo (tipicamente 4 para ordem 4).",
                                    "Registre as vantagens: alta precisão local sem necessidade de histórico.",
                                    "Identifique limitações iniciais: cada passo é independente."
                                  ],
                                  "verification": "Escreva um resumo com fórmula e número de avaliações de f para RK4.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Anotações de aula sobre Runge-Kutta",
                                    "Calculadora ou software como Python/Octave"
                                  ],
                                  "tips": [
                                    "Desenhe a tabela de Butcher para visualizar os estágios.",
                                    "Teste com um PVI simples como y' = y, y(0)=1."
                                  ],
                                  "learningObjective": "Compreender a estrutura e custo computacional dos métodos de passo único.",
                                  "commonMistakes": [
                                    "Confundir precisão local com global.",
                                    "Ignorar que cada passo requer múltiplas avaliações de f independentemente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Formulação dos Métodos Linears Multistep (LMS)",
                                  "subSteps": [
                                    "Apresente a fórmula geral dos LMS: sum_{j=0}^k α_j y_{n+j} = h sum_{j=0}^k β_j f_{n+j}.",
                                    "Explique os coeficientes α e β para métodos de ordem k.",
                                    "Discuta a necessidade de k valores iniciais (startup) para iniciar o método.",
                                    "Exemplo: Método de Euler implícito ou Adams-Bashforth explícito.",
                                    "Conte as avaliações de f: tipicamente 1 por passo após startup."
                                  ],
                                  "verification": "Escreva a fórmula geral dos LMS e identifique o papel dos valores iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas sobre métodos multistep",
                                    "Software MATLAB ou Python com solvers ode",
                                    "Tabela de coeficientes LMS padrão"
                                  ],
                                  "tips": [
                                    "Memorize que LMS usam histórico de pontos para economizar avaliações.",
                                    "Comece com k=1 (Euler) para transição suave."
                                  ],
                                  "learningObjective": "Dominar a definição e requisitos iniciais dos LMS.",
                                  "commonMistakes": [
                                    "Esquecer que LMS implícitos requerem solução de sistemas lineares.",
                                    "Confundir ordem do método com número de passos k."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar LMS com Métodos de Passo Único",
                                  "subSteps": [
                                    "Liste diferenças chave: Passo único usa apenas y_n (múltiplas f), LMS usa k passos anteriores (1 f por passo).",
                                    "Compare custo: Passo único ~s avaliações f (s estágios), LMS ~1 f/ passo após startup.",
                                    "Analise startup: LMS precisa de k passos iniciais via outro método.",
                                    "Discuta estabilidade: LMS multistep podem ser mais estáveis para problemas rígidos.",
                                    "Calcule eficiência: Para N passos, custo LMS ≈ N + startup vs. sN para passo único."
                                  ],
                                  "verification": "Crie uma tabela comparativa com colunas: Dependência, Avaliações f, Startup, Exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Exemplos numéricos de PVIs",
                                    "Gráficos de erro de ambos métodos"
                                  ],
                                  "tips": [
                                    "Use um PVI com solução conhecida para contar avaliações manualmente.",
                                    "Foque em eficiência para grandes intervalos."
                                  ],
                                  "learningObjective": "Identificar e justificar as diferenças fundamentais entre LMS e métodos de passo único.",
                                  "commonMistakes": [
                                    "Subestimar custo do startup em LMS.",
                                    "Achar que LMS sempre usam mais f (ignorar economia por passo)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Diferenciação em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha um PVI: y' = -y, y(0)=1, em [0,1] com h=0.1.",
                                    "Compute 10 passos com RK4 (conte 40 f) e LMS k=2 após startup (conte ~12 f).",
                                    "Compare erros e tempo computacional simulado.",
                                    "Conclua sobre quando usar cada um: LMS para eficiência em longas simulações.",
                                    "Registre lições aprendidas sobre economia."
                                  ],
                                  "verification": "Apresente resultados numéricos mostrando economia de LMS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Papel para cálculos manuais",
                                    "Gráficos de solução exata vs. aproximada"
                                  ],
                                  "tips": [
                                    "Implemente funções simples para f e compare contadores de chamadas.",
                                    "Varie h para ver impacto na eficiência."
                                  ],
                                  "learningObjective": "Aplicar a comparação em prática para reforçar diferenciação.",
                                  "commonMistakes": [
                                    "Não contar corretamente as avaliações durante startup.",
                                    "Ignorar overhead de LMS implícitos."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = y(1 - y), y(0) = 0.5 (modelo logístico) em [0,10] com h=0.1. Use RK4: ~400 avaliações f. Use LMS Adams-Bashforth ordem 2 após 2 passos RK4: ~100 avaliações f. Observe que LMS é ~4x mais econômico, ideal para simulações longas.",
                              "finalVerifications": [
                                "Explica corretamente que LMS requerem k valores iniciais de startup.",
                                "Identifica que LMS usam tipicamente 1 avaliação de f por passo vs. múltiplas em passo único.",
                                "Compara eficiência: LMS mais econômicos para muitos passos.",
                                "Distingue dependência: passo único em y_n só, LMS em histórico.",
                                "Menciona exemplos como Runge-Kutta vs. Adams.",
                                "Reconhece limitações de LMS (startup e estabilidade zero-free)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula geral dos LMS e identificação de α, β.",
                                "Correta contagem e comparação de avaliações da função f.",
                                "Clareza na explicação do startup e seu impacto.",
                                "Uso de exemplos numéricos para ilustrar diferenças.",
                                "Análise qualitativa de eficiência e aplicabilidade.",
                                "Ausência de confusões entre precisão local/global."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para solvers ODE.",
                                "Física: Simulações de movimento em dinâmica (economia em trajetórias longas).",
                                "Engenharia: Modelagem de circuitos rígidos onde eficiência computacional é crítica.",
                                "Estatística: Integração numérica em processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão meteorológica, LMS são usados para integrar equações diferenciais ao longo de dias (milhares de passos), economizando tempo computacional em supercomputadores comparado a métodos como RK4, permitindo previsões mais rápidas e precisas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Classificar LMS em explícitos e implícitos",
                            "description": "Identificar métodos explícitos (β_k = 0, y_{n+1} explícito) e implícitos (β_k ≠ 0, requer solução de equação não linear), com exemplos como método de Euler explícito (1-step explícito) e backward (implícito).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação Geral dos Métodos Lineares Multistep (LMS)",
                                  "subSteps": [
                                    "Estude a fórmula geral do LMS: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Identifique os coeficientes α_j (para y) e β_j (para f).",
                                    "Note que k é a ordem do método e n indica o passo atual.",
                                    "Entenda que y_{n+k} é o valor a ser aproximado.",
                                    "Registre a dependência de y_{n+1} em relação aos valores futuros."
                                  ],
                                  "verification": "Escreva a fórmula geral de um LMS de ordem k=1 e identifique todos os coeficientes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Livro-texto de Análise Numérica (capítulo de LMS)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use notação padrão e destaque β_k como chave para classificação.",
                                  "learningObjective": "Compreender a estrutura matemática fundamental dos LMS.",
                                  "commonMistakes": [
                                    "Confundir α_j com β_j",
                                    "Ignorar o índice k como o último termo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Definir Métodos LMS Explícitos",
                                  "subSteps": [
                                    "Analise o termo β_k na fórmula: se β_k = 0, y_{n+1} é calculado diretamente sem equações adicionais.",
                                    "Verifique que todos os termos do lado direito usam f de pontos conhecidos (passados ou atuais).",
                                    "Confirme que o método é 'explícito' porque não requer iterações para resolver y_{n+1}.",
                                    "Anote estabilidade típica: geralmente condicionalmente estáveis.",
                                    "Exemplo inicial: Método de Euler explícito (k=1, α_0=-1, α_1=1, β_0=1, β_1=0)."
                                  ],
                                  "verification": "Classifique um LMS com β_1=0 como explícito e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de LMS do contexto do curso",
                                    "Software como Python/MATLAB para visualizar"
                                  ],
                                  "tips": "Sempre isole y_{n+k} no lado esquerdo para ver dependências.",
                                  "learningObjective": "Reconhecer critérios matemáticos para LMS explícitos.",
                                  "commonMistakes": [
                                    "Assumir estabilidade incondicional para explícitos",
                                    "Confundir com métodos de Runge-Kutta explícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Definir Métodos LMS Implícitos",
                                  "subSteps": [
                                    "Examine β_k ≠ 0: isso implica que y_{n+k} aparece implicitamente no lado direito via f(t_{n+k}, y_{n+k}).",
                                    "Entenda a necessidade de resolver uma equação não linear para y_{n+k}, tipicamente por métodos iterativos como Newton.",
                                    "Note vantagens: geralmente incondicionalmente estáveis para problemas rígidos.",
                                    "Exemplo: Método de Euler backward (k=1, α_0=-1, α_1=1, β_0=0, β_1=1).",
                                    "Compare computacionalmente: mais caro por passo, mas permite passos maiores."
                                  ],
                                  "verification": "Para um LMS dado com β_1=1, descreva o processo de resolução implícita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de coeficientes LMS padrão",
                                    "Artigo sobre estabilidade de LMS"
                                  ],
                                  "tips": "Pense em 'implícito' como 'auto-referencial' para y_{n+1}.",
                                  "learningObjective": "Diferenciar LMS implícitos pelos critérios β_k e impactos computacionais.",
                                  "commonMistakes": [
                                    "Subestimar custo iterativo",
                                    "Confundir com métodos multi-step não lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação com Exemplos e Distinções",
                                  "subSteps": [
                                    "Pegue exemplos: Euler explícito (explícito), backward (implícito), trapezoidal (implícito).",
                                    "Classifique 3-5 LMS fornecidos ou inventados baseados em coeficientes β.",
                                    "Discuta trade-offs: explícitos mais rápidos mas menos estáveis; implícitos oposto.",
                                    "Crie um fluxograma: Verificar β_k → Explícito ou Implícito.",
                                    "Teste com problema de EDO rígido para motivar escolha."
                                  ],
                                  "verification": "Classifique corretamente 5 LMS aleatórios e explique cada um.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de 10 coeficientes LMS para prática",
                                    "Planilha Excel para fluxograma"
                                  ],
                                  "tips": "Sempre verifique se β_k é exatamente zero.",
                                  "learningObjective": "Aplicar classificação de forma autônoma e consistente.",
                                  "commonMistakes": [
                                    "Classificar baseado apenas em ordem k",
                                    "Ignorar normalização dos coeficientes"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o LMS: y_{n+1} - y_n = h (0.5 f(t_n, y_n) + 0.5 f(t_{n+1}, y_{n+1})), classifique como implícito (β_1=0.5 ≠ 0), pois requer resolver y_{n+1} - 0.5 h f(t_{n+1}, y_{n+1}) = y_n + 0.5 h f(t_n, y_n) por iteração.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre explícito e implícito usando β_k.",
                                "Classificar corretamente Euler explícito e backward.",
                                "Identificar necessidade de solver não linear em implícitos.",
                                "Criar fluxograma de classificação.",
                                "Discutir estabilidade em contexto rígido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de β_k como critério chave (100%).",
                                "Correta distinção em exemplos padrão (90%+ acerto).",
                                "Explicação clara de implicações computacionais.",
                                "Uso correto de terminologia (explícito/implícito).",
                                "Demonstração de trade-offs em aplicações.",
                                "Fluxograma ou tabela de classificação funcional."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers iterativos em Python (SciPy).",
                                "Física: Simulações de EDOs rígidos em dinâmica.",
                                "Engenharia Computacional: Escolha de métodos em FEM/CFD.",
                                "Estatística: Análise de erro em séries temporais numéricas."
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ODE solvers ou COMSOL, LMS implícitos são usados para problemas rígidos em engenharia química (reatores), permitindo passos maiores e simulações mais eficientes sem instabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Equação Geral dos Métodos LMS",
                        "description": "A formulação geral dos LMS é dada pela equação de diferença linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}), com α_k = 1 e normalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Escrever a equação geral LMS",
                            "description": "Formular a equação ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}), explicando os papéis dos coeficientes α_j (para y) e β_j (para f escalado por h).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Problemas de Valor Inicial e Métodos de Passo Múltiplo",
                                  "subSteps": [
                                    "Lembre-se da forma geral do Problema de Valor Inicial (PVI): y' = f(t, y), y(t0) = y0.",
                                    "Diferencie métodos de passo único (usam apenas yn) de métodos de passo múltiplo (usam yn, yn-1, ..., yn-k).",
                                    "Entenda que métodos LMS (Linear Multistep) aproximam a solução usando combinações lineares de valores anteriores.",
                                    "Identifique k como a ordem do método, determinando quantos passos anteriores são necessários.",
                                    "Esboce um exemplo simples com k=1 para conectar com métodos de Euler implícito."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre passo único e múltiplo, citando um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno e caneta",
                                  "tips": "Use diagramas de timeline para visualizar yn, yn+1, ..., yn+k.",
                                  "learningObjective": "Compreender o contexto e motivação dos métodos LMS.",
                                  "commonMistakes": "Confundir k com o número total de passos em vez da ordem do método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Notação Padrão para a Equação LMS",
                                  "subSteps": [
                                    "Defina a notação: yn+j ≈ y(tn+j), onde tn+j = tn + jh, h é o passo de integração.",
                                    "Apresente os coeficientes α_j (j=0 a k) para os termos y_{n+j} e β_j para os termos f(t_{n+j}, y_{n+j}).",
                                    "Escreva a estrutura esquemática: soma α_j y_{n+j} = h * soma β_j f(t_{n+j}, y_{n+j}).",
                                    "Note que o lado esquerdo é uma combinação linear das soluções aproximadas.",
                                    "Destaque que o lado direito envolve a função f escalada pelo passo h."
                                  ],
                                  "verification": "Escreva a notação com índices corretos em um papel e confira com uma referência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de referência de análise numérica, calculadora simbólica (opcional)",
                                  "tips": "Anote os índices j=0 até k para evitar confusão nos limites da soma.",
                                  "learningObjective": "Dominar a notação exata usada na formulação geral LMS.",
                                  "commonMistakes": "Esquecer o fator h no lado direito ou inverter os índices de soma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Escrever a Equação Geral Completa",
                                  "subSteps": [
                                    "Escreva explicitamente: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Verifique os limites da soma: ambos de j=0 a k.",
                                    "Confirme que α_j ponderam as y's diretamente e β_j ponderam as f's com h.",
                                    "Teste reescrevendo para um caso k=0 (reduz a Euler implícito).",
                                    "Copie a equação 3 vezes de memória para fixar."
                                  ],
                                  "verification": "Reproduza a equação exata sem olhar para referências e compare.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno, quadro branco (se disponível), tabela de coeficientes LMS",
                                  "tips": "Use LaTeX ou editor matemático para praticar a escrita precisa.",
                                  "learningObjective": "Escrever corretamente a equação geral LMS de cor.",
                                  "commonMistakes": "Colocar h fora da soma dos β_j ou errar os subscritos nos argumentos de f."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar os Papéis dos Coeficientes α_j e β_j",
                                  "subSteps": [
                                    "Descreva α_j: coeficientes que garantem consistência e estabilidade na aproximação das y's.",
                                    "Explique β_j: determinam a contribuição das derivadas f, escaladas por h para dimensionalidade.",
                                    "Relacione com propriedades: soma α_j = 0 para consistência de ordem 1; condições para ordem maior.",
                                    "Dê exemplo: em Adams-Moulton, β_k ≠ 0 torna implícito.",
                                    "Discuta implicações: métodos explícitos têm β_{k+1}=0 (não na soma padrão)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando os papéis e cite um método específico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de métodos LMS (Adams-Bashforth, Backward Differentiation), notas de aula",
                                  "tips": "Associe α_j a 'pesos de história' e β_j a 'pesos de inclinação'.",
                                  "learningObjective": "Articular claramente o significado físico/matemático dos coeficientes.",
                                  "commonMistakes": "Confundir α_j com pesos de f ou ignorar o escalonamento por h."
                                }
                              ],
                              "practicalExample": "Para o método de Adams-Bashforth de ordem 2 (k=2, explícito): α_0=0, α_1=-1, α_2=1; β_0=0, β_1=4/3 h, β_2=-1/3 h? Não, forma padrão ajustada: y_{n+1} = y_n + h ( (3/2) f_n - (1/2) f_{n-1} ), mapeando α_2=1, α_1=-1, α_0=0; β_2=0, β_1=3/2, β_0=-1/2.",
                              "finalVerifications": [
                                "Pode escrever a equação ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}) sem erros?",
                                "Explica corretamente que α_j ponderam as soluções y e β_j as derivadas f escaladas por h?",
                                "Identifica k como o número de passos anteriores usados?",
                                "Distingue métodos explícitos (β_{k+1}=0 em extensões) dos implícitos?",
                                "Reescreve a equação para k=1 e reconhece como trapezoidal?",
                                "Verifica consistência básica: soma α_j ≈ 0 para ordem 1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (somas, índices, h correto).",
                                "Clareza na explicação dos papéis de α_j e β_j.",
                                "Capacidade de reproduzir de memória sem erros tipográficos.",
                                "Compreensão contextual (ligação com PVI e estabilidade).",
                                "Uso correto de exemplos concretos para ilustrar.",
                                "Identificação de propriedades como consistência ordem 1."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar LMS em Python (biblioteca SciPy odeint).",
                                "Física: Simulações de movimento orbital ou circuitos RLC.",
                                "Engenharia: Modelagem de sistemas dinâmicos em controle automático.",
                                "Estatística: Integração numérica em processos estocásticos."
                              ],
                              "realWorldApplication": "Usada em solvers numéricos como MATLAB ode15s ou SciPy para simular equações diferenciais em previsão meteorológica, dinâmica de fluidos computacional (CFD) e modelagem farmacocinética em medicina."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Interpretar coeficientes na equação LMS",
                            "description": "Analisar como os coeficientes α_j e β_j determinam a ordem e o tipo do método, com α_0 definindo o peso do passo mais antigo e β_k indicando se é explícito ou implícito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral da Equação LMS",
                                  "subSteps": [
                                    "Escrever a equação geral dos métodos LMS: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j})",
                                    "Identificar os índices j de 0 a k, onde k é o número de passos",
                                    "Explicar o lado esquerdo como combinação linear dos valores aproximados y",
                                    "Explicar o lado direito como combinação ponderada das derivadas escaladas por h",
                                    "Notar a normalização usual α_k = 1"
                                  ],
                                  "verification": "Reescrever corretamente a equação e rotular cada componente em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica",
                                    "Acesso a notas de aula"
                                  ],
                                  "tips": [
                                    "Desenhe um 'stencil' visualizando os pontos y_{n} a y_{n+k}",
                                    "Lembre-se: h é o tamanho do passo"
                                  ],
                                  "learningObjective": "Dominar a notação e estrutura fundamental da equação LMS.",
                                  "commonMistakes": [
                                    "Confundir índices de y_{n+j} com f_{n+j}",
                                    "Esquecer o fator h no lado direito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar os Coeficientes α_j",
                                  "subSteps": [
                                    "Reconhecer α_j como pesos na combinação linear dos valores y_{n+j}",
                                    "Identificar α_0 como o peso do passo mais antigo (geralmente negativo)",
                                    "Analisar a soma ∑ α_j ≈ 0 para consistência de ordem 1",
                                    "Verificar ∑ j α_j ≈ 0 para consistência de ordem 2",
                                    "Discutir como α_j afetam a ordem local do método"
                                  ],
                                  "verification": "Dado um conjunto de α_j, calcular somas ponderadas e prever consistência básica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de métodos LMS padrão",
                                    "Planilha para somas"
                                  ],
                                  "tips": [
                                    "Use expansão de Taylor para entender ∑ α_j y^{(0)} = 0",
                                    "Sempre verifique normalização α_k=1"
                                  ],
                                  "learningObjective": "Analisar o impacto dos α_j na precisão e consistência do método.",
                                  "commonMistakes": [
                                    "Ignorar normalização levando a escalas erradas",
                                    "Confundir com β_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os Coeficientes β_j",
                                  "subSteps": [
                                    "Reconhecer β_j como pesos nas derivadas f_{n+j}",
                                    "Verificar β_k: se β_k = 0, método explícito; senão, implícito",
                                    "Analisar ∑ β_j ≈ 1 para consistência ordem 1",
                                    "Verificar ∑ j β_j ≈ 1/2 para ordem 2",
                                    "Explicar como β_j influenciam a ordem e estabilidade"
                                  ],
                                  "verification": "Classificar método como explícito/implícito e calcular somas de β_j.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplos de métodos como Adams e BDF"
                                  ],
                                  "tips": [
                                    "Explícito é mais simples mas menos estável",
                                    "Use teorema de ordem para validação"
                                  ],
                                  "learningObjective": "Determinar o tipo de método e condições de consistência via β_j.",
                                  "commonMistakes": [
                                    "Assumir todos métodos explícitos",
                                    "Esquecer dependência em f(y_{n+k}) para implícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Interpretação para Propriedades do Método",
                                  "subSteps": [
                                    "Combinar análises de α_j e β_j para determinar ordem máxima p",
                                    "Verificar condições de consistência: ρ(ζ)=∑ α_j ζ^j, σ(ζ)=∑ β_j ζ^j",
                                    "Avaliar estabilidade preliminar via raiz principal de ρ",
                                    "Classificar método (ex: Adams-Bashforth explícito, BDF implícito)",
                                    "Prever vantagens/desvantagens baseadas nos coeficientes"
                                  ],
                                  "verification": "Dado coeficientes completos, descrever ordem, tipo e consistência em parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB para polinômios",
                                    "Tabelas de coeficientes LMS"
                                  ],
                                  "tips": [
                                    "Ordem p ≤ k para explícitos",
                                    "Teste com y' = λy para estabilidade"
                                  ],
                                  "learningObjective": "Integrar interpretações para caracterizar completamente o método LMS.",
                                  "commonMistakes": [
                                    "Superestimar ordem sem verificar condições",
                                    "Ignorar implicações numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o Backward Differentiation Formula (BDF1): α_0 = -1, α_1 = 1, β_0 = 0, β_1 = 1. α_0 negativo pesa o passado; β_1 ≠ 0 indica implícito (resolve y_{n+1} - y_n = h f(t_{n+1}, y_{n+1})); ordem 1, estável para problemas rígidos.",
                              "finalVerifications": [
                                "Identificar corretamente α_0 como peso do passo antigo",
                                "Classificar método como explícito/implícito via β_k",
                                "Calcular somas ∑ α_j e ∑ β_j para consistência ordem 1",
                                "Prever ordem aproximada pelos coeficientes",
                                "Explicar impacto de α_j em combinações lineares",
                                "Descrever papel de h na equação"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação e índices da equação (20%)",
                                "Correta interpretação de α_j e seu papel na consistência (25%)",
                                "Análise precisa de β_j para tipo de método (25%)",
                                "Síntese de propriedades como ordem e estabilidade (20%)",
                                "Uso de exemplos concretos e verificações matemáticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Interpretação em simulações de EDOs em mecânica",
                                "Computação: Implementação em código para solvers numéricos",
                                "Engenharia: Análise de estabilidade em controle de sistemas",
                                "Estatística: Aproximação em processos estocásticos discretos"
                              ],
                              "realWorldApplication": "Em modelagem climática, coeficientes LMS determinam se um método explícito como Adams-Bashforth é usado para previsões rápidas ou implícito como BDF para equações rígidas de difusão, garantindo estabilidade em simulações de longo prazo."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Aplicar a equação para k=1 (método 1-step)",
                            "description": "Derivar casos especiais como α_1 y_{n+1} + α_0 y_n = h (β_1 f_{n+1} + β_0 f_n), recuperando Euler forward (α_1=1, α_0=-1, β_1=0, β_0=1) e backward.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e Escrever a Equação Geral dos Métodos LMS",
                                  "subSteps": [
                                    "Revise a formulação geral dos métodos lineares multistep (LMS): ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Identifique os coeficientes α_j e β_j para j=0 a k.",
                                    "Escreva explicitamente para o caso geral, destacando o papel de k como ordem do método.",
                                    "Confirme que para métodos consistentes, α_0 + α_1 + ... + α_k = 0 e β_k ≠ 0.",
                                    "Anote exemplos de métodos conhecidos para contextualizar."
                                  ],
                                  "verification": "Verifique se a equação geral está corretamente escrita em um papel ou editor, sem erros nos índices ou somatórios.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro-texto de Análise Numérica, caderno de anotações, calculadora simbólica (opcional como Wolfram Alpha).",
                                  "tips": "Use notação LaTeX ou simbólica para clareza visual.",
                                  "learningObjective": "Compreender a estrutura fundamental da equação LMS antes da especialização.",
                                  "commonMistakes": "Confundir índices (n+j vs n-j), ignorar o fator h, ou inverter α e β."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especializar a Equação para k=1 (Método de 1-Passo)",
                                  "subSteps": [
                                    "Substitua k=1 na equação geral: α_1 y_{n+1} + α_0 y_n = h (β_1 f_{n+1} + β_0 f_n).",
                                    "Discuta as condições de consistência: α_1 + α_0 = 0 e β_1 ≠ 0 (para ordem pelo menos 1).",
                                    "Reescreva usando α_1 = 1 e α_0 = -1 para normalizar (padrão comum).",
                                    "Simplifique a forma: y_{n+1} - y_n = h (β_1 f_{n+1} + β_0 f_n).",
                                    "Identifique que isso representa métodos implícitos ou explícitos dependendo de β_1."
                                  ],
                                  "verification": "Confirme que a equação reduzida para k=1 está correta comparando com referências do livro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel com equação geral anotada, lápis para derivações.",
                                  "tips": "Sempre normalize α_1=1 para evitar frações desnecessárias.",
                                  "learningObjective": "Derivar a forma específica para métodos de 1-passo a partir da geral.",
                                  "commonMistakes": "Esquecer o sinal negativo em α_0, ou omitir h no lado direito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Recuperar o Método de Euler Forward",
                                  "subSteps": [
                                    "Defina os coeficientes para Euler forward: α_1=1, α_0=-1, β_1=0, β_0=1.",
                                    "Substitua na equação de k=1: y_{n+1} - y_n = h f_n.",
                                    "Simplifique para y_{n+1} = y_n + h f_n.",
                                    "Verifique consistência: ordem 1, método explícito (não depende de f_{n+1}).",
                                    "Compare com a definição padrão de Euler forward."
                                  ],
                                  "verification": "Escreva a equação final e confirme que matches a fórmula conhecida de Euler forward.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Caderno, exemplos numéricos simples para teste mental.",
                                  "tips": "Lembre que β_1=0 torna explícito, ideal para testes iniciais.",
                                  "learningObjective": "Identificar e derivar Euler forward como caso especial.",
                                  "commonMistakes": "Confundir β_1 e β_0, resultando em fórmula errada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recuperar o Método de Euler Backward e Verificar Consistência",
                                  "subSteps": [
                                    "Defina coeficientes para Euler backward: α_1=1, α_0=-1, β_1=1, β_0=0.",
                                    "Substitua: y_{n+1} - y_n = h f_{n+1}.",
                                    "Simplifique para y_{n+1} = y_n + h f_{n+1} (implícito).",
                                    "Discuta necessidade de resolver equação não-linear em cada passo.",
                                    "Compare precisão e estabilidade com Euler forward."
                                  ],
                                  "verification": "Derive ambas as formas e teste com um PVI simples como y'= -y, y(0)=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora para um passo numérico opcional, tabela de coeficientes.",
                                  "tips": "Para implícito, pense em iteração de ponto fixo para solução.",
                                  "learningObjective": "Derivar Euler backward e contrastar com forward.",
                                  "commonMistakes": "Trocar β_1 e β_0 entre forward e backward."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Comparar os Casos Especiais",
                                  "subSteps": [
                                    "Tabule os coeficientes para Euler forward e backward.",
                                    "Discuta vantagens/desvantagens: forward explícito mas instável; backward implícito e estável.",
                                    "Verifique ordem de truncamento (ambos ordem 1).",
                                    "Estenda para outros valores de β (ex: trapezoidal se β_1=β_0=1/2).",
                                    "Registre insights para métodos de ordem superior."
                                  ],
                                  "verification": "Crie uma tabela comparativa correta e sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou papel para tabela.",
                                  "tips": "Use cores para diferenciar explícito/implícito.",
                                  "learningObjective": "Consolidar compreensão através de comparação.",
                                  "commonMistakes": "Ignorar implicações numéricas (estabilidade)."
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -y, y(0)=1, h=0.1: Euler forward dá y1 = 1 + 0.1*(-1) = 0.9; Euler backward resolve y1 = 1 + 0.1*(-y1) → y1 = 1/1.1 ≈ 0.909.",
                              "finalVerifications": [
                                "Equação para k=1 derivada corretamente como α1 yn+1 + α0 yn = h(β1 fn+1 + β0 fn).",
                                "Euler forward recuperado com β1=0, β0=1.",
                                "Euler backward recuperado com β1=1, β0=0.",
                                "Condições de consistência verificadas (∑αj=0, β1≠0).",
                                "Exemplo numérico simples computado sem erros.",
                                "Diferenças explícito/implícito explicadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação k=1 (100% dos coeficientes corretos).",
                                "Correta identificação de Euler forward e backward via coeficientes.",
                                "Explicação clara de implicações numéricas (explícito vs implícito).",
                                "Uso correto de notação matemática em todas as steps.",
                                "Aplicação bem-sucedida em exemplo prático com cálculos exatos.",
                                "Comparação tabular completa e precisa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (biblioteca SciPy odeint compara com analítico).",
                                "Física: Modelagem de decaimento radioativo ou circuitos RC.",
                                "Engenharia: Simulações de dinâmica em controle de sistemas.",
                                "Estatística: Aproximações em processos estocásticos discretos."
                              ],
                              "realWorldApplication": "Esses métodos são base para solvers numéricos em software como MATLAB ode45 ou simulações em engenharia aeroespacial, finanças (modelos Black-Scholes discretos) e biologia (dinâmica populacional), onde se aproximam soluções de EDOs sem solução fechada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Polinômios Geradores dos LMS",
                        "description": "Os polinômios ρ(z) = ∑_{j=0}^k α_j z^j e σ(z) = ∑_{j=0}^k β_j z^j caracterizam o método, usados para analisar ordem, consistência e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Definir polinômios geradores ρ(z) e σ(z)",
                            "description": "Construir ρ(z) a partir dos α_j como polinômio de diferença finita e σ(z) dos β_j como para a integral, ilustrando com método trapezoidal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a formulação geral dos métodos lineares multistep (LMS)",
                                  "subSteps": [
                                    "Revise a equação geral de LMS: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Identifique os coeficientes α_j (para aproximação da derivada via diferenças finitas) e β_j (para aproximação da integral).",
                                    "Estude o operador de avanço z: z y_n = y_{n+1}.",
                                    "Analise como ρ(z) e σ(z) emergem da reescrita polinomial da equação LMS.",
                                    "Discuta a ordem do método e consistência (ρ(1)=0, ρ'(1)=σ(1))."
                                  ],
                                  "verification": "Escreva a equação LMS em forma polinomial e verifique as condições de consistência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre PVI.",
                                  "tips": "Use o operador shift z para transformar somas em polinômios.",
                                  "learningObjective": "Compreender como LMS são representados por polinômios geradores.",
                                  "commonMistakes": "Confundir α_j com β_j ou ignorar o fator h na equação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o polinômio gerador ρ(z) a partir dos α_j",
                                  "subSteps": [
                                    "Defina ρ(z) = ∑_{j=0}^k α_j z^j, o polinômio de diferença finita.",
                                    "Derive ρ(z) da parte esquerda da equação LMS: ∑ α_j y_{n+j} = ρ(E) y_n, onde E é o operador shift.",
                                    "Verifique que ρ(1) = 0 para consistência de ordem 1.",
                                    "Calcule a derivada ρ'(1) = ∑ j α_j para ordem superior.",
                                    "Pratique com k=1: método Euler implícito (α_1=1, α_0=-1 → ρ(z)=z-1)."
                                  ],
                                  "verification": "Construa ρ(z) para um LMS de ordem 1 e confirme ρ(1)=0 e ρ'(1)=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (ex: Mathematica ou SymPy).",
                                  "tips": "Sempre normalize α_k=1 para univocidade.",
                                  "learningObjective": "Dominar a construção de ρ(z) como aproximador de diferenças finitas.",
                                  "commonMistakes": "Esquecer o índice j em ρ'(z) ou não normalizar coeficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o polinômio gerador σ(z) a partir dos β_j",
                                  "subSteps": [
                                    "Defina σ(z) = ∑_{j=0}^k β_j z^j, relacionado à aproximação quadratura.",
                                    "Derive σ(z) da parte direita: h ∑ β_j f(t_{n+j}, y_{n+j}) ≈ ∫ f.",
                                    "Verifique σ(1) = ρ'(1) para consistência.",
                                    "Discuta estabilidade: raízes de ρ(z)=0 dentro do círculo unitário.",
                                    "Pratique com quadratura trapezoidal: β_1=β_0=1/2 → σ(z)=(z+1)/2."
                                  ],
                                  "verification": "Construa σ(z) para o mesmo LMS e confirme σ(1)=ρ'(1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de álgebra computacional, exemplos de LMS.",
                                  "tips": "Pense em σ(z) como pesos de quadratura em função de z.",
                                  "learningObjective": "Associar σ(z) à integração numérica em LMS.",
                                  "commonMistakes": "Confundir σ(z) com ρ(z) ou ignorar a condição de consistência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com o método trapezoidal e verificar propriedades",
                                  "subSteps": [
                                    "Escreva o método trapezoidal: y_{n+1} - y_n = (h/2)(f_{n+1} + f_n).",
                                    "Identifique α_1=1, α_0=-1, β_1=1/2, β_0=1/2.",
                                    "Construa ρ(z) = z - 1 e σ(z) = (z + 1)/2.",
                                    "Verifique ordem 2: ρ(1)=0, ρ'(1)=1=σ(1), ρ''(1)/2 = σ'(1)=1/2.",
                                    "Analise estabilidade: raiz de ρ(z)=1 (no círculo unitário)."
                                  ],
                                  "verification": "Derive ρ(z) e σ(z) para trapezoidal e confirme ordem e estabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos numéricos de trapezoidal, gráfico de região de estabilidade.",
                                  "tips": "Plote a região de estabilidade para visualização.",
                                  "learningObjective": "Aplicar conceitos a um LMS clássico e validar propriedades.",
                                  "commonMistakes": "Erro nos coeficientes β_j ou falha em verificar ordem 2."
                                }
                              ],
                              "practicalExample": "Para o método trapezoidal em y' = -y, h=0.1: ρ(z)=z-1 gera diferença finita y_{n+1}-y_n, σ(z)=(z+1)/2 aproxima ∫_{-h/2}^{h/2} f(s) ds / h.",
                              "finalVerifications": [
                                "Conseguiu derivar ρ(z) e σ(z) corretamente para k=1 e trapezoidal.",
                                "Verificou condições de consistência: ρ(1)=σ(1)=ρ'(1).",
                                "Identificou raízes de ρ(z) e discutiu estabilidade.",
                                "Aplicou a um PVI simples e obteve aproximação precisa.",
                                "Explicou ligação com diferenças finitas e quadratura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e derivação de ρ(z) e σ(z) (matemática correta).",
                                "Compreensão conceitual: ligação com diferenças e integrais.",
                                "Capacidade de verificação de propriedades (consistência, ordem).",
                                "Aplicação correta ao exemplo trapezoidal.",
                                "Análise qualitativa de estabilidade.",
                                "Clareza na explicação e ilustração."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores em simulações numéricas.",
                                "Computação: Implementação de solvers em Python (SciPy odeint).",
                                "Engenharia: Análise de estabilidade em controle de sistemas.",
                                "Estatística: Aproximações em processos estocásticos."
                              ],
                              "realWorldApplication": "Usado em solvers de EDOs para simulações em previsão meteorológica, dinâmica de fluidos e circuitos elétricos, onde métodos multistep como trapezoidal garantem precisão e eficiência computacional em problemas de valor inicial."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Verificar condições de consistência zero",
                            "description": "Demonstrar que para consistência, ρ(1) = 0 e ρ'(1) = σ(1), garantindo que o método integra exatamente constantes e lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar as definições dos polinômios geradores ρ(z) e σ(z)",
                                  "subSteps": [
                                    "Defina ρ(z) = ∑_{j=0}^k α_j z^j como o polinômio de recorrência.",
                                    "Defina σ(z) = ∑_{j=0}^k β_j z^j como o polinômio de interpolação.",
                                    "Escreva a fórmula geral do método multistep: ∑ α_j y_{n+j} = h ∑ β_j f_{n+j}.",
                                    "Identifique os coeficientes α_k = 1 e α_0 = -1 para métodos consistentes.",
                                    "Verifique que ρ(1) deve ser zero para consistência básica."
                                  ],
                                  "verification": "Confirme que as expressões de ρ(z) e σ(z) estão corretamente escritas e que α_k = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, quadro branco, referência ao livro de análise numérica (ex: Burden & Faires).",
                                  "tips": "Desenhe o diagrama de diferença finita para visualizar os coeficientes.",
                                  "learningObjective": "Compreender a estrutura algébrica dos polinômios geradores em métodos multistep.",
                                  "commonMistakes": "Confundir os índices de j ou esquecer que ρ(z) é para y e σ(z) para f."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a condição de consistência de ordem 1: ρ(1) = 0",
                                  "subSteps": [
                                    "Calcule ρ(1) = ∑_{j=0}^k α_j (1)^j = ∑ α_j.",
                                    "Mostre que ∑ α_j = 0 é equivalente a ρ(1) = 0.",
                                    "Demonstre que isso garante integração exata de constantes (y' = 0).",
                                    "Substitua y_n = c (constante) na equação do método e verifique que é satisfeita.",
                                    "Considere o operador de diferença forward Δ y_n = ∑ α_j y_{n+j} = 0 para constantes."
                                  ],
                                  "verification": "ρ(1) resulta exatamente em zero ao somar os coeficientes α_j.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou software simbólico como SymPy ou Mathematica.",
                                  "tips": "Agrupe termos para ver o telescópio das diferenças finitas.",
                                  "learningObjective": "Provar que ρ(1)=0 assegura consistência para soluções constantes.",
                                  "commonMistakes": "Esquecer o sinal negativo em α_0 ou somar incorretamente os coeficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição de consistência de ordem 2: ρ'(1) = σ(1)",
                                  "subSteps": [
                                    "Calcule a derivada ρ'(z) = ∑_{j=1}^k j α_j z^{j-1}, então ρ'(1) = ∑ j α_j.",
                                    "Calcule σ(1) = ∑_{j=0}^k β_j.",
                                    "Mostre que ρ'(1) = σ(1) garante integração exata para lineares (y(t) = at + b).",
                                    "Derive a condição usando expansão de Taylor para f(y) ≈ y'.",
                                    "Verifique com y_n = a(nh) + b na equação multistep."
                                  ],
                                  "verification": "Os valores de ρ'(1) e σ(1) são iguais numericamente e simbolicamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software para derivadas simbólicas (Mathematica, Maple), papel para Taylor.",
                                  "tips": "Use a regra da cadeia ou propriedades de geradores para simplificar derivadas.",
                                  "learningObjective": "Estabelecer a relação entre derivada de ρ e σ para consistência de ordem 2.",
                                  "commonMistakes": "Erro no cálculo da derivada (esquecer o fator j) ou confundir σ(1) com ρ(1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar as condições para integração exata de constantes e lineares",
                                  "subSteps": [
                                    "Resuma: ρ(1)=0 para y'=0 (constantes), ρ'(1)=σ(1) para y'=const (lineares).",
                                    "Aplique a um método exemplo como Backward Euler (k=1): verifique condições.",
                                    "Discuta implicações para truncamento local O(h^{p+1}).",
                                    "Teste com solução exata y(t)=t^2/2 (y'=t linear).",
                                    "Conclua que ordem de consistência é pelo menos 1 ou 2."
                                  ],
                                  "verification": "O método integra exatamente y=const e y=linear sem erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de métodos multistep de um textbook, Python/MATLAB para simulação numérica.",
                                  "tips": "Sempre normalize h=1 para verificação simplificada.",
                                  "learningObjective": "Conectar condições algébricas a propriedades de exatidão do método.",
                                  "commonMistakes": "Ignorar o fator h na equação ou assumir ordem alta sem verificação."
                                }
                              ],
                              "practicalExample": "Para o método de Trapezoidal Rule (k=1): ρ(z)=z-1, σ(z)=(z+1)/2. Verifique ρ(1)=0 e ρ'(1)=1=σ(1). Integre y'=0 → y=1 exato; y'=1 → y=t exato.",
                              "finalVerifications": [
                                "ρ(1) = 0 calculado corretamente.",
                                "ρ'(1) = σ(1) demonstrado simbolicamente.",
                                "Integração exata para y=constante confirmada.",
                                "Integração exata para y=linear confirmada.",
                                "Exemplo numérico com h pequeno mostra erro O(h^2).",
                                "Condições generalizadas para ordem p discutidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ρ(1) e σ(1) (100% correto).",
                                "Correta derivação de ρ'(z) e avaliação em z=1.",
                                "Explicação clara da exatidão para constantes/lineares.",
                                "Uso apropriado de expansões de Taylor.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação a pelo menos um método exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Integração numérica em simulações dinâmicas (ex: movimento Newtoniano).",
                                "Programação: Implementação em solvers ODE como SciPy (odeint).",
                                "Engenharia: Análise de estabilidade em controle de sistemas.",
                                "Estatística: Modelos temporais em séries cronológicas."
                              ],
                              "realWorldApplication": "Essas condições garantem precisão em solvers de EDOs para modelagem climática, simulações farmacocinéticas e previsão financeira, onde erros em baixas ordens propagam em simulações longas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Métodos Explícitos de Adams-Bashforth",
                    "description": "Métodos explícitos de passo múltiplo baseados em interpolação de polinômios para avanço da solução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Princípios de Interpolação Polinomial nos Métodos Adams-Bashforth",
                        "description": "Fundamentos da derivação dos métodos explícitos de Adams-Bashforth utilizando interpolação polinomial de Newton para aproximar a integral do problema de valor inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Entender a interpolação de Newton backward para f(t,y)",
                            "description": "Compreender como construir o polinômio interpolador de Newton de grau k utilizando valores anteriores f(t_n, y_n) até f(t_{n-k}, y_{n-k}) para aproximar a solução do PVI y' = f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Interpolação Polinomial de Newton",
                                  "subSteps": [
                                    "Estude a definição de interpolação polinomial: encontrar um polinômio P(t) que passa pelos pontos dados (t_i, f(t_i, y_i)).",
                                    "Compare a forma forward e backward: forward usa diferenças progressivas (Δ), backward usa diferenças regressivas (∇).",
                                    "Entenda o parâmetro u = (t_n - t)/h para a forma backward, onde u=0 no ponto atual t_n.",
                                    "Revise a fórmula base do polinômio backward: P(t) = ∑_{j=0}^k ∇^j f_n * binom(u, j), onde binom(u,j) = u(u+1)...(u+j-1)/j!."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre interpolação forward e backward, citando a fórmula de binom(u,j).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Livro de Análise Numérica (capítulo de interpolação)"
                                  ],
                                  "tips": "Desenhe uma tabela de valores para visualizar os pontos t_{n-k} a t_n.",
                                  "learningObjective": "Compreender a base teórica da interpolação de Newton backward.",
                                  "commonMistakes": [
                                    "Confundir o parâmetro u com s da forward (u aumenta para trás no tempo)",
                                    "Esquecer que ∇ é diferença backward: ∇f_n = f_n - f_{n-1}."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Diferenças Divididas Backward (∇)",
                                  "subSteps": [
                                    "Monte uma tabela de diferenças finitas backward para k+1 pontos: f_n, f_{n-1}, ..., f_{n-k}.",
                                    "Calcule as primeiras diferenças: ∇f_n = f_n - f_{n-1}, ∇f_{n-1} = f_{n-1} - f_{n-2}, etc.",
                                    "Prossiga para segundas diferenças: ∇²f_n = ∇f_n - ∇f_{n-1}, e assim por diante até ∇^k f_n.",
                                    "Pratique com 3-4 pontos para k=2 ou 3.",
                                    "Verifique a tabela diagonal principal que leva a ∇^j f_n."
                                  ],
                                  "verification": "Construa a tabela de diferenças para dados de exemplo e isole ∇²f_n corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Exemplos de f(t,y) de PVIs simples"
                                  ],
                                  "tips": "Use h=1 para simplificar inicialmente; alinhe a tabela com t_n no topo direito.",
                                  "learningObjective": "Dominar o cálculo de diferenças backward para uso no polinômio.",
                                  "commonMistakes": [
                                    "Erro de sinal nas diferenças (sempre subtrai o anterior)",
                                    "Confundir ordem das diferenças com forward."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Polinômio Interpolador Backward de Grau k",
                                  "subSteps": [
                                    "Escreva o polinômio completo: P(u) = f_n + ∇f_n * binom(u,1) + ∇²f_n * binom(u,2) + ... + ∇^k f_n * binom(u,k).",
                                    "Expanda os coeficientes binomiais: binom(u,1)=u, binom(u,2)=u(u+1)/2, etc.",
                                    "Substitua u = (t_n - t)/h e expresse P(t) em termos de t.",
                                    "Teste interpolando em t_n (deve dar f_n) e t_{n-1} (deve dar f_{n-1}).",
                                    "Simplifique para grau baixo (k=1,2) e generalize."
                                  ],
                                  "verification": "Escreva P(u) para k=2 e verifique que P(0)=f_n e P(1)=f_{n-1}.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Papel para expansões algébricas"
                                  ],
                                  "tips": "Comece com k=0 (constante) e incremente para construir intuição.",
                                  "learningObjective": "Construir explicitamente o polinômio interpolador backward.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes binomiais (lembre: rising factorial para backward)",
                                    "Não normalizar por h nas diferenças se h≠1."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar no Contexto de Métodos Adams-Bashforth Explícitos",
                                  "subSteps": [
                                    "Lembre que Adams-Bashforth usa ∫_{t_n}^{t_{n+1}} P(t) dt ≈ h * ∑ b_j ∇^j f_n, onde b_j são coeficientes integrados.",
                                    "Entenda como o polinômio backward aproxima f(t,y) para integração no passo y_{n+1} = y_n + ∫ f(t,y(t)) dt.",
                                    "Derive para k=1: mostre que leva ao método trapezoidal backward.",
                                    "Compare estabilidade: backward é usado por conveniência em diferenças regressivas.",
                                    "Discuta truncamento: erro O(h^{k+2}) similar a forward."
                                  ],
                                  "verification": "Explique verbalmente como o polinômio leva à fórmula Adams-Bashforth de ordem k.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Notas de aula sobre Adams-Bashforth",
                                    "Exemplo numérico de PVI"
                                  ],
                                  "tips": "Integre P(u) de 0 a 1 para ver os coeficientes b_j diretamente.",
                                  "learningObjective": "Conectar a interpolação ao método numérico para PVIs.",
                                  "commonMistakes": [
                                    "Confundir com predictor-corrector (aqui só explícito)",
                                    "Ignorar que f(t,y) é avaliada em pontos passados."
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1, pontos: n=2, f_{2}=e^{-0.2}≈0.8187, f_1≈0.9048, f_0≈1. k=1. Tabela ∇: ∇f_2=0.8187-0.9048=-0.0861. P(u)=0.8187 -0.0861 u. Integre para AB1: y_3 = y_2 + h*(3/2 f_2 -1/2 f_1).",
                              "finalVerifications": [
                                "Construa tabela de diferenças backward para 4 pontos e isole ∇^3 f_n.",
                                "Escreva P(u) para k=2 e verifique valores nos 3 pontos.",
                                "Derive a fórmula Adams-Bashforth de ordem 2 a partir da integração de P(u).",
                                "Explique por que backward é preferido em multistep methods.",
                                "Identifique o erro de truncamento da interpolação.",
                                "Resolva um PVI simples com AB2 usando o polinômio."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de diferenças backward (sem erros de sinal).",
                                "Correta expansão e verificação do polinômio nos nós.",
                                "Compreensão conceitual: ligação com integração para AB methods.",
                                "Capacidade de generalizar para grau k arbitrário.",
                                "Identificação de erros comuns e limitações (ex: Runge phenomenon).",
                                "Clareza na explicação oral ou escrita do processo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar tabela de diferenças em Python/NumPy.",
                                "Física: Aproximações em simulações de osciladores ou difusão.",
                                "Estatística: Diferenças finitas em séries temporais e previsão.",
                                "Engenharia: Modelagem numérica de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Usado em solvers numéricos como MATLAB ode45 ou previsões meteorológicas/ financeiras, onde se aproximam soluções de EDOs com dados históricos para passos futuros sem reavaliação cara de f(t,y)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Derivar a fórmula integral aproximada",
                            "description": "Derivar a aproximação da integral ∫_{t_n}^{t_{n+1}} f(τ, y(τ)) dτ usando o polinômio interpolador, resultando na forma explícita y_{n+1} = y_n + h ∑ β_j f_{n-j}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a forma integral do problema de valor inicial (PVI)",
                                  "subSteps": [
                                    "Relembre o PVI: y' = f(t, y), y(t_0) = y_0.",
                                    "Expresse y(t_{n+1}) em termos integrais: y_{n+1} = y_n + ∫_{t_n}^{t_{n+1}} f(τ, y(τ)) dτ.",
                                    "Identifique o desafio: aproximar o integrando f(τ, y(τ)) numericamente.",
                                    "Defina h = t_{n+1} - t_n como o passo de integração.",
                                    "Anote a integral exata que será aproximada."
                                  ],
                                  "verification": "Escreva corretamente a expressão integral de y_{n+1} e explique seu significado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de análise numérica (opcional)"
                                  ],
                                  "tips": "Visualize graficamente o integral como área sob a curva f(t,y).",
                                  "learningObjective": "Compreender a base integral dos métodos multistep.",
                                  "commonMistakes": [
                                    "Confundir y_{n+1} com y_n + h f_n (método de Euler)",
                                    "Esquecer limites de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o polinômio interpolador de f nos pontos anteriores",
                                  "subSteps": [
                                    "Escolha k+1 pontos: f_n, f_{n-1}, ..., f_{n-k} em t_n, t_{n-1}, ..., t_{n-k}.",
                                    "Defina o polinômio P(τ) de grau ≤ k que interpola esses pontos: P(t_{n-j}) = f_{n-j} para j=0 a k.",
                                    "Use a forma de Lagrange ou Newton para expressar P(τ).",
                                    "Escreva P(τ) = ∑_{j=0}^k f_{n-j} l_j(τ), onde l_j são as funções de Lagrange.",
                                    "Verifique interpolação em pelo menos dois pontos."
                                  ],
                                  "verification": "Substitua τ = t_{n-j} e confirme P(t_{n-j}) = f_{n-j} para todos j.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para coeficientes"
                                  ],
                                  "tips": "Comece com k=1 para praticar antes de generalizar.",
                                  "learningObjective": "Dominar interpolação polinomial em pontos equidistantes.",
                                  "commonMistakes": [
                                    "Usar pontos incluindo t_{n+1} (isso seria implícito)",
                                    "Confundir índices de f_{n-j}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o polinômio interpolador sobre o intervalo [t_n, t_{n+1}]",
                                  "subSteps": [
                                    "Escreva a aproximação: ∫_{t_n}^{t_{n+1}} f(τ,y(τ)) dτ ≈ ∫_{t_n}^{t_{n+1}} P(τ) dτ.",
                                    "Compute I = ∫_{t_n}^{t_{n+1}} P(τ) dτ = ∑_{j=0}^k f_{n-j} ∫_{t_n}^{t_{n+1}} l_j(τ) dτ.",
                                    "Defina γ_j = ∫_{t_n}^{t_{n+1}} l_j(τ) dτ para cada j.",
                                    "Integre as funções de Lagrange explicitamente ou use mudança de variável.",
                                    "Simplifique os integrais resultantes."
                                  ],
                                  "verification": "Calcule numericamente γ_j para k=1 e confirme valores esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy (opcional)",
                                    "Tabela de integrais"
                                  ],
                                  "tips": "Faça mudança de variável s = (τ - t_n)/h para normalizar [0,1].",
                                  "learningObjective": "Aplicar integração exata a polinômios interpoladores.",
                                  "commonMistakes": [
                                    "Integrar de t_0 a t_n em vez do intervalo correto",
                                    "Erros em limites de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar e expressar na forma explícita com coeficientes β_j",
                                  "subSteps": [
                                    "Introduza a normalização: defina s = (τ - t_n)/h, dτ = h ds, intervalo [0,1].",
                                    "Reescreva γ_j = h ∫_0^1 l_j(h s + t_n) ds.",
                                    "Defina β_j = ∫_0^1 l_j(h s + t_n) ds, assim I ≈ h ∑_{j=0}^k β_j f_{n-j}.",
                                    "Derive explicitamente β_j para ordem baixa (ex: ordem 2: β_0=3/2, β_1=-1/2).",
                                    "Escreva a fórmula final: y_{n+1} = y_n + h ∑_{j=0}^k β_j f_{n-j}."
                                  ],
                                  "verification": "Para k=1, confirme β_0=3/2, β_1=-1/2 e teste em exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Referência de fórmulas Adams-Bashforth"
                                  ],
                                  "tips": "Memorize que β_j são coeficientes fixos independentes de f.",
                                  "learningObjective": "Obter a forma canônica dos métodos explícitos de Adams-Bashforth.",
                                  "commonMistakes": [
                                    "Inverter sinal dos β_j negativos",
                                    "Esquecer o fator h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar consistência e ordem de precisão",
                                  "subSteps": [
                                    "Expanda P(τ) em série de Taylor e compare com integral exata.",
                                    "Mostre que o erro local é O(h^{k+2}).",
                                    "Compare com método de Euler (k=0: β_0=1).",
                                    "Discuta estabilidade e uso com corrector.",
                                    "Escreva resumo da derivação completa."
                                  ],
                                  "verification": "Derive β_j para k=0 e confirme y_{n+1}=y_n + h f_n.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico de erro O(h^{k+2})"
                                  ],
                                  "tips": "Use expansão de Taylor de f em torno de t_n para análise de erro.",
                                  "learningObjective": "Compreender a precisão e limitações do método.",
                                  "commonMistakes": [
                                    "Confundir ordem de precisão com grau do polinômio"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Adams-Bashforth de ordem 2 (k=1), derive usando pontos f_n e f_{n-1}. O polinômio P(τ) = f_n [(τ - t_{n-1})/(t_n - t_{n-1})] + f_{n-1} [(τ - t_n)/(t_{n-1} - t_n)]. Após integração e normalização com h, obtém-se y_{n+1} = y_n + h (3/2 f_n - 1/2 f_{n-1}). Teste com y' = -y, y(0)=1, h=0.1.",
                              "finalVerifications": [
                                "Escreve corretamente y_{n+1} = y_n + h ∑ β_j f_{n-j}.",
                                "Constrói P(τ) interpolando exatamente k+1 pontos.",
                                "Calcula β_j corretamente para k=1 ou 2.",
                                "Explica a normalização com variável s ∈ [0,1].",
                                "Identifica erro de truncamento O(h^{k+2}).",
                                "Aplica em exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na construção do interpolador (20%)",
                                "Precisão na integração e normalização (25%)",
                                "Derivação explícita dos coeficientes β_j (20%)",
                                "Clareza e organização da derivação passo a passo (15%)",
                                "Análise de erro e consistência (10%)",
                                "Aplicação em exemplo prático (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com NumPy/SciPy para solvers de EDOs.",
                                "Física: Simular trajetórias em mecânica orbital.",
                                "Engenharia: Modelagem de circuitos RLC diferenciais.",
                                "Biologia: Dinâmica de populações com EDOs Lotka-Volterra."
                              ],
                              "realWorldApplication": "Esses métodos são usados em software como MATLAB ode45 ou simuladores em previsão meteorológica, dinâmica de fluidos computacional (CFD) e modelagem financeira de opções, onde eficiência em passos grandes é crucial para EDOs rígidos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Identificar coeficientes de Adams-Bashforth",
                            "description": "Calcular os coeficientes β_j para diferentes ordens k, relacionando-os com diferenças divididas finitas backward.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Diferenças Divididas Finitas Backward",
                                  "subSteps": [
                                    "Defina as diferenças backward de primeira ordem: ∇f_n = f_n - f_{n-1}.",
                                    "Estenda para ordens superiores: ∇^m f_n = ∇^{m-1} f_n - ∇^{m-1} f_{n-1}.",
                                    "Calcule exemplos numéricos para m=1,2,3 usando uma tabela de valores de f em pontos equidistantes.",
                                    "Relacione com o operador forward Δ via ∇ = Δ com passo negativo.",
                                    "Verifique propriedades como ∇(af + bg) = a∇f + b∇g."
                                  ],
                                  "verification": "Construa uma tabela de diferenças backward para 5 pontos e confirme que ∇^2 f_n está correto comparando com definição recursiva.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Tabela de valores de função exemplo (e.g., f(x)=sin(x))",
                                    "Referência: Capítulo de diferenças finitas em livro de Análise Numérica"
                                  ],
                                  "tips": [
                                    "Use tabelas triangulares para visualizar diferenças backward",
                                    "Comece com funções polinomiais para testar exatidão"
                                  ],
                                  "learningObjective": "Dominar o cálculo e interpretação de diferenças divididas finitas backward como base para interpolação.",
                                  "commonMistakes": [
                                    "Confundir backward com forward (∇ vs Δ)",
                                    "Erros de sinal na recursão",
                                    "Não normalizar por h^m"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Forma de Newton Backward para Interpolação Polinomial",
                                  "subSteps": [
                                    "Lembre a forma de Newton backward: P_n(s) = ∑_{m=0}^k binomial(s,m) ∇^m f_n, onde s = (x_n - x)/h.",
                                    "Construa o polinômio interpolante para k=2 usando diferenças backward calculadas anteriormente.",
                                    "Expanda P_n(s) explicitamente para k=1,2 e verifique interpolação nos pontos x_n, x_{n-1}, x_{n-2}.",
                                    "Compare com forma de Lagrange para validar equivalência.",
                                    "Pratique com uma função não polinomial para observar erro de interpolação."
                                  ],
                                  "verification": "Para k=2, confirme que P_n(0)=f_n, P_n(1)=f_{n-1}, P_n(2)=f_{n-2} com erro <10^{-6}.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Software como Python/MATLAB para plotar P_n(s)",
                                    "Papel para expansões algébricas",
                                    "Exemplos de Burden & Faires 'Análise Numérica'"
                                  ],
                                  "tips": [
                                    "binomial(s,m) = s(s+1)...(s+m-1)/m!",
                                    "Plotar P_n vs f para visualizar precisão"
                                  ],
                                  "learningObjective": "Construir e validar polinômios interpolantes na forma Newton backward.",
                                  "commonMistakes": [
                                    "Índice errado em binomial(s,m)",
                                    "Confundir s = (x - x_n)/h vs backward",
                                    "Esquecer fator 1/m! em algumas formulações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Aproximação Integral para Métodos Adams-Bashforth",
                                  "subSteps": [
                                    "Estabeleça y_{n+1} - y_n ≈ h ∫_0^1 P_n(-u) du, onde u de 0 a 1 mapeia x_n a x_{n+1}.",
                                    "Substitua P_n(s) com s = -u: P_n(-u) = ∑_{m=0}^k binomial(-u,m) ∇^m f_n.",
                                    "Integre termo a termo: β_m = ∫_0^1 binomial(-u,m) du.",
                                    "Simplifique binomial(-u,m) = (-1)^m binomial(u+m-1,m).",
                                    "Mostre que β_j são coeficientes fixos independentes de f."
                                  ],
                                  "verification": "Derive β_0 =1 para k=1 e confirme ∫_0^1 1 du =1.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou papel)",
                                    "Tabela de integrais de binomial",
                                    "Notas de aula sobre multistep methods"
                                  ],
                                  "tips": [
                                    "Use expansão binomial negativa: (1+u)^{m-1} para simplificar",
                                    "Verifique simetria com métodos implicitos"
                                  ],
                                  "learningObjective": "Entender a origem dos coeficientes β_j via integração da forma Newton backward.",
                                  "commonMistakes": [
                                    "Sinal errado em s=-u",
                                    "Confundir ordem k com índice j",
                                    "Não alternar sinal (-1)^m"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Memorizar Coeficientes β_j para Ordens Comuns",
                                  "subSteps": [
                                    "Calcule explicitamente para k=1: β_0=1.",
                                    "Para k=2: β_0=3/2, β_1=-1/2.",
                                    "Para k=3: β_0=23/12, β_1=-16/12, β_2=5/12.",
                                    "Use tabela padrão ou software para k=4 e compare.",
                                    "Relacione com precisão local O(h^{k+1}) via análise de erro de interpolação."
                                  ],
                                  "verification": "Aplique coeficientes em um método AB de ordem 2 e confirme consistência com Runge-Kutta de ordem 2.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Tabela de coeficientes AB padrão",
                                    "Python para computar integrais numéricas",
                                    "Problema teste y'=y, y(0)=1"
                                  ],
                                  "tips": [
                                    "Memorize frações reduzidas",
                                    "Use quadratura Gauss para verificação numérica"
                                  ],
                                  "learningObjective": "Computar e aplicar coeficientes β_j para diferentes k em contextos práticos.",
                                  "commonMistakes": [
                                    "Frações não reduzidas (e.g., 16/12 vs -4/3)",
                                    "Índices j de trás pra frente",
                                    "Confundir com coeficientes de Milne"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y, y(0)=1 com h=0.1 usando AB ordem 2: Calcule f_0=y(0)=1, f_1≈0.9048 (via Euler), então y_2 = y_1 + h*(1.5 f_1 - 0.5 f_0) ≈ 0.8187, compare com solução exata e^{-0.2}≈0.8187.",
                              "finalVerifications": [
                                "Deriva corretamente β_j para k=1,2,3 sem consultar tabela.",
                                "Constrói tabela de diferenças backward para 5 pontos com precisão.",
                                "Integra P_n(-u) para k=2 obtendo β_0=3/2, β_1=-1/2.",
                                "Aplica AB em problema teste e erro < h^3.",
                                "Explica relação com diferenças finitas em 2 minutos.",
                                "Identifica coeficientes padrão para k=4: 55/24, -59/24, 37/24, -9/24."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da integral (90% correto).",
                                "Correção dos coeficientes calculados (exato para k<=3).",
                                "Profundidade nos substeps (todos completos com exemplos).",
                                "Conexão clara com diferenças backward.",
                                "Aplicação prática sem erros numéricos.",
                                "Explicação verbal fluida dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar AB em Python/Octave para solvers de EDOs.",
                                "Física: Simulações dinâmicas em mecânica orbital.",
                                "Engenharia: Modelagem de circuitos RLC com métodos numéricos.",
                                "Estatística: Aproximações em processos estocásticos.",
                                "Computação Científica: Otimização em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "Os coeficientes Adams-Bashforth são usados em software de simulação como MATLAB ODE45/ODE23 para prever trajetórias em meteorologia, dinâmica de fluidos e finanças quantitativas, permitindo passos eficientes em problemas de valor inicial stiff."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.1.2",
                        "name": "Fórmulas Explícitas de Adams-Bashforth para Ordens Específicas",
                        "description": "Apresentação e memorização das fórmulas padrão explícitas de Adams-Bashforth de 2ª a 5ª ordem, com exemplos de aplicação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.2.1",
                            "name": "Aplicar método de 2ª ordem (AB2)",
                            "description": "Implementar y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}) para avançar a solução numérica de um PVI, verificando com exemplo simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula do método AB2 e seus pré-requisitos",
                                  "subSteps": [
                                    "Revise o conceito de Problema de Valor Inicial (PVI): y' = f(t,y), y(t0)=y0.",
                                    "Lembre que AB2 é um método de passo múltiplo explícito que usa f_n e f_{n-1} para aproximar y_{n+1}.",
                                    "Memorize a fórmula: y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}), onde f_n = f(t_n, y_n).",
                                    "Entenda que precisa de y0 e y1 iniciais (use Euler ou RK para y1).",
                                    "Discuta a ordem de precisão (O(h^2)) e estabilidade."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a derivação polinomial da fórmula e identifique os dois valores f necessários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Derive a fórmula interpolando f por um polinômio de grau 1 nos pontos n-1 e n.",
                                  "learningObjective": "Compreender a base teórica e os requisitos iniciais do método AB2.",
                                  "commonMistakes": [
                                    "Confundir com método de 1ª ordem (Backward Euler)",
                                    "Esquecer de calcular y1 separadamente",
                                    "Ignorar o passo h na fórmula"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o PVI e calcular condições iniciais",
                                  "subSteps": [
                                    "Escolha um PVI simples, ex: y' = -y, y(0)=1 (solução exata e^{-t}).",
                                    "Defina h (ex: h=0.1) e intervalo [0,1].",
                                    "Calcule y1 usando método de Euler: y1 = y0 + h f(t0,y0).",
                                    "Compute f0 = f(0,y0) e f1 = f(h,y1).",
                                    "Organize uma tabela com t_n, y_n, f_n."
                                  ],
                                  "verification": "Tabela inicial completa com y0, y1, f0, f1 corretos e sem erros aritméticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use h pequeno para melhor precisão inicial; verifique f(t,y) manualmente.",
                                  "learningObjective": "Preparar dados iniciais precisos para aplicação iterativa do AB2.",
                                  "commonMistakes": [
                                    "Erro no cálculo de Euler para y1",
                                    "Usar h inconsistente",
                                    "Confundir f_n com y_n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar iterativamente a fórmula AB2",
                                  "subSteps": [
                                    "Para n=1: calcule y2 = y1 + (h/2)(3f1 - f0).",
                                    "Compute f2 = f(t2, y2) onde t2 = t1 + h.",
                                    "Repita para y3 = y2 + (h/2)(3f2 - f1), f3, e assim por diante até t=1.",
                                    "Preencha a tabela com pelo menos 5-10 passos.",
                                    "Registre valores aproximados vs. exatos (e^{-t_n})."
                                  ],
                                  "verification": "Tabela completa com y2 a y10 corretos, comparados à solução exata com erro <0.01.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha para automação opcional"
                                  ],
                                  "tips": "Mantenha f_n atualizado após cada y_{n+1}; use fórmula em uma linha para rapidez.",
                                  "learningObjective": "Executar o algoritmo AB2 de forma precisa e iterativa.",
                                  "commonMistakes": [
                                    "Índice errado em f (usar f_{n+2} ao invés de f_n)",
                                    "Fator (h/2) esquecido ou trocado",
                                    "Acúmulo de erros aritméticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar precisão, analisar erros e visualizar",
                                  "subSteps": [
                                    "Calcule erro local: |y_{n+1}^{AB2} - y_{n+1}^{exata}| para cada passo.",
                                    "Plote y_n vs. t_n e compare com curva exata.",
                                    "Analise se erro cresce linearmente (consistente com O(h^2)).",
                                    "Teste com h diferente (ex: h/2) para verificar convergência.",
                                    "Discuta limitações: instabilidade para h grande."
                                  ],
                                  "verification": "Gráfico ou tabela de erros mostrando precisão global <0.05 e discussão escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem como Desmos, Excel ou Python (Matplotlib)",
                                    "Solução exata conhecida"
                                  ],
                                  "tips": "Use log-log plot para ordem de convergência; foque em 3-4 pontos chave.",
                                  "learningObjective": "Avaliar a performance do método e validar implementação.",
                                  "commonMistakes": [
                                    "Comparar com solução errada",
                                    "Ignorar propagação de erro inicial",
                                    "h inconsistente na verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1 (exata: y=e^{-2t}), h=0.1. y0=1, f0=-2. y1=Euler=1 + 0.1*(-2)=0.8, f1=-1.6. y2=0.8 + (0.1/2)(3*(-1.6)-(-2))=0.8 + 0.05*(-4.8+2)=0.8-0.14=0.66 (exata≈0.6703). Continue até t=1, erro global≈0.02.",
                              "finalVerifications": [
                                "Implementa corretamente y2, y3 para PVI dado.",
                                "Tabela de valores com f_n atualizados e erros calculados.",
                                "Explica por que AB2 usa 3f_n - f_{n-1}.",
                                "Identifica necessidade de método single-step inicial.",
                                "Compara precisão com Euler forward.",
                                "Discute estabilidade para este exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética: erros <10^{-3} por passo.",
                                "Completude da tabela: todos f_n, y_n corretos.",
                                "Análise de erro: cálculo e interpretação adequada.",
                                "Visualização: gráfico comparativo claro.",
                                "Explicação teórica: derivada ou justificada.",
                                "Eficiência: tempo dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python loop para AB2 (loops, funções).",
                                "Física: Simular decaimento radioativo ou movimento harmônico.",
                                "Computação Científica: Integração em ODE solvers como SciPy.",
                                "Estatística: Modelagem de séries temporais discretas."
                              ],
                              "realWorldApplication": "Usado em simuladores meteorológicos para prever trajetórias de partículas (ex: previsão de furacões via integração numérica de equações diferenciais), modelagem populacional em ecologia e simulações financeiras de processos estocásticos discretizados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2.2",
                            "name": "Aplicar métodos de 3ª e 4ª ordem (AB3 e AB4)",
                            "description": "Usar fórmulas y_{n+1} = y_n + (h/12)(23f_n - 16f_{n-1} + 5f_{n-2}) para AB3 e y_{n+1} = y_n + (h/24)(55f_n - 59f_{n-1} + 37f_{n-2} - 9f_{n-3}) para AB4 em problemas de teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as fórmulas dos métodos AB3 e AB4",
                                  "subSteps": [
                                    "Estude a fórmula do AB3: y_{n+1} = y_n + (h/12)(23f_n - 16f_{n-1} + 5f_{n-2}).",
                                    "Analise a fórmula do AB4: y_{n+1} = y_n + (h/24)(55f_n - 59f_{n-1} + 37f_{n-2} - 9f_{n-3}).",
                                    "Identifique os coeficientes e o que cada f_{n-k} representa (avaliações da função f na malha).",
                                    "Derive intuitivamente os pesos dos métodos multistep lineares explícitos.",
                                    "Compare com métodos de ordem inferior para entender o ganho de precisão."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de cada termo nas fórmulas e resuma as diferenças entre AB3 e AB4.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula",
                                    "Calculadora"
                                  ],
                                  "tips": "Memorize os coeficientes principais: AB3 (23/12, -16/12, 5/12); AB4 (55/24, -59/24, 37/24, -9/24).",
                                  "learningObjective": "Entender a estrutura matemática e os coeficientes dos métodos Adams-Bashforth de 3ª e 4ª ordem.",
                                  "commonMistakes": [
                                    "Confundir os sinais dos coeficientes negativos.",
                                    "Esquecer que h é o passo de integração.",
                                    "Ignorar a dependência de valores prévios (f_{n-1}, etc.)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar valores iniciais para os métodos multistep",
                                  "subSteps": [
                                    "Selecione um problema de teste: y' = f(t,y), y(0) dado, com solução conhecida.",
                                    "Use método de Runge-Kutta de 4ª ordem (RK4) para computar y_1, y_2 (para AB3) e y_1 a y_3 (para AB4).",
                                    "Calcule f_n = f(t_n, y_n) para os pontos iniciais.",
                                    "Organize os valores em uma tabela: n, t_n, y_n, f_n.",
                                    "Verifique os cálculos iniciais comparando com solução exata aproximada."
                                  ],
                                  "verification": "Tabela completa de valores iniciais com pelo menos 3-4 pontos precisos e erro < 10^{-4}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Implementação de RK4 (código ou calculadora)",
                                    "Problema de teste impresso"
                                  ],
                                  "tips": "Escolha h pequeno (ex: 0.1) para boa precisão inicial; teste com y' = -y, y(0)=1.",
                                  "learningObjective": "Gerar condições iniciais precisas necessárias para iniciar métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Usar h inconsistente entre RK4 e Adams.",
                                    "Erro de arredondamento propagado cedo.",
                                    "Não computar f_n corretamente nos pontos iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o método AB3 passo a passo",
                                  "subSteps": [
                                    "Inicie com y_0, y_1, y_2 e f_0, f_1, f_2.",
                                    "Calcule y_3 = y_2 + (h/12)(23f_2 - 16f_1 + 5f_0).",
                                    "Compute f_3 = f(t_3, y_3) e avance para y_4, y_5 etc.",
                                    "Registre todos os passos em tabela e calcule erro local/global vs. solução exata.",
                                    "Repita para 5-10 passos e plote a solução aproximada."
                                  ],
                                  "verification": "Tabela com y_n corretos para n=3 a 7, erros decrescentes com ordem 3.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Gráficos em papel ou software como Desmos",
                                    "Tabela pré-formatada"
                                  ],
                                  "tips": "Automatize cálculos repetitivos com fórmula expandida para evitar erros manuais.",
                                  "learningObjective": "Implementar corretamente o método AB3 em um PVI e avaliar sua precisão.",
                                  "commonMistakes": [
                                    "Índices errados nos f_{n-k} (ex: usar f_3 antes de calculado).",
                                    "Esquecer de atualizar t_n = t_{n-1} + h.",
                                    "Não truncar erros de arredondamento adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o método AB4 e comparar com AB3",
                                  "subSteps": [
                                    "Use os mesmos iniciais até y_3 e f_3 do passo anterior.",
                                    "Calcule y_4 = y_3 + (h/24)(55f_3 - 59f_2 + 37f_1 - 9f_0).",
                                    "Avance sucessivos passos e registre em nova tabela.",
                                    "Compare soluções AB3 vs AB4 vs exata: calcule erros e convergência.",
                                    "Analise estabilidade e eficiência (AB4 requer mais f iniciais mas maior precisão)."
                                  ],
                                  "verification": "Tabelas comparativas mostrando erro de AB4 menor que AB3 para passos iguais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Mesmos do passo 3",
                                    "Software de plotagem (opcional: Python/MATLAB)"
                                  ],
                                  "tips": "Observe que AB4 é mais preciso para h maior; teste sensibilidade a h.",
                                  "learningObjective": "Implementar AB4, comparar com AB3 e interpretar diferenças de precisão/ordem.",
                                  "commonMistakes": [
                                    "Confundir ordem dos coeficientes no AB4 (55, -59, 37, -9).",
                                    "Não alinhar malhas para comparação justa.",
                                    "Ignorar instabilidade em problemas rígidos."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 (solução exata y = e^{-2t}), h=0.1. Use RK4 para y1,y2,y3. Aplique AB3 para y4 a y10 e AB4 para y5 a y11. Compare erros: AB3 erro ~O(h^3), AB4 ~O(h^4). Tabela exemplo: n=3, t=0.3, y_AB3≈0.04979 (exato 0.049787).",
                              "finalVerifications": [
                                "Fórmulas AB3/AB4 aplicadas corretamente em pelo menos 5 passos cada.",
                                "Valores iniciais via RK4 com precisão <10^{-5}.",
                                "Erros globais calculados e consistentes com ordens teóricas.",
                                "Tabelas completas com t_n, y_n, f_n e erros.",
                                "Gráfico qualitativo mostrando convergência.",
                                "Explicação escrita das diferenças AB3 vs AB4."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos manuais (erro <10^{-4}).",
                                "Correta identificação e uso de coeficientes.",
                                "Análise de erros e ordem de convergência.",
                                "Clareza nas tabelas e verificações.",
                                "Compreensão conceitual demonstrada em comparação.",
                                "Eficiência na preparação de iniciais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/Octave para automação.",
                                "Física: Simulação de decaimento radioativo ou circuitos RC.",
                                "Engenharia: Modelagem de trajetórias em dinâmica.",
                                "Estatística: Integração numérica em MCMC.",
                                "Computação Científica: Bibliotecas como SciPy odeint."
                              ],
                              "realWorldApplication": "Usado em simulações meteorológicas (previsão de tempo), engenharia aeroespacial (órbitas) e biologia (modelos populacionais), onde alta precisão com custo computacional moderado é essencial para EDOs não-lineares em grandes intervalos de tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2.3",
                            "name": "Comparar precisão entre ordens",
                            "description": "Comparar erros numéricos em simulações para diferentes ordens de AB, observando convergência de ordem k para método de k passos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmulas explícitas de Adams-Bashforth para ordens 2, 3 e 4",
                                  "subSteps": [
                                    "Estude a fórmula geral de Adams-Bashforth: y_{n+1} = y_n + h ∑_{j=0}^k β_j f(t_{n-j}, y_{n-j}).",
                                    "Memorize os coeficientes β_j para ordens k=2 (β0=3/2, β1=-1/2), k=3 (β0=23/12, β1=-16/12, β2=5/12) e k=4 (β0=55/24, β1=-59/24, β2=37/24, β3=-9/24).",
                                    "Derive ou verifique o erro local de truncamento O(h^{k+1}) para cada ordem.",
                                    "Implemente uma função auxiliar para calcular os coeficientes automaticamente.",
                                    "Teste com um exemplo simples para validar as fórmulas."
                                  ],
                                  "verification": "Coeficientes corretos reproduzidos manualmente e código auxiliar roda sem erros para k=2,3,4.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica, papel e caneta, editor de código (Python/MATLAB).",
                                  "tips": "Use tabelas para memorizar coeficientes; associe-os à integração de Newton-Cotes.",
                                  "learningObjective": "Compreender a estrutura e precisão teórica das fórmulas AB de diferentes ordens.",
                                  "commonMistakes": "Confundir coeficientes de AB com AB-Moulton; ignorar o fator h na soma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar métodos AB para um problema de valor inicial modelo",
                                  "subSteps": [
                                    "Escolha o PVI y' = -y, y(0)=1 no intervalo [0,2], solução exata y=e^{-x}.",
                                    "Implemente Runge-Kutta 4 para inicializar os primeiros passos necessários.",
                                    "Code as funções AB2, AB3 e AB4 usando os coeficientes do passo 1.",
                                    "Execute simulações com h=0.1, 0.05, 0.025 para cada método.",
                                    "Calcule o erro global máximo ||y_exata - y_num||_∞ para cada caso."
                                  ],
                                  "verification": "Soluções numéricas aproximam a exata para h pequeno; erros diminuem com h.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, solução exata plotada.",
                                  "tips": "Vectorize o código para eficiência; use arrays para armazenar histórico de f.",
                                  "learningObjective": "Implementar corretamente métodos multistep explícitos em código.",
                                  "commonMistakes": "Esquecer passos iniciais com RK4; erro na indexação do histórico de y."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações comparativas e calcular erros numéricos",
                                  "subSteps": [
                                    "Rode simulações para AB2, AB3, AB4 com h=0.2, 0.1, 0.05, 0.025.",
                                    "Compute erros absolutos em pontos equidistantes e erro máximo para cada h e ordem.",
                                    "Crie tabelas de erros: log2(E(h)/E(h/2)) para estimar ordem de convergência.",
                                    "Gere plots de erro vs. log(h) para cada método.",
                                    "Identifique a convergência aproximada de ordem k para ABk."
                                  ],
                                  "verification": "Tabelas mostram log2(ratio) ≈ k para cada método; plots lineares com inclinação -k.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilhas Excel ou Jupyter Notebook para tabelas e plots (Matplotlib).",
                                  "tips": "Use semi-log plot para erro vs h; refine malha se necessário.",
                                  "learningObjective": "Quantificar empiricamente a precisão e convergência de diferentes ordens.",
                                  "commonMistakes": "Erro aritmético em log2(E1/E2); plots errados (eixo log no h, não no erro)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar resultados de convergência",
                                  "subSteps": [
                                    "Compare ordens de convergência estimadas vs. teóricas (k para ABk).",
                                    "Discuta por que ordens mais altas são melhores para h fixo, mas custam mais passos iniciais.",
                                    "Avalie estabilidade: rode para h maior e observe oscilações.",
                                    "Escreva relatório resumindo tabelas, plots e conclusões.",
                                    "Teste com outro PVI (ex: y'=y(1-y)) para generalizar."
                                  ],
                                  "verification": "Relatório explica convergência observada alinhada à teoria; testes em PVI extra confirmam.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documento Word/LaTeX para relatório, gráficos salvos.",
                                  "tips": "Enfatize trade-off precisão vs. custo computacional.",
                                  "learningObjective": "Interpretar numericamente a relação entre ordem do método e precisão.",
                                  "commonMistakes": "Atribuir desvios à instabilidade em vez de h inadequado; ignorar custo inicial."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 em [0,2]: Com h=0.1, AB2 erro≈0.0012, AB3≈0.00018, AB4≈3.5e-5. Plots de log(erro) vs log(h) mostram inclinações -2,-3,-4 respectivamente, confirmando convergência de ordem k.",
                              "finalVerifications": [
                                "Tabelas de erros mostram redução consistente com h/2.",
                                "Estimativas de ordem de convergência próximas a k para ABk.",
                                "Plots lineares de log(erro) vs log(h) com inclinação -k.",
                                "Discussão inclui trade-offs de custo computacional.",
                                "Teste em PVI não-linear valida generalização.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação das fórmulas AB (coeficientes corretos).",
                                "Correta estimação empírica de ordens de convergência (erro <10%).",
                                "Qualidade dos plots e tabelas (legíveis, escalas adequadas).",
                                "Interpretação teórica-empírica coerente.",
                                "Análise de limitações (ex: passos iniciais, estabilidade).",
                                "Relatório claro e conciso."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de movimento com métodos numéricos em dinâmica.",
                                "Computação: Programação científica e análise de algoritmos numéricos.",
                                "Estatística: Análise de erro e regressão linear para estimar ordens.",
                                "Engenharia: Otimização de solvers em simulações CFD ou controle."
                              ],
                              "realWorldApplication": "Em previsão numérica do tempo (modelos ECMWF usam métodos multistep como AB para eficiência em EDOs de grande escala), onde ordens mais altas melhoram precisão em previsões de longo prazo sem custo proibitivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.1.3",
                        "name": "Análise de Erro, Estabilidade e Implementação",
                        "description": "Estudo do erro local e global, condições de estabilidade A-stável e considerações práticas para implementação numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.3.1",
                            "name": "Calcular erro local de truncamento",
                            "description": "Determinar o erro local O(h^{k+1}) para método ABk, expressando-o em termos do polinômio interpolador e derivadas de f.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação exata do método Adams-Bashforth de ordem k (ABk)",
                                  "subSteps": [
                                    "Relembre o problema de valor inicial (PVI): y' = f(t,y), y(t_0)=y_0.",
                                    "Escreva a fórmula integral exata para y(t_{n+1}): y(t_{n+1}) = y(t_n) + ∫_{t_n}^{t_{n+1}} f(t,y(t)) dt.",
                                    "Apresente a aproximação do método ABk: y_{n+1} = y_n + h ∑_{j=0}^k b_j f(t_{n-j}, y_{n-j}), com coeficientes b_j.",
                                    "Liste os coeficientes b_j para ABk como integrais de coeficientes de Lagrange do polinômio interpolador.",
                                    "Verifique com um exemplo simples, como AB1 (método de Euler)."
                                  ],
                                  "verification": "Escreva corretamente a fórmula do ABk e compute os b_j para k=2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre métodos multistep",
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Foco nos coeficientes b_j derivados da interpolação backward; memorize a estrutura geral.",
                                  "learningObjective": "Compreender a base integral e a aproximação polinomial do método ABk.",
                                  "commonMistakes": [
                                    "Confundir AB explícito com métodos implícitos como ABM.",
                                    "Esquecer que usa valores passados exatos para erro local."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o erro local assumindo valores anteriores exatos",
                                  "subSteps": [
                                    "Defina o erro local de truncamento τ_{n+1} = [y(t_{n+1}) - y(t_n) - h ∑_{j=0}^k b_j f(t_{n-j}, y(t_{n-j})) ] / h.",
                                    "Expanda y(t_{n+1}) via fórmula integral exata sobre [t_n, t_{n+1}].",
                                    "Introduza o polinômio interpolador p_k(ξ) de grau k que interpola f nos pontos t_{n-j}, j=0..k.",
                                    "Aproxime a integral por ∫ p_k(ξ) dξ, que dá exatamente o termo do ABk.",
                                    "Mostre que o erro é ∫ [f(ξ,y(ξ)) - p_k(ξ)] dξ / h."
                                  ],
                                  "verification": "Derive a expressão de τ_{n+1} em termos da diferença f - p_k.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com fórmula integral do PVI",
                                    "Tabela de coeficientes ABk",
                                    "Calculadora simbólica opcional (ex: Mathematica)"
                                  ],
                                  "tips": "Use mudança de variável ξ = t - t_n para normalizar o intervalo [0,h].",
                                  "learningObjective": "Estabelecer a conexão entre erro local e erro de interpolação.",
                                  "commonMistakes": [
                                    "Negligenciar a dependência de y no f dentro da integral.",
                                    "Confundir erro local com erro global."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar o erro usando o resto de interpolação de Lagrange ou Newton",
                                  "subSteps": [
                                    "Lembre o teorema do resto de interpolação: f(ξ) - p_k(ξ) = [f^{(k+1)}(η)] / (k+1)! * ω(ξ), onde ω(ξ) = ∏_{j=0}^k (ξ - s_j), s_j pontos de interpolação.",
                                    "Para interpolação backward em ABk, adapte os pontos s_j = -jh.",
                                    "Integre o resto: erro = (1/h) ∫_0^h [f^{(k+1)}(η(ξ))] / (k+1)! * [(ξ)^k (ξ-h)...(ξ-kh)] dξ.",
                                    "Simplifique para a forma padrão O(h^{k+1}): identifique o coeficiente c_{k+1} = ∫_0^1 ∏_{j=0}^k (σ - j) dσ / (k+1)!, com σ=ξ/h.",
                                    "Verifique para k=1: deve dar -h^2/2 f''(ξ)."
                                  ],
                                  "verification": "Escreva a expressão exata do erro local como c_{k+1} h^{k+1} f^{(k+1)}(ξ).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Teorema de interpolação de Newton/Lagrange",
                                    "Tabelas de coeficientes de erro ABk",
                                    "Papel milimetrado para integrais"
                                  ],
                                  "tips": "Use a forma de Newton dividida para coeficientes mais intuitivos em multistep.",
                                  "learningObjective": "Conectar erro de truncamento diretamente às derivadas via resto de interpolação.",
                                  "commonMistakes": [
                                    "Pontos de interpolação errados (forward vs backward).",
                                    "Fator (k+1)! invertido no resto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar a ordem O(h^{k+1}) e aplicações",
                                  "subSteps": [
                                    "Compute explicitamente c_{k+1} para AB2 e AB3 usando integrais numéricas ou tabelas.",
                                    "Expanda f^{(k+1)}(η) via Taylor se necessário para confirmação.",
                                    "Discuta como o erro local acumula para erro global O(h^k).",
                                    "Teste numericamente com uma ODE simples (ex: y'=y, solução exata e^{t}).",
                                    "Resuma a expressão final em termos de polinômio interpolador e derivadas."
                                  ],
                                  "verification": "Derive o erro para AB2: (5/12) h^3 y'''(ξ), confirmando O(h^3).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para verificação numérica",
                                    "Exemplos resolvidos de Burden",
                                    "Gráficos de erro vs h"
                                  ],
                                  "tips": "Sempre normalize h=1 para visualizar o coeficiente limite.",
                                  "learningObjective": "Aplicar e validar a derivação do erro local para ABk.",
                                  "commonMistakes": [
                                    "Confundir ordem local (k+1) com global (k).",
                                    "Sinais errados nos coeficientes c_{k+1} (geralmente negativos)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para AB2: y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}). Considere y' = -y, y(0)=1. Usando interpolação em t_n e t_{n-1}, p_1(ξ) = f_n (1 + ξ/h) - f_{n-1} (ξ/h). O resto dá erro local = ∫_0^h [f''(η)/2] ξ (ξ - h) dξ / h = (5/12) h^3 f'''(ξ). Compute numericamente para h=0.1 e compare com solução exata e^{-t}.",
                              "finalVerifications": [
                                "Derivação correta da fórmula integral exata para y(t_{n+1}).",
                                "Expressão precisa do erro como diferença entre integral de f e integral de p_k.",
                                "Uso correto do resto de interpolação levando a O(h^{k+1}).",
                                "Cálculo explícito de c_{k+1} para pelo menos um k (ex: AB2 ou AB3).",
                                "Verificação numérica simples confirmando a ordem do erro.",
                                "Resumo final ligando polinômio interpolador e f^{(k+1)}."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do resto de interpolação (peso 30%).",
                                "Clareza e correção na expressão do erro local O(h^{k+1}) (peso 25%).",
                                "Uso adequado de notação e variáveis (backward points) (peso 15%).",
                                "Inclusão de coeficiente c_{k+1} e confirmação para exemplo específico (peso 15%).",
                                "Conexão explícita com polinômio interpolador e derivadas de f (peso 10%).",
                                "Ausência de erros comuns como confusão de ordens ou sinais (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementar ABk em Python e plotar erros de truncamento vs h.",
                                "Física: Aplicar em equações diferenciais de movimento orbital para análise de precisão.",
                                "Estatística: Comparar erros de truncamento com erros de arredondamento em simulações Monte Carlo.",
                                "Engenharia: Otimização de passos h em solvers numéricos para controle de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou previsão meteorológica, calcular o erro local de truncamento em métodos ABk permite escolher h ótimo, garantindo precisão em modelos climáticos de longo prazo sem instabilidade, como no ECMWF model."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.2",
                            "name": "Analisar estabilidade absoluta",
                            "description": "Construir o polinômio de estabilidade ρ(ζ) = ζ^{k+1} - ζ^k para ABk e identificar a região de estabilidade no plano complexo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da estabilidade absoluta em métodos multistep",
                                  "subSteps": [
                                    "Estudar a definição de estabilidade absoluta para métodos lineares multistep aplicados à equação teste y' = λ y.",
                                    "Revisar os polinômios característicos ρ(ζ) e σ(ζ), focando em ρ(ζ) para estabilidade.",
                                    "Entender que a região de estabilidade absoluta é tipicamente definida pelo conjunto {ζ ∈ ℂ : |ρ(ζ)| ≤ 1} ou variações para métodos explícitos.",
                                    "Analisar o papel de ζ = e^{λ h} no plano complexo, com Re(λ h) < 0 para estabilidade.",
                                    "Discutir diferenças entre estabilidade zero e absoluta."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é estabilidade absoluta e dar um exemplo simples para Euler forward.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos multistep",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Comece com métodos de passo único para analogia antes de multistep.",
                                  "learningObjective": "Dominar os conceitos teóricos de estabilidade absoluta e seu significado no plano complexo.",
                                  "commonMistakes": [
                                    "Confundir estabilidade zero (raízes de ρ) com absoluta (|ρ(ζ)| ≤ 1)",
                                    "Ignorar o papel de σ(ζ) inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o polinômio de estabilidade ρ(ζ) para o método Adams-Bashforth de ordem k (ABk)",
                                  "subSteps": [
                                    "Recordar a forma geral do método ABk: y_{n+k+1} = y_{n+k} + h ∑ coeficientes f_{n+j}.",
                                    "Derivar ρ(ζ) a partir da parte homogênea: ρ(ζ) = ζ^{k+1} - ζ^k.",
                                    "Fatorar ρ(ζ) = ζ^k (ζ - 1) e identificar raízes (ζ=0 com multiplicidade k, ζ=1).",
                                    "Verificar consistência de ordem 1: ρ'(1) = 1.",
                                    "Comparar com outros métodos como AB2 ou AB3 explicitamente."
                                  ],
                                  "verification": "Escrever ρ(ζ) corretamente para k=2 e k=3, e fatorá-lo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de derivação",
                                    "Calculadora simbólica (ex: SymPy ou Mathematica)",
                                    "Referência: fórmula padrão de ABk"
                                  ],
                                  "tips": "Use operadores de diferença finita para derivar ρ a partir da definição do método.",
                                  "learningObjective": "Construir e fatorar ρ(ζ) com precisão para ABk genérico.",
                                  "commonMistakes": [
                                    "Índice errado: confundir k-step com ordem",
                                    "Fatoração incorreta de ζ^{k+1} - ζ^k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a condição |ρ(ζ)| ≤ 1 no plano complexo",
                                  "subSteps": [
                                    "Calcular |ρ(ζ)| = |ζ|^k |ζ - 1| para ζ = x + i y.",
                                    "Definir a fronteira da região: |ζ|^k |ζ - 1| = 1.",
                                    "Analisar comportamento para |ζ| pequeno (próximo de 0) e próximo de 1.",
                                    "Estudar simetria e interseções com eixos real e imaginário.",
                                    "Discutir limitação para métodos explícitos: região pequena no semiplano esquerdo."
                                  ],
                                  "verification": "Plotar manualmente ou computacionalmente a curva |ρ(ζ)| = 1 para k=2.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/Matplotlib, MATLAB)",
                                    "Grade complexa impressa",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use coordenadas polares para simplificar |ζ|^k |ζ - 1|.",
                                  "learningObjective": "Determinar analiticamente pontos chave da fronteira de estabilidade.",
                                  "commonMistakes": [
                                    "Esquecer fator |ζ|^k, focando só em |ζ-1|",
                                    "Plotar em escala errada, perdendo detalhes perto de 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e visualizar a região de estabilidade absoluta",
                                  "subSteps": [
                                    "Rastrear a região onde |ρ(ζ)| ≤ 1, tipicamente um lóbulo no semiplano esquerdo.",
                                    "Comparar regiões para diferentes k (aumenta ligeiramente com k).",
                                    "Interpretar implicações: passo h limitado por |λ| para estabilidade.",
                                    "Sketch ou plotar a região e sombrear o interior.",
                                    "Concluir sobre vantagens/desvantagens de ABk vs métodos implícitos."
                                  ],
                                  "verification": "Desenhar/sketch da região para k=3 e listar pontos de interseção com eixo real.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou MATLAB para contour plot de |ρ(ζ)|",
                                    "Papel milimetrado para sketch manual"
                                  ],
                                  "tips": "Use contourf em Python para visualizar |ρ(ζ)| <1 claramente.",
                                  "learningObjective": "Visualizar e interpretar a região de estabilidade no contexto numérico.",
                                  "commonMistakes": [
                                    "Confundir interior/exterior da curva",
                                    "Ignorar que região é pequena para explícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para AB2 (k=2), ρ(ζ) = ζ^3 - ζ^2 = ζ^2 (ζ - 1). Calcule |ρ(ζ)| = |ζ|^2 |ζ - 1|. A fronteira |ζ|^2 |ζ - 1| = 1 intersecta o eixo real em ≈ -0.73 e 1. Fronteira imaginária máxima ≈ 1.4i. Região: pequeno lóbulo esquerdo. Implemente em Python: def rho(z, k=2): return z**k * (z - 1); plot contour onde abs(rho)<1.",
                              "finalVerifications": [
                                "ρ(ζ) corretamente construído e fatorado para k dado.",
                                "Fronteira |ρ(ζ)|=1 plotada com pontos chave identificados.",
                                "Região de estabilidade descrita qualitativamente (ex: 'lóbulo esquerdo pequeno').",
                                "Interpretação correta: h < limite / |λ| para Re(λ)<0.",
                                "Comparação com método implícito (ex: AB implícito tem região maior)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ρ(ζ): 25%.",
                                "Análise correta de |ρ(ζ)| ≤1: 25%.",
                                "Visualização clara da região: 20%.",
                                "Interpretação numérica/contextual: 20%.",
                                "Ausência de erros comuns em fatoração ou plotagem: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores harmônicos (EDOs).",
                                "Computação: Implementação de plots complexos em Python/MATLAB.",
                                "Engenharia: Análise de rigidez em modelos diferenciais.",
                                "Estatística: Regiões de confiança análogas no plano complexo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou dinâmicas de fluidos, onde EDOs rígidas requerem passos h pequenos para estabilidade em ABk explícitos, guiando escolha de métodos implícitos para eficiência computacional em previsões numéricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.3",
                            "name": "Implementar em código com inicialização",
                            "description": "Escrever pseudocódigo ou código em Python/MATLAB para AB4, utilizando método de Runge-Kutta de 4ª ordem para os primeiros passos iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema de valor inicial e preparar o ambiente de codificação",
                                  "subSteps": [
                                    "Escolha um problema modelo: y' = f(t, y), com y(t0) = y0. Exemplo: y' = -2y, y(0) = 1.",
                                    "Defina parâmetros: intervalo [t0, tf], passo h, tolerância para erro.",
                                    "Configure o ambiente em Python (importe numpy, matplotlib) ou MATLAB.",
                                    "Escreva a função f(t, y) como uma função escalar ou vetorial.",
                                    "Crie vetores para armazenar soluções aproximadas (t, y)."
                                  ],
                                  "verification": "Função f é testada com valores conhecidos e retorna resultados corretos; ambiente roda sem erros de importação.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "Python/MATLAB instalado",
                                    "Bibliotecas: numpy, scipy, matplotlib (Python)",
                                    "Editor de código (Jupyter, Spyder)"
                                  ],
                                  "tips": [
                                    "Use funções vectorizadas para eficiência.",
                                    "Teste f com solução exata conhecida para validação inicial."
                                  ],
                                  "learningObjective": "Preparar estrutura de dados e função derivada para integração numérica.",
                                  "commonMistakes": [
                                    "Definir f incorretamente (ex: esquecer dependência em t)",
                                    "Escolher h muito grande, causando instabilidade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método Runge-Kutta de 4ª ordem (RK4) para inicialização",
                                  "subSteps": [
                                    "Escreva a função RK4 que computa um passo: k1 = h*f(tn, yn), k2 = h*f(tn+h/2, yn+k1/2), etc.",
                                    "Implemente loop para 4 passos iniciais: y1, y2, y3, y4 usando RK4 a partir de y0.",
                                    "Armazene tn, yn em arrays iniciais.",
                                    "Adicione tratamento de erros (ex: if h <= 0).",
                                    "Teste com exemplo simples e compare com solução exata."
                                  ],
                                  "verification": "RK4 produz y1-y4 precisos (erro < 1e-6 comparado a solução analítica).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Código do Step 1",
                                    "Documentação RK4 (Wikipedia ou livro de Burden)"
                                  ],
                                  "tips": [
                                    "Implemente RK4 como função reutilizável.",
                                    "Use Butcher tableau para clareza no código."
                                  ],
                                  "learningObjective": "Dominar implementação de método single-step de alta ordem para bootstrap.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes k2-k4 (metade de h errado)",
                                    "Não atualizar t corretamente no loop"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método Adams-Bashforth de 4ª ordem (AB4)",
                                  "subSteps": [
                                    "Defina coeficientes AB4: β0=55/24, β1=-59/24, β2=37/24, β3=-9/24.",
                                    "Escreva fórmula: y_{n+1} = y_n + h * (β0 f_n + β1 f_{n-1} + β2 f_{n-2} + β3 f_{n-3}).",
                                    "Crie loop principal: compute f para pontos iniciais, avance com AB4.",
                                    "Atualize arrays t e y dinamicamente.",
                                    "Pare no tf ou número máximo de passos."
                                  ],
                                  "verification": "AB4 avança corretamente de y4 para y5+ sem erros de índice.",
                                  "estimatedTime": "1-1.5 hours",
                                  "materials": [
                                    "Coeficientes AB4 anotados",
                                    "Código RK4 do Step 2"
                                  ],
                                  "tips": [
                                    "Mantenha buffer de 4 valores anteriores de f em array separado.",
                                    "Use pre-alocação de arrays para performance."
                                  ],
                                  "learningObjective": "Implementar método multistep explícito usando valores bootstrapped.",
                                  "commonMistakes": [
                                    "Índices errados em arrays (off-by-one)",
                                    "Coeficientes com sinal ou fração invertida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar RK4 e AB4, simular e visualizar resultados",
                                  "subSteps": [
                                    "Chame RK4 para inicializar, então AB4 para o resto.",
                                    "Compute erro global vs. solução exata (se conhecida).",
                                    "Plote y aproximado vs. exato e tabela de erros.",
                                    "Adicione análise de convergência variando h.",
                                    "Salve código como script completo ou função."
                                  ],
                                  "verification": "Simulação completa roda, gráfico mostra convergência de ordem 4.",
                                  "estimatedTime": "45-60 minutes",
                                  "materials": [
                                    "Biblioteca de plotagem",
                                    "Solução exata do exemplo (ex: y=exp(-2t))"
                                  ],
                                  "tips": [
                                    "Use loglog para gráfico de erro vs. h.",
                                    "Modularize em função solve_ab4(f, t0, y0, tf, h)."
                                  ],
                                  "learningObjective": "Criar solver híbrido completo e validar numericamente.",
                                  "commonMistakes": [
                                    "Não conectar corretamente saída RK4 como entrada AB4",
                                    "Escala errada no plot"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar estabilidade, erro e otimizar o código",
                                  "subSteps": [
                                    "Teste estabilidade com problema rígido (ex: y' = -50y).",
                                    "Meça ordem de precisão: erro ~ O(h^4).",
                                    "Otimize: vectorize loops, adicione adaptive h se possível.",
                                    "Escreva pseudocódigo comentado.",
                                    "Documente limitações (ex: instabilidade para problemas rígidos)."
                                  ],
                                  "verification": "Análise confirma ordem 4 e identifica instabilidades esperadas.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Testes adicionais de problemas",
                                    "Teoria de estabilidade AB (livro)"
                                  ],
                                  "tips": [
                                    "Use Dahlquist test equation para estabilidade rápida.",
                                    "Comente cada seção do código."
                                  ],
                                  "learningObjective": "Avaliar implementação teoricamente e praticamente.",
                                  "commonMistakes": [
                                    "Ignorar acúmulo de erro de arredondamento",
                                    "h muito pequeno causando overflow"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y + sin(t), y(0)=1 no intervalo [0,5] com h=0.1. Use RK4 para y1-y4, AB4 depois. Compare com solução numérica de alta precisão (scipy.integrate.odeint).",
                              "finalVerifications": [
                                "Código executa sem erros para exemplo padrão.",
                                "Erro global < 1e-4 no final do intervalo.",
                                "Gráfico mostra sobreposição boa com solução exata.",
                                "Variação de h confirma convergência O(h^4).",
                                "Teste com outro f (ex: y'=y(1-y)) succeeds.",
                                "Pseudocódigo matches implementação."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica (RK4 e AB4 exatos).",
                                "Eficiência computacional (tempo razoável para N=1000 passos).",
                                "Robustez (trata h inválido, f não-linear).",
                                "Clareza do código (comentários, estrutura modular).",
                                "Validação numérica (erros e plots).",
                                "Análise de estabilidade incluída."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops, funções e vectorização.",
                                "Física: Simulação de EDOs em dinâmica (ex: osciladores).",
                                "Engenharia: Modelagem em controle e circuitos.",
                                "Estatística: Propagação de erros numéricos."
                              ],
                              "realWorldApplication": "Simulações em previsão meteorológica (modelos ODEs atmosféricos), farmacocinética (decaimento de drogas), engenharia aeroespacial (tra jetórias de mísseis), onde métodos multistep eficientes são usados após inicialização precisa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Métodos Implícitos de Adams-Moulton",
                    "description": "Métodos implícitos de passo múltiplo que requerem solução de equações não lineares em cada passo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Formulação dos Métodos Implícitos de Adams-Moulton",
                        "description": "Apresentação da estrutura geral dos métodos implícitos de Adams-Moulton como métodos de passo múltiplo para resolução de problemas de valor inicial, baseados na integração numérica da forma integral usando interpolação polinomial de f(t,y).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Entender a fórmula geral do método Adams-Moulton",
                            "description": "Compreender a representação da fórmula implícita de k passos: y_{n+1} = y_n + h β_0 f(t_{n+1}, y_{n+1}) + h Σ_{j=1}^k β_j f(t_{n+1-j}, y_{n+1-j}), incluindo os coeficientes β_j derivados da interpolação de Lagrange.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos dos Métodos de Passo Múltiplo Implícitos",
                                  "subSteps": [
                                    "Relembre o Problema de Valor Inicial (PVI): y' = f(t, y), y(t0) = y0.",
                                    "Entenda a diferença entre métodos explícitos e implícitos em métodos multistep.",
                                    "Identifique que métodos Adams-Moulton são implícitos devido ao termo f(t_{n+1}, y_{n+1}).",
                                    "Revise a necessidade de k passos anteriores para aproximar a integral.",
                                    "Estude a representação integral da solução exata: y_{n+1} = y_n + ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt."
                                  ],
                                  "verification": "Escreva a fórmula integral do PVI e explique por que ela leva a métodos implícitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de métodos multistep)",
                                    "Notas de aula sobre PVI",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Comece com um exemplo simples de PVI para fixar conceitos básicos.",
                                  "learningObjective": "Compreender a base teórica que motiva a fórmula geral do Adams-Moulton.",
                                  "commonMistakes": [
                                    "Confundir métodos explícitos (Adams-Bashforth) com implícitos",
                                    "Ignorar o papel da integral na derivação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula Geral via Interpolação de Lagrange",
                                  "subSteps": [
                                    "Aproxime f(t, y(t)) por um polinômio interpolante de grau k usando pontos (t_{n+1-j}, f_{n+1-j}) para j=0 a k.",
                                    "Escreva o polinômio de Lagrange: P_k(t) = Σ_{j=0}^k f_{n+1-j} l_j(t), onde l_j são as bases de Lagrange.",
                                    "Integre P_k(t) de t_n a t_{n+1}: ∫ P_k(t) dt = h Σ_{j=0}^k β_j f_{n+1-j}.",
                                    "Note que β_0 = ∫_{t_n}^{t_{n+1}} l_0(s) ds / h, e β_j para j≥1.",
                                    "Identifique o termo implícito: f_{n+1} = f(t_{n+1}, y_{n+1}) em β_0."
                                  ],
                                  "verification": "Derive os coeficientes β_j para k=1 e verifique se coincidem com valores tabelados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de papel para derivações",
                                    "Tabela de coeficientes Adams-Moulton",
                                    "Software como MATLAB para plotar polinômios de Lagrange"
                                  ],
                                  "tips": "Use variáveis normalizadas s = (t - t_n)/h para simplificar integrais.",
                                  "learningObjective": "Dominar a origem dos coeficientes β_j através da interpolação.",
                                  "commonMistakes": [
                                    "Erros nos índices de Lagrange (j=0 inclui n+1)",
                                    "Confundir integração de l_j com diferenciação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os Componentes da Fórmula Geral",
                                  "subSteps": [
                                    "Analise y_{n+1} = y_n + h β_0 f(t_{n+1}, y_{n+1}) + h Σ_{j=1}^k β_j f(t_{n+1-j}, y_{n+1-j}).",
                                    "Explique o termo implícito h β_0 f_{n+1}, que requer solução iterativa.",
                                    "Discuta como os termos passados Σ h β_j f_{n+1-j} usam história computacional.",
                                    "Verifique consistência: ordem do método é k+1 para Adams-Moulton de k passos.",
                                    "Compare com Adams-Bashforth: diferença está no uso de f_{n+1} vs f_n."
                                  ],
                                  "verification": "Reescreva a fórmula destacando termos implícitos e explícitos, e explique sua função.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para diagramas",
                                    "Exemplos numéricos de livros-texto",
                                    "Vídeo tutorial sobre métodos multistep"
                                  ],
                                  "tips": "Desenhe um diagrama de fluxo mostrando dependência de y_{n+1} em si mesmo.",
                                  "learningObjective": "Interpretar cada termo da fórmula e sua implicação numérica.",
                                  "commonMistakes": [
                                    "Achar que todos β_j são conhecidos a priori sem tabela",
                                    "Ignorar que β_0 depende de y_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Coeficientes β_j e Exemplos para Diferentes k",
                                  "subSteps": [
                                    "Consulte ou derive tabelas de β_j para k=1,2,3 (ex: k=1: β_0=5/12, β_1=8/12, β_2=-1/12? Não, para Moulton correto).",
                                    "Para k=1: β_0 = 5/12, β_1 = 8/12? Corrija: padrão AM2: y_{n+1}=y_n + h(5/12 f_{n+1} - 8/12 f_n +1/12 f_{n-1}).",
                                    "Calcule β_j explicitamente para k=2 usando Lagrange.",
                                    "Discuta estabilidade e precisão crescente com k.",
                                    "Resolva um PVI simples usando a fórmula para k=1."
                                  ],
                                  "verification": "Liste coeficientes corretos para AM2 e AM3, e aplique em um exemplo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela padrão de coeficientes multistep",
                                    "Planilha Excel ou Python para cálculos",
                                    "Problema de exemplo: y'=y, y(0)=1"
                                  ],
                                  "tips": "Memorize padrões: β_j alternam sinais e magnitudes crescem.",
                                  "learningObjective": "Aplicar a fórmula geral com coeficientes específicos.",
                                  "commonMistakes": [
                                    "Índices errados em tabelas (confundir Bashforth/Moulton)",
                                    "Arredondamentos em coeficientes fracionários"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y, y(0)=1 com h=0.1, k=1 (AM1: y1 = y0 + h(5/12 f1 - 8/12 f0 +1/12? Espera, AM1 é backward Euler ajustado, mas padrão AM2 usa 3 pontos. Exemplo: Assuma valores iniciais y0,y-1 aproximados, compute y1 implicitamente via iteração de ponto fixo.",
                              "finalVerifications": [
                                "Pode derivar a fórmula geral a partir da integral e Lagrange.",
                                "Escreve corretamente a fórmula com índices e termos implícitos.",
                                "Lista coeficientes β_j para k=1,2 sem consultar tabela.",
                                "Explica por que o método é implícito e como resolvê-lo.",
                                "Identifica ordem de precisão como k+1.",
                                "Compara com método explícito equivalente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação dos β_j via Lagrange (80% correto).",
                                "Correta identificação do termo implícito e sua implicação.",
                                "Uso apropriado de notação matemática (índices, somatórios).",
                                "Explicação clara da motivação integral.",
                                "Aplicação numérica sem erros aritméticos.",
                                "Compreensão de limitações (ex: necessidade de predictor)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/Octave para simulações.",
                                "Física: Modelagem de osciladores em dinâmica.",
                                "Engenharia: Simulações em controle de sistemas.",
                                "Estatística: Integração numérica em MCMC."
                              ],
                              "realWorldApplication": "Usado em software de simulação como MATLAB ODE solvers para previsões meteorológicas, dinâmica de fluidos em engenharia aeroespacial e modelagem financeira de derivativos, onde alta precisão e estabilidade são cruciais para passos grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Derivar coeficientes para métodos de baixa ordem",
                            "description": "Calcular os coeficientes β_j para os métodos AM2 (2 passos, ordem 3) e AM3 (3 passos, ordem 4), utilizando a integração exata do polinômio interpolador de grau k-1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a formulação geral para derivação dos coeficientes dos métodos AMk",
                                  "subSteps": [
                                    "Escreva a relação fundamental do método implícito Adams-Moulton: y_{n+1} = y_n + h \\sum_{j=0}^k \\beta_j f_{n+1-j}.",
                                    "Introduza a variável adimensional u = (t - t_n)/h, transformando o integral em \\int_0^1 f(t_n + h u) du.",
                                    "Estabeleça as condições de exatidão para polinômios de grau até k: \\sum_{j=0}^k \\beta_j (1 - j)^m = \\int_0^1 u^m du = \\frac{1}{m+1}, para m = 0, 1, \\dots, k.",
                                    "Formule o sistema linear de k+1 equações com k+1 incógnitas \\beta_j.",
                                    "Discuta que o polinômio interpolador de grau k-1 nos pontos passados é implicitamente usado via essas condições."
                                  ],
                                  "verification": "Sistema geral de equações escrito corretamente, com potências (1-j)^m e integrais 1/(m+1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para manipulação de frações",
                                    "Referência de livro de Análise Numérica"
                                  ],
                                  "tips": "Sempre use u = (t - t_n)/h para normalizar e simplificar os cálculos com intervalos unitários.",
                                  "learningObjective": "Compreender como as condições de exatidão derivam da integração exata do interpolador.",
                                  "commonMistakes": [
                                    "Confundir os pontos de avaliação u_j = 1 - j.",
                                    "Errar o limite do integral (deve ser de 0 a 1).",
                                    "Esquecer que são k+1 equações para ordem k+1."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar os coeficientes para o método AM2 (2 passos, ordem 3)",
                                  "subSteps": [
                                    "Escreva o sistema para k=2: m=0: \\beta_0 + \\beta_1 + \\beta_2 = 1; m=1: \\beta_0 - \\beta_2 = 1/2; m=2: \\beta_0 + \\beta_2 = 1/3.",
                                    "Resolva eqs. 2 e 3: some para 2\\beta_0 = 5/6 \\Rightarrow \\beta_0 = 5/12; subtraia para 2\\beta_2 = 1/3 - 1/2 = -1/6 \\Rightarrow \\beta_2 = -1/12.",
                                    "Substitua na eq. 1: 5/12 + \\beta_1 - 1/12 = 1 \\Rightarrow \\beta_1 = 1 - 4/12 = 8/12 = 2/3.",
                                    "Escreva a fórmula: y_{n+1} = y_n + h (5/12 f_{n+1} + 2/3 f_n - 1/12 f_{n-1}).",
                                    "Verifique plugando de volta nas equações originais."
                                  ],
                                  "verification": "Coeficientes exatos: \\beta_0 = 5/12, \\beta_1 = 2/3, \\beta_2 = -1/12; todas equações satisfeitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para matrizes",
                                    "Calculadora para frações"
                                  ],
                                  "tips": "Resolva por substituição ou eliminação para evitar erros em sistemas pequenos.",
                                  "learningObjective": "Calcular precisamente os coeficientes AM2 resolvendo o sistema tridiagonal.",
                                  "commonMistakes": [
                                    "Erro aritmético em 1/2 + 1/3 = 5/6.",
                                    "Índices errados: u_0=1, u_1=0, u_2=-1.",
                                    "Simplificar frações prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar os coeficientes para o método AM3 (3 passos, ordem 4)",
                                  "subSteps": [
                                    "Escreva o sistema para k=3: m=0: \\beta_0 + \\beta_1 + \\beta_2 + \\beta_3 = 1; m=1: \\beta_0 - \\beta_2 -2\\beta_3 = 1/2; m=2: \\beta_0 + \\beta_2 +4\\beta_3 = 1/3; m=3: \\beta_0 - \\beta_2 -8\\beta_3 = 1/4.",
                                    "Resolva sistematicamente: use eqs. pares para eliminar variáveis, ou monte matriz e inverta.",
                                    "Obtenha: \\beta_0 = 9/24, \\beta_1 = 19/24, \\beta_2 = -5/24, \\beta_3 = 1/24 (verificação via soma e literatura).",
                                    "Escreva a fórmula: y_{n+1} = y_n + h (9/24 f_{n+1} + 19/24 f_n - 5/24 f_{n-1} + 1/24 f_{n-2}).",
                                    "Verifique pelo menos duas equações para confirmar."
                                  ],
                                  "verification": "Coeficientes exatos: \\beta_0 = 9/24, \\beta_1 = 19/24, \\beta_2 = -5/24, \\beta_3 = 1/24; consistentes com valores padrão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora ou software como Python/Octave para resolver sistema"
                                  ],
                                  "tips": "Use frações com denominador comum (24) para facilitar somas e verificações.",
                                  "learningObjective": "Resolver sistemas lineares maiores para coeficientes AM3 e generalizar.",
                                  "commonMistakes": [
                                    "Erros nos poderes: (-2)^2=4, (-2)^3=-8.",
                                    "Sinal errado nos coeficientes negativos.",
                                    "Não verificar a soma para m=0."
                                  ]
                                }
                              ],
                              "practicalExample": "Para AM2, derive β_j = [5/12, 2/3, -1/12]. Aplique em y' = -y, y(0)=1, h=0.2: suponha y_{n-1}=0.8187, y_n=0.8187*e^{-0.2}≈0.8195, f_{n-1}=-0.8187, f_n=-0.8195; resolva para f_{n+1} implicitamente e encontre y_{n+1}≈0.8025, próximo de e^{-0.4}≈0.8187 wait corrigido para valores precisos.",
                              "finalVerifications": [
                                "Coeficientes AM2: 5/12, 8/12, -1/12 satisfazem as 3 equações.",
                                "Coeficientes AM3: 9/24, 19/24, -5/24, 1/24 satisfazem as 4 equações.",
                                "Frações irredutíveis e somas exatas iguais a 1 para m=0.",
                                "Verificação cruzada com tabelas padrão de métodos multistep.",
                                "Erro local esperado: O(h^4) para AM2, O(h^5) para AM3.",
                                "Capacidade de escrever as fórmulas completas dos métodos."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta do sistema linear com (1-j)^m e 1/(m+1).",
                                "Resolução algébrica precisa sem erros aritméticos em frações.",
                                "Valores finais coincidem exatamente com os coeficientes padrão.",
                                "Verificações explícitas de pelo menos duas condições por método.",
                                "Explicação clara da ligação com o polinômio interpolador de grau k-1.",
                                "Generalização para métodos de ordem superior."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em solvers ODE como ode45 no MATLAB ou solve_ivp no SciPy.",
                                "Física: Integração numérica de equações de movimento em mecânica celeste.",
                                "Engenharia: Simulação de circuitos RLC ou sistemas de controle.",
                                "Química: Modelagem de cinética de reações em reatores.",
                                "Finanças: Resolução de modelos de Black-Scholes estocásticos aproximados."
                              ],
                              "realWorldApplication": "Os métodos AM2 e AM3 são usados em softwares profissionais como MATLAB ode15s, COMSOL e ANSYS para simular dinâmicas complexas em engenharia aeroespacial, previsão climática, farmacocinética e otimização de redes neurais recorrentes, oferecendo alta precisão para EDOs não rígidos com custo computacional moderado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Aplicar o método em um exemplo numérico simples",
                            "description": "Resolver manualmente um passo do método AM2 para o PVI y' = -y, y(0)=1, com h=0.1, assumindo valores iniciais conhecidos e resolvendo a equação implícita linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os valores iniciais conhecidos",
                                  "subSteps": [
                                    "Identifique os pontos iniciais: t₀ = 0, y₀ = 1, f(t₀, y₀) = -y₀ = -1",
                                    "Recupere ou calcule y₁ ≈ 0.9 em t₁ = 0.1 (usando método explícito prévio como Euler)",
                                    "Calcule f(t₁, y₁) = -y₁ = -0.9",
                                    "Anote h = 0.1 e confirme t₂ = 0.2",
                                    "Liste todos os valores em uma tabela para referência visual"
                                  ],
                                  "verification": "Verifique se a tabela contém t₀, y₀, f₀; t₁, y₁, f₁ corretos sem erros aritméticos",
                                  "estimatedTime": "5-7 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificação rápida"
                                  ],
                                  "tips": "Use uma tabela organizada para evitar confusão nos índices (n-1=0, n=1, n+1=2)",
                                  "learningObjective": "Organizar dados iniciais necessários para aplicar o método AM2 de forma precisa",
                                  "commonMistakes": [
                                    "Confundir índices (y_{n-1} vs y_n)",
                                    "Erro no cálculo de f₁ devido a arredondamento precoce"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a equação implícita do método AM2",
                                  "subSteps": [
                                    "Recorde a fórmula AM2: y_{n+1} = y_{n-1} + (h/12) [5 f(t_{n+1}, y_{n+1}) + 8 f(t_n, y_n) - f(t_{n-1}, y_{n-1})]",
                                    "Substitua n=1: y₂ = y₀ + (h/12) [5 f(t₂, y₂) + 8 f(t₁, y₁) - f(t₀, y₀)]",
                                    "Insira f(t₂, y₂) = -y₂ e valores conhecidos: y₂ = 1 + (0.1/12) [5(-y₂) + 8(-0.9) - (-1)]",
                                    "Simplifique termos conhecidos: 8(-0.9) - (-1) = -7.2 + 1 = -6.2",
                                    "Escreva: y₂ = 1 + (0.1/12) [-5 y₂ - 6.2]"
                                  ],
                                  "verification": "Confira se a equação implícita está balanceada e todos os coeficientes numéricos estão corretos",
                                  "estimatedTime": "7-10 minutos",
                                  "materials": [
                                    "Papel com fórmula anotada",
                                    "Calculadora para coeficientes"
                                  ],
                                  "tips": "Expanda todos os termos conhecidos antes de inserir y_{n+1} para reduzir erros",
                                  "learningObjective": "Formular corretamente a equação implícita específica para o problema dado",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em f = -y",
                                    "Erro na fórmula AM2 (confundir com AB2)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a equação implícita linear",
                                  "subSteps": [
                                    "Denotando k = h/12 = 0.1/12 = 1/120 ≈ 0.008333, reescreva: y₂ = 1 + k (-5 y₂ - 6.2)",
                                    "Isole termos com y₂: y₂ + 5k y₂ = 1 - 6.2 k",
                                    "Calcule 5k = 5/120 ≈ 0.041667, então coeficiente esquerdo: 1 + 0.041667 = 1.041667",
                                    "Calcule 6.2 k = 6.2/120 ≈ 0.051667, lado direito: 1 - 0.051667 ≈ 0.948333",
                                    "Resolva y₂ = 0.948333 / 1.041667 ≈ 0.9104 (ou exatamente: multiplique por 120 para 125 y₂ = 113.8, y₂ = 113.8/125 = 0.9104)"
                                  ],
                                  "verification": "Calcule f₂ = -y₂ ≈ -0.9104 e substitua na fórmula original para confirmar y₂ ≈ y₂ (erro < 10^{-4})",
                                  "estimatedTime": "10-12 minutos",
                                  "materials": [
                                    "Calculadora com precisão decimal",
                                    "Papel para álgebra"
                                  ],
                                  "tips": "Prefira frações exatas (h=1/10) para evitar erros de arredondamento; use multiplicação por 120",
                                  "learningObjective": "Resolver equações lineares implícitas geradas por métodos numéricos de forma algébrica e numérica",
                                  "commonMistakes": [
                                    "Arredondar cedo demais",
                                    "Sinal errado ao isolar y_{n+1}",
                                    "Confundir multiplicação por h/12"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o resultado e registrar o passo completo",
                                  "subSteps": [
                                    "Calcule f₂ = -0.9104 e t₂ = 0.2",
                                    "Compare com solução exata aproximada y(0.2) = e^{-0.2} ≈ 0.8187 (notar propagação de erro de y₁)",
                                    "Atualize a tabela com t₂, y₂, f₂",
                                    "Discuta precisão: AM2 melhora estabilidade para problemas rígidos",
                                    "Prepare para próximo passo se necessário"
                                  ],
                                  "verification": "Tabela completa sem inconsistências e verificação de substituição na fórmula original converge",
                                  "estimatedTime": "5-8 minutos",
                                  "materials": [
                                    "Tabela anterior",
                                    "Calculadora ou tabela de e^x"
                                  ],
                                  "tips": "Sempre verifique por substituição reversa para detectar erros propagados",
                                  "learningObjective": "Validar a aplicação do método e entender limitações numéricas",
                                  "commonMistakes": [
                                    "Ignorar verificação final",
                                    "Não notar impacto de y₁ aproximado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1, com y₀=1, f₀=-1; y₁=0.9, f₁=-0.9. Aplicando AM2: y₂ = 1 + (0.1/12)[-5 y₂ -6.2]. Resolvendo: y₂ (1 + 5/120) = 1 - 6.2/120 → y₂ (125/120) = (120 - 6.2)/120 → 125 y₂ = 113.8 → y₂ = 0.9104, f₂ ≈ -0.9104.",
                              "finalVerifications": [
                                "Equação implícita formulada corretamente com todos os termos",
                                "Solução algébrica e numérica precisa (y₂ ≈ 0.9104)",
                                "Verificação por substituição reversa converge dentro de tolerância 10^{-4}",
                                "Tabela de valores (t, y, f) completa e consistente",
                                "Discussão breve sobre precisão vs. solução exata",
                                "Preparação para iterações subsequentes identificada"
                              ],
                              "assessmentCriteria": [
                                "Correção na preparação de dados iniciais (20%)",
                                "Precisão na formulação da equação implícita (25%)",
                                "Exatidão na resolução linear e cálculos numéricos (30%)",
                                "Qualidade da verificação e análise de resultados (15%)",
                                "Clareza na documentação e tabela final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementar AM2 em Python com solvers como SciPy para automação",
                                "Física: Modelar decaimento exponencial em radioatividade ou resfriamento Newtoniano",
                                "Engenharia: Simulações de circuitos RC ou sistemas de controle lineares",
                                "Estatística: Aproximações em processos markovianos ou simulações Monte Carlo"
                              ],
                              "realWorldApplication": "Métodos como AM2 são essenciais em softwares de simulação (MATLAB, COMSOL) para resolver EDOs em engenharia química (reatores), finanças (modelos Black-Scholes discretos), biologia (dinâmica populacional) e meteorologia (modelos de previsão numérica), onde estabilidade para problemas rígidos é crítica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Solução de Equações Não Lineares nos Passos Implícitos",
                        "description": "Técnicas para resolver a equação não linear em y_{n+1} decorrente da natureza implícita dos métodos Adams-Moulton.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Implementar o método de Newton para equações implícitas",
                            "description": "Formular o sistema F(y_{n+1}) = y_{n+1} - y_n - h β_0 f(t_{n+1}, y_{n+1}) - h Σ_{j=1}^k β_j f(t_{n+1-j}, y_{n+1-j}) = 0 e aplicar iterações de Newton com Jacobiana aproximada por β_0 h f_y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a equação não linear F(y_{n+1}) = 0",
                                  "subSteps": [
                                    "Identifique os coeficientes β_j do método implícito de Adams-Moulton de ordem k.",
                                    "Calcule os termos conhecidos: y_n e a soma h Σ_{j=1}^k β_j f(t_{n+1-j}, y_{n+1-j}).",
                                    "Escreva explicitamente F(y_{n+1}) = y_{n+1} - y_n - h β_0 f(t_{n+1}, y_{n+1}) - h Σ_{j=1}^k β_j f(t_{n+1-j}, y_{n+1-j}).",
                                    "Verifique se f(t_{n+1}, y_{n+1}) é a derivada do problema de valor inicial.",
                                    "Defina uma tolerância ε para convergência, tipicamente 10^{-6}."
                                  ],
                                  "verification": "Confirme que F(y) resulta em uma equação escalar (ou vetorial) bem definida e que os termos conhecidos estão corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de código (Python/MATLAB)",
                                    "Valores iniciais y_0 a y_n e função f definidas"
                                  ],
                                  "tips": "Anote todos os valores numéricos conhecidos em uma tabela para evitar erros de cálculo.",
                                  "learningObjective": "Compreender a origem da equação implícita nos métodos multistep.",
                                  "commonMistakes": [
                                    "Confundir índices de j (começa em 1 para soma)",
                                    "Esquecer o fator h nos termos",
                                    "Usar β errados do método"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a iteração de Newton e aproximar a Jacobiana",
                                  "subSteps": [
                                    "Escolha o chute inicial y^{(0)}_{n+1}, tipicamente y_n ou extrapolação explícita.",
                                    "Aproxime a Jacobiana J ≈ h β_0 ∂f/∂y (t_{n+1}, y^{(m)}). Para escalar, J é um número.",
                                    "Se vetorial, use diferenças finitas ou analítica para ∂f/∂y.",
                                    "Calcule o primeiro resíduo F(y^{(0)}).",
                                    "Prepare estrutura para armazenar iterações (lista ou array)."
                                  ],
                                  "verification": "Verifique se J é positiva e próxima do valor esperado; compute F(y^{(0)}) ≠ 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software numérico",
                                    "Definição analítica de f_y se possível"
                                  ],
                                  "tips": "Para problemas escalares, J é simples; teste com valor pequeno para evitar divisão por zero.",
                                  "learningObjective": "Dominar a linearização simplificada para eficiência computacional.",
                                  "commonMistakes": [
                                    "Usar Jacobiana exata em vez da aproximada",
                                    "Chute inicial ruim levando a não-convergência",
                                    "Erro no sinal da Jacobiana"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar as iterações de Newton até convergência",
                                  "subSteps": [
                                    "Para m = 0, 1, ...: Compute F(y^{(m)}).",
                                    "Resolva J δ = -F(y^{(m)}), onde δ = y^{(m+1)} - y^{(m)} (escalar: δ = -F/J).",
                                    "Atualize y^{(m+1)} = y^{(m)} + δ.",
                                    "Verifique ||δ|| < ε ou ||F(y^{(m+1)})|| < ε; se sim, pare.",
                                    "Registre número de iterações e valores para análise."
                                  ],
                                  "verification": "O loop para com ||F|| ou ||δ|| abaixo de ε em no máximo 10-20 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Loop em pseudocódigo ou Python: while abs(delta) > eps:",
                                    "Valores de passos anteriores"
                                  ],
                                  "tips": "Monitore ||F|| decrescendo quadraticamente; se não, ajuste chute inicial.",
                                  "learningObjective": "Implementar o algoritmo iterativo com critério de parada robusto.",
                                  "commonMistakes": [
                                    "Loop infinito por ε muito pequeno",
                                    "Erro de arredondamento em J pequena",
                                    "Atualização errada: usar +F em vez de -F"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a solução e preparar para próximo passo",
                                  "subSteps": [
                                    "Atribua y_{n+1} = y^{(final)}.",
                                    "Compute erro estimado comparando com solução exata se disponível.",
                                    "Atualize histórico: adicione f(t_{n+1}, y_{n+1}) para próximos passos.",
                                    "Analise número de iterações vs. ordem do método.",
                                    "Documente o código ou cálculos para reutilização."
                                  ],
                                  "verification": "y_{n+1} satisfaz F(y_{n+1}) ≈ 0 dentro de ε; erro global consistente com ordem do método.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Solução referencial ou método explícito para comparação",
                                    "Gráfico de erro vs. h"
                                  ],
                                  "tips": "Salve iterações em array para plotar convergência.",
                                  "learningObjective": "Garantir robustez e precisão na implementação numérica.",
                                  "commonMistakes": [
                                    "Não atualizar histórico corretamente",
                                    "Ignorar divergência em passos iniciais",
                                    "Esquecer normalização em problemas vetoriais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1, Adams-Moulton ordem 1 (β_0=2/3, β_1=-1/3), em n=1 com y_0=1, y_1≈0.9048 (explícito). Formule F(y_2)=y_2 - y_1 -0.1*(2/3 f(0.2,y_2) +1/3 f(0.1,y_1))=0. Chute y^{(0)}=y_1, J≈0.1*(2/3)*1=0.0667. Iterações: converge em 3 passos para y_2≈0.8187.",
                              "finalVerifications": [
                                "F(y_{n+1}) < 10^{-10} numericamente.",
                                "Número de iterações ≤ 10 por passo.",
                                "Solução y_{n+1} consistente com ordem esperada do método.",
                                "Jacobiana aproximada positiva e estável.",
                                "Histórico atualizado corretamente para passo seguinte.",
                                "Convergência quadrática observada nas últimas iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro local O(h^{k+1}).",
                                "Eficiência: <5 iterações médias por passo.",
                                "Robustez: Convergência para h razoáveis (0.01-0.1).",
                                "Correção da formulação F e J.",
                                "Implementação limpa e comentada.",
                                "Análise de sensibilidade a chute inicial."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para solvers ODE.",
                                "Física: Simulação de osciladores ou difusão com EDOs implícitas.",
                                "Engenharia Computacional: Otimização em métodos BDF.",
                                "Análise: Teorema de convergência de Newton.",
                                "Estatística: Erro e variância em simulações estocásticas."
                              ],
                              "realWorldApplication": "Usado em solvers como ODE15s no MATLAB ou SciPy para EDOs rígidos em modelagem climática, circuitos elétricos e farmacocinética, onde métodos implícitos garantem estabilidade para h maiores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Utilizar predictor-corrector com Adams-Bashforth",
                            "description": "Combinar o método explícito Adams-Bashforth como preditor para fornecer chute inicial ao corretor Adams-Moulton, realizando 1 ou mais correções para convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema e os métodos predictor-corrector",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial (PVI): y' = f(t,y), y(t0)=y0.",
                                    "Escolha a ordem k dos métodos Adams-Bashforth (AB_k) e Adams-Moulton (AM_k), tipicamente k=2 ou 3.",
                                    "Calcule os valores iniciais y0, y1, ..., y_{n-1} usando métodos de Runge-Kutta ou similar.",
                                    "Defina o passo h e escreva as fórmulas explícitas para AB_k e AM_k.",
                                    "Prepare uma tabela para armazenar predições e correções."
                                  ],
                                  "verification": "Tabela inicial preenchida corretamente com valores y0 a y_{n-1} e fórmulas anotadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora científica ou software como Python/MATLAB.",
                                  "tips": "Comece com ordem baixa (k=2) para depuração antes de ordens maiores.",
                                  "learningObjective": "Compreender a configuração prévia necessária para o predictor-corrector.",
                                  "commonMistakes": "Escolher ordem incompatível com número de pontos iniciais disponíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o preditor Adams-Bashforth para chute inicial",
                                  "subSteps": [
                                    "Calcule os coeficientes de AB_k: para k=2, y_n^p = y_{n-1} + (h/2)(3f_{n-1} - f_{n-2}).",
                                    "Avalie f(t_n, y_n^p) para obter o preditor completo.",
                                    "Registre y_n^p na tabela.",
                                    "Verifique consistência com passos anteriores.",
                                    "Repita para o próximo passo se necessário."
                                  ],
                                  "verification": "Predição y_n^p calculada e bate com solução exata aproximada dentro de 1% de erro local.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de valores iniciais, fórmula AB anotada.",
                                  "tips": "Use polinômio interpolador para derivar coeficientes se necessário.",
                                  "learningObjective": "Implementar corretamente o método explícito Adams-Bashforth como preditor.",
                                  "commonMistakes": "Inverter coeficientes de AB (ex: usar peso errado para f_{n-1})."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o corretor Adams-Moulton com chute inicial",
                                  "subSteps": [
                                    "Escreva a fórmula AM_k usando y_n^p: para k=2, y_n^{(1)} = y_{n-1} + (h/12)(5f_n^p + 8f_{n-1} - f_{n-2}).",
                                    "Avalie f(t_n, y_n^{(1)}) para a primeira correção.",
                                    "Atualize a tabela com y_n^{(1)}.",
                                    "Compare com preditor para estimar erro inicial.",
                                    "Decida número de iterações (geralmente 1-3)."
                                  ],
                                  "verification": "Primeira correção y_n^{(1)} diverge menos de 0.5% do preditor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela atualizada, calculadora para avaliações de f.",
                                  "tips": "AM_2 tem bom equilíbrio de estabilidade; teste com f linear primeiro.",
                                  "learningObjective": "Usar predição como chute no método implícito Adams-Moulton.",
                                  "commonMistakes": "Esquecer de usar f_n no lado direito da equação implícita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar iterações de correção até convergência",
                                  "subSteps": [
                                    "Para iteração m>=2: y_n^{(m)} = y_{n-1} + (h/12)(5f(t_n, y_n^{(m-1)}) + 8f_{n-1} - f_{n-2}).",
                                    "Calcule |y_n^{(m)} - y_n^{(m-1)}| < tolerância (ex: 10^{-6}).",
                                    "Atualize tabela iterativamente.",
                                    "Pare após 1-3 iterações ou convergência.",
                                    "Aceite y_n final como y_n^{(último)}."
                                  ],
                                  "verification": "Diferença entre iterações sucessivas < ε especificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Loop iterativo em software ou cálculos manuais.",
                                  "tips": "Use critério de convergência relativo para robustez.",
                                  "learningObjective": "Iterar predictor-corrector para alta precisão e convergência.",
                                  "commonMistakes": "Não parar iterações, levando a divergência numérica."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar precisão global e documentar o processo",
                                  "subSteps": [
                                    "Compare solução numérica com solução exata em pontos selecionados.",
                                    "Calcule erro global: max |y_num - y_exata|.",
                                    "Analise ordem de convergência reduzindo h.",
                                    "Documente tabela final e número de iterações por passo.",
                                    "Resuma vantagens do predictor-corrector vs métodos simples."
                                  ],
                                  "verification": "Erro global < 10^{-4} e documentação completa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Solução exata (se disponível), gráfico de erro.",
                                  "tips": "Plote y vs t para visualização intuitiva.",
                                  "learningObjective": "Avaliar eficácia do método predictor-corrector.",
                                  "commonMistakes": "Ignorar acúmulo de erro de truncamento em passos longos."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y + t, y(0)=1 (solução exata y=t-1+e^{-2t}) usando predictor-corrector ordem 2 (AB2-AM2), h=0.1, de t=0 a t=1. Calcule y(0.4) com 2 iterações por passo; resultado esperado ~0.0498 após convergência.",
                              "finalVerifications": [
                                "Predições AB coincidem com valores iniciais RK4 dentro de 0.1%.",
                                "Correções AM convergem em <=3 iterações por passo.",
                                "Erro global no intervalo < 5e-5.",
                                "Tabela completa com preditores, corretores e finais.",
                                "Gráfico mostra estabilidade sem oscilações.",
                                "Ordem de precisão observada ~2."
                              ],
                              "assessmentCriteria": [
                                "Fórmulas AB e AM implementadas corretamente (100% coeficientes exatos).",
                                "Critério de convergência aplicado rigorosamente.",
                                "Erros comuns evitados (ex: índices corretos em f_{n-j}).",
                                "Documentação clara com tabela e análise de erro.",
                                "Explicação verbal da iteração predictor-corrector.",
                                "Adaptação a h diferente sem erros proporcionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com NumPy/SciPy para automação.",
                                "Física: Modelagem de sistemas dinâmicos como circuitos RLC.",
                                "Engenharia: Simulações de controle em aerodinâmica.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou trajetórias orbitais (NASA), onde predictor-corrector (PECE) permite alta precisão sem resolver sistemas não-lineares caros a cada passo, economizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Avaliar convergência da iteração implícita",
                            "description": "Analisar critérios de parada baseados em ||y^{(m+1)} - y^{(m)}|| < ε e discutir o custo computacional por passo em comparação com métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação da iteração implícita em métodos de Adams-Moulton",
                                  "subSteps": [
                                    "Revise a equação implícita geral do método de Adams-Moulton: y_{n+1} = y_n + h ∑ β_j f(t_{n+1-j}, y_{n+1-j}) + h β_0 f(t_{n+1}, y_{n+1}).",
                                    "Identifique a dependência não linear em y_{n+1} no termo β_0 f(t_{n+1}, y_{n+1}).",
                                    "Defina a iteração de ponto fixo: y^{(m+1)} = g(y^{(m)}), onde g incorpora os termos conhecidos e o implícito.",
                                    "Escolha um chute inicial y^{(0)}, tipicamente y_n ou extrapolação explícita.",
                                    "Implemente uma iteração simples manualmente para um exemplo básico."
                                  ],
                                  "verification": "Construa a função g(y) para um método específico (ex: AM2) e compute 2 iterações manualmente, confirmando que y^{(m+1)} difere de y^{(m)} inicialmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (cap. métodos multipasso), caderno, calculadora ou Python/Jupyter para protótipo.",
                                  "tips": "Sempre normalize os passos de tempo h para evitar escalas numéricas ruins.",
                                  "learningObjective": "Formular a iteração implícita como problema de ponto fixo.",
                                  "commonMistakes": "Confundir termos explícitos com implícitos; usar y_n como chute sem ajuste."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar critérios de parada baseados na norma de diferença",
                                  "subSteps": [
                                    "Defina o critério: pare quando ||y^{(m+1)} - y^{(m)}|| < ε, com norma euclidiana ou máxima.",
                                    "Escolha ε típico (ex: 10^{-6} para precisão dupla).",
                                    "Compute a norma passo a passo em uma iteração simulada.",
                                    "Discuta tolerâncias adaptativas baseadas em h ou ordem do método.",
                                    "Teste sensibilidade: varie ε e observe número de iterações."
                                  ],
                                  "verification": "Para um exemplo, registre iterações até ||Δy|| < 10^{-8} e confirme parada em <10 iterações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (MATLAB/Python com NumPy/SciPy), planilha Excel para normas.",
                                  "tips": "Use norma infinita para vetores multi-dimensionais em problemas reais.",
                                  "learningObjective": "Aplicar e justificar critérios de convergência prática.",
                                  "commonMistakes": "Usar norma absoluta sem considerar escala da solução; ignorar ε relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar condições teóricas de convergência",
                                  "subSteps": [
                                    "Lembre o Teorema do Ponto Fixo de Banach: |g'(y)| < 1 no intervalo.",
                                    "Estime Lipschitz de f para derivar ||g(y1) - g(y2)|| ≤ K ||y1 - y2|| com K<1.",
                                    "Analise dependência em h: para h pequeno, K ≈ |β_0 h L| <1, onde L é Lipschitz de f.",
                                    "Discuta aceleração com método de Newton vs. iteração simples.",
                                    "Prove convergência quadrática para Newton em casos locais."
                                  ],
                                  "verification": "Derive K para f(y)= -y (L=1) e AM2 (β_0=9/24), mostrando K<1 para h< apropriado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula sobre teoremas de ponto fixo, papel para derivadas.",
                                  "tips": "Linearize f ao redor de y_n para estimar K rapidamente.",
                                  "learningObjective": "Estabelecer garantias teóricas para convergência.",
                                  "commonMistakes": "Esquecer fator h em K; assumir convergência global sem Lipschitz."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar custo computacional com métodos explícitos",
                                  "subSteps": [
                                    "Conte flops por passo explícito: O(k) avaliações de f, k=ordem.",
                                    "Para implícito: O(M k) com M iterações por passo, cada com O(k) f.",
                                    "Estime M médio: 3-5 para iteração simples, 2-3 para Newton.",
                                    "Compare total: implícito ~5x mais caro por passo, mas permite passos maiores (ordens altas).",
                                    "Discuta trade-off em estabilidade vs. eficiência."
                                  ],
                                  "verification": "Tabela comparativa: flops explícito vs. implícito para k=4, M=4, simulando 100 passos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Profiler em Python (timeit), tabela de coeficientes Adams.",
                                  "tips": "Meça tempo real em código para validação empírica.",
                                  "learningObjective": "Quantificar overhead computacional e justificar uso.",
                                  "commonMistakes": "Ignorar custo de Jacobiana em Newton; superestimar M sem testes."
                                }
                              ],
                              "practicalExample": "Resolva y' = y(1-y), y(0)=0.5 (equação logística) com AM2 implícito em t=1, h=0.1. Chute y^{(0)}=y_n + h f(t_n,y_n). Itere até ||y^{(m+1)}-y^{(m)}||_2 < 10^{-10}: tipicamente 4 iterações, custo ~20 f vs. 2 em explícito.",
                              "finalVerifications": [
                                "Define corretamente o critério ||y^{(m+1)} - y^{(m)}|| < ε.",
                                "Estima K Lipschitz para g(y) e verifica K<1.",
                                "Compara flops: implícito requer M vezes mais f que explícito.",
                                "Identifica h máximo para convergência em exemplo dado.",
                                "Explica por que Newton reduz M em problemas não-lineares fortes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do critério de parada (90% correto).",
                                "Correta aplicação do teorema de Banach com K<1 (com prova).",
                                "Análise quantitativa de custo: erro <20% em estimativa de flops.",
                                "Integração de teoria e prática em exemplo numérico.",
                                "Discussão equilibrada de trade-offs explícito vs. implícito.",
                                "Clareza em gráficos/tabelas de convergência."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar solvers em Python/SciPy.",
                                "Análise de Algoritmos: Complexidade O(M k) por passo.",
                                "Física Computacional: Estabilidade em simulações de EDOs rígidas."
                              ],
                              "realWorldApplication": "Em modelagem climática ou dinâmica molecular (ex: solvers em GROMACS), onde métodos implícitos garantem estabilidade para h maiores, apesar do custo por iteração, otimizando simulações longas em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Propriedades e Aplicações em Problemas Stiff",
                        "description": "Análise de estabilidade, ordem e adequação dos métodos Adams-Moulton para problemas stiff, relacionando com controle de passo e estabilidade A.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Analisar a ordem de precisão e estabilidade linear",
                            "description": "Verificar a ordem de truncamento local O(h^{k+1}) para k passos e analisar a estabilidade no teste de Dahlquist com fator de amplificação via polinômio característico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula do método implícito de Adams-Moulton e derivar o erro de truncamento local",
                                  "subSteps": [
                                    "Relembrar a interpolação de Newton para trás aplicada à integral do método.",
                                    "Expandir a solução exata y(t_{n+1}) em série de Taylor ao redor de t_n.",
                                    "Derivar o polinômio de interpolação de k pontos anteriores e subtrair da expansão exata.",
                                    "Identificar os termos residuais que levam ao erro local O(h^{k+1}).",
                                    "Simplificar a expressão para obter a constante de erro e a ordem de truncamento."
                                  ],
                                  "verification": "Comparar a derivação obtida com a fórmula padrão do livro-texto, confirmando o termo principal O(h^{k+1}).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno para derivações, calculadora simbólica (Mathematica ou papel).",
                                  "tips": "Use a notação de diferenças finitas divididas para agilizar a derivação do polinômio de interpolação.",
                                  "learningObjective": "Compreender a origem matemática do erro local no método de Adams-Moulton.",
                                  "commonMistakes": "Confundir a expansão em t_n com t_{n+1}; ignorar o fator h na integral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a ordem de precisão O(h^{k+1}) para métodos de k passos",
                                  "subSteps": [
                                    "Escolher um método específico (ex: k=2, Adams-Moulton de 2 passos).",
                                    "Implementar numericamente o método em um problema modelo y' = f(y), y(0)=y0.",
                                    "Resolver com tamanhos de passo h, h/2, h/4 e calcular erros locais via solução exata.",
                                    "Computar a razão dos erros log(|e(h/2)| / log(|e(h)|)) para confirmar ordem k+1.",
                                    "Generalizar para k arbitrário analisando o polinômio de interpolação."
                                  ],
                                  "verification": "Tabela de erros mostrando convergência com razão aproximada k+1 (ex: 3 para k=2).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MATLAB/Python (SciPy odeint para exata), planilha para tabelas de erros.",
                                  "tips": "Use problema simples como y' = -y para solução exata conhecida e testar precisão.",
                                  "learningObjective": "Validar teoricamente e numericamente a ordem de truncamento local.",
                                  "commonMistakes": "Não subtrair corretamente o valor predito para obter erro local; usar norma global em vez de local."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar o teste de Dahlquist para estabilidade linear",
                                  "subSteps": [
                                    "Considerar o problema teste y' = λy com Re(λ)<0 (problema stiff).",
                                    "Linearizar o método multistep: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Aplicar à equação teste: obter a relação de recorrência y_{n+1} = ∑ ρ(θ) y_{n-j} + hλ ∑ σ(θ) y_{n-j}, onde θ = hλ.",
                                    "Identificar os polinômios ρ(z) (característico) e σ(z) (parasita) do método.",
                                    "Plotar a região de estabilidade absoluta no plano complexo θ."
                                  ],
                                  "verification": "Diagrama da região de estabilidade mostrando se |ρ(θ)/ρ(0)| ≤1 para θ no semiplano esquerdo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel milimetrado ou software de plotagem (MATLAB contour), tabelas de coeficientes de Adams-Moulton.",
                                  "tips": "Memorize coeficientes padrão para k=1 a 4; foque em A-stabilidade para métodos implícitos.",
                                  "learningObjective": "Entender o framework de estabilidade linear para métodos multistep.",
                                  "commonMistakes": "Confundir polinômios ρ e σ; esquecer normalização ρ(1)=0, σ'(1)=1 para consistência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o fator de amplificação via polinômio característico",
                                  "subSteps": [
                                    "Calcular explicitamente ρ(θ) e σ(θ) para um método Adams-Moulton específico (ex: k=2).",
                                    "Computar o fator de amplificação |ρ(θ)/(1 - θ σ(θ)/ρ(θ))| ou raiz da equação característica.",
                                    "Analisar para θ real negativo: verificar se módulo <1 para estabilidade.",
                                    "Comparar com métodos explícitos (ex: Adams-Bashforth) destacando vantagens em stiff.",
                                    "Interpretar resultados para problemas stiff (λ com |λ| grande)."
                                  ],
                                  "verification": "Gráfico do fator de amplificação vs. θ mostrando estabilidade para Re(θ)<0.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software simbólico (SymPy/Python), gráficos em MATLAB ou Python (matplotlib).",
                                  "tips": "Para métodos implícitos, resolva o polinômio característico det(ρ - ζ σ) =0 e verifique raízes dentro do círculo unitário.",
                                  "learningObjective": "Avaliar a estabilidade linear quantitativamente para aplicações stiff.",
                                  "commonMistakes": "Não considerar o denominador implícito no fator; analisar só ρ(θ) sem σ(θ)."
                                }
                              ],
                              "practicalExample": "Para o método Adams-Moulton de 2 passos: y_{n+1} = y_n + (h/12)(5f_{n+1} + 8f_n - f_{n-1}). Calcule erro local via Taylor: confirme O(h^3). No teste Dahlquist com λ=-50, compute ρ(θ)= (1 + θ/2)^2 - (θ/2)^2 ≈1 para θ=hλ pequeno, e verifique |raízes| <1 para estabilidade em stiff.",
                              "finalVerifications": [
                                "Derivação correta do erro O(h^{k+1}) com termo principal explícito.",
                                "Tabela numérica confirmando ordem k+1 via halving de h.",
                                "Polinômios ρ(z) e σ(z) corretos para método dado.",
                                "Gráfico de região de estabilidade A-estável para implícitos.",
                                "Análise do fator de amplificação <1 para θ=-10 (stiff).",
                                "Comparação com método explícito mostrando divergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica do erro de truncamento (90% dos passos corretos).",
                                "Convergência numérica demonstrada com razão de erro ≥ k+0.9.",
                                "Identificação correta de ρ(z) e σ(z) sem erros aritméticos.",
                                "Interpretação qualitativa e quantitativa da estabilidade (A-stabilidade confirmada).",
                                "Aplicação coerente a contexto stiff com exemplos numéricos.",
                                "Clareza em gráficos e tabelas de verificação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em EDOs de osciladores amortecidos (problemas stiff).",
                                "Computação: Implementação de solvers ODE em Python/SciPy com análise de erro.",
                                "Engenharia Química: Simulações de reações stiff em reatores.",
                                "Estatística: Análise de erros numéricos em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de circuitos RLC stiff (alta razão L/C), onde métodos explícitos divergem, Adams-Moulton implícito mantém estabilidade para passos grandes, permitindo simulações eficientes em software como SPICE para design eletrônico."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Comparar com métodos explícitos em problemas stiff",
                            "description": "Explicar por que métodos implícitos como Adams-Moulton são preferíveis para problemas stiff devido à propriedade A-estável em variantes de ordem alta, contrastando com instabilidade de métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição e características de problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs com escalas de tempo muito díspares (eigenvalues com partes reais negativas grandes em módulo).",
                                    "Estude exemplos clássicos, como y' = -λ(y - g(t)) com λ >> 1.",
                                    "Analise o comportamento analítico: soluções rápidas transitórias e lentas estacionárias.",
                                    "Discuta o desafio numérico: necessidade de h << 1/λ para estabilidade.",
                                    "Identifique indicadores de stiffnes, como razão de eigenvalues."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique stiffnes em um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software MATLAB ou Python (SciPy).",
                                  "tips": "Use gráficos de componentes de solução para visualizar escalas díspares.",
                                  "learningObjective": "Compreender conceitualmente por que problemas stiff desafiam métodos numéricos padrão.",
                                  "commonMistakes": "Confundir stiff com nonlinear; ignorar o papel das escalas de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o comportamento de métodos explícitos em problemas stiff",
                                  "subSteps": [
                                    "Revise métodos explícitos de Adams-Bashforth (ordens 2-4).",
                                    "Implemente numéricamente em um problema stiff (ex: y' = -1000y + sin(t)).",
                                    "Observe instabilidade: oscilações ou blow-up para h moderado.",
                                    "Analise região de estabilidade absoluta: limitada no semiplano esquerdo.",
                                    "Calcule passos h necessários para estabilidade (h < 2/λ_max)."
                                  ],
                                  "verification": "Execute simulação e mostre gráfico de solução instável vs. h.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com odeint ou MATLAB ode45, problema teste stiff.",
                                  "tips": "Varie h sistematicamente e plote erro vs. h em escala log.",
                                  "learningObjective": "Demonstrar numericamente a instabilidade de métodos explícitos em stiff problems.",
                                  "commonMistakes": "Usar h fixo muito pequeno sem testar limites de instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar propriedades de métodos implícitos como Adams-Moulton",
                                  "subSteps": [
                                    "Revise fórmulas de Adams-Moulton (implícitos multistep).",
                                    "Implemente com solver implícito (ex: Python solve_ivp(method='BDF')).",
                                    "Verifique A-estabilidade para variantes de ordem alta (região inclui todo semiplano esquerdo).",
                                    "Simule o mesmo problema stiff com h maior que em explícitos.",
                                    "Compare precisão e eficiência computacional."
                                  ],
                                  "verification": "Mostre solução estável com h 10x maior que explícito.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB para Adams-Moulton, gráficos de estabilidade.",
                                  "tips": "Use método de Newton para resolver equações não-lineares nos passos implícitos.",
                                  "learningObjective": "Entender como A-estabilidade permite passos maiores em stiff problems.",
                                  "commonMistakes": "Ignorar custo computacional extra dos solves implícitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar quantitativamente explícitos vs. implícitos em métricas chave",
                                  "subSteps": [
                                    "Meça tempo de CPU, número de passos e erro global para ambos métodos.",
                                    "Crie tabela: h_max_estável, custo por unidade tempo, precisão.",
                                    "Discuta trade-offs: explícitos mais baratos por passo, mas ineficientes em stiff.",
                                    "Analise para ordens altas: A-estabilidade persiste em Moulton, não em Bashforth.",
                                    "Conclua preferência por implícitos em stiff."
                                  ],
                                  "verification": "Produza tabela comparativa e gráfico de eficiência (erro vs. tempo).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Jupyter notebook para métricas.",
                                  "tips": "Normalize por intervalo de integração para comparações justas.",
                                  "learningObjective": "Realizar comparação rigorosa baseada em evidências numéricas.",
                                  "commonMistakes": "Comparar sem controlar erro alvo; focar só em estabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar razões de preferência e limitações",
                                  "subSteps": [
                                    "Resuma: instabilidade explícita vs. A-estabilidade implícita.",
                                    "Discuta limitações: custo implícito em não-stiff; ordem reduzida em alguns solvers.",
                                    "Explore variantes L-stable (ex: BDF) para damping em stiff.",
                                    "Prepare argumentos para escolha de método baseado em diagnóstico de stiffnes.",
                                    "Teste em problema real-world stiff."
                                  ],
                                  "verification": "Escreva parágrafo explicando quando usar cada método.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas anteriores, artigo sobre stiff ODEs.",
                                  "tips": "Use fluxograma: teste stiffnes → implícito se sim.",
                                  "learningObjective": "Aplicar comparação para decisões práticas em análise numérica.",
                                  "commonMistakes": "Generalizar implícitos como sempre melhores; ignorar híbridos."
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = -1000(y - (1 + sin(t))) com y(0)=1. Métodos explícitos como Adams-Bashforth de ordem 4 divergem para h=0.01 (blow-up), enquanto Adams-Moulton de ordem 4 permanece estável com h=0.1, capturando a solução lenta y≈1+sin(t) com erro <1e-3 após t=10.",
                              "finalVerifications": [
                                "Explicar corretamente A-estabilidade e sua relevância para stiff.",
                                "Identificar instabilidade em simulação explícita com h inadequado.",
                                "Mostrar solução estável implícita com h maior.",
                                "Comparar eficiência (tempo/erro) quantitativamente.",
                                "Discutir critérios para detectar stiffnes.",
                                "Propor método apropriado para novo problema stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição de stiff e A-estabilidade (30%)",
                                "Análise numérica: simulações corretas e gráficos claros (25%)",
                                "Comparação quantitativa: tabelas/métricas robustas (20%)",
                                "Raciocínio: trade-offs e conclusões lógicas (15%)",
                                "Clareza: explicação escrita e visual (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC stiff ou reações químicas.",
                                "Computação: Implementação eficiente de solvers ODE em SciPy/MATLAB.",
                                "Engenharia: Simulações dinâmicas em controle de sistemas stiff.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Em simulações de redes elétricas (circuitos com capacitores/diodos stiff), métodos implícitos como Adams-Moulton permitem simular transientes rápidos sem passos minúsculos, reduzindo tempo de computação em software como SPICE de horas para minutos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Implementar controle de passo adaptativo",
                            "description": "Incorporar estimativa de erro local via diferença entre preditor e corretor para ajustar h dinamicamente, garantindo tolerância prescrita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Estimativa de Erro Local via Preditor-Corretor",
                                  "subSteps": [
                                    "Revise os métodos preditor (Adams-Bashforth explícito) e corretor (Adams-Moulton implícito).",
                                    "Calcule manualmente a predição ŷ_{n+1} usando o preditor e a correção y_{n+1} usando o corretor.",
                                    "Defina a estimativa de erro local como |y_{n+1} - ŷ_{n+1}| / tolerância prescrita.",
                                    "Analise como essa diferença aproxima o erro de truncamento local.",
                                    "Discuta o fator de escala para erros globais (aprox. erro local / h)."
                                  ],
                                  "verification": "Escreva fórmulas matemáticas para preditor, corretor e erro estimado em um notebook ou papel.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter com NumPy, papel e lápis, documentação de métodos multistep.",
                                  "tips": "Comece com ordem baixa (k=2) para visualização simples.",
                                  "learningObjective": "Compreender como a diferença preditor-corretor estima o erro local truncamento.",
                                  "commonMistakes": "Confundir erro local com global; ignorar normalização pela tolerância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Cálculo da Estimativa de Erro no Código",
                                  "subSteps": [
                                    "Defina funções para preditor e corretor em Python.",
                                    "Integre um solver implícito (ex: fixed-point ou Newton simples para corretor).",
                                    "Calcule erro_est = norm(|corretor - preditor|) após cada passo.",
                                    "Compare erro_est com tolerância (tol) usando métrica como max-norm ou RMS.",
                                    "Registre histórico de erros para depuração."
                                  ],
                                  "verification": "Execute um passo único e imprima valores de preditor, corretor e erro_est.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy e SciPy (para solve_ivp como referência), editor de código.",
                                  "tips": "Use np.linalg.norm para cálculo de norma vetorial.",
                                  "learningObjective": "Codificar com precisão a estimativa de erro local em um método multistep.",
                                  "commonMistakes": "Não linearizar corretamente o sistema implícito; usar norma errada (L1 vs L2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Lógica de Ajuste Dinâmico de h",
                                  "subSteps": [
                                    "Defina fator de segurança sf = 0.9 e expoente p = ordem do método.",
                                    "Se erro_est > tol, reduza h_new = h * (tol / erro_est)^{1/p} * sf.",
                                    "Se erro_est < 0.1*tol, aumente h_new = h * (0.1*tol / erro_est)^{1/p} * sf.",
                                    "Implemente rejeição/aceitação: rejeite passo se erro_est > tol e repita com h_new.",
                                    "Limite variações de h (ex: 0.5 < h_new/h < 2.0)."
                                  ],
                                  "verification": "Simule 5 passos e verifique se h varia corretamente baseado em erros simulados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código do passo anterior, testes unitários com pytest.",
                                  "tips": "Adicione logs para rastrear h, erro_est e decisões de aceitação/rejeição.",
                                  "learningObjective": "Implementar algoritmo de controle adaptativo garantindo erro dentro da tolerância.",
                                  "commonMistakes": "Esquecer fator de segurança levando a oscilações; expoente errado (use 1/(k+1) para global)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Controle Adaptativo em um Solver Completo",
                                  "subSteps": [
                                    "Crie loop principal: inicialize y0, h inicial, tol; avance até t_final.",
                                    "Em cada iteração, prediga, corrija, estime erro, ajuste h, aceite/rejeite.",
                                    "Gerencie histórico de passos (k valores anteriores para multistep).",
                                    "Implemente inicialização com método de ordem 1 (Euler) para primeiros passos.",
                                    "Salve solução em array para plotagem."
                                  ],
                                  "verification": "Compare solução numérica com solução exata em gráfico; cheque norma de erro global < tol.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Bibliotecas Matplotlib para plots, SciPy para soluções de referência.",
                                  "tips": "Use deque para histórico eficiente de passos passados.",
                                  "learningObjective": "Construir solver robusto com controle adaptativo para problemas stiff.",
                                  "commonMistakes": "Perda de sincronia no histórico multistep ao rejeitar passos; h inicial muito grande."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar o Controlador Adaptativo",
                                  "subSteps": [
                                    "Teste com problema não-stiff (y'=-y) e stiff (y'=-1000y + sin(t)).",
                                    "Meça eficiência: número de passos vs precisão vs solver fixo.",
                                    "Ajuste parâmetros (sf, limites h) baseado em testes.",
                                    "Analise convergência plotando erro vs h.",
                                    "Documente código com comentários e README."
                                  ],
                                  "verification": "Erro global < tol em múltiplos problemas; eficiência > 2x melhor que h fixo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Problemas de teste pré-definidos, profiler como %timeit.",
                                  "tips": "Use soluções exatas analíticas para validação automática.",
                                  "learningObjective": "Validar e refinar implementação para robustez em cenários reais.",
                                  "commonMistakes": "Testar só em problemas fáceis; ignorar overhead de rejeições frequentes."
                                }
                              ],
                              "practicalExample": "Resolva o problema stiff y' = -1000*(y - sin(t)) + cos(t), y(0)=1, t de 0 a 10, tol=1e-6. Implemente Adams-Moulton ordem 4 com preditor Bashforth. Observe h adaptando de ~0.01 para ~0.1 em regiões não-stiff, mantendo erro < tol.",
                              "finalVerifications": [
                                "Solução converge para exata com norma de erro global < tol.",
                                "Passos são rejeitados/aceitos corretamente baseado em erro_est.",
                                "h varia dinamicamente sem oscilações excessivas.",
                                "Solver lida com inicialização e histórico multistep.",
                                "Eficiência demonstrada vs h fixo em problema stiff.",
                                "Código é modular e bem documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global dentro da tolerância prescrita.",
                                "Eficiência: Menos passos que solver de h fixo equivalente.",
                                "Robustez: Funciona em stiff e não-stiff sem crash.",
                                "Corretude: Estimativa de erro corresponde à diferença preditor-corretor.",
                                "Clareza: Código legível com comentários explicando fórmulas.",
                                "Otimização: Limites em variações de h evitam instabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos e controle de loops adaptativos.",
                                "Física: Simulações de sistemas dinâmicos stiff (ex: reações químicas).",
                                "Engenharia: Modelagem de circuitos elétricos e controle PID.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular (problemas stiff em química computacional), controle de aeronaves (equações diferenciais rígidas), ou modelagem climática, onde ajustes automáticos de h garantem precisão eficiente sem intervenção manual."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Procedimento Predictor-Corrector",
                    "description": "Combinação de métodos explícitos (preditor) e implícitos (corretor) para melhorar precisão e estabilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Método Preditor Explícito",
                        "description": "Métodos explícitos de passo múltiplo, como Adams-Bashforth, utilizados para gerar uma aproximação inicial (predição) do valor da solução no próximo passo de tempo, baseados em valores anteriores da solução e derivadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar fórmulas de preditores de Adams-Bashforth",
                            "description": "Reconhecer e escrever as fórmulas explícitas de Adams-Bashforth de ordens 2 a 4 para o problema de valor inicial y' = f(t,y), t em [a,b], y(a) dado, destacando coeficientes e dependência de passos anteriores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral dos preditores Adams-Bashforth",
                                  "subSteps": [
                                    "Revise o problema de valor inicial (PVI): y' = f(t,y), y(a) dado, com malha uniforme t_n = a + n h.",
                                    "Entenda que métodos multistep lineares explícitos aproximam y_{n+1} como combinação linear de valores anteriores de f: y_{n+1} = y_n + h ∑_{j=0}^k β_j f_{n-j}.",
                                    "Identifique os preditores Adams-Bashforth como métodos explícitos derivados por interpolação de Newton para trás.",
                                    "Note a dependência de k+1 pontos anteriores para ordem k+1."
                                  ],
                                  "verification": "Escreva a forma geral y_{n+1}^P = y_n + h ∑ β_j f(t_{n-j}, y_{n-j}) e explique os coeficientes β_j.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica",
                                    "Papel e caneta",
                                    "Notas de aula sobre métodos multistep"
                                  ],
                                  "tips": "Lembre-se: preditores são explícitos, usam apenas f anteriores; correctores são implícitos.",
                                  "learningObjective": "Reconhecer a estrutura geral dos preditores AB e sua dependência de passos anteriores.",
                                  "commonMistakes": [
                                    "Confundir com correctores Adams-Moulton (implícitos)",
                                    "Esquecer o fator h na soma"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a fórmula do preditor Adams-Bashforth de ordem 2 (AB2)",
                                  "subSteps": [
                                    "Derive ou memorize: interpolação em t_n e t_{n-1}, coeficientes β_0 = 3/2, β_1 = -1/2.",
                                    "Escreva explicitamente: y_{n+1}^P = y_n + h (3/2 f_n - 1/2 f_{n-1}).",
                                    "Verifique consistência: ordem 2 significa erro local O(h^3).",
                                    "Destaque dependência: usa f_n e f_{n-1}."
                                  ],
                                  "verification": "Escreva a fórmula AB2 completa e identifique os dois coeficientes corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de coeficientes AB",
                                    "Calculadora para verificar frações"
                                  ],
                                  "tips": "Coeficientes vêm da integração da polinômio interpolador; 3/2 e -1/2 são fixos para AB2.",
                                  "learningObjective": "Escrever corretamente a fórmula AB2 e destacar seus coeficientes e dependências.",
                                  "commonMistakes": [
                                    "Invertar sinais: usar +1/2 f_{n-1} em vez de -1/2",
                                    "Esquecer y_n inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a fórmula do preditor Adams-Bashforth de ordem 3 (AB3)",
                                  "subSteps": [
                                    "Memorize coeficientes: β_0 = 23/12, β_1 = -16/12, β_2 = 5/12.",
                                    "Escreva: y_{n+1}^P = y_n + h (23/12 f_n - 16/12 f_{n-1} + 5/12 f_{n-2}).",
                                    "Simplifique frações: 23/12 ≈ 1.9167, -4/3, 5/12 ≈ 0.4167.",
                                    "Identifique dependência de três pontos: f_n, f_{n-1}, f_{n-2}.",
                                    "Confirme ordem: erro O(h^4)."
                                  ],
                                  "verification": "Reproduza a fórmula AB3 com frações exatas e liste os três coeficientes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha com fórmulas padrão AB",
                                    "Software como MATLAB para teste numérico opcional"
                                  ],
                                  "tips": "Use denominador comum 12 para facilitar memorização: 23, -16, 5.",
                                  "learningObjective": "Dominar a fórmula AB3, seus coeficientes precisos e dependências.",
                                  "commonMistakes": [
                                    "Erros em frações: e.g., 23/12 como 16/12",
                                    "Confundir ordem com número de termos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar a fórmula do preditor Adams-Bashforth de ordem 4 (AB4) e sintetizar",
                                  "subSteps": [
                                    "Memorize coeficientes: β_0 = 55/24, β_1 = -59/24, β_2 = 37/24, β_3 = -9/24.",
                                    "Escreva: y_{n+1}^P = y_n + h (55/24 f_n - 59/24 f_{n-1} + 37/24 f_{n-2} - 9/24 f_{n-3}).",
                                    "Destaque padrão: coeficientes alternam sinais, crescem em magnitude inicialmente.",
                                    "Compare com AB2 e AB3: mais termos, maior precisão, mas mais instável.",
                                    "Pratique escrita de todas as três fórmulas lado a lado."
                                  ],
                                  "verification": "Escreva AB4 corretamente e compare coeficientes com AB2/AB3 em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa de métodos AB",
                                    "Papel para tabela de coeficientes"
                                  ],
                                  "tips": "Denominador 24: 55, -59, 37, -9; memorize como sequência única.",
                                  "learningObjective": "Escrever AB4 e sintetizar identificação de fórmulas AB2-4 com coeficientes e dependências.",
                                  "commonMistakes": [
                                    "Sinais errados em β_3 (+9/24)",
                                    "Confundir com AB5 que tem mais termos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1, suponha y_0=1, y_1=0.9048 (por Runge-Kutta), f_0=-1, f_1=-0.9048. Compute y_2^P por AB2: y_2^P = 0.9048 + 0.1*(1.5*(-0.9048) - 0.5*(-1)) ≈ 0.8187.",
                              "finalVerifications": [
                                "Escreva corretamente as três fórmulas AB2, AB3, AB4 sem consulta.",
                                "Liste todos os coeficientes β_j para cada ordem com frações exatas.",
                                "Identifique o número de passos anteriores necessários para cada (2,3,4).",
                                "Explique a diferença entre preditor explícito e corrector implícito.",
                                "Aplique AB2 a um PVI simples e verifique consistência numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes (frações exatas, sem erros de sinal).",
                                "Correta identificação de dependências de f_{n-j}.",
                                "Capacidade de escrever fórmulas completas de memória.",
                                "Compreensão da ordem de precisão (O(h^{k+1})).",
                                "Habilidade em comparar fórmulas e destacar padrões.",
                                "Aplicação correta em exemplo numérico simples."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar AB em Python ou MATLAB para simulações.",
                                "Física: Usar em EDOs de movimento orbital ou circuitos RLC.",
                                "Engenharia: Modelagem de sistemas dinâmicos em controle automático.",
                                "Computação Científica: Integração em bibliotecas como SciPy odeint."
                              ],
                              "realWorldApplication": "Preditores Adams-Bashforth são usados em simulações numéricas de previsão meteorológica, trajetórias de mísseis, modelagem financeira de opções e simulações climáticas, onde alta precisão com custo computacional moderado é essencial em procedimentos predictor-corrector."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Calcular predição usando método explícito",
                            "description": "Aplicar o método de Adams-Bashforth de ordem k para prever y_{n+1} a partir de y_n, y_{n-1}, ..., y_{n-k+1} e f avaliada nesses pontos, verificando erro local de truncamento O(h^{k+1}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados iniciais e a fórmula do método Adams-Bashforth",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial: y' = f(t,y), y(t_0)=y_0.",
                                    "Colete os valores conhecidos: y_n, y_{n-1}, ..., y_{n-k+1}, passos h, pontos t_n, t_{n-1}, ..., t_{n-k+1}.",
                                    "Escreva a fórmula explícita: y_{n+1}^p = y_n + h * Σ_{j=1}^k β_j f(t_{n-j+1}, y_{n-j+1}), onde β_j são coeficientes de Adams-Bashforth de ordem k.",
                                    "Verifique a tabela de coeficientes para a ordem k específica (ex: k=2, β1=3/2, β2=-1/2).",
                                    "Confirme o erro local de truncamento O(h^{k+1})."
                                  ],
                                  "verification": "Lista de dados e fórmula anotados corretamente sem erros tipográficos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de coeficientes Adams-Bashforth",
                                    "Calculadora"
                                  ],
                                  "tips": "Memorize coeficientes comuns para ordens baixas (k=1 a 4) para agilizar.",
                                  "learningObjective": "Compreender os componentes necessários para aplicar o preditor explícito.",
                                  "commonMistakes": [
                                    "Confundir ordem k com número de pontos anteriores",
                                    "Esquecer o fator h na soma",
                                    "Usar coeficientes errados de Milne ou outros métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as avaliações da função f nos pontos anteriores",
                                  "subSteps": [
                                    "Compute f(t_n, y_n), f(t_{n-1}, y_{n-1}), ..., f(t_{n-k+1}, y_{n-k+1}).",
                                    "Registre cada f_i com precisão decimal adequada (ex: 4 casas).",
                                    "Verifique consistência das entradas t_i = t_0 + i*h.",
                                    "Anote os valores em uma tabela organizada.",
                                    "Confira cálculos manuais com uma segunda avaliação rápida."
                                  ],
                                  "verification": "Tabela de f_i completa e verificada por substituição simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de cálculo ou software como Python/Excel"
                                  ],
                                  "tips": "Use função simbólica se possível para evitar erros aritméticos.",
                                  "learningObjective": "Executar avaliações precisas de f para uso na predição.",
                                  "commonMistakes": [
                                    "Erro de sinal em f",
                                    "Índices trocados nos pontos t_i",
                                    "Arredondamento prematuro levando a propagação de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar os coeficientes e somar para obter a predição y_{n+1}^p",
                                  "subSteps": [
                                    "Multiplique cada f_{n-j+1} pelo coeficiente β_j correspondente.",
                                    "Some os produtos: Σ β_j f_{n-j+1}.",
                                    "Multiplique a soma pelo passo h: h * soma.",
                                    "Adicione a y_n: y_{n+1}^p = y_n + h * soma.",
                                    "Registre y_{n+1}^p com precisão adequada."
                                  ],
                                  "verification": "Cálculo stepwise auditado: soma dos produtos bate com o resultado final.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de coeficientes impressa"
                                  ],
                                  "tips": "Faça um checklist para cada multiplicação para evitar omissões.",
                                  "learningObjective": "Realizar o cálculo ponderado da predição explicitamente.",
                                  "commonMistakes": [
                                    "Inverter ordem dos β_j",
                                    "Esquecer de somar a y_n",
                                    "Erro em multiplicação por h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e estimar o erro local de truncamento",
                                  "subSteps": [
                                    "Estime o erro local usando a fórmula teórica: |erro| ≈ C h^{k+1}, onde C envolve derivada de ordem k+1 de y.",
                                    "Compare com solução exata ou valor correto se disponível.",
                                    "Calcule redução de erro variando h e verificando ordem (ex: erro ~ h^{k+1}).",
                                    "Documente a magnitude do erro e se está dentro de O(h^{k+1}).",
                                    "Ajuste se necessário e reflita sobre precisão."
                                  ],
                                  "verification": "Relatório de erro escrito com comparação numérica ou teórica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Solução analítica se conhecida",
                                    "Software para solução numérica fina"
                                  ],
                                  "tips": "Para testes, use problemas lineares como y'=y com solução exata e^{t}.",
                                  "learningObjective": "Avaliar a acurácia e ordem de convergência do método.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Não elevar h à potência k+1",
                                    "Ignorar constante C na estimativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 (solução exata y=e^{-t}), h=0.1, n=1, k=2 com y_0=1, y_1≈0.9048, f_0= -1, f_1≈0.9048. Coef: β1=3/2, β2=-1/2. Soma=(3/2)(0.9048) + (-1/2)(-1)=1.7072. y_2^p = 0.9048 + 0.1*1.7072 ≈ 1.0755 (erro local ~O(h^3)=0.001).",
                              "finalVerifications": [
                                "Fórmula Adams-Bashforth aplicada corretamente com coeficientes exatos.",
                                "Todos f_i calculados e tabela completa sem discrepâncias.",
                                "Predição y_{n+1}^p numérica precisa até 4 casas decimais.",
                                "Erro local estimado e confirmado como O(h^{k+1}).",
                                "Cálculos auditados independentemente.",
                                "Documentação clara com passos reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da fórmula (100% dos coeficientes corretos).",
                                "Exatidão nos cálculos de f_i e soma ponderada (erro <10^{-4}).",
                                "Correta estimação e verificação do erro de truncamento.",
                                "Organização e clareza na documentação dos passos.",
                                "Identificação de potenciais erros e correções aplicadas.",
                                "Demonstração de compreensão teórica via explicação do método."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de trajetórias em dinâmica newtoniana.",
                                "Computação: Implementação em Python com bibliotecas como SciPy.",
                                "Engenharia: Modelagem de circuitos RLC ou fluidodinâmica.",
                                "Estatística: Previsão em séries temporais numéricas."
                              ],
                              "realWorldApplication": "Usado em previsões meteorológicas (modelos de Adams-Bashforth em ECMWF), simulações financeiras de opções (Black-Scholes numérico) e controle de sistemas dinâmicos em robótica, onde predições explícitas aceleram iterações predictor-corrector sem custo computacional alto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Implementar preditor em pseudocódigo",
                            "description": "Escrever pseudocódigo para o preditor explícito multistep, incluindo inicialização com método de Runge-Kutta e cálculo sequencial de predições para passos múltiplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros e estrutura inicial do pseudocódigo",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial (PVI): especifique y' = f(t, y), y(t0) = y0, intervalo [t0, tf], passo h e ordem do método multistep k.",
                                    "Defina variáveis: arrays y_pred[k+1] para valores anteriores, t_current, contador de passos.",
                                    "Estruture o pseudocódigo com função principal: INPUTS (f, t0, y0, tf, h, k), OUTPUTS (array de predições y_n).",
                                    "Inclua seção de inicialização para os primeiros k passos.",
                                    "Adicione comentários explicativos para cada seção."
                                  ],
                                  "verification": "Revise se todos os parâmetros estão declarados corretamente e a estrutura da função está clara sem erros lógicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência ao PVI exemplo",
                                    "Editor de texto ou papel para esboço",
                                    "Documentação de métodos multistep"
                                  ],
                                  "tips": "Use nomes de variáveis descritivos como 'y_pred_prev' para evitar confusão.",
                                  "learningObjective": "Estabelecer a base modular para algoritmos numéricos em pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer de definir o tamanho do array baseado em k",
                                    "Não especificar tipo de f como função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inicialização com método de Runge-Kutta",
                                  "subSteps": [
                                    "Escolha RK4 (quarto ordem) para inicializar os primeiros k valores y1 a yk.",
                                    "Escreva sub-rotina para um passo RK4: calcular k1 = h*f(tn, yn), k2 = h*f(tn+h/2, yn+k1/2), etc., yn+1 = yn + (k1+2k2+2k3+k4)/6.",
                                    "Loop para n=0 a k-1: compute yn+1 usando RK4 e armazene em y_pred[0..k].",
                                    "Atualize t_current = t0 + k*h.",
                                    "Verifique consistência de índices no array y_pred."
                                  ],
                                  "verification": "Simule manualmente 1-2 passos iniciais com valores numéricos simples para confirmar y1, y2 corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmula explícita de RK4",
                                    "Calculadora para teste manual",
                                    "Exemplo numérico de PVI"
                                  ],
                                  "tips": "Implemente RK4 como função auxiliar para reutilização e clareza.",
                                  "learningObjective": "Dominar inicialização precisa para métodos multistep usando RK de alta ordem.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes de Butcher para RK4 (ex: 1/6 errado)",
                                    "Índices off-by-one no array"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo sequencial do preditor explícito multistep",
                                  "subSteps": [
                                    "Defina coeficientes do preditor explícito (ex: Adams-Bashforth ordem k): β0, β1, ..., βk de tabela padrão.",
                                    "Inicie loop WHILE t_current < tf: y_pred_new = y_pred[k] + h * Σ(βi * f(t_current - i*h, y_pred[k-i])) para i=0 a k.",
                                    "Atualize array: shift y_pred (y_pred[0..k-1] = y_pred[1..k]), y_pred[k] = y_pred_new.",
                                    "Atualize t_current = t_current + h e armazene predição se necessário.",
                                    "Inclua condição de parada precisa (t_current + h > tf)."
                                  ],
                                  "verification": "Trace o loop para 2-3 iterações com k=2 e verifique se predições seguem fórmula AB2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Bashforth",
                                    "Exemplo resolvido de preditor multistep"
                                  ],
                                  "tips": "Use soma acumulada para evitar recomputar f desnecessariamente.",
                                  "learningObjective": "Construir o núcleo do preditor explícito com precisão multistep.",
                                  "commonMistakes": [
                                    "Sinais errados nos coeficientes βi",
                                    "Não shiftar corretamente o array de valores anteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar, testar e documentar o pseudocódigo completo",
                                  "subSteps": [
                                    "Integre todas as seções: estrutura, inicialização RK, loop preditor.",
                                    "Adicione tratamento de erros: se k=0 ou h<=0, retorne erro.",
                                    "Inclua seção de output: imprimir ou retornar lista de (tn, y_pred_n).",
                                    "Teste logicamente com PVI simples y'= -y, y(0)=1.",
                                    "Adicione comentários detalhados e indentação para legibilidade."
                                  ],
                                  "verification": "Execute pseudocódigo mentalmente para todo o intervalo e compare com solução conhecida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Solução analítica do PVI teste",
                                    "Ferramenta de linting para pseudocódigo"
                                  ],
                                  "tips": "Formate com blocos indentados para simular código real.",
                                  "learningObjective": "Produzir pseudocódigo robusto, testável e bem documentado.",
                                  "commonMistakes": [
                                    "Loop infinito por h mal tratado",
                                    "Falta de comentários obscura lógica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para PVI y' = -2y, y(0)=1, tf=1, h=0.25, k=2 (AB2): Inicialize com RK4 para y1≈0.8187, y2≈0.6703; então preditor: y3 = y2 + (h/2)*(3f(t2,y2) - f(t1,y1)) ≈0.5490, e assim por diante até t=1.",
                              "finalVerifications": [
                                "Inicialização RK4 produz valores precisos para primeiros k passos.",
                                "Loop preditor usa corretamente coeficientes multistep sem overflow de índices.",
                                "Condições de parada e erros são tratadas adequadamente.",
                                "Pseudocódigo é legível com comentários em todas as seções críticas.",
                                "Teste com PVI linear converge para solução conhecida.",
                                "Array y_pred mantém histórico correto de k+1 valores."
                              ],
                              "assessmentCriteria": [
                                "Correção da fórmula RK4 (pontos por coeficientes exatos).",
                                "Precisão dos coeficientes do preditor multistep (ver tabela AB).",
                                "Clareza e estrutura do pseudocódigo (indentação, comentários).",
                                "Tratamento de edge cases (k=1, tf-t0 não múltiplo de h).",
                                "Verificabilidade: passos iniciais e loop testáveis manualmente.",
                                "Eficiência: evita recomputações desnecessárias de f."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loop, arrays e funções em pseudocódigo.",
                                "Física: Modelagem de EDOs em dinâmica (ex: decaimento radioativo).",
                                "Computação Científica: Bibliotecas como SciPy odeint usam similares.",
                                "Engenharia: Simulações em controle de sistemas."
                              ],
                              "realWorldApplication": "Desenvolvimento de simuladores numéricos para previsão de trajetórias em engenharia aeroespacial, modelagem climática multistep ou farmacocinética em medicina, onde preditores explícitos aceleram soluções de EDOs rígidas antes da correção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Método Corretor Implícito",
                        "description": "Métodos implícitos de passo múltiplo, como Adams-Moulton, usados para refinar a predição resolvendo uma equação não linear, oferecendo maior estabilidade especialmente para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Derivar fórmulas de corretores Adams-Moulton",
                            "description": "Obter as fórmulas implícitas de Adams-Moulton de ordens 2 a 4, expressando y_{n+1} em termos de y_n até y_{n-k} e f(t_{n+1}, y_{n+1}), com ordem de precisão k+1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos da Derivação dos Métodos Adams-Moulton",
                                  "subSteps": [
                                    "Revise a fórmula geral multistep implícita: y_{n+1} = y_n + h ∑_{j=0}^k β_j f_{n+1-j} + h γ_0 f_{n+1}, onde γ_0 ≠ 0 para implícito.",
                                    "Entenda a base na integração numérica: y_{n+1} - y_n = ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt.",
                                    "Configure a interpolação polinomial de Newton backward nos pontos t_{n+1}, t_n, ..., t_{n-k} para f.",
                                    "Expresse o polinômio interpolante P(t) = f_{n+1} + ∇f_{n+1} (s) + ... onde s = (t - t_{n+1})/h.",
                                    "Integre P(s) ds de 0 a 1 e multiplique por h para aproximar a integral."
                                  ],
                                  "verification": "Escreva corretamente a forma geral da integral e o polinômio de interpolação para k=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simbólica ou software como Mathematica/Maple",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Use diferenças divididas backward (∇) para facilitar os coeficientes de integração.",
                                  "learningObjective": "Compreender a origem da derivação via interpolação implícita.",
                                  "commonMistakes": [
                                    "Usar interpolação forward em vez de backward",
                                    "Esquecer de incluir f_{n+1} no polinômio",
                                    "Confundir os limites de integração em s"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivação da Fórmula Adams-Moulton de Ordem 2 (k=1)",
                                  "subSteps": [
                                    "Para ordem 2 (precisão 2), interpole em t_{n+1} e t_n: P(s) = f_{n+1} + ∇f_{n+1} s.",
                                    "Calcule ∇f_{n+1} = f_{n+1} - f_n.",
                                    "Integre: ∫_0^1 P(s) ds = ∫_0^1 [f_{n+1} + (f_{n+1} - f_n) s] ds = f_{n+1} (1 + 1/2) - f_n (1/2) = (1/2) f_{n+1} + (1/2) f_n.",
                                    "Assim, y_{n+1} = y_n + (h/2) (f_{n+1} + f_n).",
                                    "Verifique a ordem: erro local O(h^3)."
                                  ],
                                  "verification": "Derive e escreva a fórmula exata: y_{n+1} = y_n + (h/2)(f_{n+1} + f_n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de coeficientes de integração pré-computados"
                                  ],
                                  "tips": "Desenhe o gráfico da interpolação linear para visualizar.",
                                  "learningObjective": "Derivar explicitamente a fórmula AM2 e entender sua precisão.",
                                  "commonMistakes": [
                                    "Erro no cálculo da integral de s (é 1/2)",
                                    "Esquecer o fator h",
                                    "Confundir ∇f_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação da Fórmula Adams-Moulton de Ordem 3 (k=2)",
                                  "subSteps": [
                                    "Para ordem 3 (precisão 3), interpole em t_{n+1}, t_n, t_{n-1}: P(s) = f_{n+1} + ∇f_{n+1} s + (1/2) ∇²f_{n+1} s(s+1).",
                                    "Calcule diferenças: ∇f_{n+1} = f_{n+1} - f_n, ∇²f_{n+1} = ∇f_{n+1} - ∇f_n = (f_{n+1} - 2f_n + f_{n-1}).",
                                    "Integre termo a termo: ∫_0^1 P(s) ds = ∫ f_{n+1} = 1 f_{n+1}, ∫ ∇f s = (1/2) ∇f, ∫ (1/2)∇² s(s+1) = (1/12) ∇².",
                                    "Expanda: (5/12) f_{n+1} + (8/12) f_n - (1/12) f_{n-1}.",
                                    "Fórmula: y_{n+1} = y_n + (h/12) (5 f_{n+1} + 8 f_n - f_{n-1})."
                                  ],
                                  "verification": "Obtenha os coeficientes exatos 5/12, 8/12, -1/12.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios de diferenças divididas",
                                    "Software para verificar integrais (SymPy)"
                                  ],
                                  "tips": "Compute integrais primitivas: ∫ s ds = s²/2, ∫ s(s+1) ds = s³/3 + s²/2.",
                                  "learningObjective": "Dominar a derivação com diferenças de segunda ordem.",
                                  "commonMistakes": [
                                    "Erro na fórmula de ∇² (deve ser centrada)",
                                    "Integral errada de s(s+1)",
                                    "Coeficientes trocados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivação da Fórmula Adams-Moulton de Ordem 4 (k=3) e Verificação Geral",
                                  "subSteps": [
                                    "Para ordem 4 (precisão 4), adicione termo ∇³f_{n+1} / 6 * s(s+1)(s+2)/3! na forma Newton.",
                                    "Calcule ∇³f_{n+1} = ∇²f_{n+1} - ∇²f_n = f_{n+1} - 3f_n + 3f_{n-1} - f_{n-2}.",
                                    "Integre os novos termos: coeficientes resultam em 9/24 f_{n+1} + 19/24 f_n - 5/24 f_{n-1} + 1/24 f_{n-2}.",
                                    "Fórmula: y_{n+1} = y_n + (h/24) (9 f_{n+1} + 19 f_n - 5 f_{n-1} + f_{n-2}).",
                                    "Verifique ordem de precisão k+1 expandindo em série de Taylor e confirmando termos até h^{k+2}."
                                  ],
                                  "verification": "Escreva a fórmula AM4 completa e confirme ordem 4.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Moulton padrão",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use a tabela de integrais de Bernstein para polinômios backward: B_{j, k+1} = ∫_0^1 \binom{k}{j} s^j (1-s)^{k-j} ds, mas adapte para Newton.",
                                  "learningObjective": "Completar derivações até ordem 4 e generalizar.",
                                  "commonMistakes": [
                                    "Fórmula errada para ∇³",
                                    "Sinais incorretos nos coeficientes",
                                    "Não verificar precisão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y(1-y), y(0)=0.5, h=0.1, use predictor (ex: AB2) para f_{n+1}^p, então aplique AM3: y_1 ≈ 0.5 + (0.1/12)(5 f_1^p + 8 f_0 - f_{-1} approx), iterando até convergência.",
                              "finalVerifications": [
                                "Fórmula AM2: y_{n+1} = y_n + (h/2)(f_{n+1} + f_n)",
                                "Fórmula AM3: y_{n+1} = y_n + (h/12)(5 f_{n+1} + 8 f_n - f_{n-1})",
                                "Fórmula AM4: y_{n+1} = y_n + (h/24)(9 f_{n+1} + 19 f_n - 5 f_{n-1} + f_{n-2})",
                                "Ordem de precisão: 2, 3 e 4 respectivamente",
                                "Expressão inclui y_n a y_{n-k} e f_{n+1}",
                                "Diferenças backward usadas corretamente"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todas as integrais e expansões",
                                "Coeficientes exatos sem erros aritméticos",
                                "Uso apropriado de notação Newton backward",
                                "Verificação de ordem de precisão via Taylor",
                                "Clareza na apresentação das fórmulas finais",
                                "Identificação de dependências implícitas em f_{n+1}"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para predictor-corrector",
                                "Física: Aplicar em equações diferenciais de movimento orbital",
                                "Engenharia: Simulações de circuitos RLC com estabilidade A-estável",
                                "Computação Científica: Otimização em ODE solvers como SciPy",
                                "Estatística: Modelos estocásticos em finanças"
                              ],
                              "realWorldApplication": "Essas fórmulas são usadas em software de simulação como MATLAB ODE45 (híbrido) para previsão meteorológica, dinâmica de fluidos em aviação e modelagem epidemiológica (ex: SIR models), garantindo alta precisão e estabilidade em passos variáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Resolver equação implícita do corretor",
                            "description": "Usar iteração de ponto fixo ou Newton-Raphson para solucionar a equação não linear do corretor, dada a predição inicial, garantindo convergência com tolerância epsilon.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a equação implícita do corretor",
                                  "subSteps": [
                                    "Identifique o método corretor implícito (ex: Adams-Moulton) e a predição inicial y*_{n+1}.",
                                    "Escreva a equação não linear F(y_{n+1}) = 0, como y_{n+1} - y_n - h * φ(t_{n+1}, y_{n+1}) = 0.",
                                    "Defina parâmetros: tolerância ε (ex: 10^{-6}), máximo de iterações k_max (ex: 20).",
                                    "Calcule a derivada F'(y) se usando Newton-Raphson.",
                                    "Verifique consistência dimensional e unidades."
                                  ],
                                  "verification": "Equação F(y) = 0 está corretamente escrita e predição inicial y^{(0)} = y*_{n+1} definida.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Papel e lápis, software numérico (Python com NumPy ou MATLAB)",
                                  "tips": "Sempre use a predição como chute inicial para acelerar convergência.",
                                  "learningObjective": "Formular precisamente a equação implícita derivada do método corretor.",
                                  "commonMistakes": "Confundir preditor com corretor; ignorar dependência em y_{n+1} na função φ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar o método iterativo",
                                  "subSteps": [
                                    "Escolha ponto fixo se g(y) = y_n + h φ(t_{n+1}, y) converge (|g'(y)| < 1), senão Newton-Raphson.",
                                    "Para ponto fixo: defina iteração y^{(k+1)} = g(y^{(k)}).",
                                    "Para Newton: y^{(k+1)} = y^{(k)} - F(y^{(k)}) / F'(y^{(k)}).",
                                    "Inicialize y^{(0)} = y*_{n+1} e defina ε e k_max.",
                                    "Teste Lipschitz ou monotonicidade para prever convergência."
                                  ],
                                  "verification": "Método escolhido justificado e funções g(y) ou F(y), F'(y) implementadas.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Calculadora gráfica ou script Python/MATLAB para protótipo",
                                  "tips": "Prefira Newton-Raphson para quadrática convergência em problemas gerais.",
                                  "learningObjective": "Selecionar método iterativo adequado baseado em propriedades da equação.",
                                  "commonMistakes": "Escolher ponto fixo sem verificar |g'(ξ)| < 1, levando a divergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações até convergência",
                                  "subSteps": [
                                    "Inicie loop com k=0, y^{(0)}.",
                                    "Compute y^{(k+1)} usando fórmula escolhida.",
                                    "Verifique critério: |y^{(k+1)} - y^{(k)}| < ε ou |F(y^{(k+1)})| < ε.",
                                    "Se não convergir em k_max, pare e analise (aumente ε ou mude método).",
                                    "Registre histórico de iterações para análise."
                                  ],
                                  "verification": "Loop implementado e executado até critério satisfeito ou k_max atingido.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Software de programação (Python com loop while, MATLAB)",
                                  "tips": "Monitore resíduos |F(y)| em vez de apenas diferença para precisão.",
                                  "learningObjective": "Implementar algoritmo iterativo com controle de convergência robusto.",
                                  "commonMistakes": "Critério de parada muito rígido causando loops infinitos; não limitar k_max."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar a solução",
                                  "subSteps": [
                                    "Compare y_{n+1} final com predição y* e solução exata se conhecida.",
                                    "Calcule número de iterações necessárias e ordem de convergência.",
                                    "Analise sensibilidade a ε e y^{(0)} variando parâmetros.",
                                    "Verifique estabilidade numérica (evite overflow/underflow).",
                                    "Documente y_{n+1} como valor corrigido final."
                                  ],
                                  "verification": "Solução validada com métricas de erro e análise de convergência reportada.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": "Gráficos (Matplotlib ou MATLAB plot) para histórico de iterações",
                                  "tips": "Plote y^{(k)} vs k para visualizar convergência.",
                                  "learningObjective": "Avaliar qualidade e eficiência da solução numérica obtida.",
                                  "commonMistakes": "Aceitar solução sem verificar se F(y_{n+1}) ≈ 0; ignorar lentidão em iterações."
                                }
                              ],
                              "practicalExample": "No método predictor-corrector de Heun (explícito-implícito): dado y_n = 1, h=0.1, f(t,y)=y^2, t_{n+1}=0.1. Preditor: y* = y_n + h f(t_n, y_n) = 1 + 0.1*1 = 1.1. Equação corretor: y_{n+1} = y_n + (h/2)(f(t_n,y_n) + f(t_{n+1},y_{n+1})) → F(y) = y - 1 - 0.05(1 + y^2) = 0. Use Newton: y^{(k+1)} = y^{(k)} - F(y^{(k)})/(1 - 0.05*2 y^{(k)}). Inicie y^{(0)}=1.1, ε=1e-6. Convergirá em ~4 iterações para y_{n+1} ≈ 1.10517.",
                              "finalVerifications": [
                                "Equação F(y_{n+1})=0 resolvida com |F(y)| < ε.",
                                "Número de iterações ≤ k_max e razoável (tipicamente <10).",
                                "Solução y_{n+1} consistente com predição inicial (erro < 10 ε).",
                                "Histórico de iterações mostra convergência monotônica.",
                                "Análise de sensibilidade confirma robustez.",
                                "Valor final usado corretamente no predictor-corrector."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro na solução < ε em todos testes.",
                                "Eficiência: iterações mínimas para convergência.",
                                "Correção: implementação livre de bugs algorítmicos.",
                                "Justificativa: escolha de método bem fundamentada.",
                                "Análise: relatório inclui gráficos e métricas de convergência.",
                                "Generalidade: funciona para diferentes ε e y^{(0)}."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB reforça loops e funções.",
                                "Física: Aplicado em simulações de EDOs como movimento harmônico.",
                                "Engenharia: Otimização em controle de sistemas dinâmicos.",
                                "Estatística: Análise de erro e convergência probabilística."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional) para previsão de escoamentos, onde predictor-corrector implícito resolve EDOs rígidas em malhas temporais, garantindo estabilidade em aviões ou turbinas eólicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Avaliar estabilidade do corretor",
                            "description": "Analisar a estabilidade A-estável ou L-estável do método implícito Adams-Moulton comparado a métodos explícitos, usando região de estabilidade no plano complexo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Estabilidade em Métodos Numéricos",
                                  "subSteps": [
                                    "Defina estabilidade absoluta (A-estável) e estabilidade linear (L-estável) para métodos de Runge-Kutta e multistep.",
                                    "Explique o papel do plano complexo z = hλ na análise de estabilidade.",
                                    "Revise o teste de Dahlquist para estabilidade zero e consistência.",
                                    "Discuta diferenças entre métodos explícitos e implícitos em termos de rigidez.",
                                    "Estude exemplos simples de regiões de estabilidade para métodos de Euler explícito e implícito."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições de A-estável e L-estável, com um esboço manual do plano complexo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: Burden & Faires), papel e lápis, software de plotagem como MATLAB ou Python (Matplotlib).",
                                  "tips": "Use analogias com equações diferenciais rígidas para visualizar o 'círculo de estabilidade' dos explícitos.",
                                  "learningObjective": "Compreender os conceitos teóricos de estabilidade para contextualizar o método Adams-Moulton.",
                                  "commonMistakes": "Confundir estabilidade absoluta com condicional; ignorar o semiplano esquerdo do plano complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula do Método Adams-Moulton Implícito",
                                  "subSteps": [
                                    "Escreva a fórmula geral do método multistep linear implícito de ordem k: y_{n+1} = y_n + h ∑ β_j f(t_{n+j}, y_{n+j}).",
                                    "Especifique para Adams-Moulton de ordem 2 (AM2): y_{n+1} = y_n + (h/2)(3f_{n+1} - f_n).",
                                    "Identifique os coeficientes geradores α(z) e β(z) para o polinômio de estabilidade.",
                                    "Aplique o método ao modelo teste y' = λy, obtendo a função de amplificação R(z) = [1 - (1/2)z] / [1 + (3/2)z].",
                                    "Verifique a consistência e ordem de truncamento."
                                  ],
                                  "verification": "Derive corretamente R(z) para AM2 e compute |R(iy)| para y real pequeno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de anotações, calculadora simbólica (ex: SymPy em Python), referência ao procedimento Predictor-Corrector.",
                                  "tips": "Comece com ordem baixa (k=2) para simplicidade antes de generalizar.",
                                  "learningObjective": "Dominar a formulação matemática do corretor implícito Adams-Moulton.",
                                  "commonMistakes": "Erros nos coeficientes β; esquecer o termo implícito f_{n+1}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Plotar a Região de Estabilidade",
                                  "subSteps": [
                                    "Defina a região de estabilidade S = {z ∈ ℂ : |R(z)| ≤ 1}.",
                                    "Use software para plotar |R(z)| ≤ 1 no plano complexo para AM2 e compare com AM de ordem superior.",
                                    "Analise o semiplano Re(z) < 0: verifique se inclui todo o semiplano esquerdo (A-estável).",
                                    "Teste L-estabilidade: verifique se |R(z)| → 0 quando |z| → ∞ no semiplano esquerdo.",
                                    "Compare graficamente com região de Adams-Bashforth explícito (círculo unitário aproximado)."
                                  ],
                                  "verification": "Gere um gráfico da região de estabilidade mostrando inclusão do semiplano esquerdo.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy, Matplotlib e SciPy; ou MATLAB; templates de código para regiões de estabilidade.",
                                  "tips": "Use grade fina no plano complexo (-10 ≤ Re(z) ≤ 0, -10 ≤ Im(z) ≤ 10) para precisão visual.",
                                  "learningObjective": "Visualizar e quantificar a região de estabilidade do Adams-Moulton.",
                                  "commonMistakes": "Plotagem incorreta do eixo imaginário; confundir R(z) com polinômio de característica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Estabilidade e Concluir A/L-Estabilidade",
                                  "subSteps": [
                                    "Compare tamanho da região: AM implícito vs. AB explícito para equações rígidas (Re(λ)<0, |Im(λ)| grande).",
                                    "Verifique A-estabilidade: prove que S contém {z : Re(z) < 0} para AM2-AM4.",
                                    "Teste L-estabilidade numericamente: compute lim |R(z)| para z = x + iy, |z|→∞, x<0.",
                                    "Discuta implicações no Predictor-Corrector: predictor explícito limita h, corretor permite h maior.",
                                    "Resuma vantagens: permite passos maiores em problemas rígidos sem oscilações."
                                  ],
                                  "verification": "Escreva um relatório de 1 página com gráficos e conclusão sobre A-estável (sim) e L-estável (para ordens baixas).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de plotagem, tabelas de regiões de estabilidade de livros-texto.",
                                  "tips": "Use zoom em regiões críticas próximas à origem e infinito.",
                                  "learningObjective": "Analisar comparativamente a estabilidade e classificar o método.",
                                  "commonMistakes": "Afirmar L-estável sem verificar limite em |z|→∞; ignorar dependência da ordem."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em um Exemplo Numérico e Sintetizar",
                                  "subSteps": [
                                    "Implemente Predictor-Corrector com AM2 em y' = -50y + sin(t), y(0)=1.",
                                    "Varie h e observe estabilidade com predictor AB2 vs. corretor AM2.",
                                    "Plote soluções numéricas vs. exata para h rígido.",
                                    "Quantifique erro e número de passos necessários.",
                                    "Conclua sobre superioridade do implícito em rigidez."
                                  ],
                                  "verification": "Gráficos mostram convergência estável para h maior com AM2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python ou MATLAB para simulação numérica.",
                                  "tips": "Fixe predictor simples inicialmente para isolar efeito do corretor.",
                                  "learningObjective": "Validar teoricamente a análise de estabilidade em prática.",
                                  "commonMistakes": "Não normalizar erro; escolher λ não rígido."
                                }
                              ],
                              "practicalExample": "Considere o PVI y' = λy com λ = -100 + 50i (rígido oscilatório). Use Predictor-Corrector com AB2-AM2, h=0.1. Plote trajetórias no plano complexo e observe que AM2 permanece estável enquanto AB2 diverge, confirmando A-estabilidade.",
                              "finalVerifications": [
                                "Região de estabilidade plotada corretamente inclui semiplano Re(z)<0.",
                                "Função R(z) derivada com coeficientes exatos para AM2.",
                                "Comparação gráfica com método explícito mostra superioridade implícito.",
                                "Classificação correta: A-estável para ordens ≤4, L-estável parcial.",
                                "Exemplo numérico demonstra estabilidade para h rígido.",
                                "Relatório sintetiza implicações no Predictor-Corrector."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) (20%)",
                                "Qualidade e interpretação dos gráficos de estabilidade (30%)",
                                "Análise comparativa explícito vs. implícito (20%)",
                                "Classificação correta A/L-estável com justificativa (15%)",
                                "Aplicação prática com código e resultados (10%)",
                                "Clareza do relatório e conexões teórico-práticas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos rígidos (equações de movimento).",
                                "Computação: Implementação eficiente em bibliotecas como SciPy ODE solvers.",
                                "Engenharia: Modelagem de circuitos RLC rígidos em controle de sistemas.",
                                "Estatística: Análise de estabilidade em processos estocásticos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) ou previsão meteorológica, onde equações rígidas surgem de escalas múltiplas, o Adams-Moulton permite passos de tempo maiores, reduzindo custo computacional em supercomputadores sem perda de estabilidade."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Procedimento Predictor-Corrector Combinado",
                        "description": "Algoritmo que alterna preditor explícito e corretor implícito (modos PECE, PEC), melhorando precisão global, estabilidade e permitindo detecção de erros para controle de passo variável.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Descrever algoritmo PECE",
                            "description": "Explicar o ciclo Predict-Evaluate-Correct-Evaluate (PECE) para predictor-corrector multistep, incluindo critérios de parada de iterações baseados em diferença entre predição e correção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos do método predictor-corrector multistep",
                                  "subSteps": [
                                    "Estudar os métodos predictor (ex: Adams-Bashforth) e corrector (ex: Adams-Moulton).",
                                    "Identificar que o predictor gera uma aproximação inicial grosseira.",
                                    "Explicar que o corrector refina a predição usando valores implícitos.",
                                    "Diferenciar predição (explícita) de correção (implícita).",
                                    "Revisar fórmulas genéricas para métodos multistep lineares."
                                  ],
                                  "verification": "Escrever definições curtas para predictor e corrector, com exemplos de fórmulas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Análise Numérica, caderno e caneta.",
                                  "tips": "Use diagramas de fluxo para visualizar predictor → corrector.",
                                  "learningObjective": "Dominar os papéis distintos de predictor e corrector em métodos multistep.",
                                  "commonMistakes": "Confundir predictor explícito com corrector implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o ciclo PECE (Predict-Evaluate-Correct-Evaluate)",
                                  "subSteps": [
                                    "Passo Predict: Aplicar predictor para estimar y_{n+1}^p.",
                                    "Passo Evaluate 1: Calcular f_{n+1}^p = f(t_{n+1}, y_{n+1}^p).",
                                    "Passo Correct: Aplicar corrector para y_{n+1}^c usando f_{n+1}^p.",
                                    "Passo Evaluate 2: Calcular f_{n+1}^c = f(t_{n+1}, y_{n+1}^c) e comparar com f_{n+1}^p.",
                                    "Repetir ciclo se necessário até convergência."
                                  ],
                                  "verification": "Desenhar fluxograma do ciclo PECE com setas e condições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel milimetrado, lápis, acesso a slides ou vídeo explicativo.",
                                  "tips": "Lembre-se: PECE é iterativo dentro do passo n+1 para maior precisão.",
                                  "learningObjective": "Explicar sequencialmente os quatro passos do ciclo PECE.",
                                  "commonMistakes": "Omitir o segundo Evaluate ou inverter ordem dos passos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir critérios de parada das iterações PECE",
                                  "subSteps": [
                                    "Estabelecer tolerância ε (ex: 10^{-6}).",
                                    "Calcular diferença |y_{n+1}^{(k+1)} - y_{n+1}^{(k)}| ou |f_{n+1}^{(k+1)} - f_{n+1}^{(k)}|.",
                                    "Parar se diferença < ε ou após máximo de iterações (ex: 5).",
                                    "Discutir convergência local do método predictor-corrector.",
                                    "Considerar detecção de divergência (diferença crescente)."
                                  ],
                                  "verification": "Escrever fórmula matemática do critério e um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, tabela de tolerâncias típicas.",
                                  "tips": "Use norma L2 ou máximo para diferenças vetoriais em sistemas.",
                                  "learningObjective": "Formular critérios quantitativos para término das iterações.",
                                  "commonMistakes": "Usar diferença absoluta sem normalizar ou ignorar máximo de iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever o algoritmo completo PECE em pseudocódigo",
                                  "subSteps": [
                                    "Inicializar valores iniciais y_0 a y_k usando método de Runge-Kutta.",
                                    "Para cada passo n: executar ciclo PECE até critério de parada.",
                                    "Armazenar y_{n+1} final e f_{n+1} para próximos passos.",
                                    "Incluir tratamento de erro para não-convergência.",
                                    "Testar logicamente com h=0.1 em equação simples."
                                  ],
                                  "verification": "Executar pseudocódigo manualmente para um passo e verificar saídas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto ou papel para pseudocódigo, exemplo de EDO teste.",
                                  "tips": "Estruture com loops WHILE para iterações e FOR para passos globais.",
                                  "learningObjective": "Implementar algoritmo PECE de forma programável e verificável.",
                                  "commonMistakes": "Esquecer inicialização multistep ou atualização de histórico de f."
                                }
                              ],
                              "practicalExample": "Resolva y' = -y, y(0)=1 com h=0.2, usando predictor AB2: y_{n+1}^p = y_n + (h/2)(3f_n - f_{n-1}) e corrector AM2: y_{n+1}^c = y_n + (h/2)(f_{n+1}^p + f_n). Inicie com y0=1, y1≈0.853 (RK4). Para n=1: Predict y2^p≈0.667, f2^p≈0.333; Correct y2^c≈0.680, f2^c≈0.320; |f2^c - f2^p|<10^{-4}? Não, itere até convergir para y2≈0.6703.",
                              "finalVerifications": [
                                "Lista corretamente os 4 passos do ciclo PECE.",
                                "Escreve pseudocódigo funcional para PECE com critério de parada.",
                                "Calcula manualmente uma iteração PECE em exemplo simples.",
                                "Explica por que PECE melhora precisão sobre predictor único.",
                                "Identifica quando usar |Δf| vs |Δy| como critério."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição do ciclo PECE (30%).",
                                "Correção matemática dos critérios de parada (25%).",
                                "Clareza e lógica no pseudocódigo (20%).",
                                "Uso correto de notação e exemplos (15%).",
                                "Profundidade na discussão de convergência (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python com NumPy/SciPy.",
                                "Física: Simulações de osciladores harmônicos ou trajetórias.",
                                "Engenharia: Modelagem de circuitos RLC ou fluidodinâmica.",
                                "Estatística: Análise de erro em métodos numéricos."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, o ciclo PECE é usado em modelos como ECMWF para resolver EDOs de dinâmica atmosférica, iterando predições grosseiras até convergência dentro de tolerâncias apertadas, garantindo simulações estáveis e precisas para forecasts diários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Implementar predictor-corrector completo",
                            "description": "Codificar em pseudocódigo ou linguagem o procedimento completo, com inicialização, múltiplas iterações do corretor e controle de erro local para ajuste de passo h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e realizar inicialização",
                                  "subSteps": [
                                    "Especificar a EDO y' = f(t,y), condições iniciais y(t0)=y0 e intervalo [t0, tf].",
                                    "Escolher ordens dos métodos predictor (ex: Adams-Bashforth de ordem 3) e corrector (ex: Adams-Moulton de ordem 3).",
                                    "Implementar inicialização com Runge-Kutta de ordem 4 para gerar k=4 pontos iniciais (t0 a t_{k-1}).",
                                    "Armazenar valores em arrays: t[], y[], f[] para histórico.",
                                    "Definir tolerância de erro ε e passo inicial h."
                                  ],
                                  "verification": "Verificar se os k pontos iniciais foram computados corretamente comparando com cálculos manuais para os primeiros passos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/MATLAB), papel para cálculos iniciais, documentação de RK4.",
                                  "tips": "Use uma função separada para f(t,y) para facilitar testes.",
                                  "learningObjective": "Configurar corretamente o problema e gerar dados iniciais precisos para o predictor-corrector.",
                                  "commonMistakes": "Esquecer de armazenar f(t_i, y_i) no histórico; usar h muito grande na inicialização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o predictor",
                                  "subSteps": [
                                    "Definir fórmula do predictor: y_{n+1}^p = y_n + h * Σ β_j * f(t_{n-j}, y_{n-j}) para j=0 a m-1.",
                                    "Calcular y_{n+1}^p usando os valores históricos armazenados.",
                                    "Computar f(t_{n+1}, y_{n+1}^p) e armazená-lo temporariamente.",
                                    "Atualizar arrays t e y com a previsão (marcar como provisório).",
                                    "Testar predictor isoladamente para 2-3 passos."
                                  ],
                                  "verification": "Comparar y_{n+1}^p com valor exato ou RK4 para os primeiros passos; erro < 1e-3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, calculadora para validar fórmulas de coeficientes β.",
                                  "tips": "Hardcode coeficientes β para ordem fixa inicialmente (ex: AB3: β0=23/12, β1=-16/12, β2=5/12).",
                                  "learningObjective": "Codificar o passo de predição multistep com precisão.",
                                  "commonMistakes": "Índices errados no histórico (off-by-one); não atualizar histórico antes de prever."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corrector e iterações de correção",
                                  "subSteps": [
                                    "Definir fórmula do corrector: y_{n+1} = y_n + h * Σ γ_j * f(t_{n+1-j}, y_{n+1-j}) para j=0 a m.",
                                    "Iniciar loop de iterações: calcular y_{n+1}^{(k+1)} usando f(t_{n+1}, y_{n+1}^{(k)}) até |y_{n+1}^{(k+1)} - y_{n+1}^{(k)}| < ε.",
                                    "Atualizar f(t_{n+1}, y_{n+1}) final e adicionar ao histórico.",
                                    "Avançar n e repetir predictor-corrector até tf.",
                                    "Implementar limite máximo de iterações por passo (ex: 10)."
                                  ],
                                  "verification": "Executar 5 passos completos e verificar convergência em cada corrector (mostrar iterações).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, tabela de coeficientes γ para AM (ex: γ0=5/12, γ1=8/12, γ2=-1/12).",
                                  "tips": "Use um while loop com contador para iterações; imprima diferenças para debug.",
                                  "learningObjective": "Realizar correções iterativas até convergência local.",
                                  "commonMistakes": "Não usar a previsão como y^{(0)} no corrector; loop infinito sem limite de iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar controle de erro local e ajuste de passo",
                                  "subSteps": [
                                    "Calcular erro local: e_{n+1} = |y_{n+1}^{(última)} - y_{n+1}^p|.",
                                    "Se e_{n+1} > ε, rejeitar passo, reduzir h = 0.5 h e repetir predictor-corrector.",
                                    "Se e_{n+1} < 0.1 ε, aceitar e aumentar h = 1.5 h para próximo passo.",
                                    "Garantir que histórico seja redefinido ou ajustado ao mudar h.",
                                    "Finalizar com plot ou tabela de solução y vs t."
                                  ],
                                  "verification": "Simular com ε=1e-5; verificar se h ajusta dinamicamente e erro fica dentro de tolerância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Biblioteca de plotagem (matplotlib), exemplos de EDOs com solução exata.",
                                  "tips": "Ajuste h só após aceitar passo; use safe factor 0.9 no multiplicador para estabilidade.",
                                  "learningObjective": "Integrar controle adaptativo de erro para precisão e eficiência.",
                                  "commonMistakes": "Ajustar h sem rejeitar passo falho; histórico inconsistente com novo h."
                                }
                              ],
                              "practicalExample": "Implemente um predictor-corrector AB3-AM3 para resolver y' = -y + t, y(0)=1, em [0,2] com h=0.2 inicial e ε=1e-6. Inicialize com RK4 para 3 pontos. Compare com solução exata y(t)=(t+1)e^{-t}; erro global deve ser <1e-4.",
                              "finalVerifications": [
                                "Código executa sem erros até tf, produzindo arrays t e y completos.",
                                "Erro local em cada passo < ε, com logs de iterações por corrector.",
                                "Solução final converge para valor exato em pelo menos 3 pontos finais (|erro| < 1e-4).",
                                "Gráfico y_num vs y_exata mostra sobreposição visual.",
                                "Teste com h halved: solução mais precisa sem divergência.",
                                "Mudança de EDO/f testa generalidade do código."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global médio < 1e-4 em exemplo padrão.",
                                "Eficiência: Média <5 iterações por corrector; h adaptativo usado >2 vezes.",
                                "Robustez: Lida com rejeição de passos e ajuste h sem crash.",
                                "Clareza: Código comentado, funções modulares (f, predictor, corrector).",
                                "Generalidade: Fácil trocar ordem métodos ou EDO via parâmetros.",
                                "Documentação: Inclui coeficientes hardcoded e justificativa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops, arrays e funções em Python/MATLAB.",
                                "Física: Simulação de trajetórias (ex: movimento com atrito via EDOs).",
                                "Engenharia Computacional: Otimização numérica em CAD/FEM.",
                                "Estatística: Análise de erro e convergência em modelagem estocástica."
                              ],
                              "realWorldApplication": "Usado em simulações meteorológicas para prever trajetórias de partículas (ajuste h dinâmico para regiões instáveis), modelagem financeira de derivativos (EDOs estocásticas aproximadas) e controle de sistemas dinâmicos em robótica, onde precisão adaptativa economiza tempo computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Aplicar em problemas stiff",
                            "description": "Demonstrar vantagens do predictor-corrector em equações stiff (ex.: y' = -1000y + sin(t)), comparando com métodos explícitos em termos de estabilidade e passos necessários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Identificar Problemas Stiff",
                                  "subSteps": [
                                    "Revise a definição de problemas stiff: equações diferenciais com escalas de tempo discrepantes, levando a instabilidade em métodos explícitos.",
                                    "Analise o exemplo y' = -1000y + sin(t), identificando o termo -1000y como causa de rigidez (eigenvalue grande negativo).",
                                    "Calcule analiticamente a solução exata ou aproximada para referência: y(t) = e^{-1000t} ∫ e^{1000s} sin(s) ds.",
                                    "Escolha intervalos de integração, como t de 0 a 1, com h inicial razoável (ex: 0.01)."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando por que o problema é stiff e a solução exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, software como Python com SymPy para solução simbólica.",
                                  "tips": "Visualize escalas: o termo sin(t) é lento, -1000y é rápido.",
                                  "learningObjective": "Identificar características de rigidez em EDOs lineares.",
                                  "commonMistakes": "Confundir stiff com não-linear; ignorar eigenvalues."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Analisar Método Explícito",
                                  "subSteps": [
                                    "Implemente o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Teste com h=0.01 e observe oscilações ou divergência devido à instabilidade.",
                                    "Reduza h iterativamente (ex: 0.001, 0.0001) até estabilidade e conte passos necessários.",
                                    "Plote soluções numéricas vs. exata para quantificar erro."
                                  ],
                                  "verification": "Gere gráficos mostrando instabilidade para h>0.001 e convergência lenta.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy, Matplotlib; ou MATLAB/Octave.",
                                  "tips": "Use logscale no eixo y para visualizar oscilações.",
                                  "learningObjective": "Demonstrar limitação de estabilidade em métodos explícitos para stiff.",
                                  "commonMistakes": "Escolher h muito grande inicialmente sem testar; não plotar erros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método Predictor-Corrector",
                                  "subSteps": [
                                    "Escolha predictor-corrector simples: Predictor AB2 (extrapolação quadrática), Corrector AM2 (trapezoidal implícito).",
                                    "Inicie com Euler para primeiros passos, então aplique PECE mode: Predict, Evaluate, Correct, Evaluate.",
                                    "Aplique com h=0.01 no mesmo intervalo e plote solução.",
                                    "Itere corretor 2-3 vezes por passo para precisão."
                                  ],
                                  "verification": "Confirme que solução permanece estável sem oscilações para h=0.01.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python customizado ou SciPy odeint com método implícito.",
                                  "tips": "Implemente loop PECE para convergência; monitore resíduo.",
                                  "learningObjective": "Executar predictor-corrector combinado em EDOs.",
                                  "commonMistakes": "Esquecer iterações no corretor; usar predictor sem inicialização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Quantificar Vantagens",
                                  "subSteps": [
                                    "Compare número de passos: explícito precisa h<<0.01, predictor-corrector usa h=0.01.",
                                    "Calcule erros globais (RMSE) vs. solução exata para ambos.",
                                    "Meça tempo de computação para precisão similar.",
                                    "Tabele resultados: estabilidade, passos, erro, tempo."
                                  ],
                                  "verification": "Crie tabela e gráficos lado a lado mostrando superioridade do predictor-corrector.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilhas Excel ou Pandas para tabelas; gráficos Matplotlib.",
                                  "tips": "Normalize erros por h para comparação justa.",
                                  "learningObjective": "Quantificar ganhos em eficiência e estabilidade.",
                                  "commonMistakes": "Comparar h diferentes sem ajustar precisão; ignorar custo computacional."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir e Generalizar",
                                  "subSteps": [
                                    "Resuma vantagens: maior passo h estável, menos passos, eficiência para stiff.",
                                    "Discuta limitações: predictor-corrector ainda A-estável parcial, prefira BDF para muito stiff.",
                                    "Teste variação: mude coeficiente para -10000 e reforce conclusões.",
                                    "Escreva relatório curto com achados."
                                  ],
                                  "verification": "Relatório de 200 palavras com tabelas/gráficos anexados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, código anterior.",
                                  "tips": "Enfatize trade-off estabilidade vs. precisão.",
                                  "learningObjective": "Generalizar aplicações de métodos multistep em stiff problems.",
                                  "commonMistakes": "Superestimar predictor-corrector sem mencionar métodos modernos."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000y + sin(t), y(0)=0, em [0,1]. Euler explícito com h=0.01 diverge; predictor-corrector AB2-AM2 converge com 100 passos vs. 10.000 para Euler estável.",
                              "finalVerifications": [
                                "Solução predictor-corrector estável com h=0.01, erro <1e-3.",
                                "Explícito requer h<1e-4 para estabilidade similar.",
                                "Gráficos mostram sobreposição com exata apenas para predictor-corrector.",
                                "Tabela compara passos: 100 vs. >10.000.",
                                "Tempo computacional reduzido em fator >10.",
                                "Relatório explica rigidez via eigenvalues."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de rigidez (30%).",
                                "Correta implementação e gráficos de ambos métodos (25%).",
                                "Análise quantitativa comparativa robusta (20%).",
                                "Relatório claro com conclusões (15%).",
                                "Tratamento de erros comuns e dicas aplicadas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de decaimento radioativo com perturbações.",
                                "Engenharia Química: Reatores com cinéticas stiff.",
                                "Computação: Otimização numérica em simulações HPC.",
                                "Física Computacional: Dinâmica molecular com timestep adaptativo."
                              ],
                              "realWorldApplication": "Em simulações de circuitos RC stiff em eletrônica, predictor-corrector permite timesteps maiores, acelerando design de VLSI; ou em farmacocinética para modelar drogas com decaimento rápido."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Controlar passo com estimativa de erro",
                            "description": "Usar diferença |preditor - corretor| como estimativa de erro para rejeitar/aceitar passo e ajustar h novo = h * (tol / erro)^{1/p}, onde p é ordem do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a estimativa de erro usando diferença entre preditor e corretor",
                                  "subSteps": [
                                    "Após o passo preditor, compute y_pred usando o método explícito (ex: Adams-Bashforth).",
                                    "Aplique o passo corretor com y_pred para obter y_cor (ex: Adams-Moulton).",
                                    "Calcule o erro estimado: erro = |y_pred - y_cor|.",
                                    "Normalize o erro se necessário, considerando o problema escalar ou vetorial.",
                                    "Registre o erro e os valores y_pred e y_cor para análise."
                                  ],
                                  "verification": "Confirme que erro = |y_pred - y_cor| foi calculado corretamente comparando com solução analítica aproximada ou valor anterior.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno de anotações, calculadora científica ou software como Python (NumPy/SciPy) ou MATLAB.",
                                  "tips": "Use precisão de ponto flutuante dupla para evitar erros de arredondamento em cálculos.",
                                  "learningObjective": "Entender e implementar a estimativa local de erro truncamento baseada na diferença preditor-corretor.",
                                  "commonMistakes": "Confundir y_pred com y_cor no cálculo da diferença; ignorar normalização para problemas vetoriais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar estimativa de erro com tolerância e decidir aceitação/rejeição",
                                  "subSteps": [
                                    "Defina a tolerância tol (ex: 1e-6) baseada no problema.",
                                    "Compare erro <= tol * escala (onde escala pode ser max(|y_cor|,1)).",
                                    "Se erro <= tol, aceite o passo e avance para y_n+1 = y_cor.",
                                    "Se erro > tol, rejeite o passo e prepare para ajuste de h.",
                                    "Implemente uma contagem de rejeições para evitar loops infinitos (máx 5)."
                                  ],
                                  "verification": "Teste com um exemplo onde erro excede tol e confirme rejeição; caso contrário, aceitação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de programação numérica (Python com bibliotecas odeint para validação), exemplos de PVI.",
                                  "tips": "Ajuste tol dinamicamente se o problema variar em escala.",
                                  "learningObjective": "Aplicar critério de aceitação baseado em erro estimado para controlar precisão.",
                                  "commonMistakes": "Usar comparação absoluta sem escalonamento; não limitar rejeições levando a loop infinito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o tamanho do passo h com base na fórmula de controle",
                                  "subSteps": [
                                    "Se rejeitado: compute h_novo = h * (tol / erro)^{1/p}, onde p é a ordem do método (ex: p=4 para AM4).",
                                    "Aplique fator de segurança: h_novo = 0.9 * h_novo para conservadorismo.",
                                    "Se aceito: h_novo = h * (tol / erro)^{1/(p+1)} ou fixo um crescimento máximo (ex: 1.2 * h).",
                                    "Garanta h_novo > h_min e h_novo < h_max.",
                                    "Atualize h para o próximo passo preditor-corrector."
                                  ],
                                  "verification": "Simule rejeição e verifique se h diminui proporcionalmente ao excesso de erro; aceite aumenta h moderadamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel para protótipo ou código Python/MATLAB com loop de integração.",
                                  "tips": "Escolha p corretamente: ordem do corretor para rejeição, p+1 para aceitação.",
                                  "learningObjective": "Dominar a fórmula adaptativa de controle de passo para eficiência e precisão.",
                                  "commonMistakes": "Usar p incorreto (ex: ordem preditor em vez de corretor); h_novo negativo ou zero por erro=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o controle de passo no algoritmo predictor-corrector completo",
                                  "subSteps": [
                                    "Estruture o loop principal: inicialize h, y0, t0.",
                                    "Em cada iteração: preditor → corretor → estimar erro → decidir → ajustar h → repetir se rejeitado.",
                                    "Monitore solução até t_final, salvando histórico de h, erros e y.",
                                    "Implemente saída de emergência se h < h_min.",
                                    "Valide com solução exata ou método de alta ordem."
                                  ],
                                  "verification": "Execute até t_final sem crash; compare erro global com tol.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ambiente de programação (Jupyter Notebook), PVI teste como y'= -y, y(0)=1.",
                                  "tips": "Vectorize para sistemas; plote h vs t para visualizar adaptação.",
                                  "learningObjective": "Construir um solver adaptativo robusto com predictor-corrector.",
                                  "commonMistakes": "Não resetar preditor após rejeição; acumular erros sem reinício."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, t de 0 a 1, usando AB4 preditor e AM4 corretor (p=4), tol=1e-5. Inicie h=0.1. No primeiro passo, suponha erro=2e-5 > tol → rejeite, h_novo=0.1*(1e-5/2e-5)^{1/4}≈0.07. Aceite próximo, aumente h gradualmente. Solução final aproxima e^t com erro global < tol.",
                              "finalVerifications": [
                                "O algoritmo atinge t_final sem rejeições excessivas (>20% rejeições indica problema).",
                                "Erro global máximo < 2*tol comparado com solução exata.",
                                "h adapta corretamente: diminui com erro alto, aumenta com erro baixo.",
                                "Número total de passos é razoável (eficiente vs método fixo).",
                                "Código roda sem erros numéricos (NaN/inf).",
                                "Gráfico de h(t) mostra adaptação suave."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro estimado corretamente usado em todas iterações.",
                                "Eficiência: h ajustado pela fórmula exata com fatores de segurança.",
                                "Robustez: Lida com rejeições múltiplas e bounds em h.",
                                "Implementação: Código limpo com comentários e estrutura modular.",
                                "Validação: Testes com múltiplos PVI mostram consistência.",
                                "Documentação: Explica escolhas de p, tol e normalização."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops adaptativos em Python/MATLAB.",
                                "Física: Simulações de EDOs em mecânica (ex: osciladores).",
                                "Estatística: Análise de erro e controle de qualidade numérica.",
                                "Engenharia: Otimização de solvers em CAD/FEM."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD), previsão meteorológica e controle de sistemas (ex: aviões), onde EDOs rígidos requerem passos adaptativos para precisão sem custo computacional excessivo, evitando crash em singularidades."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Análise de Estabilidade e Ordem",
                    "description": "Critérios de consistência, convergência, ordem e estabilidade (região de estabilidade) dos métodos de passo múltiplo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1.1",
                        "name": "Critérios de Consistência e Convergência",
                        "description": "Definição e análise dos critérios de consistência para métodos de passo múltiplo, incluindo a relação com a convergência global do método aplicado ao problema de valor inicial y' = f(t,y), y(t0)=y0.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1.1",
                            "name": "Definir consistência de um método multistep",
                            "description": "Explicar o conceito de consistência usando os polinômios de diferença ρ(ζ) e σ(ζ), verificando se lim h→0 L[v;h] = f(t,v) para soluções suaves v(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Polinômios de Diferença ρ(ζ) e σ(ζ)",
                                  "subSteps": [
                                    "Revise a forma geral de um método multistep linear: ∑_{j=0}^k α_j y_{n+j} - h ∑_{j=0}^k β_j f_{n+j} = 0.",
                                    "Identifique ρ(ζ) = ∑_{j=0}^k α_j ζ^j como o polinômio de diferença para as aproximações y.",
                                    "Identifique σ(ζ) = ∑_{j=0}^k β_j ζ^j como o polinômio para as derivadas f.",
                                    "Estude as propriedades básicas: grau de ρ é k, grau de σ é geralmente k-1 ou k.",
                                    "Pratique escrevendo ρ(ζ) e σ(ζ) para um método simples como o método de Euler implícito."
                                  ],
                                  "verification": "Escreva corretamente ρ(ζ) e σ(ζ) para pelo menos dois métodos multistep conhecidos.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de métodos multistep)",
                                    "Folha de anotações",
                                    "Exemplos de métodos multistep online"
                                  ],
                                  "tips": "Sempre normalize os coeficientes para que o grau de ρ seja o mais alto e verifique somas em ζ=1.",
                                  "learningObjective": "Dominar a definição e representação dos polinômios ρ(ζ) e σ(ζ) em métodos multistep.",
                                  "commonMistakes": [
                                    "Confundir α_j com β_j",
                                    "Esquecer o fator h na definição de σ",
                                    "Não considerar o operador de avanço E"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Operador Multistep L[v; h]",
                                  "subSteps": [
                                    "Defina formalmente L[v; h](t_n) = ρ(E) v(t_n) - h σ(E) v'(t_n), onde E é o operador de avanço E v(t_n) = v(t_{n+1}).",
                                    "Expanda em termos de potências de h usando a expansão de Taylor: v(t_n + j h) = ∑ (h^j / j!) v^{(j)}(t_n).",
                                    "Mostre que ρ(E) v(t_n) = ∑_{j=0}^k α_j ∑_{m=0}^∞ (h^m / m!) v^{(m)}(t_{n+j}).",
                                    "Simplifique para expressões em termos de derivadas em t_n.",
                                    "Verifique para um método de ordem baixa, como Backward Euler."
                                  ],
                                  "verification": "Derive a expressão expandida de L[v; h] para um método dado e identifique os termos de baixa ordem.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Notas de aula sobre expansões de Taylor"
                                  ],
                                  "tips": "Use a convenção onde o índice j=0 é o ponto atual; agrupe termos por ordens de h.",
                                  "learningObjective": "Construir e expandir o operador L[v; h] para soluções suaves v(t).",
                                  "commonMistakes": [
                                    "Erros nos coeficientes de Taylor para operadores E^j",
                                    "Ignorar termos de ordem superior prematuramente",
                                    "Confundir v e v'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Limite lim_{h→0} L[v; h]",
                                  "subSteps": [
                                    "Estabeleça que para v suave, L[v; h] deve tender a zero quando h→0 para consistência.",
                                    "Mostre que lim_{h→0} L[v; h] / h = [ρ'(1) - σ(1)] v'(t) + termos de ordem superior.",
                                    "Derive as condições necessárias: ρ(1) = 0 e ρ'(1) = σ(1) para que o limite seja zero na ordem 1.",
                                    "Generalize para consistência de ordem p: condições nos momentos até p.",
                                    "Teste numericamente o limite para um método consistente vs. inconsistente."
                                  ],
                                  "verification": "Compute lim_{h→0} L[v; h] para uma função v(t) suave e verifique se equals f(t,v).",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para limites numéricos",
                                    "Função teste v(t) = sin(t), f(t,v)=cos(t)"
                                  ],
                                  "tips": "Use L'Hôpital se necessário para limites; foque em coeficientes em ζ=1.",
                                  "learningObjective": "Entender o papel do limite na definição de consistência.",
                                  "commonMistakes": [
                                    "Esquecer dividir por h",
                                    "ρ(1) ≠ 0 levando a limite infinito",
                                    "Não diferenciar ρ corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Definir Consistência Completa",
                                  "subSteps": [
                                    "Enuncie a definição: Um método é consistente se lim_{h→0} L[v; h] = 0 para toda solução suave v do PVI.",
                                    "Verifique equivalentemente pelas condições polinomiais: ρ(1)=0, ρ'(1)=σ(1).",
                                    "Discuta implicações para convergência (consistência + estabilidade).",
                                    "Aplique a um método multistep exemplo, como Adams-Moulton de ordem 2.",
                                    "Resuma em um fluxograma: dado método → ρ,σ → cheque condições → consistente?",
                                    "verification: "
                                  ],
                                  "verification": "Classifique 3 métodos como consistentes ou não, justificando com cálculos.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Lista de métodos multistep padrão",
                                    "Tabela para checagem de condições"
                                  ],
                                  "tips": "Lembre: consistência é pré-requisito para convergência pelo teorema de Dahlquist.",
                                  "learningObjective": "Definir e verificar consistência usando polinômios e limites.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Ignorar soluções suaves",
                                    "Erros aritméticos em ρ(1)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método trapezoidal: y_{n+1} - y_n - (h/2)(f_{n+1} + f_n) = 0. Então ρ(ζ)=ζ-1, σ(ζ)=(ζ+1)/2. Verifique ρ(1)=0, ρ'(ζ)=1, ρ'(1)=1=σ(1). Compute lim h→0 L[sin(t);h](t_n) = 0, confirmando consistência.",
                              "finalVerifications": [
                                "Define corretamente ρ(ζ) e σ(ζ) para um método multistep dado.",
                                "Deriva o limite lim h→0 L[v;h] mostrando termos principais.",
                                "Verifica as condições ρ(1)=0 e ρ'(1)=σ(1) com cálculos precisos.",
                                "Explica o impacto da consistência em soluções suaves v(t).",
                                "Classifica um método desconhecido como consistente ou não.",
                                "Conecta consistência à convergência numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de polinômios ρ e σ (30%)",
                                "Correção na expansão de Taylor e limite h→0 (25%)",
                                "Aplicação correta das condições de consistência (20%)",
                                "Uso de exemplos práticos e verificações (15%)",
                                "Clareza na explicação e avoidance de erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDOs em mecânica (ex: osciladores harmônicos).",
                                "Computação: Implementação numérica em Python/SciPy para testes de consistência.",
                                "Engenharia: Simulações de sistemas dinâmicos em controle automático.",
                                "Estatística: Análise de erros em métodos numéricos probabilísticos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou dinâmicas de fluidos, métodos multistep consistentes garantem que soluções numéricas aproximem fielmente as soluções exatas quando o passo h é pequeno, evitando erros acumulados em previsões de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.1.2",
                            "name": "Verificar critério de convergência",
                            "description": "Demonstrar que consistência e estabilidade zero implicam convergência global, usando o teorema de Dahlby para métodos lineares multistep.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Consistência e Estabilidade Zero",
                                  "subSteps": [
                                    "Defina consistência para métodos lineares multistep (LMMs): ρ(ζ)/ζ → 0 e σ(ζ)/ζ → 1 quando ζ → ∞, onde ρ e σ são polinômios de ordem p.",
                                    "Explique estabilidade zero: raízes de ρ(ζ) = 0 têm |ζ| ≤ 1, com raízes simples em |ζ| = 1.",
                                    "Discuta ordem de consistência e sua relação com a ordem p do método.",
                                    "Compare com métodos de um passo, destacando diferenças em LMMs.",
                                    "Esboce condições necessárias para convergência global."
                                  ],
                                  "verification": "Escreva definições precisas e verifique com fórmulas corretas em um caderno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e caneta, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Use notação padrão: método geral ∑ α_j y_{n+j} - ∑ β_j y_{n+j-1} = h ∑ γ_j f(t_{n+j}, y_{n+j}).",
                                  "learningObjective": "Compreender as bases teóricas de consistência e estabilidade zero em LMMs.",
                                  "commonMistakes": "Confundir estabilidade zero com estabilidade A(α); ignorar multiplicidade de raízes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema de Dahlby",
                                  "subSteps": [
                                    "Enuncie o teorema: Para LMMs consistentes e zero-estáveis aplicados a y' = f(t,y) Lipschitz, o erro global é O(h^p) se ordem p.",
                                    "Analise prova: decomposição em erro local e propagação via estabilidade zero.",
                                    "Derive condições: mostre que truncagem local τ_n = O(h^{p+1}) implica erro global pela estabilidade.",
                                    "Discuta hipóteses: f Lipschitz, solução suave, h pequeno o suficiente.",
                                    "Identifique limitações: não vale para ordem zero ou inconsistentes."
                                  ],
                                  "verification": "Reescreva o teorema e esboce prova em 5-7 linhas, conferindo com referência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula ou paper sobre Dahlby/Dahlquist, software LaTeX para fórmulas.",
                                  "tips": "Foquem na estimativa ||e_n|| ≤ C max |τ_k| pela zero-estabilidade.",
                                  "learningObjective": "Dominar enunciação e essência da prova do teorema.",
                                  "commonMistakes": "Omitir Lipschitz ou assumir estabilidade forte desnecessária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Implicação Consistência + Estabilidade Zero → Convergência",
                                  "subSteps": [
                                    "Assuma consistência (ordem ≥1) e zero-estabilidade.",
                                    "Mostre truncagem local O(h^{p+1}) pela consistência.",
                                    "Use zero-estabilidade para bound no erro acumulado: ||e_n|| ≤ K h^p.",
                                    "Conclua convergência global quando h → 0.",
                                    "Generalize para problema de valor inicial y' = f(t,y), y(a)=b."
                                  ],
                                  "verification": "Derive inequação de erro passo a passo e verifique limites.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel quadriculado, lápis para rascunhos, referência teórica.",
                                  "tips": "Use norma máximo e teorema de ponto fixo para resolver recursão de erro.",
                                  "learningObjective": "Provar logicamente a implicação central do teorema.",
                                  "commonMistakes": "Erros em somatórios de erros locais; ignorar fator h na propagação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar com Exemplo Numérico",
                                  "subSteps": [
                                    "Escolha LMM: Adams-Bashforth de ordem 2 (consistente, zero-estável).",
                                    "Verifique consistência: compute ρ(ζ) = ζ^2 - ζ, σ(ζ)= (3/2)ζ^2 - ζ.",
                                    "Confirme zero-estabilidade: raízes ρ simples, |raízes|≤1.",
                                    "Simule numéricamente y'= -y, y(0)=1, compare com exata e meça erro.",
                                    "Analise convergência: plote erro vs h."
                                  ],
                                  "verification": "Erro < 10^{-4} para h=0.01 e prova de redução com h menor.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com SciPy para simulação, gráfico de erro.",
                                  "tips": "Use h=0.1,0.05,...,0.001; log-log plot para ordem.",
                                  "learningObjective": "Validar teorema empiricamente.",
                                  "commonMistakes": "Método instável escolhido; escala errada em plots."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Testar Critérios",
                                  "subSteps": [
                                    "Resuma: consistência garante precisão local, zero-estabilidade global.",
                                    "Teste contraponto: método inconsistente (ex: ρ=1, σ=0) não converge.",
                                    "Discuta extensões: convergência forte vs fraca.",
                                    "Registre verificações finais.",
                                    "Prepare relatório com provas e simulações."
                                  ],
                                  "verification": "Checklist completo: definições, prova, exemplo convergente/inconvergente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documento Word/LaTeX para relatório.",
                                  "tips": "Inclua figuras de plots para clareza.",
                                  "learningObjective": "Integrar teoria e prática na verificação.",
                                  "commonMistakes": "Pular contratexemplos; conclusões precipitadas."
                                }
                              ],
                              "practicalExample": "Para o método Adams-Bashforth de ordem 2 em y' = -y, y(0)=1: verifique ρ(ζ)=ζ^2 - ζ (zero-estável), consistência ordem 2 via expansão de Taylor de σ, simule com h=0.1 obtendo erro ~10^{-3}, confirmando convergência O(h^2).",
                              "finalVerifications": [
                                "Definições de consistência e zero-estabilidade corretas com fórmulas.",
                                "Enunciação precisa do teorema de Dahlby.",
                                "Prova da implicação com bounds de erro explícitos.",
                                "Exemplo numérico com simulação e plot de convergência.",
                                "Contratexemplo de falha sem consistência.",
                                "Relatório sintetizando todos os elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas definições e prova (90% correto).",
                                "Clareza na derivação de erros locais/globais.",
                                "Correção no exemplo numérico e análise de ordem.",
                                "Uso adequado de ferramentas computacionais.",
                                "Profundidade nas conexões teóricas.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de EDOs em dinâmica (ex: osciladores).",
                                "Computação: Implementação de solvers em SciPy/ODEPACK.",
                                "Engenharia: Modelagem de circuitos RLC com métodos multistep.",
                                "Estatística: Análise de erro em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, usa-se LMMs como em modelos ECMWF para integrar EDOs de fluidos, onde consistência e zero-estabilidade garantem precisão global em forecasts de longo prazo, evitando divergência numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.1.3",
                            "name": "Calcular ordem de consistência",
                            "description": "Determinar a ordem de um método multistep comparando os coeficientes de Taylor das condições de consistência de ordem p.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma geral do método multistep e condições de consistência",
                                  "subSteps": [
                                    "Escreva a forma geral do método multistep linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Lembre as condições de consistência C(r): ∑_{j=0}^k α_j = 0 para r=0; ∑_{j=0}^k j^i (α_j - β_j) = 0 para i=1 a r; com normalização α_k=1.",
                                    "Identifique o método específico a analisar, seus coeficientes α_j e β_j.",
                                    "Expanda conceitualmente y(t_{n+j}) e f(t_{n+j}, y_{n+j}) em séries de Taylor ao redor de t_n.",
                                    "Defina o problema de valor inicial y' = f(t,y), y(t_0)=y_0."
                                  ],
                                  "verification": "Confirme que as condições C(0) estão claras e os coeficientes do método estão corretamente listados em uma tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, livro de análise numérica ou notas de aula sobre métodos multistep.",
                                  "tips": "Sempre normalize o método dividindo pelos coeficientes para α_k=1 e β_k ajustado.",
                                  "learningObjective": "Compreender a estrutura matemática das condições de consistência de ordem p.",
                                  "commonMistakes": "Esquecer a normalização α_k=1 ou confundir α_j com β_j."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar expansões de Taylor para y_{n+j} e f_{n+j}",
                                  "subSteps": [
                                    "Expanda y(t_n + j h) = y_n + j h y'_n + (j h)^2 / 2! y''_n + ... + (j h)^p / p! y^{(p)}_n + O(h^{p+1}).",
                                    "Como y' = f, y'' = f_t + f_y f, y''' = derivadas de ordem superior usando faixas de Lie ou recursão.",
                                    "Expanda f(t_{n+j}, y_{n+j}) similarmente: f_n + j h (f_t + f_y f)_n + ... até ordem p+1.",
                                    "Escreva as expansões truncadas até O(h^{p+1}) para ambos os lados do método.",
                                    "Substitua y^{(i)}_n em termos de f e suas derivadas parciais."
                                  ],
                                  "verification": "Verifique que as expansões coincidem com a solução exata até a ordem desejada comparando coeficientes iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora para derivadas simbólicas, software como SymPy ou Mathematica (opcional).",
                                  "tips": "Use notação compacta: defina c_i^{(j)} como o coeficiente de h^i / i! na expansão de y_{n+j}.",
                                  "learningObjective": "Dominar a geração de séries de Taylor para soluções de EDOs e funções compostas.",
                                  "commonMistakes": "Erro no cálculo de derivadas de ordem superior, como esquecer o produto na cadeia para y''."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir expansões no método e coletar termos por potências de h",
                                  "subSteps": [
                                    "Substitua as expansões no lado esquerdo: ∑ α_j y_{n+j} = ∑ α_j ∑_{i=0}^{p+1} (j h)^i / i! y^{(i)}_n.",
                                    "Intercale: h ∑ β_j f_{n+j} similarmente.",
                                    "Colete coeficientes para cada potência h^r / r! para r=0 a p+1: ∑ α_j j^r - ∑ β_j b_j^{(r)} = 0, onde b são coefs de f.",
                                    "Simplifique usando condições C(r): para r=0: ∑ α_j=0; para r>=1: ∑ α_j j^r = ∑ β_j ∑_{s=0}^r (j^s / s!) * coefs de derivadas.",
                                    "Calcule numericamente para o método específico até falhar."
                                  ],
                                  "verification": "Tabela de coeficientes por ordem r mostra zeros até p e não-zero em p+1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou software para somas simbólicas, papel quadriculado para tabelas.",
                                  "tips": "Comece com ordens baixas (r=0,1) para validar antes de ordens altas.",
                                  "learningObjective": "Aplicar expansões para verificar satisfação das condições C(r).",
                                  "commonMistakes": "Índices errados em j^r ou normalização inconsistente nos coeficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a ordem de consistência p e validar",
                                  "subSteps": [
                                    "Verifique C(0) a C(p) satisfeitas (coeficientes zero).",
                                    "Identifique a menor r onde C(r) falha: ordem de consistência é p = r-1.",
                                    "Para métodos explícitos/implícitos, note se zero-stability afeta.",
                                    "Teste com um EDO linear simples para confirmar numericamente.",
                                    "Documente a ordem p e justifique com os cálculos."
                                  ],
                                  "verification": "Declaração clara: 'O método tem ordem de consistência p=...' com evidência dos coeficientes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código simples em Python/MATLAB para teste numérico (opcional).",
                                  "tips": "Ordens altas requerem automação; foque em p até 4 para mão.",
                                  "learningObjective": "Concluir a ordem comparando sistematicamente as condições.",
                                  "commonMistakes": "Confundir ordem de consistência com ordem de precisão local/global."
                                }
                              ],
                              "practicalExample": "Para o método Adams-Bashforth de ordem 2: y_{n+1} = y_n + (h/2)(3 f_n - f_{n-1}). Coeficientes: α_0=1, α_1=-1, α_{-1}=0 (ajustar índices); β_0=3/2, β_1=0, β_{-1}=-1/2. Expansões mostram C(0), C(1), C(2) satisfeitas, C(3) falha → ordem p=2.",
                              "finalVerifications": [
                                "Condições C(0) até C(p) resultam em coeficientes zero.",
                                "Coeficiente de h^{p+1}/(p+1)! é não-zero.",
                                "Expansões de Taylor derivadas corretamente até ordem p+1.",
                                "Normalização do método confirmada (α_k=1).",
                                "Teste numérico com EDO y'=y, y(0)=1 mostra erro O(h^{p+1}).",
                                "Tabela de coeficientes completa e sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas de Taylor e expansões (sem erros simbólicos).",
                                "Correta coleta e comparação de coeficientes por ordem.",
                                "Identificação clara da ordem p com justificativa.",
                                "Uso apropriado de notação matemática e tabelas.",
                                "Validação numérica ou conceitual adicional.",
                                "Ausência de confusão entre consistência, estabilidade e convergência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar métodos em Python com SciPy para verificação numérica.",
                                "Física: Aplicar em simulações de osciladores harmônicos ou trajetórias.",
                                "Engenharia Computacional: Otimização de solvers em CFD ou circuitos.",
                                "Estatística: Análise de erro em simulações estocásticas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) ou previsão do tempo, calcular ordem de consistência garante precisão em integradores multistep para EDOs de alta dimensão, otimizando trade-off entre custo computacional e erro de truncamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.1.2",
                        "name": "Ordem dos Métodos de Passo Múltiplo",
                        "description": "Determinação da ordem de precisão local e global dos métodos lineares multistep, incluindo métodos de ordem elevada como Adams e BDF.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.2.1",
                            "name": "Calcular ordem local de um método multistep",
                            "description": "Usar as condições de ordem p para encontrar a ordem máxima de métodos multistep lineares implícitos e explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição de Métodos Multistep e Ordem Local",
                                  "subSteps": [
                                    "Leia a fórmula geral de um método multistep linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Identifique métodos explícitos (β_k = 0) e implícitos (β_k ≠ 0).",
                                    "Estude a definição de truncamento local τ_{n+1}, que mede o erro local por passo.",
                                    "Entenda que a ordem p significa |τ_{n+1}| ≤ M h^{p+1}.",
                                    "Anote exemplos clássicos como Adams-Bashforth (explícito) e Adams-Moulton (implícito)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando ordem local em suas palavras e dê um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de Análise Numérica I",
                                    "Livro 'Análise Numérica' de Burden & Faires (Cap. Métodos Multistep)",
                                    "Folha de papel para anotações"
                                  ],
                                  "tips": "Destaque a diferença entre truncamento local (por passo) e erro global (acumulado).",
                                  "learningObjective": "Compreender a estrutura geral dos métodos multistep e o conceito de ordem local de truncamento.",
                                  "commonMistakes": [
                                    "Confundir ordem local com ordem global",
                                    "Ignorar a distinção entre métodos explícitos e implícitos",
                                    "Esquecer o papel do passo h na análise"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar as Condições de Ordem p",
                                  "subSteps": [
                                    "Derive as condições de ordem 0: ∑ α_j = 0.",
                                    "Derive ordem 1: ∑ j α_j = 0 e ∑ β_j = 1.",
                                    "Geralize para ordem p: usar expansões de Taylor de y_{n+j} e f_{n+j} até ordem p+1.",
                                    "Escreva as k+1 condições lineares para os coeficientes α e β.",
                                    "Note que para ordem > k, nem sempre possível devido a k+1 coeficientes livres."
                                  ],
                                  "verification": "Liste as condições de ordem 1, 2 e 3 para um método genérico de k=2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cálculo I/II para séries de Taylor",
                                    "Software simbólico como SymPy ou Mathematica para verificação",
                                    "Quadro branco ou papel quadriculado"
                                  ],
                                  "tips": "Use séries de Taylor centradas em t_n para consistência nas derivações.",
                                  "learningObjective": "Dominar as condições algébricas que definem a ordem p de um método multistep.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes de Taylor para f (use y' = f)",
                                    "Confundir índices j em somas",
                                    "Esquecer fator h nas condições de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar o Sistema para um Método Específico",
                                  "subSteps": [
                                    "Escolha um método exemplo: k=2 explícito, como Adams-Bashforth de ordem 2.",
                                    "Escreva α_0, α_1, α_2 e β_0, β_1, β_2 conhecidos ou livres.",
                                    "Monte o sistema de equações das condições de ordem até p=k+1.",
                                    "Para implícito, inclua β_2 ≠ 0 e verifique solvibilidade.",
                                    "Resolva o sistema linear passo a passo, eliminando variáveis."
                                  ],
                                  "verification": "Configure e resolva o sistema para encontrar coeficientes que satisfazem ordem 2 em k=1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matriz para sistema linear (papel ou Excel)",
                                    "Exemplos de Burden & Faires pg. 300-320",
                                    "Calculadora ou Python para resolver Ax=b"
                                  ],
                                  "tips": "Comece com ordem baixa e incremente para ver o padrão.",
                                  "learningObjective": "Aplicar condições de ordem para configurar e resolver sistemas lineares específicos.",
                                  "commonMistakes": [
                                    "Sistema subdeterminado para p > k",
                                    "Erros aritméticos em somas ponderadas",
                                    "Confundir α e β nas condições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Ordem Máxima e Verificar",
                                  "subSteps": [
                                    "Identifique a maior p onde todas condições até p são satisfeitas.",
                                    "Para método dado, compute truncamento local τ explicitamente via Taylor.",
                                    "Compare ordem máxima teórica com métodos padrão (e.g., AB4 ordem 4).",
                                    "Teste numéricamente com y' = f simples (e.g., y'=y, solução exata e^{t}).",
                                    "Discuta limitações: ordem máxima geralmente k para explícitos, k+1 para implícitos."
                                  ],
                                  "verification": "Calcule ordem máxima para método dado e confirme com τ = O(h^{p+1}).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para teste numérico",
                                    "Tabela de métodos multistep padrão",
                                    "Gráfica de erro vs h (log-log)"
                                  ],
                                  "tips": "Use plot log-log de erro local vs h para visualizar ordem p.",
                                  "learningObjective": "Calcular e validar a ordem máxima local de métodos multistep explícitos e implícitos.",
                                  "commonMistakes": [
                                    "Achar ordem > k+1 possível",
                                    "Ignorar dependência em k",
                                    "Erro em normalização das condições"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método multistep explícito de k=2: α = [-3/2, 4/2, -1/2], β = [0, 5/12, -1/12, 0]? Não, exemplo padrão Adams-Bashforth ordem 2: y_{n+2} - y_{n+1} = (3/2 f_{n+1} - 1/2 f_n) h. Verifique condições: ordem 2 satisfeita, ordem 3 falha pois sistema inconsistente.",
                              "finalVerifications": [
                                "Derivar corretamente condições de ordem até p=3 para k=2.",
                                "Resolver sistema linear para coeficientes e identificar ordem máxima.",
                                "Calcular τ_{n+1} via Taylor e confirmar O(h^{p+1}).",
                                "Comparar com método padrão e explicar por que ordem máxima é k ou k+1.",
                                "Implementar teste numérico simples e plotar convergência.",
                                "Explicar impacto em métodos implícitos vs explícitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivações de Taylor e condições de ordem (100% correto).",
                                "Correta resolução de sistemas lineares sem erros aritméticos.",
                                "Identificação precisa da ordem máxima com justificativa.",
                                "Validação numérica com gráfico log-log mostrando inclinação p.",
                                "Explicação clara de limitações explícito/implícito.",
                                "Uso adequado de notação matemática consistente."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar métodos em Python/NumPy para análise de erro.",
                                "Física Computacional: Aplicar em EDOs de mecânica (e.g., oscilador harmônico).",
                                "Engenharia: Otimização de solvers em simulações CFD.",
                                "Estatística: Análise de erro em métodos de Monte Carlo para EDOs estocásticas."
                              ],
                              "realWorldApplication": "Em softwares de simulação como MATLAB ODE solvers ou previsão numérica do tempo (modelos ECMWF), calcular ordem local otimiza escolha de método multistep para precisão vs custo computacional em problemas de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.2.2",
                            "name": "Analisar relação entre ordem e estabilidade",
                            "description": "Explicar como a ordem afeta a precisão global e os requisitos de estabilidade para problemas não stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Ordem e Estabilidade em Métodos Multistep",
                                  "subSteps": [
                                    "Relembrar a definição de ordem p de um método multistep: consistência local com erro O(h^{p+1}).",
                                    "Explicar estabilidade absoluta: região onde |R(z)| ≤ 1 para z = hλ no semiplano esquerdo.",
                                    "Identificar a característica polinomial ρ(r) e σ(r) para métodos lineares multistep.",
                                    "Discutir o papel do polinômio de estabilidade R(z) = ρ(z)/σ(z).",
                                    "Listar exemplos: Adams-Bashforth (explícito) vs BDF (implícito)."
                                  ],
                                  "verification": "Escrever definições precisas e exemplos de ρ(r) para métodos de ordem 2 e 3.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Desenhe os polinômios no papel para visualizar raízes.",
                                  "learningObjective": "Dominar terminologia e fórmulas fundamentais de ordem e estabilidade.",
                                  "commonMistakes": "Confundir ordem local com ordem global; ignorar diferença entre explícito e implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Matematicamente a Relação Ordem-Estabilidade",
                                  "subSteps": [
                                    "Derivar R(z) para Adams-Bashforth de ordem k=2,3,4 e plotar |R(z)| no plano complexo.",
                                    "Comparar o raio da região de estabilidade: mostrar que ordem mais alta reduz o raio para métodos explícitos.",
                                    "Analisar o teorema de Dahlquist: ordem ≤ 2 para métodos A-estáveis explícitos.",
                                    "Calcular o comprimento máximo de h para estabilidade: h < 1.5/|λ| para ordem 2 vs h < 0.9/|λ| para ordem 4.",
                                    "Examinar trade-off: precisão global melhora com p, mas estabilidade piora."
                                  ],
                                  "verification": "Plotar regiões de estabilidade e anotar mudanças com ordem crescente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python com Matplotlib/Control), papel quadriculado.",
                                  "tips": "Use z = hλ com Re(λ)<0; foque em |R(e^{iθ})| para estabilidade relativa.",
                                  "learningObjective": "Quantificar como ordem alta restringe a região de estabilidade.",
                                  "commonMistakes": "Esquecer normalização de σ(z); plotar apenas eixo real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Análise a Problemas Não-Stiff",
                                  "subSteps": [
                                    "Definir problema não-stiff: |λ| pequeno, Re(λ)<0 moderado.",
                                    "Simular y' = -λy com λ=1 (não-stiff) usando AB2 e AB4; medir erro vs h.",
                                    "Identificar que para não-stiff, ordem alta permite h maior para precisão, apesar de estabilidade menor.",
                                    "Comparar requisitos: ordem alta precisa h menor para estabilidade, mas ganho em precisão compensa.",
                                    "Testar numericamente: variar h até instabilidade e registrar thresholds."
                                  ],
                                  "verification": "Gerar tabela de erros e h_max para diferentes ordens.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/Julia com solvers numéricos (scipy.integrate, DifferentialEquations.jl), dataset de teste.",
                                  "tips": "Use h adaptativo inicialmente para benchmark.",
                                  "learningObjective": "Entender por que ordem alta é preferível em não-stiff apesar de trade-off.",
                                  "commonMistakes": "Usar λ grande (stiff); ignorar truncamento vs propagação de erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Concluir Requisitos de Estabilidade",
                                  "subSteps": [
                                    "Resumir: ordem p aumenta precisão mas encolhe região de estabilidade explícita.",
                                    "Para não-stiff: priorize ordem alta com h escolhido para estabilidade.",
                                    "Discutir heurística: h ≈ min(estabilidade, precisão desejada).",
                                    "Comparar com métodos de Runge-Kutta: similar trade-off.",
                                    "Formular regra: para não-stiff, use AB de ordem 4-5 com monitoramento de estabilidade."
                                  ],
                                  "verification": "Escrever parágrafo explicando relação e recomendação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de resumo, exemplos de código.",
                                  "tips": "Use analogia: ordem = aceleração, estabilidade = freio.",
                                  "learningObjective": "Aplicar análise para decisões práticas em escolha de métodos.",
                                  "commonMistakes": "Generalizar para stiff sem qualificar."
                                }
                              ],
                              "practicalExample": "Considere resolver y' = -y + sin(t), y(0)=1 (não-stiff, λ≈1). Use Adams-Bashforth ordem 2 vs 4 com h=0.1. Ordem 4 dá erro global 10x menor, mas com h=0.5 ordem 4 oscila (instável) enquanto ordem 2 permanece estável. Ajuste h=0.3 para ordem 4: precisão superior sem perda de estabilidade.",
                              "finalVerifications": [
                                "Explicar verbalmente por que ordem alta reduz região de estabilidade explícita.",
                                "Plotar R(z) para AB3 e identificar raio de estabilidade.",
                                "Simular problema não-stiff e prever h_max corretamente.",
                                "Comparar erros locais/globais para ordens 2 e 4.",
                                "Formular requisito: 'Para não-stiff, ordem > estabilidade absoluta.'",
                                "Identificar limitação Dahlquist em contexto."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de R(z) e ordem (90%+ correto).",
                                "Correta identificação de trade-offs com gráficos quantitativos.",
                                "Aplicação contextualizada a não-stiff vs stiff.",
                                "Uso de terminologia padrão (ρ, σ, A-estável).",
                                "Análise numérica com tabelas/plots reproduzíveis.",
                                "Recomendações práticas baseadas em evidências."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores harmônicos (eq. de movimento).",
                                "Computação: Implementação eficiente de solvers em Python/Julia para ODEs.",
                                "Engenharia: Modelagem de circuitos RC não-stiff em controle de sistemas.",
                                "Estatística: Análise de erro em séries temporais numéricas."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de atmosfera não-stiff), métodos de alta ordem como AB5 aceleram computações com h maior para precisão, mantendo estabilidade via monitoramento, reduzindo tempo de simulação de dias para horas em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2.3",
                            "name": "Comparar ordens de métodos específicos",
                            "description": "Comparar a ordem de métodos Adams-Bashforth, Adams-Moulton e BDF, calculando erros locais truncados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as fórmulas e ordens conhecidas dos métodos",
                                  "subSteps": [
                                    "Estudar a fórmula geral do Adams-Bashforth de ordem k: y_{n+1} = y_n + h ∑_{j=0}^k β_j f(t_{n-j}, y_{n-j})",
                                    "Analisar a fórmula do Adams-Moulton de ordem k: y_{n+1} = y_n + h (γ_0 f(t_{n+1}, y_{n+1}) + ∑_{j=1}^k γ_j f(t_{n+1-j}, y_{n+1-j}))",
                                    "Examinar a fórmula do BDF de ordem k: ∑_{j=0}^k α_j y_{n+1-j} = h β_k f(t_{n+1}, y_{n+1})",
                                    "Listar as ordens padrão: AB_k (ordem k), AM_k (ordem k+1), BDF_k (ordem k)",
                                    "Identificar diferenças: AB explícito, AM e BDF implícitos"
                                  ],
                                  "verification": "Escrever corretamente as fórmulas para k=2 e listar ordens sem consultar materiais",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos multistep",
                                    "Tabela de coeficientes de Adams e BDF"
                                  ],
                                  "tips": "Memorize os coeficientes para ordens baixas (k=1,2,3) usando tabelas padrão para facilitar derivações posteriores",
                                  "learningObjective": "Compreender as estruturas matemáticas e ordens de precisão inerentes a cada método",
                                  "commonMistakes": [
                                    "Confundir os coeficientes β e γ entre AB e AM",
                                    "Esquecer que AM tem ordem k+1 enquanto AB e BDF têm ordem k",
                                    "Ignorar a natureza implícita de AM e BDF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar e derivar o erro local truncado (LTE) geral",
                                  "subSteps": [
                                    "Recordar que LTE é o erro assumindo y_n exato, medido em um passo: τ_{n+1} = [y(t_{n+1}) - y_{n+1}] / h",
                                    "Derivar LTE usando expansão de Taylor da solução exata y(t) em torno de t_n",
                                    "Expandir f(t,y) e suas derivadas para obter os termos de ordem h^{k+1}",
                                    "Generalizar LTE para métodos lineares multistep: τ = (1/h) [∑ α_j y(t_{n+1-j}) - h β_j y'(t_{n+1-j}) ] ≈ C h^k y^{(k+1)}(ξ)",
                                    "Verificar LTE para método de Euler (k=1) como exemplo base"
                                  ],
                                  "verification": "Derivar LTE para Euler e Trapezoidal, confirmando ordens 1 e 2 respectivamente",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Software simbólico como SymPy ou Mathematica para Taylor",
                                    "Referência: Hairer et al. 'Solving ODEs I'"
                                  ],
                                  "tips": "Use a forma de diferença finita para simplificar expansões de Taylor em operadores de avanço e atraso",
                                  "learningObjective": "Dominar a derivação analítica do LTE para métodos multistep genéricos",
                                  "commonMistakes": [
                                    "Parar a expansão de Taylor prematuramente (menos que k+2 termos)",
                                    "Confundir LTE local com erro global acumulado",
                                    "Esquecer o fator 1/h na definição de τ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular LTE específico para AB, AM e BDF",
                                  "subSteps": [
                                    "Calcular coeficientes exatos para AB_2, AM_2 e BDF_2 usando tabelas ou derivação",
                                    "Derivar LTE para AB_k: τ = (k+1)!^{-1} ∇^{k+1} y(t_n) / h^k + O(h^{k+1})",
                                    "Derivar LTE para AM_k: similar, mas com ordem k+1 devido ao termo implícito",
                                    "Derivar LTE para BDF_k: focar no operador de diferença backward, τ ≈ - (k+1)^{-1} Δ^{k+1} y(t_{n+1}) / h^k",
                                    "Comparar coeficientes de erro principais numéricamente para k=2"
                                  ],
                                  "verification": "Obter expressões LTE explícitas para k=2 e calcular coeficiente numérico para y''=constante",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de coeficientes (Wikipedia ou Burden)",
                                    "Calculadora ou Python para coeficientes simbólicos",
                                    "Papel para álgebra"
                                  ],
                                  "tips": "Use o polinômio interpolador de Newton backward para BDF e forward para AB/AM para automatizar",
                                  "learningObjective": "Computar e expressar LTEs precisos para os métodos específicos",
                                  "commonMistakes": [
                                    "Erro nos sinais dos coeficientes de LTE",
                                    "Confundir forward/backward differences",
                                    "Ignorar dependência em y^{(k+1)}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ordens, LTEs e implicações práticas",
                                  "subSteps": [
                                    "Tabular ordens: AB_k: k, AM_k: k+1, BDF_k: k",
                                    "Comparar magnitudes de coeficientes LTE para problema modelo y'=-y",
                                    "Discutir impacto: AM mais preciso por passo, mas requer solver não-linear; BDF A-estável para stiff",
                                    "Analisar trade-offs: custo computacional vs precisão por passo",
                                    "Simular numericamente LTE em código para validação"
                                  ],
                                  "verification": "Criar tabela comparativa e plotar log(|LTE|) vs log(h) para confirmar ordens",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB com ode solvers",
                                    "Problema teste: y'=λy, Re(λ)<0"
                                  ],
                                  "tips": "Use h pequeno e passos exatos para isolar LTE; compare com solução analítica",
                                  "learningObjective": "Sintetizar comparações quantitativas e qualitativas entre os métodos",
                                  "commonMistakes": [
                                    "Sobreestimar ordem de BDF em problemas stiff",
                                    "Ignorar custo de iterações em implícitos",
                                    "Comparar sem normalizar por custo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -y, y(0)=1 (solução y=e^{-t}), implemente AB_2, AM_2 e BDF_2 com h=0.1 em [0,1]. Calcule LTE em t=1 comparando com exata, confirmando ordens 2,3,2 e coeficientes aproximados: AB_2 LTE ~ 0.55 h^3 y''', AM_2 ~ -0.31 h^4 y^{(4)}, BDF_2 ~ 2/3 h^3 y'''",
                              "finalVerifications": [
                                "Listar corretamente ordens: AB_k (k), AM_k (k+1), BDF_k (k)",
                                "Derivar LTE para pelo menos um método de ordem 2 sem erros",
                                "Comparar numericamente LTEs em tabela para k=2",
                                "Explicar por que AM é mais preciso mas computacionalmente caro",
                                "Identificar cenários onde BDF supera AB apesar da mesma ordem",
                                "Plotar confirmação de ordem via log-log"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas e ordens (100% correto)",
                                "Correção matemática nas derivações de LTE (coeficientes exatos)",
                                "Profundidade na comparação quantitativa (tabelas/números)",
                                "Análise qualitativa de trade-offs (estabilidade, custo)",
                                "Validação numérica com código ou cálculos manuais",
                                "Clareza na comunicação via tabelas/plots"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar métodos em Python/Scipy para simulação",
                                "Física: Aplicar em modelagem de osciladores amortecidos ou circuitos RLC",
                                "Engenharia: Análise de estabilidade em controle de sistemas dinâmicos",
                                "Estatística: Comparar com métodos Monte Carlo para erros em simulações estocásticas"
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular (BDF para stiff), previsão meteorológica (AM para precisão em não-stiff), ou modelagem financeira de opções (multistep para eficiência em ODEs de Black-Scholes), onde escolher método baseado em ordem/LTE otimiza precisão vs tempo computacional em supercomputadores"
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.1.3",
                        "name": "Estabilidade e Região de Estabilidade",
                        "description": "Análise de estabilidade absoluta para métodos multistep, incluindo a região de estabilidade no plano complexo e implicações para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.3.1",
                            "name": "Definir estabilidade zero e absoluta",
                            "description": "Explicar estabilidade zero via ρ(1)=σ(1)=0 e estabilidade absoluta para o teste y' = λy com Re(λ)<0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Polinômios Característicos ρ(z) e σ(z) em Métodos Lineares Multistep",
                                  "subSteps": [
                                    "Recordar a forma geral de um método linear multistep: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Derivar os polinômios ρ(z) = ∑_{j=0}^k α_j z^j e σ(z) = ∑_{j=0}^k β_j z^j.",
                                    "Exemplificar com o método de Backward Differentiation Formula (BDF1): ρ(z) = z - 1, σ(z) = 1.",
                                    "Verificar consistência básica: ρ(1) = 0 e σ'(1) = 1.",
                                    "Plotar ou analisar graficamente ρ(z) e σ(z) para métodos simples."
                                  ],
                                  "verification": "Calcular ρ(z) e σ(z) corretamente para um método dado, como Adams-Bashforth de ordem 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e lápis, calculadora ou software como MATLAB para plotagem.",
                                  "tips": "Sempre normalize os polinômios para que o grau de ρ seja k e leading coefficient 1.",
                                  "learningObjective": "Entender a origem e representação dos polinômios de estabilidade em métodos multistep.",
                                  "commonMistakes": "Confundir os coeficientes α_j com β_j ou inverter os índices j."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Demonstrar Estabilidade Zero",
                                  "subSteps": [
                                    "Explicar que estabilidade zero requer ρ(1) = 0 e σ(1) = 0, garantindo consistência forte para problemas estacionários.",
                                    "Provar que ρ(1) = 0 é necessário para consistência de ordem 1.",
                                    "Demonstrar σ(1) = 0 para métodos que preservam soluções constantes (zero-stability forte).",
                                    "Calcular para exemplo: Método trapezoidal (ρ(z)=z-1, σ(z)=(z+1)/2 → ρ(1)=0, σ(1)=1 ≠0, não zero-stable forte).",
                                    "Comparar com BDF2: ρ(z)= (3/2)z^2 - 2z + 1/2, σ(z)= (3/2)z^2 - z → ambos zero em z=1."
                                  ],
                                  "verification": "Verificar ρ(1)=σ(1)=0 para dois métodos multistep e explicar implicações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de exercícios com métodos multistep, calculadora simbólica (ex: SymPy ou Mathematica).",
                                  "tips": "Use a regra de L'Hôpital para derivadas se necessário em provas de consistência.",
                                  "learningObjective": "Dominar a condição de estabilidade zero e sua verificação algébrica.",
                                  "commonMistakes": "Esquecer que σ(1)=0 é para estabilidade zero forte, não apenas ρ(1)=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o Teste Modelo y' = λy com Re(λ) < 0",
                                  "subSteps": [
                                    "Apresentar o problema de teste: y' = λy, solução exata y(t) = y(0) e^{λt}, que decai se Re(λ)<0.",
                                    "Aplicar método multistep ao teste: a rec. característica é ρ(r) - hλ σ(r) = 0.",
                                    "Explicar que para estabilidade, raízes r da equação devem satisfazer |r| ≤ 1 + O(h), com |r|=1 simples.",
                                    "Analisar numericamente para h pequeno: solução numérica deve imitar decaimento.",
                                    "Plotar região de estabilidade no plano complexo hλ."
                                  ],
                                  "verification": "Resolver a equação característica para λ=-1, h=0.1 em um método dado e checar |r_max| <1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de plotagem (MATLAB/Octave/Python com Matplotlib), exemplos impressos de testes.",
                                  "tips": "Comece com hλ pequeno para aproximação linear.",
                                  "learningObjective": "Compreender o papel do teste modelo na análise de estabilidade A-stability.",
                                  "commonMistakes": "Confundir Re(λ)<0 com λ real negativo, ignorando parte imaginária."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e Verificar Estabilidade Absoluta",
                                  "subSteps": [
                                    "Definir estabilidade absoluta: método estável para todo h>0 quando Re(λ)<0 (região inclui metade esquerda do plano complexo).",
                                    "Relacionar com Dahlquist: métodos explícitos não A-estáveis; implícitos como BDF até ordem 2 sim.",
                                    "Verificar para BDF1: ρ(r) - ζ σ(r)=0 com ζ=hλ → r=1/(1-ζ), |r|<1 para Re(ζ)<0.",
                                    "Comparar estabilidade zero vs absoluta: zero é h→0, absoluta é para h arbitrário.",
                                    "Discutir limitações: A(α)-estabilidade para rigidez."
                                  ],
                                  "verification": "Identificar métodos A-estáveis e plotar sua região de estabilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabelas de métodos multistep, software para raízes de polinômios complexos.",
                                  "tips": "Use teorema de Routh-Hurwitz para raízes dentro do círculo unitário.",
                                  "learningObjective": "Diferenciar e aplicar conceitos de estabilidade zero e absoluta.",
                                  "commonMistakes": "Achar que todos métodos consistentes são A-estáveis."
                                }
                              ],
                              "practicalExample": "Para o método BDF2 aplicado a y' = -y (λ=-1): Calcule ρ(1)=0, σ(1)=0 (zero-stable). Para h=0.5, resolva (3/2)r^2 -2r +1/2 +0.5 r^2 =0; verifique |r|<1 confirmando A-stabilidade.",
                              "finalVerifications": [
                                "Calcular corretamente ρ(1) e σ(1) para 3 métodos multistep diferentes.",
                                "Explicar verbalmente a diferença entre estabilidade zero e absoluta.",
                                "Resolver equação característica para teste y'=λy e analisar |r|.",
                                "Identificar um método A-estável e um não A-estável.",
                                "Plotar região de estabilidade básica para BDF1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ρ(z) e σ(z) (90% correto).",
                                "Compreensão conceitual: distinção clara entre zero e absoluta (rubrica 4/5).",
                                "Habilidade em resolver equações características complexas.",
                                "Aplicação correta ao teste modelo com análise de estabilidade.",
                                "Explicação de implicações práticas em simulações rígidas.",
                                "Uso adequado de grafos/regiões de estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais em mecânica (ex: osciladores amortecidos).",
                                "Engenharia: Análise de rigidez em controle de sistemas dinâmicos.",
                                "Computação: Implementação eficiente em solvers ODE como ODE45 no MATLAB.",
                                "Química: Modelagem de reações com escalas múltiplas de tempo."
                              ],
                              "realWorldApplication": "Em simulações numéricas de problemas rígidos como reações químicas ou circuitos elétricos, garante que soluções numéricas não explodam para h grande, permitindo passos de tempo eficientes em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3.2",
                            "name": "Construir região de estabilidade",
                            "description": "Calcular a região de estabilidade {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) = ρ(e^z)/σ(e^z) é a função de amplificação para métodos multistep.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e derivar a função de amplificação R(z)",
                                  "subSteps": [
                                    "Recordar as formas polinomiais ρ(ζ) e σ(ζ) para métodos multistep lineares.",
                                    "Derivar a expressão R(z) = ρ(e^z) / σ(e^z) a partir da equação característica.",
                                    "Explicar o significado de R(z) no contexto da estabilidade absoluta.",
                                    "Verificar a definição para métodos simples como Euler implícito.",
                                    "Discutir o papel de z = hλ, onde λ é autovalor da Jacobiana."
                                  ],
                                  "verification": "Capacidade de escrever corretamente R(z) para um método dado, como o de Trapezoidal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Folha de anotações",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Comece com métodos de um passo para intuitar antes de multistep.",
                                  "learningObjective": "Compreender a origem e interpretação da função de amplificação.",
                                  "commonMistakes": [
                                    "Confundir ρ e σ",
                                    "Esquecer a exponencial e^z em vez de ζ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo numérico de |R(z)|",
                                  "subSteps": [
                                    "Definir uma grade no plano complexo z = x + iy, com x < 0 (região relevante).",
                                    "Implementar ρ(e^z) e σ(e^z) em software (Python com NumPy ou MATLAB).",
                                    "Calcular |R(z)| para cada ponto da grade.",
                                    "Identificar pontos onde |R(z)| ≤ 1.",
                                    "Testar com polinômios de exemplo: ρ(ζ)=ζ-1, σ(ζ)=1 (Euler explícito)."
                                  ],
                                  "verification": "Código roda sem erros e produz valores corretos para pontos conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Complex",
                                    "MATLAB ou Jupyter Notebook",
                                    "Exemplos de código de estabilidade"
                                  ],
                                  "tips": "Use meshgrid para eficiência na grade; limite y entre -10 e 10 inicialmente.",
                                  "learningObjective": "Dominar o cálculo computacional de R(z) no plano complexo.",
                                  "commonMistakes": [
                                    "Overflow em e^z para Im(z) grande",
                                    "Erro em normalização de módulo complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e visualizar a região de estabilidade",
                                  "subSteps": [
                                    "Gerar contour plot ou filled contour onde |R(z)| = 1 delimita a fronteira.",
                                    "Preencher a região {z | |R(z)| ≤ 1} com cor.",
                                    "Analisar o eixo real negativo: encontrar o intervalo de estabilidade A(∞).",
                                    "Comparar com região de estabilidade do método de um passo associado.",
                                    "Exportar gráfico com legendas e limites apropriados."
                                  ],
                                  "verification": "Gráfico mostra corretamente a região fechada no semiplano esquerdo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas de plotting: Matplotlib (Python) ou contourf (MATLAB)",
                                    "Templates de código para regiões de estabilidade"
                                  ],
                                  "tips": "Use logscale para |R(z)| se necessário; teste resolução da grade.",
                                  "learningObjective": "Visualizar e interpretar graficamente a região de estabilidade.",
                                  "commonMistakes": [
                                    "Plotar no semiplano direito irrelevante",
                                    "Escala inadequada ocultando detalhes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar a região para diferentes métodos",
                                  "subSteps": [
                                    "Calcular regiões para métodos como Adams-Bashforth e BDF.",
                                    "Comparar tamanhos e formas (ex: BDF mais estável).",
                                    "Discutir implicações para rigidez e passos h grandes.",
                                    "Verificar consistência com teoria de Dahlquist.",
                                    "Documentar propriedades como convexidade e inclusão da meia-retreta."
                                  ],
                                  "verification": "Relatório compara pelo menos 3 métodos com conclusões corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de coeficientes multistep padrão",
                                    "Software de plotting"
                                  ],
                                  "tips": "Foco em métodos A-estáveis para contratos fortes.",
                                  "learningObjective": "Aplicar análise para seleção de métodos em problemas reais.",
                                  "commonMistakes": [
                                    "Ignorar diferença entre explícito e implícito",
                                    "Confundir ordem com estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Backward Differentiation Formula de ordem 2 (BDF2): ρ(ζ) = (3/2)ζ^2 - 2ζ + 1/2, σ(ζ) = ζ^2 - ζ. Implemente R(z), plote a região e verifique que é A-estável (inclui toda meia-retreta).",
                              "finalVerifications": [
                                "Pode derivar R(z) manualmente para qualquer método multistep dado.",
                                "Código gera plots precisos de regiões para 3 métodos diferentes.",
                                "Identifica corretamente se o método é A-estável ou A(α)-estável.",
                                "Calcula o espectro de estabilidade no eixo real.",
                                "Explica limitações da região para problemas rígidos.",
                                "Compara regiões visualmente com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z): 25%.",
                                "Corretude do código e plots: 30%.",
                                "Profundidade da análise e interpretação: 20%.",
                                "Uso adequado de ferramentas computacionais: 15%.",
                                "Clareza na documentação e exemplos: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Programação numérica com complexos e visualização (Python/MATLAB).",
                                "Física: Estabilidade em simulações de EDOs dinâmicas (ex: osciladores).",
                                "Engenharia: Análise de rigidez em modelagem de sistemas controlados.",
                                "Estatística: Barreiras de estabilidade em métodos MCMC."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais rígidas na engenharia aeroespacial (ex: estabilidade de voo) ou química (reações rápidas), onde selecionar métodos multistep com regiões amplas garante precisão sem passos minúsculos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.3.3",
                            "name": "Analisar estabilidade para problemas stiff",
                            "description": "Comparar regiões de estabilidade de métodos explícitos (pequena) vs. implícitos (A-estáveis como BDF) para equações stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas stiff e conceitos básicos de estabilidade",
                                  "subSteps": [
                                    "Definir equações diferenciais stiff: sistemas com escalas temporais muito díspares (eigenvalues com partes reais muito negativas).",
                                    "Explicar o teste de estabilidade linear: aplicar a equação modelo y' = λy com Re(λ) < 0.",
                                    "Introduzir a região de estabilidade: conjunto de hλ no plano complexo onde |R(hλ)| ≤ 1, com R o polinômio de estabilidade.",
                                    "Discutir o passo de tempo h necessário para estabilidade em problemas stiff.",
                                    "Identificar exemplos clássicos de problemas stiff, como o de química ou circuitos."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é um problema stiff e por que a estabilidade é um desafio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre PVI",
                                    "Software MATLAB ou Python (SciPy)"
                                  ],
                                  "tips": "Foquem em eigenvalues do Jacobiano para detectar stiffnes.",
                                  "learningObjective": "Dominar os fundamentos teóricos de stiff e estabilidade linear.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade",
                                    "Ignorar a dependência do h na estabilidade",
                                    "Subestimar o impacto de escalas díspares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar regiões de estabilidade de métodos explícitos",
                                  "subSteps": [
                                    "Revisar o método de Euler explícito: R(z) = 1 + z, região de estabilidade um disco pequeno no semiplano esquerdo.",
                                    "Estudar métodos Runge-Kutta explícitos (ex: RK4): regiões limitadas, não incluindo grandes |z| negativos.",
                                    "Plotar ou descrever graficamente as regiões de estabilidade para Euler e RK4.",
                                    "Simular numericamente um problema stiff com método explícito: observar oscilações ou blow-up.",
                                    "Calcular o h máximo permitido para estabilidade em λ grande negativo."
                                  ],
                                  "verification": "Plotar a região de estabilidade de Euler explícito e identificar seu raio.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Python para plotar regiões",
                                    "Folhas de papel para esboços manuais",
                                    "Referência: Hairer et al. Solving ODEs"
                                  ],
                                  "tips": "Use z = hλ para mapear; teste com λ = -1000.",
                                  "learningObjective": "Compreender as limitações intrínsecas dos métodos explícitos para stiff.",
                                  "commonMistakes": [
                                    "Achar que explícitos são sempre instáveis",
                                    "Erro no cálculo de R(z)",
                                    "Não normalizar pelo h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar métodos implícitos e propriedade A-estável",
                                  "subSteps": [
                                    "Introduzir métodos implícitos: Backward Euler (R(z) = 1/(1 - z), A-estável).",
                                    "Definir A-estabilidade: região inclui todo o semiplano esquerdo.",
                                    "Analisar Backward Differentiation Formulas (BDF): BDF1 (Backward Euler), BDF2, até BDF6 (todas A-estáveis ou L-estáveis).",
                                    "Comparar numericamente Backward Euler vs. explícito em um problema stiff.",
                                    "Discutir trade-offs: custo computacional (sistemas lineares a resolver) vs. estabilidade.",
                                    "Plotar regiões de estabilidade para BDF1 e BDF2."
                                  ],
                                  "verification": "Demonstrar que Backward Euler é A-estável provando |R(z)| ≤ 1 para Re(z) < 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software ODE solvers (ode45 explícito vs. ode15s implícito no MATLAB)",
                                    "Tabelas de polinômios de estabilidade"
                                  ],
                                  "tips": "Use solvers implícitos para stiff; resolva lineares com GMRES se não-diagonal.",
                                  "learningObjective": "Mestre os métodos implícitos A-estáveis como BDF para stiff.",
                                  "commonMistakes": [
                                    "Confundir A-estável com incondicionalmente estável",
                                    "Ignorar custos de iterações não-lineares",
                                    "Erro em polinômios BDF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar métodos e analisar estabilidade em problemas stiff",
                                  "subSteps": [
                                    "Comparar graficamente regiões: explícitos (pequenas) vs. implícitos (semiplano esquerdo).",
                                    "Aplicar a ambos em um exemplo stiff: medir h_max, erro e tempo de CPU.",
                                    "Analisar convergência: ordem preservada em implícitos para stiff.",
                                    "Discutir escolha do método: explícito para não-stiff, implícito para stiff.",
                                    "Generalizar para sistemas multi-escala e stiff não-lineares."
                                  ],
                                  "verification": "Produzir relatório comparativo com plots e tabelas de resultados numéricos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplo código Python/MATLAB pronto",
                                    "Gráficos de regiões de estabilidade"
                                  ],
                                  "tips": "Sempre teste com Dahlquist test equation y' = -λy, λ>>1.",
                                  "learningObjective": "Capacitar análise crítica e escolha de métodos para stiff.",
                                  "commonMistakes": [
                                    "Não quantificar h_max",
                                    "Omitir comparação numérica",
                                    "Generalizar sem evidência"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o problema stiff y' = -1000(y - sin(t)) + cos(t), y(0)=0, no intervalo [0,1]. Use Euler explícito (h=0.01 falha com oscilações) vs. Backward Euler (estável com h=0.1). Plote soluções e regiões de estabilidade para hλ com λ≈-1000.",
                              "finalVerifications": [
                                "Identificar corretamente um problema stiff a partir de eigenvalues.",
                                "Plotar e descrever regiões de estabilidade de Euler explícito e Backward Euler.",
                                "Simular numericamente e concluir que explícito requer h<<1/|λ|.",
                                "Explicar A-estabilidade e listar métodos BDF A-estáveis.",
                                "Comparar custos e benefícios em um exemplo concreto.",
                                "Prever falha de explícito em stiff sem simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e detecção de stiff (eigenvalues).",
                                "Correção nos polinômios de estabilidade R(z) e plots de regiões.",
                                "Análise numérica robusta com plots de soluções e erros.",
                                "Compreensão clara de A-estabilidade vs. regiões limitadas.",
                                "Comparação quantitativa (h_max, tempo CPU, ordem).",
                                "Generalização apropriada para problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC/RLC com parasitas (stiff por capacitores).",
                                "Engenharia Química: Simulação de reatores com reações rápidas/lentas.",
                                "Engenharia de Controle: Sistemas com polos reais negativos grandes.",
                                "Biologia Computacional: Modelos de populações com decaimento rápido.",
                                "Física Computacional: Equações de difusão-reação stiff."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular (software como GROMACS usa BDF para stiff), modelagem de redes elétricas (transientes stiff em PSCAD), ou previsão climática (equações atmosféricas multi-escala stiff), onde métodos implícitos A-estáveis permitem passos de tempo maiores e simulações eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.3.4",
                            "name": "Aplicar critérios de estabilidade prática",
                            "description": "Discutir controle de passo adaptativo baseado na região de estabilidade para manter |hλ| na região estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de região de estabilidade",
                                  "subSteps": [
                                    "Defina a região de estabilidade para métodos de passo múltiplo (ex: região estável no plano complexo onde |R(z)| ≤ 1, com z = hλ).",
                                    "Identifique o polinômio de estabilidade R(z) para o método específico (ex: trapezoidal ou Runge-Kutta).",
                                    "Desenhe ou descreva graficamente a região de estabilidade no plano z.",
                                    "Explique o papel de |hλ| em relação à região estável para problemas stiff.",
                                    "Discuta diferenças entre estabilidade absoluta e relativa."
                                  ],
                                  "verification": "Crie um diagrama da região de estabilidade e rotule pontos estáveis/instáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, calculadora gráfica, software de plotagem (ex: MATLAB ou Python com Matplotlib).",
                                  "tips": "Use cores diferentes para regiões estáveis e instáveis para visualização clara.",
                                  "learningObjective": "Compreender a base teórica da estabilidade para métodos numéricos.",
                                  "commonMistakes": "Confundir região de estabilidade com ordem do método; ignorar o componente imaginário de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o problema de valor inicial e estimar autovalores λ",
                                  "subSteps": [
                                    "Escreva o PVI modelo y' = A y + f(t), linearize se necessário para obter λ.",
                                    "Calcule autovalores da matriz jacobiana A usando decomposição espectral.",
                                    "Estime o módulo |λ| e direção (real/imaginário) relevante para estabilidade.",
                                    "Classifique o problema como stiff ou não baseado em |λ| max.",
                                    "Selecione o método de passo múltiplo apropriado (ex: BDF para stiff)."
                                  ],
                                  "verification": "Liste autovalores com |λ| e confirme classificação do problema.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (MATLAB eig() ou Python NumPy), notas do PVI.",
                                  "tips": "Para problemas não-lineares, use linearização local em torno do equilíbrio.",
                                  "learningObjective": "Identificar componentes críticos de estabilidade no problema.",
                                  "commonMistakes": "Usar autovalores errados; negligenciar partes imaginárias em oscilações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e aplicar critérios de estabilidade prática para |hλ|",
                                  "subSteps": [
                                    "Estabeleça critério: |hλ| deve estar dentro da região estável (ex: |Re(z)| < c, onde z = hλ).",
                                    "Calcule h_max tal que |h_max λ| toque o limite da região estável.",
                                    "Teste h inicial: compute |hλ| e verifique se ∈ região estável.",
                                    "Defina tolerância prática (ex: buffer de 80% da região para segurança).",
                                    "Ajuste h se fora: h_new = h * (raio_estável / |hλ|)."
                                  ],
                                  "verification": "Calcule h_max e verifique para 3 valores de h se |hλ| está estável.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora, planilha Excel ou Python para cálculos iterativos.",
                                  "tips": "Sempre use h conservador para evitar oscilações iniciais.",
                                  "learningObjective": "Aplicar quantitativamente critérios para seleção de h.",
                                  "commonMistakes": "Ignorar sinal de λ negativo; superestimar região para métodos explícitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar controle adaptativo de passo h baseado em estabilidade",
                                  "subSteps": [
                                    "Desenvolva algoritmo: em cada passo, cheque |hλ|; se > limite, reduza h por fator 0.5-0.8.",
                                    "Inclua aumento de h se |hλ| < 50% do limite (fator 1.2-1.5).",
                                    "Integre com controle de erro local (ex: combinação com tolerância de precisão).",
                                    "Simule o PVI com h adaptativo e compare com h fixo.",
                                    "Analise trajetória de h ao longo da integração."
                                  ],
                                  "verification": "Execute simulação e plote h(t) vs. solução y(t); confirme ausência de instabilidade.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de integração numérica (MATLAB ode45 com custom stepper ou Python SciPy solve_ivp).",
                                  "tips": "Monitore norma do resíduo de estabilidade como métrica adicional.",
                                  "learningObjective": "Dominar controle dinâmico de h para robustez numérica.",
                                  "commonMistakes": "Aumentar h muito agressivamente levando a instabilidade súbita; esquecer reset de h em singularidades."
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -50 y, y(0)=1 (λ=-50, stiff), usando método trapezoidal (região estável |z|≤2 no eixo real negativo). Calcule h_max ≈ 2/50=0.04. Inicie com h=0.1 (>limite), detecte |hλ|=5>2, reduza para h=0.03 (|hλ|=1.5<2). Simule até t=2 e compare soluções estável vs. oscilante.",
                              "finalVerifications": [
                                "Confirme que |hλ| permaneceu na região estável em todos os passos da simulação.",
                                "Verifique ausência de crescimento exponencial na solução numérica.",
                                "Compare norma L2 da solução adaptativa vs. referência exata (erro <1e-3).",
                                "Analise eficiência: número de passos reduzido em problemas stiff.",
                                "Teste sensibilidade: varie λ em ±10% e confirme adaptação.",
                                "Plote região de estabilidade com trajetória de hλ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da região de estabilidade (diagrama correto).",
                                "Cálculo exato de h_max e critérios quantitativos (|hλ| bounds).",
                                "Implementação correta do algoritmo adaptativo (pseudocódigo ou código funcional).",
                                "Análise qualitativa/quantitativa de resultados (gráficos e métricas).",
                                "Discussão de limitações e melhorias (ex: detecção automática de λ).",
                                "Integração com outros controles (erro local)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos stiff (ex: circuitos RC, reações químicas).",
                                "Programação: Implementação de solvers ODE em Python/MATLAB com controle adaptativo.",
                                "Engenharia: Simulações em controle de processos industriais.",
                                "Estatística: Análise de erro em métodos numéricos probabilísticos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou previsão climática, onde PVIs stiff surgem de escalas múltiplas; controle adaptativo de h baseado em estabilidade garante precisão e eficiência computacional em supercomputadores para modelar furacões ou epidemias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Controle de Passo",
                "description": "Técnicas para ajustar adaptativamente o tamanho do passo visando precisão e eficiência computacional.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Estimativa de Erro Local",
                    "description": "Técnicas para calcular o erro aproximado em um passo de integração numérica, como pares de métodos embedded.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1.1",
                        "name": "Erro Local de Truncamento",
                        "description": "O erro local de truncamento é o erro introduzido por uma única etapa de integração numérica em métodos para problemas de valor inicial, representando a diferença entre a solução exata e a aproximada após um passo de tamanho h.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1.1",
                            "name": "Definir Erro Local de Truncamento",
                            "description": "Explicar o conceito de erro local de truncamento em métodos numéricos para EDOs, diferenciando-o do erro global e expressando sua dependência na ordem do método (O(h^{p+1})).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de erro de truncamento",
                                  "subSteps": [
                                    "Revise a definição de truncamento em aproximações numéricas: substituição de operações contínuas por discretas.",
                                    "Identifique fontes de erro em métodos numéricos: arredondamento e truncamento.",
                                    "Estude exemplos simples, como a aproximação da derivada por diferenças finitas: f'(x) ≈ [f(x+h) - f(x)] / h.",
                                    "Analise como o erro de truncamento surge da expansão em série de Taylor.",
                                    "Discuta a importância de quantificar esse erro para confiabilidade dos métodos."
                                  ],
                                  "verification": "Resuma em suas palavras o que é erro de truncamento e dê um exemplo básico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de erros)",
                                    "Vídeo introdutório sobre erros numéricos (Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Comece com séries de Taylor para visualizar o erro remanescente.",
                                  "learningObjective": "Entender a origem do erro de truncamento em aproximações discretas.",
                                  "commonMistakes": [
                                    "Confundir truncamento com arredondamento",
                                    "Ignorar a dependência no tamanho do passo h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contextualizar em métodos numéricos para EDOs",
                                  "subSteps": [
                                    "Revise métodos numéricos para EDOs: um-passo (Euler, Runge-Kutta) vs. multi-passo.",
                                    "Explique que EDOs são resolvidas por discretização temporal com passo h.",
                                    "Identifique onde o truncamento ocorre: na aproximação local da solução exata em um passo.",
                                    "Estude a solução exata y(t) vs. aproximada y_n em t_n = n h.",
                                    "Discuta o papel do erro local na acumulação para o erro global."
                                  ],
                                  "verification": "Descreva como um método numérico para EDOs introduz truncamento em um único passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre métodos para EDOs",
                                    "Software como MATLAB ou Python (SciPy) para visualizar soluções"
                                  ],
                                  "tips": "Desenhe o gráfico de y(t) exata vs. aproximações para visualizar desvios.",
                                  "learningObjective": "Relacionar erro de truncamento ao contexto de resolução de EDOs.",
                                  "commonMistakes": [
                                    "Pensar que truncamento só ocorre em derivadas, não em integrais",
                                    "Confundir passo h com precisão da máquina"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir precisamente o erro local de truncamento",
                                  "subSteps": [
                                    "Defina erro local: diferença entre solução exata após um passo e a numérica, assumindo valor inicial exato.",
                                    "Use expansão de Taylor: para método de ordem p, erro local τ = O(h^{p+1}).",
                                    "Escreva formalmente: y(t_{n+1}) = y(t_n) + h φ(t_n, y(t_n), h) + τ(h), onde |τ(h)| ≤ K h^{p+1}.",
                                    "Diferencie de outros erros: local é por passo, não acumulado.",
                                    "Pratique com método de Euler: p=1, τ = (1/2) h^2 y''(ξ)."
                                  ],
                                  "verification": "Escreva a definição matemática do erro local e um exemplo para Euler.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivações de Taylor",
                                    "Exemplos resolvidos de livros como Burden & Faires"
                                  ],
                                  "tips": "Derive o erro para Euler passo a passo usando Taylor.",
                                  "learningObjective": "Formular a definição exata e matemática do erro local de truncamento.",
                                  "commonMistakes": [
                                    "Confundir erro local com o remanescente da Taylor global",
                                    "Esquecer que é assumido y_n exato"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar de erro global e expressar dependência na ordem",
                                  "subSteps": [
                                    "Defina erro global: ||y(t_n) - y_n|| ao longo de múltiplos passos, O(h^p).",
                                    "Explique acumulação: erro global ≈ (erro local / h) * (t_final / h) * h^{p+1} = O(h^p).",
                                    "Compare: local O(h^{p+1}), global O(h^p), pois local se propaga.",
                                    "Discuta ordem p: métodos de ordem superior reduzem ambos os erros.",
                                    "Verifique com tabela: h variando, observe decaimento do erro local."
                                  ],
                                  "verification": "Explique a relação entre ordens local e global e dê fórmula O(h^{p+1}).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para tabelas de erro",
                                    "Gráficos log-log de erro vs. h"
                                  ],
                                  "tips": "Plote log|erro| vs. log h para estimar ordem p+1.",
                                  "learningObjective": "Distinguir erros local/global e quantificar dependência em h e p.",
                                  "commonMistakes": [
                                    "Invertar ordens: achar global O(h^{p+1})",
                                    "Ignorar propagação do erro local"
                                  ]
                                }
                              ],
                              "practicalExample": "No método de Euler para y' = -y, y(0)=1 (solução exata y=e^{-t}), em t=0 com h=0.1, y_1 ≈ 0.9, mas y(0.1)=e^{-0.1}≈0.9048. Erro local ≈ 0.0048, que é O(h^2) com p=1: (1/2)h^2 y''(ξ) ≈ 0.005.",
                              "finalVerifications": [
                                "Defina erro local de truncamento em EDOs com fórmula.",
                                "Diferencie de erro global com exemplos de ordens.",
                                "Expresse dependência O(h^{p+1}) para método de ordem p.",
                                "Calcule erro local aproximado para Euler em um passo simples.",
                                "Explique por que erro global é O(h^p)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática do erro local.",
                                "Correta diferenciação entre erros local e global.",
                                "Uso apropriado de notação O(h^{p+1}).",
                                "Exemplos concretos e cálculos corretos.",
                                "Compreensão da acumulação de erros.",
                                "Clareza na explicação da ordem do método."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar métodos em Python (SciPy.odeint) e analisar erros.",
                                "Física: Modelagem de osciladores harmônicos com EDOs em simulações.",
                                "Engenharia: Controle de sistemas dinâmicos, ajustando h para precisão.",
                                "Estatística: Análise de erros em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de foguetes ou previsão climática, definir e estimar erro local de truncamento permite escolher h ótimo, balanceando precisão e tempo computacional em solvers como Runge-Kutta em softwares de engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.2",
                            "name": "Calcular Erro Local Teórico",
                            "description": "Derivar a expressão analítica do erro local de truncamento para métodos de Runge-Kutta de ordem p, usando expansão em série de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Expansão em Série de Taylor para Soluções de EDOs",
                                  "subSteps": [
                                    "Lembre a expansão de Taylor da solução exata y(t_n + h) = ∑_{k=0}^∞ (h^k / k!) y^{(k)}(t_n), onde y' = f(t,y).",
                                    "Expresse y^{(k)}(t_n) recursivamente usando a regra de Faà di Bruno ou diferenciação em cadeia para composições.",
                                    "Compute os termos até ordem p+1 explicitamente para y(t_n + h).",
                                    "Identifique o polinômio de Taylor de ordem p como base para métodos explícitos.",
                                    "Discuta o resto de Lagrange para o termo de truncamento O(h^{p+1})."
                                  ],
                                  "verification": "Escrever a expansão de Taylor de y(t_n + h) até ordem p+1 sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (Burden & Faires)",
                                    "Papel e lápis",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Assuma f infinitamente diferenciável e use notação compacta para derivadas parciais.",
                                  "learningObjective": "Dominar a expansão analítica da solução exata como referência para análise de erro.",
                                  "commonMistakes": [
                                    "Esquecer o denominador k! nos termos",
                                    "Confundir derivadas parciais de f com derivadas totais de y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Forma Geral do Método Runge-Kutta Explícito de Ordem p",
                                  "subSteps": [
                                    "Defina a tableau de Butcher: etapas s, nós c_i, pesos b_i, coeficientes a_{ij}.",
                                    "Escreva a aproximação y_{n+1} = y_n + h ∑_{i=1}^s b_i k_i, com k_i = f(t_n + c_i h, y_n + h ∑_{j=1}^{i-1} a_{ij} k_j).",
                                    "Liste as condições de ordem: ∑ b_i = 1 (ordem 1), ∑ b_i c_i = 1/2 (ordem 2), etc., até ordem p.",
                                    "Expanda cada k_i em série de Taylor em torno de (t_n, y_n).",
                                    "Verifique consistência das condições de ordem até p."
                                  ],
                                  "verification": "Escrever corretamente a forma geral do RK e suas condições de ordem até p.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre métodos RK",
                                    "Tabela de Butcher para RK4 clássico"
                                  ],
                                  "tips": "Comece com s=p+1 para métodos explícitos simples.",
                                  "learningObjective": "Compreender como os parâmetros do RK reproduzem os termos de Taylor até ordem p.",
                                  "commonMistakes": [
                                    "Confundir nós c_i com pesos b_i",
                                    "Ignorar dependências nos k_i (triangular estrita)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir os Estágios k_i Usando Séries de Taylor Multivariadas",
                                  "subSteps": [
                                    "Para cada k_i, expanda f(t_n + c_i h, y_n + h ∑_{j<i} a_{ij} k_j) em Taylor multivariada.",
                                    "Use a fórmula geral para Taylor de f: f + h (c_i f_t + ∑ a_{ij} k_j f_y) + (h^2/2) termos quadráticos, etc.",
                                    "Substitua k_j por suas expansões iniciais iterativamente.",
                                    "Colete coeficientes de h^m para m=0 até p+1 em cada k_i.",
                                    "Expresse ∑ b_i k_i como polinômio em h até ordem p+1."
                                  ],
                                  "verification": "Derivar expansões de k_i até ordem p+1 para um RK simples (ex: RK2).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica",
                                    "Papel para álgebra tediosa"
                                  ],
                                  "tips": "Prossiga por ordem de h, resolvendo linearmente para coeficientes desconhecidos.",
                                  "learningObjective": "Aplicar Taylor multivariada para argumentos compostos nos estágios RK.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais de segunda ordem (f_{ty}, f_{yy})",
                                    "Não expandir k_j dentro de argumentos de k_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar o Erro Local Comparando Expansões",
                                  "subSteps": [
                                    "Subtraia a expansão do polinômio RK de ∑ b_i k_i da expansão exata de y(t_n + h)/h.",
                                    "Os termos até h^p devem cancelar pelas condições de ordem.",
                                    "Identifique o coeficiente líder do erro local: (h^{p+1}/(p+1)!) y^{(p+1)}(ξ) igual a d_{p+1} h^{p+1}, onde d_{p+1} envolve derivadas de f.",
                                    "Escreva a expressão analítica geral para o erro local teórico.",
                                    "Simplifique para casos conhecidos como Euler (p=1) e RK4 (p=4)."
                                  ],
                                  "verification": "Obter a expressão erro = O(h^{p+1}) com coeficiente explícito correto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos resolvidos de livros",
                                    "SymPy para verificação numérica/simbolica"
                                  ],
                                  "tips": "Use notação elementar de ordem para compactar condições.",
                                  "learningObjective": "Concluir a derivação do erro local de truncamento teórico para RK ordem p.",
                                  "commonMistakes": [
                                    "Não normalizar por h no erro local",
                                    "Erros de sinal no termo líder"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Generalizar a Derivação",
                                  "subSteps": [
                                    "Teste a derivação para RK1 (Euler): confirme erro = (h^2/2) y''(ξ).",
                                    "Verifique para RK2 de Heun ou similar.",
                                    "Discuta implicações para ordem p arbitrária via condições de Butcher.",
                                    "Considere extensões para sistemas de EDOs.",
                                    "Anote limitações (f suave requerida)."
                                  ],
                                  "verification": "Validação numérica: compare com solução exata para EDO teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python para EDOs de teste (scipy)"
                                  ],
                                  "tips": "Use EDO linear y' = λy para verificação analítica simples.",
                                  "learningObjective": "Consolidar compreensão através de verificações e generalizações.",
                                  "commonMistakes": [
                                    "Generalizar incorretamente para sistemas vetoriais",
                                    "Ignorar dependência em ξ ∈ (t_n, t_{n+1})"
                                  ]
                                },
                                {
                                  "practicalExample": "Para o método RK2 de ordem 2 (meio-ponto): k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + (h/2)k1), y_{n+1} = y_n + h k2. Derive: erro local = (h^3/6) [f_t f_y + (1/2) f_y^2 f_{yy} + f_{yy}] y'''(ξ) ou equivalente, mostrando cancelamento até h^2.",
                                  "finalVerifications": [
                                    "Expansão correta de y(t_n + h) até ordem p+1.",
                                    "Expansões precisas de todos k_i até ordem p+1.",
                                    "Cancelamento exato dos termos até h^p na subtração.",
                                    "Coeficiente líder d_{p+1} h^{p+1} derivado corretamente.",
                                    "Validação para pelo menos dois métodos RK conhecidos (p=1,4)."
                                  ],
                                  "assessmentCriteria": [
                                    "Correção algébrica em todas as expansões Taylor (sem erros de cálculo).",
                                    "Uso apropriado de condições de ordem Butcher.",
                                    "Expressão final do erro local em forma padrão O(h^{p+1}).",
                                    "Clareza na derivação passo a passo.",
                                    "Validação com exemplos concretos."
                                  ],
                                  "crossCurricularConnections": [
                                    "Física Computacional: Análise de erro em simulações de trajetórias orbitais.",
                                    "Programação Científica: Implementação de embedded RK em bibliotecas como ODEINT.",
                                    "Engenharia de Controle: Estimativa de erro em solvers para sistemas dinâmicos.",
                                    "Estatística: Conexão com análise de truncamento em métodos Monte Carlo."
                                  ],
                                  "realWorldApplication": "Em solvers numéricos de EDOs como os usados em modelagem climática (NASA GISS), simulações farmacocinéticas ou controle de voo de drones, onde a estimativa teórica do erro local guia adaptadores de passo h para equilibrar precisão e eficiência computacional."
                                }
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.3",
                            "name": "Interpretar Impacto no Erro Global",
                            "description": "Analisar como o erro local acumula para formar o erro global em integrações múltiplas, considerando estabilidade e tamanho de passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Erro Local e Global",
                                  "subSteps": [
                                    "Defina erro local como a discrepância entre o valor exato e aproximado em um único passo de integração.",
                                    "Defina erro global como a soma acumulada dos erros locais ao longo de todo o intervalo de integração.",
                                    "Explique a relação qualitativa: erro global ≈ (erro local) × (número de passos).",
                                    "Discuta o papel do tamanho de passo h na magnitude do erro local (tipicamente O(h^{p+1}) para métodos de ordem p).",
                                    "Identifique exemplos de métodos de integração (ex: Trapezoidal, Simpson) e suas ordens de erro local."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre erro local e global, com fórmulas básicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de Integração Numérica)",
                                    "Notas de aula sobre controle de passo"
                                  ],
                                  "tips": "Use diagramas para visualizar um passo local vs. integração completa.",
                                  "learningObjective": "Compreender as definições e relação inicial entre erros local e global.",
                                  "commonMistakes": [
                                    "Confundir erro local com truncamento global",
                                    "Ignorar dependência em h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação Matemática entre Erro Local e Global",
                                  "subSteps": [
                                    "Comece com a fórmula do erro local para um método específico, ex: Trapezoidal: erro_local ≈ -(b-a)h²/12 * f''(ξ).",
                                    "Estime o número de passos N = (b-a)/h.",
                                    "Derive erro_global ≈ N * erro_local ≈ (b-a) * erro_local / h.",
                                    "Simplifique para mostrar erro_global ≈ C * h^p, onde p é a ordem do método.",
                                    "Verifique com uma função teste simples, como ∫x² dx de 0 a 1."
                                  ],
                                  "verification": "Escreva e derive a fórmula de erro global para o método trapezoidal em um papel.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB para verificação numérica",
                                    "Folha de derivadas"
                                  ],
                                  "tips": "Mantenha ξ genérico inicialmente para foco conceitual.",
                                  "learningObjective": "Derivar quantitativamente como erro local se acumula em erro global.",
                                  "commonMistakes": [
                                    "Esquecer fator N na acumulação",
                                    "Confundir ordens de erro local vs. global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto do Tamanho de Passo e Estabilidade",
                                  "subSteps": [
                                    "Teste numericamente diferentes valores de h (ex: h=0.1, 0.05, 0.01) em uma integração e plote erro global vs. h.",
                                    "Observe como redução de h diminui erro truncamento mas pode introduzir instabilidade numérica.",
                                    "Discuta estabilidade: métodos explícitos vs. implícitos em integrações com rigidez.",
                                    "Calcule razão de erros consecutivos para confirmar ordem de convergência.",
                                    "Avalie trade-off: h pequeno → precisão alta mas custo computacional alto."
                                  ],
                                  "verification": "Gere um gráfico de log(erros) vs. log(h) mostrando inclinação = ordem p.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy para integração numérica",
                                    "Gráficos via Matplotlib"
                                  ],
                                  "tips": "Use funções suaves inicialmente para evitar erros de arredondamento dominantes.",
                                  "learningObjective": "Interpretar numericamente o impacto de h na acumulação de erros.",
                                  "commonMistakes": [
                                    "Não logar para ver ordem",
                                    "Ignorar erros de arredondamento em h muito pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Integrações Múltiplas e Simular Cenários",
                                  "subSteps": [
                                    "Simule integração múltipla (ex: método adaptativo) e rastreie acumulação de erros locais.",
                                    "Compare cenários: h fixo vs. controle de passo adaptativo.",
                                    "Analise estabilidade em problemas rígidos (ex: equações diferenciais com escalas múltiplas).",
                                    "Preveja erro global para intervalos longos ou N grande.",
                                    "Documente conclusões sobre quando refinar h."
                                  ],
                                  "verification": "Produza relatório com tabelas de erros para 3 valores de h e interpretação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para método de integração adaptativo",
                                    "Exemplos de problemas rígidos"
                                  ],
                                  "tips": "Comece com intervalo [0,10] para ver acumulação clara.",
                                  "learningObjective": "Sintetizar interpretação completa do impacto no erro global em contextos reais.",
                                  "commonMistakes": [
                                    "Subestimar instabilidade em h pequeno",
                                    "Não considerar custo total de passos"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao integrar numéricamente f(x) = sin(x) de 0 a 10π usando regra trapezoidal: com h=0.1, erro local ~ O(h²), N=314 passos, erro global ~ 0.08; reduzindo h=0.01 (N=3141), erro global cai para ~0.0008, confirmando acumulação e ordem quadrática, mas tempo computacional aumenta 100x.",
                              "finalVerifications": [
                                "Explica verbalmente como erro local de O(h^{p+1}) leva a erro global O(h^p).",
                                "Calcula corretamente erro global aproximado para método dado e h específico.",
                                "Identifica quando reduzir h não melhora precisão devido a instabilidade.",
                                "Plota e interpreta gráfico de convergência erro vs. h.",
                                "Prevé impacto em integração longa (ex: N=10000 passos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação erro local-global (90% correto).",
                                "Correta interpretação de simulações numéricas (incluindo ordem via log-log).",
                                "Consideração explícita de estabilidade e trade-offs de h.",
                                "Uso adequado de exemplos concretos com cálculos verificáveis.",
                                "Clareza na comunicação de insights em relatório ou apresentação.",
                                "Identificação de erros comuns em cenários práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de trajetórias em simulações dinâmicas (ex: movimento orbital).",
                                "Computação: Implementação de solvers numéricos em bibliotecas como SciPy.",
                                "Engenharia: Análise de estruturas com métodos de elementos finitos.",
                                "Estatística: Propagação de erros em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em modelagem climática, erros locais em passos temporais de simulação acumulam para previsões globais imprecisas; controle de h adaptativo garante estabilidade em previsões de longo prazo para furacões ou aquecimento global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.2",
                        "name": "Métodos Embedded Runge-Kutta",
                        "description": "Métodos embedded, ou pares de Runge-Kutta, computam simultaneamente duas aproximações de soluções de ordens diferentes (p e p+1) usando os mesmos estágios, permitindo estimativa de erro sem custo adicional significativo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.2.1",
                            "name": "Descrever Estrutura de Pares Embedded",
                            "description": "Explicar a tabela Butcher para métodos como RK4(5) ou Fehlberg, destacando coeficientes compartilhados e soluções y_h (ordem p) e y_{h}^* (ordem p+1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Pares Embedded Runge-Kutta",
                                  "subSteps": [
                                    "Revise métodos Runge-Kutta de ordem fixa e sua representação pela tabela Butcher.",
                                    "Entenda o propósito de pares embedded: estimar erro local usando duas aproximações de ordens diferentes com estágios compartilhados.",
                                    "Diferencie y_h (aproximação de ordem p) e y_h^* (aproximação de ordem p+1).",
                                    "Estude a motivação para controle de passo adaptativo via estimativa de erro.",
                                    "Anote definições chave: k_i = f(t_n + c_i h, y_n + h ∑ a_{ij} k_j)."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos básicos e identifique diferenças entre y_h e y_h^*.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de análise numérica (ex: Burden & Faires), papel e caneta.",
                                  "tips": "Use diagramas visuais para representar os estágios k_i compartilhados.",
                                  "learningObjective": "Dominar fundamentos teóricos de pares embedded para contextualizar a estrutura.",
                                  "commonMistakes": "Confundir ordem de y_h (p) com y_h^* (p+1); ignorar eficiência computacional dos coeficientes compartilhados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura da Tabela Butcher para Pares Embedded",
                                  "subSteps": [
                                    "Desenhe uma tabela Butcher genérica com s estágios, destacando matrizes A, b (para ordem p) e b^* (para ordem p+1).",
                                    "Identifique os vetores c (nós) e os coeficientes a_{ij} compartilhados entre aproximações.",
                                    "Explique como a tabela é compacta: uma única matriz A para ambos os pesos b e b^*.",
                                    "Compare com métodos não-embedded, notando duplicação de estágios evitada.",
                                    "Pratique copiando uma tabela padrão de RK4(5)."
                                  ],
                                  "verification": "Desenhe e label corretamente uma tabela Butcher genérica para par embedded.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel quadriculado, exemplos de tabelas de livros ou online (ex: Wikipedia Runge-Kutta).",
                                  "tips": "Alinhe colunas e linhas precisamente para visualizar simetrias nos coeficientes.",
                                  "learningObjective": "Representar visualmente a estrutura Butcher, enfatizando compartilhamento.",
                                  "commonMistakes": "Esquecer de separar b e b^* na parte inferior da tabela; desalinhar índices i,j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Coeficientes Compartilhados e Cálculo das Soluções",
                                  "subSteps": [
                                    "Calcule estágios intermediários k_i usando a matriz A compartilhada.",
                                    "Mostre y_h = y_n + h ∑ b_i k_i (ordem p).",
                                    "Mostre y_h^* = y_n + h ∑ b_i^* k_i (ordem p+1).",
                                    "Derive estimativa de erro local: |y_h - y_h^*| ≈ erro de truncamento O(h^{p+1}).",
                                    "Discuta escolha de coeficientes para satisfazer condições de ordem (Butcher's conditions)."
                                  ],
                                  "verification": "Escreva fórmulas para y_h, y_h^* e erro, aplicando a um h simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou software simbólico (ex: SymPy, MATLAB), exemplos numéricos.",
                                  "tips": "Verifique condições de ordem somando coeficientes: ∑ b_i = 1, ∑ b_i c_i = 1/2, etc.",
                                  "learningObjective": "Articular como coeficientes compartilhados habilitam estimativa eficiente de erro.",
                                  "commonMistakes": "Usar pesos errados nos cálculos; não normalizar ∑ b_i = ∑ b_i^* = 1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Exemplos Específicos como RK4(5) e Fehlberg",
                                  "subSteps": [
                                    "Estude tabela Butcher do método clássico RK4(5) (Dormand-Prince similar).",
                                    "Descreva estrutura do Fehlberg RKF45, notando 6 estágios para ordens 4 e 5.",
                                    "Implemente um passo manual para y' = f(t,y) com h=0.1.",
                                    "Compare coeficientes b e b^* nestes métodos.",
                                    "Explique adaptação de passo: h_new = h * (tol / |y_h - y_h^*|)^{1/(p+1)}."
                                  ],
                                  "verification": "Reproduza tabela e compute um exemplo numérico com erro estimado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software numérico (Python/Scipy ode45, ou papel para cálculo manual).",
                                  "tips": "Comece com equação simples como y' = -y para validar.",
                                  "learningObjective": "Descrever estruturas específicas, ligando teoria a prática.",
                                  "commonMistakes": "Copiar tabelas incorretamente; ignorar FSAL (First Same As Last) para eficiência."
                                }
                              ],
                              "practicalExample": "Para o método Fehlberg RKF45, a tabela Butcher tem 6 estágios com c = [0, 1/4, 3/8, 12/13, 1, 1/2]. Coeficientes a_{ij} são compartilhados; b (ordem 4): [37/378, 0, 250/621, 125/594, 0, 512/1771]; b^* (ordem 5): [2825/27648, 0, 18575/48384, 13525/55296, 277/14336, 1/4]. Para y' = y(1-y), t=0, y=1, h=0.1, compute k1 a k6, y_h ≈ 0.9048, y_h^* ≈ 0.9049, erro ≈ 9e-5.",
                              "finalVerifications": [
                                "Desenhar corretamente tabela Butcher para RK4(5) ou Fehlberg.",
                                "Explicar verbalmente coeficientes compartilhados e seu benefício.",
                                "Calcular y_h e y_h^* para um exemplo dado com precisão.",
                                "Derivar estimativa de erro local |y_h - y_h^*|.",
                                "Identificar condições de ordem para p e p+1.",
                                "Aplicar fórmula de adaptação de passo h_new."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação da tabela Butcher (coeficientes corretos).",
                                "Clareza na distinção entre y_h (p) e y_h^* (p+1).",
                                "Correção matemática nos cálculos de estágios e soluções.",
                                "Explicação convincente de eficiência via compartilhamento.",
                                "Uso apropriado de terminologia (nós c_i, pesos b/b^*, condições de Butcher).",
                                "Capacidade de ligar a controle de erro adaptativo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de trajetórias em mecânica orbital (ex: NASA usa RK embedded).",
                                "Computação: Implementação em bibliotecas ODE solvers (Scipy, GSL).",
                                "Engenharia: Controle de sistemas dinâmicos com passos adaptativos.",
                                "Estatística: Modelagem estocástica com erros controlados."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (previsão de tempo), métodos embedded como DOPRI5 ajustam h automaticamente para precisão em trajetórias caóticas, economizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.2",
                            "name": "Implementar Método Embedded",
                            "description": "Implementar em pseudocódigo ou código um par embedded Runge-Kutta para resolver EDOs, computando ambas as aproximações em um passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Documentar Coeficientes do Método Embedded Runge-Kutta",
                                  "subSteps": [
                                    "Pesquise métodos embedded comuns, como o par Dormand-Prince (RK45).",
                                    "Obtenha a tabela de Butcher: coeficientes c_i, a_{ij}, b^{(4)}_i para ordem 4, b^{(5)}_i para ordem 5.",
                                    "Crie uma estrutura de dados (dicionário ou arrays) em pseudocódigo ou Python para armazenar esses coeficientes.",
                                    "Documente as ordens de precisão e o propósito do método em comentários.",
                                    "Verifique a soma dos coeficientes b para consistência (deve somar 1)."
                                  ],
                                  "verification": "Coeficientes implementados corretamente e documentados em código legível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de métodos numéricos (ex: livro de Burden & Faires)",
                                    "Editor de código (Python/Jupyter Notebook)",
                                    "Tabela Butcher do RK45 online"
                                  ],
                                  "tips": "Use arrays numpy para precisão numérica; comece com pseudocódigo para clareza.",
                                  "learningObjective": "Compreender a estrutura algébrica dos métodos Runge-Kutta embedded.",
                                  "commonMistakes": [
                                    "Erros de transcrição nos coeficientes a_{ij}",
                                    "Confundir b^{(4)} e b^{(5)}",
                                    "Ignorar normalização dos coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Cálculo dos Estágios Intermediários (k_i)",
                                  "subSteps": [
                                    "Defina a função principal que recebe y_n, t_n, h, e a função f(t,y) da EDO.",
                                    "Inicialize k como array vazio.",
                                    "Calcule k1 = f(t_n, y_n).",
                                    "Para i=2 a s (estágios), compute k_i = f(t_n + c_i * h, y_n + h * sum_{j=1}^{i-1} a_{ij} k_j).",
                                    "Retorne o array k completo."
                                  ],
                                  "verification": "Execute com valores simples e confira k1 correto; plote ou imprima valores intermediários.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy",
                                    "Exemplo de EDO simples: y' = -y"
                                  ],
                                  "tips": "Use loops vetorizados com NumPy para eficiência; teste incrementalmente cada k_i.",
                                  "learningObjective": "Implementar o esquema de estágios de um método Runge-Kutta explícito.",
                                  "commonMistakes": [
                                    "Índices off-by-one em loops",
                                    "Não escalar corretamente por h",
                                    "Acúmulo de erros de ponto flutuante sem NumPy"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Aproximações e Estimativa de Erro Local",
                                  "subSteps": [
                                    "Calcule y_{n+1}^{(5)} = y_n + h * sum b^{(5)}_i k_i (ordem 5).",
                                    "Calcule y_{n+1}^{(4)} = y_n + h * sum b^{(4)}_i k_i (ordem 4).",
                                    "Estime erro local: err = |y_{n+1}^{(5)} - y_{n+1}^{(4)}| / (1 - tol ou similar).",
                                    "Retorne y_{n+1}^{(5)}, err, e avance t_{n+1} = t_n + h.",
                                    "Adicione tolerância para controle futuro (opcional aqui)."
                                  ],
                                  "verification": "Para EDO y'=-y, y(0)=1, h=0.1, compare com solução exata e^{ -t }.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do Step 2",
                                    "Solução analítica da EDO de teste"
                                  ],
                                  "tips": "Norme o erro para sistemas vetoriais usando norma máxima ou L2.",
                                  "learningObjective": "Calcular aproximações de diferentes ordens e estimar erro local truncamento.",
                                  "commonMistakes": [
                                    "Inverter ordens 4 e 5",
                                    "Esquecer fator h na soma ponderada",
                                    "Não tratar sistemas de EDOs vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Implementação Completa",
                                  "subSteps": [
                                    "Crie um loop principal para múltiplos passos, coletando y e t.",
                                    "Teste com EDO linear y' = -y, compare com solução exata.",
                                    "Teste com EDO não-linear, ex: y' = y(1-y), y(0)=0.5 (lógica).",
                                    "Plote solução numérica vs exata e analise erro acumulado.",
                                    "Adicione comentários explicativos e função reutilizável."
                                  ],
                                  "verification": "Gráficos mostram convergência; erro local diminui com h menor.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "EDOs de teste conhecidas"
                                  ],
                                  "tips": "Use scipy.integrate.odeint como benchmark para validação.",
                                  "learningObjective": "Validar implementação através de testes empíricos e análise de erro.",
                                  "commonMistakes": [
                                    "Não inicializar arrays corretamente",
                                    "Ignorar estabilidade para h grande",
                                    "Falta de plots para diagnóstico visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o método RK45 para resolver y' = -2y, y(0)=1, em [0,1] com h=0.1. Solução exata: y(t)=exp(-2t). Compute y(1) ≈ 0.1353 e verifique erro local < 1e-6 em cada passo.",
                              "finalVerifications": [
                                "Código executa sem erros para EDOs escalares e vetoriais.",
                                "Aproximações de ordem 4 e 5 coincidem dentro de tolerância esperada.",
                                "Erro local estimado matches ordem de truncamento (O(h^5)).",
                                "Solução numérica converge para exata ao refinar h.",
                                "Função é modular e reutilizável para diferentes f(t,y)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global < 1e-4 para h=0.1 em teste padrão.",
                                "Eficiência: Tempo de execução razoável (segundos para 100 passos).",
                                "Clareza: Código comentado, variáveis nomeadas intuitivamente.",
                                "Robustez: Trata sistemas de EDOs e falha graciosamente em casos inválidos.",
                                "Validação: Inclui testes com soluções exatas e plots.",
                                "Documentação: Explica coeficientes e lógica de erro."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados, loops vetorizados (Python/NumPy).",
                                "Física: Simulações dinâmicas (ex: movimento orbital).",
                                "Engenharia: Controle de sistemas (ODEs em automação).",
                                "Ciência de Dados: Integração numérica em ML (redes neurais recorrentes)."
                              ],
                              "realWorldApplication": "Usado em simuladores de trajetórias espaciais (NASA), modelagem climática (previsão de tempo), e farmacocinética (simulação de liberação de drogas), onde controle adaptativo de passo via erro embedded otimiza precisão e velocidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.3",
                            "name": "Comparar com Métodos Não-Embedded",
                            "description": "Comparar eficiência computacional de métodos embedded versus métodos de passo duplo para estimativa de erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Métodos Embedded e Não-Embedded",
                                  "subSteps": [
                                    "Defina métodos Embedded Runge-Kutta: métodos que computam duas aproximações de ordens diferentes (ex: ordem 4 e 5) usando as mesmas avaliações de função.",
                                    "Descreva métodos de passo duplo (não-embedded): avance com passo h para ordem p, então com h/2 duas vezes para ordem p+1, estimando erro.",
                                    "Identifique o número de estágios (k avaliações de função) em exemplos como Dormand-Prince (5(4)) para embedded vs. clássicos RK4 duplo.",
                                    "Liste vantagens iniciais: embedded reutiliza avaliações, não-embedded requer ~2x mais.",
                                    "Anote fórmulas de erro local: |y_{n+1} - ŷ_{n+1}| para embedded, diferença entre passo h e 2*(h/2) para não-embedded."
                                  ],
                                  "verification": "Resuma diferenças em um diagrama de fluxo ou tabela comparativa com pelo menos 4 pontos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre Runge-Kutta, papel e caneta para diagramas.",
                                  "tips": "Use tabelas Butcher para visualizar estágios compartilhados nos embedded.",
                                  "learningObjective": "Compreender as diferenças arquiteturais que impactam o custo computacional.",
                                  "commonMistakes": "Confundir ordem de precisão com número de estágios; ignorar que embedded usa k avaliações para duas soluções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Custo Computacional Detalhado",
                                  "subSteps": [
                                    "Para embedded: custo por passo = s avaliações de f(t,y), onde s é número de estágios (ex: 6 para Dopri5).",
                                    "Para não-embedded passo duplo: custo = avaliações para RKp(h) + 2*avaliações para RKp+1(h/2) ≈ 2*(p+1) para RK clássicos.",
                                    "Compare flops: assuma cada f(y) custa C flops, total embedded: s*C, não-embedded: ~2s*C.",
                                    "Inclua overhead: controle de passo (rej./acc.) similar, mas embedded economiza em aceitações.",
                                    "Calcule eficiência: passos por unidade tempo ∝ 1/custo, erro controlado similar."
                                  ],
                                  "verification": "Crie tabela com custos numéricos para RK4(5) embedded vs. RK4 duplo, mostrando embedded ~1.5-2x mais eficiente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para flops simbólicos, tabelas Butcher de métodos padrão.",
                                  "tips": "Normalize custo relativo a um método base como Euler explícito.",
                                  "learningObjective": "Quantificar custo computacional em termos de avaliações de função e flops.",
                                  "commonMistakes": "Esquecer custo de h/2 no passo duplo (mais pontos de grade); superestimar overhead de controle."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Eficiência via Métricas Comparativas",
                                  "subSteps": [
                                    "Defina eficiência: log(error) vs. log(custo total) em gráfico de eficiência.",
                                    "Compare precisão: ambos controlam erro local similarmente, mas custo difere.",
                                    "Considere adaptação de passo: embedded aceita mais passos por tempo devido a menor custo.",
                                    "Avalie em regimes: stiff vs. não-stiff, onde embedded pode brilhar mais.",
                                    "Discuta trade-offs: embedded mais complexo para implementar, mas bibliotecas lidam."
                                  ],
                                  "verification": "Desenhe gráfico conceitual de eficiência mostrando curva superior para embedded.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Gráficos de eficiência de literatura (ex: Hairer livro), software de plotagem.",
                                  "tips": "Use métrica EOC (erro por custo) para quantificar.",
                                  "learningObjective": "Interpretar comparações qualitativas e quantitativas de eficiência.",
                                  "commonMistakes": "Ignorar fator de aceitação/rejeição (~0.8-0.9), que amplifica vantagem embedded."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Simulação Numérica e Validar Comparação",
                                  "subSteps": [
                                    "Implemente ambos métodos em código para EDO y' = λy, |λ| pequeno/grande.",
                                    "Meça tempo de CPU e erro global para tolerância fixa (ex: 1e-6).",
                                    "Varra tolerâncias, plote tempo vs. erro.",
                                    "Conte avaliações de f para custo exato.",
                                    "Conclua: embedded tipicamente 1.5-3x mais rápido para mesma precisão."
                                  ],
                                  "verification": "Gere relatório com tabelas/plots mostrando superioridade computacional do embedded.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com SciPy (odeint ou solve_ivp), ou MATLAB, EDOs teste (Van der Pol, stiff).",
                                  "tips": "Use %timeit ou profilers para medir custo real.",
                                  "learningObjective": "Validar teoria via experimento computacional.",
                                  "commonMistakes": "Não normalizar por comprimento de intervalo; usar hardware inconsistente."
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y, y(0)=1 até t=5 com tol=1e-6: método embedded Dormand-Prince usa ~150 avaliações f, alcançando erro 1e-7 em 0.02s; passo duplo RK4 requer ~350 avaliações, 0.05s – embedded 2.3x mais eficiente.",
                              "finalVerifications": [
                                "Explica corretamente como embedded reutiliza estágios para estimativa de erro sem custo extra.",
                                "Calcula custo relativo preciso (ex: 6 vs. 12 avaliações por passo).",
                                "Identifica cenários onde não-embedded pode ser preferível (ex: simplicidade).",
                                "Interpreta gráfico de eficiência corretamente.",
                                "Implementa simulação simples validando teoria.",
                                "Discute limitações como dependência de ordem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na quantificação de custo (avaliações f e flops).",
                                "Correta identificação de trade-offs eficiência vs. complexidade.",
                                "Qualidade de análise numérica/experimental.",
                                "Clareza em comparações qualitativas/quantitativas.",
                                "Uso apropriado de exemplos e gráficos.",
                                "Compreensão de impacto no controle adaptativo de passo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação eficiente em ODE solvers (SciPy, MATLAB).",
                                "Física/Engenharia: Simulações dinâmicas (órbitas, circuitos).",
                                "Ciência da Computação: Análise de complexidade algorítmica O(n).",
                                "Otimização: Trade-offs em métodos numéricos para HPC."
                              ],
                              "realWorldApplication": "Em software como MATLAB ode45 ou SciPy solve_ivp, embedded Runge-Kutta acelera simulações em engenharia aeroespacial (trajectories), farmacocinética (modelos PK/PD) e clima (modelos DEs), reduzindo tempo de computação em fatores 2-5 para precisão equivalente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.3",
                        "name": "Estimativa Aproximada de Erro Local",
                        "description": "Técnica para estimar o erro local usando a diferença entre as soluções das ordens p e p+1 dos métodos embedded, aproximando o erro como |y_h - y_{h}^*| / (2^p - 1) ou similar.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.3.1",
                            "name": "Calcular Estimativa de Erro",
                            "description": "Derivar e aplicar a fórmula de estimativa de erro local: e ≈ |y_{p+1} - y_p| / (2^p - 1), validando com exemplos numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de erro local e aproximações numéricas",
                                  "subSteps": [
                                    "Defina erro local em métodos numéricos para EDOs.",
                                    "Explique a notação y_p (aproximação com passo h) e y_{p+1} (com passo h/2).",
                                    "Discuta a ordem de truncamento p e sua relação com o erro O(h^{p+1}).",
                                    "Identifique quando usar estimativas aproximadas de erro em controle de passo.",
                                    "Revise exemplos simples de métodos como Euler ou Runge-Kutta."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e dê um exemplo de y_p e y_{p+1}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Visualize graficamente a evolução do erro com refinamento de malha.",
                                  "learningObjective": "Entender a base teórica do erro local e sua dependência na ordem p.",
                                  "commonMistakes": [
                                    "Confundir erro local com erro global.",
                                    "Ignorar a suposição de ordem p constante."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula de estimativa de erro local",
                                  "subSteps": [
                                    "Assuma erro de truncamento e(y) ≈ C h^{p+1} para aproximação y_p.",
                                    "Escreva a expansão para y_{p+1} com passo h/2: e(y_{p+1}) ≈ C (h/2)^{p+1}.",
                                    "Calcule a diferença |y_{p+1} - y_p| ≈ |C h^{p+1} (1/2^{p+1} - 1)|.",
                                    "Simplifique para e ≈ |y_{p+1} - y_p| / |2^{p+1} - 1| / 2, ajustando para a forma dada: / (2^p - 1).",
                                    "Verifique a derivação para p=1 (Euler): e ≈ |y_{p+1} - y_p|."
                                  ],
                                  "verification": "Derive a fórmula passo a passo em um papel e confira com a fórmula dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de papel quadriculado"
                                  ],
                                  "tips": "Use a expansão em série de Taylor para justificar o coeficiente C.",
                                  "learningObjective": "Derivar matematicamente a fórmula e ≈ |y_{p+1} - y_p| / (2^p - 1).",
                                  "commonMistakes": [
                                    "Erro no expoente: confundir 2^{p+1} com 2^p.",
                                    "Esquecer o sinal absoluto na diferença."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a fórmula em um exemplo numérico simples",
                                  "subSteps": [
                                    "Escolha EDO y' = -y, y(0)=1, intervalo [0,1], método Euler (p=1).",
                                    "Compute y_p com h=0.5 (2 passos).",
                                    "Compute y_{p+1} com h=0.25 (4 passos).",
                                    "Calcule e ≈ |y_{p+1} - y_p| / (2^1 - 1) = |y_{p+1} - y_p|.",
                                    "Compare com solução exata y=exp(-x)."
                                  ],
                                  "verification": "Obtenha e < 0.1 e anote os valores computados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para cálculos",
                                    "Tabela para anotar passos"
                                  ],
                                  "tips": "Automatize cálculos em uma planilha para evitar erros aritméticos.",
                                  "learningObjective": "Executar cálculo prático da estimativa de erro.",
                                  "commonMistakes": [
                                    "Erro na implementação do método numérico.",
                                    "Usar h errado na contagem de passos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a estimativa e analisar resultados",
                                  "subSteps": [
                                    "Repita o exemplo para p=2 (método de Heun ou RK2).",
                                    "Compare estimativa e com erro real (solução exata).",
                                    "Analise se e diminui com refinamento (ordem esperada).",
                                    "Teste com outra EDO, como y' = y(1-y), y(0)=0.5.",
                                    "Discuta limitações da fórmula (ex: não-linearidades fortes)."
                                  ],
                                  "verification": "Crie tabela comparando estimado vs. real para 3 casos; erro relativo < 20%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico (Python/Octave)",
                                    "Gráfico de erros"
                                  ],
                                  "tips": "Plote log(erro) vs log(h) para confirmar ordem p.",
                                  "learningObjective": "Validar precisão da fórmula e identificar cenários de uso.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de arredondamento.",
                                    "Não normalizar erros relativos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 em [0,1] com Euler (p=1): h=0.5 → y_p=0.75; h=0.25 → y_{p+1}=0.8164; e ≈ |0.8164-0.75| /1 = 0.0664 (erro real ≈0.0632, boa aproximação).",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula para qualquer p.",
                                "Aplica em exemplo com h e h/2 obtendo e coerente.",
                                "Valida com solução exata (erro relativo <15%).",
                                "Identifica limitações em EDOs não-lineares.",
                                "Explica uso em adaptativo de passo.",
                                "Cria tabela de comparação para p=1 e p=2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação (100% dos passos corretos).",
                                "Correção nos cálculos numéricos (erro <5% em exemplos).",
                                "Análise qualitativa de resultados (ordem observada).",
                                "Clareza na documentação de passos e tabelas.",
                                "Identificação de pelo menos 2 limitações.",
                                "Capacidade de generalizar para outros métodos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com bibliotecas como SciPy.",
                                "Física: Estimar erros em simulações de movimento oscilatório.",
                                "Engenharia: Controle de precisão em simulações CFD.",
                                "Estatística: Análise de incertezas em modelos preditivos.",
                                "Computação Científica: Otimização adaptativa de malha."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou dinâmica de veículos autônomos, onde se ajusta o tamanho de passo dinamicamente para equilibrar precisão e eficiência computacional, evitando desperdício de recursos em regiões de baixa variação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3.2",
                            "name": "Usar Estimativa no Controle de Passo",
                            "description": "Aplicar a estimativa de erro para decidir aceitação/rejeição de passo e ajuste adaptativo de h (ex: h_new = h * (tol / |e|)^{1/(p+1)}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a Estimativa de Erro Local Aproximada",
                                  "subSteps": [
                                    "Implemente dois métodos numéricos de ordens p e p+1 para o mesmo intervalo de passo h.",
                                    "Calcule as soluções y_p e y_{p+1} nos pontos finais do intervalo.",
                                    "Aplique a fórmula de estimativa de erro: |e| ≈ |y_{p+1} - y_p| / (2^p - 1)."
                                  ],
                                  "verification": "Verifique se |e| foi calculado corretamente comparando com valores analíticos conhecidos para funções teste simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou planilha Excel",
                                    "Calculadora científica",
                                    "Função teste como y' = -y, y(0)=1"
                                  ],
                                  "tips": "Use funções suaves e bem comportadas inicialmente para evitar complicações.",
                                  "learningObjective": "Compreender e aplicar a fórmula de Richardson para extrapolação de erro.",
                                  "commonMistakes": [
                                    "Confundir ordens p e p+1",
                                    "Esquecer o denominador 2^p - 1",
                                    "Usar h diferente nos dois métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decidir Aceitação ou Rejeição do Passo",
                                  "subSteps": [
                                    "Defina a tolerância tol (ex: 1e-6) e compare |e| ≤ tol.",
                                    "Se |e| ≤ tol, aceite o passo e use y_{p+1} como solução avançada.",
                                    "Se |e| > tol, rejeite o passo e prepare para redução de h.",
                                    "Registre o número de tentativas para evitar loops infinitos."
                                  ],
                                  "verification": "Simule um passo e confirme se a decisão de aceitação/rejeição está correta via tabela de resultados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo ou fluxograma",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Sempre use tolerância relativa para escalabilidade com diferentes magnitudes de y.",
                                  "learningObjective": "Aplicar critério de aceitação baseado em erro estimado vs. tolerância.",
                                  "commonMistakes": [
                                    "Usar tol absoluta sem normalizar",
                                    "Aceitar passos com |e| muito próximo de tol sem margem de segurança",
                                    "Não contar rejeições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o Tamanho de Passo h Adaptativamente",
                                  "subSteps": [
                                    "Para rejeição: calcule h_new = h * (tol / |e|)^{1/(p+1)}.",
                                    "Para aceitação: calcule h_new = h * (tol / |e|)^{1/(p+1)} mas limite crescimento (ex: max(0.9 * h * fator, h * 2)).",
                                    "Aplique fator de segurança (ex: 0.9) para estabilidade: h_new *= 0.9.",
                                    "Garanta h_new > h_min para evitar estagnação."
                                  ],
                                  "verification": "Calcule h_new manualmente e verifique se reduz |e| no próximo passo simulado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para protótipo simples",
                                    "Tabela de h, |e|, tol"
                                  ],
                                  "tips": "Teste com expoente 1/(p+1) exato; para RK4, p=4.",
                                  "learningObjective": "Implementar fórmula de ajuste adaptativo de h baseada em erro.",
                                  "commonMistakes": [
                                    "Erro no expoente 1/(p+1)",
                                    "Não aplicar fator de segurança",
                                    "Permitir h_new negativo ou zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar o Loop de Controle de Passo Completo",
                                  "subSteps": [
                                    "Estruture um loop while até atingir o intervalo final.",
                                    "Integre passos 1-3 em um algoritmo iterativo.",
                                    "Monitore custo computacional (número de função f avaliações).",
                                    "Teste com problema modelo até convergência."
                                  ],
                                  "verification": "Execute simulação completa e compare solução numérica com exata (erro global < tol).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico (Python com SciPy ou MATLAB)",
                                    "Problema teste: y' = y, y(0)=1, [0,1]"
                                  ],
                                  "tips": "Comece com h inicial conservador (ex: 0.1).",
                                  "learningObjective": "Montar algoritmo completo de controle de passo adaptativo.",
                                  "commonMistakes": [
                                    "Loop infinito sem h_min",
                                    "Não resetar y ao rejeitar",
                                    "Ignorar custo de avaliações extras"
                                  ]
                                }
                              ],
                              "practicalExample": "No método de Runge-Kutta de ordem 4 (RK4) com embedded RK3 para erro, integre y' = -2xy, y(0)=1 de x=0 a x=1 com tol=1e-5. Calcule |e| ≈ |RK4 - RK3|/15, rejeite se >tol, ajuste h_new = h*(tol/|e|)^{0.2} *0.9. Resultado: solução exata y=e^{-x^2}, erro global <1e-5 em ~20 passos adaptativos.",
                              "finalVerifications": [
                                "O aluno calcula corretamente |e| usando extrapolação de Richardson.",
                                "Decisão de aceitação/rejeição é precisa para casos limite.",
                                "Fórmula h_new é aplicada com fator de segurança e limites.",
                                "Loop completo atinge intervalo final com erro global ≤ tol.",
                                "Custo computacional é monitorado e otimizado.",
                                "Testes com múltiplos problemas confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na estimativa de erro local (erro <5% vs. analítico).",
                                "Correção na decisão aceitação/rejeição (100% em testes).",
                                "Ajuste de h leva a redução efetiva de |e| (fator >0.5 por rejeição).",
                                "Eficiência: número de passos < 2x método fixo para mesma tol.",
                                "Implementação livre de bugs em código ou pseudocódigo.",
                                "Explicação clara do raciocínio matemático."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (loops, funções numéricas).",
                                "Física: Simulações de trajetórias em dinâmica (ODEs adaptativas).",
                                "Engenharia: Otimização em controle de processos industriais.",
                                "Estatística: Análise de incerteza em modelagem preditiva."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (modelos ODEs com h adaptativo para eficiência em grids globais) ou farmacocinética (ajuste de passos para capturar picos de concentração sem desperdício computacional), garantindo precisão com mínimo custo em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3.3",
                            "name": "Avaliar Precisão da Estimativa",
                            "description": "Analisar limitações e precisão da estimativa embedded, considerando problemas stiff e estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Estimativa Embedded",
                                  "subSteps": [
                                    "Estudar a definição de métodos Runge-Kutta embedded (ex: RK45).",
                                    "Revisar as fórmulas para y_{n+1}^h (alta ordem) e y_{n+1}^l (baixa ordem).",
                                    "Calcular a estimativa de erro local: est_err = |y_{n+1}^h - y_{n+1}^l| / (1 - 2^{1-p}).",
                                    "Explicar o papel no controle adaptativo de passo.",
                                    "Discutir a ordem de precisão da estimativa (geralmente p-1)."
                                  ],
                                  "verification": "Resumir em um parágrafo as fórmulas e o propósito da estimativa embedded.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre RK embedded",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Desenhe o Butcher tableau para visualizar os estágios.",
                                  "learningObjective": "Entender como a estimativa embedded aproxima o erro local truncado.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Ignorar o fator de normalização na estimativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Precisão em Problemas Não-Stiff",
                                  "subSteps": [
                                    "Escolher um PVI não-stiff simples (ex: y' = -y, y(0)=1).",
                                    "Implementar RK embedded e calcular est_err em vários passos.",
                                    "Comparar est_err com erro real (solução exata).",
                                    "Plotar gráfico de est_err vs. erro verdadeiro.",
                                    "Calcular fator de eficiência: log(est_err / erro_real)."
                                  ],
                                  "verification": "Gerar gráfico mostrando concordância entre est_err e erro real (fator próximo de 1).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico (Python com scipy.integrate, MATLAB)",
                                    "Solução exata do PVI modelo"
                                  ],
                                  "tips": "Use passos iniciais pequenos para alta precisão.",
                                  "learningObjective": "Quantificar a precisão da estimativa em cenários ideais.",
                                  "commonMistakes": [
                                    "Não normalizar o erro adequadamente",
                                    "Escolher PVI com solução oscilatória"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Limitações da Estimativa",
                                  "subSteps": [
                                    "Estudar limitações teóricas: precisão de ordem p-1, assume Lipschitz.",
                                    "Analisar falhas em singularidades ou não-smoothness.",
                                    "Testar com PVI onde Lipschitz falha levemente.",
                                    "Discutir subestimação/suprestimação sistemática.",
                                    "Listar condições para validade da estimativa."
                                  ],
                                  "verification": "Elaborar tabela com limitações e exemplos contrários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos sobre análise de erro em RK",
                                    "Exemplos de PVIs problemáticos"
                                  ],
                                  "tips": "Compare com análise assintótica de erro.",
                                  "learningObjective": "Reconhecer cenários onde a estimativa falha.",
                                  "commonMistakes": [
                                    "Assumir precisão infinita",
                                    "Ignorar dependência na norma do Jacobiano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto em Problemas Stiff",
                                  "subSteps": [
                                    "Definir problema stiff (ex: y' = -1000y + sin(t), y(0)=1).",
                                    "Implementar RK embedded e observar est_err em escalas stiff.",
                                    "Comparar com método implícito (ex: BDF).",
                                    "Analisar rejeição de passos devido a est_err inflado.",
                                    "Explicar perda de precisão por modos rápidos não resolvidos."
                                  ],
                                  "verification": "Relatório com plots de solução e est_err para stiff vs. não-stiff.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software com solvers explícitos/implícitos",
                                    "Exemplos stiff padrão (Robertson, van der Pol)"
                                  ],
                                  "tips": "Monitore o passo h: passos muito pequenos indicam stiff.",
                                  "learningObjective": "Compreender degradação da precisão em stiff ODEs.",
                                  "commonMistakes": [
                                    "Usar tolerâncias muito soltas",
                                    "Confundir instabilidade com erro de truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Estabilidade e Conclusões Gerais",
                                  "subSteps": [
                                    "Revisar regiões de estabilidade de RK embedded.",
                                    "Testar estabilidade com PVI no limite da estabilidade.",
                                    "Avaliar se est_err detecta instabilidade.",
                                    "Sintetizar relatório: precisão, limitações, stiff/estabilidade.",
                                    "Propor melhorias (ex: switch para implícito)."
                                  ],
                                  "verification": "Apresentar análise completa com recomendações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagramas de estabilidade RK",
                                    "Ferramentas de plot (Matplotlib)"
                                  ],
                                  "tips": "Use escalas log para visualizar estabilidade.",
                                  "learningObjective": "Integrar precisão, stiff e estabilidade na avaliação.",
                                  "commonMistakes": [
                                    "Ignorar estabilidade A vs. B",
                                    "Generalizar de casos não-stiff"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o PVI y' = λy, y(0)=1 com λ=-100 (stiff). Use RK45 embedded com tol=1e-6. Calcule est_err em cada passo, compare com exata e^{λt}. Observe: em não-stiff (λ=-1), est_err ≈ erro real; em stiff, est_err subestima devido a modos rápidos, levando a passos minúsculos e possível falha.",
                              "finalVerifications": [
                                "est_err correlaciona com erro real em >90% dos passos não-stiff.",
                                "Identifica pelo menos 3 limitações específicas da estimativa.",
                                "Demonstra degradação em stiff com plots comparativos.",
                                "Explica impacto na estabilidade com exemplo.",
                                "Propõe critérios para alternar solvers.",
                                "Relatório sintetiza análise quantitativa e qualitativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de fórmulas embedded (20%)",
                                "Análise quantitativa correta com gráficos (25%)",
                                "Identificação exata de limitações e stiff (20%)",
                                "Discussão de estabilidade fundamentada (15%)",
                                "Relatório claro e estruturado (10%)",
                                "Exemplos práticos relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de dinâmica em sistemas rígidos (ex: osciladores amortecidos).",
                                "Computação: Implementação de solvers adaptativos em bibliotecas como SciPy.",
                                "Engenharia: Controle de processos industriais com ODEs stiff.",
                                "Estatística: Análise de erro em modelagem probabilística."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos (stiff devido a capacitores/indutores), avaliar precisão da estimativa embedded permite otimizar passos adaptativos, evitando desperdício computacional ou instabilidade em softwares como SPICE, garantindo precisão em designs de chips e sistemas embarcados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Critérios de Aceitação e Rejeição",
                    "description": "Condições baseadas em tolerâncias para decidir se um passo é aceito ou rejeitado.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Estimativa do Erro Local",
                        "description": "Técnicas para calcular o erro de truncamento local em métodos de Runge-Kutta embutidos ou de passo simples e múltiplo, essencial para o controle de passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Calcular erro local com métodos embutidos",
                            "description": "Implementar a estimativa de erro local utilizando pares de Runge-Kutta embutidos, como RK4(5), subtraindo soluções de ordens diferentes para obter o erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios dos Métodos Runge-Kutta Embutidos",
                                  "subSteps": [
                                    "Revise o método Runge-Kutta de ordem 4 (RK4) padrão e suas limitações em precisão local.",
                                    "Estude o conceito de métodos embutidos: calcular duas aproximações de ordens diferentes (ex: ordem 4 e 5) no mesmo passo.",
                                    "Aprenda que o erro local é estimado pela diferença entre as soluções de ordem inferior e superior.",
                                    "Entenda a fórmula geral: erro ≈ |y_{n+1}^{(p)} - y_{n+1}^{(p+1)}| / (ordem_superior - ordem_inferior), onde p=4.",
                                    "Discuta adaptação de passo baseada no erro estimado comparado a uma tolerância."
                                  ],
                                  "verification": "Explique em suas palavras como o erro local é estimado e dê um exemplo numérico simples manual.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Notebook Jupyter ou papel e caneta; documentação de métodos numéricos (ex: Wikipedia RK embutido)",
                                  "tips": "Visualize o Butcher tableau para entender estágios compartilhados que economizam computação.",
                                  "learningObjective": "Dominar o conceito teórico de estimativa de erro local via métodos embutidos.",
                                  "commonMistakes": "Confundir erro local (por passo) com erro global (acumulado); ignorar normalização do erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e Memorizar Coeficientes do Método RK4(5)",
                                  "subSteps": [
                                    "Pesquise o método Dormand-Prince RK4(5), o padrão para 'RK45'.",
                                    "Liste os coeficientes do tableau de Butcher: a_ij, b_i^{(4)}, b_i^{(5)}, c_i (7 estágios).",
                                    "Exemplo: c = [0, 0.2, 0.3, 0.6, 0.8, 0.9, 1.0]; b4 e b5 específicos.",
                                    "Implemente uma função para armazenar esses coeficientes em arrays NumPy.",
                                    "Verifique os coeficientes somando b4 e b5 para consistência."
                                  ],
                                  "verification": "Imprima os coeficientes e confirme que somam corretamente a 1 para ambos vetores b.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": "Python com NumPy; referência: SciPy ode45 ou livro de Burden & Faires",
                                  "tips": "Copie coeficientes exatos de fontes confiáveis para evitar erros de arredondamento.",
                                  "learningObjective": "Conhecer precisamente o esquema RK4(5) para implementação.",
                                  "commonMistakes": "Erros de digitação nos coeficientes flutuantes; usar aproximações erradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um Passo Completo do Método RK4(5)",
                                  "subSteps": [
                                    "Defina uma função que recebe f(t,y), t_n, y_n, h e retorne y4, y5.",
                                    "Calcule os 7 k_i = f(t_n + c_i h, y_n + h sum a_ij k_j).",
                                    "Compute y4 = y_n + h * sum b4_i k_i; y5 = y_n + h * sum b5_i k_i.",
                                    "Estruture o código em loops para os estágios, usando vetores para eficiência.",
                                    "Teste com f(y)= -y, h=0.1 para depuração manual."
                                  ],
                                  "verification": "Execute um passo e compare y4, y5 com cálculo manual para o primeiro estágio.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Python/Jupyter com NumPy; EDO de teste y'=-y",
                                  "tips": "Use broadcasting NumPy para k's como array 2D (estágios x dims y).",
                                  "learningObjective": "Codificar corretamente os estágios compartilhados do RK4(5).",
                                  "commonMistakes": "Índices off-by-one nos loops de estágios; esquecer h nos argumentos de f."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Aplicar a Estimativa de Erro Local",
                                  "subSteps": [
                                    "Calcule erro_local = |y5 - y4| / 15 (pois ordem 5-4=1, mas fator ajustado).",
                                    "Normalise o erro: max(erro / tol) sobre componentes de y.",
                                    "Decida aceitação: se erro < 1, aceite y5 e ajuste h_next = h * (tol/erro)^(1/5).",
                                    "Para rejeição: h_next = h * 0.8 * (tol/erro)^(1/4).",
                                    "Integre em um loop de solver simples com 5-10 passos."
                                  ],
                                  "verification": "Compare erro estimado com erro exato (solução analítica) para h variados.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": "Código do passo anterior; solução exata exp(-t)",
                                  "tips": "Use norma infinito para erro em vetores y multidimensionais.",
                                  "learningObjective": "Implementar estimativa de erro e controle adaptativo básico.",
                                  "commonMistakes": "Não normalizar erro para vetores; fator de ajuste de h incorreto."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 em [0,1] com h inicial=0.2 usando RK4(5). No primeiro passo: calcule k1 a k7, y4≈0.6703, y5≈0.6700, erro_local≈0.00032. Se tol=1e-3, aceite e ajuste h.",
                              "finalVerifications": [
                                "Código executa sem erros para EDO linear e não-linear.",
                                "Erro estimado converge para zero com h menor, matching solução exata.",
                                "Ajuste de h adapta corretamente (aumenta se erro baixo, diminui se alto).",
                                "Solução numérica coincide com scipy.integrate.solve_ivp(method='RK45') em 1e-6.",
                                "Teste com y' = y(1-y), logística, confirma precisão.",
                                "Norma do erro local é computada corretamente para y vetorial."
                              ],
                              "assessmentCriteria": [
                                "Coeficientes RK4(5) exatos e implementados sem erros.",
                                "Cálculo de y4 e y5 usa estágios compartilhados eficientemente.",
                                "Estimativa de erro local usa diferença y5-y4 normalizada corretamente.",
                                "Lógica de aceitação/rejeição e ajuste de h segue padrões (fator 1/5).",
                                "Código é modular, legível e testado com múltiplas EDOs.",
                                "Precisão: erro global <1e-4 em intervalo [0,1] com tol=1e-6."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores harmônicos ou trajetórias planetárias.",
                                "Engenharia: Controle de sistemas dinâmicos e robótica.",
                                "Ciência de Dados: Otimização em machine learning (gradientes adaptativos).",
                                "Computação Científica: Bibliotecas como SciPy e TensorFlow solvers."
                              ],
                              "realWorldApplication": "Usado em solvers como MATLAB ode45 ou SciPy solve_ivp para modelar epidemias (SIR), dinâmica de fluidos, trajetórias de foguetes na NASA, e previsões climáticas, garantindo precisão adaptativa sem passos fixos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Normas para avaliação do erro",
                            "description": "Aplicar normas escalares (como máximo ou L2) ou vetoriais para quantificar o erro local estimado em problemas de valor inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Erro Local e Normas",
                                  "subSteps": [
                                    "Defina erro local em métodos numéricos para PVIs como a diferença entre soluções aproximadas em um passo.",
                                    "Explique o papel do controle de passo em métodos adaptativos como Runge-Kutta.",
                                    "Liste tipos de normas: escalares (máximo, L1, L2) e vetoriais (norma euclidiana, norma infinito).",
                                    "Discuta por que quantificar o erro é crucial para aceitação/rejeição de passos.",
                                    "Revise fórmulas básicas: ||e||_∞ = max |e_i|, ||e||_2 = sqrt(∑ e_i²)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e forneça exemplos de normas aplicadas a vetores simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. Métodos para PVIs)",
                                    "Notas de aula sobre normas vetoriais"
                                  ],
                                  "tips": "Use analogias: norma máximo como 'pior caso', L2 como 'energia total do erro'.",
                                  "learningObjective": "Identificar e diferenciar normas escalares e vetoriais no contexto de erros locais.",
                                  "commonMistakes": [
                                    "Confundir norma escalar com vetorial",
                                    "Ignorar normalização em PVIs de alta dimensão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Normas Escalares para Erro Local",
                                  "subSteps": [
                                    "Selecione uma norma escalar (ex: máximo ou L2) para um vetor de erro estimado.",
                                    "Implemente cálculo manual: para norma máximo, encontre o valor absoluto máximo.",
                                    "Para L2: some quadrados dos componentes e tire raiz quadrada.",
                                    "Aplique em um passo de integração numérica simples.",
                                    "Compare resultados de diferentes normas no mesmo erro."
                                  ],
                                  "verification": "Calcule normas para um vetor de erro fornecido (ex: [0.1, 0.05, 0.2]) e justifique escolha.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter para verificação",
                                    "Exemplos de PVIs resolvidos"
                                  ],
                                  "tips": "Sempre verifique unidades: erro deve ser adimensional ou consistente.",
                                  "learningObjective": "Executar cálculos precisos de normas escalares em erros locais.",
                                  "commonMistakes": [
                                    "Esquecer raiz na L2",
                                    "Usar soma em vez de máximo na norma ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Normas Vetoriais em Estimativas de Erro",
                                  "subSteps": [
                                    "Estenda normas para sistemas vetoriais em PVIs (y' = f(t,y) com y ∈ R^n).",
                                    "Estime erro local usando diferenças entre soluções de ordem h e 2h (Richardson).",
                                    "Calcule norma vetorial do erro: ||e|| = sqrt(∑ ||e_i||^2) ou similar.",
                                    "Defina tolerância (tol) e compare ||e|| < tol para aceitação.",
                                    "Simule rejeição se ||e|| > tol e ajuste passo h."
                                  ],
                                  "verification": "Demonstre aceitação/rejeição para um PVI com h=0.1 e erro calculado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python (SciPy odeint)",
                                    "PVI de teste: y' = -y, y(0)=1"
                                  ],
                                  "tips": "Escolha norma baseada no problema: L2 para erros 'médios', ∞ para conservadorismo.",
                                  "learningObjective": "Integrar normas vetoriais em critérios de controle de passo.",
                                  "commonMistakes": [
                                    "Não ponderar componentes em sistemas não escalares",
                                    "Ignorar fator de ordem no extrapolador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Exemplo Completo e Análise",
                                  "subSteps": [
                                    "Resolva PVI y' = y + t, y(0)=1 com RK4 e estimativa de erro.",
                                    "Calcule erro local em cada passo usando norma escolhida.",
                                    "Implemente loop de controle: aceite se norma < 1e-6, rejeite e halve h.",
                                    "Registre histórico de h e normas para análise.",
                                    "Otimize: sugira norma ideal baseada em resultados."
                                  ],
                                  "verification": "Produza tabela com passos, h, norma erro e decisão (aceito/rejeitado).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python pronto para RK adaptativo",
                                    "Gráficos de solução vs exata"
                                  ],
                                  "tips": "Teste com tol variadas para ver impacto na eficiência.",
                                  "learningObjective": "Aplicar normas em fluxo completo de controle de erro.",
                                  "commonMistakes": [
                                    "Erro na estimativa de ordem (assumir p=1 sempre)",
                                    "Sobrestimar precisão sem solução exata"
                                  ]
                                }
                              ],
                              "practicalExample": "Para PVI y' = -2y + t, y(0)=0 em [0,1], use RK23. Em t=0.1, h=0.1, solução h: y1=[0.095], 2h: y2=[0.102]. Erro local e ≈ (y2 - y1)/ (1-2^{-2}) = [-0.008]. Norma L∞=0.008 < tol=0.01 → aceitar; senão rejeitar e h←h/2.",
                              "finalVerifications": [
                                "Cálculo correto de norma para vetores de erro fornecidos.",
                                "Implementação de critério aceita/rejeita em código ou manual.",
                                "Interpretação: norma < tol implica precisão local desejada.",
                                "Ajuste adaptativo de h baseado em norma erro.",
                                "Comparação de normas diferentes no mesmo exemplo.",
                                "Análise de eficiência: número de passos vs precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas (erro <1%).",
                                "Correta identificação de normas escalares vs vetoriais.",
                                "Aplicação contextual em PVIs com controle de passo.",
                                "Clareza na justificativa de escolha de norma.",
                                "Eficiência demonstrada em exemplo prático.",
                                "Ausência de erros comuns em estimativas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações dinâmicas (órbitas, circuitos) com solvers adaptativos.",
                                "Computação: Implementação em bibliotecas como SciPy ODE.",
                                "Engenharia: Controle de qualidade em modelagem numérica.",
                                "Estatística: Normas L2 ligadas a mínimos quadrados."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, normas de erro garantem precisão em previsões de longo prazo, ajustando passos para eficiência computacional sem perda de acurácia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Interpretação da estimativa de erro",
                            "description": "Analisar a precisão da estimativa de erro local e sua relação com a ordem do método numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de estimativa de erro local e ordem do método numérico",
                                  "subSteps": [
                                    "Definir erro local como a diferença entre a solução numérica exata em um passo e a solução verdadeira no final desse passo.",
                                    "Explicar a ordem do método: um método de ordem p satisfaz |erro local| ≈ C h^{p+1}, onde h é o tamanho do passo.",
                                    "Discutir métodos com estimativa embutida, como Runge-Kutta de Fehlberg ou Dormand-Prince, que computam duas aproximações de ordens diferentes.",
                                    "Diferenciar erro local de erro global e sua acumulação ao longo da integração.",
                                    "Revisar fórmula assintótica do erro local: est_{local} = |y_{p+1} - y_p| / (2^p - 1), onde y_p e y_{p+1} são soluções de ordens p e p+1."
                                  ],
                                  "verification": "Escrever definições em palavras próprias e exemplificar com um método de ordem 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise numérica",
                                    "Livro-texto de métodos numéricos para EDOs",
                                    "Quadro ou papel para anotações"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o passo de integração e onde o erro local ocorre.",
                                  "learningObjective": "Dominar as definições teóricas de erro local e ordem, preparando para cálculos práticos.",
                                  "commonMistakes": "Confundir erro local (por passo) com erro global (acumulado); ignorar o fator h^{p+1} na dependência do tamanho do passo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a estimativa de erro local em um exemplo concreto",
                                  "subSteps": [
                                    "Escolher uma EDO simples, como y' = -y, y(0) = 1, e método RK4 com estimativa (usar aproximações de ordem 4 e 5).",
                                    "Implementar os estágios do método para um passo h=0.1, computando y4 e y5.",
                                    "Calcular est_{local} = |y5 - y4| / 15 (para ordens 4 e 5).",
                                    "Comparar com solução exata y(h) = e^{-h} para validar.",
                                    "Repetir para outro ponto inicial para observar variação."
                                  ],
                                  "verification": "Obter valor numérico de est_{local} com precisão de 4 casas decimais e comparar com erro verdadeiro (<5% de diferença).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora científica ou software como Python/MATLAB com bibliotecas odeint ou solve_ivp",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Automatize cálculos em código para evitar erros aritméticos manuais.",
                                  "learningObjective": "Aplicar fórmula de estimativa em método embutido e validar contra verdade.",
                                  "commonMistakes": "Erro na contagem de estágios do RK; usar divisor incorreto para ordens específicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a relação entre estimativa de erro e ordem do método",
                                  "subSteps": [
                                    "Executar o método com tamanhos de passo h = 0.2, 0.1, 0.05, registrando est_{local}.",
                                    "Calcular log(est_{local}) vs log(h) e estimar inclinação da reta (deve ser ≈ p+1).",
                                    "Confirmar ordem teórica: para RK4, inclinação ≈5.",
                                    "Testar sensibilidade: variar EDO para uma não-linear como y' = y^2.",
                                    "Interpretar: se inclinação difere, investigar causas como truncamento superior."
                                  ],
                                  "verification": "Gerar gráfico com inclinação calculada dentro de 10% do valor teórico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de plotagem (Python com matplotlib ou MATLAB)",
                                    "Dados tabulados de simulações"
                                  ],
                                  "tips": "Use escala log-log para visualização clara da relação poder.",
                                  "learningObjective": "Quantificar numericamente como est_{local} escala com h, validando ordem.",
                                  "commonMistakes": "Escolha inadequada de intervalo h (muito próximo causa underflow); ignorar regime assintótico (h pequeno demais)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar estimativa para critérios de aceitação e rejeição no controle de passo",
                                  "subSteps": [
                                    "Definir tolerância tol (ex: 1e-6) e fator de segurança 0.9.",
                                    "Comparar est_{local} com tol: se est_{local} < tol, aceitar e sugerir h_new = h * (tol / est_{local})^{1/(p+1)}.",
                                    "Se rejeitar, h_new = h * 0.5 ou similar.",
                                    "Simular sequência de passos com adaptação e monitorar erro acumulado.",
                                    "Avaliar impacto: precisão vs custo computacional."
                                  ],
                                  "verification": "Simular 10 passos adaptativos e verificar se erro global < 10 * tol.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para solver adaptativo",
                                    "Gráficos de h vs x e erro vs x"
                                  ],
                                  "tips": "Inclua limite superior/inferior para h_new para estabilidade.",
                                  "learningObjective": "Usar est_{local} para decisões práticas em solvers adaptativos.",
                                  "commonMistakes": "Não aplicar fator de segurança, levando a rejeições excessivas; fator errado na atualização de h."
                                }
                              ],
                              "practicalExample": "Ao resolver y' = y(1 - y), y(0)=0.5 (modelo logístico) com Dormand-Prince (ordem 5), no passo inicial h=0.1, obtém-se y5 ≈ 0.5234, y4 ≈ 0.5235, est_{local} ≈ 2.1e-7. Como est_{local} << tol=1e-6, aceita-se e h_new ≈ 0.15, demonstrando alta precisão esperada pela ordem 5.",
                              "finalVerifications": [
                                "Explicar corretamente a fórmula assintótica do erro local.",
                                "Calcular est_{local} em novo exemplo com erro <5%.",
                                "Plotar log-log e identificar ordem corretamente.",
                                "Simular controle de passo com decisões consistentes.",
                                "Discutir limitações da estimativa em EDOs rígidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições sem erros (90%).",
                                "Cálculos numéricos: exatidão em 4 casas decimais.",
                                "Análise gráfica: inclinação correta ±10%.",
                                "Interpretação prática: h adaptado otimiza custo/precisão.",
                                "Validação: erro global controlado por tol.",
                                "Criatividade: extensão a EDO real."
                              ],
                              "crossCurricularConnections": [
                                "Física: simulações dinâmicas (ex: osciladores com precisão adaptativa).",
                                "Ciência da Computação: implementação de solvers em bibliotecas como SciPy.",
                                "Estatística: quantificação de incertezas em modelos estocásticos.",
                                "Engenharia: controle de qualidade em simulações CFD."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas ou simulações aeroespaciais, interpretar est_{local} permite ajustar h automaticamente, equilibrando precisão (ex: trajetórias de mísseis) e eficiência computacional em supercomputadores, evitando desperdício em regiões de baixa dinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Critérios de Aceitação",
                        "description": "Condições baseadas em tolerâncias absolutas e relativas para aceitar um passo no integrador adaptativo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Definir tolerâncias absoluta e relativa",
                            "description": "Estabelecer tolerâncias atol e rtol, computando o critério de aceitação como max(|e_i| / (atol + rtol * |y_i|)) < 1 para todos os componentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Tolerâncias Absoluta e Relativa",
                                  "subSteps": [
                                    "Defina tolerância absoluta (atol) como o limite máximo de erro independente da magnitude da solução.",
                                    "Defina tolerância relativa (rtol) como a fração máxima do valor absoluto da solução |y_i| permitida como erro.",
                                    "Explique a necessidade de combinar ambas: atol previne erros grandes em valores próximos de zero, rtol controla erros proporcionais em valores grandes.",
                                    "Analise exemplos: para y_i = 1e-10, atol domina; para y_i = 1e6, rtol domina.",
                                    "Discuta implicações em precisão numérica e custo computacional."
                                  ],
                                  "verification": "Escreva definições e exemplos em um parágrafo coeso, justificando o uso combinado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de análise numérica",
                                    "Livro 'Análise Numérica' de Burden & Faires (cap. EDOs)",
                                    "Calculadora ou papel para exemplos numéricos"
                                  ],
                                  "tips": "Visualize com gráficos de erro vs. magnitude de y para intuição.",
                                  "learningObjective": "Diferenciar atol e rtol, justificando sua combinação em critérios de precisão.",
                                  "commonMistakes": [
                                    "Confundir atol com erro absoluto total sem normalização",
                                    "Ignorar dependência de rtol em |y_i|",
                                    "Escolher valores sem considerar escala do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e Derivar a Fórmula do Critério de Aceitação",
                                  "subSteps": [
                                    "Apresente a fórmula: critério = max(|e_i| / (atol + rtol * |y_i|)) para todos os componentes i.",
                                    "Explique o numerador |e_i| como erro estimado no componente i.",
                                    "Detalhe o denominador atol + rtol * |y_i| como tolerância local adaptativa.",
                                    "Mostre que o passo é aceito se critério < 1 para todo i.",
                                    "Derive intuitivamente: normaliza erro absoluto por tolerância mista."
                                  ],
                                  "verification": "Escreva a fórmula do zero e compute manualmente para um vetor e = [1e-8, 1e-10], y = [1, 1e-6], atol=1e-12, rtol=1e-6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplos de código Python/MATLAB para verificação",
                                    "Documentação de solvers como ode45 (MATLAB)"
                                  ],
                                  "tips": "Pense no denominador como 'tolerância escalada' para cada componente.",
                                  "learningObjective": "Formular e interpretar o critério normalizado de aceitação de passo.",
                                  "commonMistakes": [
                                    "Esquecer o max sobre i",
                                    "Usar |e_i| sem normalização por |y_i|",
                                    "Confundir <1 com <=1 ou outros thresholds"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar Valores Apropriados para atol e rtol",
                                  "subSteps": [
                                    "Avalie a escala da solução: para |y| ~ 1, use rtol ≈ 1e-6 a 1e-8, atol ≈ rtol * 1e-6.",
                                    "Considere o problema: valores menores para precisão alta (ex: astrofísica), maiores para eficiência (ex: engenharia).",
                                    "Teste sensibilidade: varie atol/rtol e observe convergência/estabilidade.",
                                    "Adote convenções padrão: atol = 1e-12, rtol = 1e-6 para muitos solvers.",
                                    "Ajuste por componente se vetores multidimensionais (ex: rígidos vs. não-rígidos)."
                                  ],
                                  "verification": "Para um problema dado (ex: y'=-y), proponha atol/rtol e justifique com base na escala de y.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráficos de soluções analíticas aproximadas",
                                    "Ferramenta de plotagem (Python matplotlib ou Excel)",
                                    "Tabela de escalas típicas de problemas numéricos"
                                  ],
                                  "tips": "Comece com rtol desejado e defina atol = rtol * máquina_epsilon * escala_y.",
                                  "learningObjective": "Escolher atol e rtol otimizados para precisão e eficiência em contextos específicos.",
                                  "commonMistakes": [
                                    "Valores atol muito grandes levando a imprecisão em zeros",
                                    "rtol muito pequeno causando lentidão computacional",
                                    "Ignorar máquina epsilon (~1e-16 em double)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar o Critério em um Exemplo Prático",
                                  "subSteps": [
                                    "Implemente função para computar critério dado e, y, atol, rtol.",
                                    "Aplique em solver simples (ex: Runge-Kutta 4 adaptativo) para EDO teste.",
                                    "Teste aceitação/rejeição: ajuste h até critério <1.",
                                    "Compare com solvers prontos (scipy.integrate.odeint com tol).",
                                    "Analise impacto: número de passos e erro final."
                                  ],
                                  "verification": "Código roda sem erros e aceita/rejeita corretamente em 3 casos teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com numpy/scipy",
                                    "Jupyter Notebook",
                                    "Exemplo EDO: y' = -y, y(0)=1"
                                  ],
                                  "tips": "Use np.maximum.reduce para max eficiente em vetores.",
                                  "learningObjective": "Aplicar critério em código, validando aceitação de passos numéricos.",
                                  "commonMistakes": [
                                    "Divisão por zero se y_i=0 (atol previne)",
                                    "Esquecer abs em |e_i| e |y_i|",
                                    "Não vetorizar para múltiplos componentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver adaptativo para a EDO y' = -2y, y(0)=1 (solução y=exp(-2t)), estime erro e=[1e-7, 5e-8] em ponto y=[0.1, 0.01] com atol=1e-12, rtol=1e-6. Compute: para i=1, |e|/ (atol + rtol*|y|) = 1e-7 / (1e-12 + 1e-6*0.1) ≈ 1e-7 / 1.1e-7 ≈ 0.91 <1; para i=2 ≈ 5e-8 / 1.01e-11 ≈ 4.95 >1 → rejeitar passo.",
                              "finalVerifications": [
                                "Define corretamente atol e rtol com exemplos de escala.",
                                "Escreve e computa fórmula max(|e_i| / (atol + rtol*|y_i|)) <1.",
                                "Escolhe valores padrão/justificados para problema teste.",
                                "Implementa função que retorna True/False para aceitação.",
                                "Explica impacto em eficiência de solver.",
                                "Identifica erros comuns em implementação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e justificativa de atol/rtol (30%)",
                                "Correção na formulação e cálculo do critério (25%)",
                                "Adequação na escolha de valores para contexto (20%)",
                                "Funcionalidade e testes no código prático (15%)",
                                "Análise de erros comuns e conexões reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em Python/Scipy para solvers ODE.",
                                "Física Computacional: Controle de erro em simulações dinâmicas.",
                                "Engenharia de Software: Tolerâncias em testes unitários numéricos.",
                                "Estatística: Conceitos de erro relativo/absoluto em modelagem."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica orbital (NASA solvers), modelagem climática (GCMs) ou farmacocinética (previsão de concentrações), onde tolerâncias definem equilíbrio entre precisão diagnóstica e tempo de computação em supercomputadores, evitando instabilidades em trajetórias ou epidemias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Teste de aceitação do passo",
                            "description": "Verificar se o erro local estimado satisfaz o critério de aceitação, avançando o passo se atendido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Erro Local Estimado",
                                  "subSteps": [
                                    "Revise a definição de erro local em métodos numéricos de passo adaptativo, como o erro truncado em um único passo de integração.",
                                    "Estude fórmulas comuns para estimar o erro local, como em métodos de Runge-Kutta embutidos (ex: |y_{n+1}^{(p)} - y_{n+1}^{(q)}|).",
                                    "Identifique componentes: solução de ordem p e q, onde o erro é proporcional à diferença.",
                                    "Analise exemplos teóricos de como o erro local difere do erro global.",
                                    "Anote as suposições subjacentes, como suavidade da função."
                                  ],
                                  "verification": "Explique em suas palavras o que é erro local e dê um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de métodos de passo variável)",
                                    "Folha de papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o cálculo do erro em um passo h.",
                                  "learningObjective": "Definir e diferenciar erro local de erro global em métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir erro local com erro global acumulado",
                                    "Ignorar o papel da ordem do método na estimativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Critério de Aceitação",
                                  "subSteps": [
                                    "Escolha uma tolerância absoluta ou relativa (tol), tipicamente 10^{-6} a 10^{-3}.",
                                    "Defina a escala de normalização (scal), como max(|y|, |y'|)*h ou valores do problema.",
                                    "Formule o critério: |erro_local| ≤ tol * scal.",
                                    "Considere critérios mais avançados, como controle assintótico de erro.",
                                    "Teste a fórmula com valores hipotéticos para validar compreensão."
                                  ],
                                  "verification": "Escreva a fórmula do critério de aceitação para um problema dado e justifique os parâmetros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre controle de passo",
                                    "Exemplos de problemas de EDOs"
                                  ],
                                  "tips": "Comece com tolerância relativa para problemas escalados naturalmente.",
                                  "learningObjective": "Formular critérios de aceitação precisos e adaptados ao problema.",
                                  "commonMistakes": [
                                    "Usar tolerância absoluta sem escalonamento",
                                    "Esquecer de multiplicar por h no scal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar o Teste de Aceitação",
                                  "subSteps": [
                                    "Calcule o erro local estimado para o passo atual usando as aproximações disponíveis.",
                                    "Aplique a fórmula do critério: compare |erro_local| com tol * scal.",
                                    "Registre o valor numérico do teste (aceito/rejeitado).",
                                    "Repita para um passo h/2 se necessário para estimativa melhor.",
                                    "Documente todos os valores intermediários em uma tabela."
                                  ],
                                  "verification": "Para um exemplo dado, execute o teste e mostre os cálculos passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica ou software como Python/Octave",
                                    "Problema de exemplo impresso"
                                  ],
                                  "tips": "Automatize cálculos simples em uma planilha para evitar erros aritméticos.",
                                  "learningObjective": "Executar computacionalmente o teste de aceitação com precisão.",
                                  "commonMistakes": [
                                    "Erro de sinal no erro local",
                                    "Comparar com tol sem scal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir e Avançar o Passo",
                                  "subSteps": [
                                    "Se aceito: avance para x_{n+1}, y_{n+1} e sugira novo h (ex: h_new = h * (tol/erro)^{1/(p+1)}).",
                                    "Se rejeitado: rejeite o passo, reduza h (ex: h_new = 0.5 h) e repita.",
                                    "Implemente lógica de loop para controle contínuo.",
                                    "Monitore número de rejeições para ajustar tol dinamicamente.",
                                    "Registre estatísticas: aceitações, rejeições, h médio."
                                  ],
                                  "verification": "Simule 3 passos de um método com aceitação/rejeição e verifique convergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo de passo adaptativo",
                                    "Ambiente de programação básico"
                                  ],
                                  "tips": "Limite rejeições consecutivas para evitar loops infinitos.",
                                  "learningObjective": "Implementar decisão de avanço baseada no teste, garantindo eficiência.",
                                  "commonMistakes": [
                                    "Não atualizar h adequadamente após aceitação",
                                    "Ignorar fator de segurança (0.9) na atualização de h"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolvendo y' = -2y, y(0)=1 no intervalo [0,1] com RK4 embutido. No passo h=0.2 de x=0, yapprox_p=0.6703, yapprox_q=0.6704, erro_local=0.0001. scal=max(|y|,|y'|)*h ≈0.2*1*0.2=0.04. tol=1e-3. Teste: 0.0001 < 1e-3*0.04=4e-5? Não, rejeite e tente h=0.1.",
                              "finalVerifications": [
                                "Explique corretamente a diferença entre erro local e critério de aceitação.",
                                "Calcule teste para um exemplo novo com acurácia.",
                                "Implemente pseudocódigo completo de teste e decisão.",
                                "Identifique e corrija um erro comum em um cenário dado.",
                                "Ajuste tol e scal para otimizar eficiência em simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do critério (100% match com definições padrão).",
                                "Correção nos cálculos numéricos (erro < 1e-6).",
                                "Lógica de decisão sem falhas em fluxogramas.",
                                "Eficiência na sugestão de atualização de h (fator correto).",
                                "Capacidade de debugar rejeições excessivas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em loops while/do-while.",
                                "Estatística: Análise de erro e tolerâncias probabilísticas.",
                                "Física: Simulações de trajetórias com passos adaptativos.",
                                "Engenharia de Software: Controle de qualidade em algoritmos numéricos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou modelagem financeira, onde passos adaptativos garantem precisão sem custo computacional excessivo, evitando erros em previsões críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Ajuste conservador do fator de passo",
                            "description": "Calcular o novo tamanho de passo após aceitação usando fator f = 0.9 * (tol / erro)^{1/(p+1)}, onde p é a ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos prévios e componentes da fórmula",
                                  "subSteps": [
                                    "Identifique os parâmetros necessários: tolerância (tol), erro estimado (erro), ordem do método (p).",
                                    "Explique o propósito do ajuste conservador: aumentar o passo de forma segura após aceitação para eficiência sem perda de precisão.",
                                    "Analise o fator 0.9: ele garante conservadorismo, evitando overshooting.",
                                    "Discuta o expoente 1/(p+1): deriva da análise de erro local truncado.",
                                    "Registre valores de exemplo: tol = 1e-6, erro = 2e-6, p = 4, h_atual = 0.1."
                                  ],
                                  "verification": "Liste corretamente todos os componentes e seu papel em uma tabela ou parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Notas de aula sobre controle de passo"
                                  ],
                                  "tips": "Use um exemplo numérico real desde o início para fixar conceitos.",
                                  "learningObjective": "Compreender intuitivamente cada termo da fórmula f = 0.9 * (tol / erro)^{1/(p+1)}.",
                                  "commonMistakes": "Confundir tol com erro absoluto; ignorar que p é a ordem global/local do método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o expoente e a base da potência",
                                  "subSteps": [
                                    "Calcule a razão tol / erro (ex: 1e-6 / 2e-6 = 0.5).",
                                    "Determine o expoente: 1 / (p + 1) (ex: 1/5 = 0.2).",
                                    "Eleve a base à potência do expoente: (tol / erro)^{1/(p+1)} (ex: 0.5^0.2 ≈ 0.8706).",
                                    "Verifique o cálculo com logaritmos se necessário: log(base) * expoente.",
                                    "Anote o resultado intermediário com precisão de 4 casas decimais."
                                  ],
                                  "verification": "Confira o valor da potência com uma calculadora ou software; deve coincidir com 0.8706 no exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora com funções logarítmicas",
                                    "Planilha Excel ou Python (opcional)"
                                  ],
                                  "tips": "Use calculadora em modo científico; teste com expoentes conhecidos como 0.5^0.5 = √0.5 ≈ 0.707.",
                                  "learningObjective": "Dominar o cálculo preciso da componente não-linear da fórmula.",
                                  "commonMistakes": "Erro no sinal do expoente (lembre: tol < erro implica base <1, f<1); arredondamento prematuro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o fator conservador e atualizar o passo",
                                  "subSteps": [
                                    "Multiplique o resultado da potência por 0.9: f = 0.9 * 0.8706 ≈ 0.7835.",
                                    "Calcule novo h: h_novo = h_atual * f (ex: 0.1 * 0.7835 = 0.07835).",
                                    "Aplique limites típicos: h_novo = max(h_min, min(h_max, h_novo)) (ex: h_min=1e-6, h_max=1.0).",
                                    "Registre f e h_novo com justificativa para os limites.",
                                    "Compare h_novo com h_atual e explique a redução conservadora."
                                  ],
                                  "verification": "h_novo ≈ 0.07835 e dentro de limites; fórmula invertida corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Código Python simples para verificação"
                                  ],
                                  "tips": "Sempre aplique limites para evitar passos instáveis ou ineficientes.",
                                  "learningObjective": "Executar o cálculo completo do novo tamanho de passo com segurança.",
                                  "commonMistakes": "Esquecer o 0.9; não aplicar clamps (limites) ao h_novo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar em contexto numérico",
                                  "subSteps": [
                                    "Integre a fórmula em um pseudocódigo de solver adaptativo.",
                                    "Teste com exemplo: RK4 em y' = -y, [0,1], y(0)=1, tol=1e-6.",
                                    "Simule aceitação: erro=2e-6, calcule e aplique novo h.",
                                    "Compare solução com h fixo vs adaptativo.",
                                    "Analise impacto na precisão e eficiência (número de passos)."
                                  ],
                                  "verification": "Código roda sem erros; solução converge corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB",
                                    "Editor de código",
                                    "Função de teste y'=-y"
                                  ],
                                  "tips": "Use bibliotecas como numpy/scipy para baseline; foque em loop de controle de passo.",
                                  "learningObjective": "Aplicar o ajuste em um solver real para validar eficácia.",
                                  "commonMistakes": "Não resetar acumuladores de erro; loop infinito por h muito pequeno."
                                }
                              ],
                              "practicalExample": "Em um método Runge-Kutta de ordem 4 (p=4) para resolver y' = -2y, y(0)=1 em [0,1] com tol=1e-6. Após um passo aceito com erro local=2e-6 e h=0.1, calcule f=0.9*(1e-6/2e-6)^{1/5}≈0.7835, h_novo=0.07835. A solução adaptativa usa ~15 passos vs 10 fixos, com erro final <1e-6.",
                              "finalVerifications": [
                                "Fator f calculado com precisão relativa <1%.",
                                "h_novo dentro de [h_min, h_max].",
                                "Explicação correta do conservadorismo (f<1 mesmo se erro<tol).",
                                "Teste numérico mostra convergência.",
                                "Pseudocódigo inclui fórmula exatamente.",
                                "Comparação com h fixo demonstra eficiência."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da potência (erro <0.01).",
                                "Correta aplicação de limites ao h_novo.",
                                "Entendimento derivado da fórmula (explicação de 1/(p+1)).",
                                "Implementação funcional em código.",
                                "Análise qualitativa do impacto na eficiência.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/Scipy para solvers ODE.",
                                "Física: Simulações dinâmicas (ex: osciladores em mecânica).",
                                "Engenharia: Controle adaptativo em sistemas embarcados.",
                                "Estatística: Controle de erro em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ODE45 ou NASA trajectory solvers, onde ajustes conservadores de passo garantem precisão em órbitas espaciais sem desperdício computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Critérios de Rejeição",
                        "description": "Condições para rejeitar um passo e reduzir o tamanho de passo, garantindo estabilidade e precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Teste de rejeição do passo",
                            "description": "Rejeitar o passo se o erro local estimado exceder a tolerância, recalculando com h reduzido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Erro Local Estimado",
                                  "subSteps": [
                                    "Revise os métodos de Runge-Kutta embutidos (ex: RK45) que computam soluções com passos h e h/2.",
                                    "Calcule y_h (solução com passo h) e y_{h/2} (solução com passo h/2).",
                                    "Estime o erro local usando a fórmula: |y_h - y_{h/2}| / (2^p - 1), onde p é a ordem do método.",
                                    "Discuta o significado físico: o erro local reflete a precisão do passo atual.",
                                    "Pratique com uma equação diferencial simples: dy/dt = -y, y(0)=1."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o erro local é estimado e forneça um cálculo manual correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Sempre normalize o erro por componente se for um sistema de EDOs para maior precisão.",
                                  "learningObjective": "Identificar e calcular o erro local estimado em métodos adaptativos.",
                                  "commonMistakes": [
                                    "Confundir erro global com local",
                                    "Esquecer de dividir pela diferença de ordens (2^p - 1)",
                                    "Usar passos de tamanho fixo sem adaptação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Critérios de Tolerância e Rejeição",
                                  "subSteps": [
                                    "Defina a tolerância absoluta (atol) e relativa (rtol): erro_aceitável = atol + rtol * |y|.",
                                    "Estabeleça a condição de rejeição: se erro_local > erro_aceitável, rejeite o passo.",
                                    "Escolha fatores de segurança: tipicamente 0.9 para aceitação e 0.5 para rejeição.",
                                    "Registre exemplos onde tolerâncias diferentes afetam o número de rejeições.",
                                    "Compare com critérios de aceitação para diferenciar os fluxos."
                                  ],
                                  "verification": "Crie uma tabela comparando erro_local vs. tolerância para 3 cenários e identifique corretamente os casos de rejeição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Documentação de solvers como ode45 (MATLAB) ou scipy.integrate"
                                  ],
                                  "tips": "Use tolerâncias adaptativas baseadas na escala da solução para evitar rejeições desnecessárias.",
                                  "learningObjective": "Estabelecer e aplicar condições precisas para rejeição de passos.",
                                  "commonMistakes": [
                                    "Ignorar tolerância relativa em soluções grandes",
                                    "Usar atol=0 levando a rejeições excessivas",
                                    "Confundir rejeição com aceitação condicional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Teste de Rejeição",
                                  "subSteps": [
                                    "No algoritmo: após estimar erro_local, aplique if (erro_local > tolerância): rejeitar.",
                                    "Mantenha y_n fixo (não avance) e marque o passo como rejeitado.",
                                    "Conte o número de rejeições consecutivas para evitar loops infinitos (limite: 10).",
                                    "Codifique um pseudocódigo ou função simples em Python/MATLAB.",
                                    "Teste com uma EDO rígida: dy/dt = -100y para forçar rejeições."
                                  ],
                                  "verification": "Execute o teste em código e demonstre pelo menos uma rejeição ocorrendo com output correto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código (Python com NumPy/SciPy)",
                                    "Jupyter Notebook",
                                    "Exemplos de EDOs de teste"
                                  ],
                                  "tips": "Log as rejeições com print statements para depuração visual.",
                                  "learningObjective": "Codificar e executar o teste de rejeição de forma funcional.",
                                  "commonMistakes": [
                                    "Avançar y_n mesmo na rejeição",
                                    "Não resetar contadores de rejeição",
                                    "Erro de arredondamento em comparações de float"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recalcular com Passo Reduzido (h Reduzido)",
                                  "subSteps": [
                                    "Calcule novo h_new = h_old * (tolerância / erro_local)^{1/p} * fator_segurança (ex: 0.5).",
                                    "Garanta h_new >= h_min para evitar passos muito pequenos.",
                                    "Reinicie o cálculo do passo rejeitado com h_new.",
                                    "Monitore eficiência: rejeições excessivas indicam h inicial grande demais.",
                                    "Otimize: após 3 rejeições consecutivas, reduza h drasticamente."
                                  ],
                                  "verification": "Simule uma integração completa mostrando redução de h e convergência após rejeição.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python expandido",
                                    "Gráficos de h vs. t para visualizar adaptações"
                                  ],
                                  "tips": "Use um fator de redução conservador (0.2-0.5) para estabilidade rápida.",
                                  "learningObjective": "Ajustar dinamicamente o tamanho do passo após rejeição.",
                                  "commonMistakes": [
                                    "Não limitar h_min causando singularidades",
                                    "Exponenciação errada no cálculo de h_new",
                                    "Ignorar fator de segurança levando a oscilações"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre dy/dt = y * (1 - y), y(0)=0.5 (equação logística) de t=0 a 10 com h inicial=0.5, rtol=1e-6. O solver detecta erro_local > tolerância no início (região íngreme), rejeita, reduz h para ~0.1, recalcula e prossegue com passos adaptativos, produzindo uma solução precisa sem overshooting.",
                              "finalVerifications": [
                                "Calcula corretamente erro_local para uma EDO dada.",
                                "Identifica e rejeita passos com erro > tolerância em simulação.",
                                "Reduz h adequadamente e recalcula sem erros.",
                                "Explica o impacto de rejeições na eficiência global.",
                                "Implementa código funcional sem loops infinitos.",
                                "Compara solução adaptativa vs. fixa-h em gráfico."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de erro_local (erro < 5%).",
                                "Correta implementação da condição if de rejeição.",
                                "Fator de redução de h dentro de 10% do ótimo.",
                                "Número de rejeições razoável (<20% dos passos).",
                                "Código limpo, comentado e reproduzível.",
                                "Análise qualitativa da adaptação fornecida."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para solvers ODE.",
                                "Física: Simulações de dinâmica (ex: movimento orbital com adaptação).",
                                "Estatística: Análise de erro e controle de qualidade numérica.",
                                "Engenharia: Otimização em CFD e controle de sistemas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, onde EDOs rígidas causam instabilidades; o teste de rejeição garante precisão em regiões críticas (ex: NASA usa em trajetórias espaciais para evitar erros catastróficos por passos inadequados)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Redução do tamanho de passo",
                            "description": "Aplicar redução agressiva do passo, como h_new = 0.5 * h ou h_new = 0.7 * (tol / erro)^{1/(p+1)}, limitando rejeições consecutivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os motivos e critérios para redução do tamanho de passo",
                                  "subSteps": [
                                    "Revise o conceito de erro local em métodos numéricos adaptativos, como Runge-Kutta.",
                                    "Identifique quando um passo é rejeitado: quando o erro estimado excede a tolerância (tol).",
                                    "Estude exemplos de rejeição em integração numérica ou resolução de EDOs.",
                                    "Compare passos aceitos vs. rejeitados em termos de precisão e eficiência.",
                                    "Anote os impactos de passos grandes: perda de precisão e instabilidade."
                                  ],
                                  "verification": "Resuma em 3 frases os motivos para redução e liste 2 exemplos de rejeição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica, notas de aula, calculadora.",
                                  "tips": "Use diagramas de fluxo para visualizar o processo de aceitação/rejeição.",
                                  "learningObjective": "Explicar verbalmente por que e quando reduzir o tamanho de passo.",
                                  "commonMistakes": "Confundir erro local com erro global; ignorar o papel da tolerância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar as fórmulas de redução agressiva do passo",
                                  "subSteps": [
                                    "Memorize e derive h_new = 0.5 * h (redução fixa e agressiva).",
                                    "Aprenda a fórmula adaptativa: h_new = 0.7 * (tol / erro)^{1/(p+1)}, onde p é a ordem do método.",
                                    "Calcule exemplos numéricos: dado h=0.1, tol=1e-6, erro=2e-5, p=4.",
                                    "Entenda o fator 0.7 como segurança para evitar oscilações.",
                                    "Compare as duas abordagens em uma tabela de prós e contras."
                                  ],
                                  "verification": "Calcule corretamente h_new para 3 cenários dados e explique escolhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Python para cálculos.",
                                  "tips": "Sempre use expoente 1/(p+1) corretamente; teste com p=1 e p=5.",
                                  "learningObjective": "Aplicar fórmulas para calcular h_new dado erro e tol.",
                                  "commonMistakes": "Usar raiz errada no expoente; fator de segurança >1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar redução de passo em um algoritmo simples",
                                  "subSteps": [
                                    "Escreva pseudocódigo para um solver adaptativo incluindo redução.",
                                    "Implemente em Python ou MATLAB: loop com teste de erro e atualização de h.",
                                    "Inclua contador de rejeições consecutivas (limite: 5-10).",
                                    "Teste com EDO y' = -y, y(0)=1, intervalo [0,1].",
                                    "Registre histórico de h e erros para análise."
                                  ],
                                  "verification": "Execute código e produza gráfico de h vs. passos, sem crashes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/Jupyter), biblioteca SciPy opcional para comparação.",
                                  "tips": "Inicialize contador de rejeições; reset após aceitação.",
                                  "learningObjective": "Codificar lógica de redução com limite de rejeições.",
                                  "commonMistakes": "Loop infinito por h->0; não resetar contador após aceitação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e otimizar controle de rejeições consecutivas",
                                  "subSteps": [
                                    "Defina limite de rejeições (ex: 5) e ação: abortar ou reduzir drasticamente h.",
                                    "Simule cenários com muitas rejeições e ajuste parâmetros.",
                                    "Otimize fatores (0.5 vs. 0.7) para eficiência vs. precisão.",
                                    "Analise logs: número total de passos, rejeições %.",
                                    "Documente melhores práticas para diferentes problemas."
                                  ],
                                  "verification": "Gere relatório com métricas: <10% rejeições em teste padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código do passo anterior, gráficos (Matplotlib).",
                                  "tips": "Monitore h_min para evitar singularidades.",
                                  "learningObjective": "Gerenciar rejeições para estabilidade numérica.",
                                  "commonMistakes": "Limite muito baixo causa abortos prematuros; ignorar h_min."
                                }
                              ],
                              "practicalExample": "Em um solver Runge-Kutta de ordem 4 para y' = y*(1-y), y(0)=0.5: passo inicial h=0.2 rejeitado (erro=1e-4 > tol=1e-6), h_new=0.5*0.2=0.1 aceito; após 3 rejeições, aplicar h_new=0.7*(1e-6/5e-5)^{1/5}=0.07*h, reduzindo para convergência estável.",
                              "finalVerifications": [
                                "Calcula h_new corretamente para 5 cenários variados.",
                                "Implementa código que roda sem loops infinitos ou crashes.",
                                "Explica impacto de rejeições em eficiência computacional.",
                                "Identifica e corrige erros em simulações dadas.",
                                "Compara soluções com métodos fixos de passo.",
                                "Documenta logs com <5% rejeições em teste padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas: 100% correto em cálculos.",
                                "Implementação funcional: código executa e converge.",
                                "Eficiência: número de passos otimizado vs. fixo.",
                                "Gerenciamento de rejeições: limite respeitado sem falhas.",
                                "Análise crítica: identifica trade-offs precisão/velocidade.",
                                "Documentação clara: comentários e relatórios."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos de controle de fluxo e otimização.",
                                "Física: Simulações dinâmicas (ex: trajetórias em mecânica).",
                                "Engenharia: Modelagem de sistemas diferenciais em controle.",
                                "Estatística: Análise de erro e tolerâncias probabilísticas."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de previsão meteorológica), finanças (simulação de Monte Carlo para opções), ou engenharia aeroespacial (trajectories de foguetes), onde passos adaptativos evitam desperdício computacional e garantem precisão em regiões instáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Prevenção de loops de rejeição",
                            "description": "Implementar limites no número de rejeições consecutivas e h mínima para evitar loops infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema de loops de rejeição em controle de passo adaptativo",
                                  "subSteps": [
                                    "Estudar o algoritmo de controle de passo em métodos numéricos como Runge-Kutta adaptativo.",
                                    "Identificar pontos de aceitação e rejeição baseados no erro local estimado.",
                                    "Simular manualmente um cenário onde h diminui repetidamente sem convergência, levando a loop infinito.",
                                    "Analisar o impacto computacional de loops infinitos (ex.: overflow de h).",
                                    "Documentar condições que causam rejeições consecutivas persistentes."
                                  ],
                                  "verification": "Explicar em um diagrama de fluxo ou parágrafo como um loop de rejeição ocorre e por que precisa de prevenção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de métodos numéricos (ex.: livro de Burden & Faires)",
                                    "Código base de solver RK em Python/MATLAB"
                                  ],
                                  "tips": "Use papel e lápis para traçar o fluxo de h em rejeições sucessivas.",
                                  "learningObjective": "Identificar mecanismos que geram loops infinitos em step control.",
                                  "commonMistakes": [
                                    "Ignorar o papel do erro local na decisão de rejeição.",
                                    "Confundir redução de h com parada do algoritmo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar limite no número de rejeições consecutivas",
                                  "subSteps": [
                                    "Adicionar uma variável contador de rejeições consecutivas (ex.: rej_count = 0).",
                                    "Incrementar o contador em cada rejeição e resetá-lo em aceitações.",
                                    "Definir um limite máximo (ex.: max_rej = 5) e pausar/atualizar estratégia se excedido.",
                                    "Integrar lógica: se rej_count > max_rej, aplicar correção (ex.: reduzir tolerância ou parar).",
                                    "Testar com print/debug para observar o contador em ação."
                                  ],
                                  "verification": "Executar simulação com caso propenso a loops e confirmar que o contador atinge o limite e age corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Função teste de EDO rígida (ex.: y' = -100y)"
                                  ],
                                  "tips": "Comece com max_rej baixo (3) para testes rápidos.",
                                  "learningObjective": "Desenvolver mecanismo de contagem para quebrar sequências de rejeições.",
                                  "commonMistakes": [
                                    "Esquecer de resetar o contador após aceitação.",
                                    "Usar contador global em vez de por step."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar limite de tamanho de passo mínimo (h_min)",
                                  "subSteps": [
                                    "Definir uma h_min absoluta ou relativa (ex.: h_min = 1e-12 * T, onde T é intervalo total).",
                                    "Verificar antes de cada tentativa de step: se h_proposto < h_min, abortar ou ajustar.",
                                    "Em caso de violação, registrar falha e retornar solução parcial ou mensagem de erro.",
                                    "Ajustar h_min dinamicamente baseado em precisão desejada.",
                                    "Implementar log para rastrear quando h_min é atingida."
                                  ],
                                  "verification": "Forçar redução de h até h_min e confirmar que o algoritmo para sem loop.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "EDO com singularidades (ex.: perto de t=0 em problemas stiff)"
                                  ],
                                  "tips": "Escolha h_min conservadora para evitar overflow numérico.",
                                  "learningObjective": "Estabelecer barreira inferior para h e integrá-la ao controle.",
                                  "commonMistakes": [
                                    "Definir h_min muito pequena, permitindo loops longos.",
                                    "Não tratar o caso h == h_min corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar mecanismos, testar e validar a prevenção completa",
                                  "subSteps": [
                                    "Combinar contador de rejeições e h_min no loop principal do solver.",
                                    "Criar casos de teste: um sem prevenção (loop), um com (termina corretamente).",
                                    "Medir desempenho: tempo de execução, número de steps, precisão final.",
                                    "Debugar interações entre os dois limites.",
                                    "Documentar o código com comentários sobre prevenção de loops."
                                  ],
                                  "verification": "Rodar benchmarks e confirmar ausência de loops infinitos em todos testes.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código integrado",
                                    "Suite de testes unitários (pytest ou similar)",
                                    "Gráficos de h vs. t"
                                  ],
                                  "tips": "Use profiling para medir eficiência pós-implementação.",
                                  "learningObjective": "Garantir robustez do solver contra loops via mecanismos duplos.",
                                  "commonMistakes": [
                                    "Priorizar só um mecanismo, ignorando falhas do outro.",
                                    "Não testar com EDOs stiff reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver RK4(5) para a EDO y' = y * (1 - y), com y(0)=2 e tolerância baixa, sem prevenção h reduz para 1e-20 causando loop. Com max_rej=4 e h_min=1e-10, após 4 rejeições o algoritmo para e retorna 'Falha: loop detectado, ajuste tolerância'.",
                              "finalVerifications": [
                                "O contador de rejeições reseta corretamente após aceitação.",
                                "h nunca vai abaixo de h_min.",
                                "Algoritmo termina em < max_steps totais mesmo em casos difíceis.",
                                "Logs mostram detecção explícita de loop potenciais.",
                                "Solução parcial é salva se falha ocorrer.",
                                "Testes unitários passam para 5+ EDOs variadas."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta e eficiente dos dois limites (contador e h_min).",
                                "Código comentado e modular, fácil de debugar.",
                                "Robustez comprovada em testes com EDOs stiff e não-lineares.",
                                "Eficiência mantida: overhead <10% em casos normais.",
                                "Tratamento de erros claro e informativo.",
                                "Integração seamless no algoritmo de step control."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Controle de loops e exceções em algoritmos iterativos.",
                                "Ciência da Computação: Detecção de divergência em solvers numéricos.",
                                "Física: Modelagem de sistemas stiff em simulações dinâmicas.",
                                "Engenharia de Software: Robustez e tratamento de falhas em código numérico."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular (ex.: folding de proteínas), finanças (modelos Black-Scholes com volatilidade alta) ou controle de aeronaves, onde EDOs stiff podem causar crashes de software sem prevenção de loops, garantindo simulações confiáveis e termináveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Estratégias de Ajuste do Tamanho do Passo",
                    "description": "Regras heurísticas para aumentar ou diminuir o passo h visando equilíbrio entre precisão e custo computacional.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Estimativa de Erro Local para Controle de Passo",
                        "description": "Conceitos fundamentais para estimar o erro local em métodos de Runge-Kutta adaptativos, base para decidir ajustes no tamanho do passo h.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Calcular erro local usando pares de soluções de ordens diferentes",
                            "description": "Implementar a estimativa de erro local em métodos embedded Runge-Kutta (ex: Dormand-Prince), comparando soluções de ordem p e p+1 para quantificar truncamento local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de métodos embedded Runge-Kutta e pares de soluções",
                                  "subSteps": [
                                    "Estude a estrutura de um método embedded RK, como Dormand-Prince (DOPRI5), que gera soluções de ordens p e p+1 simultaneamente.",
                                    "Identifique os coeficientes Butcher para o método específico (a_ij, b_i^{(p)}, b_i^{(p+1)}).",
                                    "Revise a definição de truncamento local de ordem p, onde o erro local é O(h^{p+1}).",
                                    "Explique como a diferença entre y_p e y_{p+1} estima o erro principal.",
                                    "Anote a fórmula de estimativa de erro: e ≈ |y_{p+1} - y_p| / |1 - (p+1)/p| ou versão escalada."
                                  ],
                                  "verification": "Resuma em 3-5 frases os componentes chave e a fórmula de erro; compare com referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), tabela de coeficientes DOPRI5, papel e caneta.",
                                  "tips": "Comece com DOPRI5 pois é padrão; memorize apenas os estágios principais (s=7).",
                                  "learningObjective": "Dominar a teoria por trás de pares embedded para estimativa de erro local.",
                                  "commonMistakes": "Confundir ordem global com local; ignorar escalonamento da estimativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método embedded RK para um problema modelo",
                                  "subSteps": [
                                    "Escolha um EDO simples: y' = f(t,y), ex: y' = -2y, y(0)=1 (solução exata y=e^{-2t}).",
                                    "Programe os estágios k_i = f(t_n + c_i h, y_n + h Σ a_ij k_j) para i=1 a s.",
                                    "Calcule y_{p+1} = y_n + h Σ b_i^{(p+1)} k_i e y_p = y_n + h Σ b_i^{(p)} k_i.",
                                    "Implemente em código (Python/MATLAB) com função para Butcher tableau.",
                                    "Execute um passo com h inicial fixo e armazene y_p e y_{p+1}."
                                  ],
                                  "verification": "Execute o código e confirme que y_p e y_{p+1} convergem para solução exata ao reduzir h.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, editor de código, problema de teste.",
                                  "tips": "Use vetores para coeficientes; teste com h pequeno para validar.",
                                  "learningObjective": "Implementar computacionalmente o par de soluções embedded.",
                                  "commonMistakes": "Índices errados nos Butcher (off-by-one); não normalizar para autônomo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e interpretar a estimativa de erro local",
                                  "subSteps": [
                                    "Compute o erro local candidato: e = |y_{p+1} - y_p|. Para DOPRI5 (p=4), use e = |y_5 - y_4| / 15 (fator de escalonamento).",
                                    "Aplique norma adequada (ex: norma máxima ou L2 para vetores).",
                                    "Compare e com erro verdadeiro |y_exata - y_p| para validar.",
                                    "Analise dependência em h: plote log(e) vs log(h), espere inclinação p+1.",
                                    "Documente o valor de e e sua interpretação como truncamento local."
                                  ],
                                  "verification": "O erro estimado deve estar dentro de fator 2-10 do erro real; gráfico confirma ordem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do passo anterior, solução analítica, ferramenta de plotagem (Matplotlib).",
                                  "tips": "Use escalonamento preciso do método; para sistemas, norma por componente.",
                                  "learningObjective": "Calcular quantitativamente o erro local e validá-lo.",
                                  "commonMistakes": "Esquecer escalonamento (leva a estimativa enviesada); usar norma errada para vetores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar a estimativa em um laço de controle de passo básico",
                                  "subSteps": [
                                    "Defina tolerância tol (ex: 1e-6); se e < tol, aceite y_p e sugira h_new = h * (tol/e)^{1/(p+1)}.",
                                    "Se e > tol, rejeite e reduza h; inclua fatores de segurança (0.9) e limites.",
                                    "Implemente laço adaptativo para intervalo [0,1] e compare passos vs h fixo.",
                                    "Registre histórico de h, e e passos aceitos/rejeitados.",
                                    "Otimize: teste eficiência (funções avaliadas vs precisão)."
                                  ],
                                  "verification": "Solução final converge à exata; número de passos razoável (menos que h fixo fino).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código expandido, timer para eficiência.",
                                  "tips": "Comece com fator segurança 0.9; limite h_min/max para estabilidade.",
                                  "learningObjective": "Aplicar erro local para ajuste adaptativo de passo.",
                                  "commonMistakes": "Fator de h_new sem 1/(p+1); loop infinito por h muito pequeno."
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1 em [0,1], usando DOPRI5 com h=0.2 inicial e tol=1e-5: no primeiro passo, y4≈0.6703, y5≈0.6700, e≈0.0002 (aceito), h_new≈0.25; resulta em ~8 passos vs 50 com h fixo 0.02, erro final <1e-5.",
                              "finalVerifications": [
                                "Código produz y_p e y_{p+1} corretos para EDO de teste.",
                                "Estimativa e ≈ erro real dentro fator 5.",
                                "Gráfico log-log confirma ordem de convergência p+1.",
                                "Laço adaptativo usa <20% mais funções que necessário para tol.",
                                "Histórico mostra rejeições <20% e h ajustando adequadamente.",
                                "Solução em t=1 dentro tol da exata."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação Butcher (erro <1e-10 em teste conhecido).",
                                "Correção da fórmula de erro escalado.",
                                "Validação empírica com solução exata.",
                                "Eficiência do adaptativo (passos < h fixo equivalente).",
                                "Código limpo, comentado e reutilizável.",
                                "Interpretação qualitativa/quantitativa correta."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de trajetórias orbitais (N-body problems).",
                                "Engenharia: Controle de sistemas dinâmicos em aerodinâmica.",
                                "Computação: Otimização numérica e análise de algoritmos.",
                                "Estatística: Modelagem estocástica com erros de integração."
                              ],
                              "realWorldApplication": "Em modelagem climática (ECMWF usa RK embedded para previsão tempo), simulações CFD em aviação (NASA), ou farmacocinética (otimizar doses via EDOs precisas), onde erro local adaptativo garante precisão sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Definir tolerâncias absoluta e relativa para erro",
                            "description": "Estabelecer critérios de tolerância Tol com normas como ||e|| < Tol * (||y|| + Tol_atol), equilibrando precisão global e custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Erro Absoluto e Relativo",
                                  "subSteps": [
                                    "Defina erro absoluto como a diferença numérica direta |e| = |y_exact - y_approx|.",
                                    "Defina erro relativo como |e| / |y_exact| ou aproximado por |e| / (|y_approx| + ε) para evitar divisão por zero.",
                                    "Discuta limitações: absoluto ignora escala, relativo falha em valores próximos de zero.",
                                    "Compare com exemplos numéricos simples, como y=1e-10.",
                                    "Identifique quando usar cada um em contextos numéricos."
                                  ],
                                  "verification": "Resuma diferenças em um parágrafo e resolva 3 exemplos numéricos corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Use y pequeno para ilustrar falhas do relativo.",
                                  "learningObjective": "Distinguir e aplicar definições de erros absoluto e relativo.",
                                  "commonMistakes": "Confundir absoluto com relativo; ignorar divisão por zero no relativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Normas Vetoriais para Erros em Dimensões Superiores",
                                  "subSteps": [
                                    "Revise normas comuns: L1 (soma absolutos), L2 (euclidiana √(∑e_i²)), L∞ (máximo absoluto).",
                                    "Foquem na norma L2: ||e||₂ = √(∑(e_i)²), ||y||₂ similar.",
                                    "Calcule normas para vetores exemplo: e = [0.1, 0.2], y = [1, 2].",
                                    "Discuta equivalência de normas e impacto na escolha.",
                                    "Implemente cálculo de norma L2 em pseudocódigo."
                                  ],
                                  "verification": "Compute ||e|| e ||y|| para 2 vetores dados e explique escolha da norma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como Python (NumPy) ou MATLAB, exemplos impressos.",
                                  "tips": "Sempre normalize vetores unitários para testar.",
                                  "learningObjective": "Calcular e selecionar normas adequadas para erros vetoriais.",
                                  "commonMistakes": "Esquecer raiz quadrada na L2; usar norma errada para contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Critério de Tolerância Mista Absoluta e Relativa",
                                  "subSteps": [
                                    "Estude fórmula: ||e|| < Tol * (||y|| + Tol_atol), onde Tol é relativo, Tol_atol absoluto.",
                                    "Derive intuitivamente: para y grande, domina relativo; para y pequeno, absoluto.",
                                    "Escolha valores típicos: Tol=1e-6, Tol_atol=1e-12.",
                                    "Teste fórmula com exemplos: y=[1e-10,1], e=[1e-12,1e-6].",
                                    "Ajuste parâmetros para cenários variados."
                                  ],
                                  "verification": "Aplique critério a 3 casos e justifique aceitação/rejeição.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Python script para testes, referências teóricas.",
                                  "tips": "Comece com Tol_atol = Tol * escala mínima esperada de y.",
                                  "learningObjective": "Construir e validar critérios de tolerância mistos.",
                                  "commonMistakes": "Omitir Tol_atol levando a tolerâncias frouxas perto de zero; inverter papéis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Equilibrar Precisão e Custo Computacional",
                                  "subSteps": [
                                    "Analise impacto: Tol pequeno aumenta passos/refinamentos, eleva custo O(n).",
                                    "Simule trade-off: reduza Tol de 1e-3 a 1e-8, meça iterações/tempo.",
                                    "Otimize: use Tol adaptativo baseado em fase (inicial frouxo, final estrito).",
                                    "Avalie em contexto de controle de passo (ex: Runge-Kutta).",
                                    "Documente guidelines para escolha: domínio físico dita Tol."
                                  ],
                                  "verification": "Crie tabela de Tol vs. custo para exemplo e recomende valor ótimo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB para simulação de método numérico, gráfico de desempenho.",
                                  "tips": "Monitore condição numérica para evitar ill-conditioning.",
                                  "learningObjective": "Otimizar tolerâncias considerando eficiência computacional.",
                                  "commonMistakes": "Tol muito rigoroso causando explosão computacional; ignorar hardware limits."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Estimativa de Erro Local para Controle de Passo",
                                  "subSteps": [
                                    "Integre em algoritmo de passo: estime e_local com embedded methods (ex: Dormand-Prince).",
                                    "Implemente loop: se ||e|| > tol, h = h * 0.9 * (tol/||e||)^{1/4}.",
                                    "Teste em ODE exemplo: y' = -y, y(0)=1.",
                                    "Valide convergência e estabilidade.",
                                    "Registre logs de h e e ao longo da integração."
                                  ],
                                  "verification": "Execute simulação, produza gráfico de h(t) e confirme ||e|| < tol.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Biblioteca SciPy (solve_ivp) ou código custom, plotter (Matplotlib).",
                                  "tips": "Use safety factor 0.9 no ajuste de h para conservadorismo.",
                                  "learningObjective": "Implementar tolerâncias em controladores de passo reais.",
                                  "commonMistakes": "Exponte errada no ajuste de h; não rejeitar passos grandes iniciais."
                                }
                              ],
                              "practicalExample": "Em um resolvedor de ODE y' = λy com λ=-1, y(0)=1, use Tol=1e-6, Tol_atol=1e-12. Estime e_local com método RK4(5), ajuste h inicial=0.1. Verifique: para y~1e-5, tol efetiva ~1e-11, evitando perda de precisão.",
                              "finalVerifications": [
                                "Explicar fórmula ||e|| < Tol*(||y|| + Tol_atol) com derivação intuitiva.",
                                "Calcular tol efetiva para y=[1e-10, 100] com Tol=1e-6, Tol_atol=1e-12.",
                                "Simular trade-off Tol vs. número de passos em ODE simples.",
                                "Implementar critério em pseudocódigo para controle de passo.",
                                "Identificar quando tol relativo falha e justificar uso misto.",
                                "Produzir gráfico de erro vs. h para validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de erros/normas (90% acerto em exercícios).",
                                "Correta formulação e aplicação do critério misto (sem inversões).",
                                "Demonstração de trade-off precisão-custo com simulações quantitativas.",
                                "Implementação funcional em código com logs de h e e.",
                                "Justificativas claras para escolhas de Tol e Tol_atol.",
                                "Identificação correta de erros comuns em 4+ cenários."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em solvers numéricos (SciPy, ODEPACK).",
                                "Física: Simulações dinâmicas (ex: movimento orbital com tol adaptativa).",
                                "Engenharia: Controle de sistemas (PID com integração numérica estável).",
                                "Estatística: Análise de incerteza em MC simulations."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos ODE/DAE), tol mista garante precisão em variáveis pequenas (ex: concentrações traço) sem custo excessivo, permitindo runs em supercomputadores para previsões confiáveis."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Avaliar norma do erro estimado",
                            "description": "Computar a norma escalar do vetor de erro local, como max(|e_i| / ( |y_i| + atol )), para decisões unificadas de aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do vetor de erro local",
                                  "subSteps": [
                                    "Identifique o vetor de erro local e_i, que representa a diferença entre a solução numérica y_i e a solução exata ou estimada.",
                                    "Defina os parâmetros atol (tolerância absoluta) e o vetor solução y_i.",
                                    "Revise a fórmula da norma escalar: max(|e_i| / (|y_i| + atol)) para cada componente i.",
                                    "Explique o propósito: unificar erros relativos e absolutos para decisões de aceitação de passo.",
                                    "Anote exemplos de y_i e e_i de um método numérico como Runge-Kutta."
                                  ],
                                  "verification": "Liste corretamente os componentes e a fórmula em um papel ou código, confirmando com um exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, calculadora, notas de análise numérica.",
                                  "tips": "Sempre normalize pelo |y_i| + atol para evitar divisão por zero ou erros em soluções pequenas.",
                                  "learningObjective": "Entender a estrutura do vetor de erro e a motivação da norma escalar relativa.",
                                  "commonMistakes": "Confundir erro local com global; ignorar atol em soluções próximas de zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os termos relativos componente por componente",
                                  "subSteps": [
                                    "Para cada i, compute |e_i| (valor absoluto do erro na componente i).",
                                    "Calcule o denominador |y_i| + atol para cada i.",
                                    "Divida |e_i| pelo denominador obtido, obtendo o erro relativo escalar por componente.",
                                    "Armazene esses valores em um vetor temporário de erros relativos.",
                                    "Verifique se todos os componentes foram processados corretamente."
                                  ],
                                  "verification": "Compare os valores relativos calculados manualmente com uma implementação em Python ou MATLAB.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou editor de código (Python/MATLAB), exemplo de dados numéricos.",
                                  "tips": "Use funções vetorizadas como abs() em NumPy para eficiência em implementações.",
                                  "learningObjective": "Dominar o cálculo elemento-wise da métrica de erro relativa.",
                                  "commonMistakes": "Esquecer o sinal absoluto em e_i ou y_i; usar atol incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a norma máxima do vetor de erro",
                                  "subSteps": [
                                    "Aplique a função máximo (max) ao vetor de erros relativos calculados.",
                                    "Obtenha o valor escalar da norma: o maior erro relativo entre todas as componentes.",
                                    "Registre a norma e o índice i onde o máximo ocorre (opcional, para depuração).",
                                    "Teste com variações nos dados para validar consistência.",
                                    "Compare com critérios de tolerância rtol para aceitação."
                                  ],
                                  "verification": "O resultado é um escalar único; teste com max([0.01, 0.02]) = 0.02.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código ou calculadora para função max, dados de teste.",
                                  "tips": "Em código, use np.max(erros_relativos) para simplicidade e precisão.",
                                  "learningObjective": "Aplicar a operação de norma máxima para reduzir o vetor a um escalar.",
                                  "commonMistakes": "Usar média em vez de máximo; confundir com norma L2 (euclidiana)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a norma para decisões de controle de passo",
                                  "subSteps": [
                                    "Compare a norma calculada com um tolerância desejada (ex: rtol).",
                                    "Decida aceitação: norma <= rtol → aceite passo; senão, rejeite e ajuste h.",
                                    "Integre em um loop de solver numérico simulando controle adaptativo.",
                                    "Documente o processo com um fluxograma simples.",
                                    "Simule um caso de rejeição e aceitação."
                                  ],
                                  "verification": "Simule um passo: se norma=0.001 < 0.01, aceite; valide decisão logicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para fluxograma, pseudocódigo ou script simples.",
                                  "tips": "Combine com rtol para tolerância relativa global: norma <= rtol.",
                                  "learningObjective": "Usar a norma em algoritmos de controle de erro adaptativo.",
                                  "commonMistakes": "Ignorar comparação com rtol; não ajustar h após rejeição."
                                }
                              ],
                              "practicalExample": "Considere y = [1.0, 2.0], e = [0.01, 0.03], atol=1e-6. Compute: para i=1, |0.01|/(|1.0|+1e-6) ≈ 0.01; i=2, |0.03|/(|2.0|+1e-6) ≈ 0.015. Norma = max(0.01, 0.015) = 0.015. Se rtol=0.02, aceite o passo.",
                              "finalVerifications": [
                                "A norma é um escalar não-negativo.",
                                "Todos os componentes foram normalizados corretamente com atol.",
                                "O máximo corresponde ao maior erro relativo.",
                                "Decisão de aceitação é consistente com rtol.",
                                "Cálculo vetorizado é eficiente e preciso.",
                                "Teste com y_i=0 confirma uso de atol."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica no cálculo de cada termo relativo (erro < 1e-10).",
                                "Correta aplicação da função max para norma escalar.",
                                "Integração adequada com tolerâncias atol e rtol.",
                                "Identificação de erros comuns e prevenção.",
                                "Implementação em código funcional e testada.",
                                "Explicação clara da interpretação para controle de passo."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em bibliotecas como SciPy odeint.",
                                "Física: Controle de precisão em simulações dinâmicas (ex: trajetórias).",
                                "Engenharia: Otimização adaptativa em solvers de EDOs industriais.",
                                "Estatística: Métricas de erro em modelagem preditiva."
                              ],
                              "realWorldApplication": "Em solvers numéricos como MATLAB ode45 ou Python SciPy, essa norma guia o ajuste adaptativo do tamanho do passo em simulações de sistemas dinâmicos, como previsão climática, circuitos elétricos ou trajetórias espaciais, garantindo precisão sem custo computacional excessivo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Regras Heurísticas para Diminuição do Passo",
                        "description": "Estratégias para reduzir h quando o erro excede a tolerância, garantindo convergência e estabilidade sem passos excessivamente pequenos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Aplicar fator de redução baseado no expoente da ordem do método",
                            "description": "Usar h_new = h * 0.9 * (Tol / err)^{1/p}, onde p é a ordem global, para ajuste conservador que visa err_new ≈ Tol.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da fórmula de redução do passo",
                                  "subSteps": [
                                    "Identifique h como o tamanho de passo atual no método numérico.",
                                    "Defina Tol como a tolerância de erro desejada para o controle.",
                                    "Explique err como o erro local estimado no passo atual.",
                                    "Determine p como a ordem global do método numérico utilizado.",
                                    "Analise o fator 0.9 como ajuste conservador para garantir err_new ≈ Tol."
                                  ],
                                  "verification": "Escreva uma definição clara de cada componente em suas próprias palavras e relacione-os à fórmula.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Fórmula anotada",
                                    "Notas de aula sobre métodos numéricos",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se de que p é a ordem global, não local, para métodos como Runge-Kutta.",
                                  "learningObjective": "Dominar o significado e o papel de cada variável na fórmula de ajuste.",
                                  "commonMistakes": [
                                    "Confundir ordem local com global",
                                    "Ignorar o fator conservador 0.9",
                                    "Confundir Tol com err absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar o erro local (err) no passo atual",
                                  "subSteps": [
                                    "Implemente o método numérico com tamanho de passo h atual.",
                                    "Calcule a solução aproximada y_n com h.",
                                    "Repita o cálculo com h/2 para obter y_{n+1/2}.",
                                    "Estime err ≈ |y_n - y_{n+1/2}| / (2^p - 1).",
                                    "Compare err com Tol para decidir redução."
                                  ],
                                  "verification": "Obtenha um valor numérico concreto para err e confirme se err > Tol.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de análise numérica (ex: Python/NumPy ou MATLAB)",
                                    "Papel para cálculos manuais",
                                    "Exemplo de EDO simples"
                                  ],
                                  "tips": "Use soluções duplas (h e h/2) para estimativa precisa sem solução exata.",
                                  "learningObjective": "Saber estimar erros locais em métodos de integração numérica.",
                                  "commonMistakes": [
                                    "Usar h/2 sem fórmula de Richardson",
                                    "Não considerar a ordem p na estimativa",
                                    "Arredondar err prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o novo tamanho de passo h_new",
                                  "subSteps": [
                                    "Calcule a razão r = Tol / err.",
                                    "Eleve r à potência 1/p: r^{1/p}.",
                                    "Multiplique pelo fator conservador: 0.9 * r^{1/p}.",
                                    "Aplique ao passo atual: h_new = h * (0.9 * r^{1/p}).",
                                    "Garanta que h_new > h_min (limite mínimo)."
                                  ],
                                  "verification": "Verifique se h_new < h e se o cálculo resulta em err_new ≈ Tol teoricamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para cálculos",
                                    "Exemplo numérico prévio"
                                  ],
                                  "tips": "Use logaritmos para potências fracionárias se necessário: (Tol/err)^{1/p} = exp((1/p) * ln(Tol/err)).",
                                  "learningObjective": "Executar o cálculo preciso da fórmula de redução.",
                                  "commonMistakes": [
                                    "Esquecer a potência 1/p",
                                    "Não multiplicar por 0.9",
                                    "Calcular com err < Tol (não reduz quando necessário)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar o novo passo em iteração",
                                  "subSteps": [
                                    "Integre o próximo passo usando h_new.",
                                    "Reestime err_new com h_new e h_new/2.",
                                    "Confirme se err_new ≤ Tol.",
                                    "Ajuste iterativamente se necessário (reduzir mais ou aumentar).",
                                    "Documente a sequência de h para análise."
                                  ],
                                  "verification": "Simule 2-3 iterações e mostre convergência para Tol.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de solver numérico",
                                    "Gráfico de erro vs. h",
                                    "EDO de teste"
                                  ],
                                  "tips": "Implemente em loop para automação no código.",
                                  "learningObjective": "Integrar o ajuste em um algoritmo de controle de passo completo.",
                                  "commonMistakes": [
                                    "Não reavaliar err após mudança",
                                    "Aplicar redução sem limite inferior",
                                    "Ignorar oscilações no h"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o método de Euler (p=1) para y' = -y, y(0)=1, Tol=10^{-4}, h=0.1, err estimado=5×10^{-4}. Então r = 10^{-4}/5×10^{-4}=0.2, r^{1/1}=0.2, h_new=0.1 × 0.9 × 0.2 = 0.018. Próximo passo com h_new mostra err_new ≈ 9×10^{-5} < Tol.",
                              "finalVerifications": [
                                "Fórmula h_new calculada corretamente com todos os componentes.",
                                "h_new resulta em redução quando err > Tol.",
                                "Estimativa de err usa extrapolação adequada (Richardson).",
                                "Fator 0.9 aplicado para conservadorismo.",
                                "Iteração demonstra convergência estável.",
                                "Documentação inclui valores numéricos exatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro < 1%).",
                                "Correta identificação de p para o método.",
                                "Explicação teórica do conservadorismo (err_new ≈ Tol).",
                                "Implementação prática em exemplo numérico.",
                                "Análise de iterações subsequentes.",
                                "Ausência de erros comuns como confusão de ordens."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/MATLAB para solvers adaptativos.",
                                "Física: Controle de precisão em simulações dinâmicas (ex: trajetórias).",
                                "Engenharia: Otimização de tempo computacional em modelagem.",
                                "Estatística: Análise de erros e tolerâncias em aproximações."
                              ],
                              "realWorldApplication": "Em softwares como MATLAB ode45 ou SciPy solve_ivp, essa heurística ajusta h automaticamente em simulações de trajetórias espaciais, modelagem climática ou circuitos elétricos, equilibrando precisão e eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Implementar rejeição de passo e reinício",
                            "description": "Rejeitar o passo atual se err > Tol, reduzir h e recomputar a partir do ponto anterior, limitando reduções sucessivas para evitar loops.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir critérios de rejeição do passo",
                                  "subSteps": [
                                    "Analise a estimativa de erro local (err) calculada pelo método adaptativo.",
                                    "Defina a tolerância (Tol) como parâmetro de entrada.",
                                    "Implemente a condição if err > Tol para sinalizar rejeição.",
                                    "Registre o valor de err e Tol para depuração.",
                                    "Teste com valores de err acima e abaixo de Tol."
                                  ],
                                  "verification": "Execute o código com casos de teste onde err > Tol e confirme que a rejeição é sinalizada corretamente via print ou log.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code ou Jupyter Notebook)",
                                    "Biblioteca NumPy para cálculos",
                                    "Pseudocódigo de método Runge-Kutta adaptativo"
                                  ],
                                  "tips": "Use tolerâncias relativas como atol + rtol * |y| para maior robustez.",
                                  "learningObjective": "Compreender e codificar a detecção precisa de erros excedentes em passos numéricos.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Usar tolerância absoluta sem considerar escala da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar redução do tamanho do passo (h)",
                                  "subSteps": [
                                    "Defina fator de redução, tipicamente h_new = h_old * 0.5 ou 0.8.",
                                    "Atualize h apenas após confirmação de rejeição.",
                                    "Salve o h anterior para possível restauração.",
                                    "Inclua limite mínimo para h (ex: 1e-12) para evitar passos nulos.",
                                    "Registre histórico de reduções para monitoramento."
                                  ],
                                  "verification": "Simule uma rejeição e verifique se h é reduzido corretamente (ex: de 0.1 para 0.05) via inspeção de variáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos do passo 1",
                                    "Função de teste com EDO conhecida (ex: y' = -y)"
                                  ],
                                  "tips": "Fatores entre 0.5 e 0.9 equilibram precisão e eficiência; teste diferentes valores.",
                                  "learningObjective": "Dominar o ajuste heurístico de h para convergência numérica estável.",
                                  "commonMistakes": [
                                    "Reduzir h sem verificar rejeição",
                                    "Não limitar h_min, causando loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar reinício a partir do ponto anterior",
                                  "subSteps": [
                                    "Armazene o estado anterior (y_prev, t_prev, h_prev) em variáveis auxiliares.",
                                    "Ao rejeitar, volte para t_prev e y_prev.",
                                    "Recomputa o passo com o novo h a partir desse ponto.",
                                    "Atualize o histórico de solução apenas após aceitação.",
                                    "Implemente uma estrutura de loop while para tentativas de reinício."
                                  ],
                                  "verification": "Rode simulação com rejeição e confirme que a solução reinicia corretamente do ponto salvo, sem duplicação de passos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca SciPy para comparação com solve_ivp",
                                    "Gráficos com Matplotlib para visualização da trajetória"
                                  ],
                                  "tips": "Use listas ou arrays para armazenar histórico, facilitando rollback.",
                                  "learningObjective": "Implementar mecanismos de rollback para correção de passos inválidos.",
                                  "commonMistakes": [
                                    "Perder o estado anterior por sobrescrita",
                                    "Avançar t mesmo em rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Controlar reduções sucessivas para evitar loops",
                                  "subSteps": [
                                    "Inicialize contador de rejeições consecutivas (max_rejects = 5).",
                                    "Incremente contador em cada rejeição.",
                                    "Se contador > max_rejects, pare a simulação ou use h fixo.",
                                    "Reset contador após aceitação de passo.",
                                    "Adicione log de warning quando próximo do limite."
                                  ],
                                  "verification": "Force múltiplas rejeições em teste e confirme parada ou reset do contador após aceitação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Casos de teste com EDOs rígidas que causam rejeições frequentes"
                                  ],
                                  "tips": "Max_rejects entre 3-10; ajuste baseado na rigidez da EDO.",
                                  "learningObjective": "Prevenir loops infinitos com heurísticas de segurança em solvers adaptativos.",
                                  "commonMistakes": [
                                    "Não resetar contador após sucesso",
                                    "Valor alto demais para max_rejects"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver Runge-Kutta 4(5) para y' = y * (1 - y), t de 0 a 5, y(0)=0.1, Tol=1e-6, h inicial=0.1. No t≈1.2, err=2e-5 > Tol: rejeite, h=0.05, reinicie de t=1.1, y_prev=0.45; após 3 reduções sucessivas, se ainda falhar, pare com mensagem 'Máximo de rejeições atingido'.",
                              "finalVerifications": [
                                "O código detecta corretamente err > Tol em pelo menos 80% dos casos de teste.",
                                "h é reduzido monotonicamente em rejeições, sem ultrapassar limites.",
                                "Reinício preserva exatidão da solução comparada a solvers padrão (erro < 1e-4).",
                                "Contador de rejeições previne loops (máx 5 sucessivas).",
                                "Logs mostram rejeições, reduções e reinícios claramente.",
                                "Simulação completa sem crash em EDOs moderadamente rígidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e tratamento de erros locais (90% acerto).",
                                "Eficiência: número total de passos < 2x o método sem adaptativo.",
                                "Robustez: lida com 5+ rejeições sem falha.",
                                "Clareza do código: comentários e estrutura modular.",
                                "Validação: convergência para solução exata com h->0.",
                                "Escalabilidade: funciona com dimensões y > 1."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de controle (loops, condicionais) e depuração.",
                                "Física: Simulações dinâmicas com EDOs (ex: movimento harmônico).",
                                "Engenharia de Software: Tratamento de exceções e limites de iterações.",
                                "Estatística: Análise de erro numérico e heurísticas empíricas."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA solvers), modelagem climática (previsão de furacões com EDOs rígidas) e farmacocinética (simulação de liberação de drogas), onde passos adaptativos evitam imprecisões e loops em regiões singulares."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Estabelecer limite mínimo para h",
                            "description": "Definir h_min para evitar singularidades ou custos excessivos, parando a integração se h < h_min.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a necessidade de um limite mínimo para h",
                                  "subSteps": [
                                    "Analise problemas comuns em integrações numéricas, como singularidades em funções (ex: 1/x perto de x=0) ou oscilações rápidas.",
                                    "Estude o impacto de h muito pequeno: aumento exponencial no número de passos e custo computacional.",
                                    "Revise literatura ou exemplos onde h_min previne falhas em métodos como Runge-Kutta adaptativo.",
                                    "Identifique cenários onde h_min é essencial: funções com polos ou gradientes íngremes.",
                                    "Discuta trade-offs: precisão vs. eficiência computacional."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que h_min evita singularidades e custos excessivos, com um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), notebook com exemplos de integração falha.",
                                  "tips": "Comece com gráficos de erro vs. h para visualizar o problema.",
                                  "learningObjective": "Reconhecer os riscos de h excessivamente pequeno em integrações numéricas.",
                                  "commonMistakes": "Confundir h_min com tolerância de erro; ignorar dependência da função específica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o valor apropriado para h_min",
                                  "subSteps": [
                                    "Baseado na função f(x), estime h_min usando análise assintótica (ex: perto de singularidade x=a, h_min ~ (x-a)^α).",
                                    "Use heurísticas: h_min = 1e-10 * intervalo total ou baseado em máquina epsilon.",
                                    "Teste valores candidatos em uma integração simples sem singularidade para validar estabilidade.",
                                    "Considere o contexto: para funções suaves, h_min maior; para rígidas, menor mas cauteloso.",
                                    "Documente a escolha com justificativa matemática."
                                  ],
                                  "verification": "Calcule h_min para uma função dada (ex: 1/sqrt(x)) e justifique o valor escolhido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de cálculo simbólico (SymPy/Mathematica), papel e lápis para análise.",
                                  "tips": "Sempre relacione h_min ao comportamento local da função, não global.",
                                  "learningObjective": "Selecionar h_min baseado em propriedades da função e restrições computacionais.",
                                  "commonMistakes": "Escolher h_min fixo universal; muito grande, ignorando singularidades reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a verificação de h_min no algoritmo",
                                  "subSteps": [
                                    "Modifique o loop de integração: após tentativa de redução de h, cheque if h < h_min.",
                                    "Defina ação: pare a integração e retorne erro ou mensagem 'Passo muito pequeno'.",
                                    "Integre com controle de passo existente (ex: se erro local > tol, h = h/s, mas cheque h_min).",
                                    "Adicione logging: registre quando h atinge h_min e motivo.",
                                    "Teste unitário: código deve parar corretamente sem crash."
                                  ],
                                  "verification": "Execute código modificado em exemplo com singularidade; confirme parada em h_min.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Linguagem de programação (Python/MATLAB), editor de código, função de teste com singularidade.",
                                  "tips": "Use condicionais claras e evite loops infinitos com contador de iterações.",
                                  "learningObjective": "Incorporar h_min de forma robusta em algoritmos de integração adaptativa.",
                                  "commonMistakes": "Esquecer de atualizar h após redução; não tratar o caso de parada adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar o limite h_min em cenários reais",
                                  "subSteps": [
                                    "Teste com funções sem singularidade: confirme que não para prematuramente.",
                                    "Teste com singularidades: verifique parada correta e precisão até o ponto.",
                                    "Compare tempo de execução com e sem h_min.",
                                    "Analise saída: erro estimado, número de passos, logs.",
                                    "Ajuste h_min iterativamente baseado em testes."
                                  ],
                                  "verification": "Gere relatório com métricas: tempo, precisão, casos de parada para 3 funções diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código implementado, benchmarks de funções (ex: exp(-1/x^2), log(x)).",
                                  "tips": "Use plots de h vs. x para visualizar o comportamento do passo.",
                                  "learningObjective": "Avaliar eficácia de h_min através de testes empíricos.",
                                  "commonMistakes": "Testar só casos ideais; ignorar overhead computacional da verificação."
                                }
                              ],
                              "practicalExample": "Ao integrar ∫ de 0 a 1 de 1/sqrt(x) dx usando Runge-Kutta de ordem 4 adaptativo, defina h_min = 1e-6. O algoritmo reduz h perto de x=0; ao atingir h_min, para e alerta 'Singularidade detectada', evitando bilhões de passos.",
                              "finalVerifications": [
                                "O algoritmo para corretamente quando h < h_min sem crash.",
                                "h_min é escolhido adequadamente para a função testada (ex: baseado em análise local).",
                                "Logs registram o evento de parada com posição x e motivo.",
                                "Precisão é mantida até o ponto de parada.",
                                "Tempo de execução é finito e razoável comparado a sem h_min.",
                                "Testes em múltiplas funções confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Explicação clara da motivação para h_min (compreensão conceitual).",
                                "Cálculo/justificativa precisa de h_min (análise matemática).",
                                "Implementação correta e limpa do cheque (qualidade de código).",
                                "Resultados de testes empíricos com métricas quantitativas.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Relatório completo com exemplos e plots."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em loops e controle de exceções.",
                                "Física Computacional: Simulações de equações diferenciais rígidas.",
                                "Otimização: Balanceamento de precisão e custo computacional.",
                                "Estatística: Análise de erro em métodos numéricos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), h_min previne falhas em malhas perto de paredes ou choques, garantindo simulações viáveis em tempo real para design de aviões ou previsão climática."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Regras Heurísticas para Aumento do Passo",
                        "description": "Mecanismos para ampliar h quando a precisão é excedida, otimizando eficiência computacional sem perda de acurácia.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Calcular fator de aumento conservador",
                            "description": "Aplicar h_new = h * min(5, 1.4 * (Tol / err)^{1/(p+1)}), com fator de segurança 1.4 para compensar superestimação de erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e coletar parâmetros de entrada",
                                  "subSteps": [
                                    "Identifique o tamanho de passo atual h (ex: h = 0.1).",
                                    "Determine a tolerância desejada Tol (ex: Tol = 1e-3).",
                                    "Obtenha o erro estimado err do último passo (ex: err = 5e-5).",
                                    "Confirme a ordem do método p (ex: p = 1 para Euler).",
                                    "Valide que Tol > 0, err > 0 e h > 0 para evitar divisões inválidas."
                                  ],
                                  "verification": "Liste todos os parâmetros com valores numéricos e explique o papel de cada um em uma frase.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora científica, documentação do método numérico.",
                                  "tips": "Registre unidades consistentes (ex: h em segundos) para evitar erros dimensionais.",
                                  "learningObjective": "Entender o significado físico/matemático de h, Tol, err e p no contexto de métodos numéricos para EDOs.",
                                  "commonMistakes": "Confundir Tol (tolerância alvo) com err (erro atual medido); usar err = 0 levando a divisão por zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o fator de aumento base",
                                  "subSteps": [
                                    "Calcule o rácio r = Tol / err (ex: 1e-3 / 5e-5 = 20).",
                                    "Compute o expoente e = 1 / (p + 1) (ex: 1 / (1 + 1) = 0.5).",
                                    "Eleve r à potência e: base = r^e (ex: 20^0.5 ≈ 4.472).",
                                    "Arredonde para precisão adequada (ex: 4 dígitos significativos).",
                                    "Verifique se base > 1 (indicando que erro está abaixo de Tol)."
                                  ],
                                  "verification": "Mostre cálculos intermediários: r, e e base, confirmando base ≈ 4.472.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora com funções exponenciais, software como Python (numpy.power) ou MATLAB.",
                                  "tips": "Use logaritmos para potências grandes: log(base) = e * log(r) para estabilidade numérica.",
                                  "learningObjective": "Dominar o cálculo da potência fracionária que reflete a taxa de convergência do método.",
                                  "commonMistakes": "Erro no expoente (usar p em vez de p+1); calcular err/Tol em vez de Tol/err."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar fator de segurança e limite conservador",
                                  "subSteps": [
                                    "Multiplique o fator base pelo coeficiente de segurança: safe = 1.4 * base (ex: 1.4 * 4.472 ≈ 6.261).",
                                    "Aplique o limite superior: factor = min(5, safe) (ex: min(5, 6.261) = 5).",
                                    "Justifique o 1.4: compensa superestimação típica de err em métodos adaptativos.",
                                    "Explique o limite 5: evita passos muito grandes que podem perder estabilidade.",
                                    "Registre o factor final."
                                  ],
                                  "verification": "Confirme factor = 5 e explique por que não excedeu 5.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora, tabela de referência para heurísticas numéricas.",
                                  "tips": "O fator 1.4 é empírico; memorize como 'conservadorismo padrão' em solvers como ode45.",
                                  "learningObjective": "Aplicar heurísticas de segurança para robustez numérica.",
                                  "commonMistakes": "Esquecer o 1.4 ou usar max em vez de min; ignorar que factor pode ser <1 se err > Tol."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o novo tamanho de passo h_new",
                                  "subSteps": [
                                    "Multiplique h pelo factor: h_new = h * factor (ex: 0.1 * 5 = 0.5).",
                                    "Arredonde h_new para precisão numérica adequada (ex: 2-3 casas decimais).",
                                    "Verifique se h_new > h (aumento esperado quando err < Tol).",
                                    "Prepare para o próximo passo: atualize h = h_new.",
                                    "Teste consistência: simule se err esperado diminuiria."
                                  ],
                                  "verification": "Calcule h_new = 0.5 e confirme fórmula completa: h * min(5, 1.4*(Tol/err)^{1/(p+1)}).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora, pseudocódigo de algoritmo adaptativo.",
                                  "tips": "Sempre limite h_new a um máximo global baseado no domínio do problema.",
                                  "learningObjective": "Finalizar o ajuste de passo integrando todos os componentes da heurística.",
                                  "commonMistakes": "Multiplicar errado (ex: h / factor); não atualizar h para iterações futuras."
                                }
                              ],
                              "practicalExample": "Dado h=0.1, Tol=1e-3, err=5e-5, p=1: r=Tol/err=20, e=0.5, base=√20≈4.472, safe=1.4*4.472≈6.261, factor=min(5,6.261)=5, h_new=0.1*5=0.5. Isso aumenta o passo pois err << Tol, acelerando a simulação.",
                              "finalVerifications": [
                                "Reproduza a fórmula h_new = h * min(5, 1.4 * (Tol / err)^{1/(p+1)}) de memória.",
                                "Calcule corretamente h_new para valores aleatórios (ex: h=0.2, Tol=1e-4, err=1e-6, p=2).",
                                "Explique o papel do 1.4 em compensar superestimação de erro.",
                                "Identifique cenários onde factor=5 (limite atingido) vs. factor<5.",
                                "Implemente em pseudocódigo simples.",
                                "Verifique se h_new aumenta apenas quando err < Tol."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 1% nos cálculos intermediários.",
                                "Correta aplicação de min(5, ...): não exceder 5 mesmo se safe>5.",
                                "Inclusão obrigatória do fator 1.4 em todos os cálculos.",
                                "Validação de entradas: rejeitar casos inválidos (err=0).",
                                "Explicação conceitual: ligar à ordem p e convergência.",
                                "Eficiência: tempo total < 45 min com acertos >90%."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em loops de solvers ODE (Python/NumPy, MATLAB).",
                                "Física/Engenharia: Otimizar simulações dinâmicas (ex: trajetórias, circuitos).",
                                "Estatística: Análise de erro e tolerâncias em modelagem estocástica.",
                                "Ciência da Computação: Algoritmos adaptativos e complexidade O(h^{-(p+1)})."
                              ],
                              "realWorldApplication": "Usado em solvers numéricos como MATLAB ode45 ou SciPy solve_ivp para EDOs em simulações reais: previsão climática, controle de voo em aviões, modelagem de epidemias (COVID), otimizando precisão vs. tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Limitar aumentos sucessivos e próximos ao final do intervalo",
                            "description": "Restringir crescimento se próximo ao b_final ou após rejeições recentes, usando contadores para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os riscos de aumentos sucessivos no tamanho do passo",
                                  "subSteps": [
                                    "Analisar como aumentos sucessivos de h podem levar a overshooting e perda de precisão.",
                                    "Estudar o impacto cumulativo no erro global da integração numérica.",
                                    "Revisar exemplos de instabilidade em métodos adaptativos como Runge-Kutta.",
                                    "Identificar condições onde o erro local diminui rapidamente, sugerindo aumento.",
                                    "Discutir heurísticas comuns para controle conservador."
                                  ],
                                  "verification": "Explicar em um parágrafo os riscos e fornecer um exemplo gráfico simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de Dormand-Prince RK45",
                                    "Gráficos de erro em integrações adaptativas",
                                    "Notebook Jupyter com exemplos"
                                  ],
                                  "tips": "Use plots de h vs. t para visualizar aumentos sucessivos.",
                                  "learningObjective": "Reconhecer os problemas causados por aumentos excessivos de h e sua relação com estabilidade.",
                                  "commonMistakes": [
                                    "Confundir erro local com erro global",
                                    "Ignorar o efeito de overshooting no final do intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir regra heurística para limitar aumentos sucessivos",
                                  "subSteps": [
                                    "Estabelecer contador de aumentos recentes (ex: resetar após N passos sem aumento).",
                                    "Definir limite: permitir no máximo 1 aumento a cada 3-5 passos.",
                                    "Implementar lógica: se contador_aumentos >= max_sucessivos, manter h atual.",
                                    "Testar com tol de erro para disparar aumentos simulados.",
                                    "Ajustar parâmetros baseados em testes empíricos."
                                  ],
                                  "verification": "Codificar pseudocódigo da regra e simular 10 passos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de solver adaptativo",
                                    "Biblioteca SciPy odeint para referência",
                                    "Papel e lápis para fluxograma"
                                  ],
                                  "tips": "Comece com max_sucessivos = 1 para testes conservadores.",
                                  "learningObjective": "Criar e validar uma regra simples para evitar aumentos consecutivos.",
                                  "commonMistakes": [
                                    "Resetar contador incorretamente após rejeições",
                                    "Não considerar passos bem-sucedidos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar detecção de proximidade ao final do intervalo",
                                  "subSteps": [
                                    "Calcular fração restante: (b_final - t_atual) / (b_final - a_inicial).",
                                    "Definir threshold (ex: 0.05 ou 5% restante) para ativar limitação.",
                                    "Integrar à lógica: se fração < threshold, proibir aumentos de h.",
                                    "Ajustar h para caber exatamente no intervalo final se necessário.",
                                    "Verificar com projeção: h_projetado = fração_restante * h_nominal."
                                  ],
                                  "verification": "Calcular manualmente para t=0.95*b e confirmar limitação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Fórmulas de solvers numéricos",
                                    "Calculadora ou Python para simulações",
                                    "Exemplos de intervalos [0,1] e [0,10]"
                                  ],
                                  "tips": "Use frações relativas para independência de escala do intervalo.",
                                  "learningObjective": "Detectar e responder à proximidade do b_final para estabilidade.",
                                  "commonMistakes": [
                                    "Usar tempo absoluto em vez de relativo",
                                    "Overshooting b_final sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar regras no algoritmo completo e testar",
                                  "subSteps": [
                                    "Combinar contadores sucessivos e detecção de final em um loop de solver.",
                                    "Implementar em código (Python/MATLAB) com função de teste.",
                                    "Executar integração de exemplo e comparar com solver sem limitações.",
                                    "Analisar logs: número de aumentos, passos finais e erro final.",
                                    "Refinar parâmetros com base em métricas de eficiência e precisão."
                                  ],
                                  "verification": "Gerar relatório com gráficos de h(t) e erro, mostrando estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código base de RK adaptativo",
                                    "Função teste: y' = -y, [0,10]",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Monitore função custo: passos totais vs. erro tolerado.",
                                  "learningObjective": "Aplicar as regras heurísticas em um solver funcional.",
                                  "commonMistakes": [
                                    "Falhar em resetar contadores no início",
                                    "Não tratar h negativo ou zero"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao integrar y' = cos(x), y(0)=0 em [0, 10π] com tol=1e-6, h inicial=0.1. Após t=9.5 (95% do intervalo), erro local cai, mas regras limitam h_max=0.2 apesar de sugestão de 0.4, evitando overshoot em x=10π. Contador sucessivo bloqueia 2 aumentos seguidos em t=8-9.",
                              "finalVerifications": [
                                "O solver não permite >1 aumento sucessivo em simulações.",
                                "h é congelado quando <5% do intervalo resta.",
                                "Integração completa sem exceder b_final.",
                                "Erro global < tol em 90% dos testes.",
                                "Logs mostram ativação das regras em cenários apropriados.",
                                "Eficiência: <20% mais passos que solver irrestrito."
                              ],
                              "assessmentCriteria": [
                                "Correção na lógica de contadores (100% acerto em testes unitários).",
                                "Precisão na detecção de proximidade (erro <1% em fração).",
                                "Estabilidade demonstrada em exemplos oscilatórios.",
                                "Eficiência computacional otimizada (passos razoáveis).",
                                "Código limpo com comentários nas heurísticas.",
                                "Análise comparativa com solver padrão."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops adaptativos em Python/NumPy.",
                                "Física: Controle de passo em simulações de dinâmica orbital.",
                                "Engenharia: Otimização em solvers CFD para estabilidade numérica.",
                                "Estatística: Heurísticas semelhantes em MCMC para amostragem eficiente."
                              ],
                              "realWorldApplication": "Em modelagem climática (ODEs para previsão de tempo longo), limita instabilidades perto do horizonte de previsão; em finanças, integra trajetórias de risco sem overshoot em datas de vencimento."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Definir limite máximo para h",
                            "description": "Impor h_max baseado em estabilidade ou custo, ajustando para problemas stiff ou não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Necessidade de um Limite Máximo para h",
                                  "subSteps": [
                                    "Estude os conceitos de estabilidade em métodos numéricos explícitos e implícitos para EDOs.",
                                    "Analise o impacto de passos grandes em problemas stiff, onde rigidez causa instabilidade.",
                                    "Discuta o trade-off entre precisão, custo computacional e estabilidade.",
                                    "Revise exemplos de problemas não-lineares onde h excessivo leva a divergência.",
                                    "Identifique heurísticas comuns como a condição CFL para estabilidade."
                                  ],
                                  "verification": "Resuma em um parágrafo por que h_max é essencial, citando pelo menos dois exemplos de falhas sem limite.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), notas de aula sobre EDOs.",
                                  "tips": "Use diagramas de fase para visualizar instabilidade em passos grandes.",
                                  "learningObjective": "Explicar os riscos de h ilimitado em termos de estabilidade e custo.",
                                  "commonMistakes": "Confundir estabilidade com precisão local, ignorando análise global."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Critérios para Definir h_max",
                                  "subSteps": [
                                    "Avalie critérios de estabilidade: derive h_max a partir da análise de von Neumann ou eigenvalues para problemas lineares.",
                                    "Considere custo computacional: calcule h_max tal que o número total de passos não exceda um threshold (ex: N_max = 1000).",
                                    "Diferencie problemas stiff (h_max baseado em rigidez) vs. não-stiff (baseado em precisão).",
                                    "Incorpore heurísticas: h_max = min( h_stability, h_cost, h_user-defined ).",
                                    "Teste critérios em um problema simples como y' = -λy com λ grande."
                                  ],
                                  "verification": "Crie uma tabela comparando h_max por critério para um EDO de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (MATLAB/SymPy), planilha para simulações.",
                                  "tips": "Comece com problemas lineares para derivar fórmulas analíticas exatas.",
                                  "learningObjective": "Selecionar e justificar o critério dominante para h_max em cenários específicos.",
                                  "commonMistakes": "Escolher h_max muito conservador, sacrificando eficiência desnecessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo e Aplicação de h_max",
                                  "subSteps": [
                                    "Desenvolva uma função para estimar h_max: input (Jacobiano aproximado, custo por passo), output h_max.",
                                    "Integre h_max no algoritmo de controle de passo: if h_proposed > h_max, set h = h_max.",
                                    "Ajuste dinamicamente para não-linearidades: reavalie h_max a cada K passos.",
                                    "Codifique em pseudocódigo ou Python, incluindo flags para stiff detection.",
                                    "Execute simulação com e sem h_max para comparar resultados."
                                  ],
                                  "verification": "Mostre código funcional que rejeita h > h_max e plote trajetórias.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Editor de código (Python/Jupyter), biblioteca SciPy para solve_ivp.",
                                  "tips": "Use logging para rastrear quando h_max é ativado e por quê.",
                                  "learningObjective": "Implementar h_max em um solver numérico básico.",
                                  "commonMistakes": "Não atualizar h_max em problemas com coeficientes variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Ajustar a Estratégia de h_max",
                                  "subSteps": [
                                    "Compare soluções numéricas com soluções analíticas ou de referência fina.",
                                    "Meça métricas: tempo de CPU, número de passos, erro global L2.",
                                    "Teste sensibilidade: varie parâmetros de stiff e observe impacto.",
                                    "Otimize heurísticas baseadas em testes: ajuste fatores de segurança (ex: 0.9 * h_stability).",
                                    "Documente casos onde h_max previne falhas em problemas reais."
                                  ],
                                  "verification": "Gere relatório com gráficos de erro vs. h_max e conclusões.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramentas de plotagem (Matplotlib), benchmarks de EDOs stiff (ex: Van der Pol).",
                                  "tips": "Automatize testes com loops para múltiplos λ em problemas stiff.",
                                  "learningObjective": "Avaliar eficácia de h_max e refinar sua implementação.",
                                  "commonMistakes": "Avaliar apenas precisão local, ignorando custo total."
                                }
                              ],
                              "practicalExample": "Em um resolvedor RK4 para o problema stiff y' = -1000(y - cos(t)) + sin(t), defina h_max = 0.01 baseado em estabilidade (eigenvalue ~1000 requer h<0.002 para segurança, mas custo limita a 0.01). Simule de t=0 a 10, observando que sem h_max o solver diverge após t=0.5.",
                              "finalVerifications": [
                                "Código implementa clamp(h_proposed, h_min, h_max) corretamente.",
                                "Simulações em problemas stiff convergem sem oscilações.",
                                "Tempo computacional permanece dentro de 2x do ideal.",
                                "h_max é ajustado dinamicamente para não-linearidades.",
                                "Relatório documenta 3 testes com métricas de erro <1e-3.",
                                "Explicação escrita justifica escolha de critérios para h_max."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de h_max por estabilidade (nota 1-5).",
                                "Correção na implementação algorítmica (testes pass/fail).",
                                "Eficiência computacional demonstrada (gráficos comparativos).",
                                "Tratamento adequado de stiff vs. não-stiff (exemplos).",
                                "Qualidade do relatório e verificações finais (rubrica).",
                                "Criatividade em heurísticas personalizadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações dinâmicas (ex: CFD com CFL).",
                                "Ciência da Computação: Otimização de algoritmos adaptativos.",
                                "Engenharia: Controle de processos químicos stiff.",
                                "Estatística: Análise de erro em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em modelagem de reações químicas stiff (ex: combustão), h_max previne crashes em simuladores industriais como COMSOL, equilibrando precisão e tempo de simulação para otimização de reatores em tempo real."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.4",
                            "name": "Avaliar equilíbrio global precisão-custo",
                            "description": "Monitorar número de passos e erro global acumulado para validar heurísticas, ajustando fatores empíricos conforme necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Precisão e Custo",
                                  "subSteps": [
                                    "Defina precisão como o erro global acumulado (ex: norma do erro em relação à solução exata).",
                                    "Defina custo como o número total de passos ou avaliações de função realizadas.",
                                    "Estude heurísticas comuns, como critérios de parada baseados em tolerância relativa (ex: erro < tol * ||solução||).",
                                    "Revise fórmulas para erro global em métodos numéricos (ex: erro de truncamento O(h^p) vs custo O(1/h)).",
                                    "Discuta trade-off: reduzir h aumenta precisão mas eleva custo exponencialmente."
                                  ],
                                  "verification": "Resuma em um diagrama os trade-offs precisão-custo e liste 3 heurísticas exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno para anotações, calculadora.",
                                  "tips": "Use gráficos log-log de erro vs h para visualizar convergência.",
                                  "learningObjective": "Compreender quantitativamente o equilíbrio precisão-custo em métodos numéricos adaptativos.",
                                  "commonMistakes": "Confundir erro local com global; ignorar custo computacional em análises teóricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Monitoramento de Métricas em Código",
                                  "subSteps": [
                                    "Escreva código para simular um método numérico (ex: Runge-Kutta adaptativo para ODE y' = -y, y(0)=1).",
                                    "Registre em arrays: número de passos (n_steps), erro global acumulado (err_global), avaliações de função (nf_eval).",
                                    "Calcule métricas derivadas: custo por unidade de precisão (n_steps / log(1/err_global)).",
                                    "Adicione logs ou prints para monitorar evolução ao longo da integração.",
                                    "Teste com diferentes tolerâncias iniciais para observar variação."
                                  ],
                                  "verification": "Execute o código e gere um relatório com tabela de n_steps, err_global e nf_eval para 3 tolerâncias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, SciPy (odeint), Matplotlib; Jupyter Notebook.",
                                  "tips": "Use contadores globais ou callbacks em solvers SciPy para monitoramento automático.",
                                  "learningObjective": "Desenvolver habilidade em instrumentar código numérico para rastrear métricas de desempenho.",
                                  "commonMistakes": "Não sincronizar contadores de passos com reinicializações adaptativas; usar erro absoluto em vez de relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Equilíbrio Precisão-Custo Gráfica e Numericamente",
                                  "subSteps": [
                                    "Gere plots: erro global vs n_steps (semilog), custo total vs precisão alcançada.",
                                    "Defina heurística de validação: eficiência = -log(err_global) / n_steps > threshold.",
                                    "Compare com baseline fixa-h: calcule razão de melhoria (ex: passos economizados para mesma precisão).",
                                    "Identifique regimes: onde heurística falha (ex: perto de singularidades).",
                                    "Calcule índice de equilíbrio: score = w1 * precisão + w2 * (1/custo), otimize pesos empíricos."
                                  ],
                                  "verification": "Crie 2 gráficos e um tabela com scores de equilíbrio para validar se heurística é eficiente (>1.5x baseline).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Jupyter Notebook com plots Matplotlib/Seaborn, dados do Step 2.",
                                  "tips": "Escalone eixos logarítmicos para melhor visualização de trade-offs.",
                                  "learningObjective": "Analisar visual e numericamente se heurísticas mantêm equilíbrio ótimo.",
                                  "commonMistakes": "Escolher escalas lineares em plots log; ignorar overhead fixo em custo total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Fatores Empíricos e Validar Heurísticas",
                                  "subSteps": [
                                    "Identifique fatores ajustáveis: multiplicadores de segurança (ex: 0.9 para redução h), thresholds de aumento.",
                                    "Otimize via grid search: teste 5x5 combinações de fatores e selecione melhor score.",
                                    "Reexecute simulações com fatores ajustados e compare métricas pré/pós.",
                                    "Valide robustez: teste em 2-3 problemas diferentes (ex: ODE rígida, integração oscilatória).",
                                    "Documente ajustes finais e razões empíricas (ex: 'reduzir safety_factor de 0.9 para 0.85 economiza 20% passos')."
                                  ],
                                  "verification": "Relatório final com tabela comparativa pré/pós-ajuste, mostrando melhoria >10% em eficiência.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código do Step 2 modificado, planilha Excel/Google Sheets para grid search.",
                                  "tips": "Use loops aninhados em Python para automação de grid search.",
                                  "learningObjective": "Iterativamente refinar heurísticas baseadas em dados empíricos para otimização global.",
                                  "commonMistakes": "Overfitting a um problema único; não testar em cenários edge (ex: h muito pequeno)."
                                }
                              ],
                              "practicalExample": "Em uma simulação de decaimento radioativo (ODE y' = -λy), monitore n_steps e err_global com Runge-Kutta4 adaptativo. Inicial: tol=1e-6, safety=0.9. Plot mostra err=5e-7 com 150 passos; ajuste safety=0.85 reduz para 120 passos mantendo err<1e-6, validando heurística.",
                              "finalVerifications": [
                                "Erro global acumulado está abaixo da tolerância alvo em todas as runs.",
                                "Número de passos é < 2x o mínimo teórico para precisão desejada.",
                                "Eficiência (precisão por custo) melhorou >15% pós-ajuste.",
                                "Heurística robusta em 3 problemas teste variados.",
                                "Gráficos mostram convergência suave sem oscilações excessivas.",
                                "Relatório documenta todos ajustes empíricos com justificativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão do monitoramento: métricas rastreadas corretamente (100%).",
                                "Qualidade da análise: plots e scores quantitativos claros (90%+).",
                                "Eficácia dos ajustes: melhoria mensurável em equilíbrio (≥10%).",
                                "Robustez: validação em múltiplos cenários.",
                                "Documentação: relatório completo com verificações.",
                                "Eficiência código: implementação limpa e escalável."
                              ],
                              "crossCurricularConnections": [
                                "Programação: instrumentação e otimização de algoritmos numéricos.",
                                "Estatística: análise de convergência e testes de hipótese em erros.",
                                "Otimização: grid search e trade-offs multi-objetivo.",
                                "Física/Engenharia: simulações computacionais em dinâmica.",
                                "Economia: custo-benefício em decisões computacionais."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica fluidos computacional) para design aeroespacial, avaliar equilíbrio precisão-custo otimiza tempo de simulação de dias para horas, permitindo iterações rápidas em projetos da NASA ou Boeing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.2",
                              "10.1.3.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Controle de Tolerância Local e Global",
                    "description": "Definição de tolerâncias relativas e absolutas para controlar a precisão acumulada na solução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Tolerância Local",
                        "description": "Conceito de tolerância local, que controla o erro estimado em cada passo individual dos métodos numéricos para problemas de valor inicial (PVI), permitindo adaptação do tamanho do passo para manter a precisão local desejada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir tolerância local",
                            "description": "Explicar a tolerância local como o limite superior para o erro estimado por passo em métodos de Runge-Kutta adaptativos ou outros solvers de EDOs com controle de passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Erro Local de Truncamento em Métodos de Runge-Kutta",
                                  "subSteps": [
                                    "Revise a definição de erro local de truncamento para métodos de Runge-Kutta de ordem fixa.",
                                    "Derive ou memorize a fórmula aproximada do erro local: O(h^{p+1}), onde p é a ordem do método.",
                                    "Calcule o erro local para o método RK4 em uma EDO simples como y' = y, y(0)=1.",
                                    "Compare com o método de Euler para destacar a superioridade de ordens mais altas.",
                                    "Discuta como o erro local se acumula em múltiplos passos para formar o erro global."
                                  ],
                                  "verification": "Realize um cálculo manual de erro local para uma EDO de primeiro ordem e explique o resultado em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden e Faires (Capítulo sobre EDOs)",
                                    "Calculadora ou software como Python com NumPy",
                                    "Notas de aula sobre métodos explícitos de Runge-Kutta"
                                  ],
                                  "tips": "Sempre expresse o erro em termos de h para visualizar a dependência no tamanho do passo.",
                                  "learningObjective": "Dominar a base conceitual do erro local como desvio por passo individual.",
                                  "commonMistakes": [
                                    "Confundir erro local com erro global acumulado",
                                    "Esquecer que o erro local é por passo, não total"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Estimadores de Erro em Métodos Adaptativos",
                                  "subSteps": [
                                    "Estude o método Runge-Kutta-Fehlberg (RKF45) e seu estimador de erro embutido.",
                                    "Implemente ou simule dois soluções paralelas: uma de ordem 4 e outra de ordem 5 para estimar erro.",
                                    "Calcule o erro estimado como |y5 - y4| / (2^p - 1), onde p=4.",
                                    "Analise como o estimador guia o controle de passo (aceitar/rejeitar).",
                                    "Teste com uma EDO não-linear como y' = -y^2, y(0)=1."
                                  ],
                                  "verification": "Implemente um estimador simples em pseudocódigo e verifique com valores numéricos conhecidos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação MATLAB ode45 ou SciPy solve_ivp",
                                    "Python/Jupyter Notebook com bibliotecas NumPy e Matplotlib",
                                    "Artigo ou tutorial sobre RKF45"
                                  ],
                                  "tips": "Use soluções exatas conhecidas para validar o estimador em testes iniciais.",
                                  "learningObjective": "Entender como métodos adaptativos estimam o erro local dinamicamente.",
                                  "commonMistakes": [
                                    "Ignorar o fator de normalização no estimador de erro",
                                    "Não considerar vetores para sistemas de EDOs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Tolerância Local como Limite Superior para Erro Estimado",
                                  "subSteps": [
                                    "Defina formalmente: tolerância local (tol_local) como o limite máximo permitido para o erro estimado por passo.",
                                    "Explique o algoritmo: se erro_estimado <= tol_local, aceite passo; senão, reduza h.",
                                    "Discuta relação com tolerância global: tol_local ≈ tol_global / N, onde N é número de passos.",
                                    "Ajuste tol_local para componentes (absoluta e relativa: tol * (|y| + 1)).",
                                    "Simule um laço de controle de passo com tol_local = 1e-6."
                                  ],
                                  "verification": "Escreva o pseudocódigo do critério de aceitação/rejeição usando tol_local e teste logicamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Pseudocódigo de solvers adaptativos (ex: de Hairer 'Solving ODEs')",
                                    "Planilha Excel ou Python para simular laços de passo"
                                  ],
                                  "tips": "Comece com tol_local conservadora (ex: 0.1 * tol_global) para evitar rejeições excessivas.",
                                  "learningObjective": "Definir precisamente tol_local e seu papel no controle de erro por passo.",
                                  "commonMistakes": [
                                    "Definir tol_local igual a tol_global",
                                    "Não diferenciar tolerâncias absoluta e relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estratégias para Escolher e Ajustar a Tolerância Local",
                                  "subSteps": [
                                    "Avalie impacto de diferentes tol_local na precisão e eficiência computacional.",
                                    "Teste heurísticas: tol_local = tol_global^{1/2} ou baseado em Lipschitz da EDO.",
                                    "Implemente ajuste adaptativo: tol_new = tol * (erro/tol)^0.25 para eficiência.",
                                    "Compare simulações com tol_local variando de 1e-3 a 1e-9 em tempo de CPU.",
                                    "Documente trade-offs: tol muito pequena causa muitos passos; muito grande, imprecisão."
                                  ],
                                  "verification": "Execute simulações comparativas e plote erro vs. tempo para justificar uma escolha de tol_local.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python pronto para RKF45 (GitHub repos)",
                                    "Gráficos de erro vs. h em Matplotlib"
                                  ],
                                  "tips": "Monitore o número de rejeições de passo; ideal <20% do total.",
                                  "learningObjective": "Selecionar tol_local otimizada para problemas específicos de EDOs.",
                                  "commonMistakes": [
                                    "Escolher tol_local fixa sem testar",
                                    "Ignorar custo computacional em EDOs rígidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao simular o modelo Lotka-Volterra para predador-presa (sistema de 2 EDOs), defina tol_local=1e-8 para capturar oscilações precisas sem passos excessivamente pequenos perto de equilíbrios, resultando em solução estável em t=[0,20] com ~500 passos.",
                              "finalVerifications": [
                                "Explicar tol_local vs. tol_global com exemplo numérico.",
                                "Implementar critério de aceitação em pseudocódigo correto.",
                                "Escolher tol_local adequada para uma EDO dada, justificando.",
                                "Simular e plotar impacto de tol_local em precisão e eficiência.",
                                "Identificar quando tol_local falha (ex: EDOs rígidas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição exata sem confusões (30%)",
                                "Habilidade prática: implementação/simulação funcional (25%)",
                                "Análise crítica: trade-offs discutidos (20%)",
                                "Exemplos relevantes: uso de EDOs reais (15%)",
                                "Clareza na verificação: passos reproduzíveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em Python/SciPy ou MATLAB.",
                                "Física Computacional: Simulações dinâmicas em mecânica/orbitais.",
                                "Engenharia de Controle: Solvers para sistemas lineares invariantes no tempo.",
                                "Estatística Computacional: Integração MCMC com controle de erro."
                              ],
                              "realWorldApplication": "Em software como MATLAB ode45 ou NASA solvers para trajetórias espaciais, tol_local garante precisão em simulações de reentrada atmosférica, balanceando erro <1e-10 com tempo de computação viável em missões reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Diferenciar tolerâncias locais absolutas e relativas",
                            "description": "Distinguir tolerância local absoluta (erro absoluto por passo) de relativa (erro relativo à solução local), com fórmulas como |e| ≤ tol_abs ou |e|/|y| ≤ tol_rel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de tolerância local em métodos numéricos",
                                  "subSteps": [
                                    "Revise o contexto de análise numérica e controle de passo em métodos iterativos.",
                                    "Leia a definição de erro local como a diferença entre iterações consecutivas.",
                                    "Identifique onde a tolerância local é usada para decidir quando parar uma iteração.",
                                    "Anote exemplos de métodos que usam controle de tolerância (ex: método da bissecção, Newton-Raphson).",
                                    "Compare tolerância local com global para fixar diferenças iniciais."
                                  ],
                                  "verification": "Explique em suas palavras o que é tolerância local e dê um exemplo de método iterativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula de Análise Numérica I",
                                    "Livro-texto sobre métodos numéricos (capítulo de controle de erro)",
                                    "Vídeo introdutório sobre erros numéricos"
                                  ],
                                  "tips": "Foque no 'local' como erro por passo, não acumulado.",
                                  "learningObjective": "Compreender o papel da tolerância local no controle de precisão iterativa.",
                                  "commonMistakes": [
                                    "Confundir tolerância local com global (acumulada)",
                                    "Ignorar que é por iteração específica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e exemplificar tolerância local absoluta",
                                  "subSteps": [
                                    "Estude a fórmula |e| ≤ tol_abs, onde e é o erro local (ex: |x_{n+1} - x_n|).",
                                    "Calcule manualmente um exemplo simples: em bissecção, |b - a|/2 ≤ 0.001.",
                                    "Desenhe um fluxograma de decisão para aplicar tol_abs em um algoritmo.",
                                    "Registre vantagens: simples, independente da magnitude da solução.",
                                    "Pratique com valores numéricos variados para observar o impacto."
                                  ],
                                  "verification": "Resolva um problema onde aplique tol_abs e verifique se |e| ≤ tol_abs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Papel e lápis para cálculos manuais",
                                    "Pseudocódigo de método iterativo"
                                  ],
                                  "tips": "Use tol_abs para soluções próximas de zero, onde rel é problemática.",
                                  "learningObjective": "Dominar a fórmula e aplicação da tolerância absoluta local.",
                                  "commonMistakes": [
                                    "Usar tol_abs em soluções grandes, levando a pouca precisão relativa",
                                    "Esquecer o valor absoluto na fórmula"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e exemplificar tolerância local relativa",
                                  "subSteps": [
                                    "Estude a fórmula |e| / |y| ≤ tol_rel, onde y é a solução aproximada atual.",
                                    "Calcule um exemplo: em iteração, |x_{n+1} - x_n| / |x_{n+1}| ≤ 10^{-6}.",
                                    "Compare com tol_abs no mesmo exemplo para ver diferenças.",
                                    "Implemente em pseudocódigo a condição de parada relativa.",
                                    "Analise casos onde y é pequeno ou zero (problemas de divisão por zero)."
                                  ],
                                  "verification": "Aplique tol_rel em um cálculo e confirme que a condição relativa é satisfeita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplos de código Python simples para iterações",
                                    "Tabela comparativa de exemplos"
                                  ],
                                  "tips": "tol_rel é ideal para soluções de grande magnitude, mantendo precisão percentual.",
                                  "learningObjective": "Dominar a fórmula e aplicação da tolerância relativa local.",
                                  "commonMistakes": [
                                    "Dividir por zero quando y≈0",
                                    "Confundir com erro percentual global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e escolher entre tolerâncias absolutas e relativas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: fórmulas, vantagens, desvantagens e cenários de uso.",
                                    "Resolva um problema híbrido: use tol_abs para y pequeno e tol_rel para y grande.",
                                    "Discuta critérios de escolha baseados na escala da solução esperada.",
                                    "Simule um algoritmo que combina ambas (ex: max(tol_abs, tol_rel * |y|)).",
                                    "Avalie impacto na convergência e eficiência computacional."
                                  ],
                                  "verification": "Classifique corretamente 3 cenários: quando usar abs vs rel, justificando.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela em branco para comparação",
                                    "Exemplos numéricos resolvidos",
                                    "Gráfico de convergência"
                                  ],
                                  "tips": "Sempre considere a escala física da solução real.",
                                  "learningObjective": "Saber diferenciar e selecionar a tolerância apropriada por contexto.",
                                  "commonMistakes": [
                                    "Usar sempre uma só, ignorando o contexto",
                                    "Misturar fórmulas na implementação"
                                  ]
                                }
                              ],
                              "practicalExample": "No método da bissecção para resolver f(x)=0 em [0,1], com tol_abs=0.01: pare se |b-a|/2 ≤ 0.01 (erro fixo). Com tol_rel=10^{-4}: pare se |b-a|/2 / |(a+b)/2| ≤ 10^{-4} (erro percentual). Para raiz ~0.5, ambas semelhantes; para raiz ~10^{-5}, tol_rel falha por divisão pequena, tol_abs é melhor.",
                              "finalVerifications": [
                                "Defina corretamente as fórmulas de tol_abs e tol_rel.",
                                "Dê um exemplo onde tol_abs é preferível (solução pequena).",
                                "Dê um exemplo onde tol_rel é preferível (solução grande).",
                                "Implemente pseudocódigo para ambas em um método iterativo.",
                                "Explique por que combinar ambas pode ser ideal.",
                                "Identifique erro comum: divisão por zero em tol_rel."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas matemáticas (100% correto).",
                                "Capacidade de diferenciar contextos de uso (abs vs rel).",
                                "Exemplos práticos corretos e relevantes.",
                                "Análise de vantagens/desvantagens clara.",
                                "Sugestão de implementação híbrida viável.",
                                "Ausência de confusão com tolerâncias globais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar controles de tolerância em Python (NumPy/SciPy).",
                                "Física: Controle de precisão em simulações de trajetórias ou equações diferenciais.",
                                "Engenharia: Otimização de algoritmos em CAD ou controle de processos.",
                                "Estatística: Análise de erros de aproximação em regressões numéricas."
                              ],
                              "realWorldApplication": "Em simulações financeiras (ex: precificação de opções via Monte Carlo) ou modelagem climática, tol_abs garante estabilidade perto de zero, enquanto tol_rel assegura precisão em valores grandes, otimizando tempo de CPU em supercomputadores sem perda de acurácia relevante."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Aplicar tolerância local no controle de passo",
                            "description": "Demonstrar como a tolerância local é usada para aceitar/rejeitar passos e ajustar h em métodos de passo variável, garantindo estabilidade local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tolerância local em métodos de passo variável",
                                  "subSteps": [
                                    "Defina tolerância local como o limite de erro aceitável para um único passo de integração numérica.",
                                    "Compare tolerância local (erro por passo) com tolerância global (erro acumulado ao longo da integração).",
                                    "Estude a fórmula típica de estimativa de erro local em métodos embedded, como RK4(5).",
                                    "Revise como a tolerância local garante estabilidade ao rejeitar passos imprecisos."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre tolerância local e global, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos de Runge-Kutta adaptativos"
                                  ],
                                  "tips": "Use diagramas para visualizar erro local vs. global.",
                                  "learningObjective": "Entender o papel da tolerância local na estabilidade de métodos numéricos adaptativos.",
                                  "commonMistakes": [
                                    "Confundir tolerância local com global",
                                    "Ignorar que tol local é tipicamente mais rigorosa que global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o erro local estimado em um passo",
                                  "subSteps": [
                                    "Implemente o método embedded (ex: Dormand-Prince) para estimar erro local como |y_{n+1}^{alta} - y_{n+1}^{baixa}|.",
                                    "Escolha uma EDO teste: y' = f(t,y), com condição inicial.",
                                    "Compute soluções de ordens diferentes no mesmo passo h.",
                                    "Normalize o erro por componente se multidimensional."
                                  ],
                                  "verification": "Calcule erro local para h=0.1 em y'= -y, y(0)=1, e confirme se < tol=1e-3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB com funções numéricas",
                                    "Papel e lápis para cálculos manuais"
                                  ],
                                  "tips": "Sempre normalize erro para vetores: err = |e_i| / tol_i^{1/p}",
                                  "learningObjective": "Dominar o cálculo preciso do erro local usando métodos embedded.",
                                  "commonMistakes": [
                                    "Não normalizar erro em problemas vetoriais",
                                    "Usar ordem errada na estimativa de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar critério de aceitação/rejeição baseado na tolerância local",
                                  "subSteps": [
                                    "Defina critério: aceita se erro_local <= tol_local.",
                                    "Se rejeitado, rejeite o passo e tente novamente com h reduzido.",
                                    "Registre estatísticas: passos aceitos/rejeitados.",
                                    "Integre em loop de controle de passo."
                                  ],
                                  "verification": "Simule 5 passos; verifique se passos com erro > tol são rejeitados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo adaptativo",
                                    "Ambiente de programação (Python com SciPy odeint para referência)"
                                  ],
                                  "tips": "Use fator de segurança 0.9 no critério para evitar oscilações.",
                                  "learningObjective": "Implementar logicamente a decisão de aceitação/rejeição.",
                                  "commonMistakes": [
                                    "Aceitar passos com erro marginal sem fator de segurança",
                                    "Não resetar y_n ao rejeitar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o tamanho do passo h dinamicamente",
                                  "subSteps": [
                                    "Calcule fator de ajuste: h_new = h_old * (tol / erro_local)^{1/(p+1)}, onde p=ordem.",
                                    "Aplique limites: 0.1 <= fator <= 4 para estabilidade.",
                                    "Atualize h para próximo passo se aceito; reduza se rejeitado.",
                                    "Teste convergência global comparando com solução exata."
                                  ],
                                  "verification": "Execute simulação completa; verifique se h varia corretamente e erro global < tol_global.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código fonte de solver adaptativo",
                                    "Gráficos de h vs. t para análise"
                                  ],
                                  "tips": "Monitore número de rejeições; >20% indica tol muito rigorosa.",
                                  "learningObjective": "Otimizar h para eficiência e precisão usando feedback de erro local.",
                                  "commonMistakes": [
                                    "Exponte errada no fator de ajuste",
                                    "Aumentar h excessivamente após aceitação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar tolerância local em algoritmo completo de controle de passo",
                                  "subSteps": [
                                    "Monte loop principal: while t < tf, compute passo, cheque tol local, ajuste h.",
                                    "Inclua controle global opcional: tol_global / (N_passos restantes).",
                                    "Valide com EDO rígida vs. não-rígida.",
                                    "Otimize para eficiência computacional."
                                  ],
                                  "verification": "Implemente e rode para intervalo [0,1]; compare solução numérica com exata (erro <1e-6).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Implementação em Python (scipy.integrate.solve_ivp)",
                                    "Solução analítica para validação"
                                  ],
                                  "tips": "Use eventos para parada precoce se necessário.",
                                  "learningObjective": "Construir solver robusto com controle de tolerância local.",
                                  "commonMistakes": [
                                    "Loop infinito por h->0",
                                    "Ignorar overhead de rejeições frequentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = y*(1-y), y(0)=0.5 (modelo logístico), de t=0 a 5, com tol_local=1e-6 usando RK4(5) adaptativo. Ajuste h começando em 0.1, rejeite passos com erro_local > tol, e plote y(t) vs. solução exata  y(t)=(1+e^{-t})^{-1}. Verifique estabilidade perto do equilíbrio.",
                              "finalVerifications": [
                                "Explicar verbalmente como tol local previne instabilidade.",
                                "Calcular manualmente erro local para um passo dado.",
                                "Implementar código que rejeita corretamente 80% dos passos teste.",
                                "Ajustar h para que erro global final < 1e-5.",
                                "Identificar e corrigir bug comum em ajuste de h.",
                                "Comparar eficiência com método de passo fixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de erro local (erro <1%).",
                                "Correção na decisão aceita/rejeita (100% taxa certa).",
                                "Faixa de variação de h razoável (1e-4 a 0.5).",
                                "Eficiência: <2x passos vs. fixo para mesma precisão.",
                                "Código limpo e comentado.",
                                "Análise de convergência demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos numéricos em Python/MATLAB.",
                                "Física: Simulações de dinâmica em sistemas diferenciais (ex: osciladores).",
                                "Engenharia de Controle: Estabilidade em controladores PID adaptativos.",
                                "Ciência de Dados: Otimização em machine learning para gradientes."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, tolerância local ajusta passos em trajetórias de foguetes para precisão em fases críticas sem desperdício computacional; em modelagem financeira, garante estabilidade em simulações Monte Carlo de opções exóticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Tolerância Global",
                        "description": "Conceito de tolerância global, que visa controlar a precisão acumulada da solução ao final da integração, relacionando-se à tolerância local para evitar acúmulo excessivo de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Definir tolerância global",
                            "description": "Descrever a tolerância global como o erro total desejado na solução final de PVI, medido em normas como máximo ou L2 ao longo do intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tolerância global em PVIs",
                                  "subSteps": [
                                    "Leia a definição: tolerância global é o erro total desejado na solução aproximada ao longo de todo o intervalo de integração.",
                                    "Compare com tolerância local: global mede erro acumulado, local mede erro por passo.",
                                    "Estude exemplos de normas: norma máximo (sup norm) e norma L2 (integral do quadrado do erro).",
                                    "Anote a fórmula matemática para erro global: ||y(t) - y_h(t)|| ≤ tol_global para t em [a,b].",
                                    "Discuta por que tol_global guia o controle de passo para convergência."
                                  ],
                                  "verification": "Escreva um parágrafo explicando tolerância global vs. local e cite uma norma exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre PVIs",
                                    "Calculadora ou papel para anotações"
                                  ],
                                  "tips": "Visualize o erro como uma 'banda' ao redor da solução exata no gráfico da solução.",
                                  "learningObjective": "Explicar precisamente o que é tolerância global e sua relação com o erro total em PVIs.",
                                  "commonMistakes": [
                                    "Confundir com tolerância local (erro por passo)",
                                    "Ignorar que é medida ao longo de todo intervalo",
                                    "Não relacionar com normas vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e selecionar normas adequadas para tolerância global",
                                  "subSteps": [
                                    "Liste normas comuns: norma máximo (||e||_∞ = max |e(t)|), norma L2 (√∫|e(t)|^2 dt).",
                                    "Calcule norma máximo para uma função erro simples, ex: e(t)=sin(t) em [0,π].",
                                    "Calcule norma L2 para o mesmo exemplo usando integração numérica básica.",
                                    "Compare prós/contras: máximo é conservadora, L2 é mais suave para erros oscilatórios.",
                                    "Escolha norma baseada no contexto: máximo para precisão pontual, L2 para energia total."
                                  ],
                                  "verification": "Resolva um exercício: para e(t)=t^2 em [0,1], compute ||e||_∞ e ||e||_L2.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para integração (opcional)",
                                    "Tabela de fórmulas de normas",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use gráficos para visualizar como normas capturam diferentes padrões de erro.",
                                  "learningObjective": "Selecionar e calcular normas apropriadas para medir tolerância global.",
                                  "commonMistakes": [
                                    "Usar norma escalar em vez de vetor/função",
                                    "Confundir L1 com L2",
                                    "Não normalizar pelo comprimento do intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o valor numérico da tolerância global para um PVI específico",
                                  "subSteps": [
                                    "Analise o problema: identifique requisitos de precisão (ex: engenharia precisa 1e-5).",
                                    "Considere custo computacional: tol pequena = mais passos, tol grande = menos precisão.",
                                    "Escolha valor inicial: tipicamente 1e-6 a 1e-3, baseado em solução exata se conhecida.",
                                    "Ajuste por norma: para L2, tol pode ser maior que para máximo devido a suavidade.",
                                    "Documente justificativa: escreva 'tol_global = 1e-6 em norma ∞ para garantir erro <0.1%'.",
                                    "Teste sensibilidade: varie tol e observe impacto no número de passos."
                                  ],
                                  "verification": "Para um PVI dado, proponha tol_global com justificativa e norma escolhida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo de PVI resolvido (ex: y'=y, y(0)=1)",
                                    "Solver numérico online ou Python (SciPy odeint)",
                                    "Planilha para registrar testes"
                                  ],
                                  "tips": "Comece com tol conservadora e refine iterativamente com testes.",
                                  "learningObjective": "Definir um valor quantitativo de tol_global adaptado ao contexto do problema.",
                                  "commonMistakes": [
                                    "Escolher tol arbitrária sem justificativa",
                                    "Ignorar escala da solução (tol relativa vs absoluta)",
                                    "Não considerar comprimento do intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar tolerância global com controle de tolerância local",
                                  "subSteps": [
                                    "Revise relação: tol_local ≈ tol_global / N, onde N é número estimado de passos.",
                                    "Estude adaptativo: tol_global guia refinamento até erro estimado < tol.",
                                    "Implemente em pseudocódigo: while ||erro_acumulado|| > tol_global, refine passos.",
                                    "Simule um exemplo: aplique em método de Euler adaptativo.",
                                    "Avalie trade-off: tol_global apertada requer tol_local menor."
                                  ],
                                  "verification": "Escreva pseudocódigo para solver que para quando tol_global é atingida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python/MATLAB de solver ODE simples",
                                    "Gráficos de soluções com diferentes tols"
                                  ],
                                  "tips": "Monitore erro a posteriori usando soluções em malhas duplas.",
                                  "learningObjective": "Relacionar tol_global com tol_local para controle efetivo de erro.",
                                  "commonMistakes": [
                                    "Definir tol_local = tol_global (subestima acumulação)",
                                    "Não atualizar tol_local dinamicamente",
                                    "Ignorar estimativas de erro local-global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -2y, y(0)=1 em [0,5] (solução exata y=e^{-2t}), defina tol_global=1e-5 em norma máximo. Usando Runge-Kutta4 adaptativo, ajuste passos até max|y_exata(t_i) - y_num(t_i)| ≤ 1e-5, resultando em ~200 passos vs. 50 sem controle.",
                              "finalVerifications": [
                                "Explicar diferença entre tol_global e tol_local com exemplo numérico.",
                                "Calcular norma L2 e máximo para uma função erro dada.",
                                "Propor tol_global para novo PVI com justificativa.",
                                "Escrever pseudocódigo integrando tol_global em solver.",
                                "Identificar norma ideal para aplicação específica (ex: oscilatória vs. suave)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta sem confusões com tol_local (30%)",
                                "Seleção de norma: escolha justificada e cálculo correto (25%)",
                                "Valor de tol: numérico apropriado com análise de sensibilidade (20%)",
                                "Integração prática: pseudocódigo ou simulação funcional (15%)",
                                "Justificativa contextual: adaptação ao problema real (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em solvers ODE (Python SciPy, MATLAB ode45)",
                                "Física: Controle de precisão em simulações dinâmicas (ex: movimento orbital)",
                                "Estatística: Análise de erro e intervalos de confiança em aproximações",
                                "Engenharia Computacional: Otimização de tempo de CPU vs. precisão em CFD"
                              ],
                              "realWorldApplication": "Em modelagem climática, definir tol_global=1e-4 em norma L2 permite simular décadas de dinâmica atmosférica com precisão aceitável em horas de computação, equilibrando erro acumulado e viabilidade em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Relacionar tolerância local e global",
                            "description": "Explicar como definir tol_local ≈ tol_global / √N (N passos) ou estratégias semelhantes para controlar precisão acumulada em métodos de passo múltiplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de tolerância local e global",
                                  "subSteps": [
                                    "Defina tolerância local (tol_local) como o critério de parada em cada passo individual de um método numérico.",
                                    "Defina tolerância global (tol_global) como o erro desejado na solução final após múltiplos passos.",
                                    "Explique a diferença: tol_local controla precisão por passo, tol_global controla precisão acumulada.",
                                    "Discuta por que tol_local deve ser mais estrita que tol_global em métodos iterativos.",
                                    "Revise exemplos simples de métodos como Euler ou Runge-Kutta onde tolerâncias são usadas."
                                  ],
                                  "verification": "Resuma as definições em suas próprias palavras e dê um exemplo de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (capítulo de controle de erro), notas de aula sobre EDOs.",
                                  "tips": "Use analogias: tol_local é como checar cada quilômetro em uma viagem, tol_global é o erro total na chegada.",
                                  "learningObjective": "Distinguir e definir tol_local e tol_global no contexto de métodos numéricos.",
                                  "commonMistakes": "Confundir tol_local com tol_global, achando que são iguais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o acúmulo de erro em métodos de múltiplos passos",
                                  "subSteps": [
                                    "Estude o modelo de erro por passo: erro local ~ O(h^p), onde h é o tamanho do passo.",
                                    "Calcule erro global aproximado: para N passos, erro_total ≈ N * erro_local se erros se somam linearmente.",
                                    "Introduza o fator estatístico: erros aleatórios se acumulam como √N (modelo de caminhada aleatória).",
                                    "Derive qualitativamente: tol_global ≈ √N * tol_local para erros independentes.",
                                    "Compare com erros sistemáticos que se acumulam como N * tol_local."
                                  ],
                                  "verification": "Esboce um gráfico de erro acumulado vs. N passos para erros aleatórios e sistemáticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis para derivações, software como Python/MATLAB para simulações simples de erro.",
                                  "tips": "Pense em termos probabilísticos: variância de soma de variáveis independentes é soma de variâncias.",
                                  "learningObjective": "Modelar o acúmulo de erro em métodos numéricos de passo múltiplo.",
                                  "commonMistakes": "Assumir acúmulo linear para todos os erros, ignorando natureza estocástica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a relação tol_local ≈ tol_global / √N",
                                  "subSteps": [
                                    "Assuma erros locais independentes com variância σ² ≈ tol_local².",
                                    "Variância total do erro global: σ_global² ≈ N * σ², logo σ_global ≈ √N * tol_local.",
                                    "Defina tol_global = k * σ_global, onde k é fator de confiança (ex: 2-3).",
                                    "Resolva para tol_local ≈ tol_global / √N.",
                                    "Discuta generalizações: para erros correlacionados, use fatores diferentes como 1/N ou log(N)."
                                  ],
                                  "verification": "Derive a fórmula passo a passo e aplique a um N=100, tol_global=1e-6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de derivações matemáticas, calculadora para √N.",
                                  "tips": "Comece com o caso simples de soma de erros quadráticos médios (RMS).",
                                  "learningObjective": "Derivar matematicamente a relação entre tolerâncias local e global.",
                                  "commonMistakes": "Usar soma linear em vez de raiz quadrada para erros aleatórios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar a relação em um exemplo prático",
                                  "subSteps": [
                                    "Escolha uma EDO simples: y' = -y, y(0)=1 (solução exata y=e^{-t}).",
                                    "Implemente método de Euler com tol_local = tol_global / √N estimado.",
                                    "Execute simulações variando N (ex: 10, 100, 1000) e compare erro global.",
                                    "Ajuste tol_local iterativamente até erro global ≈ tol_global.",
                                    "Registre resultados em tabela: N, tol_local usada, erro global observado."
                                  ],
                                  "verification": "Confirme que com tol_local = 1e-6 / √100 = 1e-7, erro global fica próximo de 1e-6.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, código template para solver de EDO.",
                                  "tips": "Use controle adaptativo de passo para automação, mas foque manual primeiro.",
                                  "learningObjective": "Aplicar a relação em código numérico e validar empiricamente.",
                                  "commonMistakes": "Ignorar overhead computacional: tol_local muito pequena aumenta tempo excessivamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar estratégias alternativas e boas práticas",
                                  "subSteps": [
                                    "Discuta heurísticas: tol_local = tol_global / N^{1/2} para Runge-Kutta, /N para Euler explícito.",
                                    "Considere controle adaptativo: ajustar h dinamicamente baseado em estimativas locais.",
                                    "Analise trade-offs: precisão vs. custo computacional.",
                                    "Estude casos reais: tolerâncias em bibliotecas como ODE45 (MATLAB).",
                                    "Crie uma tabela de regras para diferentes métodos numéricos."
                                  ],
                                  "verification": "Elabore um fluxograma para escolher tol_local dado tol_global e método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de solvers numéricos (SciPy odeint, MATLAB ode45), artigos sobre controle de erro.",
                                  "tips": "Sempre valide com solução exata quando possível.",
                                  "learningObjective": "Conhecer e comparar estratégias para controle de precisão acumulada.",
                                  "commonMistakes": "Aplicar fórmula única a todos os métodos sem considerar ordem de precisão."
                                }
                              ],
                              "practicalExample": "Ao resolver a EDO y' = y(1-y), y(0)=0.5 (modelo logístico) com Runge-Kutta de ordem 4 até t=5, defina tol_global=1e-5. Estime N≈1000 passos (h=0.005), então tol_local ≈ 1e-5 / √1000 ≈ 3e-7. Implemente e verifique se ||y_num - y_exata|| < 1e-5.",
                              "finalVerifications": [
                                "Derivar corretamente tol_local ≈ tol_global / √N a partir de modelo de erro.",
                                "Implementar em código e obter erro global dentro de tol_global para N variados.",
                                "Explicar diferenças para erros sistemáticos vs. aleatórios.",
                                "Identificar heurística apropriada para método específico (ex: Euler vs. RK4).",
                                "Discutir impacto no tempo de computação.",
                                "Aplicar a um exemplo não-trivial de EDO."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (fórmula exata e justificativa).",
                                "Correção da implementação numérica (código roda sem erros, resultados válidos).",
                                "Análise empírica: gráficos/tabelas mostram relação esperada.",
                                "Compreensão conceitual: explicações claras sem confusões entre conceitos.",
                                "Criatividade em estratégias alternativas e trade-offs discutidos.",
                                "Clareza na documentação: passos reproduzíveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelos de erro como processos estocásticos e lei dos grandes números.",
                                "Computação: Otimização de algoritmos numéricos e controle adaptativo.",
                                "Física: Simulações de dinâmica (ex: movimento browniano, erros em trajetórias).",
                                "Engenharia: Controle de precisão em simulações CFD ou circuitos.",
                                "Probabilidade: Acúmulo de variância em somas independentes."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos de previsão numérica), tol_local é ajustada via tol_global / √N para controlar propagação de erros em milhares de passos temporais, garantindo previsões confiáveis sem custo computacional excessivo em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Implementar controle de tolerâncias em solvers",
                            "description": "Configurar tolerâncias relativas e absolutas em bibliotecas como ODE solvers, ajustando para problemas stiff e verificando estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Tolerâncias Relativas e Absolutas",
                                  "subSteps": [
                                    "Defina tolerância absoluta (atol): erro máximo permitido independentemente do tamanho da solução.",
                                    "Defina tolerância relativa (rtol): erro máximo como fração do valor atual da solução (|err| < rtol * |y| + atol).",
                                    "Analise impacto em erros locais e globais: atol para valores pequenos, rtol para grandes.",
                                    "Estude relação com estabilidade em problemas stiff: tolerâncias frouxas podem causar instabilidade.",
                                    "Revise fórmulas matemáticas para controle de passo adaptativo em solvers ODE."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre atol e rtol com um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação SciPy solve_ivp",
                                    "Notebook Jupyter",
                                    "Artigo sobre ODE solvers"
                                  ],
                                  "tips": "Use rtol=1e-3 e atol=1e-6 como ponto de partida; ajuste baseado na escala da solução.",
                                  "learningObjective": "Distinguir e aplicar conceitos de tolerâncias em contextos de solvers ODE.",
                                  "commonMistakes": [
                                    "Confundir atol com rtol",
                                    "Ignorar escala da solução ao escolher valores",
                                    "Usar tolerâncias muito pequenas sem hardware adequado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Tolerâncias em um Solver ODE Básico",
                                  "subSteps": [
                                    "Instale SciPy e importe solve_ivp de scipy.integrate.",
                                    "Defina um problema ODE simples: y' = -y, y(0)=1 (não-stiff).",
                                    "Implemente solve_ivp com rtol e atol personalizados, plotando solução vs tempo.",
                                    "Varie rtol/atol e compare número de passos e precisão com solução analítica (e^{-t}).",
                                    "Registre métricas: tempo de computação e erro máximo."
                                  ],
                                  "verification": "Gere plots mostrando convergência da solução numérica à analítica para diferentes tolerâncias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python 3.9+",
                                    "SciPy 1.10+",
                                    "Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre defina t_span e t_eval para controle fino da saída; use method='RK45' inicialmente.",
                                  "learningObjective": "Implementar e testar configuração de tolerâncias em solver explícito.",
                                  "commonMistakes": [
                                    "Esquecer de importar corretamente",
                                    "Não especificar dense_output=True para avaliação suave",
                                    "Comparar sem solução de referência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Tolerâncias a Problemas Stiff",
                                  "subSteps": [
                                    "Escolha problema stiff clássico: sistema de Robertson (reações químicas).",
                                    "Configure solve_ivp com method='Radau' ou 'BDF' para implícito.",
                                    "Ajuste rtol/atol iterativamente: comece frouxo (1e-3) e aperte para 1e-8, observando falhas.",
                                    "Monitore passos rejeitados e eventos de estabilidade via atributos da solução.",
                                    "Compare com solver explícito para destacar necessidade de métodos implícitos."
                                  ],
                                  "verification": "O solver converge sem warnings para atol=1e-8 em problema stiff, com passos < 1000.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "SciPy",
                                    "Exemplo de dados Robertson: y' = [-0.04*y0 + 1e4*y1*y2, 0.04*y0 - 1e4*y1*y2 - 3e7*y1^2, 1e4*y1*y2]"
                                  ],
                                  "tips": "Para stiff, priorize atol pequeno em componentes rígidos; use max_step para limitar.",
                                  "learningObjective": "Adaptar tolerâncias para garantir estabilidade em ODEs stiff.",
                                  "commonMistakes": [
                                    "Usar método explícito em stiff sem tolerâncias frouxas",
                                    "Ignorar warnings de step size too small",
                                    "Não escalar variáveis para ordem de magnitude similar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade e Otimizar Configurações",
                                  "subSteps": [
                                    "Calcule erros globais comparando com solução de alta precisão (rtol=1e-12).",
                                    "Analise eficiência: passos totais, tempo CPU vs precisão alcançada.",
                                    "Implemente função para auto-ajuste de tolerâncias baseado em erro estimado.",
                                    "Teste sensibilidade: varie parâmetros e plote curvas de erro vs log(rtol).",
                                    "Documente melhores práticas para problemas reais."
                                  ],
                                  "verification": "Relatório com tabelas/plots mostrando trade-off precisão vs custo computacional.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NumPy para métricas de erro",
                                    "Matplotlib para visualizações"
                                  ],
                                  "tips": "Use np.linalg.norm para erros; log-scale plots para tolerâncias.",
                                  "learningObjective": "Avaliar e otimizar controle de tolerâncias para eficiência e estabilidade.",
                                  "commonMistakes": [
                                    "Avaliar só visualmente sem métricas quantitativas",
                                    "Sobreajustar tolerâncias levando a lentidão desnecessária",
                                    "Não considerar ruído numérico em componentes pequenos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o problema stiff de Robertson com y0(0)=1, y1(0)=0, y2(0)=0 até t=1e5*ln(2). Use solve_ivp(rtol=1e-6, atol=1e-8, method='LSODA') e compare com solução de referência, ajustando para estabilidade sem mais de 500 passos.",
                              "finalVerifications": [
                                "Código executa sem erros ou warnings para problemas stiff e não-stiff.",
                                "Soluções numéricas convergem monotonicamente com tolerâncias menores.",
                                "Número de passos aumenta razoavelmente com precisão demandada.",
                                "Erros globais respeitam rtol/atol em todos componentes.",
                                "Plots mostram estabilidade: sem oscilações espúrias ou divergência.",
                                "Relatório documenta otimizações específicas para o problema testado."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro < rtol em 95% dos pontos avaliados.",
                                "Eficiência: tempo < 5s para simulações padrão em hardware comum.",
                                "Correção: uso adequado de métodos implícitos para stiff.",
                                "Análise: identificação de trade-offs via métricas quantitativas.",
                                "Generalização: aplicação bem-sucedida a pelo menos dois problemas diferentes.",
                                "Documentação: código comentado com explicações de escolhas de tolerâncias."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso avançado de SciPy/NumPy em computação científica.",
                                "Física/Química: Modelagem de sistemas dinâmicos stiff como reações químicas.",
                                "Engenharia: Simulações em controle de sistemas e aerodinâmica.",
                                "Estatística: Análise de erros e convergência numérica."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas (ex: farmacocinética), ajustes de tolerâncias garantem precisão em cinéticas stiff sem custo computacional excessivo; usado em software como MATLAB SimBiology ou COMSOL para engenharia química e biomédica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Tolerâncias Relativas e Absolutas",
                        "description": "Definições e uso combinado de tolerâncias absolutas e relativas para lidar com soluções próximas de zero ou com escalas variadas na precisão numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Definir tolerâncias absolutas",
                            "description": "Explicar tol_abs como limite para |erro| independente da magnitude da solução, útil quando y é pequeno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Erro Absoluto e Tolerância Absoluta",
                                  "subSteps": [
                                    "Defina erro absoluto como |erro| = |aproximação - valor exato|.",
                                    "Explique que tol_abs é um limite fixo para |erro|, independente do tamanho da solução y.",
                                    "Discuta cenários onde y é pequeno (ex: y ≈ 10^-6), tornando tol_rel ineficaz.",
                                    "Compare com tol_rel = tol * |y|, destacando independência de tol_abs.",
                                    "Visualize graficamente: linha horizontal para tol_abs vs linha proporcional para tol_rel."
                                  ],
                                  "verification": "Escreva uma definição precisa de tol_abs e dê um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora, gráfico de erro absoluto vs relativo.",
                                  "tips": "Use exemplos com números pequenos para intuitivamente sentir a diferença.",
                                  "learningObjective": "Compreender tol_abs como limite fixo para |erro|.",
                                  "commonMistakes": "Confundir tol_abs com tol_rel ou achar que depende de y."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Quando Usar Tolerâncias Absolutas",
                                  "subSteps": [
                                    "Analise casos onde |y| é muito pequeno (ex: < 10^-3), tol_rel pode ser muito restritiva.",
                                    "Liste situações: soluções próximas de zero em equações diferenciais ou otimização.",
                                    "Compare critérios de parada: pare se |erro| < tol_abs OU |erro| < tol_rel * |y|.",
                                    "Teste com exemplo: resolver x^2 = 10^-10, onde tol_rel falha.",
                                    "Crie tabela comparativa de tol_abs vs tol_rel em diferentes magnitudes de y."
                                  ],
                                  "verification": "Classifique 3 problemas numéricos quanto ao uso de tol_abs ou tol_rel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou Python para simulações rápidas, exemplos de problemas.",
                                  "tips": "Sempre pergunte: 'A solução é pequena?' para decidir tol_abs.",
                                  "learningObjective": "Saber selecionar tol_abs baseado no tamanho esperado de y.",
                                  "commonMistakes": "Usar tol_rel universalmente, ignorando y pequeno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Escolher Valores para tol_abs",
                                  "subSteps": [
                                    "Estabeleça tol_abs típico: 10^-6 a 10^-12, baseado em precisão da máquina.",
                                    "Considere precisão de ponto flutuante (eps ≈ 10^-16).",
                                    "Escolha tol_abs > 10 * eps para estabilidade numérica.",
                                    "Ajuste empiricamente: rode algoritmo com diferentes tol_abs e observe convergência.",
                                    "Documente justificativa: 'tol_abs=10^-8 pois y esperado ~10^-4'."
                                  ],
                                  "verification": "Proponha tol_abs para 2 cenários dados e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação IEEE 754, calculadora científica.",
                                  "tips": "Comece com tol_abs = 10^-10 e ajuste se necessário.",
                                  "learningObjective": "Selecionar tol_abs apropriado com justificativa.",
                                  "commonMistakes": "Escolher tol_abs muito pequeno, causando loops infinitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar tol_abs em um Algoritmo de Análise Numérica",
                                  "subSteps": [
                                    "Implemente critério de parada em método simples (ex: bissecção).",
                                    "Adicione tol_abs: while |x_new - x_old| >= tol_abs.",
                                    "Teste com y pequeno e compare com tol_rel apenas.",
                                    "Analise resultados: número de iterações e precisão final.",
                                    "Refatore para usar híbrido: min(tol_abs, tol_rel * |y|)."
                                  ],
                                  "verification": "Código funcional com tol_abs que converge corretamente em caso y pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/MATLAB, editor de código.",
                                  "tips": "Use print statements para monitorar |erro| durante iterações.",
                                  "learningObjective": "Implementar tol_abs em controle de tolerância.",
                                  "commonMistakes": "Esquecer de checar tol_abs em conjunto com outras condições."
                                }
                              ],
                              "practicalExample": "Ao resolver numericamente a equação x^2 - 10^-8 = 0 (solução x ≈ 10^-4), defina tol_abs = 10^-10. O algoritmo para quando |x_new - x_old| < 10^-10, evitando tol_rel que seria tol*10^-4 ≈ 10^-8, insuficiente para precisão.",
                              "finalVerifications": [
                                "Explicar tol_abs em palavras próprias sem erros.",
                                "Identificar corretamente 3 cenários para tol_abs.",
                                "Propor tol_abs adequado com justificativa numérica.",
                                "Implementar critério de parada híbrido em pseudocódigo.",
                                "Comparar tol_abs vs tol_rel em tabela com exemplos.",
                                "Analisar impacto de tol_abs pequeno em convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de tol_abs (90%).",
                                "Aplicação contextual: seleção correta de uso (80%).",
                                "Escolha quantitativa: valor de tol_abs justificado (85%).",
                                "Implementação prática: código sem bugs (95%).",
                                "Análise crítica: comparação com tol_rel (80%).",
                                "Comunicação clara: explicações concisas e exemplos (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em loops de métodos iterativos (Python/NumPy).",
                                "Física: Simulações de partículas com posições próximas de zero.",
                                "Engenharia: Controle de erro em simulações CFD onde velocidades são mínimas.",
                                "Estatística: Tolerâncias em estimações de parâmetros pequenos."
                              ],
                              "realWorldApplication": "Em simulações financeiras para derivativos com valores nominais pequenos (ex: taxas de juros próximas de zero), tol_abs garante parada precisa sem depender de magnitudes variáveis, evitando erros em portfólios de alta frequência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Definir tolerâncias relativas",
                            "description": "Descrever tol_rel como limite para |erro| / |y + atol|, permitindo precisão proporcional à solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tolerâncias em métodos numéricos",
                                  "subSteps": [
                                    "Revise o que são erros numéricos em aproximações (erro absoluto e relativo).",
                                    "Identifique por que tolerâncias são usadas para controlar a precisão de soluções numéricas.",
                                    "Discuta cenários onde precisão fixa causa problemas (ex: soluções muito pequenas ou grandes).",
                                    "Leia definições básicas de tol_abs e tol_rel em um livro de análise numérica.",
                                    "Anote exemplos onde tol_rel é preferível."
                                  ],
                                  "verification": "Explique em suas palavras a necessidade de tolerâncias e liste 2 cenários para tol_rel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno e caneta",
                                  "tips": "Comece com exemplos simples como soma de séries para visualizar erros.",
                                  "learningObjective": "Entender o papel das tolerâncias no controle de precisão numérica.",
                                  "commonMistakes": "Confundir erro absoluto com relativo desde o início."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar tolerância absoluta e relativa",
                                  "subSteps": [
                                    "Defina tol_abs: limite para |erro| ≤ tol_abs.",
                                    "Defina tol_rel: limite para |erro| / |y + atol| ≤ tol_rel, onde y é a solução aproximada.",
                                    "Compare: tol_abs é fixa, tol_rel é proporcional ao tamanho de y.",
                                    "Calcule exemplos numéricos: para y=1e-10, tol_abs=1e-6 vs tol_rel=1e-6.",
                                    "Desenhe um gráfico comparando os dois em escalas diferentes."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 3 exemplos numéricos mostrando diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou papel quadriculado",
                                  "tips": "Use notação científica para lidar com números muito pequenos/grandes.",
                                  "learningObjective": "Distinguir e comparar tol_abs e tol_rel em contextos práticos.",
                                  "commonMistakes": "Ignorar o termo 'atol' na normalização de tol_rel."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a definição matemática de tol_rel",
                                  "subSteps": [
                                    "Estude a fórmula: critério de parada quando |erro| / |y + atol| ≤ tol_rel.",
                                    "Explique cada componente: erro (diferença entre iterações), y (solução atual), atol (tolerância absoluta mínima).",
                                    "Derive por que adicionar atol evita divisão por zero ou problemas em y≈0.",
                                    "Implemente a verificação em pseudocódigo para um método iterativo (ex: Newton-Raphson).",
                                    "Teste com valores: tol_rel=1e-8, atol=1e-12."
                                  ],
                                  "verification": "Escreva o pseudocódigo completo e teste com um exemplo manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto para pseudocódigo, calculadora",
                                  "tips": "Sempre inclua atol para robustez, mesmo em problemas sem y=0.",
                                  "learningObjective": "Formular e aplicar a definição exata de tol_rel.",
                                  "commonMistakes": "Esquecer atol, levando a divisões instáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar tol_rel em um exemplo de método numérico",
                                  "subSteps": [
                                    "Escolha um método simples: bissecção para encontrar raiz de f(x)=e^x - 3x^2.",
                                    "Implemente o loop com critério tol_rel=1e-6, atol=1e-12.",
                                    "Registre iterações até convergência e calcule tol_rel em cada passo.",
                                    "Compare resultados com tol_abs equivalente e analise precisão.",
                                    "Ajuste tol_rel e observe impacto no número de iterações."
                                  ],
                                  "verification": "Produza tabela de iterações mostrando tol_rel calculada e convergência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python ou MATLAB (opcional), papel para cálculo manual",
                                  "tips": "Comece manualmente para 5 iterações antes de codificar.",
                                  "learningObjective": "Implementar tol_rel em um algoritmo numérico real.",
                                  "commonMistakes": "Parar prematuramente sem verificar a fórmula completa."
                                }
                              ],
                              "practicalExample": "Em um solver de EDOs (equações diferenciais ordinárias), ao integrar y' = -y com y(0)=1, use tol_rel=1e-8 para controlar o passo h, garantindo que o erro local seja proporcional à solução y, evitando passos muito pequenos quando y decai para valores próximos de zero.",
                              "finalVerifications": [
                                "Explique tol_rel sem consultar notas.",
                                "Calcule tol_rel para y=1e-5, erro=1e-10, atol=1e-12.",
                                "Identifique quando tol_rel é melhor que tol_abs em um exemplo.",
                                "Implemente critério em pseudocódigo para método de Euler.",
                                "Compare convergência com tol_abs em um teste numérico.",
                                "Discuta impacto de atol baixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição da fórmula tol_rel (incluindo atol).",
                                "Correta diferenciação entre tol_abs e tol_rel com exemplos.",
                                "Implementação correta em algoritmo com tabela de iterações.",
                                "Análise qualitativa de vantagens da tol_rel.",
                                "Identificação de erros comuns e soluções.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em bibliotecas como SciPy (odeint com rtol).",
                                "Física: Controle de precisão em simulações de dinâmica molecular.",
                                "Engenharia: Otimização em controle de sistemas com solvers numéricos.",
                                "Estatística: Análise de erros em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em softwares de simulação como MATLAB ou ANSYS, tol_rel garante precisão adaptativa em modelos de engenharia, como previsão de falhas estruturais, onde soluções variam em magnitude, evitando desperdício computacional ou imprecisões em regiões críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Combinar tolerâncias relativas e absolutas",
                            "description": "Mostrar critérios mistos como max(tol_rel * |y|, tol_abs) para controle robusto em controle de passo, evitando problemas em singularidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Tolerâncias Relativas e Absolutas",
                                  "subSteps": [
                                    "Defina tolerância absoluta (tol_abs): critério |erro| < tol_abs.",
                                    "Defina tolerância relativa (tol_rel): critério |erro| / |y| < tol_rel.",
                                    "Discuta limitações: tol_abs falha perto de zero; tol_rel falha em singularidades grandes.",
                                    "Calcule exemplos numéricos simples para cada tipo.",
                                    "Compare comportamentos em valores y próximos de zero e grandes."
                                  ],
                                  "verification": "Resolva 3 exercícios manuais e confirme que os critérios são aplicados corretamente sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, calculadora; notas de aula sobre análise numérica.",
                                  "tips": "Use tabelas para comparar tol_abs vs tol_rel em diferentes escalas de y.",
                                  "learningObjective": "Compreender as diferenças fundamentais e limitações individuais de cada tolerância.",
                                  "commonMistakes": "Confundir tol_rel com divisão por erro absoluto; ignorar normalização em tol_rel."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Problemas em Singularidades e Regiões Críticas",
                                  "subSteps": [
                                    "Analise singularidades: onde |y| → 0 ou |y| → ∞ em soluções de EDOs.",
                                    "Simule controle de passo com tol_abs pura: observe passos excessivos perto de zero.",
                                    "Simule com tol_rel pura: observe passos muito pequenos em regiões de alto gradiente.",
                                    "Registre métricas: número de passos, tempo computacional, precisão.",
                                    "Discuta necessidade de critério híbrido para robustez."
                                  ],
                                  "verification": "Gere gráficos de passos vs h (passo) para ambos critérios e identifique falhas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com solver ODE simples (ex: scipy.integrate); funções teste como 1/x.",
                                  "tips": "Escolha funções com singularidades conhecidas, como y' = -y^2 com y(0)=1.",
                                  "learningObjective": "Reconhecer cenários onde tolerâncias puras falham em controle de passo adaptativo.",
                                  "commonMistakes": "Usar tolerâncias fixas sem escalar com norma de y; ignorar custo computacional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Implementar Critério Misto Combinado",
                                  "subSteps": [
                                    "Introduza fórmula mista: tol_mista = max(tol_rel * |y|, tol_abs).",
                                    "Explique racional: captura o pior caso, robusto em zero e singularidades.",
                                    "Implemente em pseudocódigo para verificador de erro em Runge-Kutta.",
                                    "Ajuste parâmetros: tol_rel=1e-6, tol_abs=1e-12 tipicamente.",
                                    "Teste em código com função singular."
                                  ],
                                  "verification": "Execute código e confirme que tol_mista alterna corretamente entre modos rel/abs.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Editor de código (Python/Jupyter); bibliotecas numéricas (numpy, scipy).",
                                  "tips": "Vectorize para soluções vetoriais: max(tol_rel * |y|, tol_abs) elemento-sabio.",
                                  "learningObjective": "Formular e codificar critério híbrido para controle de tolerância local.",
                                  "commonMistakes": "Usar min em vez de max; esquecer normalização por norma de y em vetores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Controle de Passo e Avaliar Robustez",
                                  "subSteps": [
                                    "Integre tol_mista no algoritmo de controle de passo (ex: Dormand-Prince).",
                                    "Resolva EDO completa com singularidade e compare com critérios puros.",
                                    "Meça eficiência: passos totais, erro global, tempo.",
                                    "Ajuste tol_rel/tol_abs para otimização.",
                                    "Documente resultados em relatório curto."
                                  ],
                                  "verification": "Compare soluções numéricas com analítica/exata; erro < 1e-5 globalmente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código do Step 3; EDOs teste (ex: y' = 1/y perto de singularidade).",
                                  "tips": "Monitore rejeições de passo; mire <20% para eficiência.",
                                  "learningObjective": "Implementar e validar controle robusto usando tolerâncias combinadas.",
                                  "commonMistakes": "Não escalar h baseado em erro estimado; fixar h sem adaptação."
                                }
                              ],
                              "practicalExample": "Em um solver adaptativo para y' = -1/y^2 (singular em y=0), use tol_rel=1e-3, tol_abs=1e-8. Perto de y=0.01, tol_mista ≈ max(1e-3*0.01, 1e-8)=1e-5 (dominado por rel), evitando passos minúsculos; em y grande, domina abs para estabilidade.",
                              "finalVerifications": [
                                "Critério misto aplicado corretamente em código sem bugs.",
                                "Simulações mostram redução de passos rejeitados >30% vs puros.",
                                "Solução converge para solução exata em teste benchmark.",
                                "Relatório inclui gráficos de h vs t e erro vs t.",
                                "Parâmetros tol_rel/tol_abs justificados numericamente.",
                                "Testado em pelo menos 2 EDOs diferentes com singularidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática do critério misto (100% correto).",
                                "Implementação funcional e eficiente em código (roda sem erros, <5s por teste).",
                                "Análise comparativa mostra robustez (gráficos claros).",
                                "Explicação verbal cobre limitações e escolhas de parâmetros.",
                                "Criatividade em testes adicionais (ex: vetores, stiff problems).",
                                "Relatório estruturado com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para análise numérica.",
                                "Física/Engenharia: Simulações de trajetórias com singularidades (ex: colisões).",
                                "Estatística: Controle de erro em Monte Carlo para integrais singulares.",
                                "Ciência da Computação: Otimização adaptativa em solvers de otimização."
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ODE45 ou NASA solvers para dinâmica orbital, onde singularidades em periélio exigem controle robusto de tolerâncias para precisão sem explosão computacional."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Implementação em Métodos de Passo Variável",
                    "description": "Aplicação prática em métodos Runge-Kutta ou multistep com passo adaptativo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Métodos Runge-Kutta com Passo Variável",
                        "description": "Implementação prática de métodos Runge-Kutta embedded, como o RK45 (Dormand-Prince), para controle adaptativo de passo baseado em estimativa de erro local.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Entender o algoritmo embedded Runge-Kutta",
                            "description": "Compreender a estrutura de métodos Runge-Kutta com dois estimadores de ordem (alta e baixa) para calcular o erro local e decidir a adaptação do passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos Runge-Kutta",
                                  "subSteps": [
                                    "Estudar a forma geral do método Runge-Kutta de ordem p, incluindo os estágios intermediários k_i.",
                                    "Analisar o tableau de Butcher para métodos explícitos e implícitos.",
                                    "Resolver manualmente um exemplo simples com RK4 para uma EDO linear como y' = -y.",
                                    "Identificar como os coeficientes a_ij, b_i e c_i definem a ordem do método.",
                                    "Comparar precisão local e global dos métodos RK."
                                  ],
                                  "verification": "Derivar corretamente os valores de k1 a k4 para uma EDO dada e calcular o próximo passo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e calculadora ou software como Python/Octave",
                                    "Notas de aula sobre EDOs"
                                  ],
                                  "tips": "Desenhe o tableau de Butcher para visualizar as dependências entre estágios.",
                                  "learningObjective": "Compreender a estrutura algébrica base dos métodos RK necessária para embedded variants.",
                                  "commonMistakes": [
                                    "Confundir ordem de precisão local com global",
                                    "Ignorar a soma dos pesos b_i que deve ser 1 para consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Métodos Embedded Runge-Kutta",
                                  "subSteps": [
                                    "Aprender que métodos embedded computam duas aproximações simultâneas: ordem alta (p) e baixa (p-1) usando os mesmos estágios.",
                                    "Estudar o tableau de Butcher expandido com duas linhas de pesos b_i^(p) e b_i^(p-1).",
                                    "Identificar métodos comuns como Dormand-Prince (RK45).",
                                    "Examinar como os coeficientes são projetados para minimizar o erro principal.",
                                    "Calcular os k_i compartilhados para um tableau simples."
                                  ],
                                  "verification": "Montar o tableau embedded para RK45 e listar os pesos diferenciais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de solvers ODE (MATLAB ode45)",
                                    "Software para plotar tableaus (ex: Python com sympy)",
                                    "Referências online sobre Butcher tableaus"
                                  ],
                                  "tips": "Lembre-se: os estágios k_i são os mesmos, só os pesos finais diferem.",
                                  "learningObjective": "Dominar a representação dual-ordem que permite estimativa de erro sem custo extra.",
                                  "commonMistakes": [
                                    "Assumir que todos os coeficientes são idênticos nas duas ordens",
                                    "Não notar que o método de ordem baixa é usado só para erro, não para avanço"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro Local no Algoritmo Embedded",
                                  "subSteps": [
                                    "Definir o erro local como |y_{n+1}^p - y_{n+1}^{p-1}|.",
                                    "Implementar a fórmula escalada: err = |y_high - y_low| / tol, ajustando por norma.",
                                    "Analisar como o erro local estima o erro global aproximado.",
                                    "Testar com uma EDO de teste como y' = y(1-y), y(0)=0.5.",
                                    "Discutir controle de tolerância absoluta vs relativa."
                                  ],
                                  "verification": "Computar erro local para um passo dado em uma EDO e decidir se h é aceitável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou MATLAB para simulação numérica",
                                    "Exemplos de EDOs não-lineares",
                                    "Gráficos de soluções exatas vs numéricas"
                                  ],
                                  "tips": "Use norma máxima ou RMS para erros vetoriais em sistemas.",
                                  "learningObjective": "Aplicar a estimativa de erro embedded para controle adaptativo.",
                                  "commonMistakes": [
                                    "Usar erro bruto sem escalonamento por tolerância",
                                    "Confundir erro local com truncamento global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o Algoritmo de Adaptação de Passo",
                                  "subSteps": [
                                    "Descrever o loop principal: calcular k_i, y_high, y_low, err.",
                                    "Definir regras de aceitação/rejeição: se err < 1, aceitar y_high e propor h_new = h * (tol/err)^{1/(p+1)}.",
                                    "Se err > 1, rejeitar e reduzir h = h * 0.8 * (tol/err)^{1/(p+1)}.",
                                    "Incluir limites de segurança (0.2 < fator < 5) e contadores de rejeição.",
                                    "Simular um passo completo com adaptação."
                                  ],
                                  "verification": "Executar o algoritmo manualmente para 2-3 passos e verificar convergência.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código template em Python para RK embedded",
                                    "Ferramentas de debugging numérico",
                                    "Benchmark com soluções exatas"
                                  ],
                                  "tips": "Inicie com h pequeno e monitore rejeições para tuning.",
                                  "learningObjective": "Integrar todos os componentes em um algoritmo funcional de passo variável.",
                                  "commonMistakes": [
                                    "Exponte errado no fator de adaptação (deve ser 1/(p+1))",
                                    "Não aplicar fator de segurança para oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar o Algoritmo Completo",
                                  "subSteps": [
                                    "Implementar o algoritmo full em código para uma EDO stiff.",
                                    "Comparar eficiência (passos totais) com RK fixo.",
                                    "Analisar logs de h, err e rejeições.",
                                    "Testar sensibilidade a tolerâncias diferentes.",
                                    "Documentar vantagens em problemas reais."
                                  ],
                                  "verification": "Gerar relatório com gráficos de h vs t e erro acumulado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas como SciPy odeint para comparação",
                                    "Jupyter Notebook para visualizações"
                                  ],
                                  "tips": "Use problemas Lotka-Volterra para demonstrar adaptação.",
                                  "learningObjective": "Avaliar performance prática do embedded RK.",
                                  "commonMistakes": [
                                    "Ignorar overhead computacional dos estágios extras",
                                    "Sobreestimar estabilidade sem testes stiff"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva a EDO y' = -2y + sin(t), y(0)=1 no intervalo [0,10] usando RK45 embedded com tol=1e-6. Observe como h aumenta em regiões suaves e diminui perto de oscilações, plotando h(t) e solução vs exata.",
                              "finalVerifications": [
                                "Explicar verbalmente como o tableau embedded economiza computação.",
                                "Calcular manualmente y_high e y_low para o primeiro passo de uma EDO dada.",
                                "Implementar pseudocódigo do algoritmo de adaptação.",
                                "Identificar quando rejeitar um passo e propor novo h.",
                                "Comparar com método fixo em termos de passos necessários.",
                                "Analisar um gráfico de adaptação de h em uma simulação.",
                                "Discutir limitações em problemas muito stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do erro local (erro <5%).",
                                "Correção do fator de adaptação de passo (fórmula exata).",
                                "Eficiência demonstrada: <20% mais passos que solvers padrão.",
                                "Clareza na explicação do tableau Butcher embedded.",
                                "Capacidade de debug de rejeições excessivas.",
                                "Análise qualitativa de convergência ordem p.",
                                "Integração correta de tolerâncias rel/abs."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em Python/SciPy ou MATLAB.",
                                "Física Computacional: Simulações de órbitas planetárias com adaptação automática.",
                                "Engenharia de Controle: Modelagem de sistemas dinâmicos stiff.",
                                "Estatística Computacional: Integração MCMC com passos adaptativos.",
                                "Ciência de Dados: Otimização de solvers para big data numérico."
                              ],
                              "realWorldApplication": "Amplamente usado em solvers como MATLAB ode45, SciPy solve_ivp para simulações precisas e eficientes em engenharia aeroespacial (tra jetórias de foguetes), modelagem climática (EDOs atmosféricas) e biologia computacional (reações químicas stiff), onde adaptação automática equilibra precisão e velocidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Implementar estimativa de erro e controle de passo",
                            "description": "Desenvolver o pseudocódigo para calcular o erro local usando a diferença entre soluções de ordem k e k-1, e ajustar o passo h novo com base em tolerância tol (h_new = h * (tol/err)^(1/(2k-1))).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de erro local em métodos Runge-Kutta de ordem variável",
                                  "subSteps": [
                                    "Revise a estrutura do método Runge-Kutta de ordem k e k-1 para estimativa de erro.",
                                    "Identifique que o erro local é aproximado pela diferença |y_k - y_{k-1}|.",
                                    "Estude a fórmula de ajuste de passo: h_new = h * (tol / err)^{1/(2k-1)}.",
                                    "Defina tolerância tol e ordens k para o contexto específico.",
                                    "Anote os critérios de aceitação (err < tol) e rejeição."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando o erro local e a fórmula h_new, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e caneta, notas de aula sobre Runge-Kutta.",
                                  "tips": "Use diagramas de Butcher para visualizar as diferenças entre ordens k e k-1.",
                                  "learningObjective": "Entender a base teórica da estimativa de erro e controle adaptativo de passo.",
                                  "commonMistakes": "Confundir erro local com erro global; ignorar o expoente 1/(2k-1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver pseudocódigo para cálculo do erro local",
                                  "subSteps": [
                                    "Inicie o pseudocódigo com inputs: f, y0, t0, tf, h, tol, k.",
                                    "Implemente computação de y_k e y_{k-1} no mesmo passo h.",
                                    "Calcule err = max(|y_k[i] - y_{k-1}[i]| para cada componente i).",
                                    "Adicione normalização se y for vetorial (ex: norma infinito).",
                                    "Teste logicamente com valores fictícios."
                                  ],
                                  "verification": "Execute pseudocódigo manualmente para um passo simples e confirme err correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto ou papel para pseudocódigo, calculadora.",
                                  "tips": "Estruture como função separada estimate_error(y_k, y_{k-1}).",
                                  "learningObjective": "Implementar precisamente o cálculo da diferença como proxy de erro local.",
                                  "commonMistakes": "Usar soma em vez de máximo para err; esquecer normalização vetorial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o ajuste do passo h_new no pseudocódigo",
                                  "subSteps": [
                                    "Adicione cálculo de h_new = h * (tol / err)^{1/(2k-1)} após err.",
                                    "Inclua segurança: h_new = 0.9 * h_new (fator de amortecimento).",
                                    "Defina limites: h_new min e max para estabilidade.",
                                    "Integre decisão: se err <= tol, aceite y_k e h = h_new; senão rejeite e repita com h_new.",
                                    "Atualize t e y no loop principal."
                                  ],
                                  "verification": "Simule 2-3 iterações com tol=1e-6 e verifique se h ajusta corretamente (aumenta se err pequeno, diminui se grande).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Pseudocódigo do passo anterior, software como Python para protótipo rápido.",
                                  "tips": "Use pow(tol/err, 1.0/(2*k-1)) em código para evitar overflow.",
                                  "learningObjective": "Dominar o algoritmo de controle adaptativo de passo variável.",
                                  "commonMistakes": "Erro no expoente (usar 1/k em vez de 1/(2k-1)); h_new negativo por err=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar o pseudocódigo completo do método",
                                  "subSteps": [
                                    "Monte o loop while t < tf: compute err, adjust h, accept/reject.",
                                    "Adicione saída de resultados: t, y, h usado por passo.",
                                    "Teste com EDO simples y' = -y, y(0)=1, tf=1.",
                                    "Compare com solução exata exp(-t) para validar precisão.",
                                    "Debugue casos de rejeição excessiva ajustando fatores."
                                  ],
                                  "verification": "O método converge com erro global < tol e h adaptativo (varia entre 0.01 e 0.1).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB com scipy para comparação, pseudocódigo completo.",
                                  "tips": "Registre histórico de h e err para plotar eficiência.",
                                  "learningObjective": "Construir e validar um solver Runge-Kutta adaptativo funcional.",
                                  "commonMistakes": "Loop infinito por h->0; não tratar singularidades em f."
                                }
                              ],
                              "practicalExample": "Para y' = y*(1-y), y(0)=0.5 (modelo logístico), use RK4 (k=4) e RK3 (k-1=3), tol=1e-5. No primeiro passo h=0.1, compute y4≈0.525, y3≈0.524, err=0.001 < tol, h_new≈0.12 (aceito). Próximo passo err=0.0005, h_new≈0.15, demonstrando adaptação.",
                              "finalVerifications": [
                                "Pseudocódigo calcula err corretamente como |y_k - y_{k-1}|.",
                                "h_new ajusta monotonicamente: cresce se err < tol, diminui se > tol.",
                                "Loop aceita/rejeita passos corretamente sem loop infinito.",
                                "Erro global final < tol em teste com solução conhecida.",
                                "Número de passos reduzido vs. h fixo (eficiência >20%).",
                                "h respeita limites min/max definidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula h_new (expoente exato 1/(2k-1)).",
                                "Correta implementação de err (diferença máxima/normalizada).",
                                "Lógica de aceitação/rejeição sem falhas.",
                                "Estrutura modular do pseudocódigo (funções separadas).",
                                "Validação numérica com exemplo converge ao tol.",
                                "Comentários claros explicando cada seção."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python (loops, funções, vetores).",
                                "Física: Simulações dinâmicas (ex: movimento orbital com passo adaptativo).",
                                "Engenharia: Controle de sistemas (ODEs em automação).",
                                "Estatística: Análise de erro e precisão numérica."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA usa RK adaptativo para órbitas precisas), previsão meteorológica (modelos ODEs com passos variáveis para eficiência computacional) e farmacocinética (ajuste de doses via soluções precisas de equações diferenciais)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Codificar método RK45 em Python",
                            "description": "Escrever um programa em Python para resolver EDOs com método RK45 adaptativo, incluindo parâmetros de tolerância, fator de segurança e limites para aumento/redução de passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e revisar coeficientes do método RK45",
                                  "subSteps": [
                                    "Estude o tableau de Butcher para o método Dormand-Prince RK45(4), listando os vetores c, a (matriz), b5 (para ordem 5) e b4 (para ordem 4).",
                                    "Instale bibliotecas necessárias: numpy para operações vetoriais e matplotlib para visualização.",
                                    "Crie um script Python ou notebook Jupyter com a função modelo de teste: def f(t, y): return -y (decaimento exponencial).",
                                    "Defina constantes globais para tolerância (tol=1e-6), fator de segurança (fac=0.9), limites de passo (h_min=1e-10, h_max=0.1).",
                                    "Escreva um esqueleto da função principal rk45_solve(t0, y0, tf, f, tol=1e-6)."
                                  ],
                                  "verification": "Coeficientes RK45 corretamente definidos em arrays numpy e ambiente testado com importações sem erros.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Documentação do método RK45 (Wikipedia ou livro de análise numérica)",
                                    "Python 3+ com numpy e matplotlib instalados",
                                    "Notebook Jupyter para experimentação"
                                  ],
                                  "tips": "Copie os coeficientes exatos de uma fonte confiável para evitar erros de transcrição.",
                                  "learningObjective": "Compreender a estrutura algébrica do RK45 e preparar o setup computacional.",
                                  "commonMistakes": [
                                    "Usar coeficientes errados para RK4 em vez de RK45.",
                                    "Esquecer de importar numpy as np."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo de um passo fixo RK45",
                                  "subSteps": [
                                    "Defina a função rk45_step(t, y, h, f) que calcula os estágios k1 a k7 usando os coeficientes.",
                                    "Implemente k1 = f(t, y), k2 = f(t + c2*h, y + a21*k1*h), e assim por diante até k7.",
                                    "Calcule o candidato de ordem 5: y5 = y + h * (b51*k1 + b52*k2 + ... + b57*k7).",
                                    "Calcule o candidato de ordem 4: y4 = y + h * (b41*k1 + ... + b47*k7).",
                                    "Retorne y5, y4 e o erro local estimado: err = |y5 - y4| / max(1, |y5|)."
                                  ],
                                  "verification": "Teste com h fixo em exemplo simples: solução deve aproximar y(t) = exp(-t).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Coeficientes RK45 em tabela impressa",
                                    "Código de teste com solução exata conhecida"
                                  ],
                                  "tips": "Use loops vetorizados com numpy para eficiência em sistemas de EDOs.",
                                  "learningObjective": "Dominar o algoritmo de um passo embedded RK45 para estimativa de erro local.",
                                  "commonMistakes": [
                                    "Erro na indexação da matriz a (lembre que é lower triangular).",
                                    "Não escalar o erro corretamente com norma."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o controle adaptativo de passo",
                                  "subSteps": [
                                    "Na função rk45_step, após calcular err, compare com tol: se err < tol, aceite y5.",
                                    "Calcule fator de ajuste: r = tol / err, h_new = h * fac * r**0.2 (com clamps facmin <= r <= facmax).",
                                    "Se rejeitado (err >= tol), repita com h_new reduzido; limite rejeições consecutivas a 10.",
                                    "Registre histórico de h, t, y para depuração.",
                                    "Integre ao loop principal: while t < tf, avance t += h_new, y = y5 aceito."
                                  ],
                                  "verification": "Simule com tol variando: h deve diminuir quando err alto e aumentar quando baixo.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Pseudocódigo de controle de passo de livros como Hairer et al.",
                                    "Debugger do IDE (VSCode/PyCharm)"
                                  ],
                                  "tips": "Use print ou logging para monitorar aceitações/rejeições e evolução de h.",
                                  "learningObjective": "Implementar passo variável robusto baseado em estimativa de erro local.",
                                  "commonMistakes": [
                                    "Exponte errado no ajuste (é 1/(p+1) onde p=4 para ordem 4).",
                                    "Não clamp h_new, causando overflow/underflow."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar a função principal e adicionar tratamento de eventos",
                                  "subSteps": [
                                    "Implemente condições de parada: t >= tf ou h < h_min (falha).",
                                    "Adicione suporte a sistemas vetoriais: y como array numpy.",
                                    "Inclua interpolação densa opcional para saída suave (simplificada).",
                                    "Adicione parâmetros opcionais: rtol, atol, max_steps=1000.",
                                    "Retorne dicionário com t_history, y_history, h_history."
                                  ],
                                  "verification": "Execute full solve e plote y vs t, comparando com solução exata exp(-t).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Exemplos de scipy.integrate.solve_ivp para benchmark"
                                  ],
                                  "tips": "Vetorize f para múltiplas EDOs desde o início.",
                                  "learningObjective": "Criar uma solver completa e reutilizável para IVPs.",
                                  "commonMistakes": [
                                    "Loop infinito sem max_steps.",
                                    "Ignorar eventos como singularidades em f."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, validar e otimizar o código",
                                  "subSteps": [
                                    "Teste com múltiplos problemas: oscilador harmônico rígido, Van der Pol.",
                                    "Compare erro global vs solução exata ou scipy para tol=1e-3 a 1e-9.",
                                    "Analise eficiência: número de passos vs precisão.",
                                    "Otimize: evite recálculos desnecessários nos k's rejeitados.",
                                    "Documente código com docstrings e comentários."
                                  ],
                                  "verification": "Erros < tol * 10 e h adapta corretamente em plots.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Soluções exatas conhecidas",
                                    "Scipy.integrate para validação"
                                  ],
                                  "tips": "Use assert para testes unitários em passos individuais.",
                                  "learningObjective": "Garantir robustez e precisão da implementação RK45.",
                                  "commonMistakes": [
                                    "Não testar com sistemas não-lineares.",
                                    "Ignorar overhead de rejeições excessivas."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o sistema de Lorenz (caos): dx/dt = sigma*(y-x), dy/dt = x*(rho-z)-y, dz/dt = x*y - beta*z, com x0=[1,1,1], sigma=10, rho=28, beta=8/3, t de 0 a 40. Plote trajetórias 3D e verifique atrator.",
                              "finalVerifications": [
                                "O código resolve o exemplo de decaimento com erro global < 1e-5 para tol=1e-6.",
                                "Passo h varia dinamicamente: diminui em regiões íngremes, aumenta em suaves.",
                                "Número de passos é razoável (<1000 para intervalos típicos).",
                                "Funciona para sistemas escalares e vetoriais sem modificações.",
                                "Rejeições são raras (<10% dos passos) em problemas suaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes Butcher (verificação exata).",
                                "Correta estimativa e uso do erro local para adaptação.",
                                "Robustez: lida com rejeições, limites de h e max_steps.",
                                "Eficiência: ordem de convergência ~4-5 em testes de precisão vs passos.",
                                "Clareza e documentação do código (docstrings, comentários)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Uso avançado de NumPy para álgebra linear.",
                                "Física Computacional: Simulação de dinâmica em mecânica/orbitais.",
                                "Engenharia: Controle de sistemas e simulações CFD.",
                                "Estatística: Análise de erro e Monte Carlo em propagação de incertezas.",
                                "Ciência de Dados: Integração em pipelines de ML para séries temporais."
                              ],
                              "realWorldApplication": "Simulações em engenharia aeroespacial para trajetórias de foguetes, modelagem epidemiológica (SIR com passo adaptativo para surtos), previsão climática (EDOs atmosféricas), circuitos elétricos não-lineares e farmacocinética em medicina."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Métodos Multistep com Passo Variável",
                        "description": "Aplicação de métodos multistep lineares, como Adams-Bashforth-Moulton (ABM), com estratégias de mudança de passo para manter precisão e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Compreender predictor-corrector em multistep",
                            "description": "Explicar o uso do predictor Adams-Bashforth e corrector Adams-Moulton para estimar erro e adaptar o passo em métodos de passo variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos Multistep Adams-Bashforth e Adams-Moulton",
                                  "subSteps": [
                                    "Estudar a fórmula geral do método Adams-Bashforth de ordem k: y_{n+1}^P = y_n + h \frac{k}{k!} f(t_n + \theta h, y_n + \theta (y_{n+1}^P - y_n)) para predictor.",
                                    "Analisar o método Adams-Moulton de ordem k: y_{n+1}^C = y_n + h \frac{k+1}{(k+1)!} f(t_{n+1}, y_{n+1}^C) para corrector.",
                                    "Comparar explicitamente predictor (explícito) vs. corrector (implícito) em termos de estabilidade e precisão.",
                                    "Derivar coeficientes para ordens comuns (k=2,3) usando polinômios interpoladores.",
                                    "Resolver um EDO simples manualmente com ambos os métodos para um passo fixo."
                                  ],
                                  "verification": "Capacidade de escrever as fórmulas corretas e computar uma iteração manual sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Comece com ordens baixas (k=1 ou 2) para visualizar os coeficientes antes de generalizar.",
                                  "learningObjective": "Compreender as bases matemáticas dos predictors e correctors multistep.",
                                  "commonMistakes": "Confundir os coeficientes de Bashforth (predictor) com Moulton (corrector); ignorar o termo de interpolação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Procedimento Predictor-Corrector",
                                  "subSteps": [
                                    "Descrever o ciclo PECE: Predict (Adams-Bashforth), Evaluate f no predicted, Correct (Adams-Moulton), Evaluate novamente.",
                                    "Explicar iterações adicionais para convergência no corrector até |y^{C,new} - y^{C,old}| < tol.",
                                    "Analisar por que PECE melhora a precisão em comparação a predictor sozinho.",
                                    "Implementar PECE manualmente para 3 passos em uma EDO teste.",
                                    "Discutir convergência: provar que o erro local é O(h^{k+2}) para ordem k."
                                  ],
                                  "verification": "Executar PECE em papel para uma EDO e obter valores consistentes com solução exata.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel quadriculado, software Python/MATLAB para verificação opcional.",
                                  "tips": "Use tolerância pequena (1e-6) nas iterações para simular precisão numérica real.",
                                  "learningObjective": "Dominar o algoritmo predictor-corrector e sua iteração.",
                                  "commonMistakes": "Parar após um Predict-Evaluate sem corrigir adequadamente; não checar convergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar o Erro Local Usando Diferença Predictor-Corrector",
                                  "subSteps": [
                                    "Derivar a estimativa de erro local: |e| ≈ |y^{C} - y^{P}| / (1 - \frac{c_B}{c_M}) onde c são coeficientes líderes.",
                                    "Para ordens comuns, usar |y^C - y^P| como proxy simples para erro.",
                                    "Calcular erro estimado em um exemplo numérico multistep.",
                                    "Comparar com erro real (solução exata ou método de ordem superior).",
                                    "Analisar assimptótica: erro estimado é proporcional ao erro verdadeiro."
                                  ],
                                  "verification": "Computar estimativa de erro em pelo menos dois passos e validar contra exato.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela de coeficientes multistep, EDO com solução conhecida (ex: y'= -y).",
                                  "tips": "Escolha EDOs lineares primeiro para facilitar cálculos manuais.",
                                  "learningObjective": "Saber quantificar erro local via predictor-corrector.",
                                  "commonMistakes": "Usar diferença bruta sem normalizar pelos coeficientes; superestimar em passos iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adaptar o Tamanho do Passo Baseado na Estimação de Erro",
                                  "subSteps": [
                                    "Definir critério: se |e_est| > tol * max(1, |y|), rejeitar passo e reduzir h por fator (ex: 0.5).",
                                    "Se |e_est| < 0.1 tol, aceitar e aumentar h por fator (ex: 1.2).",
                                    "Implementar algoritmo completo de passo variável com PECE e controle de erro.",
                                    "Simular em código ou papel para uma EDO não-linear.",
                                    "Avaliar eficiência: número de passos vs. precisão global."
                                  ],
                                  "verification": "Gerar tabela de passos adaptativos que mantenha erro < tol em toda a integração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, pseudocódigo impresso.",
                                  "tips": "Inclua fator de segurança (0.9) no ajuste de h para evitar oscilações.",
                                  "learningObjective": "Implementar controle de passo variável usando predictor-corrector.",
                                  "commonMistakes": "Aumentar h prematuramente sem checar múltiplos passos; ignorar rejeições em regiões rígidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Refinar a Implementação",
                                  "subSteps": [
                                    "Testar com EDOs de diferentes rigidezes (ex: y'=y^2, y'=sin(t)).",
                                    "Comparar com solver built-in (ex: ode45) em gráfico de solução vs. h.",
                                    "Analisar custo computacional: funções f avaliadas por passo.",
                                    "Documentar ajustes no código para diferentes tolerâncias.",
                                    "Discutir limitações: regiões onde estimativa falha (ex: singularidades)."
                                  ],
                                  "verification": "Gráficos mostram convergência e adaptação correta de h.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter Notebook ou MATLAB script.",
                                  "tips": "Plote log(|e_est|) vs. t para visualizar adaptações.",
                                  "learningObjective": "Validar robustez do método multistep com passo variável.",
                                  "commonMistakes": "Não inicializar com método Runge-Kutta para primeiros passos; overflow em h muito pequeno."
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -2y + sin(t), y(0)=1, de t=0 a 5, com tol=1e-4. Use Adams-Bashforth ordem 3 (predictor) e Adams-Moulton ordem 3 (corrector) em PECE. Inicie com h=0.1 via RK4, estime erro |y^C - y^P|, adapte h se erro > tol: h_new = 0.9 * (tol / |e_est|)^{1/4} * h. Plote solução, h(t) e erro.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel do predictor vs. corrector em 1 minuto.",
                                "Derivar fórmula de erro estimado para ordem 2.",
                                "Implementar PECE com passo variável em código e rodar exemplo sem crashes.",
                                "Identificar quando h é aumentado/reduzido em uma tabela de saída.",
                                "Comparar precisão global com método fixo h=0.1.",
                                "Discutir por que multistep é eficiente para EDOs suaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas multistep (100% correto).",
                                "Correta estimação de erro e fator de adaptação (erro < 20% do real).",
                                "Eficiência: < 2x funções f vs. solver adaptativo padrão.",
                                "Código limpo com comentários e tratamento de erros.",
                                "Análise qualitativa das limitações do método.",
                                "Gráficos claros mostrando adaptação de h."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para solvers ODE.",
                                "Física: Simulações de osciladores amortecidos ou trajetórias.",
                                "Engenharia: Controle de sistemas dinâmicos com passo variável.",
                                "Estatística: Modelagem estocástica com erros controlados."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (previsão numérica do tempo), onde modelos EDOs grandes usam multistep predictor-corrector com passo variável para equilibrar precisão e custo computacional em regiões de alta/baixa variabilidade dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Implementar mudança de ordem e passo",
                            "description": "Desenvolver algoritmo para alterar a ordem do método multistep e o tamanho do passo baseado em estimativas de erro convergência do corrector.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos Multistep e Estimativa de Erro",
                                  "subSteps": [
                                    "Estude a formulação geral de métodos multistep lineares implícitos (ex: Adams-Moulton).",
                                    "Implemente um predictor-corrector básico (Adams-Bashforth + Adams-Moulton) com ordem fixa.",
                                    "Calcule a estimativa de erro local usando a diferença entre predictor e corrector ou fórmulas de erro de ordem p.",
                                    "Implemente convergência do corrector iterando até tolerância epsilon.",
                                    "Teste em uma EDO simples como y' = -y para validar."
                                  ],
                                  "verification": "Execute o código e verifique se o corrector converge para a solução exata em pelo menos 90% dos passos.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden & Faires",
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use tolerância adaptativa (ex: 1e-6) para iterações do corrector e plote resíduos.",
                                  "learningObjective": "Compreender como estimativas de erro do corrector guiam ajustes em métodos multistep.",
                                  "commonMistakes": [
                                    "Ignorar instabilidade em ordens altas",
                                    "Não normalizar erros por h^p",
                                    "Usar predictor sem verificar consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Algoritmo de Mudança de Ordem",
                                  "subSteps": [
                                    "Defina critérios: aumentar ordem se erro < tol * 0.1 (ordem máx 5), diminuir se erro > tol * 10.",
                                    "Implemente coeficientes multistep para ordens variáveis (tabela pré-computada ou função geradora).",
                                    "Ao mudar ordem, recomece histórico com passos recentes ou extrapolação.",
                                    "Teste mudança dinâmica em EDO com solução conhecida.",
                                    "Monitore estabilidade adicionando filtro (não mude ordem em passos consecutivos)."
                                  ],
                                  "verification": "Simule 100 passos e confirme pelo menos 20% das mudanças de ordem ocorrerem corretamente sem divergência.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Código do Step 1",
                                    "Tabela de coeficientes Adams (Wikipedia ou livro)",
                                    "SciPy para soluções exatas"
                                  ],
                                  "tips": "Armazene histórico em deque para eficiência O(1) em shifts.",
                                  "learningObjective": "Criar lógica robusta para adaptação de ordem baseada em erro de convergência.",
                                  "commonMistakes": [
                                    "Mudanças frequentes levando a oscilações",
                                    "Não atualizar coeficientes corretamente",
                                    "Perder histórico ao aumentar ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Controle de Tamanho de Passo",
                                  "subSteps": [
                                    "Estime erro local global como erro local / h * passo total restante.",
                                    "Defina fator de ajuste: h_new = h_old * (tol / erro)^{1/(p+1)} * safety (0.9).",
                                    "Implemente rejeição: se erro > tol, refaça passo com h menor; aceite e avance se ok.",
                                    "Limites: h_min=1e-8, h_max=0.1; rejeite se >2 reduções consecutivas.",
                                    "Integre com mudança de ordem, priorizando erro do corrector mais alto."
                                  ],
                                  "verification": "Plote h vs t e erro vs t; confirme que erro fica dentro de tol em 95% dos passos.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Função odeint do SciPy para benchmark"
                                  ],
                                  "tips": "Use fator de segurança 0.9 para evitar rejeições excessivas.",
                                  "learningObjective": "Dominar ajuste adaptativo de h para eficiência e precisão.",
                                  "commonMistakes": [
                                    "Exponte errada no fator (use 1/(p+1))",
                                    "Não rejeitar passos ruins",
                                    "Ignorar integração com ordem variável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar Algoritmo Completo",
                                  "subSteps": [
                                    "Combine mudança de ordem e h em uma classe SolverMultistepVariavel.",
                                    "Adicione logging de ordem, h, erros por passo.",
                                    "Teste em EDOs não-lineares como y' = y*(1-y), y(0)=0.5.",
                                    "Compare com solvers fixos: meça tempo, passos, erro global L2.",
                                    "Otimize para estabilidade (ex: detecte oscilações e reduza ordem)."
                                  ],
                                  "verification": "Erro global < 1e-4 com 50% menos passos que método fixo.",
                                  "estimatedTime": "5 hours",
                                  "materials": [
                                    "Códigos anteriores",
                                    "Matplotlib para plots comparativos",
                                    "Soluções analíticas ou SciPy"
                                  ],
                                  "tips": "Salve histórico em array para pós-análise.",
                                  "learningObjective": "Construir solver multistep variável funcional e eficiente.",
                                  "commonMistakes": [
                                    "Sobrecarga computacional em mudanças frequentes",
                                    "Não tratar singularidades",
                                    "Falta de normalização de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar com Análise de Sensibilidade",
                                  "subSteps": [
                                    "Varie tolerâncias (1e-3 a 1e-8) e plote eficiência (passos vs precisão).",
                                    "Teste EDOs rígidas (ex: Van der Pol) para checar robustez.",
                                    "Analise impacto de safety factors e limites em rejeições.",
                                    "Implemente checkpointing para problemas longos.",
                                    "Documente código com docstrings e exemplos."
                                  ],
                                  "verification": "Relatório mostrando convergência ótima e zero falhas em 5 EDOs teste.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Todos códigos",
                                    "Jupyter para relatórios interativos"
                                  ],
                                  "tips": "Use logscale em plots de erro para insights.",
                                  "learningObjective": "Avaliar e otimizar algoritmo em cenários reais.",
                                  "commonMistakes": [
                                    "Testes só em EDOs lineares fáceis",
                                    "Ignorar custo de rejeições",
                                    "Não documentar thresholds"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o algoritmo para resolver y' = -2y + sin(t), y(0)=1 no intervalo [0,10]. Use tol=1e-5. Observe como ordem sobe para 4 em regiões suaves e h aumenta para 0.05, enquanto em oscilações iniciais ordem cai para 2 e h para 0.01, mantendo erro global <1e-4 com 150 passos vs 500 fixos.",
                              "finalVerifications": [
                                "O algoritmo ajusta ordem entre 2-5 dinamicamente sem divergência.",
                                "Tamanho de passo varia por fator 0.5-2.0 baseado em erro, com <10% rejeições.",
                                "Erro local fica dentro de tol em 95% dos passos.",
                                "Solução global coincide com referência (L2 <1e-4).",
                                "Tempo de execução <2x método fixo para mesma precisão.",
                                "Logs mostram convergência do corrector em <5 iterações médias."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global L2 < tol * sqrt(T).",
                                "Eficiência: Número de passos < 1.5x otimal fixo.",
                                "Robustez: Sem falhas (divergência/rejeições infinitas) em 5 EDOs teste.",
                                "Adaptatividade: Mudanças de ordem/h ocorrem em >20% dos passos.",
                                "Código: Modular, comentado, com funções reutilizáveis.",
                                "Análise: Plots de h, ordem, erro vs t mostram comportamento esperado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados dinâmicas (deques), otimização numérica.",
                                "Física: Simulações de dinâmica (EDOs em mecânica/orbitais).",
                                "Engenharia: Controle adaptativo em sistemas reais (ex: CFD).",
                                "Estatística: Análise de erro e convergência probabilística."
                              ],
                              "realWorldApplication": "Em modelagem climática, ajusta passos/ordem em simulações de atmosfera para equilibrar precisão em frentes instáveis e eficiência em regiões estáveis, reduzindo tempo de computação em supercomputadores de dias para horas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Simular solução com ABM variável",
                            "description": "Implementar em pseudocódigo ou código a solução de PVI com método ABM de passo variável, gerenciando histórico de passos anteriores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Problema PVI e Inicialização do Método ABM Variável",
                                  "subSteps": [
                                    "Definir a equação diferencial y' = f(t,y) e condições iniciais y(t0)=y0.",
                                    "Escolher a ordem k do método ABM (ex: k=3 ou 4) e tolerância de erro local tol (ex: 1e-6).",
                                    "Implementar integrador inicial (ex: Runge-Kutta ordem 4) para gerar k+1 pontos iniciais com passo h inicial.",
                                    "Inicializar arrays para histórico: t_hist[], y_hist[], f_hist[] para armazenar valores anteriores.",
                                    "Definir coeficientes fixos de ABM para predictor (Adams-Bashforth) e corrector (Adams-Moulton)."
                                  ],
                                  "verification": "Verificar se os k+1 pontos iniciais foram computados corretamente comparando com solução analítica conhecida (se disponível).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de código ou pseudocódigo (ex: Jupyter Notebook, VS Code)",
                                    "Documentação de coeficientes ABM (tabelas de Butcher ou fórmulas)",
                                    "Biblioteca numérica opcional para RK4 (ex: scipy.integrate em Python)"
                                  ],
                                  "tips": [
                                    "Use ordem k=3 para simplicidade inicial; armazene histórico em deque para eficiência O(1) remoção do mais antigo.",
                                    "Sempre normalize passos h para consistência."
                                  ],
                                  "learningObjective": "Configurar corretamente o problema e preparar dados iniciais para método multistep variável.",
                                  "commonMistakes": [
                                    "Esquecer de computar f(t_i, y_i) no histórico inicial.",
                                    "Usar passo h inconsistente na inicialização."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação do Predictor Adams-Bashforth com Passo Variável",
                                  "subSteps": [
                                    "Extrair últimos k valores de t_hist, y_hist, f_hist.",
                                    "Calcular preditor y_p_{n+1} = y_n + h * sum_{j=1}^k β_j * f(t_{n+1-j}, y_{n+1-j}) usando coeficientes β_j para ordem k.",
                                    "Computar f_p = f(t_{n+1}, y_p_{n+1}).",
                                    "Adaptar fórmula para último h variável: ponderar por h_{n+1-j} se passos anteriores diferem."
                                  ],
                                  "verification": "Comparar y_p com valor de Runge-Kutta de um passo para checar implementação básica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Bashforth para ordens 1-5",
                                    "Calculadora simbólica para verificar fórmulas (ex: SymPy)",
                                    "Exemplo numérico manual para teste unitário"
                                  ],
                                  "tips": [
                                    "Implemente função separada ab_predictor(h, t_hist, y_hist, f_hist, k) para reutilização.",
                                    "Teste com passos constantes primeiro para validar."
                                  ],
                                  "learningObjective": "Dominar a extrapolação multistep no predictor com suporte a passos variáveis.",
                                  "commonMistakes": [
                                    "Índices errados no histórico (off-by-one).",
                                    "Não ajustar coeficientes para h variáveis (assumir h constante)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do Corrector Adams-Moulton e Iteração Predictor-Corrector",
                                  "subSteps": [
                                    "Calcular corrector y_c_{n+1} = y_n + h * (β_0 f_p + sum_{j=1}^k γ_j f(t_{n+1-j}, y_{n+1-j})) com coeficientes γ_j.",
                                    "Atualizar f_c = f(t_{n+1}, y_c_{n+1}) e iterar até |y_c - y_p| < tol_pc (ex: 2 iterações fixas).",
                                    "Escolher y_{n+1} = y_c final e f_{n+1} = f_c; adicionar ao histórico.",
                                    "Remover ponto mais antigo do histórico se exceder k+1.",
                                    "Gerenciar truncamento de histórico para passos variáveis via interpolação linear se necessário."
                                  ],
                                  "verification": "Verificar convergência da iteração P-C medindo |y_c^{(m)} - y_c^{(m-1)}| < tol_pc.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Moulton",
                                    "Código do predictor do step anterior",
                                    "Testes unitários com solução exata"
                                  ],
                                  "tips": [
                                    "Use 2-3 iterações P-C suficientes para ABM; evite loop infinito com max_iter.",
                                    "Ponderar corrector implicitamente resolvendo linearmente se ordem alta."
                                  ],
                                  "learningObjective": "Implementar ciclo predictor-corrector robusto para precisão multistep.",
                                  "commonMistakes": [
                                    "Confundir coeficientes β e γ entre predictor/corrector.",
                                    "Não atualizar f_hist corretamente após correção."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Controle de Passo Variável e Simulação Completa",
                                  "subSteps": [
                                    "Estimar erro local e = |y_c - y_p| / (1 - |γ_0| approx).",
                                    "Ajustar h_new = h * (tol / e)^{1/(2k+2)} com segurança 0.9; aceitar se e < tol.",
                                    "Se rejeitar, reduzir h e repetir passo; avançar histórico apenas em aceitação.",
                                    "Loop até t_final, output gráfico y vs t e histórico h.",
                                    "Implementar reinicialização: se ordem muda, refaça pontos iniciais com RK."
                                  ],
                                  "verification": "Plotar solução vs analítica; checar se passos h diminuem em regiões íngremes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca de plotagem (ex: Matplotlib)",
                                    "Solução analítica para benchmark",
                                    "Debugger para histórico"
                                  ],
                                  "tips": [
                                    "Fator de segurança 0.9 evita rejeições excessivas; limite h_min/h_max.",
                                    "Monitore estatísticas: num aceita/rejeita, tempo total."
                                  ],
                                  "learningObjective": "Integrar controle adaptativo para eficiência e precisão em PVI não-lineares.",
                                  "commonMistakes": [
                                    "Fórmula de h_new errada (expoente ou tolerância).",
                                    "Não truncar histórico levando a overflow."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testes, Validação e Otimização Final",
                                  "subSteps": [
                                    "Executar simulação em exemplo benchmark (ex: y'=y, y(0)=1).",
                                    "Comparar com solver built-in (ex: ode45 MATLAB) em norma L2.",
                                    "Analisar eficiência: passos totais vs método fixo h.",
                                    "Otimizar código: vetores NumPy para velocidade.",
                                    "Documentar pseudocódigo final com comentários."
                                  ],
                                  "verification": "Erro global < 1e-4 e passos < 2x método fixo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Solver de referência (scipy.odeint)",
                                    "Ferramentas de profiling"
                                  ],
                                  "tips": [
                                    "Use logs para debug: print h, e a cada 10 passos.",
                                    "Vectorize somas em ABM para performance."
                                  ],
                                  "learningObjective": "Validar implementação completa e refinar para uso prático.",
                                  "commonMistakes": [
                                    "Ignorar reinicialização em h muito pequeno.",
                                    "Comparação errada de soluções (escala de eixo)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -2y + sin(t), y(0)=1 em [0,10], use ABM ordem 4, h_init=0.2, tol=1e-5. Inicialize com RK4 para 5 pontos, simule gerenciando histórico de h variáveis, plote y(t) vs t e evolução de h(t). Solução deve matching aproximado com método explícito de alta ordem.",
                              "finalVerifications": [
                                "Código executa sem erros até t_final.",
                                "Histórico mantém exatamente k+1 pontos válidos sempre.",
                                "Passos h adaptam: diminuem em singularidades, aumentam em suaves.",
                                "Erro local médio < tol em 95% passos.",
                                "Gráfico mostra convergência suave à solução referência."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro global L2 < 1e-4 vs referência.",
                                "Robustez: lida com PVI stiff sem crash (>80% aceitação passos).",
                                "Eficiência: <150 passos para intervalo [0,10] com h_init=0.2.",
                                "Correção algorítmica: predictor/corrector usam coefs exatos.",
                                "Gerenciamento histórico: append/pop correto sem vazamentos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Estruturas de dados dinâmicas (deque/array).",
                                "Física Computacional: Simulações dinâmicas (ex: osciladores).",
                                "Engenharia de Software: Testes unitários e profiling.",
                                "Estatística: Análise de erro e convergência numérica.",
                                "Ciência de Dados: Otimização adaptativa em ML pipelines."
                              ],
                              "realWorldApplication": "Em modelagem climática ou aeroespacial, simula trajetórias/ondas com precisão variável, economizando computação em regiões estáveis e refinando em transientes críticos, como previsão de furacões ou órbitas espaciais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Controle de Estabilidade e Tratamento de Problemas Stiff",
                        "description": "Estratégias para manter estabilidade em métodos de passo variável, especialmente em problemas stiff, integrando controle de passo com análise de estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Analisar estabilidade em passo variável",
                            "description": "Avaliar regiões de estabilidade absoluta e condições para detecção de instabilidade em Runge-Kutta e multistep adaptativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Estabilidade em Métodos Numéricos",
                                  "subSteps": [
                                    "Defina estabilidade absoluta e condicional em esquemas de Runge-Kutta e multistep.",
                                    "Estude o teste de Dahlquist para estabilidade em problemas lineares.",
                                    "Revise o conceito de região de estabilidade no plano complexo.",
                                    "Analise o impacto do passo h na amplificação de erros.",
                                    "Compare estabilidade em métodos explícitos vs. implícitos."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre estabilidade absoluta e condicional, com exemplos de EDOs teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e lápis, software Python com NumPy/Matplotlib.",
                                  "tips": "Use o problema modelo y' = λy para visualizar círculos de estabilidade.",
                                  "learningObjective": "Compreender os conceitos básicos de estabilidade para contextualizar análises avançadas.",
                                  "commonMistakes": "Confundir estabilidade absoluta (independente de h) com condicional (dependente de h)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Regiões de Estabilidade em Runge-Kutta Adaptativos",
                                  "subSteps": [
                                    "Calcule a função de estabilidade R(z) para métodos Runge-Kutta de ordens 2-4.",
                                    "Plote regiões de estabilidade no plano z = hλ usando Butcher tableau.",
                                    "Avalie o efeito de adaptação de passo na amplificação de modos instáveis.",
                                    "Simule uma EDO stiff com Dormand-Prince (RK45) e observe rejeições de passo.",
                                    "Determine condições para h ótimo baseado no raio espectral."
                                  ],
                                  "verification": "Gere e interprete um gráfico da região de estabilidade para RK4, marcando eigenvalues típicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (SciPy odeint/solve_ivp), MATLAB, tabelas de Butcher.",
                                  "tips": "Implemente uma função personalizada para plotar regiões de estabilidade.",
                                  "learningObjective": "Mapear e interpretar regiões de estabilidade específicas de Runge-Kutta adaptativos.",
                                  "commonMistakes": "Ignorar o acoplamento entre ordem e estabilidade em métodos de alto grau."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Estabilidade em Métodos Multistep Adaptativos",
                                  "subSteps": [
                                    "Derive funções de estabilidade ρ(z) e σ(z) para Adams-Bashforth e BDF.",
                                    "Analise regiões de A-stabilidade e L-stabilidade para problemas stiff.",
                                    "Implemente detecção de instabilidade via monitoramento de resíduos locais.",
                                    "Compare desempenho em EDOs com eigenvalues reais negativos grandes.",
                                    "Ajuste critérios de mudança de passo baseados em ordem de consistência."
                                  ],
                                  "verification": "Compare plots de estabilidade para AB3 vs. BDF2, destacando vantagens para stiff.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software Python/MATLAB com implementações multistep, referências como Hairer et al.",
                                  "tips": "Foquem em BDF para stiff; teste com y' = -1000y.",
                                  "learningObjective": "Diferenciar e analisar estabilidade em métodos multistep adaptativos.",
                                  "commonMistakes": "Subestimar oscilações em multistep explícitos para eigenvalues imaginários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Condições para Detecção e Tratamento de Instabilidade",
                                  "subSteps": [
                                    "Defina critérios baseados em truncamento local e global para rejeitar passos.",
                                    "Implemente detecção via normas de solução e derivadas estimadas.",
                                    "Estabeleça thresholds para alternar entre Runge-Kutta e multistep.",
                                    "Teste em problemas stiff como van der Pol com μ grande.",
                                    "Otimize parâmetros de controle de passo para manter estabilidade."
                                  ],
                                  "verification": "Crie um algoritmo que detecta e corrige instabilidade em uma simulação numérica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código fonte de solvers adaptativos (SciPy), exemplos de EDOs stiff.",
                                  "tips": "Monitore ||y_{n+1} - y_n|| / tol como indicador precoce.",
                                  "learningObjective": "Formular condições acionáveis para detectar e mitigar instabilidade.",
                                  "commonMistakes": "Usar tolerâncias fixas sem escalar pelo Lipschitz constante."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Análise e Validar com Exemplos Práticos",
                                  "subSteps": [
                                    "Combine análises de Runge-Kutta e multistep em um framework híbrido.",
                                    "Valide regiões de estabilidade com soluções analíticas de EDOs teste.",
                                    "Avalie sensibilidade a perturbações iniciais e ruído.",
                                    "Documente um relatório com gráficos e conclusões.",
                                    "Discuta limitações em problemas não-lineares."
                                  ],
                                  "verification": "Resolva uma EDO stiff com sucesso, reportando regiões visitadas e detecções.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Todos os materiais anteriores, template de relatório.",
                                  "tips": "Use log-plot para erros vs. h para visualizar instabilidades.",
                                  "learningObjective": "Aplicar integralmente a análise de estabilidade em cenários reais.",
                                  "commonMistakes": "Generalizar resultados de lineares para não-lineares sem linearização."
                                }
                              ],
                              "practicalExample": "Resolva a EDO stiff y' = -1000(y - cos(t)) + sin(t), y(0)=1, no intervalo [0,1], usando RK45 e BDF2 adaptativos. Plote regiões de estabilidade, monitore rejeições de passo e detecte instabilidade quando o erro local excede 10x a tolerância.",
                              "finalVerifications": [
                                "Pode plotar e interpretar regiões de estabilidade para RK e multistep.",
                                "Implementa detecção de instabilidade em código funcional.",
                                "Identifica corretamente condições para problemas stiff.",
                                "Compara desempenho de métodos em EDOs teste.",
                                "Explica impactos de adaptação de passo na estabilidade.",
                                "Valida resultados contra soluções de referência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de funções de estabilidade (90% correto).",
                                "Qualidade dos plots e interpretações (clareza e acurácia).",
                                "Efetividade do algoritmo de detecção (taxa de sucesso >95%).",
                                "Análise de erros comuns e mitigação.",
                                "Integração interdisciplinar em exemplos.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos stiff em dinâmica.",
                                "Computação: Otimização de algoritmos numéricos em HPC.",
                                "Engenharia: Modelagem de circuitos RLC stiff.",
                                "Estatística: Análise de incertezas em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos stiff de oceanos), finanças (equações diferenciais estocásticas), e aeroespacial (trajectories com regimes stiff), garantindo precisão sem explosão numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Implementar detecção de stiff",
                            "description": "Desenvolver critérios para identificar problemas stiff (ex: fracasso repetido em redução de passo) e sugerir troca para métodos implicitamente estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de problemas stiff e critérios de detecção",
                                  "subSteps": [
                                    "Estude definições de problemas stiff: autovalores com partes reais muito negativas e magnitudes díspares.",
                                    "Revise exemplos clássicos como o oscilador de van der Pol com parâmetro μ grande.",
                                    "Identifique sintomas numéricos: reduções repetidas de passo em solvers explícitos devido a rejeições.",
                                    "Analise literatura: leia seções sobre stiff em Hairer et al. 'Solving Ordinary Differential Equations I'.",
                                    "Anote critérios quantitativos: contagem de rejeições consecutivas > threshold (ex: 5-10)."
                                  ],
                                  "verification": "Resuma em um documento os 3 principais critérios de detecção e forneça um exemplo matemático.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Solving ODEs I' de Hairer (cap. IV)",
                                    "Artigos sobre stiff ODEs",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas de autovalores no plano complexo para visualizar stiff regions.",
                                  "learningObjective": "Explicar o que são problemas stiff e listar critérios de detecção baseados em comportamento numérico.",
                                  "commonMistakes": [
                                    "Confundir stiff com oscilatório",
                                    "Ignorar o papel dos autovalores reais negativos",
                                    "Subestimar o impacto em step sizes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar monitoramento de tamanho de passo e rejeições",
                                  "subSteps": [
                                    "Modifique um solver de passo variável existente (ex: Runge-Kutta adaptativo) para logar step size atual e rejeições.",
                                    "Adicione variáveis de estado: contador de rejeições consecutivas (reject_count) e histórico de h (últimos 10 passos).",
                                    "Implemente função log_step(h, accepted, rejected) que atualiza contadores.",
                                    "Teste com problema não-stiff (ex: y' = -y) para validar logging sem detecção falsa.",
                                    "Visualize logs com plots de h vs. tempo para observar padrões."
                                  ],
                                  "verification": "Execute solver em problema teste e confirme que logs capturam reduções de h corretamente via print ou gráfico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base de RK45 em Python (SciPy odeint como referência)",
                                    "NumPy, Matplotlib",
                                    "Problemas teste: y'=-y, y'=y^2"
                                  ],
                                  "tips": "Use deque do collections para histórico eficiente de step sizes.",
                                  "learningObjective": "Implementar logging robusto para rastrear dinâmicas de step size em solvers adaptativos.",
                                  "commonMistakes": [
                                    "Não resetar contador após aceitação de passo",
                                    "Logar apenas h final, ignorando histórico",
                                    "Overflow em contadores sem limites"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver lógica de detecção de stiff com thresholds",
                                  "subSteps": [
                                    "Defina thresholds: max_rejects_consecutive = 8, min_h_reduction_ratio = 0.1 (h atual / h inicial < 0.1).",
                                    "Crie função is_stiff(detected_rejects, h_history): retorne True se rejects > threshold OU ratio < min_ratio.",
                                    "Incorpore análise espectral simples: estime Lipschitz local via Jacobiana numérica se possível.",
                                    "Integre detecção no loop principal do solver: chame is_stiff após cada rejeição.",
                                    "Adicione hysteresis: confirme stiff após 2 detecções consecutivas para evitar falsos positivos."
                                  ],
                                  "verification": "Teste função isolada com dados simulados de rejects e h_history; assert True para stiff simulado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código do Step 2",
                                    "SymPy para Jacobiana simbólica opcional",
                                    "Dados teste: séries de rejects [0,3,5,7,9]"
                                  ],
                                  "tips": "Ajuste thresholds empiricamente com problemas conhecidos stiff/non-stiff.",
                                  "learningObjective": "Criar algoritmo de detecção baseado em métricas observáveis sem análise espectral cara.",
                                  "commonMistakes": [
                                    "Thresholds fixos sem adaptação ao problema",
                                    "Detecção imediata sem confirmação",
                                    "Ignorar contexto inicial de h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar sugestão e switch para métodos implicitamente estáveis",
                                  "subSteps": [
                                    "Defina lista de métodos alternativos: explícito RK -> implícito BDF ou Rosenbrock.",
                                    "Ao detectar stiff, pause solver atual e sugira: print('Stiff detectado! Switch para BDF?') ou auto-switch.",
                                    "Implemente wrapper para trocar solver: use scipy.integrate.solve_ivp com method='BDF'.",
                                    "Salve estado atual (t, y) e reinicie com novo método do ponto de detecção.",
                                    "Adicione flag de recovery: se BDF falhar, fallback para step fixo pequeno."
                                  ],
                                  "verification": "Rode solver completo em problema stiff (van der Pol μ=1000); confirme switch e solução converge.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "SciPy solve_ivp",
                                    "Exemplo stiff: van der Pol y'' - μ(1-y^2)y' + y = 0",
                                    "Código dos Steps anteriores"
                                  ],
                                  "tips": "Teste switch com solve_ivp(method='RK45' then 'BDF') para validar continuidade.",
                                  "learningObjective": "Integrar detecção com adaptação dinâmica de método para estabilidade.",
                                  "commonMistakes": [
                                    "Perda de estado ao switch",
                                    "Não tratar singularidades pós-switch",
                                    "Switch prematuro sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refinar a detecção em cenários variados",
                                  "subSteps": [
                                    "Colete suíte de testes: 3 stiff (vdPol μ=1e3, Robertson chem), 3 non-stiff.",
                                    "Meça métricas: taxa de detecção correta, overhead computacional (<10%).",
                                    "Tune thresholds via grid search minimizando falsos positivos/negativos.",
                                    "Documente casos edge: stiff inicial vs. emergente.",
                                    "Compare performance pré/pós-detecção com plots de erro e tempo."
                                  ],
                                  "verification": "Relatório com tabela: Problema | Detectado? | Tempo | Erro; todos stiff detectados corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Suite de problemas ODE stiff/non-stiff",
                                    "SciPy, Pandas para métricas",
                                    "Jupyter para relatórios"
                                  ],
                                  "tips": "Use unit tests com pytest para is_stiff isolada.",
                                  "learningObjective": "Validar robustez da detecção via testes abrangentes e otimização.",
                                  "commonMistakes": [
                                    "Poucos testes (bias)",
                                    "Ignorar overhead",
                                    "Não documentar falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python um solver RK45 para o problema stiff de van der Pol (μ=1000): y'' = μ(1-y^2)y' - y. Monitore steps; após 7 rejeições consecutivas e h reduzido em >90%, detecte stiff e switch para solve_ivp(method='BDF'). Compare solução: RK falha em t>0.1, BDF succeeds até t=20 com h estável.",
                              "finalVerifications": [
                                "Código detecta stiff em van der Pol μ=1000 após <20 passos rejeitados.",
                                "Não detecta falsamente em y'=-y (non-stiff) em 1000 passos.",
                                "Switch para BDF mantém precisão ||y(t=20) - y_exata|| < 1e-3.",
                                "Overhead de monitoramento <5% do tempo total.",
                                "Logs mostram histórico de h e rejects claramente.",
                                "Função is_stiff retorna True/False corretamente em testes unitários."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção: >95% em suite de 6 problemas.",
                                "Eficiência: tempo total <2x solver vanilla em non-stiff.",
                                "Robustez: lida com edge cases sem crash.",
                                "Clareza do código: comentários em funções chave, modularidade.",
                                "Documentação: README com thresholds e resultados de testes.",
                                "Correção matemática: thresholds baseados em literatura."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados (histórico, contadores), logging/debugging.",
                                "Análise Numérica: Estabilidade de métodos lineares/multipasso.",
                                "Física/Química: Modelos stiff em reações químicas rígidas ou circuitos RC.",
                                "Otimização: Tuning de thresholds via busca empírica.",
                                "Engenharia de Software: Adapters para troca de solvers."
                              ],
                              "realWorldApplication": "Em simulações de cinética química (ex: modelos de combustão com escalas rápidas/lentas), detecção automática permite solvers eficientes sem intervenção manual, reduzindo tempo de simulação de dias para horas em software como COMSOL ou custom CFD codes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Otimizar parâmetros de controle",
                            "description": "Ajustar fatores de segurança, limites de mudança de passo e tolerâncias para equilibrar precisão, eficiência e estabilidade em implementações práticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e compreender os parâmetros de controle chave",
                                  "subSteps": [
                                    "Estude a definição de fator de segurança (tipicamente 0.9-0.5), limites de mudança de passo (ex: fator de aumento 2-4, redução 0.25-0.5) e tolerâncias locais/globais.",
                                    "Analise o impacto teórico de cada parâmetro na precisão (erro local), eficiência (número de passos) e estabilidade (evitar rejeições em problemas stiff).",
                                    "Revise literatura ou documentação de solvers como Dormand-Prince (DOPRI5) para valores padrão.",
                                    "Crie uma tabela resumindo faixas recomendadas e trade-offs esperados.",
                                    "Discuta com exemplos como problemas stiff demandam fatores de segurança menores."
                                  ],
                                  "verification": "Tabela completa de parâmetros com faixas, impactos e referências teóricas criada e compreendida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de solvers numéricos (MATLAB ode45, SciPy solve_ivp)",
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Comece com valores padrão de solvers estabelecidos para benchmark.",
                                  "learningObjective": "Compreender o papel quantitativo de cada parâmetro no equilíbrio precisão-eficiência-estabilidade.",
                                  "commonMistakes": [
                                    "Confundir tolerância local com global",
                                    "Ignorar dependência em problemas stiff",
                                    "Usar valores fora de faixas práticas (ex: fator >1 para redução)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar simulação base com parâmetros iniciais",
                                  "subSteps": [
                                    "Selecione um problema teste: EDO stiff como y' = -50(y - cos(t)) + sin(t), y(0)=1.",
                                    "Implemente um método de passo variável (ex: RK4 adaptativo) em Python/MATLAB com parâmetros padrão (safety=0.9, step_up=4, step_down=0.5, tol=1e-6).",
                                    "Execute simulação e registre métricas: número de passos, rejeições, erro global vs. solução exata.",
                                    "Plote solução, passos adaptados e histórico de h(t).",
                                    "Compare com solver built-in para validar implementação."
                                  ],
                                  "verification": "Código executado com métricas basais registradas e plots gerados, coincidente com solver padrão em 90%+.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com SciPy/NumPy ou MATLAB",
                                    "Exemplo de EDO stiff (Van der Pol ou Robertson)",
                                    "Solução referencial analítica ou de alta precisão"
                                  ],
                                  "tips": "Use logging para capturar rejeições e mudanças de passo automaticamente.",
                                  "learningObjective": "Configurar baseline reprodutível para testes de otimização.",
                                  "commonMistakes": [
                                    "Implementação incorreta do critério de aceitação de passo",
                                    "Escolha de problema não-stiff, mascarando instabilidades",
                                    "Falta de validação contra solver confiável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar otimização iterativa dos parâmetros",
                                  "subSteps": [
                                    "Defina métrica composta: custo = w1*erro_global + w2*N_passos + w3*N_rejeicoes (ex: w1=0.5, w2=0.3, w3=0.2).",
                                    "Varra sistematicamente: safety [0.4,0.5,0.6,0.7,0.9]; step_up/down [2,3,4]/[0.3,0.4,0.5]; tol [1e-5,1e-6,1e-7].",
                                    "Execute grid search ou otimização simples (ex: Nelder-Mead) para minimizar custo.",
                                    "Analise sensibilidade: plote custo vs. cada parâmetro.",
                                    "Ajuste para equilíbrio: priorize estabilidade em stiff (reduza safety se rejeições >10%)."
                                  ],
                                  "verification": "Conjunto otimizado de parâmetros identificado com redução de custo >20% vs. baseline, suportado por tabelas/plots.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código de simulação do Step 2",
                                    "Ferramentas de otimização (SciPy optimize)",
                                    "Planilhas para grid search"
                                  ],
                                  "tips": "Limite grid para evitar explosão computacional; foque em 2-3 problemas teste.",
                                  "learningObjective": "Aplicar análise de sensibilidade para otimização prática.",
                                  "commonMistakes": [
                                    "Métrica de custo desbalanceada (ex: ignorar rejeições)",
                                    "Sobre-otimização para um problema, perdendo generalidade",
                                    "Não testar em múltiplos intervalos de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar configuração otimizada",
                                  "subSteps": [
                                    "Teste parâmetros otimizados em 2-3 EDOs adicionais (stiff e não-stiff).",
                                    "Compare métricas finais vs. baseline e solvers comerciais.",
                                    "Documente configuração final com justificativas e limites de uso.",
                                    "Simule cenários edge: tol muito apertada, h inicial grande.",
                                    "Crie guia de tuning genérico para outros problemas."
                                  ],
                                  "verification": "Relatório com validação cross-problema, documentação e guia criado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Banco de EDOs teste (ex: Internet: DETEST set)",
                                    "Templates de relatório LaTeX/Markdown"
                                  ],
                                  "tips": "Sempre inclua intervalos de confiança nas métricas.",
                                  "learningObjective": "Garantir robustez e generalização da otimização.",
                                  "commonMistakes": [
                                    "Validação só no problema de treino",
                                    "Falta de documentação de trade-offs",
                                    "Ignorar custo computacional em cenários reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver para o problema stiff de Robertson (química: y1' = -0.04y1 + 1e4 y2 y3, etc.), otimize safety=0.6, step_down=0.3, tol=1e-7 para reduzir rejeições de 25% para 5% com erro global <1e-4 e 30% menos passos que padrão.",
                              "finalVerifications": [
                                "Solução converge estável sem crash em problemas stiff",
                                "Número de rejeições <10% do total de tentativas",
                                "Erro global < tolerância alvo em múltiplos testes",
                                "Eficiência melhorada: N_passos reduzido >15% vs. baseline",
                                "Sensibilidade baixa: variação ±10% em params altera custo <5%",
                                "Compatível com solvers padrão em precisão"
                              ],
                              "assessmentCriteria": [
                                "Compreensão teórica demonstrada em tabela de params (80%+ acurácia)",
                                "Código funcional com logging de métricas (sem erros numéricos)",
                                "Otimização quantitativa com redução custo >20%",
                                "Análise de trade-offs explícita em relatório",
                                "Validação cross-problema com plots comparativos",
                                "Guia de tuning prático e generalizável"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Otimização numérica e análise de dados (SciPy, Pandas)",
                                "Engenharia: Controle de sistemas dinâmicos e simulações CFD",
                                "Física/Química: Modelagem de EDOs stiff em reações e mecânica",
                                "Estatística: Análise de sensibilidade e métricas compostas"
                              ],
                              "realWorldApplication": "Em softwares como COMSOL ou ANSYS para simulações de engenharia, onde tuning de params em solvers ODE garante precisão em fluidos viscosos ou reações químicas stiff, reduzindo tempo de computação em 50% sem perda de confiabilidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Estabilidade",
                "description": "Análise da estabilidade dos métodos numéricos aplicados a equações diferenciais ordinárias.",
                "totalSkills": 43,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Análise de Estabilidade Linear",
                    "description": "Estudo da estabilidade através da equação modelo y' = λy e fator de amplificação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Equação Modelo y' = λy",
                        "description": "A equação diferencial ordinária linear y' = λy, onde λ é um número complexo, serve como modelo canônico para analisar a estabilidade local de métodos numéricos para problemas de valor inicial, capturando o comportamento de crescimento ou decaimento da solução exata.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Resolver analiticamente a equação y' = λy",
                            "description": "Derivar e compreender a solução exata y(t) = y(0) * exp(λ t), identificando que para Re(λ) < 0 a solução decai, Re(λ) > 0 cresce, e Im(λ) ≠ 0 introduz oscilações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da equação diferencial y' = λy",
                                  "subSteps": [
                                    "Identifique que se trata de uma equação diferencial linear homogênea de primeira ordem com coeficiente constante λ.",
                                    "Reconheça que λ pode ser complexo: Re(λ) determina crescimento/decaimento, Im(λ) introduz oscilações.",
                                    "Escreva a equação na forma dy/dt = λ y(t), destacando a proporcionalidade direta.",
                                    "Lembre-se do contexto de estabilidade linear em análise numérica.",
                                    "Anote a condição inicial y(0) = y₀."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que essa equação modela sistemas lineares simples e liste os tipos de λ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de EDOs (opcional)"
                                  ],
                                  "tips": "Visualize λ como taxa de crescimento; pense em exemplos reais como juros compostos.",
                                  "learningObjective": "Identificar corretamente a forma da equação e suas implicações qualitativas.",
                                  "commonMistakes": [
                                    "Confundir com equações não lineares",
                                    "Ignorar que λ pode ser complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar separação de variáveis",
                                  "subSteps": [
                                    "Reescreva a equação como dy/y = λ dt.",
                                    "Verifique que y ≠ 0 (solução trivial y=0 é conhecida).",
                                    "Integre ambos os lados intuitivamente antes de formalizar.",
                                    "Prepare para integração: lado esquerdo em y, direito em t.",
                                    "Discuta validade do método para equações separáveis."
                                  ],
                                  "verification": "Mostre a forma separada dy/y = λ dt em um papel.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": "Sempre divida por y primeiro; evite integrar sem separar.",
                                  "learningObjective": "Transformar a EDO em forma integrável via separação de variáveis.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por y",
                                    "Trocar dy e dt"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a integração e obter a solução geral",
                                  "subSteps": [
                                    "Integre o lado esquerdo: ∫(1/y) dy = ln|y| + C₁.",
                                    "Integre o lado direito: ∫ λ dt = λ t + C₂.",
                                    "Combine: ln|y| = λ t + C, onde C = C₂ - C₁.",
                                    "Exponentie ambos os lados: |y| = e^{λ t + C} = e^C e^{λ t}.",
                                    "Defina K = ± e^C (constante arbitrária), obtendo y(t) = K e^{λ t}."
                                  ],
                                  "verification": "Derive y(t) = K exp(λ t) a partir da separada e verifique diferenciando: y' = λ K exp(λ t) = λ y.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de integrais básicas"
                                  ],
                                  "tips": "Use propriedades de expoentes; lembre que exp(λ t) lida com λ complexo via Euler.",
                                  "learningObjective": "Derivar a solução geral exata y(t) = K exp(λ t).",
                                  "commonMistakes": [
                                    "Esquecer o módulo em ln|y|",
                                    "Perder o sinal na constante K"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condição inicial e analisar comportamento",
                                  "subSteps": [
                                    "Substitua t=0: y(0) = K exp(0) = K = y₀.",
                                    "Escreva solução particular: y(t) = y₀ exp(λ t).",
                                    "Analise casos: se Re(λ) < 0, |y(t)| → 0 (decaimento); Re(λ) > 0, cresce; Im(λ) ≠ 0, oscila com envelope exp(Re(λ)t).",
                                    "Esboce gráficos qualitativos para λ real positivo, negativo e complexo.",
                                    "Conclua sobre estabilidade: assintoticamente estável se Re(λ) < 0."
                                  ],
                                  "verification": "Resolva para y(0)=1, λ=-1 (y=exp(-t), decai); λ=i (y=exp(it)=cos t + i sin t, oscila).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para gráficos",
                                    "Software de plotagem como Desmos (opcional)"
                                  ],
                                  "tips": "Para λ complexo, separe em real e imaginário; foque em |exp(λ t)| = exp(Re(λ)t).",
                                  "learningObjective": "Obter solução exata e interpretar estabilidade qualitativamente.",
                                  "commonMistakes": [
                                    "Errar y(0)=K",
                                    "Ignorar parte real para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e generalizar a solução",
                                  "subSteps": [
                                    "Diferencie y(t) = y₀ exp(λ t) e confirme y' = λ y.",
                                    "Discuta unicidade via teorema de Picard-Lindelöf.",
                                    "Generalize para sistemas lineares: autovalores λ determinam comportamento.",
                                    "Resolva numericamente um exemplo simples e compare com exata.",
                                    "Registre insights sobre aproximações numéricas em Análise Numérica."
                                  ],
                                  "verification": "Confirme que a derivada da solução satisfaz a EDO original para um λ dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para verificação numérica"
                                  ],
                                  "tips": "Sempre verifique por diferenciação; isso constrói confiança.",
                                  "learningObjective": "Validar a solução e conectar ao contexto de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Não verificar a EDO",
                                    "Confundir solução geral com particular"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=5. Separação: dy/y = -2 dt → ln|y| = -2t + C → y= K e^{-2t}. Com y(0)=5, y(t)=5 e^{-2t}, que decai para 0 (Re(λ)=-2<0). Para λ=1+i: y(t)=y₀ e^{(1+i)t} = y₀ e^t (cos t + i sin t), cresce com oscilações.",
                              "finalVerifications": [
                                "Derive corretamente y(t) = y(0) exp(λ t) a partir de y' = λ y.",
                                "Interprete estabilidade: Re(λ)<0 → decaimento, Re(λ)>0 → crescimento.",
                                "Descreva efeito de Im(λ)≠0 como oscilações.",
                                "Verifique por diferenciação: y' = λ y₀ exp(λ t).",
                                "Esboce gráfico qualitativo para λ=-1, λ=2, λ= i.",
                                "Explique relevância para métodos numéricos de EDOs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução geral e particular (100% correto).",
                                "Correta análise qualitativa de estabilidade baseada em Re(λ) e Im(λ).",
                                "Verificação explícita por substituição na EDO original.",
                                "Clareza em subpassos de separação e integração.",
                                "Uso apropriado de propriedades exponenciais para λ complexo.",
                                "Conexão com contexto de análise de estabilidade linear."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decaimento radioativo (λ<0) ou movimento harmônico (λ= iω).",
                                "Engenharia: Estabilidade de sistemas de controle lineares.",
                                "Biologia: Modelos de crescimento populacional exponencial.",
                                "Economia: Juros compostos contínuos (λ>0).",
                                "Computação: Análise de autovalores em métodos numéricos."
                              ],
                              "realWorldApplication": "Essa equação modela o decaimento radioativo (ex.: Carbono-14, λ≈-0.00012/ano), crescimento bacteriano, circuitos RC (corrente decai como exp(-t/τ)), ou estabilidade de algoritmos numéricos onde autovalores com Re(λ)<0 garantem convergência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Interpretar o papel de λ no comportamento da solução",
                            "description": "Analisar como a parte real e imaginária de λ determinam a estabilidade e oscilação da solução contínua, relacionando com problemas stiff quando |Im(λ)/Re(λ)| é grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a solução analítica da equação y' = λy",
                                  "subSteps": [
                                    "Derivar a solução exata: y(t) = y(0) * exp(λ t), onde λ = a + bi.",
                                    "Expressar exp(λ t) = exp(a t) * (cos(b t) + i sin(b t)) para λ complexo.",
                                    "Plotar ou visualizar a solução para λ real positivo, negativo e zero.",
                                    "Identificar o papel de exp(a t) como fator de crescimento/decrescimento.",
                                    "Discutir o módulo |y(t)| ≈ |y(0)| * exp(a t) * constante."
                                  ],
                                  "verification": "Escrever e plotar corretamente a solução para pelo menos três valores de λ (real positivo, negativo e complexo).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, calculadora ou software como Python/MATLAB para plots, referência de equações diferenciais lineares.",
                                  "tips": "Use a forma polar para visualizar o crescimento exponencial e oscilação separadamente.",
                                  "learningObjective": "Compreender a forma exata da solução e sua dependência em Re(λ) e Im(λ).",
                                  "commonMistakes": "Confundir a solução com y(t) = λ t (linear) em vez de exponencial; ignorar a parte imaginária em λ real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto da parte real de λ na estabilidade",
                                  "subSteps": [
                                    "Examinar casos: Re(λ) > 0 (instável, crescimento exponencial), Re(λ) = 0 (marginal), Re(λ) < 0 (estável, decaimento).",
                                    "Calcular limite t→∞ de |y(t)| para diferentes Re(λ).",
                                    "Simular numericamente com método de Euler para comparar com solução exata.",
                                    "Identificar regiões de estabilidade no plano complexo de λ.",
                                    "Relacionar com autovalores de matrizes em sistemas lineares maiores."
                                  ],
                                  "verification": "Prever corretamente o comportamento assintótico (cresce, decai ou constante) para 5 valores de λ dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Desmos, Python com Matplotlib/NumPy), tabela de valores de λ.",
                                  "tips": "Sempre normalize y(0)=1 para comparar magnitudes diretamente.",
                                  "learningObjective": "Determinar estabilidade baseada exclusivamente em Re(λ).",
                                  "commonMistakes": "Atribuir instabilidade à Im(λ) em vez de Re(λ); confundir estabilidade local com global."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o papel da parte imaginária na oscilação",
                                  "subSteps": [
                                    "Fixar Re(λ) < 0 e variar Im(λ): observar frequência angular b = |Im(λ)|.",
                                    "Plotar soluções reais e imaginárias separadamente para λ = a ± bi.",
                                    "Calcular período de oscilação T = 2π / |Im(λ)|.",
                                    "Analisar decaimento amortecido quando Re(λ) < 0 e Im(λ) ≠ 0.",
                                    "Comparar com oscilador harmônico (λ = ± i ω)."
                                  ],
                                  "verification": "Descrever e plotar oscilações com frequências corretas para 3 pares de λ conjugados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de simulação numérica (MATLAB/Octave ou Python), gráficos pré-prontos como referência.",
                                  "tips": "Use animações de plots para visualizar oscilações em tempo real.",
                                  "learningObjective": "Relacionar Im(λ) com frequência e tipo de oscilação na solução.",
                                  "commonMistakes": "Ignorar que oscilações ocorrem apenas se Im(λ) ≠ 0; confundir amplitude com frequência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com problemas stiff via razão |Im(λ)/Re(λ)|",
                                  "subSteps": [
                                    "Definir problemas stiff: escalas de tempo muito diferentes (alta frequência vs. decaimento lento).",
                                    "Calcular razão r = |Im(λ)/Re(λ)|; identificar stiff quando r >> 1.",
                                    "Simular método explícito (ex: Euler) para λ stiff e observar instabilidade numérica.",
                                    "Comparar com métodos implícitos que lidam melhor com stiff.",
                                    "Discutir implicações para escolha de step size h < 2/|λ|."
                                  ],
                                  "verification": "Classificar 4 exemplos de λ como stiff ou não, justificando com simulações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python/MATLAB para solvers ODE (scipy.integrate.odeint), exemplos de λ stiff.",
                                  "tips": "Teste h pequeno para métodos explícitos em stiff para ver rigidez.",
                                  "learningObjective": "Identificar e interpretar problemas stiff baseados no espectro de autovalores.",
                                  "commonMistakes": "Confundir stiff com instável (Re(λ)>0); subestimar necessidade de métodos implícitos."
                                }
                              ],
                              "practicalExample": "Considere λ = -1 + 10i (r ≈ 10, stiff). Plote y(t) = exp(λ t) de t=0 a 1. Observe oscilações rápidas com decaimento lento. Simule com Euler explícito (h=0.01): método falha por instabilidade, enquanto implícito converge.",
                              "finalVerifications": [
                                "Explicar verbalmente como Re(λ) controla estabilidade e Im(λ) oscilação.",
                                "Prever comportamento para λ = -0.1 + 100i (stiff oscilatório).",
                                "Plotar região de estabilidade absoluta no plano λ para Euler forward.",
                                "Identificar por que |Im/Re| grande causa stiff em simulações.",
                                "Relacionar a um sistema real como circuito RLC subamortecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e interpretação da solução exata (30%).",
                                "Correta análise de estabilidade via Re(λ) e oscilação via Im(λ) (25%).",
                                "Identificação correta de problemas stiff com exemplos numéricos (20%).",
                                "Uso adequado de plots e simulações para suporte visual (15%).",
                                "Conexões claras com contexto mais amplo de análise numérica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Osciladores amortecidos e autovalores em equações de movimento.",
                                "Engenharia: Estabilidade em controle de sistemas dinâmicos lineares.",
                                "Computação: Algoritmos ODE solvers e escolha de métodos para stiff.",
                                "Química: Cinética de reações com múltiplas escalas temporais."
                              ],
                              "realWorldApplication": "Em modelagem de circuitos elétricos RLC, λ determina se o circuito oscila (Im(λ)≠0) e decai (Re(λ)<0); problemas stiff surgem em simulações de alta frequência, exigindo solvers implícitos para precisão eficiente em design de filtros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Discretizar o problema modelo com passo h",
                            "description": "Introduzir a variável complexa z = λ h e explicar por que ela determina o comportamento numérico local, conectando ao fator de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema modelo contínuo y' = λ y",
                                  "subSteps": [
                                    "Escreva a equação diferencial ordinária (EDO) modelo: y'(t) = λ y(t), onde λ é um escalar complexo.",
                                    "Determine a solução exata: y(t) = y(0) exp(λ t).",
                                    "Discuta o comportamento qualitativo: se Re(λ) < 0, solução decai; se Re(λ) > 0, cresce; parte imaginária causa oscilações.",
                                    "Identifique o papel de λ no crescimento/decay exponencial.",
                                    "Calcule exemplos numéricos para λ real e complexo para ilustrar."
                                  ],
                                  "verification": "Escreva a solução exata e descreva verbalmente o comportamento para λ = -1 e λ = -1 + i.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Sempre normalize y(0) = 1 para simplificar comparações.",
                                  "learningObjective": "Compreender a dinâmica contínua governada por λ.",
                                  "commonMistakes": "Confundir λ com o passo h; esquecer que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar discretização com método de Euler forward",
                                  "subSteps": [
                                    "Defina o passo de tempo h > 0 e os pontos t_n = n h.",
                                    "Escreva a aproximação de Euler: y_{n+1} = y_n + h f(t_n, y_n) = y_n + h λ y_n.",
                                    "Simplifique para y_{n+1} = (1 + h λ) y_n.",
                                    "Expresse a solução numérica recursiva: y_n = [1 + h λ]^n y_0.",
                                    "Compare com a solução exata aproximada por exp(λ t_n) ≈ [1 + λ h]^n."
                                  ],
                                  "verification": "Derive a recursão y_{n+1} = (1 + h λ) y_n a partir da definição de Euler.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha ou Python para testar iterações"
                                  ],
                                  "tips": "Use notação y_n para enfatizar a discretização temporal.",
                                  "learningObjective": "Derivar a discretização explícita do método de Euler para a EDO modelo.",
                                  "commonMistakes": "Esquecer o termo h na aproximação integral; usar Euler backward por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a variável complexa z = h λ",
                                  "subSteps": [
                                    "Defina z = h λ, onde h é real positivo e λ complexo, tornando z complexo.",
                                    "Reescreva a recursão como y_{n+1} = (1 + z) y_n.",
                                    "Expresse a solução numérica: y_n = (1 + z)^n y_0.",
                                    "Compare com a solução exata: y(t_n) = exp(z n) y_0, já que t_n = n h e λ t_n = z n.",
                                    "Discuta como z encapsula tanto o passo h quanto a eigenvalue λ."
                                  ],
                                  "verification": "Substitua z = h λ na recursão e verifique que y_n = (1 + z)^n y_0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfica complexa (software como MATLAB ou GeoGebra)"
                                  ],
                                  "tips": "Plane o plano complexo para visualizar |z| e arg(z).",
                                  "learningObjective": "Reconhecer z = h λ como variável adimensional que unifica h e λ.",
                                  "commonMistakes": "Tratar z como real quando λ é complexo; inverter z = λ / h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar z ao fator de amplificação e comportamento numérico local",
                                  "subSteps": [
                                    "Defina o fator de amplificação ρ(z) = 1 + z para Euler forward.",
                                    "Analise |ρ(z)|: estabilidade requer |ρ(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Discuta comportamento local: cada passo multiplica por ρ(z), determinando crescimento/decay numérico.",
                                    "Compare ρ(z) com exp(z): erro local ≈ (1/2) z^2 por expansão de Taylor.",
                                    "Ilustre com gráfico de |ρ(z)| no semiplano esquerdo."
                                  ],
                                  "verification": "Calcule ρ(z) para z = -0.5 + 0.5i e verifique |ρ(z)| < 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Python/MATLAB para plotar região de estabilidade"
                                  ],
                                  "tips": "Foco em |ρ(z)| para estabilidade absoluta.",
                                  "learningObjective": "Explicar como z determina o comportamento numérico via ρ(z).",
                                  "commonMistakes": "Confundir fator de amplificação com solução exata; ignorar parte imaginária."
                                }
                              ],
                              "practicalExample": "Para λ = -10 + 10i (oscilação amortecida rápida), h = 0.01, então z = (-0.1 + 0.1i). Calcule ρ(z) = 1 + z = 0.9 + 0.1i, |ρ(z)| ≈ 0.905 < 1 (estável). Simule 100 passos em Python: y_n converge para 0 como a exata.",
                              "finalVerifications": [
                                "Deriva corretamente ρ(z) = 1 + z para Euler.",
                                "Explica por que z determina comportamento local numérico.",
                                "Calcula |ρ(z)| para z com Re(z) < 0.",
                                "Compara solução numérica y_n = ρ(z)^n y_0 com exata exp(z n) y_0.",
                                "Identifica região de estabilidade |1 + z| ≤ 1.",
                                "Descreve impacto de h pequeno em z."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de z = h λ e ρ(z).",
                                "Compreensão qualitativa de |ρ(z)| ≤ 1 para estabilidade.",
                                "Capacidade de conectar ao erro local via Taylor.",
                                "Uso correto de números complexos em cálculos.",
                                "Explicação clara do papel de z no comportamento numérico.",
                                "Aplicação em exemplo numérico com gráfico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em sistemas dinâmicos lineares (e.g., osciladores amortecidos).",
                                "Computação: Implementação de solvers ODE em Python (scipy.integrate).",
                                "Engenharia: Análise de estabilidade em controle automático.",
                                "Estatística: Modelos estocásticos com eigenvalues complexas."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), z = h λ determina se vórtices numéricos dampam ou explodem; engenheiros ajustam h para |ρ(z)| < 1, evitando instabilidades em previsões meteorológicas ou aerodinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Fator de Amplificação",
                        "description": "O fator de amplificação R(z) é a razão y_{n+1}/y_n na recursão numérica aplicada à equação modelo, obtido resolvendo a equação característica do método.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Calcular o fator de amplificação para o método de Euler explícito",
                            "description": "Derivar R(z) = 1 + z para o método forward Euler y_{n+1} = y_n + h λ y_n, e plotar sua magnitude no plano complexo z.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método de Euler explícito e a equação modelo de teste",
                                  "subSteps": [
                                    "Lembre-se da fórmula do método forward Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Considere a equação de teste linear y' = λ y, onde λ é complexo, levando a f(y) = λ y.",
                                    "Introduza a variável z = h λ, que representa o passo no plano complexo.",
                                    "Entenda que a análise de estabilidade usa soluções do tipo y_n = R(z)^n y_0.",
                                    "Verifique exemplos simples com λ real negativo para intuição."
                                  ],
                                  "verification": "Escreva corretamente a fórmula de Euler para y' = λ y e defina z = h λ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Comece com um exemplo numérico simples para fixar a intuição antes da derivação.",
                                  "learningObjective": "Compreender os fundamentos do método de Euler e o papel da equação de teste na análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir forward Euler com backward Euler.",
                                    "Esquecer que λ pode ser complexo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a relação de recursão para o método de Euler",
                                  "subSteps": [
                                    "Substitua f(t_n, y_n) = λ y_n na fórmula de Euler: y_{n+1} = y_n + h λ y_n.",
                                    "Fatore y_n: y_{n+1} = y_n (1 + h λ).",
                                    "Identifique z = h λ, então y_{n+1} = y_n (1 + z).",
                                    "Defina o fator de amplificação R(z) como o coeficiente multiplicador: R(z) = 1 + z.",
                                    "Confirme que y_n = [R(z)]^n y_0 satisfaz a recursão."
                                  ],
                                  "verification": "Escreva y_{n+1} = y_n (1 + z) e identifique R(z) = 1 + z.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para exemplos numéricos"
                                  ],
                                  "tips": "Faça a derivação passo a passo algebricamente, evitando saltos.",
                                  "learningObjective": "Derivar com precisão a recursão característica do método de Euler para a equação de teste.",
                                  "commonMistakes": [
                                    "Escrever y_{n+1} = y_n + h λ em vez de fatorar.",
                                    "Confundir z = h λ com λ h invertido."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a forma de R(z) e preparar para o plot",
                                  "subSteps": [
                                    "Confirme R(z) = 1 + z, onde z = x + i y no plano complexo.",
                                    "Calcule a magnitude |R(z)| = |1 + z| = sqrt( (1 + x)^2 + y^2 ).",
                                    "Discuta o região de estabilidade: |R(z)| ≤ 1 para estabilidade absoluta.",
                                    "Identifique que para Euler explícito, a região é o disco |z + 1| ≤ 1 no lado esquerdo.",
                                    "Prepare eixos: eixo real (Re(z)) horizontal, imaginário (Im(z)) vertical."
                                  ],
                                  "verification": "Escreva a fórmula explícita de |R(z)| e descreva qualitativamente sua forma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Python (matplotlib) ou MATLAB"
                                  ],
                                  "tips": "Visualize z como vetor de -1 no plano para entender o círculo unitário centrado em -1.",
                                  "learningObjective": "Calcular e interpretar a magnitude do fator de amplificação no plano complexo.",
                                  "commonMistakes": [
                                    "Calcular |R(z)| como |1| + |z| em vez da norma euclidiana.",
                                    "Plotar em coordenadas polares sem converter."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar a magnitude |R(z)| no plano complexo",
                                  "subSteps": [
                                    "Desenhe o plano complexo com Re(z) de -3 a 1 e Im(z) de -2 a 2.",
                                    "Trace a curva |1 + z| = 1, que é um círculo de raio 1 centrado em z = -1.",
                                    "Preencha ou destaque a região onde |R(z)| ≤ 1 (interior do círculo).",
                                    "Marque pontos de teste, como z = -0.5 (estável), z = i (instável).",
                                    "Interprete: método instável para Re(λ h) > -2."
                                  ],
                                  "verification": "Produza um gráfico correto mostrando o círculo |z + 1| = 1 e rotule os eixos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/MATLAB/GeoGebra)",
                                    "Papel para esboço manual"
                                  ],
                                  "tips": "Use contour plot ou meshgrid em Python para precisão; esboce à mão primeiro.",
                                  "learningObjective": "Visualizar e interpretar graficamente a região de estabilidade do método de Euler explícito.",
                                  "commonMistakes": [
                                    "Centralizar o círculo em 0 em vez de -1.",
                                    "Esquecer de plotar apenas a magnitude igual a 1."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y (λ = -1) com h = 0.5, z = -0.5. Então R(z) = 1 - 0.5 = 0.5, |R| = 0.5 < 1 (estável). Plote z = -0.5 no gráfico: dentro do círculo. Simule 10 passos em Python e verifique se |y_n| decai.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = 1 + z a partir da recursão.",
                                "Fórmula precisa de |R(z)| = sqrt((1 + Re(z))^2 + Im(z)^2).",
                                "Gráfico mostrando círculo de raio 1 centrado em (-1, 0).",
                                "Identificação correta da região |R(z)| ≤ 1.",
                                "Exemplo numérico com interpretação de estabilidade.",
                                "Explicação verbal da limitação do método para Re(z) > -2."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de R(z) (30%).",
                                "Correção e clareza do gráfico de |R(z)| (25%).",
                                "Interpretação qualitativa da estabilidade (20%).",
                                "Uso adequado de notação complexa e z = h λ (15%).",
                                "Exemplo prático com simulação numérica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar plot em Python com numpy/matplotlib.",
                                "Física: Aplicar em equações diferenciais de osciladores harmônicos.",
                                "Engenharia Computacional: Análise de estabilidade em simulações CFD.",
                                "Matemática Pura: Funções complexas e geometria no plano complexo."
                              ],
                              "realWorldApplication": "Na simulação numérica de sistemas dinâmicos, como propagação de ondas em engenharia acústica ou modelagem de epidemias, o fator de amplificação garante que erros numéricos não explodam, evitando instabilidades em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Calcular o fator de amplificação para o método de Euler implícito",
                            "description": "Derivar R(z) = 1 / (1 - z) para o método backward Euler y_{n+1} = y_n + h λ y_{n+1}, comparando com o explícito em termos de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação do método de Euler implícito (backward Euler)",
                                  "subSteps": [
                                    "Escrever a equação diferencial linear teste: y' = λ y, onde λ é escalar complexo.",
                                    "Apresentar a iteração do backward Euler: y_{n+1} = y_n + h λ y_{n+1}, com h > 0 o passo de tempo.",
                                    "Explicar que é implícito porque y_{n+1} aparece nos dois membros da equação.",
                                    "Comparar brevemente com o explícito: y_{n+1} = y_n + h λ y_n.",
                                    "Identificar as variáveis chave: h (passo), λ (autovalor), y_n (aproximação atual)."
                                  ],
                                  "verification": "Reescrever corretamente a fórmula do backward Euler e explicar a diferença com o explícito em uma frase.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Livro-texto de Análise Numérica (capítulo de métodos para EDOs)",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Visualize graficamente: no implícito, usa o valor futuro para aproximar a derivada.",
                                  "learningObjective": "Entender a estrutura algébrica do método backward Euler para problemas lineares.",
                                  "commonMistakes": [
                                    "Confundir os lados da equação (colocar y_{n+1} só no lado direito)",
                                    "Esquecer que λ pode ser complexo para análise de estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Rearranjar a equação para expressar y_{n+1} em função de y_n",
                                  "subSteps": [
                                    "Partir da equação: y_{n+1} = y_n + h λ y_{n+1}.",
                                    "Subtrair h λ y_{n+1} de ambos os lados: y_{n+1} - h λ y_{n+1} = y_n.",
                                    "Fatorar y_{n+1}: y_{n+1} (1 - h λ) = y_n.",
                                    "Isolar y_{n+1}: y_{n+1} = y_n / (1 - h λ).",
                                    "Verificar algebricamente substituindo de volta na equação original."
                                  ],
                                  "verification": "Derivar corretamente y_{n+1} = y_n / (1 - h λ) sem erros algébricos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Folha com equações anotadas"
                                  ],
                                  "tips": "Trate h λ como uma constante durante a manipulação para simplificar.",
                                  "learningObjective": "Dominar a resolução da recorrência linear implícita.",
                                  "commonMistakes": [
                                    "Dividir incorretamente (esquecer o sinal negativo em -h λ)",
                                    "Confundir com a forma explícita 1 + h λ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e derivar o fator de amplificação R(z)",
                                  "subSteps": [
                                    "Introduzir a variável adimensional z = h λ.",
                                    "Definir o fator de amplificação R(z) = y_{n+1} / y_n.",
                                    "Substituir na expressão: R(z) = 1 / (1 - z).",
                                    "Verificar o limite para z → 0: R(0) = 1, consistente com exatidão.",
                                    "Esboçar graficamente |R(z)| no plano complexo (opcional, para intuição)."
                                  ],
                                  "verification": "Escrever R(z) = 1 / (1 - z) e confirmar com z pequeno que R(z) ≈ 1 + z + z² + ... (expansão em série).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Gráfica de |R(z)| (software como Desmos ou papel)",
                                    "Tabela de valores de z"
                                  ],
                                  "tips": "z = h λ captura tanto o tamanho do passo quanto a rigidez (Re(λ) < 0).",
                                  "learningObjective": "Derivar formalmente o fator de amplificação para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Escrever R(z) = 1 / (1 + z) (confusão com outro método)",
                                    "Esquecer de definir z = h λ explicitamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com o método explícito e analisar estabilidade",
                                  "subSteps": [
                                    "Recordar R(z)_{explícito} = 1 + z.",
                                    "Comparar regiões de estabilidade: para explícito, |1 + z| ≤ 1 (círculo unitário esquerdo); para implícito, todo semiplano Re(z) ≤ 0.",
                                    "Discutir implicações: implícito é incondicionalmente estável para problemas stiff.",
                                    "Calcular exemplo numérico: para z = -2, |R_impl| = 1/3 <1, |R_expl| = 1 <1? Não, |1-2|=1=1, mas para z=-3, expl>1.",
                                    "Concluir vantagens do implícito em termos de estabilidade."
                                  ],
                                  "verification": "Desenhar/esboçar as regiões de estabilidade e explicar por que implícito é A-estável.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Software de plotagem (GeoGebra/Desmos)",
                                    "Exemplos numéricos tabulados"
                                  ],
                                  "tips": "Foco na metade esquerda do plano z: implícito cobre tudo, explícito só disco pequeno.",
                                  "learningObjective": "Analisar e comparar estabilidade entre métodos explícito e implícito.",
                                  "commonMistakes": [
                                    "Afirmar que explícito é mais estável",
                                    "Ignorar o semiplano esquerdo para stiff problems."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO y' = -50 y (λ = -50, stiff), com h = 0.1, então z = -5. Para backward Euler: R(-5) = 1/(1 - (-5)) = 1/6 ≈ 0.1667, |R| <1 estável. Para explícito: R(-5)=1-5=-4, |R|=4>1 instável. Simule 10 passos: implícito converge, explícito explode.",
                              "finalVerifications": [
                                "Derivação exata de R(z) = 1/(1 - z) mostrada algebricamente.",
                                "Correta definição de z = h λ.",
                                "Comparação gráfica ou tabular de |R(z)| para Re(z) < 0.",
                                "Explicação da estabilidade incondicional do método implícito.",
                                "Cálculo numérico de R(z) para pelo menos dois valores de z.",
                                "Identificação correta da região de estabilidade absoluta."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de R(z) (sem erros de sinal ou fator).",
                                "Correta introdução e uso de z = h λ em todos os passos.",
                                "Qualidade da comparação com Euler explícito (R(z)=1+z).",
                                "Análise qualitativa de estabilidade (A-estabilidade mencionada).",
                                "Exemplo prático computado corretamente com interpretação.",
                                "Clareza na verificação de consistência (R(0)=1)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em osciladores amortecidos (equações diferenciais lineares).",
                                "Engenharia Química: Simulação de reações stiff em reatores.",
                                "Ciência da Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Matemática Aplicada: Teoria de Runge-Kutta e métodos multistep."
                              ],
                              "realWorldApplication": "Em simulações de sistemas stiff como circuitos elétricos RC/RLC ou cinética química com escalas de tempo díspares, o backward Euler permite passos h maiores sem instabilidade, acelerando computações em softwares como COMSOL ou ode23s do MATLAB."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Generalizar o fator de amplificação para métodos lineares",
                            "description": "Explicar que para métodos lineares de k passos, R(z) é uma função racional de grau k, aproximando exp(z) via polinômio de Padé ou interpolação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Fator de Amplificação para Métodos de 1 Passo",
                                  "subSteps": [
                                    "Relembre a equação de teste linear y' = λy, com solução exata y_n = exp(λ h) y_0.",
                                    "Defina o fator de amplificação R(z) onde z = λ h, tal que y_{n+1} = R(z) y_n.",
                                    "Analise exemplos como Euler explícito (R(z) = 1 + z) e Euler implícito (R(z) = 1/(1 - z)).",
                                    "Verifique a estabilidade: |R(z)| ≤ 1 para z no semiplano esquerdo.",
                                    "Compare com a solução exata exp(z)."
                                  ],
                                  "verification": "Escreva as expressões de R(z) para Euler explícito e implícito e plote |R(z)| no plano complexo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Sempre normalize z = h λ para dimensionless analysis.",
                                  "learningObjective": "Compreender o papel fundamental do fator R(z) no caso unipasso.",
                                  "commonMistakes": "Confundir estabilidade A com B; lembrar que A é |R(iy)|≤1 para y real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Métodos Lineares Multiuso de k Passos",
                                  "subSteps": [
                                    "Estude a recursão geral: ∑_{j=0}^k α_j y_{n+j} = h λ ∑_{j=0}^k β_j y_{n+j}.",
                                    "Defina o polinômio característico ρ(ζ) = ∑ α_j ζ^j e σ(ζ) = ∑ β_j ζ^j.",
                                    "Introduza a transformação ζ = R(z), levando à equação ρ(R) = z σ(R).",
                                    "Reconheça que isso define R(z) implicitamente como solução de uma equação polinomial de grau k.",
                                    "Discuta ordem de consistência e estabilidade para multistep."
                                  ],
                                  "verification": "Escreva a equação ρ(R) - z σ(R) = 0 para um método de k=2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Comece com k=2 para visualizar a estrutura racional.",
                                  "learningObjective": "Entender a generalização da recursão para métodos multistep lineares.",
                                  "commonMistakes": "Esquecer o fator h em z = h λ na definição de σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar que R(z) é uma Função Racional de Grau k",
                                  "subSteps": [
                                    "Resolva ρ(ζ) = z σ(ζ) para ζ, mostrando que é um polinômio de grau k em ζ e z.",
                                    "Expresse R(z) = P(z)/Q(z), onde P e Q são polinômios de graus ≤k, com Q monico.",
                                    "Verifique que num e den têm grau k para métodos consistentes de ordem 2k ou menos.",
                                    "Analise o comportamento assintótico: R(z) ~ exp(z) para z→0.",
                                    "Calcule exemplos para Adams-Bashforth de k=2."
                                  ],
                                  "verification": "Derive explicitamente R(z) para o método trapezoidal (k=2) e confirme grau [1/1].",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": [
                                    "Python ou MATLAB para resolução simbólica",
                                    "Quadro branco para derivação"
                                  ],
                                  "tips": "Use expansão em série de Taylor para verificar ordem.",
                                  "learningObjective": "Provar que R(z) é racional de grau k na generalização.",
                                  "commonMistakes": "Assumir grau exato sem consistência; grau num=den=k para ordem alta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar R(z) com Aproximações de Padé e Interpolação",
                                  "subSteps": [
                                    "Revise polinômios de Padé [m/n] aproximando exp(z) com racional m+n=k.",
                                    "Mostre que métodos lineares de ordem 2k usam Padé [k/k].",
                                    "Explique interpolação: R(z) interpola exp(z) em k+1 pontos escolhidos.",
                                    "Compare com extrapolação em multistep explícitos.",
                                    "Avalie estabilidade: região onde |R(z)|≤1 contém o semiplano esquerdo."
                                  ],
                                  "verification": "Construa o Padé [1/1] para exp(z) e compare com trapezoidal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de Padé (online ou livro)",
                                    "Software para aproximação racional"
                                  ],
                                  "tips": "Padé [k/k] é ótimo para estabilidade em stiff problems.",
                                  "learningObjective": "Vincular generalização teórica a técnicas de aproximação conhecidas.",
                                  "commonMistakes": "Confundir Padé simétrico [k/k] com assimétricos em métodos explícitos."
                                }
                              ],
                              "practicalExample": "Para o método de Milne-Simpson (k=3, implícito), R(z) é o Padé [3/3] de exp(z), aproximando y_{n+3} com pesos históricos. Implemente em Python: resolva ρ(R) = z σ(R) numericamente e plote |R(z)| para Re(z)<0, verificando estabilidade A(α) com α≈3.",
                              "finalVerifications": [
                                "Derivar corretamente R(z) para um método multistep k=2.",
                                "Explicar por que R(z) tem grau k no numerador e denominador.",
                                "Construir Padé [1/1] e mostrar igual ao trapezoidal.",
                                "Plotar região de estabilidade e compará-la com exp(z).",
                                "Discutir limitações para k grande (rigidez).",
                                "Aplicar a um EDO teste y'= -y, simulando com k=3."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação ρ(R) - z σ(R) = 0 (100% correto).",
                                "Clareza na explicação de grau k e racionalidade.",
                                "Correta identificação de Padé para métodos específicos.",
                                "Análise qualitativa de estabilidade (região A/B).",
                                "Criatividade em exemplos práticos e plots.",
                                "Profundidade nas conexões com interpolação."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Estabilidade em simulações de ondas/difusão.",
                                "Programação: Implementação de solvers multistep em SciPy.",
                                "Engenharia: Controle de sistemas stiff (ex: circuitos RLC).",
                                "Estatística: Aproximações racionais em processos markovianos.",
                                "Ciência de Dados: Integração numérica em MLPs recorrentes."
                              ],
                              "realWorldApplication": "Em modelagem climática, solvers multistep com R(z) Padé [k/k] integram EDOs stiff de longa duração sem oscilações, como em previsões de furacões (NOAA models) ou simulações farmacocinéticas em drug design."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1",
                              "10.1.4.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Critérios de Estabilidade Linear",
                        "description": "A estabilidade linear requer que o fator de amplificação satisfaça |R(z)| ≤ 1 para z = λ h com Re(λ) < 0, definindo a região de estabilidade no plano z.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Determinar a condição de estabilidade absoluta",
                            "description": "Verificar |R(z)| ≤ 1 + O(|z|^2) para consistência e estabilidade A-estável quando o disco unitário contém o semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de estabilidade absoluta e A-estabilidade",
                                  "subSteps": [
                                    "Estude a definição de região de estabilidade absoluta: conjunto {z ∈ ℂ | |R(z)| ≤ 1}, onde z = hλ e Re(λ) ≤ 0.",
                                    "Revise o que é A-estabilidade: a região de estabilidade absoluta contém todo o semiplano esquerdo {z | Re(z) ≤ 0}.",
                                    "Entenda a relação com o disco unitário: para alguns métodos, a região instável é relacionada ao exterior do disco unitário.",
                                    "Leia sobre consistência: requer R(0) = 1 e R'(0) = 0, implicando |R(z)| = 1 + O(|z|^2) perto de z = 0.",
                                    "Anote exemplos de métodos A-estáveis como Backward Euler e Trapezoidal."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre estabilidade absoluta e A-estabilidade, e cite um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Desenhe o semiplano esquerdo e o disco unitário no plano complexo para visualizar.",
                                  "learningObjective": "Dominar as definições chave de estabilidade em métodos numéricos para EDOs.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com estabilidade zero",
                                    "Ignorar que A-estabilidade requer contenção do semiplano inteiro esquerdo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a função de estabilidade R(z) para um método dado",
                                  "subSteps": [
                                    "Identifique os polinômios ρ(z) e σ(z) do método linear multistep ou Runge-Kutta equivalente.",
                                    "Calcule R(z) = [ρ(z) - z σ(z)] / ρ(1), assumindo consistência com ρ(1) = 1.",
                                    "Para métodos one-step, derive R(z) da recursão y_{n+1} = R(z) y_n.",
                                    "Exemplo: Para Backward Euler, R(z) = 1 / (1 - z).",
                                    "Verifique R(0) = 1."
                                  ],
                                  "verification": "Compute R(z) para o método Trapezoidal Rule e confirme R(0) = 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica, SymPy ou papel)",
                                    "Tabela de métodos numéricos"
                                  ],
                                  "tips": "Sempre normalize para que o método seja consistente antes de calcular R(z).",
                                  "learningObjective": "Saber derivar a função de estabilidade R(z) a partir dos coeficientes do método.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes de ρ(z) ou σ(z)",
                                    "Esquecer a divisão por ρ(1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição local |R(z)| ≤ 1 + O(|z|^2) perto de z = 0",
                                  "subSteps": [
                                    "Expanda R(z) em série de Taylor ao redor de z = 0: R(z) = 1 + c_2 z^2 + O(z^3).",
                                    "Mostre que |R(z)| ≤ 1 + K |z|^2 para |z| pequeno e Re(z) ≤ 0, usando |1 + w| ≤ 1 + |w| para Re(w) ≤ 0.",
                                    "Calcule os coeficientes até ordem 2 e verifique c_1 = 0 (consistência ordem 1).",
                                    "Teste numericamente para z pequeno no semiplano esquerdo.",
                                    "Conclua se a condição implica consistência e estabilidade local."
                                  ],
                                  "verification": "Para um R(z) dado, comprove a expansão e a desigualdade para |z| < 0.1.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software para expansão Taylor (SymPy ou MATLAB)",
                                    "Caderno"
                                  ],
                                  "tips": "Use a desigualdade triangular para estimar |R(z)|.",
                                  "learningObjective": "Aplicar análise assintótica para verificar consistência via estabilidade local.",
                                  "commonMistakes": [
                                    "Parar na ordem 1 sem verificar O(|z|^2)",
                                    "Não considerar apenas Re(z) ≤ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar A-estabilidade e relação com o disco unitário",
                                  "subSteps": [
                                    "Plote ou descreva a região {z | |R(z)| ≤ 1} no plano complexo.",
                                    "Verifique se {Re(z) ≤ 0} ⊆ {z | |R(z)| ≤ 1}, testando pontos críticos como eixos real/imanáginário.",
                                    "Analise se o disco unitário |z| ≤ 1 contém ou é contido na região relevante (para métodos A-estáveis).",
                                    "Use teorema de máxima módulo ou propriedades analíticas para provar contenção.",
                                    "Conclua se o método é A-estável baseado na verificação."
                                  ],
                                  "verification": "Para Backward Euler, prove que |R(z)| ≤ 1 ∀ Re(z) ≤ 0.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Software de plotagem (Python Matplotlib, MATLAB)",
                                    "Livro com teoremas de estabilidade"
                                  ],
                                  "tips": "Teste infinitos pontos como z → -∞ e z = iy.",
                                  "learningObjective": "Determinar A-estabilidade verificando inclusão do semiplano esquerdo na região estável.",
                                  "commonMistakes": [
                                    "Confundir disco unitário com região de |R(z)| > 1",
                                    "Testar apenas pontos finitos sem limite"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler (R(z) = 1/(1 - z)): Expansão Taylor R(z) = 1 + z + z^2 + ... , mas |R(z)| = 1/|1 - z| ≤ 1 quando |1 - z| ≥ 1 (exterior do disco centrado em 1, raio 1), que contém o semiplano esquerdo. Verifique |R(-1)| = 0.5 ≤ 1, |R(-iy)| = 1/√(1 + y^2) ≤ 1, e expansão |1 + z + O(z^2)| ≤ 1 + |z| + O(|z|^2) ajustada para O(|z|^2).",
                              "finalVerifications": [
                                "Deriva corretamente R(z) para métodos dados.",
                                "Confirma R(0)=1 e R'(0)=0 via Taylor.",
                                "Prova |R(z)| ≤ 1 + O(|z|^2) para pequenos z com Re(z)≤0.",
                                "Descreve a região |R(z)|≤1 e verifica inclusão do semiplano esquerdo.",
                                "Identifica métodos A-estáveis corretamente.",
                                "Aplica a condição a um exemplo novo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) (20%)",
                                "Correção da expansão Taylor e desigualdade O(|z|^2) (25%)",
                                "Análise completa da região de estabilidade (25%)",
                                "Verificação de A-estabilidade com provas ou plots (20%)",
                                "Clareza na explicação e exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores rígidos.",
                                "Engenharia de Controle: Análise de sistemas lineares discretos.",
                                "Ciência da Computação: Implementação de solvers ODE em bibliotecas como SciPy.",
                                "Matemática Aplicada: Teoria de funções analíticas e máxima módulo."
                              ],
                              "realWorldApplication": "Em simulações numéricas de sistemas dinâmicos rígidos, como modelos climáticos ou circuitos elétricos, onde passos h variáveis requerem A-estabilidade para evitar instabilidades em escalas rápidas, usado em softwares como MATLAB ode15s ou COMSOL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Construir a região de estabilidade no plano complexo",
                            "description": "Plotar e interpretar a região {z ∈ ℂ : |R(z)| ≤ 1}, comparando Euler explícito (disco |z| ≤ 2) vs. implícito (semiplano esquerdo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de região de estabilidade",
                                  "subSteps": [
                                    "Definir a região de estabilidade como o conjunto {z ∈ ℂ : |R(z)| ≤ 1}, onde R(z) é a função de amplificação do método numérico.",
                                    "Explicar o papel de z = hλ, com h passo de tempo e λ autovalor da matriz jacobiana.",
                                    "Identificar R(z) = 1 + z para Euler explícito e R(z) = 1/(1 - z) para Euler implícito.",
                                    "Discutir a importância para estabilidade absoluta em problemas rígidos.",
                                    "Revisar representação no plano complexo com eixos Re(z) horizontal e Im(z) vertical."
                                  ],
                                  "verification": "Escrever definições e fórmulas de R(z) para ambos métodos sem consultar materiais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula, quadro branco.",
                                  "tips": "Visualize z como perturbação complexa; foque em |R(z)| ≤ 1 para não amplificar erros.",
                                  "learningObjective": "Dominar definições e notação para análise de estabilidade linear.",
                                  "commonMistakes": "Confundir z = hλ com λh; ignorar parte imaginária de z."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a região de estabilidade do Euler explícito",
                                  "subSteps": [
                                    "Escrever |1 + z| ≤ 1 e reescrever como |z - (-1)| ≤ 1.",
                                    "Identificar centro em -1 + 0i e raio 1, formando disco unitário à esquerda.",
                                    "No eixo real, determinar intervalo [-2, 0] (aproximação |z| ≤ 2 para negativos).",
                                    "Esboçar manualmente o círculo no plano complexo.",
                                    "Verificar pontos: z = -2 (borda), z = 0 (borda), z = -1 (centro, |R|=0)."
                                  ],
                                  "verification": "Plotar disco corretamente e calcular |R(-2)| = 1, |R(0)| = 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel milimetrado, lápis, calculadora, software GeoGebra ou Python (matplotlib).",
                                  "tips": "Use desigualdade triangular para bounds; teste pontos fora do disco.",
                                  "learningObjective": "Calcular e descrever geometricamente a região |1 + z| ≤ 1.",
                                  "commonMistakes": "Erro no centro (pensar em |z| ≤ 1); confundir raio 1 com 2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a região de estabilidade do Euler implícito",
                                  "subSteps": [
                                    "Escrever |1/(1 - z)| ≤ 1, equivalente a |1 - z| ≥ 1.",
                                    "Interpretar como exterior do disco |z - 1| ≤ 1 (centro 1 + 0i, raio 1).",
                                    "Notar que inclui todo semiplano esquerdo Re(z) ≤ 0 (A-estável).",
                                    "Esboçar o círculo e sombrear exterior.",
                                    "Verificar: z = -1 (|1 - (-1)| = 2 >1), z = 2 (|1-2|=1 borda)."
                                  ],
                                  "verification": "Confirmar que semiplano Re(z) ≤ 0 está contido e calcular |R| para pontos teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel milimetrado, calculadora complexa, Python ou MATLAB para plot.",
                                  "tips": "Inverta desigualdade ao manipular frações; foque em estabilidade incondicional.",
                                  "learningObjective": "Entender região ilimitada e propriedade A-estável.",
                                  "commonMistakes": "Confundir com interior do disco; esquecer inverso em R(z)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar, interpretar e comparar as regiões",
                                  "subSteps": [
                                    "Plotar ambas regiões no mesmo plano complexo usando software.",
                                    "Comparar: explícito limitado (disco pequeno), implícito amplo (exterior disco).",
                                    "Interpretar implicações: explícito para h pequeno, implícito para rígidos.",
                                    "Analisar interseção e problemas com parte imaginária.",
                                    "Discutir trade-offs: explícito mais simples/barato, implícito mais estável."
                                  ],
                                  "verification": "Gerar gráfico com regiões sombreadas e legendas corretas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python (numpy, matplotlib), MATLAB, ou Desmos; impressora para gráficos.",
                                  "tips": "Use cores diferentes; escale eixos para -3 a 3.",
                                  "learningObjective": "Visualizar e analisar comparações para escolha de método.",
                                  "commonMistakes": "Escalas erradas ocultando diferenças; ignorar implicações práticas."
                                }
                              ],
                              "practicalExample": "Para EDO y' = -10 y + sin(t), com λ ≈ -10 (rígida), use Euler explícito: h ≤ 0.2 para z = hλ ≥ -2. Com Euler implícito, qualquer h>0 estável. Plote regiões e teste h=0.3: explícito oscila, implícito converge.",
                              "finalVerifications": [
                                "Desenhar disco |z + 1| ≤ 1 corretamente para explícito.",
                                "Descrever semiplano esquerdo na região implícita.",
                                "Comparar áreas: explícito finito, implícito infinito.",
                                "Calcular |R(z)| ≤1 para 3 pontos em cada região.",
                                "Explicar por que implícito é A-estável.",
                                "Gerar plot overlay das duas regiões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de |R(z)| ≤1 (100% correto).",
                                "Qualidade do esboço/plots (formas, centros, raios exatos).",
                                "Profundidade da comparação (limitações, aplicações).",
                                "Correção em verificações numéricas (erro <1%).",
                                "Clareza na interpretação prática.",
                                "Uso adequado de ferramentas/software."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos.",
                                "Computação: Implementação de solvers numéricos em Python/NumPy.",
                                "Engenharia: Análise de controle e sistemas dinâmicos rígidos.",
                                "Programação: Visualização de dados complexos com matplotlib."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional) ou circuitos elétricos rígidos, escolher Euler implícito permite passos h maiores, reduzindo tempo computacional em 10x sem instabilidade, essencial em engenharia aeroespacial para modelar turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1",
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Analisar estabilidade para problemas stiff",
                            "description": "Explicar como métodos A-estáveis são necessários para λ com |Im(λ)| >> |Re(λ)| < 0, limitando o passo h apenas pela precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas stiff em EDOs",
                                  "subSteps": [
                                    "Defina problemas stiff: sistemas lineares y' = A y onde eigenvalues λ têm Re(λ) < 0 pequeno em magnitude comparado a |Im(λ)| grande.",
                                    "Identifique características: componentes rápidos oscilatórios (Im grande) e decaimento lento (Re pequeno negativo).",
                                    "Explique limitação de métodos explícitos: h < 1/|λ| para estabilidade, forçando passos minúsculos.",
                                    "Compare com problemas não-stiff: escalas temporais semelhantes permitem h maior."
                                  ],
                                  "verification": "Escreva uma definição precisa e dê um exemplo de eigenvalue stiff como λ = -0.1 + 10i.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Notas de Análise Numérica I",
                                    "Software MATLAB ou Python (SymPy para eigenvalues)"
                                  ],
                                  "tips": "Visualize no plano complexo: eigenvalues no semiplano esquerdo com parte imaginária dominante.",
                                  "learningObjective": "Identificar e caracterizar problemas stiff por seus eigenvalues.",
                                  "commonMistakes": [
                                    "Confundir stiff com problemas não-lineares",
                                    "Ignorar a parte imaginária nos eigenvalues",
                                    "Achar que todo Re(λ)<0 é stiff"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar análise de estabilidade linear",
                                  "subSteps": [
                                    "Lembre o teste de Dahlquist: para y' = λ y, solução numérica u_{n+1} = R(hλ) u_n, estável se |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Calcule R(z) para métodos comuns: Euler explícito R(z)=1+z (círculo unitário), Backward Euler R(z)=1/(1-z) (semiplano esquerdo).",
                                    "Desenhe regiões de estabilidade no plano z = hλ.",
                                    "Analise para λ real negativo: limitação h < 2/|λ| para explícito."
                                  ],
                                  "verification": "Plote região de estabilidade para Euler explícito e Backward Euler.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Folha de papel ou GeoGebra para plotar",
                                    "Referência: Burden & Faires Análise Numérica"
                                  ],
                                  "tips": "Use z = hλ para mapear eigenvalues reais para o plano complexo.",
                                  "learningObjective": "Aplicar teste de estabilidade linear a métodos de Runge-Kutta simples.",
                                  "commonMistakes": [
                                    "Esquecer que estabilidade requer |R(z)|≤1 para todo Re(z)≤0",
                                    "Confundir estabilidade absoluta com condicional",
                                    "Não normalizar por h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir A-estabilidade e suas implicações",
                                  "subSteps": [
                                    "Defina A-estabilidade: região de estabilidade contém todo semiplano esquerdo Re(z) ≤ 0.",
                                    "Exemplos: Backward Euler é A-estável; Trapezoidal também, mas não L-estável.",
                                    "Discuta L-estabilidade: A-estável + |R(z)|→0 quando |z|→∞.",
                                    "Explique benefício para stiff: h limitado só por precisão local/truncamento, não estabilidade.",
                                    "Compare com métodos não A-estáveis: oscilações ou instabilidade para h moderado."
                                  ],
                                  "verification": "Classifique Backward Euler como A-estável provando |R(z)| <1 para Re(z)<0.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Calculadora ou Python para verificar |R(z)| em pontos teste",
                                    "Tabela de métodos A-estáveis"
                                  ],
                                  "tips": "Prove usando |1/(1-z)|² = 1 / (|1-x|² + y²) ≤1 para x≥0 (z=x+iy).",
                                  "learningObjective": "Reconhecer métodos A-estáveis e justificar sua necessidade em stiff problems.",
                                  "commonMistakes": [
                                    "Achar que todos implícitos são A-estáveis",
                                    "Confundir A com incondicionalmente estável",
                                    "Ignorar damping em L-estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade para λ com |Im(λ)| >> |Re(λ)| < 0",
                                  "subSteps": [
                                    "Escolha exemplo: λ = -ε + iω com ε<<ω pequeno positivo, ε>0.",
                                    "Para explícito Euler: z = h(-ε + iω), |1+z| >1 se hω grande, instável.",
                                    "Para Backward Euler: z no semiplano esquerdo, sempre estável independentemente de h.",
                                    "Simule numericamente: compare soluções com h pequeno vs grande.",
                                    "Conclua: A-estáveis permitem h ~ 1/ω para precisão oscilatória, ignorando ε."
                                  ],
                                  "verification": "Resolva y' = λ y com λ=-0.1+10i, compare Euler explícito h=0.05 (instável) vs Backward h=0.2 (estável).",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "Python/Octave script para integração numérica",
                                    "Gráficos de solução exata y(t)=exp(λt)"
                                  ],
                                  "tips": "Use ode45 em MATLAB com stiff solver para validar.",
                                  "learningObjective": "Demonstrar quantitativamente por que A-estabilidade é crucial nesse regime.",
                                  "commonMistakes": [
                                    "Escolher h muito grande sem checar precisão",
                                    "Não plotar |R(hλ)|",
                                    "Confundir erro de truncamento com instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = (-0.1 + 10i) y, solução exata oscila com frequência ~10 e decai lentamente. Euler explícito com h=0.1 explode devido a |1 + hλ| >1; Backward Euler com h=0.5 permanece estável e preciso, permitindo simulação eficiente de 0 a 10s em poucos passos.",
                              "finalVerifications": [
                                "Explicar verbalmente por que métodos não A-estáveis falham em problemas com |Im(λ)| >> |Re(λ)|.",
                                "Identificar eigenvalues stiff em uma matriz A de exemplo.",
                                "Plotar região de estabilidade e localizar hλ para caso dado.",
                                "Simular em software e comparar estabilidade vs precisão.",
                                "Provar A-estabilidade para Backward Euler.",
                                "Discutir trade-offs: custo computacional implícito vs explícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiff e A-estabilidade (80% correto).",
                                "Correta aplicação do teste de Dahlquist com cálculos numéricos.",
                                "Análise qualitativa/quantitativa do caso |Im| >> |Re|.",
                                "Uso apropriado de exemplos e gráficos para ilustrar.",
                                "Identificação de erros comuns e justificativas claras.",
                                "Conexão com limitação de h pela precisão, não estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos com atrito pequeno (equações de onda).",
                                "Engenharia Elétrica: Simulação de circuitos RLC stiff com indutores.",
                                "Química Computacional: Cinemática de reações com passos rápidos oscilatórios.",
                                "Ciência da Computação: Otimização de solvers ODE em bibliotecas como SciPy.",
                                "Engenharia Mecânica: Vibrações em estruturas com modos rápidos e lentos."
                              ],
                              "realWorldApplication": "Em simulações de circuitos integrados (SPICE), onde capacitores e indutores criam stiff oscilações; permite passos h grandes com solvers A-estáveis como TRAP ou BDF, acelerando design de chips em eletrônica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Região de Estabilidade",
                    "description": "Conjunto de pontos hλ no plano complexo para os quais o método numérico é estável.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição e Interpretação da Região de Estabilidade",
                        "description": "Conjunto de pontos hλ no plano complexo para os quais o método numérico de integração de EDOs é estável, definido pela condição |R(hλ)| ≤ 1, onde R(z) é a função de amplificação do método.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Definir a região de estabilidade",
                            "description": "Explicar formalmente a região de estabilidade como o conjunto {z ∈ ℂ : |R(z)| ≤ 1}, onde z = hλ e R(z) é a função de amplificação polinomial ou racional do método numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Contexto de Estabilidade em Métodos Numéricos para EDOs",
                                  "subSteps": [
                                    "Revisar equações diferenciais lineares de teste y' = λy, onde λ ∈ ℂ.",
                                    "Explicar o comportamento assintótico da solução exata: y(t) = y(0) e^{λt}, estável se Re(λ) < 0.",
                                    "Discutir como métodos numéricos aproximam isso via iterações y_{n+1} = R(hλ) y_n.",
                                    "Analisar condições para que |y_n| não exploda: requer |R(hλ)| ≤ 1.",
                                    "Estudar o papel do passo de tempo h na escolha de λ simuláveis."
                                  ],
                                  "verification": "Escrever um parágrafo explicando por que estabilidade é necessária para simulações numéricas confiáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs lineares",
                                    "Livro de Análise Numérica (cap. Estabilidade)",
                                    "Calculadora ou software como Python/MATLAB"
                                  ],
                                  "tips": "Comece com λ real negativo para visualizar convergência exponencial.",
                                  "learningObjective": "Compreender a motivação para a região de estabilidade em métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir estabilidade numérica com estabilidade da EDO exata",
                                    "Ignorar o impacto de h pequeno vs. grande"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Função de Amplificação R(z)",
                                  "subSteps": [
                                    "Derivar a recursão numérica para y' = λy usando um método explícito (ex: Euler forward: y_{n+1} = y_n + hλ y_n).",
                                    "Identificar R(z) = 1 + z para Euler forward, onde z = hλ.",
                                    "Generalizar para métodos Runge-Kutta ou multistep: R(z) polinomial ou racional.",
                                    "Calcular |R(z)| para z pequeno e compará-lo com |e^z| da solução exata.",
                                    "Plotar R(z) no plano complexo para um método simples."
                                  ],
                                  "verification": "Derivar R(z) corretamente para pelo menos dois métodos (Euler forward e backward).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Software de plotagem complexa (ex: MATLAB complex plot ou Python matplotlib)",
                                    "Exemplos de métodos numéricos"
                                  ],
                                  "tips": "Use z = x + iy para visualizar magnitude no plano complexo.",
                                  "learningObjective": "Saber construir e interpretar a função de amplificação R(z).",
                                  "commonMistakes": [
                                    "Esquecer fatores h em multistep methods",
                                    "Confundir R(z) com a solução exata e^z"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir z = hλ e sua Interpretação",
                                  "subSteps": [
                                    "Explicar z = hλ como escalamento adimensional: h > 0, λ eigenvalue da matriz Jacobiana.",
                                    "Discutir como h pequeno mapeia λ para z próximo de 0, onde todos métodos são locais.",
                                    "Analisar para λ com Re(λ) < 0: z no semiplano esquerdo.",
                                    "Verificar estabilidade local: lim_{z→0} R(z) = 1 e R'(0) = 1 para consistência.",
                                    "Explorar como rigidez (Re(λ) << 0) requer h pequeno para z em região estável."
                                  ],
                                  "verification": "Calcular z para um exemplo dado: h=0.1, λ=-10 + 5i, e plotar no plano complexo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Plano complexo impresso ou digital",
                                    "Exemplos numéricos de EDOs rígidas"
                                  ],
                                  "tips": "Pense em z como 'passo efetivo' que determina se o método amplifica ou atenua.",
                                  "learningObjective": "Dominar a transformação z = hλ e seu significado físico.",
                                  "commonMistakes": [
                                    "Tratar hλ como escalar real em vez de complexo",
                                    "Subestimar o impacto de partes imaginárias em oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar e Interpretar a Região de Estabilidade",
                                  "subSteps": [
                                    "Definir formalmente S = {z ∈ ℂ : |R(z)| ≤ 1} como região de estabilidade absoluta.",
                                    "Interpretar: para z ∈ S, a solução numérica não diverge; fora, pode explodir.",
                                    "Comparar com o semiplano esquerdo {z : Re(z) ≤ 0} da solução exata.",
                                    "Plotar S para Euler forward (|1 + z| ≤ 1: disco centro -1 raio 1).",
                                    "Discutir A-estabilidade: S contém todo semiplano esquerdo."
                                  ],
                                  "verification": "Escrever a definição exata de S e esboçar para dois métodos diferentes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software para contorno |R(z)|=1 (ex: contour plot em Python)",
                                    "Tabela de regiões conhecidas"
                                  ],
                                  "tips": "Use software para visualizar; memorize disco de Euler.",
                                  "learningObjective": "Definir precisamente e interpretar graficamente a região de estabilidade.",
                                  "commonMistakes": [
                                    "Definir |R(z)| < 1 em vez de ≤1",
                                    "Confundir região com o conjunto onde método é preciso"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Aplicar a Definição em Exemplos",
                                  "subSteps": [
                                    "Testar um z dado: calcular R(z), |R(z)| e decidir se ∈ S.",
                                    "Analisar estabilidade condicional: max |hλ| para λ reais negativos.",
                                    "Comparar regiões de métodos explícitos vs. implícitos.",
                                    "Discutir implicações para escolha de h em problemas práticos.",
                                    "Resolver exercício: dada R(z), esboçar S."
                                  ],
                                  "verification": "Resolver 3 exercícios independentes de identificação de S.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exercícios resolvidos de análise numérica",
                                    "Python/MATLAB para verificação numérica"
                                  ],
                                  "tips": "Sempre verifique |R(z)| numericamente para pontos de fronteira.",
                                  "learningObjective": "Aplicar a definição para analisar estabilidade de métodos.",
                                  "commonMistakes": [
                                    "Ignorar singularidades em R(z) racional",
                                    "Confundir A-estabilidade com L-estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Euler forward aplicado a y' = -10y (λ=-10), com h=0.05, z=hλ=-0.5. R(z)=1+z=0.5, |R(z)|=0.5≤1 → estável. Se h=0.2, z=-2, R(z)=-1, |R(z)|=1≤1 → limite. Se h=0.3, z=-3, R(z)=-2, |R(z)|=2>1 → instável, simulação explode.",
                              "finalVerifications": [
                                "Definir corretamente S = {z ∈ ℂ : |R(z)| ≤ 1}.",
                                "Explicar z = hλ com exemplo numérico.",
                                "Derivar R(z) para Euler forward e backward.",
                                "Esboçar região para pelo menos um método.",
                                "Interpretar implicações para escolha de h em EDO rígida.",
                                "Comparar com semiplano esquerdo da exata.",
                                "Identificar se um método é A-estável."
                              ],
                              "assessmentCriteria": [
                                "Definição formal precisa (exata, sem erros notacionais).",
                                "Interpretação correta de z = hλ e |R(z)| ≤ 1.",
                                "Exemplos concretos com cálculos numéricos corretos.",
                                "Visualizações gráficas claras e rotuladas.",
                                "Análise de implicações práticas (ex: limite em h).",
                                "Generalização para métodos polinomiais/racionais.",
                                "Ausência de confusões comuns (ex: estabilidade vs. consistência)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações de dinâmica (ex: osciladores amortecidos).",
                                "Computação Científica: Implementação de solvers adaptativos em bibliotecas como SciPy.",
                                "Engenharia de Controle: Projeto de controladores discretos estáveis.",
                                "Processamento de Sinais: Filtros digitais e Z-transform (análoga a R(z)).",
                                "Matemática Aplicada: Teoria de perturbações em autovalores."
                              ],
                              "realWorldApplication": "Na simulação numérica de reações químicas rígidas ou previsão numérica do tempo, definir a região de estabilidade garante que o passo h permita resolver EDOs sem blow-up numérico, permitindo simulações eficientes e confiáveis em software como COMSOL ou modelos climáticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Interpretar o plano hλ",
                            "description": "Descrever o significado físico e matemático do produto hλ no plano complexo, relacionando-o à taxa de crescimento/decrescimento da solução exata e à estabilidade numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Solução Exata de EDOs Lineares",
                                  "subSteps": [
                                    "Revise a EDO teste y' = λ y, cuja solução exata é y(nh) = y(0) exp(λ n h).",
                                    "Analise o fator de amplificação exato exp(λ h), focando no módulo |exp(λ h)| = exp(Re(λ) h).",
                                    "Discuta casos: Re(λ) > 0 (crescimento exponencial), Re(λ) < 0 (decaimento), Re(λ) = 0 (oscilação).",
                                    "Relacione h (passo de tempo) ao controle da taxa de crescimento/decrescimento.",
                                    "Plote exemplos no plano complexo para λ variados."
                                  ],
                                  "verification": "Escreva e explique a solução exata para λ = -1 + i, identificando o comportamento físico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de EDOs lineares",
                                    "Software de plotagem (Matlab/Python)",
                                    "Livro de análise numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Use animações de soluções para visualizar crescimento/decrescimento.",
                                  "learningObjective": "Entender o significado físico do expoente λ h na dinâmica da solução exata.",
                                  "commonMistakes": [
                                    "Confundir parte real de λ com imaginária",
                                    "Ignorar dependência em h",
                                    "Esquecer normalização por y(0)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Construir o Plano hλ",
                                  "subSteps": [
                                    "Defina hλ como o produto escalar h vezes autovalor complexo λ, com h > 0.",
                                    "Posicione hλ no plano complexo: eixo real (Re(hλ) = h Re(λ)), eixo imaginário (Im(hλ) = h Im(λ)).",
                                    "Explique que hλ escala a 'direção' de λ pelo tamanho do passo h.",
                                    "Discuta limite h → 0: hλ → 0, aproximando consistência.",
                                    "Desenhe o plano hλ manualmente para λ fixo variando h."
                                  ],
                                  "verification": "Marque 3 pontos hλ no plano complexo e explique suas coordenadas para λ dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel quadriculado ou GeoGebra",
                                    "Exemplos de autovalores de matrizes Jacobianas"
                                  ],
                                  "tips": "Pense em hλ como 'vetor deslocamento' no plano de estabilidade.",
                                  "learningObjective": "Dominar a construção matemática do plano hλ como representação escalada de λ.",
                                  "commonMistakes": [
                                    "Usar hλ com h negativo",
                                    "Inverter eixos real/imaginário",
                                    "Confundir λ com hλ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar hλ à Taxa de Crescimento/Decrescimento Numérico",
                                  "subSteps": [
                                    "Para método numérico, fator de amplificação R(hλ) tal que y_{n+1} = R(hλ) y_n.",
                                    "Compare |R(hλ)| com |exp(λ h)|: idealmente |R(hλ)| ≈ exp(Re(λ) h) para grandes n.",
                                    "Analise: se |R(hλ)| > 1 e Re(λ) < 0, instabilidade (crescimento artificial).",
                                    "Estude trajetória de hλ ao variar h: movimento radial do origem.",
                                    "Calcule numericamente |R(hλ)| para Euler forward: R(z) = 1 + z."
                                  ],
                                  "verification": "Para hλ = -0.5 + 0.5i, compute |exp(hλ)| e |1 + hλ|, comparando comportamentos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/Matlab para cálculos complexos",
                                    "Tabela de fatores R para métodos comuns"
                                  ],
                                  "tips": "Sempre normalize por |exp(λ h)| para medir fidelidade.",
                                  "learningObjective": "Interpretar hλ como ponte entre dinâmica exata e numérica.",
                                  "commonMistakes": [
                                    "Comparar apenas módulos sem contexto de estabilidade",
                                    "Esquecer n grande para asymptótica",
                                    "Confundir R(hλ) com exp(hλ)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Estabilidade no Plano hλ",
                                  "subSteps": [
                                    "Defina região de estabilidade (ROS): {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Classifique pontos: dentro ROS (estável), fora (instável para n→∞).",
                                    "Relacione a soluções exatas: ROS contém disco esquerdo para A-estabilidade.",
                                    "Exemplo: Euler explícito ROS = disco |1+z|≤1; backward ilimitado no semiplano esquerdo.",
                                    "Teste pontos hλ em ROS para métodos dados."
                                  ],
                                  "verification": "Dado método e hλ, afirme estabilidade e justifique com |R(hλ)|.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagramas de ROS impressos",
                                    "Software para plotar ROS (ex: scikit-stability)"
                                  ],
                                  "tips": "Memorize ROS comuns: Euler (|z+1|≤1), Trapezoidal (semiplano esquerdo).",
                                  "learningObjective": "Avaliar estabilidade numérica via posicionamento de hλ na ROS.",
                                  "commonMistakes": [
                                    "Confundir ROS absoluta com relativa",
                                    "Ignorar direção de hλ (sempre Re(z)≤0 para rígidas)",
                                    "Plotar λ em vez de hλ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para EDO y' = (-1 + i) y (oscilador amortecido), com h=0.5, hλ = (-0.5 + 0.5i). Para Euler forward, R(hλ)=1 + hλ = 0.5 + 0.5i, |R|=√(0.5)≈0.707 <1, mas compare com |exp(hλ)|≈0.78; estável mas dissipativo. Aumente h=2, hλ=(-2+2i), |R|=| -1+2i |=√5>1, instável: solução numérica explode apesar de exata decaer.",
                              "finalVerifications": [
                                "Explica corretamente |exp(λ h)| como taxa exata de crescimento/decrescimento.",
                                "Posiciona hλ no plano complexo com coordenadas precisas.",
                                "Compara |R(hλ)| com comportamento esperado para estabilidade.",
                                "Identifica se hλ está dentro/fora da ROS para método dado.",
                                "Relaciona escolha de h à trajetória de hλ e viabilidade numérica.",
                                "Discute implicações físicas para sistemas reais (ex: amortecimento)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de hλ (20%)",
                                "Correta interpretação física do crescimento/decrescimento (25%)",
                                "Análise qualitativa/quantitativa de estabilidade via ROS (25%)",
                                "Uso de exemplos numéricos com cálculos complexos corretos (15%)",
                                "Clareza na relação entre exata e numérica (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou circuitos RLC via EDOs rígidas.",
                                "Engenharia: Simulações em controle automático (polos de realimentação).",
                                "Computação: Implementação de solvers ODE em bibliotecas como SciPy.",
                                "Física Computacional: Estabilidade em métodos Monte Carlo para difusão."
                              ],
                              "realWorldApplication": "Em modelagem climática (EDOs para atmosfera), hλ garante que perturbações numéricas não amplifiquem artificialmente furacões; em finanças, previne explosões em simulações de opções (equações Black-Scholes discretizadas)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Identificar estabilidade absoluta",
                            "description": "Diferenciar estabilidade absoluta (região contém o semi-eixo negativo) de estabilidade relativa, e explicar sua importância para problemas lineares com autovalores negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Estabilidade em Métodos Numéricos",
                                  "subSteps": [
                                    "Defina estabilidade relativa: propriedade onde o método é estável para hλ pequeno o suficiente, com |R(hλ)| ≤ 1.",
                                    "Defina estabilidade absoluta: o método é estável para todos h > 0 quando λ é real negativo (semi-eixo negativo no plano hλ).",
                                    "Desenhe o plano complexo hλ e destaque o semi-eixo negativo (Re(z) ≤ 0, Im(z)=0).",
                                    "Liste exemplos iniciais: Euler forward (relativa), Euler backward (absoluta).",
                                    "Compare estabilidade A-stável (contém semi-plano esquerdo) vs absoluta."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo e desenhe o plano complexo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora, notas de aula sobre métodos de Runge-Kutta.",
                                  "tips": "Use cores diferentes para semi-eixo negativo e região de estabilidade.",
                                  "learningObjective": "Compreender as definições fundamentais de estabilidade relativa e absoluta.",
                                  "commonMistakes": "Confundir estabilidade absoluta com A-estabilidade (que inclui semi-plano esquerdo inteiro)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Região de Estabilidade e o Semi-Eixo Negativo",
                                  "subSteps": [
                                    "Calcule a função de amplificação R(z) para um método simples (ex: Euler backward: R(z) = 1/(1-z)).",
                                    "Plote |R(z)| ≤ 1 no plano complexo e verifique se contém todo semi-eixo negativo.",
                                    "Identifique pontos no semi-eixo negativo (z = -a, a>0) e teste lim h→∞.",
                                    "Compare com método condicionalmente estável (ex: Euler forward: |1+z| ≤1).",
                                    "Crie uma tabela: método | contém semi-eixo? | absoluta?"
                                  ],
                                  "verification": "Gere gráfico ou tabela mostrando inclusão do semi-eixo negativo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como MATLAB/Python (Matplotlib ou SymPy), papel quadriculado.",
                                  "tips": "Teste valores extremos: z→0 e z→-∞ para confirmar.",
                                  "learningObjective": "Visualizar e verificar matematicamente a inclusão do semi-eixo negativo.",
                                  "commonMistakes": "Ignorar o limite h→∞, achando que basta checar pontos finitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Estabilidade Absoluta de Relativa em Exemplos",
                                  "subSteps": [
                                    "Pegue EDO y' = λy, λ<0 real; resolva analiticamente (y=Ce^{λt}).",
                                    "Aplique Euler forward e backward com h variando; observe oscilações para h grande.",
                                    "Classifique: absoluta se solução numérica decai monotonicamente para qualquer h>0.",
                                    "Crie fluxograma: dada R(z), contém semi-eixo neg? → absoluta sim/não.",
                                    "Discuta trade-offs: absoluta often mais dissipativa."
                                  ],
                                  "verification": "Simule numericamente e compare gráficos analítico vs numérico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/Jupyter com NumPy/SciPy, exemplos de EDOs lineares.",
                                  "tips": "Use h = 0.1, 1, 10 para demonstrar falha em relativa.",
                                  "learningObjective": "Diferenciar comportamentos numéricos entre os dois tipos de estabilidade.",
                                  "commonMistakes": "Confundir estabilidade para λ complexo com real negativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Importância para Problemas Lineares com Autovalores Negativos",
                                  "subSteps": [
                                    "Considere sistema y' = Ay, A com autovalores reais negativos (estável).",
                                    "Explique: absoluta permite h livre (eficiente para stiff problems).",
                                    "Dê exemplo stiff: reator químico com escalas rápidas/lentas.",
                                    "Compare tempo de computação: relativa precisa h pequeno → ineficiente.",
                                    "Resuma importância: escolha método absoluto para problemas reais estáveis."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) com exemplo e conclusão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos sobre stiff ODEs, exemplos de matrizes A.",
                                  "tips": "Relacione com Dahlquist's test equation y'=-y.",
                                  "learningObjective": "Entender implicações práticas na escolha de métodos numéricos.",
                                  "commonMistakes": "Subestimar impacto em problemas grandes (milhares de passos)."
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler em y' = -y: R(z) = 1/(1-z). Para z=-2 (hλ=-2), |R|=1/3<1; para z→-∞, R→0. Simulação: solução numérica decai sem oscilações para qualquer h, ao contrário do Forward Euler que explode para h>2.",
                              "finalVerifications": [
                                "Desenhar corretamente o semi-eixo negativo e região de estabilidade sobreposta.",
                                "Classificar 3 métodos (ex: RK4, Trapezoidal, Backward) como absoluta ou não.",
                                "Simular EDO y'=-50y com h=0.1 e h=1; verificar decaimento em absoluta.",
                                "Explicar verbalmente por que absoluta é crucial para autovalores grandes negativos.",
                                "Identificar em gráfico dado se região contém semi-eixo (sim/não + justificativa).",
                                "Listar 2 problemas reais onde absoluta é essencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de estabilidade absoluta vs relativa (90% correto).",
                                "Correção matemática na verificação do semi-eixo negativo (incluindo limites).",
                                "Qualidade de gráficos/simulações (clareza, escalas corretas).",
                                "Profundidade na explicação de importância para problemas lineares.",
                                "Número e relevância de exemplos práticos fornecidos.",
                                "Capacidade de diferenciar em fluxograma ou tabela."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo (EDOs stiff com autovalores negativos).",
                                "Engenharia de Controle: Estabilidade em sistemas lineares discretizados.",
                                "Computação Científica: Otimização de solvers em bibliotecas como SciPy/ODEPACK.",
                                "Química Computacional: Simulações de reações com escalas múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC (stiff devido a capacitores), métodos com estabilidade absoluta como Backward Euler ou BDF permitem passos de tempo grandes, reduzindo tempo computacional de horas para minutos em softwares como SPICE, garantindo precisão para autovalores negativos grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Região de Estabilidade para Métodos Explícitos e Implícitos",
                        "description": "Análise comparativa das regiões de estabilidade para métodos de passo simples (ex.: Euler explícito e implícito) e sua relação com restrições no passo de tempo h.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Calcular região para método de Euler explícito",
                            "description": "Derivar e plotar a região de estabilidade do método de Euler explícito, identificando o disco unitário centrado em -1 no plano z = hλ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método de Euler explícito e derivar o fator de amplificação",
                                  "subSteps": [
                                    "Lembre-se da equação teste y' = λ y, com solução exata y(t) = y0 e^{λ t}.",
                                    "Escreva a iteração do Euler explícito: y_{n+1} = y_n + h λ y_n = (1 + h λ) y_n.",
                                    "Identifique o fator de amplificação R(z) = 1 + z, onde z = h λ.",
                                    "Verifique que para estabilidade absoluta, requer |R(z)| ≤ 1 para todos os autovalores λ.",
                                    "Confirme que z pertence ao plano complexo."
                                  ],
                                  "verification": "Escreva corretamente R(z) = 1 + z e explique seu significado em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software simbólico como SymPy",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Comece sempre pela equação teste padrão para métodos de Runge-Kutta lineares.",
                                  "learningObjective": "Compreender o fator de amplificação como base para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito com implícito (R(z) = 1/(1 - z))",
                                    "Esquecer que z = h λ é complexo",
                                    "Ignorar a necessidade de |R(z)| ≤ 1 para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a condição de estabilidade |1 + z| ≤ 1",
                                  "subSteps": [
                                    "Escreva a desigualdade de estabilidade: |1 + z| ≤ 1.",
                                    "Expanda em coordenadas complexas: z = x + i y, então |1 + x + i y| = sqrt{(1 + x)^2 + y^2} ≤ 1.",
                                    "Eleve ao quadrado: (1 + x)^2 + y^2 ≤ 1.",
                                    "Simplifique: x^2 + 2x + 1 + y^2 ≤ 1 → x^2 + y^2 + 2x ≤ 0 → (x + 1)^2 + y^2 ≤ 1.",
                                    "Conclua que é o disco de raio 1 centrado em -1 + 0i."
                                  ],
                                  "verification": "Mostre algebricamente que a região é {(x,y) | (x + 1)^2 + y^2 ≤ 1}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para esboço",
                                    "Software de álgebra como Mathematica ou Python (NumPy/SymPy)",
                                    "Gráfica de complexos básica"
                                  ],
                                  "tips": "Use a propriedade |w|^2 = w * conj(w) para manipular desigualdades complexas.",
                                  "learningObjective": "Derivar matematicamente a fronteira da região de estabilidade.",
                                  "commonMistakes": [
                                    "Erro no quadrado: esquecer o +1 em (1 + x)^2",
                                    "Confundir centro em -1 com +1",
                                    "Não elevar ao quadrado corretamente preservando desigualdade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar geometricamente a região no plano z = hλ",
                                  "subSteps": [
                                    "Desenhe o plano complexo z com eixos Re(z) horizontal e Im(z) vertical.",
                                    "Marque o centro em z = -1 + 0i e raio unitário.",
                                    "Identifique pontos na fronteira: z = -1 + i (círculo passa por 0), z = -2, z = 0.",
                                    "Explique implicações: região esquerda do plano (Re(z) < 0) parcialmente coberta.",
                                    "Discuta por que métodos explícitos são limitados para λ com parte real negativa grande."
                                  ],
                                  "verification": "Esboce o disco e rotule centro, raio e origem corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel ou tablet de desenho",
                                    "Ferramenta online como Desmos ou GeoGebra para plano complexo"
                                  ],
                                  "tips": "Lembre-se: o disco toca a origem (estável para hλ pequeno) mas não vai além de Re(z) = -2.",
                                  "learningObjective": "Visualizar a região de estabilidade como um conjunto geométrico no plano complexo.",
                                  "commonMistakes": [
                                    "Desenhar círculo centrado em 0 em vez de -1",
                                    "Confundir raio 1 com outro valor",
                                    "Ignorar a parte imaginária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar a região e verificar com exemplo numérico",
                                  "subSteps": [
                                    "Use Python/MATLAB para plotar |1 + z| = 1 com contour ou circle plot.",
                                    "Escolha λ = -10 + 5i, compute z = h λ para h tal que |1 + z| ≤ 1.",
                                    "Simule Euler para esse λ e compare estabilidade.",
                                    "Gere gráfico final destacando o disco unitário centrado em -1.",
                                    "Anote limitações: passo h ≤ 2/|λ| para λ real negativo."
                                  ],
                                  "verification": "Produza um gráfico mostrando o disco e confirme |R(z)| ≤ 1 dentro dele.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Jupyter Notebook",
                                    "Exemplo de código base para fator de amplificação"
                                  ],
                                  "tips": "Use meshgrid para contourf: z = np.exp(1j * theta) - 1 para fronteira.",
                                  "learningObjective": "Aplicar computacionalmente a visualização da região de estabilidade.",
                                  "commonMistakes": [
                                    "Erro de escala no plot (raio não unitário)",
                                    "Plotar |z| ≤ 1 em vez de |z + 1| ≤ 1",
                                    "Não testar pontos fora da região"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -10 y com y(0)=1 usando Euler explícito, a região |1 + h*(-10)| ≤ 1 implica h ≤ 0.1. Plote z = h*(-10) dentro do disco centrado em -1; para h=0.2, z=-2 está na fronteira, oscilações começam.",
                              "finalVerifications": [
                                "Fator de amplificação R(z) = 1 + z está correto.",
                                "Desigualdade |1 + z| ≤ 1 deriva para (Re(z) + 1)^2 + Im(z)^2 ≤ 1.",
                                "Gráfico mostra disco de raio 1 centrado em -1 + 0i, tocando a origem.",
                                "Exemplo numérico confirma instabilidade fora da região.",
                                "Explicação liga z = hλ à estabilidade prática.",
                                "Identificação clara do 'disco unitário centrado em -1'."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (100% dos passos corretos).",
                                "Correção geométrica: centro, raio e fronteira exatos.",
                                "Qualidade do plot: legível, rotulado, com testes de pontos.",
                                "Profundidade da interpretação: implicações para h e λ.",
                                "Clareza na comunicação: explicações concisas e sem erros.",
                                "Uso adequado de ferramentas computacionais sem bugs."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Plotagem com Python/MATLAB (Ciência da Computação).",
                                "Física: Estabilidade em simulações de osciladores amortecidos.",
                                "Engenharia: Análise de métodos numéricos em controle de sistemas.",
                                "Álgebra Linear: Autovalores λ no plano complexo."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou modelagem financeira (ex: Black-Scholes PDE), garante escolha de h para evitar explosão numérica em equações com autovalores no semiplano esquerdo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Comparar regiões explícito vs. implícito",
                            "description": "Comparar as regiões de estabilidade do Euler explícito (limitada) e implícito (meio-plano esquerdo), explicando implicações para escolha de métodos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a região de estabilidade do método de Euler explícito",
                                  "subSteps": [
                                    "Lembre a fórmula de amplificação do Euler explícito: |1 + hλ| < 1 para estabilidade.",
                                    "Identifique que a região é um disco unitário centrado em -1 no plano complexo hλ.",
                                    "Plote ou descreva graficamente o disco limitado (raio 1, centro -1 + 0i).",
                                    "Discuta limitações: requer passo h pequeno para λ com parte real negativa grande.",
                                    "Exemplo numérico: teste com λ = -10, varie h para ver instabilidade."
                                  ],
                                  "verification": "Desenhe ou descreva corretamente o disco de estabilidade e demonstre instabilidade com h grande via cálculo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel gráfico, software como Python/MATLAB para plotar região, notas de aula sobre Euler explícito.",
                                  "tips": "Use o plano hλ com eixo real horizontal (negativo à esquerda) para visualização padrão.",
                                  "learningObjective": "Entender a forma limitada da região de estabilidade do Euler explícito.",
                                  "commonMistakes": "Confundir centro do disco (é -1, não 0); ignorar que é |1 + z| ≤ 1 onde z = hλ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a região de estabilidade do método de Euler implícito",
                                  "subSteps": [
                                    "Lembre a fórmula: resolver (I - hA)u^{n+1} = u^n, fator de amplificação 1/(1 - hλ).",
                                    "Determine estabilidade: |1/(1 - hλ)| ≤ 1 para Re(hλ) ≤ 0 (meio-plano esquerdo).",
                                    "Descreva graficamente: todo o semiplano esquerdo Re(z) ≤ 0 é estável para qualquer |h|.",
                                    "Compare tamanho: ilimitado vs. disco finito do explícito.",
                                    "Teste numérico: com λ = -10, h=1 mostra estabilidade."
                                  ],
                                  "verification": "Explique por que é estável no meio-plano esquerdo e prove com desigualdade |1/(1+z)| ≤1 para Re(z)≤0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmos do step 1, mais calculadora para fator de amplificação.",
                                  "tips": "Derive a condição de estabilidade algebricamente para fixar o conceito.",
                                  "learningObjective": "Compreender a estabilidade incondicional no meio-plano esquerdo para Euler implícito.",
                                  "commonMistakes": "Pensar que é instável para h grande; confundir com backward Euler (é o mesmo)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar diretamente as regiões de estabilidade",
                                  "subSteps": [
                                    "Sobreponha as regiões em um gráfico único: disco pequeno vs. semiplano infinito.",
                                    "Quantifique diferenças: explícito cobre apenas |z+1|≤1; implícito todo Re(z)≤0.",
                                    "Identifique problemas onde explícito falha: autovalores com |Re(λ)| grande (stiff).",
                                    "Calcule razão máxima h: para explícito h<2/|λ|, implícito ilimitado.",
                                    "Visualize com software: shade regiões e destaque sobreposição."
                                  ],
                                  "verification": "Produza um gráfico comparativo rotulando limites e diferenças chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Python com matplotlib, ou MATLAB), régua para esboço manual.",
                                  "tips": "Use cores diferentes: azul para explícito (limitado), verde para implícito (amplo).",
                                  "learningObjective": "Visualizar e quantificar as diferenças geométricas das regiões.",
                                  "commonMistakes": "Ignorar direção do semiplano (esquerdo para dissipativos); superestimar sobreposição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar implicações para escolha de métodos numéricos",
                                  "subSteps": [
                                    "Discuta trade-offs: explícito mais simples/rápido, mas condicionalmente estável.",
                                    "Implícito: estável para stiff, mas requer resolver sistema linear por passo.",
                                    "Critérios de escolha: se max|Re(λ)| grande, prefira implícito; senão explícito.",
                                    "Exemplo: EDOs de reações químicas stiff → implícito.",
                                    "Resuma: implícito para h fixo grande ou estabilidade prioritária."
                                  ],
                                  "verification": "Escreva um parágrafo justificando escolha para um problema hipotético stiff vs. não-stiff.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de problemas stiff, exemplos de EDOs reais.",
                                  "tips": "Pense em custo computacional: explícito O(n), implícito O(n^3) por passo se denso.",
                                  "learningObjective": "Aplicar comparação para decisões práticas em análise numérica.",
                                  "commonMistakes": "Subestimar custo do implícito; ignorar que explícito é A-estável só no disco."
                                }
                              ],
                              "practicalExample": "Considere a EDO u' = -100u + sin(t) (stiff). Implemente Euler explícito com h=0.05 (instável, oscila) vs. implícito com h=0.2 (estável, converge). Plote soluções e compare erros para demonstrar superioridade do implícito em problemas stiff.",
                              "finalVerifications": [
                                "Pode esboçar ambas regiões corretamente sem referência.",
                                "Explica verbalmente por que implícito é preferido para Re(λ)<<0.",
                                "Identifica corretamente o disco do explícito: centro -1, raio 1.",
                                "Calcula h_max para λ dado em ambos métodos.",
                                "Discute trade-off custo-estabilidade em contexto real.",
                                "Compara graficamente sobreposição das regiões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição geométrica das regiões (disco vs. semiplano).",
                                "Correção matemática das condições de estabilidade.",
                                "Profundidade na comparação quantitativa (ex: razões de h).",
                                "Clareza nas implicações práticas para escolha de método.",
                                "Qualidade do gráfico comparativo (rótulos, escalas).",
                                "Identificação correta de cenários stiff vs. não-stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de difusão/ondas (equações diferenciais PDEs).",
                                "Programação: Implementação em Python/NumPy para plotar regiões e testar EDOs.",
                                "Engenharia: Escolha de solvers em controle de sistemas stiff (ex: circuitos RC).",
                                "Estatística: Análise de erros numéricos em modelagem estocástica."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química, como reatores stiff, o Euler implícito permite passos de tempo maiores, reduzindo tempo computacional em 10x vs. explícito, essencial para otimização em tempo real de processos industriais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Analisar impacto em problemas stiff",
                            "description": "Explicar como regiões pequenas em métodos explícitos limitam h em problemas stiff (autovalores com partes reais grandes negativas), motivando métodos implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs com escalas temporais muito diferentes, caracterizados por autovalores com partes reais grandes negativas.",
                                    "Identifique componentes rápidos (decaimento rápido) e lentos em soluções stiff.",
                                    "Estude exemplos clássicos, como o modelo de Van der Pol ou reações químicas rígidas.",
                                    "Calcule autovalores de uma matriz Jacobiana simples para ilustrar rigidez.",
                                    "Discuta implicações para integração numérica: necessidade de passos adaptativos."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique autovalores em um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), calculadora ou Python/MATLAB para autovalores.",
                                  "tips": "Sempre relacione autovalores à rigidez via Lipschitz constante.",
                                  "learningObjective": "Compreender a origem matemática da rigidez em EDOs.",
                                  "commonMistakes": "Confundir stiff com não-lineares; ignorar que rigidez é sobre espectro de autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar região de estabilidade para métodos explícitos",
                                  "subSteps": [
                                    "Lembre o teste de estabilidade para EDOs lineares y' = λ y, com solução y_n = (1 + hλ)^n y_0.",
                                    "Desenhe a região de estabilidade absoluta para Euler explícito (|1 + z| ≤ 1, z = hλ).",
                                    "Analise o formato: disco unitário no semiplano esquerdo, pequeno para métodos de ordem baixa.",
                                    "Compare com Runge-Kutta explícitos: regiões maiores mas ainda limitadas no eixo negativo real.",
                                    "Calcule h_max para λ real negativo grande, mostrando h < 2/|λ| aproximadamente."
                                  ],
                                  "verification": "Plote ou descreva a região de estabilidade e calcule h_max para λ = -1000.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Desmos ou Python Matplotlib), notas de aula sobre RK.",
                                  "tips": "Use o plano z = hλ para visualizar; foque no eixo real negativo.",
                                  "learningObjective": "Mapear limitações geométricas da estabilidade explícita.",
                                  "commonMistakes": "Esquecer que região é para amplificação |R(z)| ≤ 1; confundir com precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impacto da rigidez em métodos explícitos",
                                  "subSteps": [
                                    "Para problema stiff com Re(λ) << 0, derive que h deve satisfazer |h λ| < 2 para estabilidade.",
                                    "Mostre que componentes stiff ditam h_min << 1/|λ_max|, desperdiçando computação em componentes lentos.",
                                    "Simule numericamente um problema stiff (ex: y' = -1000(y-1) + sin(t)) com h inadequado, observando oscilações.",
                                    "Calcule razão de custo: número de passos N ~ 1/(h_min) >> necessário para precisão.",
                                    "Discuta ineficiência: tempo de CPU explode para simulações longas."
                                  ],
                                  "verification": "Execute simulação mostrando instabilidade para h > 0.001 em λ=-1000.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Octave com solvers ode45/ode23s, exemplos de código para stiff ODEs.",
                                  "tips": "Compare erro vs. h em log-log para visualizar limitação de estabilidade.",
                                  "learningObjective": "Quantificar restrições impostas por regiões pequenas em stiff problems.",
                                  "commonMistakes": "Atribuir falha só a precisão, não estabilidade; usar h fixo sem adaptação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Motivar o uso de métodos implícitos",
                                  "subSteps": [
                                    "Introduza Euler implícito: y_{n+1} = y_n + h f(y_{n+1}), região |1/(1-z)| ≤ 1 (meio-plano esquerdo).",
                                    "Compare regiões: implícitos A-estáveis cobrem todo Re(z)<0, permitindo h maior.",
                                    "Discuta trade-offs: custo por passo maior (resolver sistema linear/não-linear), mas menos passos totais.",
                                    "Exemplo: BDF métodos (Backward Differentiation) para stiff, com ordem alta.",
                                    "Conclua motivação: eficiência em problemas com rigidez severa."
                                  ],
                                  "verification": "Descreva vantagem em h_max para implícito vs. explícito em stiff case.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabelas de regiões de estabilidade (Hairer livro), simulador online.",
                                  "tips": "Enfatize A-estabilidade: válido para qualquer h>0 em Re(λ)<0.",
                                  "learningObjective": "Justificar transição para implícitos via análise de estabilidade.",
                                  "commonMistakes": "Ignorar custo de Newton por passo; achar implícitos sempre melhores."
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - sin(t)) + cos(t), stiff devido a λ≈-1000. Euler explícito requer h<0.002 para estabilidade (10^6 passos em t=1-10), enquanto Backward Euler permite h=0.1 (10^4 passos), resolvendo Newton iterativamente, 100x mais rápido.",
                              "finalVerifications": [
                                "Explicar corretamente por que regiões pequenas limitam h em explícitos para stiff.",
                                "Calcular h_max preciso para dado λ negativo grande.",
                                "Simular e identificar instabilidade em explícito vs. estabilidade em implícito.",
                                "Derivar condição |1 + hλ| ≤1 para Euler explícito.",
                                "Discutir motivação quantitativa para implícitos (razão de passos).",
                                "Identificar autovalores stiff em um sistema 2x2 simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de regiões de estabilidade (geométrica e analítica).",
                                "Correta quantificação de h_min via autovalores (erro <10%).",
                                "Análise qualitativa/quantitativa do impacto em eficiência computacional.",
                                "Uso correto de terminologia (stiff, A-estável, Lipschitz).",
                                "Clareza em exemplos numéricos e plots.",
                                "Conexão lógica entre limitação explícita e motivação implícita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC stiff ou dinâmica molecular.",
                                "Engenharia: Controle de sistemas (polos dominantes negativos grandes).",
                                "Computação: Otimização de solvers em SciPy/ODEPACK.",
                                "Química: Cinética reacional rígida em combustão."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) ou reações químicas em reatores, problemas stiff surgem de escalas múltiplas; métodos implícitos como BDF permitem simulações real-time em aviões ou previsão climática, reduzindo tempo de computação de dias para horas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Extensão a Métodos de Passo Múltiplo",
                        "description": "Regiões de estabilidade para métodos lineares multistep (Adams-Bashforth, BDF), incluindo A-stabilidade e L-estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Definir A-estabilidade",
                            "description": "Definir métodos A-estáveis como aqueles cuja região de estabilidade contém o meio-plano esquerdo {z : Re(z) ≤ 0}, e identificar exemplos como trapezoidal e BDF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Estabilidade em Métodos Numéricos",
                                  "subSteps": [
                                    "Relembre a definição de região de estabilidade para métodos de Runge-Kutta ou lineares multistep.",
                                    "Entenda o teste de estabilidade para a equação modelo y' = λy, onde λ tem parte real negativa.",
                                    "Discuta por que a região de estabilidade é importante para equações rígidas.",
                                    "Desenhe um diagrama do plano complexo destacando o semi-plano esquerdo Re(z) ≤ 0.",
                                    "Identifique limitações de métodos explícitos na região de estabilidade."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é região de estabilidade e desenhe o semi-plano esquerdo corretamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Gráficos de regiões de estabilidade pré-computados"
                                  ],
                                  "tips": "Use cores diferentes para distinguir regiões estáveis e instáveis no plano complexo.",
                                  "learningObjective": "Compreender os fundamentos da estabilidade numérica como base para A-estabilidade.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com estabilidade para passos variáveis",
                                    "Ignorar a importância do semi-plano esquerdo para rigidez"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente A-Estabilidade",
                                  "subSteps": [
                                    "Leia a definição: Um método é A-estável se sua região de estabilidade contém todo o semi-plano {z ∈ ℂ | Re(z) ≤ 0}.",
                                    "Escreva a definição matemática usando notação de conjunto: S ⊇ {z : Re(z) ≤ 0}, onde S é a região de estabilidade.",
                                    "Explique intuitivamente: Permite passos de tempo grandes para equações com autovalores de parte real negativa.",
                                    "Derive brevemente a condição para métodos lineares implícitos.",
                                    "Compare com estabilidade incondicional no semi-plano negativo."
                                  ],
                                  "verification": "Escreva a definição exata e prove que o semi-plano esquerdo é relevante para rigidez.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib) para visualizar planos complexos"
                                  ],
                                  "tips": "Memorize a notação {z : Re(z) ≤ 0} e pratique escrevendo-a várias vezes.",
                                  "learningObjective": "Definir precisamente A-estabilidade e sua representação matemática.",
                                  "commonMistakes": [
                                    "Definir como contendo apenas o eixo imaginário",
                                    "Confundir com B-estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Analisar Exemplos de Métodos A-Estáveis",
                                  "subSteps": [
                                    "Analise o método trapezoidal: Mostre que sua função de amplificação R(z) satisfaz |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Estude métodos BDF (Backward Differentiation Formulas), especialmente BDF1 e BDF2, e confirme A-estabilidade.",
                                    "Plote ou descreva as regiões de estabilidade para trapezoidal e BDF.",
                                    "Verifique numericamente com um exemplo simples de y' = -y.",
                                    "Liste propriedades: Trapezoidal é A-estável e L-estável; BDF até ordem 2 são A-estáveis."
                                  ],
                                  "verification": "Forneça a função de amplificação para trapezoidal e argumente por que |R(z)| ≤ 1 no semi-plano esquerdo.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "MATLAB/Python para computar |R(z)|",
                                    "Tabelas de regiões de estabilidade de livros-textos"
                                  ],
                                  "tips": "Use o teorema de Dahquist para lembrar que métodos A-estáveis são implícitos.",
                                  "learningObjective": "Reconhecer e justificar exemplos clássicos de métodos A-estáveis.",
                                  "commonMistakes": [
                                    "Achar que métodos explícitos podem ser A-estáveis",
                                    "Errar a ordem máxima para BDF A-estáveis (ordem 2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar A-Estabilidade com Outros Conceitos e Aplicar",
                                  "subSteps": [
                                    "Compare com métodos não A-estáveis, como Euler explícito (região limitada).",
                                    "Introduza A(α)-estabilidade brevemente como extensão.",
                                    "Resolva um PVI rígido usando trapezoidal vs. explícito para demonstrar.",
                                    "Discuta trade-offs: Precisão vs. custo computacional.",
                                    "Resuma critérios para escolher métodos A-estáveis."
                                  ],
                                  "verification": "Compare regiões de estabilidade de pelo menos dois métodos e explique quando usar A-estáveis.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Solver numérico online ou software local",
                                    "Exemplos de EDOs rígidas"
                                  ],
                                  "tips": "Sempre teste com λ grande negativo para verificar estabilidade prática.",
                                  "learningObjective": "Diferenciar A-estabilidade de outros tipos e contextualizar seu uso.",
                                  "commonMistakes": [
                                    "Ignorar que A-estabilidade não garante precisão de ordem alta"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO y' = -1000y + sin(t), rígida devido ao termo -1000y. Implemente o método trapezoidal em Python: def trapezoidal(f, y0, t0, tf, h): ... e plote a solução para h=0.1, mostrando estabilidade mesmo com h grande, ao contrário do Euler explícito que diverge.",
                              "finalVerifications": [
                                "Define corretamente A-estabilidade usando notação de conjunto.",
                                "Identifica trapezoidal e BDF1/BDF2 como A-estáveis.",
                                "Explica a relevância para equações rígidas.",
                                "Desenha ou descreve a região de estabilidade cobrindo Re(z) ≤ 0.",
                                "Compara com um método não A-estável.",
                                "Aplica em um exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (100% dos elementos corretos).",
                                "Correta identificação de exemplos (pelo menos 3 métodos).",
                                "Demonstração visual ou argumento analítico da região.",
                                "Explicação clara da intuição e aplicações.",
                                "Ausência de erros comuns como confusão com estabilidade condicional.",
                                "Capacidade de resolver um PVI rígido estável."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de sistemas dissipativos (ex: amortecedores).",
                                "Engenharia: Controle de processos industriais com rigidez.",
                                "Computação: Otimização de solvers em bibliotecas como SciPy.",
                                "Química: Modelagem de reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC grandes ou modelos climáticos com rigidez, métodos A-estáveis como trapezoidal permitem passos de tempo maiores, reduzindo tempo computacional em software como COMSOL ou ANSYS sem perda de estabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Calcular região para método multistep",
                            "description": "Derivar a função de amplificação R(z) para um método linear multistep genérico e determinar sua região de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os polinômios característicos ρ(ζ) e σ(ζ) para um método linear multistep genérico",
                                  "subSteps": [
                                    "Estude a forma geral do método linear multistep (LMM): ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Defina o polinômio de diferença ρ(ζ) = ∑_{j=0}^k α_j ζ^j, com α_k = 1.",
                                    "Defina o polinômio de interpolação σ(ζ) = ∑_{j=0}^k β_j ζ^j.",
                                    "Verifique as condições de consistência: ρ(1)=0, ρ'(1)=σ(1).",
                                    "Escolha um exemplo concreto, como o método de Euler implícito (k=1)."
                                  ],
                                  "verification": "Escreva explicitamente ρ(ζ) e σ(ζ) para um método de ordem 2 e confirme as condições de consistência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno de anotações, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Sempre normalize com α_k=1 para evitar ambiguidades nas raízes.",
                                  "learningObjective": "Compreender a representação polinomial dos métodos LMM e suas propriedades básicas.",
                                  "commonMistakes": "Confundir os índices de j ou esquecer a normalização α_k=1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o método ao problema teste y' = λ y e derivar a equação característica",
                                  "subSteps": [
                                    "Substitua y_n = ζ^n na equação do LMM para o problema modelo y' = λ y.",
                                    "Obtenha a relação ∑ α_j ζ^{n+j} = z ∑ β_j ζ^{n+j}, onde z = h λ.",
                                    "Divida por ζ^n e simplifique para ρ(ζ) - z σ(ζ) = 0.",
                                    "Explique que as soluções ζ são as raízes dessa equação polinomial em z.",
                                    "Teste com k=1 (método de Euler) para verificar: ρ(ζ)=ζ-1, σ(ζ)=1, equação ζ-1 - z =0."
                                  ],
                                  "verification": "Derive a equação ρ(ζ) - z σ(ζ)=0 para um método genérico e resolva para z=0.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e lápis para derivação, software de álgebra simbólica (SymPy ou MATLAB Symbolic Toolbox).",
                                  "tips": "Mantenha o expoente n+j consistente ao dividir por ζ^n.",
                                  "learningObjective": "Dominar a derivação da equação característica para análise de estabilidade.",
                                  "commonMistakes": "Esquecer o fator h na definição de z = h λ ou errar os expoentes nas potências de ζ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e calcular a função de amplificação R(z)",
                                  "subSteps": [
                                    "Identifique R(z) como a raiz ζ(z) da equação ρ(ζ) - z σ(ζ)=0 que aproxima ζ=1 quando z→0 (raiz principal).",
                                    "Para métodos de ordem baixa, resolva explicitamente: ex, para Trapezoidal, resolva ζ -1 -z(ζ+1)/2=0.",
                                    "Use séries de potências ou métodos numéricos para aproximar R(z) perto de z=0.",
                                    "Verifique a ordem do método: R(z) = 1 + z + (1/2)z^2 + ... até a ordem desejada.",
                                    "Implemente uma função numérica para calcular as raízes ζ_i(z) para z dado."
                                  ],
                                  "verification": "Calcule R(z) para |z| pequeno e confirme que |R(0)|=1 e derivadas iniciais corretas.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Software de programação (Python com NumPy/SciPy ou MATLAB) para resolver polinômios.",
                                  "tips": "Use fsolve ou roots para encontrar todas as raízes e selecione a principal pela proximidade a 1.",
                                  "learningObjective": "Construir e validar a função de amplificação R(z) para LMM genéricos.",
                                  "commonMistakes": "Selecionar a raiz errada como principal; sempre plote |ζ_i(z)| para z pequeno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar as condições de estabilidade absoluta e delinear a região de estabilidade",
                                  "subSteps": [
                                    "Defina a região de estabilidade S = {z ∈ ℂ : todas ζ_i(z) satisfazem |ζ_i| ≤1, e se |ζ_i|=1 então raiz simples}.",
                                    "Para cada z, resolva ρ(ζ)-zσ(ζ)=0 e cheque max |ζ_i(z)| ≤1.",
                                    "Use critério de Schur para polinômios: todas raízes dentro do círculo unitário.",
                                    "Gere uma grade de z no plano complexo e compute o conjunto onde a condição holds.",
                                    "Plote a fronteira onde max |ζ_i(z)|=1."
                                  ],
                                  "verification": "Gere um plot da região de estabilidade para um método específico (ex: BDF2) e identifique se inclui o eixo negativo.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "MATLAB ou Python (Matplotlib + NumPy) para contour plots, exemplos de código de livros de análise numérica.",
                                  "tips": "Use contourf para visualizar {z: max|ζ_i| -1 <=0}, refine a grade perto da fronteira.",
                                  "learningObjective": "Analisar e visualizar numericamente a região de estabilidade de métodos LMM.",
                                  "commonMistakes": "Ignorar raízes múltiplas na fronteira; sempre cheque multiplicidade com derivadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar a região de estabilidade para aplicações práticas",
                                  "subSteps": [
                                    "Compare a região com métodos one-step (ex: Runge-Kutta) e discuta A-stabilidade.",
                                    "Analise o comportamento para z real negativo (rigidez).",
                                    "Teste estabilidade numérica simulando y'=λy com λ negativo grande.",
                                    "Discuta limitações para métodos multistep (ex: ordem alta reduz a região).",
                                    "Documente achados em um relatório com plots e conclusões."
                                  ],
                                  "verification": "Simule uma EDO rígida e confirme que hλ está dentro da região calculada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Solver numérico (ODE45 em MATLAB ou solve_ivp em SciPy), exemplos de EDOs rígidas.",
                                  "tips": "Escolha |λ| grande negativo para testar; compare erros com h dentro/fora da região.",
                                  "learningObjective": "Interpretar a região de estabilidade em contextos de simulação real.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; foque em |ζ|<=1 para zero-stability."
                                }
                              ],
                              "practicalExample": "Para o método BDF2: (3/2)y_{n+2} - 2 y_{n+1} + (1/2) y_n = h f_{n+2}. Então ρ(ζ)=(3/2)ζ^2 -2ζ +1/2, σ(ζ)=ζ^2. Resolva (3/2)ζ^2 -2ζ +1/2 - z ζ^2=0. Plote a região: um setor no semiplano esquerdo, útil para problemas rígidos.",
                              "finalVerifications": [
                                "Derivação correta de ρ(ζ) e σ(ζ) para método dado.",
                                "Equação característica ρ(ζ)-zσ(ζ)=0 obtida sem erros.",
                                "Função R(z) aproximada corretamente perto de z=0.",
                                "Plot da região de estabilidade com fronteira precisa.",
                                "Condições de raízes simples na fronteira verificadas.",
                                "Simulação numérica confirma estabilidade dentro da região."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de polinômios ρ e σ (100% coeficientes corretos).",
                                "Correção da equação característica e raízes ζ(z).",
                                "Qualidade do plot da região (resolução fina, legenda clara).",
                                "Análise qualitativa: A-estável? Inclui semiplano esquerdo?",
                                "Validação via simulação (gráficos de erro vs h).",
                                "Relatório completo com interpretações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers em Python/MATLAB.",
                                "Física: Estabilidade em simulações de dinâmica (ex: osciladores rígidos).",
                                "Engenharia Computacional: Análise de CFD e problemas diferenciais rígidos.",
                                "Álgebra Linear: Critérios de Schur e autovalores de companion matrices."
                              ],
                              "realWorldApplication": "Em software de simulação como COMSOL ou ANSYS para EDOs rígidas em engenharia química (reatores) e aeroespacial (órbitas), onde métodos multistep como BDF são usados para eficiência em passos grandes sem perda de estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Estabilidade Zero",
                    "description": "Condição das raízes da equação característica para métodos de passo múltiplo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Métodos de Passo Múltiplo",
                        "description": "Métodos numéricos lineares multistep para resolver problemas de valor inicial, utilizando valores anteriores para aproximar a solução da EDO.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir métodos de passo múltiplo",
                            "description": "Explicar a forma geral dos métodos lineares multistep (LMM) dada por ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}), identificando os coeficientes α e β.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto dos métodos numéricos para EDOs",
                                  "subSteps": [
                                    "Revise o problema de valor inicial (PVI) para equações diferenciais ordinárias (EDOs): y' = f(t, y), y(t0) = y0.",
                                    "Diferencie métodos de passo único (ex: Euler, Runge-Kutta) de métodos de passo múltiplo, que usam múltiplos pontos anteriores.",
                                    "Identifique a necessidade de métodos multistep para eficiência em problemas stiff ou de longa integração.",
                                    "Estude a discretização temporal: yn+j ≈ y(tn+j).",
                                    "Compare com métodos explícitos e implícitos em termos de história computacional."
                                  ],
                                  "verification": "Escreva uma definição clara do PVI e liste 2 vantagens dos métodos multistep sobre os de passo único.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), slides de aula sobre EDOs.",
                                  "tips": "Use diagramas de timeline para visualizar pontos tn, tn+1, ..., tn+k.",
                                  "learningObjective": "Entender o problema e a motivação para métodos lineares multistep (LMM).",
                                  "commonMistakes": "Confundir multistep com multi-estágio (Runge-Kutta usa estágios internos, não história)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Apresentar a forma geral dos métodos lineares multistep (LMM)",
                                  "subSteps": [
                                    "Escreva a fórmula geral: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Explique o lado esquerdo como combinação linear das aproximações futuras e passadas.",
                                    "Explique o lado direito como combinação linear das derivadas escaladas pelo passo h.",
                                    "Classifique como explícito (β_k = 0) ou implícito (β_k ≠ 0).",
                                    "Derive intuitivamente para k=1 (método de Euler implícito/explícito)."
                                  ],
                                  "verification": "Reescreva a fórmula geral de memória e classifique um método simples como explícito ou implícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, calculadora, software como MATLAB para plotar timelines.",
                                  "tips": "Memorize a estrutura somatória; pratique escrevendo para k=2.",
                                  "learningObjective": "Memorizar e reproduzir a forma geral dos LMM.",
                                  "commonMistakes": "Esquecer o índice j=0 a k ou inverter os lados da equação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e interpretar os coeficientes α_j e β_j",
                                  "subSteps": [
                                    "Defina α_j como coeficientes da combinação linear das y_{n+j} (polinômio de diferença finita).",
                                    "Defina β_j como coeficientes da combinação linear das f(t_{n+j}, y_{n+j}) (aproximação da integral).",
                                    "Note que ∑ α_j = 0 para consistência de ordem 1.",
                                    "Exemplo: Para Adams-Bashforth de ordem 2, α_0=-1, α_1=1, β_0=0, β_1=3/2, β_2=-1/2.",
                                    "Discuta como coeficientes determinam ordem, estabilidade e precisão."
                                  ],
                                  "verification": "Dado um conjunto de coeficientes, escreva a equação LMM correspondente e identifique se é explícito.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela de métodos multistep padrão, papel para tabelas de coeficientes.",
                                  "tips": "Use tabelas para listar α e β; verifique somas para consistência.",
                                  "learningObjective": "Reconhecer o papel exato de α_j e β_j na fórmula.",
                                  "commonMistakes": "Confundir α com β ou ignorar normalização (∑ α_j = 0)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar propriedades iniciais dos LMM",
                                  "subSteps": [
                                    "Defina ordem p: erro local O(h^{p+1}), via expansão de Taylor.",
                                    "Condições de consistência: ∑ α_j = 0 e ∑ j α_j - ∑ β_j = 0.",
                                    "Discuta geração de pontos iniciais (usando Runge-Kutta).",
                                    "Introduza o polinômio de característica ρ(ζ) = ∑ α_j ζ^j e σ(ζ) = ∑ β_j ζ^j.",
                                    "Verifique consistência para um método exemplo."
                                  ],
                                  "verification": "Calcule a ordem de um LMM simples e verifique consistência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software simbólico (SymPy ou Mathematica) para expansões Taylor.",
                                  "tips": "Comece com métodos de baixa ordem (k=1,2) para praticar.",
                                  "learningObjective": "Ligar coeficientes a propriedades como ordem e consistência.",
                                  "commonMistakes": "Esquecer condições de consistência ou confundir ordem local com global."
                                }
                              ],
                              "practicalExample": "Para o método de Adams-Bashforth de ordem 2: α_0 = -1, α_1 = 1, β_0 = 0, β_1 = 3/2, β_2 = -1/2. A equação é y_{n+2} - y_{n+1} = h (3/2 f_{n+1} - 1/2 f_n), usado para integrar y' = -y numericamente de t=0 a t=10.",
                              "finalVerifications": [
                                "Reproduzir a fórmula geral dos LMM de memória.",
                                "Identificar α_j e β_j em um método dado (ex: Backward Euler).",
                                "Classificar um LMM como explícito ou implícito.",
                                "Explicar o papel dos coeficientes na discretização.",
                                "Verificar consistência básica para k=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escrita da fórmula geral (100% dos símbolos corretos).",
                                "Correta identificação e interpretação de α_j e β_j (exemplos fornecidos).",
                                "Classificação explícito/implícito com justificativa.",
                                "Compreensão de motivação e contexto (vantagens sobre passo único).",
                                "Aplicação em exemplo prático sem erros aritméticos.",
                                "Uso correto de terminologia (LMM, consistência, ordem)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar LMM em Python/MATLAB para simulações.",
                                "Física: Aplicar em equações de movimento ou circuitos RLC.",
                                "Computação Científica: Análise de estabilidade via método das raízes.",
                                "Estatística: Integração numérica em processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos ECMWF usam multistep para eficiência em grids grandes), previsão financeira (soluções de EDOs em opções), engenharia aeroespacial (tra jetórias de foguetes) e biologia computacional (modelos populacionais)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Classificar métodos de passo múltiplo",
                            "description": "Distinguir entre métodos explícitos (β_k = 0) e implícitos (β_k ≠ 0), e entre consistentes e de ordem k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral dos métodos de passo múltiplo",
                                  "subSteps": [
                                    "Estude a equação geral: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}",
                                    "Identifique os coeficientes α_j (para y) e β_j (para f)",
                                    "Revise exemplos clássicos como Adams-Bashforth e Adams-Moulton",
                                    "Anote as condições de ordem p: ∑ α_j = 0 e ∑ j α_j = 1 para consistência",
                                    "Pratique reescrevendo métodos lineares multistep (LMM) em notação padrão"
                                  ],
                                  "verification": "Escreva a forma geral de um método multistep de ordem 2 e liste seus coeficientes corretamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), notas de aula sobre EDOs",
                                  "tips": "Use tabelas para organizar coeficientes α e β de métodos conhecidos",
                                  "learningObjective": "Dominar a notação padrão e identificar componentes chave dos métodos multistep",
                                  "commonMistakes": "Confundir α_j com β_j ou inverter o índice de soma"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Distinguir métodos explícitos de implícitos",
                                  "subSteps": [
                                    "Defina método explícito: β_k = 0 (não depende de f_{n+k})",
                                    "Defina método implícito: β_k ≠ 0 (requer solução de equação não linear)",
                                    "Compare Adams-Bashforth (explícito, β_k=0) vs Adams-Moulton (implícito, β_k≠0)",
                                    "Calcule β_k para métodos de ordem baixa (1 a 3)",
                                    "Classifique 3 exemplos dados manualmente"
                                  ],
                                  "verification": "Classifique corretamente 5 métodos como explícito ou implícito justificando com β_k",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela de coeficientes de métodos Runge-Kutta multistep, calculadora ou Python para verificação",
                                  "tips": "Sempre verifique o último coeficiente β_k; ignore os anteriores para esta distinção",
                                  "learningObjective": "Identificar univocamente explícitos vs implícitos baseado em β_k",
                                  "commonMistakes": "Assumir implícito só se todos β_j ≠0; foque apenas em β_k"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar consistência dos métodos",
                                  "subSteps": [
                                    "Recapitule consistência: ordem p ≥1, i.e., ∑_{j=0}^k α_j = 0 e ∑_{j=0}^k j α_j = 1",
                                    "Verifique as condições de consistência para métodos dados",
                                    "Diferencie métodos consistentes de inconsistentes com exemplos",
                                    "Prove consistência para Adams-Bashforth de ordem 1",
                                    "Liste implicações da inconsistência (erro de truncamento não controlado)"
                                  ],
                                  "verification": "Verifique consistência de 4 métodos e explique falhas se houver",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de fórmulas de análise numérica, software SymPy para somas simbólicas",
                                  "tips": "Use expansão em série de Taylor para validar condições sem cálculo manual extenso",
                                  "learningObjective": "Avaliar se um método é consistente usando condições padrão",
                                  "commonMistakes": "Esquecer a segunda condição (∑ j α_j =1); testar apenas p=0"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a ordem k do método",
                                  "subSteps": [
                                    "Defina ordem k: maior p tal que condições de ordem p são satisfeitas até p=k",
                                    "Calcule ordem para métodos multistep conhecidos (ex: AB2 ordem 2, AM3 ordem 3)",
                                    "Use método de Butcher para tabelas de ordem",
                                    "Classifique completamente: explícito/implícito + consistente + ordem",
                                    "Resolva exercícios de classificação mista"
                                  ],
                                  "verification": "Classifique integralmente 3 métodos desconhecidos com justificativa completa",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exercícios de livro-texto, MATLAB ou Python com sympy para ordens",
                                  "tips": "Comece com ordem 1 e incremente até falhar nas condições",
                                  "learningObjective": "Calcular e classificar a ordem exata de um método multistep",
                                  "commonMistakes": "Confundir ordem local com global; ignorar β_j em ordens altas"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar classificação integrada e revisar",
                                  "subSteps": [
                                    "Compile uma tabela de 10 métodos com classificações",
                                    "Resolva problemas de estabilidade zero envolvendo classificação",
                                    "Discuta vantagens/desvantagens (explícitos mais rápidos, implícitos mais estáveis)",
                                    "Auto-teste com quiz de classificação rápida",
                                    "Reflita sobre aplicações em estabilidade A-stável"
                                  ],
                                  "verification": "Crie e responda um quiz de 10 itens com 100% acerto",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabelas, flashcards Anki",
                                  "tips": "Agrupe métodos por família (Adams, BDF) para memorização",
                                  "learningObjective": "Aplicar classificação de forma fluida em contextos de estabilidade",
                                  "commonMistakes": "Sobrepor classificações sem verificar todas as dimensões (expl/implic + consist + ordem)"
                                }
                              ],
                              "practicalExample": "Classifique o método: y_{n+2} - (3/2)y_{n+1} + (1/2)y_n = h (23/12 f_{n+2} - 16/12 f_{n+1} + 5/12 f_n). Resposta: Implícito (β_2=23/12 ≠0), consistente (ver condições), ordem 2 (satisfaz até p=2).",
                              "finalVerifications": [
                                "Classifica corretamente β_k=0 como explícito em 5 exemplos",
                                "Verifica consistência com somas exatas para 4 métodos",
                                "Determina ordem k precisa para métodos de ordem ≤4",
                                "Integra todas classificações sem erros em quiz de 10 itens",
                                "Explica implicações para estabilidade zero",
                                "Distingue Adams-Bashforth vs Moulton em aplicações práticas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de β_k (>95%)",
                                "Correta aplicação de condições de consistência (100%)",
                                "Cálculo de ordem com tabela de coeficientes válida",
                                "Justificativas matemáticas completas e concisas",
                                "Integração de conceitos em exemplos reais",
                                "Tempo de resposta em classificações rápidas <2min por método"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers explícitos/implícitos em Python (SciPy)",
                                "Física: Simulações de osciladores em dinâmica (EDOs rígidas)",
                                "Engenharia: Controle de sistemas com métodos implícitos para estabilidade",
                                "Computação Científica: Otimização de solvers em MATLAB ode23s/ode15s"
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos ECMWF usam multistep implícitos para estabilidade em EDOs rígidas) e finanças (preços de opções via métodos consistentes de alta ordem para precisão em trajetórias estocásticas)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Aplicar método de passo múltiplo simples",
                            "description": "Implementar numericamente um método como Adams-Bashforth de ordem 2 para resolver y' = f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Problema e Recordar a Fórmula do Método",
                                  "subSteps": [
                                    "Defina a equação diferencial y' = f(t, y) com condição inicial y(t0) = y0.",
                                    "Escolha o passo h e o intervalo [t0, tf].",
                                    "Recorde a fórmula de Adams-Bashforth ordem 2: y_{n+1} = y_n + (h/2) * (3 f(t_n, y_n) - f(t_{n-1}, y_{n-1})).",
                                    "Identifique a necessidade de pelo menos dois pontos iniciais (y0 e y1).",
                                    "Planeje usar um método single-step (ex: Euler ou RK4) para y1."
                                  ],
                                  "verification": "Verifique se a fórmula está corretamente anotada e o problema bem definido em uma tabela inicial com colunas t, y, f(t,y).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, tabela de referência de fórmulas numéricas.",
                                  "tips": "Anote a fórmula em negrito para consulta rápida durante cálculos.",
                                  "learningObjective": "Compreender os requisitos e a estrutura do método de passo múltiplo ordem 2.",
                                  "commonMistakes": "Confundir o coeficiente (h/2 ao invés de h) ou esquecer que precisa de y_{n-1}."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os Pontos Iniciais y0 e y1",
                                  "subSteps": [
                                    "Calcule y0 = y(t0) diretamente da condição inicial.",
                                    "Use o método de Euler para y1: y1 = y0 + h * f(t0, y0).",
                                    "Compute f(t0, y0) e preencha a tabela.",
                                    "Calcule f(t1, y1) para uso futuro.",
                                    "Verifique numericamente se os valores iniciais fazem sentido (ex: sinal correto)."
                                  ],
                                  "verification": "Confira cálculos aritméticos duplamente e compare com solução exata aproximada se conhecida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, papel para tabela (t | y | f(t,y)).",
                                  "tips": "Use precisão de 4 casas decimais para evitar erros de arredondamento acumulados.",
                                  "learningObjective": "Dominar o cálculo de pontos iniciais precisos para inicializar métodos multi-step.",
                                  "commonMistakes": "Erro no cálculo de f(t0,y0) ou uso incorreto de h no Euler."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Método para Passos Subsequentes",
                                  "subSteps": [
                                    "Para n=1, compute y2 = y1 + (h/2)*(3*f(t1,y1) - f(t0,y0)).",
                                    "Preencha f(t2,y2) e avance para y3 = y2 + (h/2)*(3*f(t2,y2) - f(t1,y1)).",
                                    "Continue iterativamente até atingir tf, registrando todos os valores na tabela.",
                                    "Monitore o número de passos necessários: N = (tf - t0)/h.",
                                    "Registre pelo menos 5 passos para prática."
                                  ],
                                  "verification": "Cada y_{n+1} deve ser calculado e f(t_{n+1}, y_{n+1}) computado imediatamente após.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela expandida, calculadora para multiplicações repetitivas.",
                                  "tips": "Crie uma coluna auxiliar para os termos (3f_n - f_{n-1}) para agilizar.",
                                  "learningObjective": "Implementar corretamente a recursão multi-step numericamente.",
                                  "commonMistakes": "Usar índices errados (confundir f_n com f_{n-1}) ou propagar erros aritméticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Verificar Estabilidade",
                                  "subSteps": [
                                    "Compare com solução exata se disponível (ex: erro local/truncamento).",
                                    "Plote ou tabule y_num vs t e observe comportamento (oscilações?).",
                                    "Calcule erro global aproximado em pontos conhecidos.",
                                    "Teste com h diferente para verificar convergência de ordem 2.",
                                    "Conclua sobre estabilidade zero para o problema linear."
                                  ],
                                  "verification": "Erro deve decrescer com h menor; sem divergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráfico manual ou software como Excel/Python para plotagem.",
                                  "tips": "Para estabilidade, escolha f(t,y) com Lipschitz constante pequeno.",
                                  "learningObjective": "Avaliar precisão e estabilidade do método aplicado.",
                                  "commonMistakes": "Ignorar erros acumulados ou não testar com h variado."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 (solução exata y=e^{-2t}) de t=0 a 0.4 com h=0.1. y0=1, f(0,1)=-2. y1=Euler:1 +0.1*(-2)=0.8. f1=-1.6. y2=0.8 +0.05*(3*(-1.6)-(-2))=0.8 +0.05*(-4.8+2)=0.8-0.14=0.66. Continue até y4≈0.4493 (exato y(0.4)≈0.4493).",
                              "finalVerifications": [
                                "Tabela completa com t, y_n, f_n sem lacunas ou erros aritméticos.",
                                "Pelo menos 4 passos computados corretamente.",
                                "Comparação com solução exata mostra erro <1% em tf.",
                                "Fórmula aplicada consistentemente sem variação nos coeficientes.",
                                "Comportamento estável: y_n não explode ou oscila.",
                                "Teste com h/2 confirma ordem de precisão 2 (erro ~1/4)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e aplicação da fórmula AB2 (peso 30%).",
                                "Correção nos cálculos numéricos iniciais e iterativos (peso 25%).",
                                "Análise de erro e estabilidade documentada (peso 20%).",
                                "Clareza na tabela e verificações (peso 15%).",
                                "Generalização para problemas semelhantes (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python loop para automação.",
                                "Física: Modelagem de decaimento radioativo ou circuitos RC.",
                                "Computação Científica: Integração em bibliotecas como SciPy.",
                                "Estatística: Análise de erro numérico como incerteza."
                              ],
                              "realWorldApplication": "Simulações de trajetórias em engenharia aeroespacial, previsão de populações em ecologia, ou modelagem financeira de juros compostos com taxas variáveis, onde métodos eficientes multi-step aceleram computações em grandes intervalos de tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Equação Característica",
                        "description": "Polinômio associado aos métodos multistep que determina o comportamento assintótico da solução numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Derivar a equação característica",
                            "description": "Obter o polinômio de primeira característica ρ(ζ) = ∑_{j=0}^k α_j ζ^j a partir dos coeficientes do método multistep.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os coeficientes α_j do método multistep",
                                  "subSteps": [
                                    "Ler a definição formal do método multistep linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}",
                                    "Listar explicitamente todos os coeficientes α_0, α_1, ..., α_k a partir da documentação ou formulação do método",
                                    "Confirmar o número total de passos k (grau do polinômio)",
                                    "Verificar se os coeficientes estão normalizados (ex.: α_k = 1)",
                                    "Anotar os índices corretamente, associando α_j ao termo y_{n+j}"
                                  ],
                                  "verification": "Lista completa e correta dos α_j escrita em uma tabela ou equação",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição do método multistep (livro de análise numérica, notas de aula)",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre priorize a formulação exata do método; coeficientes α referem-se à aproximação da derivada, não à integração",
                                  "learningObjective": "Compreender a origem e notação dos coeficientes de avanço no método multistep",
                                  "commonMistakes": "Confundir coeficientes α_j (polinômio de primeira característica) com β_j (polinômio de segunda característica); inverter índices"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a equação recursiva homogênea",
                                  "subSteps": [
                                    "Escrever a equação geral do método: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(y_{n+j})",
                                    "Para análise de estabilidade zero, considerar a parte homogênea: ∑_{j=0}^k α_j y_{n+j} = 0 (ignorando termos f)",
                                    "Explicar que isso modela o comportamento livre da solução numérica",
                                    "Dividir toda a equação por y_n para normalizar em termos relativos",
                                    "Preparar para introduzir a forma exponencial assumida"
                                  ],
                                  "verification": "Equação homogênea ∑_{j=0}^k α_j y_{n+j} = 0 escrita corretamente",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Folha de rascunho",
                                    "Exemplo de método multistep específico"
                                  ],
                                  "tips": "Lembre-se: estabilidade zero foca no operador de avanço, sem forçantes",
                                  "learningObjective": "Distinguir a recursão completa da forma homogênea para estabilidade",
                                  "commonMistakes": "Incluir erroneamente os termos h β_j f na análise de estabilidade zero; não dividir por y_n"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a ansatz exponencial y_m = ζ^m",
                                  "subSteps": [
                                    "Assumir solução de modo puro: y_{n+j} = ζ^{n+j} para todo j",
                                    "Substituir na equação homogênea: ∑_{j=0}^k α_j ζ^{n+j} = 0",
                                    "Fatorar ζ^n comum: ζ^n ∑_{j=0}^k α_j ζ^j = 0",
                                    "Como ζ^n ≠ 0 (exceto ζ=0 trivial), obter ∑_{j=0}^k α_j ζ^j = 0",
                                    "Verificar que ζ=0 não é raiz relevante para estabilidade"
                                  ],
                                  "verification": "Equação característica ∑_{j=0}^k α_j ζ^j = 0 derivada corretamente",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simbólica opcional (ex.: Mathematica, papel)",
                                    "Notas da Step 1 e 2"
                                  ],
                                  "tips": "A transformação ζ = e^{λ h} liga à estabilidade absoluta, mas foque em zero por agora",
                                  "learningObjective": "Derivar a equação característica via separação de variáveis exponenciais",
                                  "commonMistakes": "Esquecer de fatorar ζ^n; tratar ζ^n como zero; confundir com polinômio σ(ζ) dos β_j"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e explicitar o polinômio ρ(ζ)",
                                  "subSteps": [
                                    "Definir formalmente ρ(ζ) = ∑_{j=0}^k α_j ζ^j",
                                    "Escrever o polinômio expandido com todos os termos: α_0 + α_1 ζ + ... + α_k ζ^k",
                                    "Verificar propriedades básicas: grau k, coeficiente líder α_k ≠ 0",
                                    "Testar consistência: ρ(1) = 0 para métodos consistentes (ordem pelo menos 1)",
                                    "Simplificar se possível e anotar a equação ρ(ζ) = 0"
                                  ],
                                  "verification": "Polinômio ρ(ζ) escrito na forma padrão ∑_{j=0}^k α_j ζ^j com valores corretos",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resultados das steps anteriores",
                                    "Software de álgebra computacional para verificação (opcional)"
                                  ],
                                  "tips": "Normalmente α_k = 1; expanda explicitamente para métodos de baixa ordem",
                                  "learningObjective": "Formalizar o polinômio de primeira característica e suas propriedades",
                                  "commonMistakes": "Erro nos sinais dos α_j ao somar; grau incorreto; esquecer termo constante"
                                }
                              ],
                              "practicalExample": "Para o método Backward Difference de 2 passos: α_0 = 1, α_1 = -3, α_2 = 2. A recursão homogênea é 2 y_{n+2} - 3 y_{n+1} + y_n = 0. Assumindo y_{n+j} = ζ^{n+j}, obtemos ζ^n (2 ζ^2 - 3 ζ + 1) = 0, logo ρ(ζ) = 2ζ^2 - 3ζ + 1 = (2ζ - 1)(ζ - 1).",
                              "finalVerifications": [
                                "ρ(ζ) tem exatamente grau k com coeficiente líder α_k ≠ 0",
                                "Todos os coeficientes α_j correspondem aos do método original",
                                "ρ(1) = 0 se o método for consistente (verificação de ordem 1)",
                                "Equação ρ(ζ) = 0 produz as raízes de crescimento da solução numérica",
                                "Substituição inversa: recuperar a recursão a partir de ρ(ζ)"
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa e completa dos α_j (20%)",
                                "Derivação correta da equação homogênea (20%)",
                                "Aplicação bem-sucedida da ansatz exponencial (25%)",
                                "Definição formal e expansão exata de ρ(ζ) (25%)",
                                "Verificações de propriedades (grau, ρ(1)=0) (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar análise de raízes de ρ(ζ) em Python com NumPy/roots para visualização de regiões de estabilidade",
                                "Física: Aplicar em esquemas de diferenças finitas para equações de onda ou difusão, analisando modos espúrios",
                                "Engenharia Computacional: Avaliar estabilidade em solvers de EDOs para simulações CFD ou controle de sistemas",
                                "Estatística: Estudar autocorrelação em séries temporais numéricas discretizadas"
                              ],
                              "realWorldApplication": "Na simulação numérica de equações diferenciais ordinárias (EDOs) em previsão meteorológica ou modelagem financeira, derivar ρ(ζ) permite determinar o passo de tempo máximo h para estabilidade zero, evitando oscilações ou divergência em integrações de longo prazo como trajetórias orbitais ou simulações de epidemias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Calcular raízes da equação característica",
                            "description": "Resolver ρ(ζ) = 0 para um método dado, como o método de Euler implícito ou trapezoidal, e analisar o módulo das raízes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o método numérico e formular a equação característica ρ(ζ)",
                                  "subSteps": [
                                    "Revise a definição do método numérico dado (ex: Euler implícito, trapezoidal ou BDF2).",
                                    "Identifique os coeficientes ρ(ζ) = ∑_{j=0}^k α_j ζ^j a partir da forma linear multistep: ∑ α_j y_{n+j} = h ∑ β_j f_{n+j}.",
                                    "Escreva explicitamente o polinômio ρ(ζ) para o método específico.",
                                    "Verifique se o método é consistente (ρ(1)=0 e ρ'(1)=0 para ordem ≥1).",
                                    "Anote o grau do polinômio e possíveis raízes conhecidas (ex: ζ=1 sempre para métodos consistentes)."
                                  ],
                                  "verification": "Confirme que ρ(ζ) está corretamente escrito e ρ(1)=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre métodos numéricos, calculadora ou papel para anotar coeficientes.",
                                  "tips": "Sempre normalize ρ(ζ) para que o coeficiente líder seja 1.",
                                  "learningObjective": "Compreender a origem da equação característica na análise de zero-estabilidade.",
                                  "commonMistakes": "Confundir ρ(ζ) com σ(ζ); esquecer o fator h na derivação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever e preparar a equação ρ(ζ) = 0 para resolução",
                                  "subSteps": [
                                    "Escreva ρ(ζ) = 0 como uma equação polinomial padrão: a_k ζ^k + ... + a_0 = 0.",
                                    "Se possível, fatorize ou use fórmula quadrática para graus baixos.",
                                    "Para graus altos, prepare para método numérico ou software.",
                                    "Identifique raízes óbvias (ex: teste ζ=1).",
                                    "Divida o polinômio pela raiz conhecida (ζ-1) para reduzir o grau."
                                  ],
                                  "verification": "A equação está em forma polinomial com coeficientes corretos e testada em ζ=1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora gráfica ou app de polinômios.",
                                  "tips": "Use divisão sintética para fatorar (ζ-1).",
                                  "learningObjective": "Preparar a equação para resolução eficiente.",
                                  "commonMistakes": "Erros de sinal nos coeficientes; não normalizar o polinômio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver ρ(ζ) = 0 para encontrar todas as raízes",
                                  "subSteps": [
                                    "Para grau 1: ζ = -a0/a1.",
                                    "Para grau 2: use fórmula quadrática ζ = [2 ± sqrt(4 - 6)] / 3 para BDF2.",
                                    "Para graus >2: use numpy.roots() em Python ou comando Solve no Mathematica.",
                                    "Liste todas as raízes complexas se aplicável.",
                                    "Verifique numericamente somando raízes (soma = -coef_{k-1}/a_k)."
                                  ],
                                  "verification": "Raízes satisfazem ρ(ζ_j)=0 dentro de tolerância 1e-10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com numpy (np.roots), Mathematica ou calculadora TI-89.",
                                  "tips": "Sempre verifique raízes analiticamente quando possível.",
                                  "learningObjective": "Dominar resolução de polinômios de baixa ordem em contexto numérico.",
                                  "commonMistakes": "Ignorar raízes complexas; arredondamento em cálculos manuais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular módulos das raízes e analisar estabilidade",
                                  "subSteps": [
                                    "Para cada raiz ζ_j, compute |ζ_j| = sqrt(Re(ζ_j)^2 + Im(ζ_j)^2).",
                                    "Verifique se todas |ζ_j| ≤ 1.",
                                    "Identifique a raiz principal (ζ=1, multiplicidade 1).",
                                    "Raízes espúrias devem ter |ζ| <1.",
                                    "Conclua: zero-estável se root condition satisfeita."
                                  ],
                                  "verification": "Tabela com ζ_j, |ζ_j|, e conclusão de estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora complexa ou Python (abs(ζ)).",
                                  "tips": "Raiz principal deve ser simples (multiplicidade 1).",
                                  "learningObjective": "Analisar impacto das raízes na estabilidade numérica.",
                                  "commonMistakes": "Confundir módulo com magnitude real; ignorar multiplicidade."
                                }
                              ],
                              "practicalExample": "Para BDF2: ρ(ζ) = (3/2)ζ² - 2ζ + 1/2 = 0. Multiplique por 2/1: 3ζ² - 4ζ + 1 = 0. Fatoriza: (3ζ - 1)(ζ - 1) = 0 → ζ=1 (|ζ|=1), ζ=1/3 (|ζ|=0.333<1). Zero-estável.",
                              "finalVerifications": [
                                "ρ(ζ) corretamente formulada para o método.",
                                "Todas raízes encontradas e verificadas em ρ(ζ_j)=0.",
                                "Módulos |ζ_j| calculados com precisão.",
                                "Raiz principal ζ=1 simples identificada.",
                                "Conclusão correta sobre zero-estabilidade.",
                                "Tabela ou relatório com todos os resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ρ(ζ) (100% coeficientes corretos).",
                                "Correção na resolução das raízes (erro <1e-6).",
                                "Análise completa dos módulos e multiplicidades.",
                                "Explicação conceitual clara da zero-estabilidade.",
                                "Uso eficiente de ferramentas numéricas.",
                                "Relatório organizado e sem erros aritméticos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra: Resolução de equações polinomiais e teorema fundamental.",
                                "Programação: Uso de bibliotecas como numpy.roots para automação.",
                                "Física: Estabilidade em simulações de sistemas dinâmicos (ex: osciladores).",
                                "Engenharia Computacional: Análise de métodos em CFD ou controle.",
                                "Estatística: Análise de erros de propagação em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em engenharia aeroespacial (ex: trajetórias de voo) ou finanças (modelos Black-Scholes), calcular raízes garante que o método não amplifique erros de arredondamento, evitando instabilidades catastróficas em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Estabilidade Zero",
                        "description": "Condição necessária para a convergência dos métodos multistep, baseada nas raízes do polinômio de primeira característica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Definir estabilidade zero",
                            "description": "Estabelecer que um método é zero-estável se todas as raízes de ρ(ζ) = 0 satisfazem |ζ| ≤ 1, e as raízes com |ζ| = 1 são simples (Teorema de Dahlquist).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o polinômio característico ρ(ζ) em métodos lineares multistep",
                                  "subSteps": [
                                    "Estude a forma geral de métodos lineares multistep: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Identifique o polinômio de primeira característica ρ(ζ) = ∑_{j=0}^k α_j ζ^j.",
                                    "Entenda que ρ(ζ) governa o comportamento assintótico da solução numérica.",
                                    "Calcule ρ(ζ) para exemplos simples como o método de Euler backward: ρ(ζ) = ζ - 1.",
                                    "Discuta o papel de ρ(ζ) na análise de consistência e convergência."
                                  ],
                                  "verification": "Calcule ρ(ζ) para dois métodos multistep e explique seu significado em uma frase curta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Folha de papel e calculadora",
                                    "Notas de aula sobre métodos multistep"
                                  ],
                                  "tips": "Comece com métodos de um passo para familiarizar antes de multistep.",
                                  "learningObjective": "Compreender a origem e o papel do polinômio ρ(ζ) na estabilidade.",
                                  "commonMistakes": [
                                    "Confundir ρ(ζ) com o polinômio de segunda característica σ(ζ)",
                                    "Esquecer que ρ é independente de h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a condição básica de zero-estabilidade: |ζ| ≤ 1 para todas as raízes",
                                  "subSteps": [
                                    "Defina zero-estabilidade: Todas as raízes de ρ(ζ) = 0 devem satisfazer |ζ| ≤ 1.",
                                    "Explique que raízes com |ζ| > 1 causam crescimento exponencial parasitário.",
                                    "Analise graficamente o círculo unitário no plano complexo.",
                                    "Verifique para o método trapezoidal: ρ(ζ) = ζ - 1/2, raiz ζ=1/2 (|ζ|<1).",
                                    "Discuta por que |ζ| ≤ 1 previne instabilidade de baixo ordem."
                                  ],
                                  "verification": "Liste as raízes de ρ(ζ) para um método dado e confirme |ζ| ≤ 1 para todas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem complexa (ex: MATLAB ou Python com numpy)",
                                    "Tabela de métodos numéricos padrão"
                                  ],
                                  "tips": "Use o plano complexo para visualizar magnitudes das raízes.",
                                  "learningObjective": "Aplicar a condição |ζ| ≤ 1 às raízes de ρ(ζ).",
                                  "commonMistakes": [
                                    "Permitir múltiplas raízes na fronteira sem checar simplicidade",
                                    "Confundir magnitude com argumento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a exigência de raízes simples na fronteira |ζ| = 1",
                                  "subSteps": [
                                    "Defina raiz simples: Multiplicidade algébrica igual a 1.",
                                    "Justifique que raízes múltiplas em |ζ|=1 causam crescimento polinomial (t^k).",
                                    "Verifique multiplicidade computando ρ'(ζ) ≠ 0 na raiz.",
                                    "Exemplo: Método de Euler forward tem ρ(ζ)=ζ-1, raiz ζ=1 simples (ρ'(1)=1≠0).",
                                    "Contraexemplo: ρ(ζ)=(ζ-1)^2 tem raiz dupla em |ζ|=1, não zero-estável."
                                  ],
                                  "verification": "Para uma ρ(ζ) dada, identifique raízes em |ζ|=1 e confirme se são simples calculando derivada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy ou Mathematica)",
                                    "Exemplos de polinômios instáveis"
                                  ],
                                  "tips": "Sempre compute a derivada para raízes candidatas na unidade.",
                                  "learningObjective": "Distinguir raízes simples de múltiplas na fronteira unitária.",
                                  "commonMistakes": [
                                    "Assumir todas as raízes |ζ|=1 são simples sem derivada",
                                    "Ignorar multiplicidade em análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o Teorema de Dahlquist e suas implicações",
                                  "subSteps": [
                                    "Enuncie o Teorema de Dahlquist: Método multistep é zero-estável iff raízes de ρ satisfazem as condições acima.",
                                    "Discuta que zero-estabilidade é necessária (mas não suficiente) para convergência.",
                                    "Relacione com ordem do método: Ordem ≤ k-1 se zero-estável.",
                                    "Aplique a métodos conhecidos: Backward Differentiation Formulas (BDF) são zero-estáveis.",
                                    "Resuma em um fluxograma para checagem de zero-estabilidade."
                                  ],
                                  "verification": "Enuncie o teorema completo e aplique a um método novo para classificar zero-estável ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo original de Dahlquist ou resumo em livro-texto",
                                    "Fluxograma em branco para preencher"
                                  ],
                                  "tips": "Memorize: 'Raízes dentro ou simples na fronteira'.",
                                  "learningObjective": "Citar e aplicar o Teorema de Dahlquist corretamente.",
                                  "commonMistakes": [
                                    "Confundir zero-estabilidade com A-estabilidade",
                                    "Esquecer necessidade de simplicidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Milne-Simpson: ρ(ζ) = ζ^3 - ζ^2 + ζ/4 - 1/4. Encontre raízes: ζ≈0.435, 1.207i, 1.207(-i). |1.207|>1 → não zero-estável. Verifique com derivada para raízes unitárias inexistentes.",
                              "finalVerifications": [
                                "Defina zero-estabilidade usando as condições exatas de ρ(ζ).",
                                "Calcule raízes e magnitudes para ρ(ζ) = ζ^2 - ζ de um método dado.",
                                "Identifique se raízes |ζ|=1 são simples via ρ'(ζ).",
                                "Enuncie o Teorema de Dahlquist sem erros.",
                                "Classifique corretamente 3 métodos como zero-estáveis ou não.",
                                "Explique por que uma raiz dupla em |ζ|=1 viola zero-estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: 100% das condições (|ζ|≤1 e simplicidade).",
                                "Correção em cálculos de raízes e magnitudes (erro <1%).",
                                "Compreensão conceitual: Explicação clara de crescimento parasitário.",
                                "Aplicação do teorema: Uso correto em exemplos.",
                                "Identificação de erros comuns: Evita confusões com outros tipos de estabilidade.",
                                "Clareza na comunicação: Definição concisa e exemplos relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Análise de autovalores e polinômios característicos.",
                                "Análise Complexa: Raízes de polinômios e círculo unitário.",
                                "Programação Numérica: Implementação de solvers ODE com checagem de estabilidade.",
                                "Física Computacional: Estabilidade em simulações dinâmicas.",
                                "Teoria de Sistemas: Polos dentro do círculo unitário para estabilidade."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em engenharia aeroespacial (ex: trajetórias de foguetes) ou finanças (modelos Black-Scholes), zero-estabilidade garante que erros de arredondamento não explodam, permitindo previsões confiáveis em softwares como MATLAB ODE solvers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Verificar estabilidade zero",
                            "description": "Analisar se um método multistep dado satisfaz a condição de estabilidade zero, calculando e examinando as raízes de ρ(ζ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular o polinômio de estabilidade ρ(ζ)",
                                  "subSteps": [
                                    "Leia a equação do método multistep linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}",
                                    "Extraia os coeficientes α_j para formar ρ(ζ) = ∑_{j=0}^k α_j ζ^j",
                                    "Verifique se α_k = 1 (normalização padrão)",
                                    "Escreva explicitamente ρ(ζ) para o método dado",
                                    "Confirme o grau k do polinômio"
                                  ],
                                  "verification": "ρ(ζ) está corretamente escrito e coeficientes batem com o método.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência do método multistep (livro ou notas)"
                                  ],
                                  "tips": "Sempre normalize dividindo pela α_k para ter leading coefficient 1.",
                                  "learningObjective": "Formular com precisão o polinômio ρ(ζ) a partir da equação do método.",
                                  "commonMistakes": [
                                    "Esquecer o sinal dos coeficientes α_j",
                                    "Confundir ρ(ζ) com σ(ζ)",
                                    "Não normalizar o polinômio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as raízes do polinômio ρ(ζ)",
                                  "subSteps": [
                                    "Escreva ρ(ζ) = 0 como equação polinomial",
                                    "Use método analítico para graus baixos (≤4) ou numérico para graus altos",
                                    "Aplique fórmula quadrática para grau 2, ou fatorização",
                                    "Utilize software (ex: numpy.roots em Python) se necessário e liste todas as raízes complexas",
                                    "Registre raízes com precisão de 4 casas decimais"
                                  ],
                                  "verification": "Todas as k raízes são encontradas e somam corretamente pelo teorema de Vieta.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Python/MATLAB com função de raízes polinomiais"
                                  ],
                                  "tips": "Raízes complexas vêm em pares conjugados; verifique numericamente.",
                                  "learningObjective": "Resolver numericamente ou analiticamente equações polinomiais de grau até 4.",
                                  "commonMistakes": [
                                    "Perder raízes múltiplas",
                                    "Erro de arredondamento em cálculos numéricos",
                                    "Confundir raízes reais com complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o módulo de cada raiz |ζ_i|",
                                  "subSteps": [
                                    "Para cada raiz ζ_i = a + bi, compute |ζ_i| = sqrt(a² + b²)",
                                    "Liste |ζ_i| para todas as raízes",
                                    "Identifique raízes internas (|ζ_i| < 1), na fronteira (|ζ_i| = 1) e externas (|ζ_i| > 1)",
                                    "Verifique numericamente com tolerância ε=10^{-6} para |ζ_i| ≈ 1",
                                    "Tabule as raízes e seus módulos"
                                  ],
                                  "verification": "Todos |ζ_i| calculados corretamente e classificados.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para sqrt"
                                  ],
                                  "tips": "Use tolerância para erros numéricos em |ζ| ≈1.",
                                  "learningObjective": "Avaliar magnitudes de números complexos com precisão.",
                                  "commonMistakes": [
                                    "Calcular arg(ζ) em vez de |ζ|",
                                    "Ignorar parte imaginária",
                                    "Erro em sqrt(a² + b²)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar multiplicidades das raízes na fronteira unitária",
                                  "subSteps": [
                                    "Selecione raízes com |ζ_i| = 1 (dentro da tolerância)",
                                    "Para cada uma, verifique se é raiz simples: compute ρ'(ζ_i) ≠ 0",
                                    "Calcule derivada ρ'(ζ) = d/dζ ρ(ζ)",
                                    "Avalie ρ'(ζ_i); se ≠0, é simples",
                                    "Se múltipla (ρ'(ζ_i)=0), anote"
                                  ],
                                  "verification": "Multiplicidades confirmadas para todas raízes |ζ|=1.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel para derivadas",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Raiz principal ζ=1 geralmente é simples em métodos consistentes.",
                                  "learningObjective": "Determinar multiplicidade de raízes via derivadas.",
                                  "commonMistakes": [
                                    "Esquecer derivada para multiplicidade",
                                    "Considerar |ζ|≈1 como interna sem checar",
                                    "Erro no cálculo de ρ'(ζ)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir sobre a satisfação da condição de estabilidade zero",
                                  "subSteps": [
                                    "Verifique: Todas |ζ_i| ≤ 1?",
                                    "Para |ζ_i|=1, todas simples?",
                                    "Se ambas sim: método satisfaz estabilidade zero",
                                    "Se não: identifique violações específicas (raiz externa ou múltipla)",
                                    "Escreva conclusão formal"
                                  ],
                                  "verification": "Conclusão lógica baseada nas verificações anteriores.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resumo das tabelas anteriores"
                                  ],
                                  "tips": "Estabilidade zero é necessária mas não suficiente para estabilidade A.",
                                  "learningObjective": "Aplicar critérios formais para julgar estabilidade zero.",
                                  "commonMistakes": [
                                    "Ignorar raízes múltiplas",
                                    "Concluir estável com |ζ|>1",
                                    "Confundir com consistência (ρ(1)=0)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método trapezoidal: y_{n+1} - y_n = (h/2)(f_{n+1} + f_n). ρ(ζ) = ζ - 1. Raiz: ζ=1, |1|=1. ρ'(ζ)=1 ≠0 em ζ=1. Conclusão: Satisfaz estabilidade zero.",
                              "finalVerifications": [
                                "Pode formular ρ(ζ) corretamente para qualquer método multistep dado",
                                "Calcula todas as raízes e seus módulos com precisão",
                                "Identifica corretamente raízes na fronteira unitária",
                                "Verifica multiplicidades usando derivadas",
                                "Emite conclusão correta sobre estabilidade zero",
                                "Explica violações potenciais em exemplos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de ρ(ζ) (20%)",
                                "Correção no cálculo de raízes e módulos (30%)",
                                "Análise de multiplicidades (20%)",
                                "Conclusão lógica e justificada (20%)",
                                "Clareza na tabulação e explicação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas numéricas (NumPy, MATLAB) para raízes",
                                "Física: Estabilidade em simulações de EDOs dinâmicas",
                                "Engenharia: Análise de métodos numéricos em controle",
                                "Computação Científica: Integração com análise de estabilidade A(α)"
                              ],
                              "realWorldApplication": "Em simulações numéricas para modelagem climática, finanças (Black-Scholes) e engenharia aeroespacial, garante que métodos multistep não amplifiquem erros de arredondamento em longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Relacionar com convergência",
                            "description": "Explicar como a estabilidade zero, junto com a consistência, implica convergência pelo Teorema de Lax-Richtmyer adaptado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de consistência e estabilidade zero",
                                  "subSteps": [
                                    "Definir consistência: explique que um esquema numérico é consistente se a solução exata da EDP satisfaz o esquema no limite de h,t -> 0.",
                                    "Definir estabilidade zero: descreva que o erro de arredondamento não amplifica sob iterações do esquema.",
                                    "Comparar estabilidade zero com estabilidade geral de Lax.",
                                    "Estudar exemplos simples de esquemas consistentes e estáveis zero.",
                                    "Resolver exercício: verificar consistência de um esquema explícito para equação de calor."
                                  ],
                                  "verification": "Escrever definições precisas e resolver um exercício de verificação de consistência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires), notas de aula sobre estabilidade, calculadora simbólica (Mathematica ou similar)"
                                  ],
                                  "tips": "Use notação matemática precisa; desenhe diagramas de truncagem para consistência.",
                                  "learningObjective": "Dominar os conceitos fundamentais que precedem o teorema.",
                                  "commonMistakes": "Confundir consistência (aproximação local) com convergência (global); ignorar o papel do passo de tempo na estabilidade zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o enunciado do Teorema de Lax-Richtmyer adaptado",
                                  "subSteps": [
                                    "Enunciar o teorema: consistência + estabilidade zero implica convergência da solução numérica para a exata.",
                                    "Analisar condições: domínio em espaços de Banach, operadores lineares.",
                                    "Explicar adaptação para estabilidade zero em vez de estabilidade GKS.",
                                    "Ler prova esquemática: decomposição do erro em truncagem + arredondamento.",
                                    "Discutir limitações do teorema (linearidade, etc.)."
                                  ],
                                  "verification": "Reescrever o teorema de cor e listar suas hipóteses principais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo original de Lax-Richtmyer ou capítulo de livro avançado (ex: Gustafsson et al.), slides da aula sobre o teorema"
                                  ],
                                  "tips": "Memorize o fluxo: consistência controla truncagem, estabilidade zero controla propagação de erros.",
                                  "learningObjective": "Compreender o statement exato e suas premissas.",
                                  "commonMistakes": "Omitir a necessidade de consistência forte; achar que estabilidade sozinha basta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a prova e o mecanismo de implicação",
                                  "subSteps": [
                                    "Decompor o erro total: erro = truncagem (consistência) + erro inicial + arredondamento (estabilidade zero).",
                                    "Estudar desigualdade triangular para ligar os termos.",
                                    "Verificar como estabilidade zero previne crescimento exponencial do erro de arredondamento.",
                                    "Simular numericamente um caso onde falta consistência mas há estabilidade.",
                                    "Concluir a implicação: ambos juntos forçam ||erro|| -> 0 quando h,t -> 0."
                                  ],
                                  "verification": "Esboçar a prova em 5-10 linhas e computar norma de erro em um exemplo numérico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software numérico (MATLAB/Python com NumPy/SciPy), exemplos de códigos de esquemas FD para EDP"
                                  ],
                                  "tips": "Implemente um código simples para visualizar o erro; foque em normas adequadas (L2, sup).",
                                  "learningObjective": "Internalizar o raciocínio lógico da prova.",
                                  "commonMistakes": "Ignorar termos de ordem superior na expansão de truncagem; confundir estabilidade com dissipatividade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o teorema em um exemplo concreto",
                                  "subSteps": [
                                    "Escolher esquema: Leapfrog para equação de onda, verificar consistência.",
                                    "Verificar estabilidade zero via análise de von Neumann.",
                                    "Simular numericamente convergência variando h,t.",
                                    "Analisar gráficos de erro vs. malha.",
                                    "Discutir falhas se uma condição for violada."
                                  ],
                                  "verification": "Gerar gráfico de convergência e explicar resultados à luz do teorema.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB pronto para esquemas de onda, computador com ambiente numérico"
                                  ],
                                  "tips": "Use malhas refinadas (h=1/100 a 1/1000); plote log-log para ordem de convergência.",
                                  "learningObjective": "Conectar teoria à prática computacional.",
                                  "commonMistakes": "Não normalizar erros adequadamente; atribuir convergência só à estabilidade."
                                }
                              ],
                              "practicalExample": "Considere o esquema Leapfrog para a equação de onda u_tt = c^2 u_xx. Verifique consistência pela expansão de Taylor (ordem 2). Analise estabilidade zero mostrando que o amplificador de Fourier tem módulo 1. Simule com c=1, domínio [0,1]x[0,1], u0=sen(pi x), e observe ||u_num - u_exata||_2 -> 0 à medida que h,t diminuem, ilustrando o teorema.",
                              "finalVerifications": [
                                "Enunciar corretamente o Teorema de Lax-Richtmyer adaptado.",
                                "Explicar verbalmente como estabilidade zero controla erros de arredondamento.",
                                "Identificar em um esquema dado se ele satisfaz consistência e estabilidade zero.",
                                "Prever se um método converge baseado nas condições.",
                                "Analisar um gráfico de erro e ligá-lo ao teorema.",
                                "Discutir uma limitação do teorema (ex: não-linearidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de terminologia matemática (consistência, estabilidade zero, convergência).",
                                "Capacidade de decompor o erro total corretamente.",
                                "Demonstração via exemplo numérico com gráficos de convergência.",
                                "Identificação clara da contribuição de cada hipótese.",
                                "Explicação lógica sem lacunas na implicação.",
                                "Aplicação independente a um novo esquema."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de ondas e fluidos.",
                                "Engenharia: métodos numéricos em CFD e estruturas.",
                                "Ciência da Computação: análise de algoritmos numéricos estáveis.",
                                "Matemática Aplicada: teoria de aproximação em PDEs."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), como previsão de tempo ou aerodinâmica, garante que discretizações numéricas convirjam para soluções físicas reais, evitando instabilidades que poderiam invalidar modelos de aviões ou turbinas eólicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Estabilidade Absoluta",
                    "description": "Estabilidade para passos de tempo variáveis e equações com autovalores negativos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Definição e Conceitos Básicos de Estabilidade Absoluta",
                        "description": "Fundamentos da estabilidade absoluta em métodos numéricos para equações diferenciais ordinárias (EDOs), incluindo a definição da região de estabilidade e análise via fator de amplificação para métodos de passo simples e múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Definir estabilidade absoluta",
                            "description": "Explicar o conceito de estabilidade absoluta como a propriedade de um método numérico que mantém a solução numérica estável independentemente do tamanho do passo de tempo, para EDOs lineares teste y' = λy com Re(λ) < 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Teste Linear y' = λy",
                                  "subSteps": [
                                    "Explicar o que é uma Equação Diferencial Ordinária (EDO) linear de teste: y' = λy, onde λ é um número complexo com parte real negativa (Re(λ) < 0).",
                                    "Derivar a solução exata: y(t) = y(0) * e^(λt), mostrando que |y(t)| → 0 quando t → ∞ devido a Re(λ) < 0.",
                                    "Discutir o comportamento assintótico: a solução exata decai exponencialmente para zero, representando estabilidade física.",
                                    "Relacionar com métodos numéricos: precisamos que a solução discreta imite isso independentemente do passo h.",
                                    "Plotar ou esboçar a solução exata para um λ exemplo, como λ = -1 + 0i."
                                  ],
                                  "verification": "Derivar corretamente a solução exata e explicar verbalmente por que ela tende a zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Software de plotagem (Desmos, GeoGebra ou Python com Matplotlib)"
                                  ],
                                  "tips": "Sempre especifique Re(λ) < 0 para garantir decaimento; visualize graficamente para intuição.",
                                  "learningObjective": "Entender o modelo canônico para análise de estabilidade em EDOs lineares.",
                                  "commonMistakes": [
                                    "Assumir λ real positivo, levando a crescimento exponencial",
                                    "Esquecer o fator e^(λt) na solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Métodos Numéricos e a Noção de Estabilidade Numérica",
                                  "subSteps": [
                                    "Definir método numérico básico: aproximação y_{n+1} = y_n + h * f(t_n, y_n), com h = passo de tempo.",
                                    "Aplicar ao teste: para Euler explícito, y_{n+1} = y_n * (1 + hλ), levando a y_n = y_0 * (1 + hλ)^n.",
                                    "Analisar crescimento: a solução numérica é estável se |1 + hλ| ≤ 1 para n → ∞.",
                                    "Introduzir região de estabilidade: conjunto de z = hλ onde |ampliação| ≤ 1.",
                                    "Comparar com solução exata: estabilidade numérica requer imitação do decaimento exato."
                                  ],
                                  "verification": "Calcular a recursão para Euler e identificar a condição |1 + z| ≤ 1, com z = hλ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Calculadora ou Python para iterações numéricas simples"
                                  ],
                                  "tips": "Use z = hλ para normalizar; teste com h pequeno vs. grande para ver instabilidade.",
                                  "learningObjective": "Relacionar discretização numérica com comportamento assintótico discreto.",
                                  "commonMistakes": [
                                    "Confundir h com tamanho fixo vs. variável",
                                    "Ignorar que n = t/h, então h pequeno nem sempre resolve"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Dependência no Passo de Tempo h",
                                  "subSteps": [
                                    "Testar Euler com Re(λ) < 0 e h variando: para h grande, |1 + hλ| > 1 causa explosão.",
                                    "Definir estabilidade condicional: requer h < h_max dependente de λ (ex: h < 2/|λ| para Euler real).",
                                    "Contrastar com estabilidade incondicional: solução estável para qualquer h > 0.",
                                    "Discutir limitações: em problemas reais, h pode precisar ser grande por eficiência computacional.",
                                    "Simular numericamente: implementar loop simples para y_n e observar para h=0.1 vs. h=10."
                                  ],
                                  "verification": "Executar simulação numérica mostrando instabilidade para h grande em Euler.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou MATLAB (código simples de Euler)",
                                    "Gráficos para comparar y_n vs. y exata"
                                  ],
                                  "tips": "Comece com λ real negativo simples (-1); aumente h gradualmente para observar oscilações/explosão.",
                                  "learningObjective": "Identificar como estabilidade numérica depende do tamanho de h.",
                                  "commonMistakes": [
                                    "Achar que h pequeno sempre estabiliza (falha para λ complexo)",
                                    "Não normalizar com z = hλ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Formalmente Estabilidade Absoluta",
                                  "subSteps": [
                                    "Definir estabilidade absoluta: um método é absolutamente estável se, para todo h > 0 e Re(λ) < 0, a solução numérica y_n permanece limitada (|y_n| ≤ K para todo n).",
                                    "Explicar independência de h: região de estabilidade cobre todo o semiplano esquerdo Re(z) < 0.",
                                    "Contrastar com métodos condicionais como Euler (região limitada).",
                                    "Dar exemplo de método A-estável: Backward Euler, onde |1/(1 - z)| ≤ 1 para Re(z) < 0.",
                                    "Formalizar: para y' = λy, o polinômio de ampliação R(z) satisfaz |R(z)| ≤ 1 ∀ Re(z) < 0."
                                  ],
                                  "verification": "Reescrever a definição em suas palavras e aplicar a Backward Euler com exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência teórica (livro de análise numérica)",
                                    "Papel para diagramas de região de estabilidade"
                                  ],
                                  "tips": "Lembre: absoluta = para qualquer h>0; foque no semiplano esquerdo no plano z.",
                                  "learningObjective": "Formular precisamente o conceito de estabilidade absoluta para métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir com estabilidade relativa (A(α)-estável)",
                                    "Pensar que todos métodos implícitos são absolutos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Sintetizar o Conceito",
                                  "subSteps": [
                                    "Resumir diferenças: absoluta vs. condicional via regiões de estabilidade.",
                                    "Testar definição com outro método: Runge-Kutta 4 (não absoluta).",
                                    "Discutir implicações: preferível para problemas rígidos onde h grande é necessário.",
                                    "Criar fluxograma: dado método → teste y' = λy → varrer h → checar boundedness.",
                                    "Autoavaliar compreensão com perguntas: 'Por que Euler falha para h grande?'."
                                  ],
                                  "verification": "Explicar por que estabilidade absoluta é desejável em aplicações reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de regiões de estabilidade impresso ou desenhado"
                                  ],
                                  "tips": "Use plano complexo z para visualizar: esquerda inteira para absoluta.",
                                  "learningObjective": "Sintetizar e aplicar a definição em contextos comparativos.",
                                  "commonMistakes": [
                                    "Limitar a λ real, ignorar complexo",
                                    "Confundir bounded com exatidão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -100y, y(0)=1 (rigidez alta). Com Euler explícito e h=0.02 (>0.01 limite), y_n explode. Com Backward Euler (absoluto), y_n decai estável para qualquer h, aproximando e^(-100t). Implemente em Python: compare plots para h=0.001, 0.1.",
                              "finalVerifications": [
                                "Explicar verbalmente a definição de estabilidade absoluta.",
                                "Derivar recursão de ampliação para Euler e Backward no teste λ.",
                                "Identificar se um método dado é absolutamente estável baseado em R(z).",
                                "Simular numericamente instabilidade condicional vs. absoluta.",
                                "Diferenciar estabilidade absoluta de consistência e convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: independência de h para Re(λ)<0 (peso 30%).",
                                "Correta análise do teste linear: solução exata e recursão (25%).",
                                "Exemplos numéricos/simulações corretas sem erros (20%).",
                                "Uso correto de terminologia (região de estabilidade, A-estável) (15%).",
                                "Conexões com implicações práticas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de sistemas dissipativos (ex: amortecedores em engenharia mecânica).",
                                "Ciência da Computação: Implementação eficiente de solvers ODE em bibliotecas como SciPy.",
                                "Engenharia: Modelagem de circuitos RC/RL rígidos onde h variável é comum.",
                                "Economia/Finanças: Modelos estocásticos com decaimento exponencial estável."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, EDOs rígidas requerem passos h grandes para eficiência; métodos com estabilidade absoluta (ex: Radau, BDF) previnem crashes numéricos, permitindo previsões confiáveis em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Descrever a região de estabilidade",
                            "description": "Identificar e plotar a região de estabilidade absoluta no plano complexo z = hλ, diferenciando métodos explícitos (região limitada) e implícitos (A-estáveis, incluindo semiplano esquerdo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina estabilidade absoluta para métodos de Runge-Kutta aplicados a EDOs lineares y' = λy.",
                                    "Explique o papel do parâmetro z = hλ no plano complexo.",
                                    "Descreva a condição |R(z)| ≤ 1, onde R(z) é a função de amplificação.",
                                    "Identifique que a região de estabilidade é {z ∈ ℂ : |R(z)| ≤ 1}.",
                                    "Diferencie estabilidade absoluta de estabilidade relativa."
                                  ],
                                  "verification": "Escreva definições precisas e verifique com fórmulas padrão de livros-texto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), caderno e lápis.",
                                  "tips": "Use diagramas simples do plano complexo para visualizar z = x + iy.",
                                  "learningObjective": "Dominar a definição matemática da região de estabilidade absoluta.",
                                  "commonMistakes": "Confundir estabilidade absoluta com passo de tempo h pequeno; ignorar o semiplano esquerdo para λ reais negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar região de estabilidade para métodos explícitos",
                                  "subSteps": [
                                    "Estude o método de Euler explícito: R(z) = 1 + z.",
                                    "Determine a região |1 + z| ≤ 1, que é um disco unitário centrado em -1.",
                                    "Plote o disco no plano complexo e note sua limitação ao semiplano esquerdo.",
                                    "Discuta por que métodos explícitos têm regiões limitadas.",
                                    "Calcule pontos de fronteira, como z = -2 (instável)."
                                  ],
                                  "verification": "Desenhe o disco corretamente e teste pontos dentro/fora com |R(z)|.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (ex: Python com Matplotlib ou Desmos), papel milimetrado.",
                                  "tips": "Comece plotando o círculo |z + 1| = 1 para visualizar o disco.",
                                  "learningObjective": "Identificar e plotar a região limitada típica de métodos explícitos.",
                                  "commonMistakes": "Errar o centro do disco (é -1, não 0); esquecer de verificar |R(z)| em pontos teste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar região de estabilidade para métodos implícitos",
                                  "subSteps": [
                                    "Estude o método de Euler implícito: R(z) = 1 / (1 - z).",
                                    "Determine que |R(z)| ≤ 1 para Re(z) ≤ 0 (todo o semiplano esquerdo).",
                                    "Defina A-estabilidade: região inclui o semiplano esquerdo.",
                                    "Compare com métodos multistep implícitos (ex: trapezoidal).",
                                    "Discuta vantagens para problemas rígidos."
                                  ],
                                  "verification": "Prove que para Re(z) < 0, |R(z)| < 1, e confirme com exemplos numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora ou Python para computar |R(z)|, referências teóricas.",
                                  "tips": "Use desigualdades complexas para provar a inclusão do semiplano.",
                                  "learningObjective": "Reconhecer regiões ilimitadas e A-estabilidade em métodos implícitos.",
                                  "commonMistakes": "Confundir Euler implícito com explícito; achar que todos implícitos são A-estáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e visualizar as regiões no plano z = hλ",
                                  "subSteps": [
                                    "Compare visualmente disco explícito vs. semiplano implícito.",
                                    "Descreva verbalmente: explícitos limitados, implícitos incluem todo Re(z) ≤ 0.",
                                    "Plote ambas regiões no mesmo gráfico.",
                                    "Explique implicações para escolha de h em problemas com Re(λ) < 0.",
                                    "Crie uma tabela resumindo diferenças."
                                  ],
                                  "verification": "Gere gráfico comparativo e descreva diferenças em parágrafo coerente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de graficação (MATLAB, Python/Matplotlib), quadro branco.",
                                  "tips": "Use cores diferentes para regiões explícita/implícita no plot.",
                                  "learningObjective": "Capacitar descrição precisa e diferenciada das regiões.",
                                  "commonMistakes": "Ignorar o eixo imaginário; superestimar região explícita."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e praticar descrição completa",
                                  "subSteps": [
                                    "Escreva uma descrição textual completa das regiões.",
                                    "Teste com exemplos de EDOs (ex: y' = -λy com λ > 0).",
                                    "Discuta não-A-estáveis implícitos (ex: regiões L-estáveis).",
                                    "Revise conceitos integrando explicitos vs. implícitos.",
                                    "Prepare para verificação final."
                                  ],
                                  "verification": "Redija relatório de 200 palavras descrevendo regiões com plots anexados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documento editor (Word/Google Docs), plots salvos.",
                                  "tips": "Estruture descrição: definição, explícito, implícito, comparação.",
                                  "learningObjective": "Consolidar habilidade de descrever regiões de forma estruturada.",
                                  "commonMistakes": "Omitir diferenças qualitativas; usar terminologia vaga."
                                }
                              ],
                              "practicalExample": "Para resolver y' = -10y + sin(t), com λ ≈ -10 (Re(λ)<0). Use Euler explícito: região limitada exige h < 0.2. Plote disco |1 + hλ| ≤1. Para Euler implícito, qualquer h>0 é estável no semiplano esquerdo. Compare soluções numéricas em Python para h=0.5.",
                              "finalVerifications": [
                                "Pode definir precisamente região de estabilidade como {z : |R(z)| ≤1}.",
                                "Desenha corretamente disco unitário centrado em -1 para Euler explícito.",
                                "Explica A-estabilidade como inclusão do semiplano Re(z)≤0.",
                                "Diferencia limitações explícitas vs. ilimitadas implícitas verbalmente.",
                                "Plota regiões comparativas sem erros.",
                                "Aplica conceito a exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e fórmulas (30%).",
                                "Qualidade e acurácia dos plots/diagramas (25%).",
                                "Clareza na diferenciação explícito/implícito (20%).",
                                "Uso correto de terminologia (A-estável, etc.) (15%).",
                                "Explicação de implicações práticas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Análise de sistemas rígidos em controle.",
                                "Estatística: Modelos estocásticos com estabilidade similar."
                              ],
                              "realWorldApplication": "Em modelagem climática ou farmacocinética, onde EDOs rígidas (autovalores com partes reais negativas grandes) exigem métodos implícitos A-estáveis para simulações estáveis com passos h grandes, evitando custos computacionais excessivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Analisar estabilidade via fator de amplificação",
                            "description": "Calcular o fator de amplificação |R(z)| para métodos como Euler forward e backward, verificando se |R(z)| ≤ 1 para z no semiplano esquerdo, usando equações teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade absoluta e fator de amplificação",
                                  "subSteps": [
                                    "Defina estabilidade absoluta para métodos de Runge-Kutta lineares.",
                                    "Explique o papel do fator de amplificação R(z) na análise de estabilidade.",
                                    "Identifique o semiplano esquerdo do plano complexo (Re(z) ≤ 0).",
                                    "Discuta a condição |R(z)| ≤ 1 para estabilidade.",
                                    "Revise a equação teste y' = λy com Re(λ) < 0."
                                  ],
                                  "verification": "Escreva definições precisas e desenhe o semiplano esquerdo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de estabilidade)",
                                    "Papel e caneta para diagramas",
                                    "Software de plotagem como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Use diagramas do plano z para visualizar a região de estabilidade.",
                                  "learningObjective": "Compreender a base teórica do fator de amplificação e sua relação com estabilidade.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Ignorar que z = hλ onde h é o passo de tempo",
                                    "Esquecer que a condição é para todo z com Re(z) ≤ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o fator de amplificação R(z) para o método de Euler forward",
                                  "subSteps": [
                                    "Escreva a recursão do método: y_{n+1} = y_n + h f(t_n, y_n) = (1 + z) y_n para y' = λy.",
                                    "Identifique R(z) = 1 + z.",
                                    "Calcule |R(z)| = |1 + z|.",
                                    "Teste pontos no semiplano esquerdo, ex: z = -1 + 0i.",
                                    "Discuta limitações para |z| grande."
                                  ],
                                  "verification": "Derive R(z) e compute |R(z)| para 3 pontos no semiplano esquerdo, confirmando >1 em alguns casos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Folha de exercícios com equações teste"
                                  ],
                                  "tips": "Sempre expresse em termos de z = hλ para clareza.",
                                  "learningObjective": "Derivar e calcular R(z) explicitamente para Euler forward.",
                                  "commonMistakes": [
                                    "Esquecer o módulo | | ao calcular magnitude",
                                    "Confundir com Euler backward",
                                    "Não considerar h pequeno o suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o fator de amplificação R(z) para o método de Euler backward",
                                  "subSteps": [
                                    "Escreva a recursão implícita: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) = y_n / (1 - z) para y' = λy.",
                                    "Resolva para R(z) = 1 / (1 - z).",
                                    "Calcule |R(z)| = 1 / |1 - z|.",
                                    "Teste pontos no semiplano esquerdo, ex: z = -1 + 0i.",
                                    "Compare com Euler forward graficamente."
                                  ],
                                  "verification": "Derive R(z), compute |R(z)| para os mesmos 3 pontos e mostre |R(z)| ≤ 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos da Step 2",
                                    "Gráficos prontos de regiões de estabilidade"
                                  ],
                                  "tips": "Verifique a inversão: resolva y_{n+1}(1 - z) = y_n.",
                                  "learningObjective": "Dominar a derivação de R(z) para métodos implícitos como Euler backward.",
                                  "commonMistakes": [
                                    "Erro na algebra da forma implícita",
                                    "Confundir sinal de z",
                                    "Não normalizar |R(z)| corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade comparando |R(z)| ≤ 1 no semiplano esquerdo",
                                  "subSteps": [
                                    "Selecione uma grade de pontos z com Re(z) ≤ 0.",
                                    "Compute |R(z)| para ambos métodos em cada ponto.",
                                    "Identifique regiões onde |R(z)| > 1 (instável).",
                                    "Desenhe a região de estabilidade no plano z.",
                                    "Conclua sobre estabilidade absoluta de cada método."
                                  ],
                                  "verification": "Crie tabela com 5 pontos z e marque estabilidade; região de Euler forward é disco unitário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotar |R(z)|",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use contour plots para visualizar |R(z)| = 1.",
                                  "learningObjective": "Aplicar critério |R(z)| ≤ 1 para analisar estabilidade.",
                                  "commonMistakes": [
                                    "Testar apenas eixo real",
                                    "Ignorar imag(z) ≠ 0",
                                    "Confundir estabilidade condicional"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar análise a equações teste e sintetizar resultados",
                                  "subSteps": [
                                    "Escolha equação teste: y' = -y, λ = -1.",
                                    "Para h=0.5, z=-0.5; compute iterações numéricas vs exata.",
                                    "Varie h até instabilidade (Euler forward).",
                                    "Repita para Euler backward com h grande.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Simule 10 passos e compare erro; mostre divergência para Euler forward com h>1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python simples para simulação",
                                    "Gráficos de solução numérica vs exata"
                                  ],
                                  "tips": "Sempre compare com solução analítica e^{λt}.",
                                  "learningObjective": "Integrar cálculo teórico com simulação prática para verificação.",
                                  "commonMistakes": [
                                    "Passo h muito pequeno ocultando instabilidade",
                                    "Não plotar múltiplos h",
                                    "Esquecer normalização inicial y(0)=1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y (λ=-1), usando Euler forward com h=1.5 (z=-1.5): R(z)=1-1.5=-0.5, |R|=0.5≤1 ok; mas para h=2 (z=-2), R=-1, |R|=1; simule e veja oscilação vs backward estável.",
                              "finalVerifications": [
                                "R(z) derivado corretamente para ambos métodos.",
                                "Tabela de |R(z)| ≤1 confirmada para semiplano esquerdo em backward, falha em forward.",
                                "Regiões de estabilidade plotadas/esboçadas.",
                                "Simulação numérica mostra instabilidade em forward para h grande.",
                                "Conclusões escritas justificando estabilidade absoluta.",
                                "Comparação com solução exata e^{λt} em gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de R(z) (100% correto).",
                                "Correta identificação de regiões onde |R(z)| >1.",
                                "Qualidade dos gráficos e tabelas (clareza e legibilidade).",
                                "Análise crítica de limitações dos métodos.",
                                "Integração teórica com prática numérica.",
                                "Relatório conciso com conclusões fundamentadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores harmônicos.",
                                "Programação: Implementar métodos em Python para visualização.",
                                "Engenharia: Análise de controle em sistemas lineares discretos.",
                                "Ciências Computacionais: Regiões de estabilidade em ODE solvers."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou previsão meteorológica, onde Euler backward garante estabilidade para passos de tempo maiores em modelos rígidos, otimizando computação em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Estabilidade Absoluta com Passos de Tempo Variáveis",
                        "description": "Técnicas de controle adaptativo de passo para manter a estabilidade absoluta em métodos de passo simples e múltiplo, ajustando h dinamicamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Implementar controle adaptativo de passo",
                            "description": "Desenvolver algoritmos para estimar e ajustar o passo h variável baseado na proximidade da borda da região de estabilidade, usando estimativas locais de Lipschitz ou autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Estabilidade e Constantes Locais",
                                  "subSteps": [
                                    "Estude a região de estabilidade absoluta para métodos de Runge-Kutta explícitos.",
                                    "Revise a definição de constante de Lipschitz local para a função f(t,y) da EDO.",
                                    "Aprenda a estimar autovalores locais da Jacobiana ∂f/∂y.",
                                    "Calcule exemplos analíticos para EDOs lineares como y' = λy.",
                                    "Compare estimativas de Lipschitz vs. autovalores em casos stiff."
                                  ],
                                  "verification": "Resolva 3 EDOs simples manualmente e confirme que |λh| < limite de estabilidade.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), MATLAB/Python com sympy para Jacobianas.",
                                  "tips": "Use gráficos da região de estabilidade no plano complexo para visualização intuitiva.",
                                  "learningObjective": "Compreender como Lipschitz e autovalores determinam o passo máximo estável.",
                                  "commonMistakes": "Confundir Lipschitz global com local; ignorar termos não lineares na Jacobiana."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Estimador Local de Constante de Estabilidade",
                                  "subSteps": [
                                    "Implemente função para aproximar Lipschitz local via diferenças finitas: L ≈ max | (f(t,y1)-f(t,y2)) / |y1-y2| |.",
                                    "Calcule autovalores da Jacobiana numérica usando SVD ou eig em Python/MATLAB.",
                                    "Defina métrica de proximidade à borda: ρ = |λ_max h| / r, onde r é raio de estabilidade.",
                                    "Teste em EDO y' = -y + sin(t) com perturbações.",
                                    "Ajuste tolerâncias para precisão da estimativa (ex: h_probe = 1e-6)."
                                  ],
                                  "verification": "Compare estimativas com valores exatos em EDOs lineares; erro < 5%.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Python (numpy, scipy.linalg), Jupyter notebook para prototipagem.",
                                  "tips": "Use forward Euler para probe inicial rápido na estimativa de Lipschitz.",
                                  "learningObjective": "Criar funções robustas para estimar limites de estabilidade locais.",
                                  "commonMistakes": "Passos de probe muito grandes levando a instabilidade na estimativa; não tratar singularidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Algoritmo de Controle Adaptativo de Passo",
                                  "subSteps": [
                                    "Defina regra de ajuste: se ρ > 0.9, h_new = 0.8 h; se ρ < 0.5, h_new = 1.2 h.",
                                    "Incorpore controle de erro local: h_new = h * (tol / err)^{1/(p+1)}, p=ordem método.",
                                    "Crie loop: estime ρ, ajuste h, avance passo, rejeite se instável.",
                                    "Adicione limites: h_min, h_max baseados em precisão desejada.",
                                    "Pseudocódigo: while t < T: estimate, adjust h, integrate, check."
                                  ],
                                  "verification": "Simule trajetória de h em EDO stiff; confirme oscilações < 20%.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": "Papel para pseudocódigo, SciPy odeint para baseline.",
                                  "tips": "Combine ρ com erro para ajuste híbrido: mais robusto em não-lineares.",
                                  "learningObjective": "Formular regras heurísticas seguras para variação dinâmica de h.",
                                  "commonMistakes": "Fatores de ajuste muito agressivos causando rejeições infinitas; ignorar h_max."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Integrar no Solver Numérico",
                                  "subSteps": [
                                    "Escreva classe StepController com métodos estimate_lipschitz(), estimate_eigs(), adjust_step().",
                                    "Integre em solver RK4 adaptativo: modifique loop principal.",
                                    "Adicione logging: plote h(t), ρ(t), erro local.",
                                    "Teste em EDO Van der Pol stiff (μ=1000).",
                                    "Otimize: vetorize estimativas para eficiência."
                                  ],
                                  "verification": "Código roda sem crash; solução converge com tol=1e-6.",
                                  "estimatedTime": "5-6 horas",
                                  "materials": "Python (matplotlib para plots), Git para versionamento.",
                                  "tips": "Use @numba.jit para acelerar estimativas em loops.",
                                  "learningObjective": "Construir solver completo com controle adaptativo funcional.",
                                  "commonMistakes": "Não resetar estimativas em rejeições; overflow em eig para matrizes grandes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar o Controlador",
                                  "subSteps": [
                                    "Compare com solvers padrão (ex: DOPRI5 em SciPy).",
                                    "Meça eficiência: NFEE (número de funções avaliadas).",
                                    "Teste sensibilidade a parâmetros (fatores, tol).",
                                    "Aplique a EDOs reais: oscilador amortecido não-linear.",
                                    "Ajuste heurísticas baseado em métricas."
                                  ],
                                  "verification": "NFEE < 1.5x solver padrão; erro global < 1e-5.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Benchmarks de EDOs stiff (ex: Hairer livro), profiler (cProfile).",
                                  "tips": "Grave vídeos curtos de plots h(t) para debug visual.",
                                  "learningObjective": "Avaliar performance e refinar algoritmo iterativamente.",
                                  "commonMistakes": "Testes só em lineares; não medir custo computacional."
                                }
                              ],
                              "practicalExample": "Implemente em Python para resolver y' = -50y + 50 sin(t), y(0)=1, [0,10]. Sem adaptativo, h fixo=0.01 falha (instável); com controle, h varia de 0.2 a 0.001, convergindo suavemente ao envelope sin(t).",
                              "finalVerifications": [
                                "O passo h ajusta automaticamente mantendo ρ < 0.95 em toda simulação.",
                                "Erro local por passo fica abaixo de tolerância especificada.",
                                "Número total de passos é razoável (eficiência > baseline).",
                                "Solução final bate com referência analítica/ alta precisão (<1e-4 erro).",
                                "Código lida com rejeições sem loop infinito.",
                                "Gráficos mostram h estável e solução precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global < 1e-5 em testes padrão.",
                                "Eficiência: NFEE reduzido em 20-50% vs h fixo ótimo.",
                                "Robustez: Funciona em EDOs stiff/moderados sem crashes.",
                                "Flexibilidade: Parâmetros ajustáveis (tol, safety_factor).",
                                "Clareza: Código comentado, modular, com testes unitários.",
                                "Escalabilidade: OK para dim(y)>10."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Otimização numérica e análise de algoritmos.",
                                "Física: Simulações dinâmicas stiff (ex: reações químicas).",
                                "Engenharia: Controle de sistemas (PID-like para passos).",
                                "Estatística: Estimativa de incerteza em autovalores.",
                                "Machine Learning: Adaptação similar a learning rate em GD."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) para turbulência stiff, ajusta h localmente evitando instabilidades; em finanças, modela opções exóticas com volatilidade variável, garantindo precisão em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Estimar passo máximo para estabilidade",
                            "description": "Calcular h_max tal que h_max |λ| esteja dentro da região de estabilidade para passos variáveis, considerando contração em problemas com autovalores negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina estabilidade absoluta para métodos numéricos de EDOs.",
                                    "Explique o papel do autovalor λ na análise de estabilidade local.",
                                    "Descreva a região de estabilidade no plano complexo z = hλ.",
                                    "Diferencie estabilidade para passos constantes e variáveis.",
                                    "Identifique condições de contração para autovalores com parte real negativa."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe o plano z com a região de estabilidade de um método simples como Euler explícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para diagramas",
                                    "Software MATLAB ou Python (SymPy para plots)"
                                  ],
                                  "tips": "Use diagramas no plano complexo para visualizar melhor a região de estabilidade.",
                                  "learningObjective": "Compreender os fundamentos teóricos da estabilidade absoluta e seu vínculo com autovalores.",
                                  "commonMistakes": [
                                    "Confundir estabilidade local com global.",
                                    "Ignorar a parte imaginária de λ complexos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a região de estabilidade do método numérico",
                                  "subSteps": [
                                    "Escolha um método numérico específico (ex: Euler explícito, Runge-Kutta).",
                                    "Derive ou recorde a função de amplificação R(z) onde z = hλ.",
                                    "Determine a região S = {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Plote a fronteira da região de estabilidade.",
                                    "Verifique exemplos para autovalores reais negativos."
                                  ],
                                  "verification": "Desenhe e descreva a região de estabilidade para Euler explícito, confirmando que para λ < 0 real, z ∈ [-2, 0].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folhas de cálculo ou GeoGebra para plots",
                                    "Referência: Notas de aula sobre métodos de Runge-Kutta",
                                    "Python com Matplotlib"
                                  ],
                                  "tips": "Comece com métodos lineares simples para construir intuição antes de métodos implícitos.",
                                  "learningObjective": "Dominar a identificação e representação gráfica da região de estabilidade.",
                                  "commonMistakes": [
                                    "Erro na derivação de R(z).",
                                    "Confundir |R(z)| < 1 com ≤ 1 na fronteira."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o passo máximo h_max para estabilidade",
                                  "subSteps": [
                                    "Dado λ, encontre o limite da região S ao longo da direção de λ.",
                                    "Para passos variáveis, adapte h_k tal que h_k |λ| permaneça em S.",
                                    "Calcule h_max = sup {h | hλ ∈ S} ≈ raio / |λ|.",
                                    "Implemente fórmula para λ real negativo: h_max ≈ 2 / |λ| para Euler.",
                                    "Teste numericamente com uma EDO teste y' = λy."
                                  ],
                                  "verification": "Compute h_max para λ = -1 e método Euler, simulando 10 passos sem divergência.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter Notebook",
                                    "Código template para solver de EDOs",
                                    "Tabela de regiões de estabilidade de métodos comuns"
                                  ],
                                  "tips": "Use aproximações conservadoras: h_max = 0.9 * limite teórico para margem de segurança.",
                                  "learningObjective": "Aplicar cálculo de h_max garantindo h_max |λ| ∈ S para passos variáveis.",
                                  "commonMistakes": [
                                    "Usar h constante em vez de variável.",
                                    "Esquecer normalização por |λ|."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Considerar contração e ajustes para autovalores negativos",
                                  "subSteps": [
                                    "Explique contração: para Re(λ) < 0, solução analítica decai.",
                                    "Ajuste h_max para preservar contração numérica.",
                                    "Analise impacto em passos variáveis: h_k decrescente se necessário.",
                                    "Simule problema com autovalores negativos e verifique estabilidade.",
                                    "Otimize escolha de h_max minimizando erro global."
                                  ],
                                  "verification": "Simule y' = -y com h_max variável, confirmando decaimento sem oscilações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com SciPy (odeint ou solve_ivp)",
                                    "Gráficos de solução numérica vs exata"
                                  ],
                                  "tips": "Monitore norma da solução numérica para detectar instabilidade precoce.",
                                  "learningObjective": "Integrar efeitos de contração na estimativa de h_max para problemas dissipativos.",
                                  "commonMistakes": [
                                    "Subestimar contração levando a h_max muito pequeno.",
                                    "Ignorar acoplamento em sistemas multi-D."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -5y, y(0)=1 (decaimento exponencial), usando Euler explícito: região S = {z | |1+z| ≤1}, para λ=-5 real, h_max = 2/5 = 0.4. Com passos variáveis, inicie h=0.3 e ajuste se |1 + hλ| >1. Simule até t=2, verificando y_num ≈ e^{-5t}.",
                              "finalVerifications": [
                                "Calcula corretamente h_max para λ dado e método específico.",
                                "Simulação numérica permanece estável sem divergência.",
                                "Solução respeita contração para Re(λ)<0.",
                                "Ajusta h_k em passos variáveis adequadamente.",
                                "Compara com solução exata sem erro de estabilidade.",
                                "Identifica corretamente região S no plano z."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de h_max (erro <5%).",
                                "Correta representação gráfica da região de estabilidade.",
                                "Implementação bem-sucedida de passos variáveis.",
                                "Análise qualitativa de contração preservada.",
                                "Eficiência: passos mínimos sem perda de estabilidade.",
                                "Documentação clara de derivações e simulações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de sistemas dissipativos (ex: amortecedores).",
                                "Engenharia: Controle de processos com EDOs rígidas.",
                                "Computação: Otimização de solvers adaptativos em SciPy.",
                                "Estatística: Modelos estocásticos com estabilidade numérica."
                              ],
                              "realWorldApplication": "Em simulações de circuitos RC (y' = -1/RC y + u(t)), estimar h_max garante precisão em softwares como SPICE sem oscilações artificiais, essencial para design de eletrônicos estáveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Avaliar impacto de variações no passo",
                            "description": "Simular numericamente o efeito de mudanças abruptas em h sobre a estabilidade absoluta em métodos multistep, identificando oscilações ou divergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de estabilidade absoluta em métodos multistep",
                                  "subSteps": [
                                    "Relembrar o problema modelo y' = λy com Re(λ) < 0 e o teste de Dahlquist.",
                                    "Explicar a região de estabilidade absoluta para métodos multistep lineares (ex: polinômio de estabilidade ρ(z)/σ(z)).",
                                    "Discutir como o passo h afeta a estabilidade: |R(hλ)| ≤ 1 para estabilidade.",
                                    "Identificar métodos multistep comuns (ex: Adams-Moulton, BDF) e suas regiões de estabilidade.",
                                    "Estudar efeitos de h variáveis em esquemas adaptativos."
                                  ],
                                  "verification": "Resumir em um diagrama a região de estabilidade de um método multistep escolhido e explicar o papel de h.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software de plotagem (Python/MATLAB), notas de aula sobre estabilidade.",
                                  "tips": "Desenhe o plano complexo z = hλ para visualizar a região de estabilidade.",
                                  "learningObjective": "Compreender teoricamente como variações em h impactam a estabilidade absoluta.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; ignorar o multiplicador de amplificação R(z)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar simulação numérica com h constante",
                                  "subSteps": [
                                    "Escolher um método multistep (ex: Adams-Bashforth de ordem 2) e problema modelo com λ = -1.",
                                    "Codificar o método em Python/MATLAB para resolver y' = λy com condição inicial y(0)=1 e h fixo estável (ex: h=0.1).",
                                    "Executar simulação por N passos e plotar |y_n| vs n.",
                                    "Verificar se a solução decai monotonicamente (estável) ou cresce (instável).",
                                    "Testar h ligeiramente maior para borda da estabilidade."
                                  ],
                                  "verification": "Plot deve mostrar decaimento exponencial suave sem oscilações para h estável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy, Matplotlib) ou MATLAB, template de código para métodos multistep.",
                                  "tips": "Use loop explícito para multistep e armazene histórico de y para análise.",
                                  "learningObjective": "Implementar baseline estável para comparação posterior.",
                                  "commonMistakes": "Erro na inicialização multistep (passos iniciais errados); escala errada no plot."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular variações abruptas no passo h",
                                  "subSteps": [
                                    "Modificar código para alterar h abruptamente (ex: de h=0.1 para h=0.5 no passo k=50).",
                                    "Executar múltiplas simulações com diferentes pontos de mudança e magnitudes (aumento/redução).",
                                    "Registrar y_n antes/depois da mudança e plotar sobreposição com baseline.",
                                    "Repetir para diferentes métodos multistep e valores de λ.",
                                    "Salvar dados numéricos para análise quantitativa."
                                  ],
                                  "verification": "Observar plots mostrando oscilações ou crescimento imediato pós-mudança.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código da Step 2 modificado, planilha para registrar h_k e y_k.",
                                  "tips": "Use h_new = factor * h_old com factor >1 para abruptas; monitore |R(hλ)|.",
                                  "learningObjective": "Simular numericamente o impacto de mudanças em h na trajetória da solução.",
                                  "commonMistakes": "Não resetar histórico multistep corretamente na mudança; divisões por zero em h=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e identificar oscilações ou divergência",
                                  "subSteps": [
                                    "Calcular norma ||y|| em janelas pré/pós-mudança e detectar amplificação.",
                                    "Identificar padrões: oscilações (z real >1), divergência (crescimento exponencial).",
                                    "Comparar com teoria: verificar se h_newλ está fora da região de estabilidade.",
                                    "Quantificar impacto: % de aumento em erro ou passos até divergência.",
                                    "Documentar conclusões em relatório com plots e tabelas."
                                  ],
                                  "verification": "Relatório explica causalidade entre variação h e perda de estabilidade com evidências numéricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Códigos das steps anteriores, software de análise (Excel/Python Pandas).",
                                  "tips": "Use zoom nos plots pós-mudança; teste com λ complexo para oscilações.",
                                  "learningObjective": "Interpretar simulações para avaliar impacto qualitativa e quantitativamente.",
                                  "commonMistakes": "Atribuir oscilações a ruído numérico em vez de instabilidade; ignorar efeitos transitórios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Generalizar achados e propor mitigações",
                                  "subSteps": [
                                    "Resumir condições para oscilação/divergência (ex: h_max > limite de estabilidade).",
                                    "Testar mitigações: ramp-up gradual de h, reinicialização multistep.",
                                    "Discutir implicações para solvers adaptativos (ex: tolerâncias em h).",
                                    "Preparar apresentação com exemplos chave.",
                                    "Autoavaliar compreensão com perguntas de verificação."
                                  ],
                                  "verification": "Proposta de mitigação comprovada por simulação adicional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Relatório da Step 4, código para testes de mitigação.",
                                  "tips": "Simule ramp: h_k = h_{k-1} + δh com δh pequeno.",
                                  "learningObjective": "Aplicar insights para melhorar prática numérica.",
                                  "commonMistakes": "Generalizações sem base numérica; subestimar custos computacionais de mitigações."
                                }
                              ],
                              "practicalExample": "Usando Adams-Bashforth ordem 2 para y' = -y, y(0)=1: simule 100 passos com h=0.1 (estável), mude para h=1.0 no passo 50. Observe oscilações imediatas e divergência, pois hλ = -1.0 está fora da região de estabilidade (plot mostra |y| crescendo de ~0.05 para >1 em 10 passos).",
                              "finalVerifications": [
                                "Simulações mostram decaimento estável para h constante dentro da região.",
                                "Variações abruptas >20% em h causam oscilações detectáveis em plots.",
                                "Análise quantitativa confirma |R(hλ)| >1 pós-mudança leva a divergência.",
                                "Relatório inclui pelo menos 3 plots comparativos e tabela de normas.",
                                "Mitigação gradual preserva estabilidade em testes.",
                                "Explicação teórica alinha com resultados numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação multistep (erro <1e-6 em baseline).",
                                "Correta identificação de instabilidade em 80% dos casos simulados.",
                                "Qualidade dos plots e análises quantitativas (legíveis, anotados).",
                                "Profundidade da conexão teórica-numérica.",
                                "Criatividade e eficácia das mitigações propostas.",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de sistemas dinâmicos com passos adaptativos (ex: N-body).",
                                "Computação: Algoritmos numéricos e controle de erro em ODE solvers (SciPy).",
                                "Engenharia: Estabilidade em controle de processos industriais com amostragem variável.",
                                "Estatística: Análise de sensibilidade em modelos estocásticos."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), variações abruptas no passo h devido a refinamento de grade espacial podem induzir oscilações artificiais em previsões de temperatura; avaliação prévia previne divergências em simulações de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Estabilidade Absoluta para Equações com Autovalores Negativos",
                        "description": "Análise de estabilidade em sistemas lineares com autovalores reais negativos (problemas stiff), destacando métodos A-estáveis e L-estáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Identificar problemas com autovalores negativos",
                            "description": "Reconhecer EDOs stiff onde autovalores têm partes reais grandes e negativas, exigindo passos pequenos em métodos explícitos para estabilidade absoluta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de EDOs stiff e autovalores",
                                  "subSteps": [
                                    "Defina o que caracteriza uma Equação Diferencial Ordinária (EDO) stiff: presença de escalas temporais muito discrepantes.",
                                    "Explique o papel dos autovalores da matriz Jacobiana na análise de estabilidade de sistemas lineares y' = A y.",
                                    "Identifique que autovalores com partes reais grandes e negativas (Re(λ) << 0) indicam componentes que decaem rapidamente.",
                                    "Discuta como isso afeta a solução analítica e numérica.",
                                    "Revise a relação entre autovalores e constantes de tempo (τ = 1/|Re(λ)|)."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases definindo EDO stiff e o impacto de autovalores negativos grandes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise numérica",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Visualize graficamente: componentes rápidos (λ muito negativo) dominam inicialmente, mas decaem rápido.",
                                  "learningObjective": "Dominar a teoria básica de stiff equations e autovalores negativos.",
                                  "commonMistakes": "Confundir parte real negativa com instabilidade; lembrar que negativa indica decaimento estável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e analisar autovalores de uma matriz Jacobiana",
                                  "subSteps": [
                                    "Converta uma EDO não-linear em sua linearização: compute a matriz Jacobiana J = df/dy.",
                                    "Para sistemas lineares y' = A y, resolva det(A - λI) = 0 para encontrar autovalores λ.",
                                    "Calcule as partes reais Re(λ) para todos os autovalores.",
                                    "Classifique: se max|Re(λ)| / min|Re(λ)| >> 1 e Re(λ) < 0 grandes, é stiff.",
                                    "Use software para verificação numérica se analítico for complexo."
                                  ],
                                  "verification": "Compute autovalores de uma matriz exemplo e liste Re(λ); confirme se há discrepância > 1000.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB, Python com NumPy/SciPy ou calculadora matricial",
                                    "Exemplos de matrizes de aula"
                                  ],
                                  "tips": "Sempre verifique autovalores complexos: foque na parte real para stiff.",
                                  "learningObjective": "Habilitar cálculo preciso de autovalores e análise de suas partes reais.",
                                  "commonMistakes": "Esquecer autovalores complexos ou confundir com valores singulares; use eig() em software."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar sinais de problemas com autovalores negativos grandes",
                                  "subSteps": [
                                    "Examine o espectro de autovalores: procure Re(λ) ≤ -100 (regra prática para stiff).",
                                    "Compare magnitudes: razão |λ_rápido| / |λ_lento| > 10^3 indica stiff severo.",
                                    "Teste sensibilidade: solucione numericamente com passos grandes e observe oscilações ou instabilidade.",
                                    "Reconheça padrões comuns: autovalores reais negativos grandes em modelos reacionais ou amortecidos.",
                                    "Documente evidências: anote valores de λ e razões de escala."
                                  ],
                                  "verification": "Para um sistema dado, classifique como stiff ou não, justificando com valores de Re(λ).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Solver numérico como ode45 no MATLAB ou solve_ivp no SciPy",
                                    "Gráficos de soluções"
                                  ],
                                  "tips": "Plote o espectro no plano complexo para visualização intuitiva.",
                                  "learningObjective": "Desenvolver habilidade em diagnosticar stiff via análise espectral.",
                                  "commonMistakes": "Ignorar autovalores próximos de zero; stiff requer contraste grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações para estabilidade em métodos explícitos",
                                  "subSteps": [
                                    "Lembre a condição de estabilidade absoluta para Euler explícito: h < 2 / |λ_max| onde λ_max é o mais negativo.",
                                    "Calcule h_max necessário: para Re(λ) = -1000, h < 0.002.",
                                    "Compare com métodos implícitos (ex: Backward Euler), que são incondicionalmente estáveis.",
                                    "Simule: aplique método explícito com h inadequado e observe blow-up.",
                                    "Conclua: autovalores negativos grandes demandam h pequeno em explícitos, tornando-os ineficientes."
                                  ],
                                  "verification": "Simule uma EDO stiff com h grande explícito vs. implícito; descreva diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para solvers ODE",
                                    "Exemplos stiff prontos"
                                  ],
                                  "tips": "Use região de estabilidade no plano complexo para métodos explícitos (círculo unitário).",
                                  "learningObjective": "Entender por que métodos explícitos falham em stiff e necessidade de passos pequenos.",
                                  "commonMistakes": "Subestimar |λ|: sempre compute numericamente para precisão."
                                }
                              ],
                              "practicalExample": "Considere o sistema y' = [-999, 1; -1, -1000] y. Autovalores ≈ -999 e -1000 (Re << 0). Usando Euler explícito com h=0.01, solução explode; h deve ser <0.001 para estabilidade, identificando stiff.",
                              "finalVerifications": [
                                "Calcula corretamente autovalores e identifica Re(λ) grandes negativos.",
                                "Classifica o sistema como stiff com justificativa quantitativa (razão de escalas).",
                                "Explica impacto em passos de métodos explícitos (h < 2/|λ_max|).",
                                "Simula e demonstra instabilidade com h inadequado.",
                                "Distingue de casos não-stiff (ex: autovalores moderados)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores (erro <1%).",
                                "Correta identificação de stiff baseado em |Re(λ)| >100 e razão >10^3.",
                                "Explicação clara das implicações para estabilidade absoluta.",
                                "Uso adequado de simulações para validação.",
                                "Análise qualitativa e quantitativa integrada.",
                                "Ausência de confusão com estabilidade relativa ou condicional."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de osciladores amortecidos com amortecimento forte (ex: movimento browniano).",
                                "Engenharia Química: Reatores com reações rápidas/lentas (cinética química).",
                                "Computação Científica: Otimização de solvers ODE em bibliotecas como Sundials.",
                                "Engenharia Elétrica: Simulação de circuitos RLC com capacitores grandes."
                              ],
                              "realWorldApplication": "Em simulações de redes neurais recorrentes ou modelos climáticos com processos rápidos (ex: turbulência), autovalores negativos grandes causam stiff, exigindo solvers implícitos como BDF para eficiência computacional em previsões meteorológicas ou controle de aviões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Classificar métodos A-estáveis",
                            "description": "Verificar se um método (ex: trapezoidal, backward differentiation) é A-estável, ou seja, sua região de estabilidade inclui todo o semiplano esquerdo, usando o polinômio de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição de A-estabilidade",
                                  "subSteps": [
                                    "Revise o conceito de estabilidade absoluta para métodos numéricos de resolução de EDOs lineares y' = λy com Re(λ)<0.",
                                    "Defina A-estabilidade: a região de estabilidade absoluta inclui todo o semiplano esquerdo {z ∈ ℂ | Re(z) < 0}.",
                                    "Estude a relação com o polinômio de estabilidade R(z) do método.",
                                    "Analise exemplos iniciais de métodos não A-estáveis como Euler forward.",
                                    "Discuta implicações para problemas stiff."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de A-estabilidade e dê um contraexemplo de método não A-estável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre estabilidade",
                                    "Papel e calculadora"
                                  ],
                                  "tips": [
                                    "Lembre-se: A-estabilidade é crucial para h grandes em problemas stiff.",
                                    "Use diagramas do plano complexo para visualizar o semiplano esquerdo."
                                  ],
                                  "learningObjective": "Compreender conceitualmente o que torna um método A-estável e sua importância.",
                                  "commonMistakes": [
                                    "Confundir com estabilidade relativa.",
                                    "Ignorar o semiplano esquerdo completo, focando só no eixo imaginário."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o polinômio de estabilidade R(z) para um método dado",
                                  "subSteps": [
                                    "Identifique o método (ex: trapezoidal: y_{n+1} = y_n + (h/2)(f_n + f_{n+1}), ou BDF1: y_{n+1} = y_n + h f_{n+1}).",
                                    "Aplique o teste de estabilidade: assuma y_n = ρ^n, derive R(z) onde z = hλ.",
                                    "Para trapezoidal, calcule R(z) = (1 + z/2)/(1 - z/2).",
                                    "Para BDF1 (backward Euler), calcule R(z) = 1/(1 - z).",
                                    "Verifique o grau e coeficientes do polinômio."
                                  ],
                                  "verification": "Escreva explicitamente R(z) para dois métodos e confirme com fórmula padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de métodos numéricos",
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Lápis e papel"
                                  ],
                                  "tips": [
                                    "Padronize z = hλ com λ negativo real primeiro para testes simples.",
                                    "Mantenha frações exatas para evitar erros numéricos."
                                  ],
                                  "learningObjective": "Calcular corretamente o polinômio de estabilidade R(z) a partir da esquematização do método.",
                                  "commonMistakes": [
                                    "Erro no sinal de z (lembre z = hλ, λ<0 implica Re(z)<0).",
                                    "Confundir numerador e denominador em métodos implícitos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar |R(z)| no semiplano esquerdo",
                                  "subSteps": [
                                    "Defina a região de estabilidade S = {z | |R(z)| ≤ 1}.",
                                    "Teste no eixo imaginário: compute |R(iy)| para y ∈ ℝ e verifique se ≤1.",
                                    "Para Re(z)<0, use propriedades analíticas: |R(z)| ≤1 se o método satisfaz condições de Dahlquist.",
                                    "Aplique teorema: para métodos A-estáveis, |R(iy)|=1 e função de dissipação ≥0.",
                                    "Plote ou esboce a fronteira de estabilidade."
                                  ],
                                  "verification": "Mostre que |R(iy)| ≤1 para y∈ℝ e argumente inclusão do semiplano esquerdo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráfica do plano complexo",
                                    "Python/MATLAB para plotar |R(z)|",
                                    "Tabela de valores de teste"
                                  ],
                                  "tips": [
                                    "Comece com z = i y puro; se |R|=1, é candidato forte.",
                                    "Use transformação bilinear para métodos como trapezoidal."
                                  ],
                                  "learningObjective": "Avaliar analiticamente se S contém o semiplano esquerdo.",
                                  "commonMistakes": [
                                    "Testar só pontos reais negativos, ignorando imaginários.",
                                    "Confundir |R(z)|≤1 com Re(R(z))≤1."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar métodos específicos como A-estáveis",
                                  "subSteps": [
                                    "Classifique trapezoidal: prove |R(z)| =1 no eixo imaginário e <1 dentro do semiplano esquerdo.",
                                    "Classifique BDF1: mostre |R(z)| <1 para Re(z)<0.",
                                    "Compare com métodos não A-estáveis como Euler forward (R(z)=1+z, instável).",
                                    "Liste propriedades: A-estáveis são L-estáveis se também |R(∞)|=0.",
                                    "Documente classificações em tabela."
                                  ],
                                  "verification": "Crie uma tabela classificando 3 métodos com justificativa breve para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de métodos comuns (trapezoidal, BDF1, BDF2)",
                                    "Referência teórica (Hairer et al.)"
                                  ],
                                  "tips": [
                                    "Trapezoidal é A-estável mas não L-estável; BDF1 é ambos.",
                                    "Memorize: todos BDF até ordem 2 são A-estáveis, ordem 3 não."
                                  ],
                                  "learningObjective": "Aplicar análise para classificar métodos conhecidos.",
                                  "commonMistakes": [
                                    "Classificar trapezoidal como não A-estável por oscilações.",
                                    "Esquecer que A-estabilidade requer inclusão estrita do semiplano."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar classificação com simulações numéricas",
                                  "subSteps": [
                                    "Implemente o método em código para EDO teste y'=-50y + sin(t), h grande.",
                                    "Compare soluções numérica vs exata para Re(λ)<0.",
                                    "Meça erro e observe se converge para hλ → -∞.",
                                    "Repita para método não A-estável e contraste.",
                                    "Analise resíduos de estabilidade."
                                  ],
                                  "verification": "Execute simulação e confirme ausência de instabilidade para h grande.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "EDO teste stiff"
                                  ],
                                  "tips": [
                                    "Use λ=-100 para stiff; plote log(error) vs log(h).",
                                    "Valide código com solução analítica conhecida."
                                  ],
                                  "learningObjective": "Confirmar classificação teórica empiricamente via implementação.",
                                  "commonMistakes": [
                                    "Escolha h pequena onde todos métodos funcionam.",
                                    "Ignorar erros de arredondamento em simulações."
                                  ]
                                }
                              ],
                              "practicalExample": "Classifique o método trapezoidal: R(z) = (1 + z/2)/(1 - z/2). No eixo imaginário z=iy, |R(iy)| = |(1 + iy/2)/(1 - iy/2)| =1. Pelo teorema de dissipação, é A-estável. Simule y' = -100y, h=0.1: solução numérica converge à exata sem oscilações.",
                              "finalVerifications": [
                                "Classifica corretamente trapezoidal e backward Euler como A-estáveis.",
                                "Explica por que Euler forward não é A-estável.",
                                "Computa |R(iy)|=1 para trapezoidal.",
                                "Identifica semiplano esquerdo em diagrama de estabilidade.",
                                "Simula numericamente um caso stiff sem instabilidade.",
                                "Lista 2 métodos A-estáveis e 1 não."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de R(z) (100% correto).",
                                "Justificativa analítica completa para inclusão do semiplano.",
                                "Uso correto de testes no eixo imaginário.",
                                "Análise de erros comuns evitados.",
                                "Simulação numérica com interpretação adequada.",
                                "Clareza na tabela de classificação."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para análise de estabilidade.",
                                "Física: Modelagem de sistemas dissipativos (ex: amortecedores).",
                                "Engenharia: Simulação de circuitos RC stiff.",
                                "Estatística: Análise de erros em métodos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (cinética enzimática), onde autovalores negativos grandes exigem A-estabilidade para passos de tempo eficientes sem instabilidade, usado em software como COMSOL ou MATLAB ODE solvers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Aplicar análise em problemas stiff",
                            "description": "Resolver numericamente uma EDO stiff com autovalores negativos usando métodos implícitos, comparando com explícitos e avaliando eficiência computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e caracterizar problemas stiff em EDOs",
                                  "subSteps": [
                                    "Definir problema stiff: EDOs com autovalores reais negativos de magnitudes muito diferentes (ex: eigenvalues λ1 ≈ -1, λ2 ≈ -1000).",
                                    "Explicar impacto na estabilidade: métodos explícitos requerem passos h << 1/|λ_max| para estabilidade.",
                                    "Analisar razão de escalas de tempo: componente rápida (stiff) vs. lenta.",
                                    "Identificar exemplo: sistema linear y' = A y, com A = diag(-1, -1000).",
                                    "Plotar solução analítica para referência."
                                  ],
                                  "verification": "Resumir em relatório curto as características do problema stiff e plotar solução exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy, SciPy, Matplotlib",
                                    "Documentação de análise numérica"
                                  ],
                                  "tips": "Use eigenvalues para quantificar 'stiffness'; teste com diferentes magnitudes de λ.",
                                  "learningObjective": "Identificar quando uma EDO é stiff e suas implicações para métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade",
                                    "Ignorar autovalores complexos",
                                    "Não normalizar escalas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar método explícito (Euler forward)",
                                  "subSteps": [
                                    "Codificar Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Escolher h inicial razoável (ex: h=0.01) e simular até t=10.",
                                    "Observar instabilidade: solução explode para h > 1/|λ_max|.",
                                    "Reduzir h iterativamente até estabilidade e registrar número de passos.",
                                    "Plotar solução numérica vs. exata e medir erro."
                                  ],
                                  "verification": "Gráficos mostram blow-up para h grande; erro baixo só com h muito pequeno.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "NumPy para vetores",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Monitore norma ||y|| para detectar instabilidade precoce.",
                                  "learningObjective": "Demonstrar limitação de métodos explícitos em problemas stiff.",
                                  "commonMistakes": [
                                    "Passo h fixo sem adaptação",
                                    "Não testar múltiplos h",
                                    "Ignorar custo computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método implícito (Backward Euler)",
                                  "subSteps": [
                                    "Formular Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Resolver equação não-linear por iteração de ponto fixo ou Newton (para linear, fórmula fechada).",
                                    "Simular com h maior (ex: h=0.1, 10x maior que explícito estável).",
                                    "Verificar estabilidade incondicional para autovalores negativos.",
                                    "Plotar solução e comparar com exata."
                                  ],
                                  "verification": "Solução estável e precisa com h grande; convergência rápida do solver.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SciPy solve_ivp ou fsolve para não-lineares",
                                    "Código Python customizado"
                                  ],
                                  "tips": "Para lineares, use (I - hA)^{-1}; pré-condicione para eficiência.",
                                  "learningObjective": "Aplicar métodos implícitos para superar restrições de estabilidade.",
                                  "commonMistakes": [
                                    "Não iterar o suficiente no solver",
                                    "Usar h muito grande sem verificar precisão",
                                    "Confundir forward/backward"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções e eficiência computacional",
                                  "subSteps": [
                                    "Executar ambos métodos com h que deem erro similar (ex: <1e-3).",
                                    "Medir tempo de CPU (timeit) e número de passos para intervalo [0,10].",
                                    "Calcular eficiência: passos/hora ou FLOPs aproximados.",
                                    "Plotar erros vs. h (ordem de convergência O(h)).",
                                    "Tabelar resultados: precisão, tempo, h usado."
                                  ],
                                  "verification": "Tabela mostra implícito ~10x mais eficiente para stiff.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "timeit ou %timeit no Jupyter",
                                    "Pandas para tabelas"
                                  ],
                                  "tips": "Repita simulações 10x para média de tempo; use log-scale em plots.",
                                  "learningObjective": "Quantificar vantagens de implícitos em eficiência.",
                                  "commonMistakes": [
                                    "Comparar h fixos sem igualar erro",
                                    "Não isolar overhead do solver",
                                    "Ignorar vetorização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e formular conclusões",
                                  "subSteps": [
                                    "Interpretar: por que implícitos permitem h maior apesar de custo por passo?",
                                    "Discutir trade-offs: stiff solvers como BDF em SciPy.",
                                    "Generalizar para sistemas maiores ou não-lineares.",
                                    "Escrever relatório com gráficos, tabelas e recomendações.",
                                    "Testar variação: mude λ_max e reavalie."
                                  ],
                                  "verification": "Relatório explica análise A-stability e escolhas de método.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "LaTeX ou Markdown para relatório",
                                    "Códigos anteriores"
                                  ],
                                  "tips": "Enfatize região de estabilidade no plano complexo.",
                                  "learningObjective": "Sintetizar análise para decisão informada de métodos.",
                                  "commonMistakes": [
                                    "Não discutir limitações implícitos (ex: oscilações)",
                                    "Generalizações sem testes",
                                    "Relatório sem quantificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema y' = A y com A = [[-1, 0], [0, -1000]], y(0)=[1,1]. Explícito falha para h>0.001; Backward Euler resolve estável com h=0.1 em ~10 passos vs. 10000 explícitos, com tempo 20x menor.",
                              "finalVerifications": [
                                "Reproduzir solução estável implícita com h=0.1 (erro <1e-3).",
                                "Mostrar blow-up explícito para h=0.01.",
                                "Tabela compara tempos: implícito < explícito para erro igual.",
                                "Explicar A-stability verbalmente.",
                                "Plot erros vs. h convergindo O(h).",
                                "Adaptar código para λ=-5000 e confirmar escalabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro global <1e-3 em ambos componentes.",
                                "Eficiência: quantificação numérica (tempo/passos) com >5x ganho implícito.",
                                "Código: limpo, comentado, reproduzível.",
                                "Gráficos: claros, com legendas, escalas adequadas.",
                                "Análise: explica estabilidade via autovalores.",
                                "Relatório: conciso, com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Física: modelagem de circuitos RLC com constantes de tempo díspares.",
                                "Computação: otimização numérica e solvers em SciPy/ODEPACK.",
                                "Engenharia Química: simulação de reações stiff (rápida/lenta).",
                                "Biologia Computacional: dinâmica populacional com decaimentos rápidos."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, onde reações rápidas (stiff) e lentas coexistem, métodos implícitos permitem simulações em tempo real para controle de processos industriais, reduzindo tempo de CPU em ordens de magnitude."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Métodos A-Estáveis",
                    "description": "Métodos cuja região de estabilidade inclui o semiplano esquerdo complexo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Definição de Métodos A-Estáveis",
                        "description": "Conceito fundamental de métodos numéricos para EDOs cuja região de estabilidade absoluta inclui todo o semiplano esquerdo do plano complexo, garantindo estabilidade incondicional para valores próprios com parte real negativa.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar a região de estabilidade absoluta",
                            "description": "Compreender e representar graficamente a região de estabilidade absoluta no plano complexo para métodos de Runge-Kutta ou lineares multistep, verificando se ela contém o semiplano esquerdo Re(z) ≤ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de região de estabilidade absoluta",
                                  "subSteps": [
                                    "Estude a definição formal: a região de estabilidade absoluta S é o conjunto de z ∈ ℂ tal que |R(z)| ≤ 1, onde R(z) é a função de amplificação do método.",
                                    "Identifique que para métodos A-estáveis, S deve conter o semiplano esquerdo {z | Re(z) ≤ 0}.",
                                    "Diferencie estabilidade absoluta de estabilidade relativa.",
                                    "Revise exemplos clássicos como o método de Euler explícito (S é o disco unitário centrado em -1).",
                                    "Anote as condições matemáticas para |R(z)| ≤ 1."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e cite um exemplo correto de S para Euler explícito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula, papel e caneta.",
                                  "tips": "Use diagramas do plano complexo para visualizar o semiplano esquerdo desde o início.",
                                  "learningObjective": "Compreender conceitualmente a região de estabilidade absoluta e seu critério A-estável.",
                                  "commonMistakes": "Confundir estabilidade absoluta com condicional; ignorar que é para hλ com λ próprio negativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de amplificação R(z) para um método específico",
                                  "subSteps": [
                                    "Escolha um método, ex: Runge-Kutta de ordem 2 ou método de trapezoidal.",
                                    "Escreva a fórmula do método e derive R(z) resolvendo a equação de teste y' = λy.",
                                    "Calcule |R(z)| para pontos teste no semiplano esquerdo.",
                                    "Simplifique R(z) simbolicamente se possível.",
                                    "Verifique lim_{z→∞} R(z) = 0 para métodos A(α)-estáveis."
                                  ],
                                  "verification": "Obtenha R(z) correta para o método escolhido e compute |R(iy)| < 1 para y real.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software simbólico (Mathematica ou SymPy), calculadora, quadro branco.",
                                  "tips": "Comece com métodos lineares multistep simples como backward Euler (R(z) = 1/(1-z)).",
                                  "learningObjective": "Calcular a função de amplificação R(z) para métodos Runge-Kutta ou multistep.",
                                  "commonMistakes": "Erro na derivação da soma ponderada em Runge-Kutta; esquecer fator h em z = hλ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e plotar graficamente a região S no plano complexo",
                                  "subSteps": [
                                    "Defina uma grade no plano complexo (ex: Re(z) de -10 a 1, Im(z) de -10 a 10).",
                                    "Compute |R(z)| para cada ponto da grade.",
                                    "Marque pontos onde |R(z)| ≤ 1 como interior de S.",
                                    "Plote as fronteiras usando contour plot.",
                                    "Sobreponha o semiplano esquerdo para visualização."
                                  ],
                                  "verification": "Gere um gráfico onde S seja claramente delineada e contenha ou não o semiplano.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com Matplotlib e NumPy, ou MATLAB; template de código para contourf.",
                                  "tips": "Use meshgrid para eficiência; teste com resolução fina nas bordas.",
                                  "learningObjective": "Representar visualmente a região de estabilidade absoluta.",
                                  "commonMistakes": "Escala inadequada no eixo imaginário; plotar |R(z)| >1 como estável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar se S contém o semiplano esquerdo Re(z) ≤ 0",
                                  "subSteps": [
                                    "Selecione pontos representativos no semiplano (ex: eixo real negativo, eixo imaginário puro).",
                                    "Prove ou disprove ∀ z com Re(z) ≤ 0, |R(z)| ≤ 1.",
                                    "Use teorema de máxima ou propriedades analíticas de R(z).",
                                    "Classifique o método como A-estável se verdadeiro.",
                                    "Documente contraexemplos se falso."
                                  ],
                                  "verification": "Confirme |R(z)| ≤ 1 para 10 pontos aleatórios no semiplano e prove para o método.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráfico do step 3, software de plot, referências teóricas.",
                                  "tips": "Para Runge-Kutta implícitos, lembre que são A-estáveis por construção Butcher.",
                                  "learningObjective": "Avaliar a propriedade A-estável de um método numérico.",
                                  "commonMistakes": "Verificar apenas eixo real; ignorar instabilidade no imaginário puro."
                                }
                              ],
                              "practicalExample": "Para o método de Euler implícito: R(z) = 1/(1 - z). Plote S: todo o plano complexo exceto disco |1 - z| < 1 centrado em 1. Verifique: contém Re(z) ≤ 0 pois |R(z)| < 1 para Re(z) < 0.",
                              "finalVerifications": [
                                "Região S plotada corretamente com |R(z)| ≤ 1 sombreada.",
                                "Semiplano esquerdo inteiramente dentro de S.",
                                "R(z) derivada e validada para método escolhido.",
                                "Classificação A-estável justificada matematicamente.",
                                "Gráfico inclui legendas, eixos rotulados e escala apropriada.",
                                "Testes numéricos em pontos críticos confirmam |R(z)| ≤ 1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) (100% correto).",
                                "Qualidade visual do plot de S (clareza, resolução).",
                                "Correta verificação de inclusão do semiplano (prova ou contraexemplo).",
                                "Explicação conceitual completa e sem erros.",
                                "Eficiência computacional no código de plotagem.",
                                "Conexão com propriedades A-estáveis documentada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de EDOs para osciladores amortecidos.",
                                "Computação: Implementação de solvers numéricos em SciPy odeint.",
                                "Engenharia: Análise de sistemas lineares em controle automático.",
                                "Matemática Pura: Funções analíticas e teorema de Schwarz."
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff como reações químicas ou circuitos elétricos, identificar métodos A-estáveis garante estabilidade sem restrições em h, permitindo passos de tempo maiores e simulações mais rápidas em software como COMSOL ou MATLAB Simulink."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Definir A-estabilidade formalmente",
                            "description": "Enunciar a definição matemática de A-estabilidade: |R(iy)| ≤ 1 e |R(z)| ≤ 1 para todo z com Re(z) ≤ 0, onde R(z) é a função de amplificação do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de função de amplificação R(z)",
                                  "subSteps": [
                                    "Lembre-se que métodos de Runge-Kutta ou lineares multistep aplicados a y' = λy geram y_{n+1} = R(z) y_n, onde z = hλ.",
                                    "Identifique R(z) para métodos simples como Euler forward (R(z) = 1 + z) e backward (R(z) = 1/(1 - z)).",
                                    "Desenhe o plano complexo e marque pontos z com |R(z)| > 1 para instabilidade.",
                                    "Calcule |R(iy)| para y real em Euler forward.",
                                    "Explique verbalmente o papel de R(z) na estabilidade."
                                  ],
                                  "verification": "Escreva a expressão de R(z) para pelo menos dois métodos e compute |R(i)| para cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou software de desenho (GeoGebra/Desmos)",
                                    "Notas de aula sobre métodos numéricos"
                                  ],
                                  "tips": "Sempre associe R(z) ao teste de Dahlquist para EDOs lineares.",
                                  "learningObjective": "Compreender que R(z) determina o comportamento assintótico da solução numérica.",
                                  "commonMistakes": [
                                    "Confundir R(z) com o polinômio de estabilidade",
                                    "Esquecer que z = hλ, com λ eigenvalue"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o semiplano esquerdo de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina o semiplano esquerdo: {z ∈ ℂ | Re(z) ≤ 0}.",
                                    "Explique por que este semiplano é relevante para EDOs com partes reais negativas (estáveis).",
                                    "Desenhe o semiplano no plano complexo, sombreando Re(z) ≤ 0.",
                                    "Discuta o que |R(z)| ≤ 1 significa: não amplifica erros.",
                                    "Marque o eixo imaginário puro (z = iy, y ∈ ℝ)."
                                  ],
                                  "verification": "Desenhe o semiplano e rotule pontos como -1, i, -1+i.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Plano complexo impresso ou software como Mathematica/MATLAB"
                                  ],
                                  "tips": "Pense em λ com Re(λ) < 0 para decaimento exponencial.",
                                  "learningObjective": "Visualizar geometricamente a região de estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Confundir com semiplano direito",
                                    "Esquecer inclusão da fronteira Re(z)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as condições específicas de A-estabilidade",
                                  "subSteps": [
                                    "Estude a condição no eixo imaginário: |R(iy)| ≤ 1 para todo y ∈ ℝ.",
                                    "Verifique para Backward Euler: R(iy) = 1/(1 - iy), compute |R(iy)| = 1/sqrt(1 + y²) ≤ 1.",
                                    "Analise a condição geral: |R(z)| ≤ 1 ∀ z com Re(z) ≤ 0.",
                                    "Compare com A(α)-estabilidade (setor cônico).",
                                    "Escreva as duas condições juntas."
                                  ],
                                  "verification": "Prove que |R(iy)| ≤ 1 para Backward Euler e verifique um ponto z = -1 + i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para plots de |R(z)|",
                                    "Exemplos de métodos A-estáveis"
                                  ],
                                  "tips": "Use propriedades analíticas de R(z) racional para simplificar.",
                                  "learningObjective": "Dominar as duas condições matemáticas exatas.",
                                  "commonMistakes": [
                                    "Trocar ≤1 por <1",
                                    "Esquecer 'para todo z' ou 'todo y'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar e memorizar a definição completa",
                                  "subSteps": [
                                    "Enuncie: Um método é A-estável se |R(iy)| ≤ 1 ∀ y ∈ ℝ e |R(z)| ≤ 1 ∀ z, Re(z) ≤ 0.",
                                    "Escreva em notação matemática formal com símbolos.",
                                    "Compare com estabilidade forte (A(0)-estável com ordem >1).",
                                    "Crie um mnemônico: 'Imaginário primeiro, depois o semiplano inteiro'.",
                                    "Recite a definição 5 vezes de cor."
                                  ],
                                  "verification": "Escreva a definição exata sem olhar notas e explique cada parte.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Caderno para escrita repetida",
                                    "Flashcards com definição"
                                  ],
                                  "tips": "Associe a Dahlquist (1975) como origem do conceito.",
                                  "learningObjective": "Enunciar precisamente a definição formal.",
                                  "commonMistakes": [
                                    "Omitir uma das condições",
                                    "Usar |R(z)| < 1 em vez de ≤1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler aplicado a y' = λy com λ = -100 (stiff), z = hλ com h=0.01, z≈-1. R(-1)=1/(1-(-1))=0.5, |R(-1)|=0.5≤1, estável. No eixo imaginário, z=i, |R(i)|=1/sqrt(2)≤1.",
                              "finalVerifications": [
                                "Enuncie a definição completa sem erros.",
                                "Identifique corretamente o semiplano esquerdo.",
                                "Dê um exemplo de método A-estável e verifique uma condição.",
                                "Explique a diferença entre |R(iy)|≤1 e a condição geral.",
                                "Desenhe a região e marque pontos de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% dos símbolos corretos).",
                                "Compreensão conceitual (explicação verbal clara).",
                                "Exemplo prático correto com cálculo numérico.",
                                "Identificação de erros comuns evitados.",
                                "Visualização gráfica precisa do semiplano."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos (EDOs stiff).",
                                "Computação: Implementação de solvers em ODEPACK/Scipy.",
                                "Engenharia: Controle de sistemas dinâmicos estáveis.",
                                "Análise Complexa: Funções analíticas e regiões de convergência."
                              ],
                              "realWorldApplication": "Em simulações numéricas de reações químicas stiff ou circuitos elétricos RC, onde eigenvalues têm partes reais negativas grandes, métodos A-estáveis como Backward Euler ou TR-BDF2 previnem instabilidade sem passos h minúsculos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Diferenciar A-estabilidade de estabilidade forte",
                            "description": "Comparar A-estabilidade (inclui semiplano esquerdo) com estabilidade de Dahlquist (intervalo [-β,0]) e explicar implicações para passos de tempo variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de A-estabilidade",
                                  "subSteps": [
                                    "Estude a definição formal: um método numérico é A-estável se sua região de estabilidade absoluta S contém o semiplano complexo esquerdo {z ∈ ℂ | Re(z) ≤ 0}.",
                                    "Analise o teste de estabilidade para o problema modelo y' = λy com Re(λ) < 0.",
                                    "Examine exemplos como o método de Euler implícito (A-estável) versus Euler explícito (não A-estável).",
                                    "Desenhe a região de estabilidade no plano complexo para métodos conhecidos.",
                                    "Verifique a relação com problemas stiff onde |Im(λ)| >> |Re(λ)|."
                                  ],
                                  "verification": "Desenhe e rotule corretamente a região de estabilidade de um método A-estável, confirmando inclusão do semiplano esquerdo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e lápis para diagramas, software como MATLAB para plots de estabilidade.",
                                  "tips": "Use o teste |R(z)| ≤ 1 para z no semiplano esquerdo, onde R(z) é a função de amplificação.",
                                  "learningObjective": "Compreender precisamente o que constitui A-estabilidade e sua representação gráfica.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade relativa; esquecer que A-estabilidade é para métodos consistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a estabilidade forte de Dahlquist",
                                  "subSteps": [
                                    "Defina estabilidade forte: para métodos multistep lineares, o polinômio de estabilidade ρ(z) tem raízes |z| ≤ 1, com raízes |z|=1 simples.",
                                    "Relacione com o intervalo [-β, 0] no eixo real negativo: a região de estabilidade inclui pelo menos [-β, 0] para algum β > 0.",
                                    "Compare com classes A(α): estabilidade forte é um requisito básico para convergência em problemas não-stiff.",
                                    "Estude exemplos: método de Euler explícito (estável forte para β pequeno) vs trapezoidal.",
                                    "Calcule ρ(z) e σ(z) para métodos simples e verifique as raízes."
                                  ],
                                  "verification": "Liste as condições de Dahlquist para estabilidade forte e aplique a um método multistep, confirmando raízes unitárias simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Notas de aula sobre métodos multistep, calculadora simbólica (ex: SymPy), tabela de polinômios ρ e σ.",
                                  "tips": "Lembre-se: estabilidade forte garante convergência para h fixo, mas não lida bem com stiff.",
                                  "learningObjective": "Dominar os critérios algébricos de estabilidade forte e sua limitação ao eixo real.",
                                  "commonMistakes": "Ignorar a multiplicidade das raízes unitárias; confundir com zero-estabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar A-estabilidade e estabilidade forte",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: região de estabilidade (semiplano vs intervalo [-β,0]), aplicabilidade (stiff vs não-stiff), exemplos de métodos.",
                                    "Discuta diferenças: A-estabilidade é mais restritiva, requer métodos implícitos; estabilidade forte é necessária mas insuficiente para stiff.",
                                    "Analise interseções: métodos A-estáveis são fortemente estáveis, mas o inverso não vale.",
                                    "Plote regiões sobrepostas no plano z.",
                                    "Resuma implicações: A-estabilidade permite passos maiores em stiff problems."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um método fortemente estável pode falhar em problemas stiff.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou LaTeX para tabela, software de plotagem (ex: Python Matplotlib).",
                                  "tips": "Use setas no diagrama para mostrar inclusão: estabilidade forte ⊂ A-estabilidade não necessariamente.",
                                  "learningObjective": "Identificar diferenças chave e hierarquia entre os conceitos.",
                                  "commonMistakes": "Achar que estabilidade forte inclui o semiplano; ignorar exemplos contrários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações para passos de tempo variáveis",
                                  "subSteps": [
                                    "Explique como A-estabilidade permite adaptação de h sem perda de estabilidade em stiff regions.",
                                    "Compare com estabilidade forte: requer controle estrito de h ≤ β/|λ|.",
                                    "Simule um problema stiff com passos variáveis usando métodos A-estável vs não.",
                                    "Discuta custos computacionais: implícitos mais caros, mas eficientes para h variáveis.",
                                    "Conclua com critérios de escolha em solvers adaptativos (ex: ode45 vs ode15s)."
                                  ],
                                  "verification": "Simule numericamente e mostre que passos variáveis falham sem A-estabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Octave/Python (SciPy) para simulações, problema teste y' = -1000y + sin(t).",
                                  "tips": "Comece com h fixo para baseline, depois adapte.",
                                  "learningObjective": "Entender impactos práticos em algoritmos adaptativos.",
                                  "commonMistakes": "Subestimar overhead de implícitos; não testar com eigenvalues complexos."
                                }
                              ],
                              "practicalExample": "Considere resolver y' = -100y + sin(t), y(0)=0. O método backward Euler (A-estável) mantém estabilidade com h variáveis até h=0.1, enquanto forward Euler (fortemente estável só para h<0.01) oscila e diverge com h variáveis maiores.",
                              "finalVerifications": [
                                "Desenhar corretamente regiões de estabilidade para ambos conceitos.",
                                "Listar 3 métodos A-estáveis e confirmar sua estabilidade forte.",
                                "Explicar falha de método fortemente estável em problema stiff.",
                                "Simular exemplo prático mostrando implicações de h variáveis.",
                                "Comparar verbalmente diferenças e implicações.",
                                "Identificar corretamente A(α)-estabilidade como extensão."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% match com literatura).",
                                "Clareza na comparação tabular/gráfica.",
                                "Correção em simulações numéricas.",
                                "Profundidade nas implicações para h variáveis.",
                                "Uso correto de terminologia (ex: função de amplificação R(z)).",
                                "Criatividade em exemplos e conexões práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de osciladores amortecidos stiff.",
                                "Engenharia: controle de sistemas dinâmicos com solvers adaptativos.",
                                "Ciência da Computação: otimização de algoritmos numéricos em HPC.",
                                "Matemática Aplicada: análise de convergência em PDEs parabólicas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC stiff ou reações químicas rápidas/lentas, métodos A-estáveis com passos variáveis (ex: em COMSOL ou LSODE) reduzem tempo computacional em 10x comparado a métodos só fortemente estáveis, permitindo análises em tempo real."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Exemplos de Métodos A-Estáveis",
                        "description": "Métodos clássicos de passo simples implícitos e lineares multistep que satisfazem A-estabilidade, como Backward Euler e Trapezoidal Rule.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Analisar o método Backward Euler",
                            "description": "Derivar a função de amplificação R(z) = 1/(1-z) para o Backward Euler e verificar que |R(z)| ≤ 1 para Re(z) ≤ 0, plotando sua região de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do método Backward Euler",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial ordinária modelo y' = λ y, com λ complexo.",
                                    "Escreva a iteração do Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Para o modelo linear, substitua f(t,y) = λ y, obtendo y_{n+1} = y_n + h λ y_{n+1}.",
                                    "Resolva para y_{n+1} em termos de y_n: y_{n+1} (1 - h λ) = y_n.",
                                    "Expresse y_{n+1} / y_n = 1 / (1 - h λ)."
                                  ],
                                  "verification": "Confirme que a fórmula iterativa y_{n+1} = y_n / (1 - h λ) está correta comparando com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Use notação consistente com h como passo de tempo e z = h λ.",
                                  "learningObjective": "Compreender a natureza implícita do Backward Euler e sua discretização.",
                                  "commonMistakes": [
                                    "Confundir com Forward Euler (explícito)",
                                    "Esquecer o argumento t_{n+1} na função f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de amplificação R(z)",
                                  "subSteps": [
                                    "Defina z = h λ, onde λ é o autovalor com Re(λ) ≤ 0.",
                                    "Da relação y_{n+1} = y_n / (1 - h λ), reescreva como y_{n+1} / y_n = 1 / (1 - z).",
                                    "Identifique R(z) = 1 / (1 - z) como a função de amplificação.",
                                    "Verifique o limite quando z → 0: R(z) ≈ 1 + z + z² + ..., consistente com expansão em série.",
                                    "Anote a fórmula final R(z) = 1/(1 - z)."
                                  ],
                                  "verification": "Escreva R(z) explicitamente e teste com z = -1: R(-1) = 1/2, que é correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy",
                                    "Papel para derivações"
                                  ],
                                  "tips": "Sempre normalize pela solução exata e^{z} para validar.",
                                  "learningObjective": "Derivar corretamente a função de amplificação para métodos lineares implícitos.",
                                  "commonMistakes": [
                                    "Erro de sinal em z = h λ",
                                    "Esquecer de inverter corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade |R(z)| ≤ 1 para Re(z) ≤ 0",
                                  "subSteps": [
                                    "Considere z = x + i y com x ≤ 0 (semiplano esquerdo).",
                                    "Compute |R(z)|^2 = |1/(1 - z)|^2 = 1 / |(1 - x) - i y|^2 = 1 / [(1 - x)^2 + y^2].",
                                    "Mostre que (1 - x)^2 + y^2 ≥ 1 para x ≤ 0, pois 1 - x ≥ 1 e y^2 ≥ 0.",
                                    "Conclua que |R(z)|^2 ≤ 1, logo |R(z)| ≤ 1.",
                                    "Teste pontos boundary: z = 0 (|R|=1), z = i (|R|=1/√2 <1)."
                                  ],
                                  "verification": "Prove matematicamente que (1 - x)^2 + y^2 ≥ 1 para x ≤ 0 e compute |R(i∞)| → 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra computacional como Mathematica ou Python com NumPy"
                                  ],
                                  "tips": "Use desigualdade triangular ou geometria complexa para intuição.",
                                  "learningObjective": "Analisar estabilidade absoluta usando módulo da função de amplificação.",
                                  "commonMistakes": [
                                    "Confundir Re(z) ≤ 0 com |z| ≤ 1",
                                    "Erro no cálculo de |1 - z|^2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e interpretar a região de estabilidade",
                                  "subSteps": [
                                    "Defina a grade no plano complexo z para Re(z) ≤ 0 e Im(z) de -10 a 10.",
                                    "Compute |R(z)| em uma malha usando código Python/MATLAB.",
                                    "Plote o contorno onde |R(z)| = 1 e sombreie onde |R(z)| ≤ 1.",
                                    "Observe que a região é o semiplano esquerdo inteiro, confirmando A-estabilidade.",
                                    "Compare visualmente com Forward Euler (círculo unitário)."
                                  ],
                                  "verification": "O plot mostra |R(z)| ≤ 1 exatamente para Re(z) ≤ 0, sem vazamentos no semiplano direito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Ou MATLAB/Octave"
                                  ],
                                  "tips": "Use meshgrid para eficiência e logscale para |R| perto de singularidades.",
                                  "learningObjective": "Visualizar e validar propriedades de estabilidade numericamente.",
                                  "commonMistakes": [
                                    "Polo em z=1 causando NaN no plot",
                                    "Escala inadequada no eixo imaginário"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplique o Backward Euler à EDO y' = -100 y (rígida). Com h=0.1, Forward Euler diverge, mas Backward Euler permanece estável pois |R(-10)| = 1/11 <1, demonstrando A-estabilidade em ação.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = 1/(1 - z).",
                                "Prova analítica de |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                "Plot da região de estabilidade cobrindo todo o semiplano esquerdo.",
                                "Testes numéricos em pontos boundary confirmam o resultado.",
                                "Comparação com métodos explícitos destaca vantagens.",
                                "Identificação correta como método A-estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de R(z) (20%).",
                                "Rigor na prova de estabilidade (30%).",
                                "Qualidade e correção do plot (20%).",
                                "Interpretação física/matemática dos resultados (15%).",
                                "Uso correto de ferramentas computacionais (10%).",
                                "Clareza na documentação do processo (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de plots em Python/MATLAB para visualização numérica.",
                                "Física: Estabilidade em simulações de sistemas dinâmicos rígidos como osciladores amortecidos.",
                                "Engenharia de Controle: Análise de estabilidade em sistemas lineares discretos.",
                                "Matemática Pura: Funções analíticas e conformes no plano complexo."
                              ],
                              "realWorldApplication": "O Backward Euler é usado em solvers de EDOs como ODE15s no MATLAB para problemas rígidos em engenharia química (reatores), aerodinâmica (fluxos viscosos) e finanças (modelos estocásticos), garantindo estabilidade incondicional para passos grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Estudar o método Trapezoidal Implícito",
                            "description": "Calcular R(z) = (1 + z/2)/(1 - z/2) para o método trapezoidal e demonstrar A-estabilidade, comparando com métodos explícitos como Forward Euler.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Formulação do Método Trapezoidal Implícito",
                                  "subSteps": [
                                    "Leia a definição do método trapezoidal implícito para EDOs: y_{n+1} = y_n + (h/2)(f(t_n, y_n) + f(t_{n+1}, y_{n+1})).",
                                    "Compare com o método explícito de Euler forward: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Identifique por que é implícito: requer solução de equação não linear em cada passo.",
                                    "Estude o método para o teste de Dahlquist: y' = λ y, com λ < 0.",
                                    "Anote as diferenças em termos de estabilidade condicional vs incondicional."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e por que é implícito, sem consultar materiais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos lineares multistep",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Visualize geometricamente como a trapézio médio entre pontos.",
                                  "learningObjective": "Dominar a formulação matemática e intuitiva do método trapezoidal implícito.",
                                  "commonMistakes": [
                                    "Confundir com regra trapezoidal de integração",
                                    "Ignorar a natureza implícita",
                                    "Esquecer o fator h/2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Função de Amplificação R(z)",
                                  "subSteps": [
                                    "Aplique o método ao problema teste y' = λ y: derive y_{n+1} (1 - (hλ)/2) = y_n (1 + (hλ)/2).",
                                    "Calcule R(z) = y_{n+1}/y_n = (1 + z/2)/(1 - z/2), onde z = hλ.",
                                    "Simplifique algebricamente e verifique para z real negativo.",
                                    "Teste valores específicos: R(0) = 1, limite |z|→∞.",
                                    "Registre a fórmula exata em seu caderno."
                                  ],
                                  "verification": "Derive R(z) do zero e confirme que matches (1 + z/2)/(1 - z/2).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy/MATLAB",
                                    "Caderno de derivções",
                                    "Referência teórica de estabilidade"
                                  ],
                                  "tips": "Use frações para evitar erros aritméticos; verifique com z=0.",
                                  "learningObjective": "Derivar precisamente a função de amplificação para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Erro no sinal de z",
                                    "Inverter numerador/denominador",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar A-Estabilidade Analisando |R(z)|",
                                  "subSteps": [
                                    "Defina A-estabilidade: |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Calcule |R(z)|² = |(1 + z/2)/(1 - z/2)|² para z = x + iy, x ≤ 0.",
                                    "Mostre que |R(z)| = 1 no eixo imaginário e <1 no semiplano esquerdo.",
                                    "Plote |R(z)| no plano complexo usando software.",
                                    "Interprete graficamente a região de estabilidade absoluta."
                                  ],
                                  "verification": "Produza um gráfico de |R(z)| confirmando |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib/NumPy ou MATLAB",
                                    "Ferramenta de plotagem complexa",
                                    "Papel milimetrado para esboço manual"
                                  ],
                                  "tips": "Use transformação bilinear para visualizar; foque em |1 + z/2| vs |1 - z/2|.",
                                  "learningObjective": "Provar analiticamente e visualmente a A-estabilidade do método.",
                                  "commonMistakes": [
                                    "Plotar apenas eixo real",
                                    "Confundir com estabilidade relativa",
                                    "Erro em magnitude complexa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Método Explícito Forward Euler",
                                  "subSteps": [
                                    "Lembre R_Euler(z) = 1 + z.",
                                    "Compare regiões: Euler instável para |z| > 0 no semiplano esquerdo.",
                                    "Simule numericamente y' = -50y, h=0.1, para ambos métodos (muitos passos).",
                                    "Observe oscilações no Euler vs convergência no trapezoidal.",
                                    "Quantifique: erro final após N passos."
                                  ],
                                  "verification": "Execute simulação e mostre gráfico comparativo sem oscilações no trapezoidal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/Octave para simulação",
                                    "Exemplo de EDO stiff: y'=-50y",
                                    "Gráficos lado a lado"
                                  ],
                                  "tips": "Escolha λ grande negativo para stiff; use solver implícito fixpoint.",
                                  "learningObjective": "Contrastar estabilidade explícita vs implícita em problemas stiff.",
                                  "commonMistakes": [
                                    "Passo h grande demais para Euler",
                                    "Não linearizar implícito",
                                    "Ignorar custo computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar e Verificar Numericamente",
                                  "subSteps": [
                                    "Codifique o método trapezoidal implícito para EDO linear usando fixed-point iteration.",
                                    "Teste com y' = λ y + f(t), compare solução exata.",
                                    "Analise convergência do iterador para o implícito.",
                                    "Gere relatório com gráficos e tabelas de erro.",
                                    "Discuta limitações: ordem 2, custo por passo."
                                  ],
                                  "verification": "Código roda sem erro, solução matches exata dentro de 1e-6.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python (SciPy para referência)",
                                    "Jupyter Notebook",
                                    "Documentação de solvers implícitos"
                                  ],
                                  "tips": "Inicie iteração com Euler predict; max 20 iterações.",
                                  "learningObjective": "Aplicar teoricamente em código prático e validar A-estabilidade.",
                                  "commonMistakes": [
                                    "Loop infinito no solver",
                                    "Erro de indexação em arrays",
                                    "Não plotar log-error"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -100(y - sin(t)), y(0)=0, t em [0,10], h=0.05. Use trapezoidal implícito via fixed-point (iterar y^{k+1} até convergência |y^{k+1}-y^k|<1e-8). Compare com Forward Euler (explode) e solução exata y=sin(t). Observe estabilidade apesar de stiff.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = (1 + z/2)/(1 - z/2).",
                                "Gráfico de |R(z)| ≤1 no semiplano esquerdo.",
                                "Simulação comparativa mostra Euler instável e trapezoidal estável.",
                                "Código implementado roda para problema stiff sem oscilações.",
                                "Explicação clara da prova de A-estabilidade.",
                                "Identificação de ordem do método (2) e custo implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de R(z) (sem erros aritméticos).",
                                "Correção e clareza dos gráficos de estabilidade.",
                                "Qualidade da comparação numérica (gráficos, tabelas de erro).",
                                "Funcionalidade e eficiência do código implementado.",
                                "Profundidade da análise: intuição, provas e limitações.",
                                "Comunicação: relatório conciso com conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em Python/NumPy para solvers ODE.",
                                "Física Computacional: Simulações de sistemas stiff como reações químicas.",
                                "Engenharia de Controle: Estabilizadores em sistemas dinâmicos lineares.",
                                "Finanças Quantitativas: Modelos de Black-Scholes com volatilidade implícita.",
                                "Ciência de Dados: Otimização implícita em machine learning (gradient descent variants)."
                              ],
                              "realWorldApplication": "O método trapezoidal implícito é fundamental em solvers de EDOs stiff como MATLAB's ode23s ou SciPy's solve_ivp(method='BDF'), usado em modelagem climática (equações diferenciais rígidas), simulações de circuitos elétricos RLC, farmacocinética (decaimento exponencial rápido) e dinâmica molecular em bioquímica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Explorar métodos BDF A-estáveis",
                            "description": "Identificar métodos Backward Differentiation Formula (BDF) de ordem 1 e 2 como A-estáveis e discutir limitações para ordens superiores (apenas até ordem 2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação dos métodos BDF de ordem 1 e 2",
                                  "subSteps": [
                                    "Estude a definição geral dos métodos Backward Differentiation Formula (BDF) para EDOs y' = f(t,y).",
                                    "Derive explicitamente a fórmula BDF1 (método Backward Euler): y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Derive a fórmula BDF2: y_{n+1} = (4/3) y_n - (1/3) y_{n-1} + (2/3) h f(t_{n+1}, y_{n+1}).",
                                    "Compare as fórmulas com métodos explícitos como Euler forward para destacar a natureza implícita.",
                                    "Implemente as fórmulas em pseudocódigo para um solver simples."
                                  ],
                                  "verification": "Derivação correta das fórmulas BDF1 e BDF2 sem erros algébricos, confirmada por comparação com referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e calculadora",
                                    "Notebook Jupyter com Python (opcional)"
                                  ],
                                  "tips": "Comece com BDF1 para construir intuição antes de BDF2; use diagramas para visualizar os multisteps.",
                                  "learningObjective": "Compreender a estrutura matemática dos métodos BDF1 e BDF2 e sua relação com aproximações diferenciais backward.",
                                  "commonMistakes": [
                                    "Confundir coeficientes de BDF2 (lembre: 4/3, -1/3, 2/3)",
                                    "Esquecer que são implícitos, exigindo iterações como Newton",
                                    "Ignorar necessidade de y_{n-1} em multistep"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estabilidade linear dos métodos BDF1 e BDF2",
                                  "subSteps": [
                                    "Aplique o teste de estabilidade linear ao problema modelo y' = λ y, com λ complexo.",
                                    "Calcule o polinômio de estabilidade para BDF1: ρ(z) = 1 - z, σ(z) = z.",
                                    "Para BDF2: ρ(z) = (3/2)z^2 - 2z + 1/2, σ(z) = (3/2)z^2 (verificar coeficientes exatos).",
                                    "Plote ou esboce a região de estabilidade |R(hλ)| ≤ 1 no plano complexo hλ.",
                                    "Identifique se a região cobre o semiplano esquerdo Re(hλ) < 0."
                                  ],
                                  "verification": "Esboço correto da região de estabilidade para BDF1 (disco unitário tangente) e BDF2 (maior cobertura do semiplano esquerdo).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib ou papel quadriculado)",
                                    "Tabelas de polinômios de estabilidade de referências"
                                  ],
                                  "tips": "Use z = hλ e teste pontos no eixo imaginário puro para A-estabilidade; amplie o gráfico para visualizar o semiplano.",
                                  "learningObjective": "Dominar o teste de estabilidade linear e calcular regiões de estabilidade para métodos BDF de baixa ordem.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes de ρ e σ",
                                    "Confundir estabilidade absoluta com relativa",
                                    "Plotar no plano λ em vez de hλ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Confirmar A-estabilidade para BDF1 e BDF2",
                                  "subSteps": [
                                    "Defina formalmente A-estabilidade: região de estabilidade contém todo o semiplano Re(z) < 0.",
                                    "Verifique para BDF1: mostre que |1/(1 - z)| ≤ 1 para Re(z) < 0.",
                                    "Para BDF2: analise o polinômio e confirme inclusão do semiplano esquerdo (use teoremas ou gráficos).",
                                    "Teste numericamente com λ = -1 + iω para ω variando, medindo erro de crescimento.",
                                    "Compare com métodos não A-estáveis como trapezoidal para contrastar."
                                  ],
                                  "verification": "Prova ou gráfico demonstrando que ambos métodos satisfazem a definição de A-estabilidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/Scilab para simulações numéricas",
                                    "Artigo clássico de Gear sobre BDF"
                                  ],
                                  "tips": "Use o teorema de Dahlquist para multistep lineares; foque em |R(iy)| ≤ 1 para y real.",
                                  "learningObjective": "Verificar propriedades de A-estabilidade e interpretar seu significado para problemas rígidos.",
                                  "commonMistakes": [
                                    "Achar que todos BDF são A-estáveis (só até ordem 2)",
                                    "Ignorar o limite |R(z)| ≤ 1 + O(|z|^2) para consistência",
                                    "Testes insuficientes no eixo imaginário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir limitações dos métodos BDF para ordens superiores",
                                  "subSteps": [
                                    "Estude por que BDF3 e superiores não são A-estáveis (região de estabilidade sai do semiplano esquerdo).",
                                    "Calcule ou cite a ordem máxima A-estável para BDF (teorema: só ordens 1 e 2).",
                                    "Discuta trade-offs: precisão vs. estabilidade em problemas rígidos.",
                                    "Exemplo numérico: simule uma EDO rígida com BDF2 vs. BDF3 para demonstrar instabilidade.",
                                    "Conclua recomendações de uso em solvers como LSODE ou SUNDIALS."
                                  ],
                                  "verification": "Explicação clara das limitações com evidência gráfica ou numérica para ordens >2.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação de solvers numéricos (SciPy odeint)",
                                    "Gráficos de regiões de estabilidade de literatura"
                                  ],
                                  "tips": "Consulte Hairer & Wanner para provas rigorosas; limite a ordens até 2 como especificado.",
                                  "learningObjective": "Entender restrições teóricas dos BDF e critérios para seleção de métodos.",
                                  "commonMistakes": [
                                    "Generalizar A-estabilidade para todas ordens BDF",
                                    "Ignorar custos computacionais implícitos",
                                    "Não testar com h grande em problemas rígidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a EDO rígida y' = -1000(y - cos(t)) + sin(t), y(0)=1, com h=0.1 usando BDF1 e BDF2 em Python (scipy.integrate.solve_ivp com method='BDF'). Compare soluções com h pequeno explícito (instável) para mostrar como BDF mantém estabilidade sem oscilações.",
                              "finalVerifications": [
                                "Deriva corretamente fórmulas BDF1 e BDF2.",
                                "Esboça regiões de estabilidade incluindo semiplano esquerdo.",
                                "Explica A-estabilidade com prova ou gráfico para ordens 1-2.",
                                "Identifica limitação: BDF > ordem 2 não A-estáveis.",
                                "Implementa simulação numérica demonstrando estabilidade.",
                                "Discute aplicação em problemas rígidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (90% correto).",
                                "Correção das regiões de estabilidade plotadas.",
                                "Profundidade na análise de A-estabilidade vs. limitações.",
                                "Qualidade da simulação prática e interpretação.",
                                "Clareza na discussão de trade-offs e recomendações.",
                                "Uso adequado de referências e ferramentas numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de sistemas dinâmicos rígidos (ex: circuitos RC).",
                                "Computação: Implementação em bibliotecas como SciPy ou PETSc.",
                                "Engenharia Química: Modelagem de reações com escalas múltiplas.",
                                "Matemática Aplicada: Teoria de aproximação e análise de erros."
                              ],
                              "realWorldApplication": "Métodos BDF A-estáveis são essenciais em solvers industriais para EDOs rígidas, como simulações de circuitos elétricos em SPICE, dinâmica de fluidos em CFD (COMSOL), e farmacocinética em modelagem de drogas, onde escalas rígidas causariam falha em métodos explícitos."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Aplicação a Problemas Stiff",
                        "description": "Relevância dos métodos A-estáveis na solução eficiente de problemas stiff, onde escalas de tempo rígidas demandam passos pequenos em métodos explícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Caracterizar problemas stiff",
                            "description": "Definir problemas stiff como aqueles com autovalores com partes reais negativas grandes em magnitude, exigindo passos de tempo h << 1/|λ| para estabilidade em métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações diferenciais lineares e autovalores",
                                  "subSteps": [
                                    "Estude a forma geral de sistemas lineares y' = A y.",
                                    "Revise como resolver analiticamente usando autovalores de A.",
                                    "Calcule autovalores para matrizes 2x2 simples.",
                                    "Analise o comportamento da solução exponencial e(tλ).",
                                    "Discuta componentes rápidos e lentos na solução."
                                  ],
                                  "verification": "Calcule corretamente autovalores de pelo menos duas matrizes exemplo e descreva o decaimento das soluções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. estabilidade)",
                                    "Software MATLAB ou Python (NumPy)",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Comece com matrizes diagonais para intuitar o impacto dos autovalores.",
                                  "learningObjective": "Compreender a conexão entre autovalores da matriz jacobiana e o comportamento temporal da solução.",
                                  "commonMistakes": [
                                    "Confundir autovalores com autovetores",
                                    "Ignorar a parte real nos autovalores complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender escalas temporais e rigidez intuitiva",
                                  "subSteps": [
                                    "Identifique componentes rápidos (λ com Re(λ) << 0) e lentos (Re(λ) próximo de 0).",
                                    "Compare tempos característicos τ = 1/|Re(λ)| para diferentes autovalores.",
                                    "Discuta por que simulações precisam resolver tanto escalas rápidas quanto lentas.",
                                    "Exemplo: sistema com τ1 = 0.01 e τ2 = 10.",
                                    "Visualize graficamente o decaimento exponencial."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um sistema com discrepância de escalas é 'rígido'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de decaimento exponencial (pré-gerados ou software)",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Pense em analogia com molas rígidas vs flexíveis para intuitar 'stiff'.",
                                  "learningObjective": "Reconhecer rigidez como discrepância em escalas temporais ditadas pelos autovalores.",
                                  "commonMistakes": [
                                    "Focar apenas no módulo |λ| em vez da parte real",
                                    "Confundir rigidez com não-linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente problemas stiff",
                                  "subSteps": [
                                    "Defina stiff: autovalores com max|Re(λ)| >> min|Re(λ)|, todos Re(λ) < 0.",
                                    "Estabeleça condição para métodos explícitos: h << 1/max|Re(λ)| para estabilidade.",
                                    "Compare com problemas não-stiff onde h pode ser maior.",
                                    "Estude definição de 'stiffness ratio' = max|Re(λ)| / min|Re(λ)|.",
                                    "Classifique exemplos como stiff ou não."
                                  ],
                                  "verification": "Escreva a definição precisa e aplique a um sistema dado, justificando se é stiff.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre estabilidade",
                                    "Exemplos de matrizes jacobianas",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Lembre-se: stiff requer h pequena para explícitos, mas soluções são suaves (lentas).",
                                  "learningObjective": "Formular a definição matemática precisa de problemas stiff baseada em autovalores.",
                                  "commonMistakes": [
                                    "Definir apenas por 'h pequena necessária', sem mencionar autovalores",
                                    "Incluir autovalores positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações numéricas",
                                  "subSteps": [
                                    "Simule um problema stiff com método explícito (ex: Euler) e h inadequado.",
                                    "Observe oscilações ou instabilidade.",
                                    "Repita com h << 1/|λ_max| e note custo computacional.",
                                    "Contraste com método implícito (ex: Backward Euler).",
                                    "Conclua necessidade de métodos A-estáveis."
                                  ],
                                  "verification": "Gere plots mostrando instabilidade em explícito vs estabilidade em implícito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB ODE45, SciPy solve_ivp)",
                                    "Problema teste stiff padrão (ex: van der Pol μ=1000)"
                                  ],
                                  "tips": "Use problemas teste conhecidos como o de Robertson para química.",
                                  "learningObjective": "Demonstrar por que caracterização de stiff guia escolha de método numérico.",
                                  "commonMistakes": [
                                    "Escolher h baseado em escala lenta em vez de rápida",
                                    "Não normalizar soluções para ver instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema linear y' = A y com A = [[-100, 1], [1, -100]]. Autovalores ≈ -99 e -101 (Re(λ) ≈ -100). Stiffness ratio ≈1 (fraco), mas ajuste para A = [[-1000,1],[1,-1]] com ratio 1000:1. Simule com Euler explícito h=0.01 (instável) vs h=0.0005 (estável, mas caro).",
                              "finalVerifications": [
                                "Define corretamente problemas stiff via autovalores e partes reais negativas grandes.",
                                "Calcula autovalores e identifica stiffness ratio em um sistema dado.",
                                "Explica requisito h << 1/|λ_max| para métodos explícitos.",
                                "Classifica exemplos como stiff ou não-stiff com justificativa.",
                                "Descreve impacto na escolha de métodos numéricos.",
                                "Simula numericamente instabilidade em explícito para stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição formal (autovalores, Re(λ)<0, magnitude).",
                                "Correção nos cálculos de autovalores e stiffness ratio.",
                                "Clareza na explicação de implicações para passos de tempo h.",
                                "Qualidade de exemplos e simulações numéricas.",
                                "Integração de conceitos de estabilidade prévia.",
                                "Capacidade de generalizar para sistemas não-lineares (Jacobiana)."
                              ],
                              "crossCurricularConnections": [
                                "Química: Modelos de cinética química com reações rápidas/lentas (ex: mecanismo de Robertson).",
                                "Física: Equações de circuitos RC/RL com constantes de tempo díspares.",
                                "Engenharia de Controle: Sistemas com polos dominantes rápidos e lentos.",
                                "Biologia Computacional: Modelos de populações com dinâmicas multi-escala."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas industriais (ex: combustão), onde espécies intermediárias decaem rapidamente (λ grande), mas produto final evolui lentamente; métodos explícitos falham sem h minúscula, tornando implícitos essenciais para eficiência computacional em previsões de reatores."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Demonstrar vantagem em stiff equations",
                            "description": "Resolver numericamente uma EDO stiff modelo (ex: y' = -1000(y-1) + sin(t)) com Backward Euler vs. Euler explícito, mostrando estabilidade com h grande nos A-estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema EDO stiff e definir o modelo matemático",
                                  "subSteps": [
                                    "Estude a definição de EDO stiff: sistemas com escalas temporais muito diferentes, exigindo passos pequenos para estabilidade em métodos explícitos.",
                                    "Defina o modelo exemplo: y' = -1000(y - 1) + sin(t), com y(0) = 0, onde λ = -1000 causa rigidez.",
                                    "Analise analiticamente a solução exata aproximada: y(t) ≈ 1 + (sin(t) - cos(t))/1001 para grandes t.",
                                    "Calcule manualmente alguns passos com h pequeno para entender o comportamento.",
                                    "Registre as propriedades de estabilidade: Euler explícito instável para |λh| > 1, Backward Euler A-estável."
                                  ],
                                  "verification": "Resumo escrito explicando por que o problema é stiff e esboço da solução exata.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou Jupyter Notebook para anotações; referência teórica de Análise Numérica.",
                                  "tips": "Visualize graficamente sin(t) e o termo -1000(y-1) para intuitar o equilíbrio rápido.",
                                  "learningObjective": "Identificar características de EDOs stiff e formular o problema de teste.",
                                  "commonMistakes": "Confundir stiff com não-linear; ignorar condição inicial y(0)=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar o método de Euler explícito",
                                  "subSteps": [
                                    "Escreva a função f(t,y) = -1000(y - 1) + sin(t) em Python.",
                                    "Implemente o esquema: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Teste com h pequeno (ex: 0.001) até t=10, plote a solução.",
                                    "Aumente h para 0.01 e observe instabilidade (oscilações ou divergência).",
                                    "Registre número de passos e erro relativo à solução exata."
                                  ],
                                  "verification": "Gráficos gerados mostrando convergência com h pequeno e instabilidade com h=0.01.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy, SciPy (para solução exata opcional), Matplotlib.",
                                  "tips": "Use arrays para eficiência; normalize erro como max| y_num - y_exata | / max|y_exata|.",
                                  "learningObjective": "Implementar Euler explícito e demonstrar limitação em problemas stiff.",
                                  "commonMistakes": "Erro na função f (esquecer sin(t)); h grande demais causando NaN imediatamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método de Backward Euler",
                                  "subSteps": [
                                    "Lembre o esquema implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Resolva a equação não-linear por iteração de ponto fixo ou Newton simples para este caso linear.",
                                    "Como é linear em y: y_{n+1} = (y_n + h sin(t_{n+1})) / (1 + 1000 h).",
                                    "Implemente em código, teste com h pequeno.",
                                    "Prepare para h grande."
                                  ],
                                  "verification": "Código executável produzindo solução estável com h=0.1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo ambiente Python; adicione função para solver implícito.",
                                  "tips": "Para este modelo linear, fórmula fechada evita iterações; generalize para não-lineares futuramente.",
                                  "learningObjective": "Dominar implementação de método implícito A-estável.",
                                  "commonMistakes": "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1}); loop infinito em iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações comparativas com passo h grande",
                                  "subSteps": [
                                    "Escolha h=0.1 (grande para |λ|=1000, pois |λh|=100 >>1).",
                                    "Rode ambos métodos até t=10, plote sobrepostas com solução exata.",
                                    "Meça tempo de computação e passos necessários.",
                                    "Varie h de 0.001 a 0.1, tabule erros vs h.",
                                    "Gere gráficos de erro log-log para regiões de estabilidade."
                                  ],
                                  "verification": "Gráficos comparativos mostrando Euler explícito oscilante e Backward estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Scripts Python expandidos; exporte figuras PNG.",
                                  "tips": "Use subplot para múltiplos gráficos; legendas claras.",
                                  "learningObjective": "Comparar numericamente estabilidade e precisão.",
                                  "commonMistakes": "Escala errada nos plots ocultando oscilações; esquecer normalização de erro."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e demonstrar vantagem dos métodos A-estáveis",
                                  "subSteps": [
                                    "Descreva qualitativamente: Backward Euler permite h grande sem instabilidade.",
                                    "Calcule razão de passos: ex. Euler precisa h<0.001 (10000 passos), Backward h=0.1 (100 passos).",
                                    "Discuta trade-off: Backward menos preciso por passo, mas eficiente globalmente.",
                                    "Conclua com região de estabilidade no plano complexo (círculo unitário para explícito vs. semiplano para A-estável).",
                                    "Escreva relatório curto com conclusões."
                                  ],
                                  "verification": "Relatório de 1 página com gráficos, tabelas e conclusões.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documento Word/Markdown; gráficos salvos.",
                                  "tips": "Use equações LaTeX para clareza; foque em eficiência computacional.",
                                  "learningObjective": "Interpretar resultados e justificar uso de métodos implícitos em stiff problems.",
                                  "commonMistakes": "Atribuir instabilidade a erro de arredondamento em vez de CFL; ignorar custo implícito."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000(y - 1) + sin(t), y(0)=0 até t=10. Com h=0.1, Euler explícito diverge em oscilações selvagens após poucos passos, enquanto Backward Euler segue a solução y≈1 oscilando levemente com sin(t)/1001, usando 100x menos passos.",
                              "finalVerifications": [
                                "Gráficos mostram instabilidade clara no Euler explícito com h=0.1.",
                                "Backward Euler converge estável com h grande, próximo à exata.",
                                "Tabela de erros confirma eficiência: erro Backward <1% com 100 passos vs. falha no explícito.",
                                "Código reproduzível gera resultados consistentes.",
                                "Relatório explica região A-estável.",
                                "Tempo total de Backward <1/10 do explícito viável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de ambos métodos (código correto e comentado).",
                                "Qualidade dos gráficos e tabelas comparativos (legendas, escalas adequadas).",
                                "Análise quantitativa de estabilidade e eficiência (erros, passos, tempo).",
                                "Compreensão teórica demonstrada (explicação de A-estabilidade).",
                                "Relatório claro e conciso com conclusões acionáveis.",
                                "Reprodutibilidade: código roda sem erros em ambiente padrão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas rígidos como circuitos RC com parasitas ou reações químicas rápidas.",
                                "Computação: Otimização numérica e solvers em bibliotecas como SciPy odeint.",
                                "Engenharia: Simulações em controle de processos industriais stiff.",
                                "Estatística: Análise de erros numéricos e convergência.",
                                "Programação: Estruturas de loops eficientes e visualização de dados."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos com capacitores pequenos (stiff), Backward Euler permite passos maiores em software como SPICE, reduzindo tempo de simulação de horas para minutos em designs de chips; similar em farmacocinética para modelar decaimentos rápidos de drogas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Discutir controle de passo em A-estáveis",
                            "description": "Explicar como métodos A-estáveis permitem controle de erro adaptativo sem restrições de estabilidade, integrando com bibliotecas como as citadas na bibliografia (LeVeque, Golub-Ortega).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Métodos A-Estáveis e Problemas Stiff",
                                  "subSteps": [
                                    "Defina problemas stiff em EDOs, destacando a razão de escalas de tempo discrepantes.",
                                    "Explique a região de estabilidade absoluta (A-estabilidade) no semi-plano esquerdo complexo.",
                                    "Liste exemplos de métodos A-estáveis, como Backward Euler e métodos BDF.",
                                    "Compare com métodos explícitos que sofrem restrições CFL.",
                                    "Cite referências iniciais de LeVeque (Capítulo 11) para problemas stiff."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre problemas stiff e não-stiff, confirmando compreensão da A-estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de LeVeque 'Finite Difference Methods for ODEs'; notas de aula sobre estabilidade.",
                                  "tips": "Desenhe a região de estabilidade no plano complexo para visualização clara.",
                                  "learningObjective": "Compreender por que métodos A-estáveis são essenciais para problemas stiff.",
                                  "commonMistakes": "Confundir A-estabilidade com estabilidade L-estável; ignorar o papel dos autovalores negativos grandes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Controle de Erro Adaptativo em Métodos Numéricos",
                                  "subSteps": [
                                    "Descreva o algoritmo padrão de controle de passo: estimar erro local via embedded methods ou soluções duplas.",
                                    "Explique fórmulas de ajuste de h: h_new = h_old * (tol / erro)^(1/p), onde p é a ordem.",
                                    "Discuta tolerâncias absolutas e relativas (atol, rtol).",
                                    "Implemente um pseudocódigo simples para rejeição/aceitação de passos.",
                                    "Referencie Golub e Ortega para análise de erro em métodos implícitos."
                                  ],
                                  "verification": "Escreva pseudocódigo funcional para controle de passo e teste com um exemplo simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pseudocódigo editor (Jupyter Notebook); capítulos de Golub e Ortega sobre erro.",
                                  "tips": "Use runge-kutta embedded (como Dormand-Prince) como benchmark antes de A-estáveis.",
                                  "learningObjective": "Dominar os mecanismos de adaptação de passo baseados em erro.",
                                  "commonMistakes": "Escolher fatores de segurança muito altos (>0.9), levando a passos pequenos desnecessários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vantagens do Controle de Passo em Métodos A-Estáveis",
                                  "subSteps": [
                                    "Explique como A-estabilidade remove restrições |hλ| < 1 para Re(λ) < 0.",
                                    "Discuta liberdade para aumentar h baseado apenas em precisão, não estabilidade.",
                                    "Compare eficiência computacional: menos passos rejeitados em stiff vs. explícitos.",
                                    "Aborde limitações: custo por passo maior devido a solves não-lineares (Newton).",
                                    "Integre com LeVeque: exemplos de eficiência em problemas reacionais stiff."
                                  ],
                                  "verification": "Crie uma tabela comparativa de número de passos e tempo para método explícito vs. A-estável em um stiff ODE.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela em Excel ou Markdown; exemplos de LeVeque.",
                                  "tips": "Gráficos de h vs. tempo ajudam a visualizar adaptação livre.",
                                  "learningObjective": "Identificar como A-estabilidade habilita controle puramente erro-driven.",
                                  "commonMistakes": "Subestimar overhead de Jacobianos em implícitos para stiff severos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Integrar com Bibliotecas Numéricas",
                                  "subSteps": [
                                    "Implemente Backward Euler com controle adaptativo em Python (SciPy odeint ou solve_ivp).",
                                    "Teste em um problema stiff clássico: y' = -1000(y-1) + sin(t).",
                                    "Analise logs de passos: rejeições, h_min/max.",
                                    "Compare com bibliotecas citadas (SUNDIALS via Assimulo, se disponível).",
                                    "Discuta escalabilidade para sistemas grandes (Golub-Ortega)."
                                  ],
                                  "verification": "Execute simulação e gere relatório com métricas de eficiência (passos totais, tempo CPU).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com SciPy/NumPy; Jupyter; códigos de exemplo de LeVeque.",
                                  "tips": "Use method='BDF' em solve_ivp para A-estável automático.",
                                  "learningObjective": "Aplicar conceitos em software real, validando teoria.",
                                  "commonMistakes": "Não monitorar singularidades ou stiff inicial, causando falhas."
                                }
                              ],
                              "practicalExample": "Simule o problema stiff y' = -50(y - cos(t)), y(0)=0 com Backward Euler adaptativo. Observe h crescendo de 0.01 para 0.1 sem oscilações instáveis, contrastando com Euler explícito que falha para h>0.02.",
                              "finalVerifications": [
                                "Explica corretamente ausência de restrições de estabilidade em A-estáveis.",
                                "Implementa controle de passo sem erros em código simples.",
                                "Identifica pelo menos 3 vantagens em problemas stiff.",
                                "Compara eficiência com métodos não-A-estáveis.",
                                "Cita referências (LeVeque, Golub-Ortega) com exemplos relevantes.",
                                "Gera gráficos de solução e h(t) coerentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e teoremas corretos (30%)",
                                "Profundidade análise: comparações quantitativas (25%)",
                                "Implementação prática: código funcional e eficiente (20%)",
                                "Clareza comunicação: explicações e visualizações (15%)",
                                "Integração bibliográfica: uso adequado de fontes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica e otimização em SciPy/SUNDIALS.",
                                "Física: Modelagem de circuitos RC stiff ou difusão reacional.",
                                "Engenharia Química: Simulações de reatores com escalas rápidas/lentas.",
                                "Estatística: Análise de sensibilidade em parâmetros stiff."
                              ],
                              "realWorldApplication": "Em simulações de redes elétricas (circuitos com capacitores/diodos stiff), controle adaptativo em métodos A-estáveis permite prever transientes rápidos sem passos minúsculos, otimizando design em software como MATLAB Simulink ou PSCAD."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Problemas Stiff",
                "description": "Estudo e tratamento de equações diferenciais rígidas que demandam métodos numericamente estáveis.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Definição de Problemas Stiff",
                    "description": "Caracterização de equações diferenciais ordinárias rígidas que exigem passos de tempo muito pequenos em métodos explícitos para manter a estabilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1.1",
                        "name": "Estabilidade Numérica em Métodos Explícitos",
                        "description": "Conceito fundamental que descreve como métodos explícitos, como Euler e Runge-Kutta, possuem estabilidade condicional, dependendo do passo de tempo h estar dentro da região de estabilidade absoluta determinada pelos autovalores da equação diferencial.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1.1",
                            "name": "Definir região de estabilidade",
                            "description": "Explicar a região de estabilidade no plano complexo z = hλ, onde λ são autovalores da jacobiana, e identificar para qual h o método permanece estável em EDOs lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estabilidade em EDOs lineares",
                                  "subSteps": [
                                    "Revise a solução exata de uma EDO linear y' = λy, onde |e^{λt}| determina a estabilidade.",
                                    "Discuta como métodos numéricos aproximam isso via amplificação de fatores de estabilidade.",
                                    "Explique o conceito de problemas stiff: autovalores com partes reais negativas grandes em magnitude.",
                                    "Identifique por que métodos explícitos falham em problemas stiff devido a restrições em h.",
                                    "Compare estabilidade absoluta vs. estabilidade numérica."
                                  ],
                                  "verification": "Escreva uma definição clara de estabilidade para y' = λy e identifique quando λ < 0 causa decaimento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use exemplos simples como y' = -y para visualizar decaimento exponencial.",
                                  "learningObjective": "Compreender os fundamentos teóricos da estabilidade em EDOs lineares autônomas.",
                                  "commonMistakes": "Confundir estabilidade da solução exata com a do método numérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o plano complexo z = hλ",
                                  "subSteps": [
                                    "Defina z = hλ, onde h é o passo de tempo e λ é autovalor da jacobiana.",
                                    "Explique o semiplano esquerdo Re(z) < 0 como região relevante para problemas stiff.",
                                    "Discuta como h pequeno mapeia λ para z próximo de 0.",
                                    "Ilustre com um gráfico: eixo real negativo para Re(λ) < 0.",
                                    "Calcule z para exemplos: λ = -100, h=0.01 → z=-1."
                                  ],
                                  "verification": "Desenhe o plano z e marque pontos para λ=-50 (h=0.01 e h=0.1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (ex: Desmos ou Python Matplotlib)",
                                    "Caderno de anotações"
                                  ],
                                  "tips": "Sempre normalize pensando em |λ| grande e h pequeno para stiff.",
                                  "learningObjective": "Mapear autovalores da EDO para o plano de estabilidade escalonado por h.",
                                  "commonMistakes": "Esquecer que Im(λ) afeta o eixo imaginário de z."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a região de estabilidade de um método",
                                  "subSteps": [
                                    "Defina região de estabilidade S como {z ∈ ℂ : |R(z)| ≤ 1}, onde R(z) é a função de amplificação.",
                                    "Para Euler explícito: R(z) = 1 + z, S = {z : |1 + z| ≤ 1} (círculo unitário esquerdo).",
                                    "Descreva como plotar S integrando |R(z)| ≤ 1 no plano complexo.",
                                    "Compare com métodos implícitos (ex: Backward Euler, S = disco inteiro esquerdo).",
                                    "Explique A-stabilidade: S contém todo semiplano Re(z) < 0."
                                  ],
                                  "verification": "Esboce a região S para Euler explícito e verifique se z=-1 está dentro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB para plotar |R(z)|",
                                    "Referência: Hairer 'Solving ODEs I'"
                                  ],
                                  "tips": "Comece com métodos lineares simples antes de Runge-Kutta.",
                                  "learningObjective": "Identificar e visualizar a região de estabilidade via função de amplificação R(z).",
                                  "commonMistakes": "Confundir R(z) com a solução exata e^{z}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar h para estabilidade",
                                  "subSteps": [
                                    "Para dado λ, encontre h tal que hλ ∈ S.",
                                    "Exemplo: Euler, λ=-100, h < 2/|λ| = 0.02 para Re(z) > -2.",
                                    "Generalize: h_max ≈ diâmetro de S / |λ|_max.",
                                    "Verifique numericamente: simule y' = λy com h variando.",
                                    "Discuta trade-off: h pequeno para estabilidade vs. custo computacional."
                                  ],
                                  "verification": "Calcule h_max para λ=-50 no Euler e simule 10 passos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/Octave para simulação numérica",
                                    "Gráficos de erro vs. h"
                                  ],
                                  "tips": "Use scripts reutilizáveis para testar múltiplos h.",
                                  "learningObjective": "Determinar o intervalo de h que mantém z na região de estabilidade.",
                                  "commonMistakes": "Ignorar autovalores complexos ou múltiplos."
                                }
                              ],
                              "practicalExample": "Para o método de Euler explícito aplicado a y' = -100y, y(0)=1. A região S é o círculo |1+z|≤1. Para estabilidade, Re(hλ) > -2, logo h < 0.02. Simule com h=0.01 (estável, oscilações mínimas) vs. h=0.03 (instável, cresce exponencialmente).",
                              "finalVerifications": [
                                "Pode esboçar corretamente o plano z = hλ com semiplano esquerdo destacado?",
                                "Identifica R(z) para Euler e plota sua região S?",
                                "Calcula h_max preciso para λ dado e método?",
                                "Simula numericamente e observa instabilidade para h grande?",
                                "Explica por que problemas stiff requerem h pequeno em explícitos?",
                                "Distingue estabilidade absoluta de numérica?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de z = hλ e seu significado (20%)",
                                "Correta identificação e plot da região S via R(z) (25%)",
                                "Cálculo exato de h para estabilidade em exemplos (20%)",
                                "Uso de exemplos numéricos/simulações para validação (15%)",
                                "Explicação clara de implicações para EDOs stiff (10%)",
                                "Conexão com conceitos mais amplos como A-estabilidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos rígidos.",
                                "Computação: Implementação de solvers ODE em bibliotecas como SciPy.",
                                "Engenharia Química: Modelos de reatores com cinéticas stiff.",
                                "Controle Automático: Análise de sistemas lineares discretizados."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou circuitos elétricos RC stiff, definir a região de estabilidade garante que métodos explícitos como Runge-Kutta sejam viáveis sem oscilações artificiais, otimizando h para precisão e eficiência computacional em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.2",
                            "name": "Analisar estabilidade no método de Euler explícito",
                            "description": "Derivar e aplicar a condição |1 + hλ| ≤ 1 para estabilidade no método de Euler explícito, determinando o passo máximo h_max = 2 / |Re(λ_max)| para autovalores com parte real negativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do método de Euler explícito",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial y' = f(t, y).",
                                    "Escreva a iteração do Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Considere o caso linear y' = λ y, levando a y_{n+1} = (1 + hλ) y_n.",
                                    "Identifique o fator de amplificação g(hλ) = 1 + hλ.",
                                    "Discuta a necessidade de |g(hλ)| ≤ 1 para estabilidade."
                                  ],
                                  "verification": "Escreva corretamente a recursão para y' = λ y e identifique g(hλ).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Livro de Análise Numérica (capítulo de métodos de Runge-Kutta)"
                                  ],
                                  "tips": "Comece com o caso escalar simples antes de generalizar para sistemas.",
                                  "learningObjective": "Compreender a base iterativa do método de Euler explícito para problemas lineares.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito com implícito",
                                    "Esquecer o papel de h na amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a condição de estabilidade absoluta",
                                  "subSteps": [
                                    "Para estabilidade, exija |1 + hλ| ≤ 1 para todos os autovalores λ do Jacobiano.",
                                    "Assuma λ com Re(λ) < 0 (problemas estáveis).",
                                    "Resolva |1 + hλ| ≤ 1 geometricamente no plano complexo z = hλ.",
                                    "Mostre que a região de estabilidade é o disco |1 + z| ≤ 1, centro -1, raio 1.",
                                    "Conclua que para λ real negativo, h ≤ 2 / |λ|."
                                  ],
                                  "verification": "Desenhe o disco de estabilidade e marque pontos para λ real negativo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfica no plano complexo (papel ou software como Desmos/GeoGebra)",
                                    "Calculadora para manipular desigualdades"
                                  ],
                                  "tips": "Use z = hλ e teste valores boundary como z = -2.",
                                  "learningObjective": "Derivar analiticamente a região de estabilidade do Euler explícito.",
                                  "commonMistakes": [
                                    "Confundir centro do disco (-1 vs 0)",
                                    "Ignorar parte imaginária de λ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a condição para problemas stiff",
                                  "subSteps": [
                                    "Defina problema stiff: autovalores com |Re(λ_max)| >> |Re(λ_min)|.",
                                    "Identifique λ_max como o autovalor com maior |Re(λ)| negativo.",
                                    "Determine h_max = 2 / |Re(λ_max)| para garantir |1 + hλ_max| ≤ 1.",
                                    "Verifique que h_max é pequeno para stiff, limitando eficiência.",
                                    "Compare com h desejado pela precisão."
                                  ],
                                  "verification": "Calcule h_max para um exemplo com λ_max = -100.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de matrizes Jacobianas de problemas stiff",
                                    "Software MATLAB/Python para autovalores (opcional)"
                                  ],
                                  "tips": "Sempre normalize hλ para verificar inclusão no disco.",
                                  "learningObjective": "Aplicar a condição de estabilidade para limitar h em problemas stiff.",
                                  "commonMistakes": [
                                    "Usar |λ| ao invés de |Re(λ)|",
                                    "Esquecer que é para Re(λ) < 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar numericamente",
                                  "subSteps": [
                                    "Implemente Euler explícito em código para y' = -λ y, λ = 50.",
                                    "Teste com h < h_max = 2/50 = 0.04 e h > h_max.",
                                    "Observe oscilações ou divergência para h grande.",
                                    "Plote soluções numérica vs exata e analise erro.",
                                    "Conclua sobre necessidade de métodos implícitos para stiff."
                                  ],
                                  "verification": "Execute simulação e mostre gráfico estável vs instável.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Código template de Euler"
                                  ],
                                  "tips": "Use λ complexo para testar parte imaginária.",
                                  "learningObjective": "Validar teoricamente a estabilidade através de experimentos numéricos.",
                                  "commonMistakes": [
                                    "Passos de tempo inconsistentes",
                                    "Erro de escala no plot"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -50 y, y(0)=1, solução exata y(t)=exp(-50t). h_max=2/50=0.04. Com h=0.03, solução numérica decai suavemente; com h=0.05, oscila e diverge.",
                              "finalVerifications": [
                                "Derivar corretamente |1 + hλ| ≤ 1 para λ real negativo.",
                                "Calcular h_max = 2 / |Re(λ_max)| para um sistema dado.",
                                "Desenhar e interpretar a região de estabilidade no plano hλ.",
                                "Identificar instabilidade em simulação numérica com h > h_max.",
                                "Explicar por que Euler explícito falha em problemas stiff.",
                                "Comparar com método implícito (ex: Backward Euler)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição |1 + hλ| ≤ 1 (100%).",
                                "Correção no cálculo de h_max para autovalores dados (90%).",
                                "Qualidade do desenho da região de estabilidade (80%).",
                                "Análise correta de simulação numérica (85%).",
                                "Explicação clara de limitações em stiff problems (95%).",
                                "Uso apropriado de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos.",
                                "Engenharia: Controle de sistemas lineares discretos.",
                                "Programação: Implementação eficiente de solvers ODE em Python/MATLAB.",
                                "Química: Modelagem de reações stiff em cinética química.",
                                "Computação Científica: Análise de erro em métodos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou reações químicas stiff (ex: combustão), onde autovalores grandes negativos exigem h pequeno no Euler explícito, tornando-o ineficiente; motiva uso de solvers implícitos como em software COMSOL ou ODE45 no MATLAB."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.3",
                            "name": "Comparar estabilidade explícita vs implícita",
                            "description": "Contrastar a estabilidade condicional de métodos explícitos com a estabilidade absoluta de métodos implícitos, como Euler implícito, destacando a independência de h em implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estabilidade em Métodos Explícitos",
                                  "subSteps": [
                                    "Defina estabilidade numérica para métodos de Runge-Kutta ou Euler explícito.",
                                    "Analise a região de estabilidade absoluta no plano complexo (disco unitário para Euler explícito).",
                                    "Examine a condição CFL ou restrição em h para problemas stiff (λh dentro do disco).",
                                    "Calcule exemplos numéricos com h pequeno vs h grande para demonstrar instabilidade.",
                                    "Compare com o espectro de autovalores do problema stiff (autovalores com partes reais grandes negativas)."
                                  ],
                                  "verification": "Resolva um ODE y' = -100y com Euler explícito para h=0.01 (estável) e h=0.1 (instável); plote soluções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software como Python/MATLAB para plotar soluções",
                                    "Notas de aula sobre Euler explícito"
                                  ],
                                  "tips": "Sempre normalize λh para visualizar no plano de estabilidade.",
                                  "learningObjective": "Entender que estabilidade explícita é condicional e depende de h pequeno para problemas stiff.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; ignorar o tamanho do espectro de autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Estabilidade em Métodos Implícitos",
                                  "subSteps": [
                                    "Defina método de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Derive a região de estabilidade (meio-plano esquerdo para Euler implícito).",
                                    "Mostre que para Re(λh) < 0, |amplificação| < 1 independentemente de |h|.",
                                    "Resolva numericamente o mesmo ODE y' = -100y com Euler implícito para vários h.",
                                    "Discuta resolução linear via Jacobiana para sistemas não-lineares."
                                  ],
                                  "verification": "Implemente Euler implícito e confirme estabilidade para h=0.01 até h=1.0; compare erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/Scipy para fsolve",
                                    "Livro de análise numérica (Hairer ou Burden)",
                                    "Gráficos de regiões de estabilidade"
                                  ],
                                  "tips": "Use fsolve ou Newton para resolver a equação implícita em cada passo.",
                                  "learningObjective": "Compreender a estabilidade incondicional dos implícitos, independente de h.",
                                  "commonMistakes": "Esquecer de linearizar para não-lineares; assumir custo computacional zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar Estabilidade Explícita vs Implícita",
                                  "subSteps": [
                                    "Compare regiões: disco unitário (explícito) vs meio-plano (implícito).",
                                    "Para problemas stiff (espectro amplo), mostre h_max explícito << h_max implícito.",
                                    "Calcule fator de custo: explícito O(1) vs implícito O(n^3) por passo para n variáveis.",
                                    "Analise trade-off: precisão vs eficiência em problemas stiff.",
                                    "Use diagrama de Dahlquist para visualizar diferenças."
                                  ],
                                  "verification": "Crie tabela comparativa: método, região estabilidade, dependência h, exemplo stiff.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagramas de estabilidade impressos",
                                    "Excel ou Python para tabelas",
                                    "Exemplos de ODEs stiff"
                                  ],
                                  "tips": "Foque em λ reais negativos grandes para stiff clássico.",
                                  "learningObjective": "Contrastar condicional (explícito) vs absoluta (implícito) estabilidade.",
                                  "commonMistakes": "Ignorar custo implícito; generalizar de lineares para não-lineares sem Jacobiana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação a Problemas Stiff",
                                  "subSteps": [
                                    "Escolha ODE stiff real, como reação química y' = -1000(y-1) + sin(t).",
                                    "Simule com ambos métodos, variando h até falha explícito.",
                                    "Meça tempo de CPU e erro global (norma L2).",
                                    "Discuta quando usar cada: explícito para não-stiff, implícito para stiff.",
                                    "Explore variantes como trapezoidal (A-estável)."
                                  ],
                                  "verification": "Gere relatório com plots, tempos e erros para h=0.001, 0.01, 0.1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python pronto (odeint ou custom)",
                                    "Artigos sobre stiff solvers"
                                  ],
                                  "tips": "Use lipschitz constante para quantificar stiff (L >> 1/h).",
                                  "learningObjective": "Aplicar comparação prática, destacando independência de h em implícitos.",
                                  "commonMistakes": "Escolher problema não-stiff; não medir custo corretamente."
                                }
                              ],
                              "practicalExample": "Resolva y' = -50y + sin(t), y(0)=1, t em [0,1]. Use Euler explícito: falha para h>0.02. Euler implícito: converge para h=0.2 com erro <1e-3, 10x mais rápido em passos.",
                              "finalVerifications": [
                                "Explicar verbalmente por que explícitos requerem h < 2/|λ_max|.",
                                "Desenhar regiões de estabilidade corretas para ambos.",
                                "Simular stiff ODE e identificar falha explícita.",
                                "Calcular fator de amplificação para λh=-10 em ambos métodos.",
                                "Discutir por que implícitos são preferidos em stiff apesar de custo.",
                                "Comparar com método trapezoidal (também A-estável)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de regiões de estabilidade (explícito: |1+λh|<1; implícito: |1/(1-λh)|<1).",
                                "Correta identificação de dependência em h para stiff (explícito sim, implícito não).",
                                "Exemplos numéricos com plots mostrando oscilações explícitas vs suavidade implícita.",
                                "Análise de trade-offs custo-benefício quantitativa.",
                                "Uso correto de terminologia (A-estável, stiff, Dahlquist).",
                                "Conexão clara com problemas reais stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de circuitos RC/RL stiff em dinâmica.",
                                "Química: Equações de reação-difusão stiff (Van der Pol).",
                                "Computação: Implementação de solvers em SciPy (odeint com método implícito).",
                                "Engenharia: Controle de sistemas stiff (aeronáutica).",
                                "Estatística: MCMC com passos stiff em simulações."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos stiff, métodos implícitos permitem h maiores, reduzindo tempo de simulação de horas para minutos, essencial para otimização industrial em farmacêutica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.2",
                        "name": "Definição e Caracterização de Problemas Stiff",
                        "description": "Problemas stiff são equações diferenciais ordinárias (EDOs) rígidas caracterizadas por escalas temporais muito díspares, onde autovalores da linearização possuem partes reais grandes negativas (λ_min << 0), exigindo h muito pequeno em métodos explícitos para estabilidade, apesar da solução ser suave.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.2.1",
                            "name": "Definir formalmente problemas stiff",
                            "description": "Formular a definição de um problema stiff como um sistema y' = f(y) onde a razão de stiffness |λ_max / λ_min| é muito grande (tipicamente > 1000), com λ_min dominante em magnitude negativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral de sistemas de EDOs",
                                  "subSteps": [
                                    "Revise a representação padrão de um sistema de EDOs como y' = f(t, y), onde y é um vetor em R^n.",
                                    "Discuta casos autônomos y' = f(y), focando em problemas não lineares comuns em aplicações.",
                                    "Identifique a importância da estabilidade numérica em métodos de integração.",
                                    "Explique o conceito de escalas temporais múltiplas em sistemas dinâmicos.",
                                    "Diferencie EDOs stiff de não-stiff qualitativamente."
                                  ],
                                  "verification": "Escreva a forma geral y' = f(y) e dê um exemplo simples não-stiff, confirmando compreensão básica.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDOs)",
                                    "Caderno para anotações",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Comece com exemplos visuais de trajetórias para intuir escalas rápidas e lentas.",
                                  "learningObjective": "Reconhecer a estrutura matemática de sistemas de EDOs e sua relevância para problemas stiff.",
                                  "commonMistakes": "Confundir y' = f(t,y) com y' = f(y) e ignorar o caráter autônomo típico em stiff problems."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a linearização via Jacobiana",
                                  "subSteps": [
                                    "Defina a matriz Jacobiana J(y) = ∂f/∂y avaliada em um ponto de equilíbrio y*.",
                                    "Calcule a Jacobiana para um sistema não linear simples.",
                                    "Explique por que problemas lineares y' = A y servem como modelo local para não lineares.",
                                    "Discuta a relação entre autovalores de J e o comportamento local da solução.",
                                    "Verifique estabilidade via parte real dos autovalores (todas Re(λ) < 0 para estável)."
                                  ],
                                  "verification": "Compute a Jacobiana de um sistema dado e liste seus autovalores.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Exemplos de sistemas químicos ou mecânicos"
                                  ],
                                  "tips": "Use simetria ou estrutura esparsa da Jacobiana para simplificar cálculos.",
                                  "learningObjective": "Dominar a linearização de sistemas não lineares para análise espectral.",
                                  "commonMistakes": "Esquecer de avaliar J em y* ou confundir derivadas parciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os autovalores e definir a razão de stiffness",
                                  "subSteps": [
                                    "Ordene os autovalores λ por magnitude: λ_min (maior |λ|, Re(λ_min) << 0) e λ_max (menor |λ|).",
                                    "Calcule a razão de stiffness ρ = |λ_max / λ_min|.",
                                    "Interprete ρ >> 1 (tipicamente > 1000) como indicador de múltiplas escalas temporais.",
                                    "Discuta o impacto em métodos explícitos (passo h < 1/|λ_min| restritivo).",
                                    "Compare com métodos implícitos que toleram h maior."
                                  ],
                                  "verification": "Para uma matriz A dada, compute ρ e classifique como stiff ou não.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Software para autovalores (eigenvals no MATLAB/Python)",
                                    "Tabela de exemplos stiff clássicos"
                                  ],
                                  "tips": "Normalize autovalores para visualizar a separação de escalas.",
                                  "learningObjective": "Quantificar stiffness via espectro da Jacobiana.",
                                  "commonMistakes": "Usar módulo total |λ| em vez de |Re(λ)| ou inverter λ_max e λ_min."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição de problemas stiff",
                                  "subSteps": [
                                    "Enuncie: Um problema y' = f(y) é stiff se, na linearização local, |λ_max / λ_min| >> 1 (>1000), com λ_min dominante negativo.",
                                    "Estenda para não lineares: stiffness persiste ao longo da integração.",
                                    "Diferencie de problemas oscilatórios (parte imaginária dominante).",
                                    "Forneça contraexemplos (ρ pequeno = não stiff).",
                                    "Resuma critérios: ρ grande + componentes rápidas decayem rapidamente."
                                  ],
                                  "verification": "Escreva a definição formal e aplique a um exemplo, justificando classificação.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Resumo em folha de referência",
                                    "Quiz com 3 problemas para classificar"
                                  ],
                                  "tips": "Memorize a condição >1000 como threshold prático, mas discuta flexibilidade.",
                                  "learningObjective": "Articular precisamente a definição matemática de stiff problems.",
                                  "commonMistakes": "Ignorar dominância negativa de λ_min ou aplicar só a lineares."
                                }
                              ],
                              "practicalExample": "Considere o sistema químico de Robertson: dy1/dt = -0.04 y1 + 1e4 y2 y3, dy2/dt = 0.04 y1 - 1e4 y2 y3 - 3e7 y2^2, dy3/dt = 3e7 y2^2. A Jacobiana no equilíbrio tem autovalores ≈ -0.04, -10^4, -3×10^7, com ρ ≈ 10^9 >>1000, tornando-o stiff.",
                              "finalVerifications": [
                                "Defina formalmente y' = f(y) com stiffness ratio >1000.",
                                "Classifique corretamente 3 exemplos (2 stiff, 1 não).",
                                "Explique impacto em solvers explícitos vs implícitos.",
                                "Calcule ρ para uma Jacobiana 2x2 dada.",
                                "Distinga stiffness de oscilação.",
                                "Forneça contraexemplo não-stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ρ = |λ_max / λ_min|.",
                                "Correta identificação de λ_min como dominante negativo.",
                                "Uso apropriado de linearização Jacobiana.",
                                "Threshold >1000 justificado com exemplo.",
                                "Compreensão qualitativa de escalas temporais.",
                                "Ausência de confusão com problemas lineares puros."
                              ],
                              "crossCurricularConnections": [
                                "Química: Modelagem de reações rápidas/lentas (ex: cinética enzimática).",
                                "Física: Oscilações amortecidas em circuitos RLC com parasitas.",
                                "Engenharia: Controle de sistemas com polos rápidos/lentos.",
                                "Biologia: Modelos populacionais com predador-presa stiff."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas combustão, onde escalas moleculares rápidas e macroscópicas lentas requerem solvers implícitos como BDF para eficiência computacional em CFD (Computational Fluid Dynamics)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.2",
                            "name": "Calcular razão de stiffness",
                            "description": "Para uma EDO linear y' = Ay, computar os autovalores de A e determinar a razão de stiffness como max|Re(λ)| / min|Re(λ)|, identificando se o problema é stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o sistema de EDO linear e identificar a matriz A",
                                  "subSteps": [
                                    "Leia a equação diferencial ordinária (EDO) dada no formato y' = A y, onde y é o vetor de estado e A é a matriz de coeficientes constante.",
                                    "Confirme que o sistema é linear com coeficientes constantes, sem termos não lineares.",
                                    "Extraia explicitamente a matriz A do problema fornecido.",
                                    "Verifique as dimensões de A (n x n para sistema de ordem n).",
                                    "Esboce a representação matricial para visualização."
                                  ],
                                  "verification": "A matriz A foi corretamente extraída e suas dimensões confirmadas por escrito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou caderno",
                                    "Exemplo de EDO linear"
                                  ],
                                  "tips": "Sempre anote a EDO original ao lado da matriz para evitar confusões.",
                                  "learningObjective": "Identificar e representar corretamente o sistema linear em forma matricial.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente termos não lineares como lineares",
                                    "Erros de transcrição na extração de A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os autovalores da matriz A",
                                  "subSteps": [
                                    "Lembre a definição: autovalores λ satisfazem det(A - λI) = 0.",
                                    "Construa a matriz A - λI e compute o polinômio característico.",
                                    "Resolva o polinômio para encontrar todos os autovalores λ_i.",
                                    "Se complexos, anote-os na forma a + bi.",
                                    "Verifique numericamente usando software se possível."
                                  ],
                                  "verification": "Lista completa de autovalores computados e polinômio característico resolvido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software como MATLAB, Python (NumPy/SciPy) ou Wolfram Alpha"
                                  ],
                                  "tips": "Para matrizes 2x2, use fórmula quadrática; para maiores, decomposição ou ferramentas numéricas.",
                                  "learningObjective": "Computar autovalores de forma precisa para sistemas lineares.",
                                  "commonMistakes": [
                                    "Esquecer o sinal em A - λI",
                                    "Erros aritméticos no polinômio",
                                    "Ignorar autovalores complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair as partes reais dos autovalores e identificar max/min |Re(λ)|",
                                  "subSteps": [
                                    "Para cada autovalor λ_i, identifique a parte real Re(λ_i).",
                                    "Calcule |Re(λ_i)| para todos os autovalores.",
                                    "Encontre o valor máximo max|Re(λ)| entre todos.",
                                    "Encontre o valor mínimo min|Re(λ)| (não zero, assumindo estabilidade).",
                                    "Liste os valores em uma tabela para clareza."
                                  ],
                                  "verification": "Tabela com Re(λ_i), |Re(λ_i)|, max e min destacados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha ou tabela em editor de texto"
                                  ],
                                  "tips": "Considere apenas partes reais não nulas; foque em magnitudes para escalas de tempo.",
                                  "learningObjective": "Analisar componentes reais dos autovalores para caracterização de rigidez.",
                                  "commonMistakes": [
                                    "Confundir parte real com módulo total |λ|",
                                    "Ignorar autovalores com Re(λ)=0",
                                    "Selecionar min como zero indevidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a razão de stiffness e classificar o problema",
                                  "subSteps": [
                                    "Compute a razão S = max|Re(λ)| / min|Re(λ)|.",
                                    "Interprete: se S >> 1 (tipicamente S > 1000), o problema é stiff.",
                                    "Registre o valor exato de S e a classificação (stiff ou não).",
                                    "Discuta implicações: necessidade de métodos implícitos para integração.",
                                    "Teste com variação pequena em A para sensibilidade."
                                  ],
                                  "verification": "Valor de S calculado, classificação feita e implicações anotadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software para verificação numérica"
                                  ],
                                  "tips": "Use log(S) para visualizar discrepâncias de escala; threshold comum é 10^3-10^6.",
                                  "learningObjective": "Determinar rigidez e suas consequências em métodos numéricos.",
                                  "commonMistakes": [
                                    "Dividir incorretamente max/min",
                                    "Classificar stiff com S pequeno",
                                    "Esquecer interpretação prática"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = [[-1, 0], [0, -1000]] y. Autovalores: λ1 = -1, λ2 = -1000. |Re(λ1)|=1, |Re(λ2)|=1000. Razão S = 1000/1 = 1000 → stiff (exige solvers implícitos como BDF).",
                              "finalVerifications": [
                                "Autovalores de A computados corretamente para pelo menos dois exemplos.",
                                "Partes reais extraídas e max/min |Re(λ)| identificados sem erros.",
                                "Razão S calculada precisamente e problema classificado como stiff/não-stiff.",
                                "Interpretação correta das implicações numéricas.",
                                "Verificação independente via software coincide com cálculos manuais.",
                                "Tabela ou relatório completo com todos os valores."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos autovalores (erro < 10^-6).",
                                "Correta extração e uso exclusivo das partes reais.",
                                "Cálculo exato da razão S sem erros aritméticos.",
                                "Classificação adequada baseada em threshold padrão (>1000).",
                                "Explicação clara de implicações para solvers numéricos.",
                                "Uso eficiente de ferramentas e verificações cruzadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em sistemas dinâmicos como circuitos RC.",
                                "Engenharia: Modelagem de controle em processos com múltiplas escalas de tempo.",
                                "Computação: Implementação de ODE solvers em Python/MATLAB para problemas stiff.",
                                "Química: Simulações de reações com cinéticas rápidas e lentas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, calcular stiffness em modelos de fluidodinâmica computacional (CFD) para escolher integradores numéricos adequados, evitando instabilidades em simulações de turbulência com escalas de tempo díspares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.3",
                            "name": "Identificar implicações para passos de tempo",
                            "description": "Explicar por que em problemas stiff, o passo h é ditado pela estabilidade (h < 2/|λ_min|) e não pela precisão local, levando a ineficiência computacional em métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e características de problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs com escalas de tempo muito díspares, envolvendo autovalores com partes reais grandes em magnitude.",
                                    "Identifique componentes rápidas (autovalores λ com Re(λ) << 0 e |λ| grande) e lentas (componentes com |λ| pequeno).",
                                    "Explique que em problemas stiff, a solução tende a seguir trajetórias lentas após um transiente rápido.",
                                    "Discuta o papel da rigidez na limitação de passos de tempo em métodos numéricos.",
                                    "Examine um exemplo matricial simples, como A com autovalores λ1 = -1, λ2 = -1000."
                                  ],
                                  "verification": "Resuma em uma frase por que problemas stiff são desafiadores para integradores explícitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre EDOs lineares, calculadora ou software como MATLAB para autovalores.",
                                  "tips": "Visualize autovalores no plano complexo para entender a rigidez.",
                                  "learningObjective": "Compreender as origens espectrais da rigidez em problemas stiff.",
                                  "commonMistakes": "Confundir rigidez com não-linearidade; rigidez é primariamente um fenômeno linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a condição de estabilidade para métodos explícitos",
                                  "subSteps": [
                                    "Revise o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive a condição de estabilidade para EDOs lineares y' = λ y: |1 + h λ| ≤ 1.",
                                    "Mostre que para λ com Re(λ) < 0 e |λ| grande, h deve satisfazer h < 2 / |λ_min| onde λ_min é o autovalor mais negativo.",
                                    "Teste numericamente com h acima e abaixo do limite para observar oscilações ou divergência.",
                                    "Compare com o método de Euler implícito, que é incondicionalmente estável."
                                  ],
                                  "verification": "Calcule h_max para λ = -1000 e demonstre instabilidade com h = 0.01.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (Python/Scipy ou MATLAB), planilha para testes.",
                                  "tips": "Use o diagrama de estabilidade de von Neumann para visualizar regiões.",
                                  "learningObjective": "Derivar e aplicar a restrição de estabilidade h < 2/|λ_min|.",
                                  "commonMistakes": "Ignorar a parte imaginária de λ; foque inicialmente em casos reais negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar estabilidade com precisão local",
                                  "subSteps": [
                                    "Defina precisão local: erro por passo O(h^2) ou superior, ditando h ~ 1/N para precisão global.",
                                    "Mostre que em problemas stiff, h_estabilidade << h_precisão, pois |λ_min| >> 1.",
                                    "Calcule para um problema não-stiff (λ ~ -1): h pode ser maior para precisão.",
                                    "Ilustre com gráfico de erro vs. h: platô de estabilidade limita antes da precisão.",
                                    "Explique que isso força milhares de passos desnecessários para capturar dinâmica lenta."
                                  ],
                                  "verification": "Compare h requerido para erro 10^{-6} vs. estabilidade em um exemplo stiff.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos gerados em Python/MATLAB, tabela de comparações.",
                                  "tips": "Plote log(|λ|h) para visualizar o trade-off.",
                                  "learningObjective": "Distinguir domínios de limitação: estabilidade vs. precisão.",
                                  "commonMistakes": "Assumir que precisão sempre domina; em stiff, estabilidade prevalece."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir implicações computacionais e alternativas",
                                  "subSteps": [
                                    "Quantifique ineficiência: custo ~ 1/h_estabilidade, exponencial em |λ_min|.",
                                    "Compare custo computacional explícito vs. implícito (resolve sistema linear por passo).",
                                    "Introduza métodos A-stáveis (ex: Backward Differentiation Formulas) que liberam h pela precisão.",
                                    "Avalie trade-offs: explícitos baratos por passo mas muitos passos; implícitos caros mas poucos.",
                                    "Conclua recomendando adaptativos ou implícitos para stiff."
                                  ],
                                  "verification": "Estime número de passos e tempo total para simular t=1 com h_stiff vs. h_precision.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Códigos de exemplo em Jupyter notebook.",
                                  "tips": "Use solvers como ode45 (adaptativo) vs. ode15s (stiff) no MATLAB.",
                                  "learningObjective": "Identificar ineficiência e motivar métodos implícitos.",
                                  "commonMistakes": "Subestimar custo de Jacobianos em implícitos; eles são viáveis com pré-condicionadores."
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - sin(t)) + cos(t), com y(0)=1. Aqui, λ ≈ -1000 dita h < 0.002 para estabilidade em Euler explícito, exigindo >500 passos para t=1, mesmo que precisão local permita h=0.1. Implícito converge com h=0.1 em 10 passos.",
                              "finalVerifications": [
                                "Explicar corretamente h < 2/|λ_min| como limite de estabilidade.",
                                "Identificar que em stiff, estabilidade domina precisão local.",
                                "Calcular h_max para dado λ e prever instabilidade.",
                                "Quantificar ineficiência computacional com números de passos.",
                                "Comparar com método implícito em exemplo numérico.",
                                "Descrever gráfico de erro vs. h mostrando platô de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição de estabilidade (exato: 80%).",
                                "Correta distinção estabilidade vs. precisão (com exemplos: 90%).",
                                "Uso de autovalores para caracterizar rigidez (correto: 85%).",
                                "Quantificação de ineficiência (ordem de magnitude: 80%).",
                                "Sugestões de alternativas viáveis (implícitos/A-estáveis: 75%).",
                                "Clareza em explicações e exemplos práticos (comunicação: 85%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos ou reações químicas stiff.",
                                "Computação: Otimização de algoritmos numéricos e análise de complexidade.",
                                "Engenharia: Simulações em controle de sistemas e dinâmica de fluidos.",
                                "Estatística: Integração de SDEs stiff em finanças ou bioestatística."
                              ],
                              "realWorldApplication": "Em simulações de combustão química (reações rápidas stiff), métodos explícitos falham economicamente; implícitos como BDF permitem prever frentes de chama em CFD para design de motores, reduzindo tempo de simulação de dias para horas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.4",
                            "name": "Reconhecer exemplos clássicos de stiff",
                            "description": "Analisar exemplos como y' = -1000y + sin(t) ou o oscilador de van der Pol com parâmetro μ grande, verificando autovalores e comportamento stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e características de problemas stiff",
                                  "subSteps": [
                                    "Defina um problema stiff como um sistema de EDOs onde os autovalores do Jacobiano têm partes reais muito negativas e variam em magnitude.",
                                    "Explique o conceito de escalas de tempo múltiplas: componentes rápidas (decaimento rápido) e lentas (oscilações suaves).",
                                    "Discuta a constante de Lipschitz elevada e a instabilidade de métodos explícitos com passos grandes.",
                                    "Identifique indicadores: razão entre o maior e menor |Re(λ)| > 1000 tipicamente.",
                                    "Revise exemplos não-stiff para contraste, como y' = -y + sin(t)."
                                  ],
                                  "verification": "Escreva uma definição precisa em suas próprias palavras e liste 3 características chave; compare com referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, notas de aula sobre EDOs lineares, calculadora.",
                                  "tips": "Use analogias como molas rígidas vs. flexíveis para visualizar rigidez.",
                                  "learningObjective": "Compreender os critérios teóricos para classificar problemas como stiff.",
                                  "commonMistakes": "Confundir stiff com não-linearidade; ignorar partes imaginárias dos autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o exemplo clássico linear y' = -1000y + sin(t)",
                                  "subSteps": [
                                    "Escreva o sistema em forma matricial: y' = A y + f(t), onde A = -1000.",
                                    "Calcule o autovalor: λ = -1000 (parte real muito negativa).",
                                    "Analise o comportamento: solução exata y(t) ≈ (sin(t) - sin(0))/1001 + decaimento rápido do termo homogêneo.",
                                    "Simule numericamente com Euler explícito: teste h=0.01 vs. h=0.001 para ver instabilidade.",
                                    "Classifique como stiff devido à razão de escalas 1000:1 (oscilação período 2π vs. decaimento 1/1000)."
                                  ],
                                  "verification": "Plote ou tabule solução numérica estável e confirme que h deve ser <<1/1000 para precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como Python (SciPy) ou MATLAB, ou planilha Excel para Euler simples.",
                                  "tips": "Comece com solução exata via variação de parâmetros para validar.",
                                  "learningObjective": "Identificar stiff em problemas lineares via autovalores e simulação.",
                                  "commonMistakes": "Esquecer o termo forçante sin(t) altera a escala lenta; usar h grande sem checar erro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o oscilador de Van der Pol com μ grande",
                                  "subSteps": [
                                    "Escreva as equações: x' = y, y' = μ[(1-x²)y - x].",
                                    "Para μ grande (ex: μ=1000), analise o Jacobiano linearizado no repouso: autovalores ≈ -μ/2 ± i, com Re(λ) ≈ -500 (rápido).",
                                    "Descreva o limite de relaxação: relaxação rápida para curva lenta (locus y = x - x³/3).",
                                    "Simule trajetórias: observe spikes rápidos e movimento lento ao longo da curva limite.",
                                    "Confirme stiff: componentes rápidas (transversais) vs. lentas (ao longo manifold)."
                                  ],
                                  "verification": "Gere gráfico de fase mostrando relaxação rápida; meça tempo para estabilizar em curva lenta.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB com odeint/ode45, ou app online como Desmos para 2D.",
                                  "tips": "Use μ=10 primeiro para visualizar, depois aumente para stiff.",
                                  "learningObjective": "Reconhecer stiff em problemas não-lineares via análise local e simulação.",
                                  "commonMistakes": "Tratar como não-stiff por ser oscilador; ignorar que μ grande cria rigidez."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar verificação e classificação de exemplos",
                                  "subSteps": [
                                    "Liste 3 exemplos clássicos adicionais: equação de Robertson, modelo químico stiff.",
                                    "Para cada um, calcule/compute autovalores ou escalas de tempo.",
                                    "Compare simulações explícita vs. implícita (ex: Backward Euler).",
                                    "Crie uma tabela: exemplo | autovalores | razão escalas | stiff? (sim/não).",
                                    "Explique verbalmente por que cada um é stiff ou não."
                                  ],
                                  "verification": "Submeta tabela e explicações; confira com soluções conhecidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, software numérico, referências online (Wikipedia 'Stiff equation').",
                                  "tips": "Foco em razão |λ_max / λ_min| > 10³ como regra prática.",
                                  "learningObjective": "Aplicar critérios para reconhecer stiff independentemente.",
                                  "commonMistakes": "Classificar baseado só em não-linearidade, não em rigidez espectral."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000y + sin(t), y(0)=0 com Euler explícito. Para h=0.01, solução diverge após t=0.1 devido à instabilidade; reduza h para 0.0005 para seguir sin(t)/1001, demonstrando necessidade de passos minúsculos para capturar decaimento rápido.",
                              "finalVerifications": [
                                "Identifica corretamente y'=-1000y+sin(t) como stiff com λ=-1000.",
                                "Explica Van der Pol (μ grande) como stiff via relaxação rápida para manifold lento.",
                                "Calcula autovalores com precisão para exemplos lineares.",
                                "Simula e observa instabilidade explícita em pelo menos um exemplo.",
                                "Lista pelo menos 2 indicadores quantitativos de stiff (ex: razão eigenvalues >1000)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de autovalores (erro <1%).",
                                "Correta identificação de componentes rápidas/lentas.",
                                "Qualidade das simulações numéricas (gráficos estáveis e interpretados).",
                                "Profundidade das explicações causais (por quê stiff?).",
                                "Capacidade de generalizar para novos exemplos.",
                                "Clareza na tabela de classificação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de osciladores amortecidos e limites de relaxação.",
                                "Engenharia: Simulações de circuitos com constantes de tempo díspares.",
                                "Computação: Implementação de solvers ODE (explícitos vs. implícitos).",
                                "Química: Cinética de reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em modelagem de redes químicas (ex: combustão), onde espécies intermediárias decaem rápido, métodos para stiff evitam artefatos numéricos e permitem simulações realistas de explosões ou reações catalíticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Características e Exemplos de Rigidez",
                    "description": "Propriedades matemáticas e exemplos clássicos de problemas stiff, como equações com escalas temporais díspares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Propriedades Matemáticas da Rigidez",
                        "description": "Definição e características matemáticas fundamentais dos problemas stiff, incluindo a presença de autovalores com partes reais grandes e negativas, levando a escalas temporais díspares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Definir problema stiff",
                            "description": "Explicar a definição formal de um problema stiff em equações diferenciais ordinárias (EDOs), destacando que métodos explícitos explodem numericamente devido à rigidez, mesmo que a solução seja suave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de EDOs e Métodos Numéricos Explícitos",
                                  "subSteps": [
                                    "Relembre a forma geral de uma EDO: dy/dt = f(t,y).",
                                    "Explique o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Discuta a estabilidade condicional de métodos explícitos, dependendo do passo h.",
                                    "Identifique que soluções suaves podem exigir h pequeno para precisão.",
                                    "Compare com métodos implícitos, que são incondicionalmente estáveis."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos revisados e dê um exemplo simples de Euler explícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo EDOs)",
                                    "Notebook para anotações",
                                    "Software como Python/MATLAB para testes rápidos"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar iterações numéricas.",
                                  "learningObjective": "Compreender os pilares de EDOs e limitações iniciais de métodos explícitos.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com precisão",
                                    "Ignorar dependência em h para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Rigidez via Escalas de Tempo",
                                  "subSteps": [
                                    "Defina escalas de tempo lenta e rápida em sistemas de EDOs.",
                                    "Explique que rigidez ocorre quando componentes rápidos decaem rapidamente mas solução total é suave.",
                                    "Discuta autovalores do Jacobiano com partes reais grandes negativas.",
                                    "Calcule o índice de rigidez: max|Re(λ)| / min|Re(λ)| >> 1.",
                                    "Ilustre com equação y' = λ y, onde λ < 0 e |λ| grande."
                                  ],
                                  "verification": "Calcule o índice de rigidez para λ = -1000 e λ = -1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel para cálculos",
                                    "Calculadora ou Python para autovalores"
                                  ],
                                  "tips": "Pense em analogia com molas rígidas vs. flexíveis.",
                                  "learningObjective": "Identificar rigidez como desequilíbrio de escalas temporais.",
                                  "commonMistakes": [
                                    "Confundir rigidez com não-linearidade",
                                    "Ignorar autovalores complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Falha Numérica de Métodos Explícitos em Problemas Stiff",
                                  "subSteps": [
                                    "Simule y' = -1000 y com y(0)=1 usando Euler explícito com h=0.01.",
                                    "Observe explosão numérica: solução oscila e diverge apesar de y exata = e^{-1000t} → 0 suavemente.",
                                    "Derive condição de estabilidade: h < 2 / |λ| para λ real negativo.",
                                    "Mostre que para rigidez alta, h deve ser minúsculo, tornando método impraticável.",
                                    "Compare com método implícito de Euler, que permanece estável."
                                  ],
                                  "verification": "Execute simulação e plote curvas, confirmando divergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Código template para Euler"
                                  ],
                                  "tips": "Use h ligeiramente maior que limite para ver explosão claramente.",
                                  "learningObjective": "Demonstrar numericamente por que explícitos falham em stiff problems.",
                                  "commonMistakes": [
                                    "Usar h muito pequeno acidentalmente",
                                    "Não plotar múltiplos passos h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição de Problema Stiff",
                                  "subSteps": [
                                    "Enuncie definição: Problema stiff se requer h << 1/|λ_max| para estabilidade com explícitos, mas solução suave.",
                                    "Inclua: mesmo com solução estável, rigidez causa instabilidade numérica.",
                                    "Destaque exemplos: reações químicas, circuitos RC com constantes diferentes.",
                                    "Discuta detecção: via autovalores ou testes numéricos.",
                                    "Resuma propriedades: alta rigidez, necessidade de métodos implícitos."
                                  ],
                                  "verification": "Escreva definição formal em suas palavras e aplique a um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência: Hairer 'Solving ODEs I'",
                                    "Resumo escrito"
                                  ],
                                  "tips": "Memorize: 'Solução suave, mas simulação explode'.",
                                  "learningObjective": "Articular definição precisa e contextualizada de stiff problem.",
                                  "commonMistakes": [
                                    "Definir apenas por autovalores sem menção a métodos",
                                    "Omitir suavidade da solução"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - sin(t)) com y(0)=0. Solução segue sin(t) suavemente após transiente rápido, mas Euler explícito com h=0.002 explode em oscilações, enquanto implícito converge.",
                              "finalVerifications": [
                                "Explique rigidez sem usar 'stiff'.",
                                "Simule exemplo e identifique explosão.",
                                "Calcule limite de estabilidade para λ=-999.",
                                "Distinga stiff de não-stiff.",
                                "Cite 2 aplicações reais.",
                                "Defina formalmente em 1 parágrafo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (inclui suavidade e falha explícita).",
                                "Correta interpretação de simulações numéricas.",
                                "Uso adequado de autovalores e rigidez ratio.",
                                "Clareza em distinções com problemas não-stiff.",
                                "Exemplos relevantes e cálculos exatos.",
                                "Conexão com necessidade de métodos implícitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos elétricos com capacitores (RLC stiff).",
                                "Química: Equações de reações em série com taxas díspares.",
                                "Computação: Otimização de solvers numéricos em SciPy/ODEPACK.",
                                "Engenharia: Simulações dinâmicas em controle de sistemas rígidos."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas em reatores industriais, problemas stiff surgem de taxas de reação muito diferentes; métodos explícitos falham, exigindo implícitos para previsões precisas de concentrações ao longo do tempo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Identificar autovalores em problemas stiff",
                            "description": "Analisar a matriz Jacobiana de um sistema de EDOs para identificar autovalores com partes reais grandes e negativas, que determinam a rigidez do problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de matriz Jacobiana em sistemas de EDOs",
                                  "subSteps": [
                                    "Revise a definição de um sistema de EDOs autônomas: dY/dt = f(Y), onde Y é um vetor.",
                                    "Entenda que a Jacobiana J é a matriz de derivadas parciais: J_ij = ∂f_i/∂y_j avaliada em um ponto.",
                                    "Identifique por que a Jacobiana lineariza o sistema ao redor de um equilíbrio.",
                                    "Discuta o papel da Jacobiana na estabilidade local via autovalores.",
                                    "Examine exemplos simples de Jacobianas para EDOs escalares e vetoriais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é a Jacobiana e seu propósito em EDOs, com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo EDOs)",
                                    "Notas de aula sobre linearização",
                                    "Calculadora simbólica como SymPy ou Mathematica"
                                  ],
                                  "tips": "Visualize a Jacobiana como a 'taxa de mudança' das funções f em relação às variáveis y.",
                                  "learningObjective": "Dominar a definição e o significado da matriz Jacobiana em contextos de EDOs.",
                                  "commonMistakes": [
                                    "Confundir Jacobiana com Hessiana",
                                    "Esquecer de avaliar em um ponto específico",
                                    "Ignorar que é para sistemas autônomos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz Jacobiana para um sistema de EDOs dado",
                                  "subSteps": [
                                    "Escreva o sistema de EDOs em forma vetorial: dY/dt = f(Y).",
                                    "Compute as derivadas parciais ∂f_i/∂y_j para cada i,j.",
                                    "Monte a matriz J com essas entradas.",
                                    "Avalie J em um ponto de equilíbrio Y* onde f(Y*) = 0.",
                                    "Verifique o cálculo simbólico ou numérico para precisão."
                                  ],
                                  "verification": "Produza a Jacobiana correta para um sistema exemplo fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/SymPy",
                                    "Exemplos de sistemas stiff de EDOs"
                                  ],
                                  "tips": "Use notação matricial clara e teste com valores numéricos simples.",
                                  "learningObjective": "Calcular com precisão a Jacobiana de sistemas de EDOs não lineares.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais mistas",
                                    "Não avaliar no equilíbrio",
                                    "Confundir índices de linhas/colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar os autovalores da matriz Jacobiana",
                                  "subSteps": [
                                    "Resolva o polinômio característico det(J - λI) = 0.",
                                    "Use métodos analíticos para matrizes 2x2 ou numéricos para maiores.",
                                    "Implemente em software para precisão (e.g., eig() no MATLAB).",
                                    "Identifique partes reais e imaginárias de cada autovalor λ.",
                                    "Confirme que todos os autovalores foram encontrados (multiplicidade algébrica)."
                                  ],
                                  "verification": "Liste todos os autovalores com partes reais para uma Jacobiana dada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB, Python com NumPy/SciPy)",
                                    "Tabela de polinômios característicos para 2x2"
                                  ],
                                  "tips": "Para problemas stiff, espere autovalores com |Re(λ)| grande.",
                                  "learningObjective": "Extrair autovalores de forma confiável de Jacobianas.",
                                  "commonMistakes": [
                                    "Erros no polinômio característico",
                                    "Ignorar autovalores complexos",
                                    "Arredondamentos numéricos sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar autovalores para identificar rigidez do problema",
                                  "subSteps": [
                                    "Analise Re(λ): rigidez ocorre quando max|Re(λ)| >> 1 (grande negativo).",
                                    "Compare escalas: rigidez se |Re(λ_stiff)| / |Re(λ_non-stiff)| >> 1.",
                                    "Verifique se partes imaginárias são pequenas comparadas às reais.",
                                    "Classifique o problema como stiff ou não com base nos autovalores.",
                                    "Discuta implicações para escolha de métodos numéricos (implícitos vs explícitos)."
                                  ],
                                  "verification": "Classifique corretamente um sistema como stiff baseado nos autovalores da Jacobiana.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas stiff clássicos (e.g., modelo químico)",
                                    "Gráficos de escalas de autovalores"
                                  ],
                                  "tips": "Foquem na magnitude da parte real negativa; rigidez = passos pequenos necessários em métodos explícitos.",
                                  "learningObjective": "Reconhecer padrões de autovalores indicativos de problemas stiff.",
                                  "commonMistakes": [
                                    "Focar só em autovalores positivos",
                                    "Ignorar múltiplos autovalores",
                                    "Confundir rigidez com instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema stiff de reação química: dy1/dt = -1000 y1 + 999 y2, dy2/dt = y1 - y2. No equilíbrio (0,0), Jacobiana J = [[-1000, 999], [1, -1]]. Autovalores: λ1 ≈ -1000, λ2 ≈ -1. |Re(λ1)| >> |Re(λ2)| indica rigidez.",
                              "finalVerifications": [
                                "Calcule corretamente a Jacobiana para um novo sistema.",
                                "Encontre todos autovalores com precisão numérica.",
                                "Identifique corretamente o autovalor dominante causador de rigidez.",
                                "Explique por que o problema é stiff em termos de escalas temporais.",
                                "Sugira método numérico apropriado (e.g., implícito) baseado na análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da Jacobiana (100% correto).",
                                "Correta computação e listagem de autovalores (erro < 1e-6).",
                                "Interpretação qualitativa e quantitativa de rigidez.",
                                "Uso apropriado de ferramentas numéricas sem erros.",
                                "Clareza na explicação das implicações para solvers de EDOs.",
                                "Identificação de pelo menos um erro comum evitado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em osciladores amortecidos com rigidez.",
                                "Química Computacional: Modelos de cinética química rígida.",
                                "Engenharia: Simulações de circuitos elétricos com parasitas.",
                                "Ciência da Computação: Otimização de algoritmos para solvers de EDOs stiff."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas rápidas/lentas (e.g., combustão), identificar autovalores stiff da Jacobiana permite escolher integradores implícitos como BDF, evitando instabilidade numérica e permitindo simulações precisas em indústrias farmacêutica e aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Explicar escalas temporais díspares",
                            "description": "Descrever como problemas stiff apresentam componentes rápidas (rigidas) e lentas (não-rigidas), exigindo passos de tempo muito pequenos em métodos explícitos para manter estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar escalas temporais em equações diferenciais ordinárias (EDOs)",
                                  "subSteps": [
                                    "Revise a forma geral de uma EDO linear autônoma: y' = A y, onde A é a matriz de coeficientes.",
                                    "Analise a solução analítica: y(t) = ∑ c_k v_k e^{λ_k t}, destacando o papel dos autovalores λ_k.",
                                    "Defina a escala temporal τ_k = 1 / |Re(λ_k)| para cada modo, representando o tempo de decaimento ou oscilação.",
                                    "Classifique escalas como rápidas (τ pequeno, |Re(λ)| grande) ou lentas (τ grande, |Re(λ)| pequeno).",
                                    "Discuta como múltiplas escalas criam disparidade quando max(τ) >> min(τ)."
                                  ],
                                  "verification": "Escreva e calcule τ para autovalores de uma matriz 2x2 simples, identificando disparidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora científica",
                                    "Notas de álgebra linear sobre autovalores"
                                  ],
                                  "tips": "Foquem na parte real dos autovalores para decaimento; parte imaginária para oscilações.",
                                  "learningObjective": "Compreender como autovalores determinam escalas temporais em soluções de EDOs.",
                                  "commonMistakes": [
                                    "Usar |λ_k| completo em vez de |Re(λ_k)|",
                                    "Confundir escala temporal com período oscilatório (2π/|Im(λ)|)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes rígidos e não-rígidos em problemas stiff",
                                  "subSteps": [
                                    "Defina rigidez: presença de escalas temporais díspares, com componentes rígidos (rápidos, τ pequeno) e não-rígidos (lentos).",
                                    "Examine o espectro de autovalores de A: rígidos têm |Re(λ)| >> 1/Δt desejado.",
                                    "Separe a solução y(t) = y_rápida(t) + y_lenta(t), onde y_rápida decai rapidamente para quase zero.",
                                    "Ilustre graficamente: plot de y(t) mostrando transientes rápidos vs. comportamento lento dominante.",
                                    "Compare com problemas não-stiff: todos τ similares, sem disparidade extrema."
                                  ],
                                  "verification": "Classifique os autovalores de uma matriz dada como rígidos ou não, justificando com razões de τ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem como Python/MATLAB ou Desmos",
                                    "Exemplos de matrizes stiff pré-definidas"
                                  ],
                                  "tips": "Use razão de rigidez ρ = max|Re(λ)| / min|Re(λ)| > 1000 como indicador prático.",
                                  "learningObjective": "Distinguir componentes rígidos e não-rígidos baseados em escalas temporais.",
                                  "commonMistakes": [
                                    "Ignorar que rigidez é relativa ao passo de tempo h",
                                    "Confundir rigidez com não-linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o impacto das escalas díspares em métodos explícitos",
                                  "subSteps": [
                                    "Revise método explícito de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Analise estabilidade: região de estabilidade limitada, requer h < 2 / max|Re(λ)| para modos rígidos.",
                                    "Demonstre instabilidade: para h fixo adequado à escala lenta, modos rígidos explodem (oscilações crescendo).",
                                    "Calcule passo de tempo restrito: h << min(τ_rígido), desperdiçando computação na escala lenta.",
                                    "Compare precisão: erro local O(h^2), mas global domina por necessidade de h minúsculo."
                                  ],
                                  "verification": "Simule Euler em um problema stiff com h inadequado e observe instabilidade numérica.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Código template para método de Euler"
                                  ],
                                  "tips": "Teste com h = 0.01 vs. h = 0.001 para ver trade-off estabilidade vs. eficiência.",
                                  "learningObjective": "Entender por que métodos explícitos falham em problemas stiff devido a restrições de h.",
                                  "commonMistakes": [
                                    "Achar que erro de truncamento causa instabilidade, não violação de estabilidade",
                                    "Esquecer normalização de h pela escala"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar explicação com exemplo e implicações",
                                  "subSteps": [
                                    "Monte exemplo: y' = [0 1; -ε^{-2} -2ε^{-1}] y, com ε pequeno (escalas 1 e ε).",
                                    "Compute autovalores: ≈ -ε^{-1} ± i ε^{-1}, τ_rápido ≈ ε, τ_lento ≈ 1.",
                                    "Simule com Euler explícito: mostre necessidade h << ε para estabilidade.",
                                    "Discuta solução: após transiente rápido, y ≈ solução lenta; métodos implícitos permitem h ~1.",
                                    "Resuma: escalas díspares forçam h pequeno em explícitos, ineficiente para simular longo tempo."
                                  ],
                                  "verification": "Escreva parágrafo explicando escalas díspares no exemplo, com razões qualitativas/quantitativas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código de simulação pronto",
                                    "Gráficos de solução analítica vs. numérica"
                                  ],
                                  "tips": "Use ε=0.01 para visualização clara sem computação excessiva.",
                                  "learningObjective": "Integrar conceitos em explicação coerente de rigidez via escalas temporais.",
                                  "commonMistakes": [
                                    "Omitir papel do transiente rápido",
                                    "Generalizar exemplo sem escalas díspares reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o oscilador amortecido rígido: y1' = y2, y2' = -1/ε^2 y1 - 2/ε y2 (ε=0.01). Autovalores ≈ -100 ± 100i (τ≈0.01) e comportamento lento. Euler explícito requer h<0.005 para estabilidade, mas simulação até t=10 leva >2000 passos; implícito permite h=0.1.",
                              "finalVerifications": [
                                "Defina corretamente escala temporal τ a partir de autovalor λ.",
                                "Identifique componentes rígidos em espectro de exemplo stiff.",
                                "Explique por que h deve ser << τ_rígido em métodos explícitos.",
                                "Descreva gráfico típico de solução stiff (transiente rápido + lenta).",
                                "Compare eficiência explícito vs. implícito para escalas díspares.",
                                "Calcule razão de rigidez ρ para matriz dada."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre τ_rápido e τ_lento.",
                                "Uso de matemática: autovalores e estabilidade corretamente invocados.",
                                "Exemplo concreto: ilustração numérica ou gráfica relevante.",
                                "Clareza explicativa: linguagem acessível sem jargão excessivo.",
                                "Completude: cobre definição, identificação, impacto e implicações.",
                                "Originalidade: evita cópia, usa analogias se apropriado."
                              ],
                              "crossCurricularConnections": [
                                "Física: modelagem de circuitos RLC com alta razão L/R (rigidez em amortecimento).",
                                "Química: cinética de reações com equilíbrios rápidos/lentos (reações enzimáticas).",
                                "Engenharia: simulações de controle em sistemas com parasitas rápidos.",
                                "Computação: análise de complexidade algorítmica em solvers numéricos."
                              ],
                              "realWorldApplication": "Em simulações climáticas, escalas díspares (atmosférico rápido vs. oceânico lento) exigem solvers implícitos para eficiência; em farmacocinética, modela absorção rápida vs. eliminação lenta de drogas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Exemplos Clássicos de Problemas Stiff",
                        "description": "Apresentação de exemplos padrão de problemas stiff, ilustrando as características matemáticas em contextos reais como reações químicas e osciladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Analisar equação de van der Pol stiff",
                            "description": "Estudar o exemplo da equação diferencial de van der Pol no regime stiff (parâmetro μ grande), mostrando relaxação rápida e solução limite suave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a equação de van der Pol e seu contexto stiff",
                                  "subSteps": [
                                    "Revise a forma padrão da equação: x'' - μ(1 - x²)x' + x = 0, onde μ > 0.",
                                    "Explique o papel do parâmetro μ: para μ pequeno, comportamento harmônico; para μ grande (>10), regime stiff.",
                                    "Identifique características stiff: relaxação rápida nas camadas de fronteira e solução limite suave no interior.",
                                    "Discuta origem histórica: modela oscilador elétrico não-linear inventado por Balthasar van der Pol.",
                                    "Esboce qualitativamente o ciclo limite para μ grande: oscilações de relaxação com saltos rápidos."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades stiff da equação e desenhe um esboço do ciclo limite.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Artigo original de van der Pol (1920)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com μ=1 para intuição, depois aumente para visualizar stiffening.",
                                  "learningObjective": "Compreender a estrutura matemática e o comportamento qualitativo da equação no regime stiff.",
                                  "commonMistakes": [
                                    "Confundir com regime não-stiff (μ pequeno)",
                                    "Ignorar o termo não-linear (1 - x²)",
                                    "Não reconhecer a origem como modelo físico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reescrever como sistema de EDOs de primeira ordem",
                                  "subSteps": [
                                    "Introduza variáveis: y1 = x, y2 = x' = y1'.",
                                    "Derive o sistema: y1' = y2, y2' = μ(1 - y1²)y2 - y1.",
                                    "Analise a rigidez: para μ grande, y2' tem escalas rápidas quando |y1| < 1.",
                                    "Discuta condições iniciais típicas: [2, 0] para convergir ao ciclo limite.",
                                    "Verifique dimensionalidade: sistema 2D autônomo não-linear."
                                  ],
                                  "verification": "Escreva o sistema vetorial e compute manualmente y' para y=[0.5, 0] com μ=100.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Folha de cálculo para testes manuais"
                                  ],
                                  "tips": "Use notação vetorial ŷ' = f(ŷ) para clareza.",
                                  "learningObjective": "Transformar a EDO de segunda ordem em sistema de primeira ordem pronto para integração numérica.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo de amortecimento",
                                    "Esquecer dependência não-linear em y2'",
                                    "Condições iniciais que não convergem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar solução limite e oscilações de relaxação",
                                  "subSteps": [
                                    "Estude aproximação assintótica para μ → ∞: lenta em |x|≈1, rápida em saltos.",
                                    "Descreva fases: lenta (x≈±2/3? Não, para van der Pol é x≈±2), rápida vertical.",
                                    "Derive equação reduzida lenta: dx/dt ≈ 1/(μ(1-x²)) durante fase lenta? Use escalonamento.",
                                    "Esboce diagrama de fase: ciclo retangular com curvas lentas hiperbólicas e saltos.",
                                    "Compare com solução exata para μ pequeno usando método de perturbação."
                                  ],
                                  "verification": "Desenhe o diagrama de fase aproximado e identifique pontos de salto (máx/mín).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de EDOs não-lineares (ex: Jordan & Smith)",
                                    "Gráficos de referência de soluções numéricas"
                                  ],
                                  "tips": "Use escalonamento τ = t/μ para separar escalas rápida/lenta.",
                                  "learningObjective": "Dominar análise qualitativa assintótica revelando estrutura stiff.",
                                  "commonMistakes": [
                                    "Confundir com Hopf bifurcation (μ pequeno)",
                                    "Ignorar matching assintótico nas camadas",
                                    "Amplitude errada: ciclo limite tem amplitude ~2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular numericamente e observar comportamento stiff",
                                  "subSteps": [
                                    "Implemente em Python/MATLAB com método explícito (RK4) para μ=10, 100, 1000.",
                                    "Observe instabilidade: passos pequenos necessários para estabilidade em regime rápido.",
                                    "Teste método implícito (ex: ode15s no MATLAB ou solve_ivp com BDF no SciPy).",
                                    "Plote trajetórias, diagrama de fase e y2 vs tempo mostrando relaxação rápida.",
                                    "Meça tempo de computação e tamanho de passo para quantificar rigidez."
                                  ],
                                  "verification": "Gere plots comparando explícito vs implícito; confirme ciclo limite suave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy/NumPy/Matplotlib",
                                    "MATLAB ou Octave",
                                    "Código template para van der Pol"
                                  ],
                                  "tips": "Use μ=1000; limite passos explícitos para ver falha.",
                                  "learningObjective": "Demonstrar numericamente por que problemas stiff requerem solvers especiais.",
                                  "commonMistakes": [
                                    "Passo fixo grande causando overflow",
                                    "Não normalizar para período ~constante",
                                    "Ignorar transients iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e implicações para solvers stiff",
                                  "subSteps": [
                                    "Resuma diferenças: explícito ineficiente (ordem reduzida), implícito eficiente.",
                                    "Discuta generalizações: índice de rigidez ~μ², A-stability necessária.",
                                    "Conecte a outros exemplos stiff (ex: Robertson chemical kinetics).",
                                    "Proponha extensões: adicionar ruído ou controle.",
                                    "Documente relatório com plots e conclusões."
                                  ],
                                  "verification": "Escreva um relatório de 1 página com key insights e plots.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto/LaTeX",
                                    "Plots gerados anteriormente"
                                  ],
                                  "tips": "Enfatize motivação para métodos backward differentiation (BDF).",
                                  "learningObjective": "Integrar teoria, análise e computação para domínio completo.",
                                  "commonMistakes": [
                                    "Não quantificar eficiência computacional",
                                    "Generalizar incorretamente para stiff não-oscillatórios"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente no SciPy: def vdp(t, y, mu): return [y[1], mu*(1-y[0]**2)*y[1] - y[0]]. Use solve_ivp com method='RK45' (explícito, falha para mu=1000) vs 'BDF' (sucesso). Plote para t=0..20, y0=[2,0]; observe relaxação em <0.1 unidades de tempo e ciclo limite periódico.",
                              "finalVerifications": [
                                "Descreve corretamente o ciclo limite como retangular com fases lenta/rápida.",
                                "Implementa simulação numérica estável para μ=1000 usando solver implícito.",
                                "Explica por que métodos explícitos falham (passos <1/μ necessários).",
                                "Desenha diagrama de fase preciso com curvas lentas ~x=±2.",
                                "Quantifica rigidez via tempo de CPU ou passos rejeitados.",
                                "Identifica aplicações reais como circuitos osciladores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do sistema de EDOs (100% correto).",
                                "Qualidade dos plots numéricos: claro, legendas, escalas apropriadas (nota 1-5).",
                                "Profundidade da análise assintótica: menciona escalonamento e matching (sim/não).",
                                "Compreensão de implicações stiff: diferencia explicit/implicit (explicação coerente).",
                                "Relatório síntese: estrutura lógica, insights originais (nota 1-5).",
                                "Tempo de conclusão dentro do estimado (±20%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores não-lineares em circuitos LC.",
                                "Engenharia Elétrica: Simulação de válvulas triodo no oscilador original.",
                                "Computação Científica: Algoritmos ODE solvers (Runge-Kutta vs multistep).",
                                "Química: Analogia com cinética química stiff (reações rápidas/lentas).",
                                "Controle Automático: Estabilização de limit cycles."
                              ],
                              "realWorldApplication": "A equação modela osciladores elétricos em rádios antigos (triodo valvular); hoje, usada em neuromorphic computing para spiking neurons, lasers semicondutores e modelagem cardíaca (scrolling de ação), onde rigidez surge de múltiplas escalas temporais, exigindo solvers stiff em simulações industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Examinar modelo de reações químicas rígidas",
                            "description": "Explorar um sistema de EDOs para reações químicas com escalas temporais muito diferentes, como o modelo de Oregonator ou decomposição radioativa, destacando a rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o modelo Oregonator e suas equações",
                                  "subSteps": [
                                    "Pesquise a reação de Belousov-Zhabotinsky e o modelo Oregonator simplificado.",
                                    "Identifique as variáveis principais: concentrações de A, B, C (ou u, v, w).",
                                    "Escreva as equações diferenciais: du/dt = f(u,v,w), dv/dt = g(u,v), dw/dt = h(u,w).",
                                    "Analise os parâmetros típicos (ex: ε pequeno para rigidez).",
                                    "Desenhe um diagrama esquemático das reações químicas envolvidas."
                                  ],
                                  "verification": "Escreva as equações completas em um documento e explique verbalmente o significado físico de cada termo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Artigos ou tutoriais sobre Oregonator (ex: Wikipedia, livros de EDOs); caderno para anotações.",
                                  "tips": "Comece com valores padrão de parâmetros para facilitar a compreensão inicial.",
                                  "learningObjective": "Compreender a estrutura matemática e física do modelo de reações químicas rígidas.",
                                  "commonMistakes": "Confundir variáveis ou ignorar o papel do parâmetro ε na rigidez."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o sistema de EDOs em Python",
                                  "subSteps": [
                                    "Instale bibliotecas: numpy, scipy.integrate, matplotlib.",
                                    "Defina a função das EDOs como def oregonator(t, y, params): com y = [u,v,w].",
                                    "Configure condições iniciais (ex: u0=0.1, v0=0.1, w0=0.1) e parâmetros (ε=0.01, etc.).",
                                    "Crie uma função para plotar soluções (concentrações vs tempo).",
                                    "Teste uma integração simples com solve_ivp."
                                  ],
                                  "verification": "Execute o código e gere um gráfico básico de u,v,w vs tempo sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python 3+, Jupyter Notebook, bibliotecas numpy, scipy, matplotlib.",
                                  "tips": "Use método='RK45' inicialmente para uma solução estável rápida.",
                                  "learningObjective": "Capacitar-se a codificar sistemas de EDOs químicos de forma reprodutível.",
                                  "commonMistakes": "Erros de indexação em y[0], y[1]; unidades inconsistentes nos parâmetros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular com métodos explícitos não-stiff e observar problemas",
                                  "subSteps": [
                                    "Use método explícito como 'Euler' ou 'RK45' com passo fixo pequeno.",
                                    "Aumente o intervalo de tempo e reduza ε para acentuar rigidez.",
                                    "Observe instabilidades: oscilações espúrias, blow-up ou lentidão extrema.",
                                    "Registre tempos de computação e compare gráficos com solução estável.",
                                    "Plote eigenvalues da Jacobiana para visualizar escalas temporais separadas."
                                  ],
                                  "verification": "Gere gráficos mostrando falhas (ex: NaN ou crashes) e anote tempos de execução.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código Python do step anterior; timer para medir performance.",
                                  "tips": "Comece com ε=0.1 e diminua para 0.001 para dramatizar a rigidez.",
                                  "learningObjective": "Identificar manifestações numéricas da rigidez em simulações químicas.",
                                  "commonMistakes": "Passos de tempo inadequados levando a resultados errôneos sem detecção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar escalas temporais e características de rigidez",
                                  "subSteps": [
                                    "Calcule os termos dominantes nas equações (fast: dw/dt, slow: du/dt).",
                                    "Estime Lipschitz constants ou condições da Jacobiana para rigidez.",
                                    "Compare escalas: τ_fast ~ ε, τ_slow ~1.",
                                    "Discuta por que métodos explícitos falham (passo h < ε).",
                                    "Documente em relatório: razões físicas (reações rápidas vs lentas)."
                                  ],
                                  "verification": "Produza um relatório com cálculos de escalas e eigenvalues plotados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código Python com sympy ou numpy para Jacobiana; documento LaTeX ou Markdown.",
                                  "tips": "Use np.linalg.eig para eigenvalues em pontos de equilíbrio.",
                                  "learningObjective": "Diagnosticar rigidez quantitativamente em sistemas químicos.",
                                  "commonMistakes": "Ignorar dependência em parâmetros, confundindo rigidez com não-linearidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar com métodos implícitos stiff e validar",
                                  "subSteps": [
                                    "Implemente solver stiff: method='BDF' ou 'Radau' no solve_ivp.",
                                    "Compare soluções, tempos e estabilidade com métodos explícitos.",
                                    "Varie ε e parâmetros para testar robustez.",
                                    "Valide contra literatura (padrões oscilatórios do Oregonator).",
                                    "Otimize tolerâncias (rtol=1e-6, atol=1e-8)."
                                  ],
                                  "verification": "Gere gráficos sobrepostos mostrando convergência e relatório de performance.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código estendido; referências literárias sobre Oregonator.",
                                  "tips": "Monitore eventos com events= no solve_ivp para oscilações.",
                                  "learningObjective": "Demonstrar superioridade de solvers stiff em problemas rígidos reais.",
                                  "commonMistakes": "Tolerâncias muito frouxas mascarando diferenças."
                                }
                              ],
                              "practicalExample": "Implemente o modelo Oregonator em Python com ε=0.02, simulando por t=0 a 100s. Use RK45 (falha com h>0.01) vs BDF (estável). Plote u,v,w mostrando oscilações químicas reais, destacando como solvers explícitos explodem enquanto implícitos capturam padrões de Belousov-Zhabotinsky.",
                              "finalVerifications": [
                                "Explicar verbalmente as equações e por que o sistema é rígido.",
                                "Executar simulações reproduzíveis com falhas explícitas e sucessos stiff.",
                                "Calcular e plotar eigenvalues da Jacobiana confirmando separação de escalas.",
                                "Comparar tempos de CPU: explícito >100x mais lento ou instável.",
                                "Identificar oscilações corretas vs literatura (período ~10-20 unidades).",
                                "Documentar relatório com gráficos e análises quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação das EDOs (equações idênticas à referência).",
                                "Detecção clara de rigidez via instabilidades numéricas observadas.",
                                "Análise quantitativa de escalas temporais (eigenvalues corretos).",
                                "Comparação robusta de solvers (gráficos sobrepostos, métricas de performance).",
                                "Relatório completo com interpretações físicas e matemáticas.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Química: Modelagem de reações oscilatórias como Belousov-Zhabotinsky.",
                                "Física: Dinâmica não-linear e sistemas dissipativos.",
                                "Computação: Algoritmos numéricos e otimização de solvers.",
                                "Biologia: Osciladores químicos em ritmos biológicos (ex: glicólise).",
                                "Engenharia: Simulações em reatores químicos industriais."
                              ],
                              "realWorldApplication": "Em farmacêutica, modela cinéticas rígidas de degradação de drogas; em química industrial, simula reatores com reações rápidas/lentas para otimizar yields; em astroquímica, decay chains radioativos para evolução estelar."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Comparar soluções numéricas em exemplos stiff",
                            "description": "Comparar o comportamento de métodos explícitos (como Euler) versus implícitos em exemplos clássicos, demonstrando instabilidade e necessidade de passos adaptativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e compreender um exemplo clássico de problema stiff",
                                  "subSteps": [
                                    "Escolha um problema stiff clássico, como y' = -1000(y - cos(t)), y(0) = 1, para t em [0, 1].",
                                    "Analise analiticamente a solução exata aproximada: y(t) ≈ cos(t) para grandes λ=1000.",
                                    "Identifique escalas de tempo rápida (transiente) e lenta (oscilação).",
                                    "Desenhe o gráfico qualitativo da solução exata.",
                                    "Explique por que é stiff: razão de eigenvalues grande."
                                  ],
                                  "verification": "Você pode resumir em um parágrafo as características do problema e esboçar o gráfico manualmente.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Papel e caneta para esboço",
                                    "Notebook Python com NumPy e Matplotlib",
                                    "Documentação de EDOs stiff online"
                                  ],
                                  "tips": "Comece com λ pequeno para visualizar, depois aumente para stiff.",
                                  "learningObjective": "Compreender as propriedades matemáticas de um problema stiff clássico.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linear",
                                    "Ignorar a solução quasi-estacionária y≈cos(t)",
                                    "Não escalar o problema adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e resolver usando método explícito (Euler forward)",
                                  "subSteps": [
                                    "Escreva o código Python para Euler forward com h fixo (ex: h=0.01).",
                                    "Execute com h pequeno e plote a solução numérica vs tempo.",
                                    "Reduza h para h=0.001 e observe o comportamento.",
                                    "Aumente h gradualmente até observar instabilidade.",
                                    "Registre os valores de h onde explode."
                                  ],
                                  "verification": "Gráficos mostram solução estável só para h muito pequeno; explode para h>0.005.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Python/Jupyter com NumPy, Matplotlib, SciPy",
                                    "Exemplo de código Euler forward"
                                  ],
                                  "tips": "Use np.linspace para t; monitore norma da solução para detectar blow-up.",
                                  "learningObjective": "Demonstrar instabilidade condicional do Euler explícito em stiff problems.",
                                  "commonMistakes": [
                                    "Passo h muito grande inicial",
                                    "Não plotar múltiplos h no mesmo gráfico",
                                    "Esquecer condição inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e resolver usando método implícito (Backward Euler)",
                                  "subSteps": [
                                    "Derive a fórmula do Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Implemente em Python resolvendo linearmente (para este f linear).",
                                    "Execute com vários h (0.01, 0.1, 1.0) e plote.",
                                    "Compare estabilidade com Euler explícito.",
                                    "Calcule erro relativo vs solução exata aproximada."
                                  ],
                                  "verification": "Solução permanece estável e precisa mesmo para h=0.1, próxima a cos(t).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Mesmo ambiente Python",
                                    "Solver linear np.linalg.solve se necessário"
                                  ],
                                  "tips": "Para problemas lineares, use forma matricial; teste com h grande para ver robustez.",
                                  "learningObjective": "Verificar A-stabilidade do método implícito em stiff problems.",
                                  "commonMistakes": [
                                    "Confundir forward/backward",
                                    "Não linearizar corretamente",
                                    "Ignorar termo f(t_{n+1}, y_{n+1})"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções e discutir passos adaptativos",
                                  "subSteps": [
                                    "Plote soluções lado a lado: explícito vs implícito vs exata.",
                                    "Calcule custo computacional (número de passos) para precisão similar.",
                                    "Discuta necessidade de h adaptativo: reduzir h localmente onde erro alto.",
                                    "Implemente um passo adaptativo simples (ex: Embedded RK, mas foque conceito).",
                                    "Conclua vantagens/desvantagens de cada método."
                                  ],
                                  "verification": "Relatório com gráficos, tabelas de h/erro/custo, e tabela comparativa.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Gráficos comparativos",
                                    "Tabela Excel ou Pandas para métricas"
                                  ],
                                  "tips": "Use logscale para h; destaque região transiente inicial.",
                                  "learningObjective": "Analisar trade-offs e motivar métodos adaptativos para stiff.",
                                  "commonMistakes": [
                                    "Não quantificar erro",
                                    "Ignorar custo do implícito",
                                    "Generalizar sem dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -1000(y - cos(t)), y(0)=1 em [0,10]: Euler explícito com h=0.01 diverge após t=0.1; Backward Euler com h=0.1 segue cos(t) com erro <1%.",
                              "finalVerifications": [
                                "Pode plotar soluções explícita/implícita mostrando blow-up no explícito.",
                                "Identifica h crítico para estabilidade no Euler forward (~1/1000).",
                                "Calcula erro L2 <0.01 para implícito com h=0.05.",
                                "Explica rigidez via razão de timescales.",
                                "Sugere Runge-Kutta implícito ou adaptativo como next step.",
                                "Relatório resume comparações quantitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instabilidade (ex: h>1/λ).",
                                "Qualidade dos gráficos comparativos (múltiplos h, escalas adequadas).",
                                "Análise quantitativa de erro e custo computacional.",
                                "Explicação clara de A-stabilidade e stiff decay.",
                                "Proposta válida de adaptação de passos.",
                                "Correção matemática na derivação dos métodos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Osciladores amortecidos stiff em dinâmica.",
                                "Química: Cinética de reações com timescales díspares (ex: Robertson).",
                                "Computação: Otimização de solvers numéricos (SciPy odeint).",
                                "Engenharia: Simulações em controle de sistemas rígidos."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC stiff, modelagem climática com dissipação rápida, ou farmacocinética onde métodos explícitos falham sem h minúsculo, exigindo implícitos para eficiência."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.4",
                            "name": "Identificar rigidez em problemas lineares",
                            "description": "Resolver e analisar problemas lineares stiff, como y' = -λy com λ >> 1, ilustrando a restrição no passo de tempo pelo critério de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de rigidez em equações diferenciais ordinárias (EDOs)",
                                  "subSteps": [
                                    "Defina um problema stiff como uma EDO onde os autovalores do Jacobiano têm partes reais muito negativas e discrepantes em magnitude.",
                                    "Identifique as componentes rápidas (rigidez) e lentas (dinâmica principal) na solução.",
                                    "Compare problemas stiff com não-stiff, destacando a necessidade de passos de tempo minúsculos em métodos explícitos.",
                                    "Revise o papel da estabilidade numérica em esquemas de integração.",
                                    "Estude exemplos simples como sistemas lineares autônomos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição de rigidez e suas implicações numéricas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de EDOs)",
                                    "Folha de anotações",
                                    "Acesso a definições online de 'stiff ODE'"
                                  ],
                                  "tips": "Use analogias como 'freios bruscos em um carro' para visualizar componentes rápidas.",
                                  "learningObjective": "Dominar a definição e causas de rigidez em problemas diferenciais.",
                                  "commonMistakes": [
                                    "Confundir rigidez com não-linearidade ou instabilidade incondicional.",
                                    "Ignorar a discrepância de escalas temporais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o exemplo clássico y' = -λy com λ >> 1",
                                  "subSteps": [
                                    "Resolva analiticamente a EDO y' = -λy, obtendo y(t) = y0 * exp(-λt).",
                                    "Observe o decaimento exponencial rápido para λ grande (ex: λ=1000).",
                                    "Aplique o método de Euler explícito: yn+1 = yn + h*(-λ yn) = yn(1 - λ h).",
                                    "Teste numericamente com h fixo e λ crescente, plotando soluções.",
                                    "Identifique o comportamento oscilatório quando |1 - λ h| > 1."
                                  ],
                                  "verification": "Gere um gráfico comparando solução exata e numérica para λ=1000 e h=0.001.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software como Python (NumPy/Matplotlib) ou MATLAB",
                                    "Exemplo de código para Euler explícito"
                                  ],
                                  "tips": "Comece com λ=1 (não-stiff) e aumente gradualmente para visualizar a transição.",
                                  "learningObjective": "Reconhecer rigidez no exemplo linear padrão através de análise qualitativa e numérica.",
                                  "commonMistakes": [
                                    "Escolher h muito grande sem testar estabilidade.",
                                    "Confundir erro de truncamento com erro de estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o critério de estabilidade e restrição de passo de tempo",
                                  "subSteps": [
                                    "Derive a condição de estabilidade para Euler explícito: |1 - λ h| ≤ 1, implicando h ≤ 2/|λ|.",
                                    "Calcule h máximo para λ=1000 (h≤0.002) e demonstre falha com h maior.",
                                    "Compare com métodos implícitos como Backward Euler, que não têm essa restrição.",
                                    "Analise o custo computacional: número de passos N ≈ T/h.",
                                    "Discuta trade-offs entre precisão, estabilidade e eficiência."
                                  ],
                                  "verification": "Calcule e justifique h máximo para um dado λ, prevendo instabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python para simulações",
                                    "Tabela de métodos numéricos"
                                  ],
                                  "tips": "Regra prática: h < 2/λ_max onde λ_max é o maior |Re(autovalor)|.",
                                  "learningObjective": "Aplicar critérios de estabilidade para quantificar rigidez.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em λ, invertendo a condição.",
                                    "Aplicar critério absoluto sem considerar o polo no semiplano esquerdo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de rigidez em problemas lineares variados",
                                  "subSteps": [
                                    "Dado um sistema linear Y' = A Y, compute autovalores de A.",
                                    "Classifique como stiff se max|Re(λ_i)| >> min|Re(λ_i)| ou λ grande negativo.",
                                    "Teste com exemplos: y1' = -10 y1 + y2, y2' = y1 - 0.1 y2.",
                                    "Simule numericamente e observe necessidade de h pequeno.",
                                    "Crie seu próprio exemplo stiff e valide."
                                  ],
                                  "verification": "Classifique 3 problemas dados como stiff ou não, justificando com autovalores.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou MATLAB para autovalores (numpy.linalg.eig)",
                                    "Lista de problemas de exemplo"
                                  ],
                                  "tips": "Foque em matrizes com autovalores discrepantes em magnitude.",
                                  "learningObjective": "Identificar rigidez de forma independente em problemas lineares.",
                                  "commonMistakes": [
                                    "Não normalizar escalas das variáveis.",
                                    "Ignorar autovalores complexos com parte real negativa grande."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -1000 y, y(0)=1, até t=0.1 com Euler explícito usando h=0.001 (estável) vs h=0.01 (instável, oscilações). Plote e observe como h deve ser <0.002 para estabilidade, ilustrando rigidez.",
                              "finalVerifications": [
                                "Explicar corretamente por que λ >>1 causa rigidez no exemplo y'=-λy.",
                                "Calcular h máximo de estabilidade para Euler explícito dado λ.",
                                "Identificar autovalores causadores de rigidez em um sistema 2x2.",
                                "Comparar soluções numérica e exata, destacando artefatos de instabilidade.",
                                "Propor uso de método implícito para problemas stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de rigidez (baseada em autovalores e estabilidade).",
                                "Correta derivação e aplicação do critério |1 - λ h| ≤1.",
                                "Análise qualitativa e quantitativa do exemplo clássico.",
                                "Identificação correta em 80% dos problemas de prática.",
                                "Uso apropriado de ferramentas computacionais sem erros de implementação.",
                                "Conexão clara entre teoria e simulações numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos com rigidez em amortecimento.",
                                "Química: Equações de cinética com reações rápidas e lentas (ex: mecanismos enzimáticos).",
                                "Engenharia Elétrica: Simulação de circuitos RC/RL com descargas rápidas.",
                                "Computação Científica: Otimização de solvers em bibliotecas como SciPy (métodos stiff).",
                                "Biologia Computacional: Modelos de populações com dinâmicas em múltiplas escalas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos integrados (IC design), onde capacitores descarregam rapidamente (λ grande), métodos explícitos falham sem h minúsculo, demandando solvers implícitos para eficiência em SPICE-like simulators."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Estabilidade em Métodos Explícitos",
                    "description": "Análise da perda de estabilidade em métodos de passo simples explícitos ao resolver problemas stiff.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Problemas Stiff",
                        "description": "Conceito fundamental de equações diferenciais ordinárias (EDOs) stiff, caracterizadas por componentes com escalas de decaimento muito rápidas e lentas, exigindo passos de tempo minúsculos para estabilidade em métodos explícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar características de um problema stiff",
                            "description": "Reconhecer EDOs stiff a partir de seus autovalores ou componentes com razões de escalas temporais extremas, como no modelo y' = λy com λ negativo e |λ| grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de problemas stiff em EDOs",
                                  "subSteps": [
                                    "Defina EDO stiff como sistemas com componentes de decaimento rápido e lento, exigindo passos de tempo pequenos em métodos explícitos.",
                                    "Estude a relação com a rigidez: razão de escalas temporais extremas (ex: τ_fast << τ_slow).",
                                    "Revise autovalores de sistemas lineares: parte real negativa grande indica rigidez.",
                                    "Compare com problemas não-stiff: autovalores com magnitudes semelhantes.",
                                    "Analise o exemplo simples y' = λy, onde |Re(λ)| grande e negativo causa stiff."
                                  ],
                                  "verification": "Explique em suas palavras o que torna uma EDO stiff e dê um exemplo numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogias como molas rígidas vs. flexíveis para visualizar escalas temporais.",
                                  "learningObjective": "Compreender a definição e causas raiz de problemas stiff.",
                                  "commonMistakes": "Confundir stiff com instabilidade numérica; stiff é sobre rigidez, não erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar autovalores para identificar rigidez",
                                  "subSteps": [
                                    "Linearize o sistema EDO não-linear ao redor de um ponto de equilíbrio.",
                                    "Calcule a matriz Jacobiana e encontre seus autovalores.",
                                    "Identifique autovalores com |Re(λ)| >> 1 (ex: λ = -1000 vs. λ = -1).",
                                    "Verifique se o espectro tem separação grande na parte real negativa.",
                                    "Classifique: se max|Re(λ)| / min|Re(λ)| > 1000, provável stiff."
                                  ],
                                  "verification": "Para um sistema dado, liste autovalores e conclua se é stiff com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplos de EDOs lineares"
                                  ],
                                  "tips": "Use eig() no MATLAB para computar autovalores rapidamente.",
                                  "learningObjective": "Aplicar análise espectral para detectar características stiff.",
                                  "commonMistakes": "Ignorar autovalores complexos; foque na parte real negativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer razões de escalas temporais extremas",
                                  "subSteps": [
                                    "Identifique componentes rápidos (ex: y_fast' = -1/ε y_fast, ε pequeno) e lentos.",
                                    "Calcule escalas temporais τ = 1/|λ| para cada modo.",
                                    "Verifique se max(τ) / min(τ) é muito grande (>>100).",
                                    "Examine termos com coeficientes grandes em equações desacopladas.",
                                    "Simule numericamente com passos variados para observar necessidade de h pequeno."
                                  ],
                                  "verification": "Descreva escalas temporais de um modelo e identifique discrepâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com odeint ou MATLAB ode45",
                                    "Gráficos de solução numérica"
                                  ],
                                  "tips": "Plote soluções com h fixo grande para ver oscilações em métodos explícitos.",
                                  "learningObjective": "Detectar stiff via análise de múltiplas escalas temporais.",
                                  "commonMistakes": "Focar só em magnitudes absolutas; considere direção (negativa para decaimento)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em exemplos concretos",
                                  "subSteps": [
                                    "Resolva 3 exemplos: um stiff (ex: y' = -1000y + y^2), um não-stiff e um borderline.",
                                    "Para cada, compute autovalores ou escalas e classifique.",
                                    "Compare estabilidade de Euler explícito vs. implícito.",
                                    "Documente características chave em um relatório curto.",
                                    "Teste com EDO não-linear: reações químicas rígidas."
                                  ],
                                  "verification": "Classifique corretamente 3 exemplos independentes com evidências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Notebook Jupyter",
                                    "Exemplos prontos de EDOs stiff"
                                  ],
                                  "tips": "Salve plots de erro vs. h para visualizar rigidez.",
                                  "learningObjective": "Consolidar identificação prática de problemas stiff.",
                                  "commonMistakes": "Classificar como stiff baseado só em não-linearidade, ignore linearidade local."
                                }
                              ],
                              "practicalExample": "Considere o sistema y' = [-999, 1; -1, -1] y. Autovalores ≈ -1000 e -1. Razão |λ1|/|λ2| ≈ 1000 indica stiff: modo rápido decai em t=0.001, lento em t=1. Euler explícito requer h<0.001 para estabilidade.",
                              "finalVerifications": [
                                "Explica corretamente stiff via autovalores ou escalas temporais.",
                                "Identifica stiff em exemplos lineares e não-lineares.",
                                "Distingue de problemas não-stiff.",
                                "Prevé impacto em métodos explícitos.",
                                "Fornece justificativa quantitativa (ex: razão >1000)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise espectral (autovalores corretos).",
                                "Correta interpretação de escalas temporais.",
                                "Classificação consistente com critérios quantitativos.",
                                "Uso de evidências numéricas/simulações.",
                                "Clareza na explicação de características."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de reações químicas rígidas (cinética).",
                                "Engenharia: Simulações de circuitos RC com parasitas.",
                                "Computação: Otimização de solvers ODE em SciPy.",
                                "Química: Equilíbrios rápidos em mecanismos de reação."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou clima, problemas stiff surgem em reações químicas rápidas vs. processos lentos; identificação permite escolher métodos implícitos como BDF, acelerando simulações industriais em farmacêutica e engenharia aeroespacial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Analisar o modelo teste para stiff",
                            "description": "Aplicar o problema teste y' = λy (λ ∈ ℂ, Re(λ) < 0) para demonstrar o comportamento instável em problemas stiff com autovalores de módulo elevado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo teste para problemas stiff",
                                  "subSteps": [
                                    "Defina o problema teste y' = λy, onde λ ∈ ℂ com Re(λ) < 0 e |λ| grande.",
                                    "Explique a solução analítica: y(t) = y(0) e^{λt}, que decai rapidamente para 0 devido a Re(λ) < 0.",
                                    "Discuta o conceito de stiff: escalas temporais muito diferentes, exigindo h << 1/|λ| para estabilidade em métodos explícitos.",
                                    "Identifique autovalores de módulo elevado como causa de rigidez.",
                                    "Esboce o comportamento esperado: solução suave e decrescente."
                                  ],
                                  "verification": "Escreva a solução exata e explique verbalmente por que é stiff para |λ| = 1000.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, referência de livro de análise numérica.",
                                  "tips": "Use λ = -1000 como exemplo concreto para visualizar o decaimento rápido.",
                                  "learningObjective": "Entender a natureza do problema teste e sua rigidez inerente.",
                                  "commonMistakes": "Confundir Re(λ) < 0 (estável analiticamente) com instabilidade numérica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método explícito (Euler forward) no modelo",
                                  "subSteps": [
                                    "Escreva a iteração de Euler forward: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Escolha y(0) = 1, intervalo [0,1], e teste h = 0.01 (adequado) vs h = 0.1 (inadequado para |λ|=1000).",
                                    "Implemente em código (Python/MATLAB) ou calcule manualmente 5 passos.",
                                    "Registre os valores de y_n para ambos h.",
                                    "Observe o fator amplificador |1 + hλ|."
                                  ],
                                  "verification": "Calcule y_5 para h=0.01 e confirme próximo da solução exata e^{-1000* t_5}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy/MATLAB, ou planilha Excel para cálculos manuais.",
                                  "tips": "Comece com poucos passos para depurar antes de simular todo o intervalo.",
                                  "learningObjective": "Aplicar método explícito e observar dependência em h.",
                                  "commonMistakes": "Esquecer o sinal negativo em λ, levando a crescimento em vez de decaimento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a região de estabilidade e instabilidade",
                                  "subSteps": [
                                    "Derive a condição de estabilidade para Euler forward: |1 + z| < 1, onde z = hλ.",
                                    "Plote no plano complexo z: região de estabilidade é disco |1 + z| ≤ 1.",
                                    "Para Re(λ) < 0, z está no semiplano esquerdo; para |λ| grande, h deve satisfazer h < 2/|λ|.",
                                    "Compare com h escolhido: para λ=-1000, h<0.002 para estabilidade.",
                                    "Explique por que métodos explícitos falham em stiff: h restrito pela componente rígida."
                                  ],
                                  "verification": "Desenhe o plano z e marque pontos z=hλ para h=0.01 e 0.1, indicando se dentro/fora da região.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel milimetrado ou software de plotagem (Python matplotlib).",
                                  "tips": "Lembre que para λ real negativo, estabilidade requer -2 < hλ < 0.",
                                  "learningObjective": "Derivar e interpretar a região de estabilidade absoluta.",
                                  "commonMistakes": "Confundir estabilidade absoluta com condicional ou ignorar parte imaginária."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar numericamente o comportamento instável e concluir",
                                  "subSteps": [
                                    "Simule com h grande (0.1): observe oscilações ou explosão de y_n.",
                                    "Simule com h pequeno (0.001): solução segue a exata.",
                                    "Gere gráficos de y(t) numérico vs exato para ambos h.",
                                    "Compare custo computacional: número de passos = T/h.",
                                    "Conclua necessidade de métodos implícitos para stiff."
                                  ],
                                  "verification": "Gráfico mostra divergência para h=0.1 e convergência para h=0.001.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python com Matplotlib/NumPy para simulação e plotagem.",
                                  "tips": "Use logscale no eixo y para visualizar decaimento.",
                                  "learningObjective": "Visualizar instabilidade e justificar métodos stiff-adequados.",
                                  "commonMistakes": "Escolher h muito pequeno inicialmente, mascarando o problema."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000 y, y(0)=1 em [0,0.05]. Com Euler forward e h=0.01, solução diverge após poucos passos (y_n oscila e cresce), enquanto solução exata é ~e^{-50} ≈ 1.9e-22. Com h=0.0005, aproxima bem, mas requer 100 passos vs 5 teóricos.",
                              "finalVerifications": [
                                "Explicar corretamente a condição |1 + hλ| < 1 para estabilidade.",
                                "Identificar h máximo para estabilidade dado λ.",
                                "Demonstrar via simulação que h grande causa instabilidade.",
                                "Comparar gráfico numérico com exato.",
                                "Discutir limitação de métodos explícitos em stiff.",
                                "Sugerir método implícito como Backward Euler."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição de estabilidade (100%).",
                                "Correção da implementação numérica e gráficos (90%).",
                                "Profundidade na análise de por que stiff causa instabilidade (80%).",
                                "Uso apropriado de exemplos concretos com λ=-1000.",
                                "Conexão clara entre teoria e simulação.",
                                "Ausência de erros comuns como sinal errado em λ."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de decaimento radioativo ou circuitos RC com constantes grandes.",
                                "Engenharia: Simulações em dinâmica de fluidos (CFD) com escalas múltiplas.",
                                "Computação: Otimização de algoritmos numéricos em software científico.",
                                "Química: Cinemática de reações com componentes rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), métodos explícitos com h inadequado causam crashes; usa-se solvers implícitos como em MATLAB ode15s para eficiência em autovalores rígidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Comparar escalas em sistemas stiff",
                            "description": "Examinar sistemas lineares com autovalores disparatados, calculando a razão de rigidez e prevendo restrições em h para métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender sistemas lineares stiff e autovalores disparatados",
                                  "subSteps": [
                                    "Defina um sistema linear de EDOs na forma y' = A y, onde A é uma matriz com autovalores reais negativos disparatados.",
                                    "Explique o conceito de rigidez: presença de escalas temporais muito diferentes devido a autovalores com magnitudes muito distintas.",
                                    "Identifique exemplos de autovalores disparatados, como λ1 ≈ -1 e λ2 ≈ -10^6.",
                                    "Discuta implicações para integração numérica: componentes rápidas e lentas decayem em taxas diferentes.",
                                    "Revise o papel dos autovalores na solução analítica: y(t) = sum c_i v_i exp(λ_i t)."
                                  ],
                                  "verification": "Resuma em um parágrafo as características de um sistema stiff e forneça um exemplo simples de matriz A.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), calculadora científica, papel e lápis.",
                                  "tips": "Visualize graficamente os modos de decaimento exponencial para entender disparidades.",
                                  "learningObjective": "Identificar e descrever sistemas stiff com base em autovalores disparatados.",
                                  "commonMistakes": "Confundir rigidez com instabilidade; rigidez é sobre escalas, não sinal dos autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores de uma matriz do sistema",
                                  "subSteps": [
                                    "Dada uma matriz A (ex: 2x2 ou 3x3), compute o polinômio característico det(A - λI) = 0.",
                                    "Resolva para autovalores usando fórmula quadrática ou métodos numéricos para maiores dimensões.",
                                    "Ordene autovalores por magnitude: |λ_max| << |λ_min| indica disparidade.",
                                    "Verifique autovetores associados se necessário para decomposição.",
                                    "Use software para validação em matrizes maiores."
                                  ],
                                  "verification": "Calcule autovalores para A = [[-1000, 1], [0, -1]] e liste-os com magnitudes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (numpy.linalg.eig), planilha Excel para pequenos casos.",
                                  "tips": "Para matrizes triangulares, autovalores são diagonais; pratique com elas primeiro.",
                                  "learningObjective": "Calcular e ordenar autovalores de matrizes representando sistemas stiff.",
                                  "commonMistakes": "Esquecer de considerar apenas partes reais para rigidez em sistemas reais negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e interpretar a razão de rigidez",
                                  "subSteps": [
                                    "Defina razão de rigidez ρ = |λ_min| / |λ_max|, onde λ_min tem maior magnitude.",
                                    "Compute ρ para o conjunto de autovalores calculados.",
                                    "Classifique: ρ > 10^3 geralmente stiff; discuta thresholds típicos.",
                                    "Analise impacto: componentes stiff dominam erro em passos grandes.",
                                    "Compare ρ entre diferentes sistemas para relativizar rigidez."
                                  ],
                                  "verification": "Para autovalores -1 e -1000, calcule ρ e explique se é stiff.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, tabela de autovalores do passo anterior.",
                                  "tips": "Use log10(ρ) para visualizar disparidade em escalas logarítmicas.",
                                  "learningObjective": "Quantificar rigidez via razão de autovalores e interpretá-la.",
                                  "commonMistakes": "Inverter ρ (usar menor sobre maior); sempre maior magnitude no denominador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever restrições no passo h para métodos explícitos",
                                  "subSteps": [
                                    "Lembre região de estabilidade de Euler explícito: |1 + h λ| < 1 para todos λ.",
                                    "Para λ reais negativos, h < 2 / |λ_min|.",
                                    "Estenda para Runge-Kutta: h < c / |λ_min| onde c depende do método.",
                                    "Simule numericamente para validar: integre com h acima/abaixo do limite.",
                                    "Discuta trade-off: h pequeno → custo computacional alto."
                                  ],
                                  "verification": "Para ρ=1000, estime h_max para Euler e teste estabilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/MATLAB para simulação (scipy.integrate.odeint), gráficos de solução.",
                                  "tips": "Plote solução analítica vs numérica para visualizar blow-up.",
                                  "learningObjective": "Derivar e aplicar restrições de estabilidade em h baseadas em rigidez.",
                                  "commonMistakes": "Ignorar que restrição é ditada pelo autovalor mais negativo, não médio."
                                }
                              ],
                              "practicalExample": "Considere o sistema y' = [[-1000, 1], [0, -1]] y, com autovalores ≈ -1000 e -1 (ρ=1000). Para Euler explícito, h < 0.002 para estabilidade. Simule y(0)=[1,1] até t=0.01: com h=0.001 converge, h=0.01 explode.",
                              "finalVerifications": [
                                "Calcula corretamente autovalores e ρ para um sistema dado.",
                                "Identifica escalas disparatadas e classifica como stiff.",
                                "Deriva h_max preciso para método explícito específico.",
                                "Simula e compara soluções estáveis vs instáveis.",
                                "Explica verbalmente implicações da rigidez.",
                                "Compara rigidez entre dois sistemas diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores (erro < 1e-6).",
                                "Correta definição e computação de ρ (>90% acerto).",
                                "Derivação exata de restrições h (fórmula e valor numérico).",
                                "Interpretação qualitativa da rigidez e estabilidade.",
                                "Uso adequado de software para validação gráfica.",
                                "Identificação de erros comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos com modos rápidos/lentos.",
                                "Engenharia Química: Reatores com cinéticas disparatadas.",
                                "Computação Científica: Otimização de solvers em bibliotecas como SciPy.",
                                "Física Computacional: Simulações de dinâmica molecular stiff."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) ou cinética química, sistemas stiff surgem de escalas multi-físicas; entender rigidez permite escolher h ótimo ou métodos implícitos, reduzindo tempo de CPU em supercomputadores para previsões climáticas ou design de aviões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Métodos Explícitos de Passo Único",
                        "description": "Métodos numéricos explícitos de passo simples, como Euler forward e Runge-Kutta de ordem baixa, aplicados a EDOs, com foco em sua formulação e limitação em problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Formular o método de Euler explícito",
                            "description": "Derivar e implementar y_{n+1} = y_n + h f(t_n, y_n) para o problema teste, identificando a condição de estabilidade |1 + hλ| ≤ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema de Valor Inicial e Conceitos Básicos de Métodos Explícitos",
                                  "subSteps": [
                                    "Recordar a forma geral de um problema de valor inicial (IVP): dy/dt = f(t, y), com y(t₀) = y₀.",
                                    "Explicar o que são métodos numéricos explícitos de passo único, focando no Euler como o mais simples.",
                                    "Diferenciar métodos explícitos (não requerem solução de equações no passo seguinte) de implícitos.",
                                    "Introduzir o problema teste para estabilidade em problemas stiff: y' = λy, y(0) = 1, onde λ é negativo e |λ| grande.",
                                    "Discutir a importância da estabilidade para problemas stiff."
                                  ],
                                  "verification": "Escrever corretamente a forma geral do IVP e descrever verbalmente a diferença entre explícito e implícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica (capítulo de EDOs)",
                                    "Calculadora"
                                  ],
                                  "tips": "Desenhe a reta tangente na solução exata para visualizar a aproximação linear do Euler.",
                                  "learningObjective": "Compreender os fundamentos teóricos necessários para derivar o método de Euler explícito.",
                                  "commonMistakes": [
                                    "Confundir a condição inicial y(t₀) com y(0)",
                                    "Ignorar o papel de f(t,y) na definição do IVP",
                                    "Misturar estabilidade com precisão local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula do Método de Euler Explícito",
                                  "subSteps": [
                                    "Aproximar a derivada no ponto tₙ: y'(tₙ) ≈ (y(tₙ + h) - y(tₙ))/h.",
                                    "Substituir y'(tₙ) pela função f: f(tₙ, yₙ) ≈ (y_{n+1} - yₙ)/h.",
                                    "Rearranjar a equação para obter y_{n+1} = yₙ + h f(tₙ, yₙ).",
                                    "Verificar a consistência via expansão de Taylor: a fórmula coincide com a solução exata até O(h²).",
                                    "Escrever a fórmula iterativa geral para n = 0,1,2,... até t_final."
                                  ],
                                  "verification": "Derivar a fórmula y_{n+1} = yₙ + h f(tₙ, yₙ) passo a passo sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Folha com expansão de Taylor básica"
                                  ],
                                  "tips": "Use setas para mostrar o rearranjo algébrico e evite saltar passos.",
                                  "learningObjective": "Derivar matematicamente a atualização do método de Euler explícito.",
                                  "commonMistakes": [
                                    "Usar f(t_{n+1}, y_{n+1}) em vez de f(tₙ, yₙ)",
                                    "Esquecer o fator h na aproximação",
                                    "Confundir com a fórmula de Euler implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método para um Problema Teste",
                                  "subSteps": [
                                    "Escolher o problema teste: y' = λy, y(0) = 1, com λ = -10 (stiff).",
                                    "Definir h = 0.1 e calcular os primeiros 3 passos manualmente: y₁, y₂, y₃.",
                                    "Comparar com a solução exata y(t) = e^{λt} para observar o erro.",
                                    "Tabular os resultados: n, tₙ, yₙ, f(tₙ,yₙ), h f(tₙ,yₙ).",
                                    "Discutir observações iniciais sobre comportamento numérico."
                                  ],
                                  "verification": "Calcular corretamente y₁ = 0.9, y₂ = 0.81, y₃ = 0.729 e tabela completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou papel para tabela"
                                  ],
                                  "tips": "Calcule f(tₙ,yₙ) = λ yₙ explicitamente para evitar erros aritméticos.",
                                  "learningObjective": "Aplicar a fórmula derivada a um IVP concreto e gerar aproximações numéricas.",
                                  "commonMistakes": [
                                    "Arredondamentos prematuros",
                                    "Erro no cálculo iterativo (ex: usar y_{n+1} no f)",
                                    "Não tabular para rastrear erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Analisar a Condição de Estabilidade",
                                  "subSteps": [
                                    "Aplicar o método ao problema teste: y_{n+1} = yₙ + h λ yₙ = (1 + hλ) yₙ.",
                                    "Analisar a recursão geométrica: |1 + hλ| ≤ 1 para que |yₙ| não exploda.",
                                    "Derivar a região de estabilidade no plano hλ: disco unitário centrado em -1.",
                                    "Verificar numericamente: para h=0.1, λ=-10, |1 -1| = 0 ≤1 (estável); para h=0.2, |1-2|=1=1 (marginal).",
                                    "Concluir limitações para problemas stiff (|λ| grande requer h pequeno)."
                                  ],
                                  "verification": "Escrever corretamente |1 + hλ| ≤ 1 e plotar/esboçar a região no plano complexo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para gráfico do plano hλ",
                                    "Software como GeoGebra (opcional)"
                                  ],
                                  "tips": "Pense em termos de amplificação por fator |r| <1 para convergência à solução zero.",
                                  "learningObjective": "Determinar a condição de estabilidade absoluta para o método de Euler explícito.",
                                  "commonMistakes": [
                                    "Usar |hλ| ≤1 em vez de |1 + hλ| ≤1",
                                    "Ignorar parte imaginária em λ complexo",
                                    "Confundir estabilidade com truncamento local"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o IVP y' = -10y, y(0)=1, h=0.1: y₁ = 1 + 0.1*(-10*1) = 0.9; y₂ = 0.9 + 0.1*(-10*0.9) = 0.81; y₃ = 0.729. Solução exata em t=0.3: e^{-3} ≈ 0.0498 (erro grande, mas estável aqui; aumente h para ver instabilidade).",
                              "finalVerifications": [
                                "Derivação completa da fórmula y_{n+1} = y_n + h f(t_n, y_n) sem erros.",
                                "Implementação correta para 3 passos no problema teste com tabela.",
                                "Condição de estabilidade |1 + hλ| ≤ 1 identificada e explicada.",
                                "Região de estabilidade esboçada corretamente.",
                                "Comparação com solução exata mostrando limitações.",
                                "Explicação verbal das razões para problemas stiff."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação (100% dos passos corretos).",
                                "Precisão nos cálculos numéricos (erro < 0.01 nos valores).",
                                "Compreensão da estabilidade demonstrada na análise qualitativa.",
                                "Clareza na tabulação e gráficos (legíveis e completos).",
                                "Profundidade na discussão de limitações (menciona ordem e stiff).",
                                "Criatividade no exemplo prático (aplica além do teste básico)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com loops para simulações longas.",
                                "Física: Modelar decaimento radioativo ou circuitos RC com EDOs lineares.",
                                "Engenharia: Simulações iniciais em controle de sistemas dinâmicos.",
                                "Computação Científica: Integração com bibliotecas como SciPy para comparação.",
                                "Estatística: Análise de erro numérico e propagação de incertezas."
                              ],
                              "realWorldApplication": "O método de Euler explícito é usado em solvers iniciais de EDOs em softwares como MATLAB (ode45 inicia com ele), simulações de trajetórias em jogos/vídeo games, modelagem básica de epidemias (SIR simplificado) e protótipos de controle em robótica, embora substituído por métodos implícitos em problemas stiff industriais como dinâmica de fluidos ou química reacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Calcular região de estabilidade para Euler explícito",
                            "description": "Determinar a região de estabilidade absoluta no plano complexo hλ, limitada ao disco |1 + z| ≤ 1 com z = hλ, e analisar sua inadequação para Re(λ) << 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método de Euler explícito e introduzir o conceito de estabilidade",
                                  "subSteps": [
                                    "Lembre-se da fórmula de iteração do Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Explique o teste de estabilidade para o problema modelo y' = λ y, levando a y_{n+1} = (1 + hλ) y_n.",
                                    "Defina z = hλ e introduza a função de amplificação R(z) = 1 + z.",
                                    "Discuta estabilidade absoluta: |R(z)| ≤ 1 para todos os autovalores λ do problema.",
                                    "Identifique que para problemas stiff, Re(λ) << 0 exige h muito pequeno."
                                  ],
                                  "verification": "Escreva a fórmula de amplificação R(z) corretamente e explique z = hλ em suas próprias palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Livro-texto de Análise Numérica (capítulo de métodos de Runge-Kutta)"
                                  ],
                                  "tips": "Visualize o problema como uma espiral no plano complexo para entender o crescimento ou decaimento.",
                                  "learningObjective": "Compreender a base conceitual da estabilidade no método de Euler explícito.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito com implícito",
                                    "Esquecer que z = hλ é complexo",
                                    "Ignorar o papel dos autovalores em problemas stiff"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a região de estabilidade no plano z",
                                  "subSteps": [
                                    "Escreva |R(z)| = |1 + z| ≤ 1.",
                                    "No plano complexo z = x + iy, expanda: |1 + x + iy|^2 = (1 + x)^2 + y^2 ≤ 1.",
                                    "Simplifique a desigualdade: (1 + x)^2 + y^2 ≤ 1, que descreve um disco centrado em (-1, 0) com raio 1.",
                                    "Verifique os limites: centro em z = -1, raio 1, tocando a origem.",
                                    "Desenhe o disco no plano complexo, destacando que está inteiramente no semiplano Re(z) ≤ 0."
                                  ],
                                  "verification": "Desenhe o disco |1 + z| ≤ 1 e marque pontos como z=0, z=-2, z=-1+i0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software como GeoGebra/Desmos para plotar",
                                    "Calculadora para verificar pontos"
                                  ],
                                  "tips": "Use a forma polar de z para validar pontos de fronteira: |1 + re^{iθ}| = 1.",
                                  "learningObjective": "Derivar e visualizar geometricamente a região de estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Erro na expansão da magnitude: esquecer y^2",
                                    "Confundir centro do disco (é -1, não 0)",
                                    "Pensar que inclui Re(z)>0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear a região para o plano hλ e analisar limitações",
                                  "subSteps": [
                                    "Note que z = hλ, com h>0 fixo e λ complexo (autovalores).",
                                    "Para λ real negativo (Re(λ)<0), h ≤ 2/|λ| para estabilidade.",
                                    "Para Re(λ) << 0 (stiff), h deve ser minúsculo para cobrir todos λ, limitando eficiência.",
                                    "Discuta rotação: para λ com parte imaginária, o disco restringe passos em direção radial.",
                                    "Compare com solução exata e^{hλ}, estável para todo h>0 quando Re(λ)<0."
                                  ],
                                  "verification": "Para λ = -100, calcule h_max tal que |1 + hλ| =1 e discuta por que é inadequado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos impressos do plano hλ",
                                    "Python/MATLAB para plotar (opcional)"
                                  ],
                                  "tips": "Pense em hλ como escalonamento: região fixa em z torna h restritivo para |λ| grande.",
                                  "learningObjective": "Analisar como a região em z afeta escolhas de h em problemas reais.",
                                  "commonMistakes": [
                                    "Esquecer h>0, permitindo regiões inválidas",
                                    "Ignorar que para stiff, h<<1 força muitos passos",
                                    "Confundir estabilidade absoluta com condicional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e ilustrar com exemplos numéricos",
                                  "subSteps": [
                                    "Escolha λ = -1 + i, compute R(z) para h=1 (z dentro/fora).",
                                    "Calcule iterativamente y_n para 5 passos e veja crescimento/decaimento.",
                                    "Plote trajetórias estáveis vs instáveis no plano hλ.",
                                    "Resuma inadequação: Euler explícito ruim para stiff devido a restrição h < 2/|λ_max|.",
                                    "Sugira transição para métodos implícitos com regiões maiores."
                                  ],
                                  "verification": "Execute um exemplo numérico mostrando instabilidade para h inadequado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou spreadsheet (Excel)",
                                    "Código Python simples para iterações"
                                  ],
                                  "tips": "Teste pontos de fronteira do disco para ver |R(z)|=1 exatamente.",
                                  "learningObjective": "Aplicar o cálculo em cenários numéricos concretos.",
                                  "commonMistakes": [
                                    "Arredondamento numérico levando a falsos positivos",
                                    "Não normalizar y_0=1",
                                    "Confundir oscilação com instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema y' = -50 y + sin(t), com λ ≈ -50 (stiff), calcule h_max ≈ 0.04 para |1 -50h| ≤1. Simule 100 passos com h=0.03 (estável) vs h=0.05 (instável, explode).",
                              "finalVerifications": [
                                "Desenhar corretamente o disco |1+z|≤1 centrado em -1 com raio 1.",
                                "Calcular h_max = 2/|λ| para λ real negativo.",
                                "Explicar por que Euler explícito falha em problemas stiff (Re(λ)<<0).",
                                "Identificar pontos dentro/fora da região para z dado.",
                                "Comparar com estabilidade da solução exata.",
                                "Plotar ou descrever região no plano hλ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de |1+z|≤1 (equação quadrática correta).",
                                "Visualização geométrica clara do disco no plano complexo.",
                                "Análise qualitativa correta das limitações para stiff problems.",
                                "Cálculos numéricos exatos em exemplos (erro <1%).",
                                "Conexão clara entre z=hλ e restrições práticas em h.",
                                "Explicação fluida sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos (equações diferenciais stiff).",
                                "Computação: Implementação em código numérico (Python/Scipy odeint).",
                                "Engenharia: Análise de controle e sistemas dinâmicos lineares.",
                                "Matemática Aplicada: Teoria de autovalores em análise de stiff ODEs."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (e.g., combustão), onde autovalores negativos grandes exigem h minúsculo no Euler explícito, levando a métodos implícitos para eficiência computacional em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Perda de Estabilidade em Métodos Explícitos",
                        "description": "Análise detalhada da instabilidade numérica em métodos explícitos para problemas stiff, resultando em passos h excessivamente pequenos ou oscilações/divergência.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Demonstrar perda de estabilidade numérica",
                            "description": "Simular numericamente o método explícito em y' = -1000y, mostrando que para h > 2/1000, a solução oscila ou diverge, apesar da solução exata decair rapidamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema e a solução exata",
                                  "subSteps": [
                                    "Analise a EDO y' = -1000y com condição inicial y(0) = 1.",
                                    "Derive a solução exata: y(t) = e^{-1000t}, que decai rapidamente para zero.",
                                    "Calcule o passo de estabilidade teórico: h < 2/λ = 0.002 para método explícito de Euler.",
                                    "Discuta o conceito de problema stiff devido ao autovalor grande negativo.",
                                    "Esboce graficamente o comportamento esperado da solução exata."
                                  ],
                                  "verification": "Escreva a fórmula exata e confirme que y(t) → 0 monotonicamente; anote o limite de estabilidade h < 0.002.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; calculadora.",
                                  "tips": "Lembre-se: λ = -1000 é o autovalor; estabilidade A-stável requer métodos implícitos para stiff.",
                                  "learningObjective": "Entender o decaimento exponencial rápido e o papel do passo h na estabilidade.",
                                  "commonMistakes": "Confundir o sinal do autovalor ou ignorar que a solução é decrescente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de Euler explícito",
                                  "subSteps": [
                                    "Escreva o esquema: y_{n+1} = y_n + h * f(t_n, y_n) = y_n + h*(-1000 y_n) = y_n (1 - 1000 h).",
                                    "Configure o código em Python com NumPy para integrar de t=0 a t=1.",
                                    "Defina função para diferentes valores de h: 0.001 (estável), 0.0021 (instável), 0.003 (divergente).",
                                    "Inicialize y[0] = 1 e armazene trajetórias.",
                                    "Adicione loop de tempo com dt = h."
                                  ],
                                  "verification": "Execute o código para h=0.001 e confirme que y final ≈ e^{-1} ≈ 0.000045.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy e Matplotlib; Jupyter Notebook.",
                                  "tips": "Use arrays NumPy para eficiência; teste com poucos passos primeiro.",
                                  "learningObjective": "Implementar corretamente o iterador de Euler explícito para EDO linear.",
                                  "commonMistakes": "Esquecer o fator (1 - 1000 h) ou usar h negativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações para vários h e visualizar",
                                  "subSteps": [
                                    "Rode simulações para h = 0.001, 0.002, 0.0021, 0.003 até t=1.",
                                    "Plote todas as curvas numéricas vs. solução exata y(t) = exp(-1000*t).",
                                    "Observe: para h ≤ 0.002, decaimento; para h > 0.002, oscilações ou divergência.",
                                    "Aumente t_max para ver blow-up em casos instáveis.",
                                    "Salve gráficos com legendas claras."
                                  ],
                                  "verification": "Gráficos mostram oscilação/divergência para h > 0.002 enquanto exata decai.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib para plotting; código do passo anterior.",
                                  "tips": "Use semilogy para visualizar decaimento rápido; limite eixos para foco em t=0 a 0.01.",
                                  "learningObjective": "Visualizar numericamente a perda de estabilidade em problemas stiff.",
                                  "commonMistakes": "Escala errada no plot ocultando oscilações; poucos pontos de plot."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e concluir sobre estabilidade",
                                  "subSteps": [
                                    "Compare erro global: ||y_num - y_exact|| para cada h.",
                                    "Explique amplificador de erro: |1 - 1000 h| >1 causa crescimento.",
                                    "Discuta região de estabilidade no plano complexo (disco de raio 2 para Euler).",
                                    "Teste h=2/1000=0.002: |1-2|=1, oscila sem crescer.",
                                    "Redija relatório resumindo perda de estabilidade numérica."
                                  ],
                                  "verification": "Relatório explica por que método explícito falha para stiff apesar de exata estável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos gerados; editor de texto.",
                                  "tips": "Foco no fator de amplificação r(hλ) = 1 + hλ.",
                                  "learningObjective": "Interpretar simulações em termos de teoria de estabilidade.",
                                  "commonMistakes": "Atribuir instabilidade a erro de truncamento em vez de estabilidade."
                                }
                              ],
                              "practicalExample": "Em Python: def euler_explicit(h, t_max=1): t = np.arange(0, t_max, h); y = np.exp(-1000*t); y_num = np.zeros_like(t); y_num[0]=1; for i in range(1,len(t)): y_num[i] = y_num[i-1]*(1-1000*h); plt.plot(t,y_num,label=f'h={h}'); plt.plot(t,y,'k--',label='exata'); plt.legend(); plt.show(). Rode para h=0.001 (decai), h=0.003 (diverge).",
                              "finalVerifications": [
                                "Solução exata y(t)=exp(-1000t) decai para <1e-10 em t=0.01.",
                                "Para h=0.001<0.002, y_num segue exata sem oscilação.",
                                "Para h=0.0021>0.002, y_num oscila em torno de zero.",
                                "Para h=0.003, y_num diverge para valores >1 ou NaN.",
                                "Gráficos comparativos salvos e anotados.",
                                "Fator |1-1000h| >1 confirmado para h>0.002."
                              ],
                              "assessmentCriteria": [
                                "Implementação do Euler explícito correta (20%).",
                                "Simulações para múltiplos h com plots claros (25%).",
                                "Análise precisa da condição |1 + hλ| ≤1 (25%).",
                                "Relatório explica stiff e perda de estabilidade (20%).",
                                "Verificações finais completas e precisas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decaimento radioativo ou circuitos RC com constantes rápidas.",
                                "Engenharia: Simulação de sistemas dinâmicos stiff em controle.",
                                "Computação: Algoritmos numéricos e análise de estabilidade.",
                                "Química: Cinética de reações com escalas temporais díspares."
                              ],
                              "realWorldApplication": "Em modelagem de reações químicas stiff (ex: combustão), métodos explícitos com h grande causam instabilidade, levando a predições erradas de concentrações; usar implícitos como BDF evita isso em software como MATLAB ode15s."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Avaliar impacto do controle de passo adaptativo",
                            "description": "Explicar como esquemas de controle de passo em métodos explícitos falham em stiff problems, forçando h → 0 para manter estabilidade, aumentando custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Problemas Stiff e Métodos Explícitos",
                                  "subSteps": [
                                    "Defina problemas stiff: equações diferenciais com escalas de tempo muito diferentes (ex.: eigenvalues com partes reais muito negativas).",
                                    "Explique métodos explícitos como Euler forward: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Discuta critério de estabilidade: região de estabilidade limitada para métodos explícitos.",
                                    "Identifique limitação: para stiff problems, h deve ser < 2/|λ_max| para estabilidade.",
                                    "Calcule exemplo simples: para y' = -λ y com λ grande, h_max ≈ 2/λ."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e calcule h_max para λ=1000.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex.: Burden & Faires), papel e calculadora.",
                                  "tips": "Use diagrama de Butcher para visualizar região de estabilidade.",
                                  "learningObjective": "Compreender por que métodos explícitos são instáveis em stiff problems.",
                                  "commonMistakes": "Confundir estabilidade com precisão; ignorar componente imaginária em eigenvalues."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Mecanismo de Controle de Passo Adaptativo",
                                  "subSteps": [
                                    "Descreva algoritmo padrão: estimar erro local com dois passos (h e h/2), ajuste h baseado em tolerância τ (h_new = h * (τ/err)^{1/(p+1)}).",
                                    "Implemente pseudocódigo para Runge-Kutta 4 com controle adaptativo.",
                                    "Teste em problema não-stiff: y' = -y, observe h crescendo para valor ótimo.",
                                    "Meça custo: número de avaliações de f por unidade de tempo.",
                                    "Compare com h fixo: mostre redução de custo com adaptativo."
                                  ],
                                  "verification": "Implemente e rode código simples mostrando h adaptando em não-stiff.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, editor de código.",
                                  "tips": "Comece com τ=1e-6; plote h vs. t para visualização.",
                                  "learningObjective": "Dominar como controle adaptativo otimiza custo em problemas suaves.",
                                  "commonMistakes": "Escolha errada de p (ordem do método); não rejeitar passos com err>τ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Falha em Problemas Stiff",
                                  "subSteps": [
                                    "Escolha problema stiff: y' = -1000(y - sin(t)), y(0)=1.",
                                    "Rode método explícito com controle adaptativo: observe h → 0 perto de λ grande.",
                                    "Plote solução, h(t) e erro: h fica preso em ~0.002 para estabilidade.",
                                    "Conte avaliações de f: custo explode devido a passos minúsculos.",
                                    "Compare com h fixo pequeno: similar custo, mas adaptativo falha em progredir."
                                  ],
                                  "verification": "Gere gráficos de h(t) e número de steps para stiff vs. não-stiff.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (odeint ou solve_ivp com método explícito custom), gráficos Matplotlib.",
                                  "tips": "Use stiff_test_eqs de SciPy para benchmarks; limite h_min para evitar loop.",
                                  "learningObjective": "Demonstrar que controle força h→0 em stiff, sem resolver instabilidade inerente.",
                                  "commonMistakes": "Usar solver implícito por engano; ignorar rejeições de passo no custo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar Impacto Computacional e Concluir",
                                  "subSteps": [
                                    "Meça custo: NF_evals / T_final para stiff vs. não-stiff.",
                                    "Estime escalabilidade: custo ~ 1/|λ_max| para explícito adaptativo.",
                                    "Compare com implícito (ex.: BDF): h constante maior, custo linear em log(1/τ).",
                                    "Discuta trade-offs: explícito bom para não-stiff, mas inviável para stiff reais.",
                                    "Resuma: controle adaptativo amplifica custo em stiff ao forçar h minúsculo."
                                  ],
                                  "verification": "Tabela comparativa de custos para λ=10^2, 10^3, 10^4.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Jupyter notebook para tabelas/gráficos.",
                                  "tips": "Varie λ sistematicamente; normalize custo por precisão.",
                                  "learningObjective": "Avaliar quantitativamente o overhead computacional em stiff problems.",
                                  "commonMistakes": "Não contabilizar rejeições; confundir custo com erro global."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000(y - sin(t)), y(0)=1 em [0,1] com RK4 adaptativo. Observe: h cai para ~0.002, >10^5 avaliações de f, vs. 100 para não-stiff y'=-y. Implícito (BDF) usa h~0.1, ~1000 evals.",
                              "finalVerifications": [
                                "Explicar verbalmente por que h→0 em stiff com controle adaptativo.",
                                "Apresentar gráficos de h(t) mostrando platô pequeno em stiff.",
                                "Calcular custo relativo: NF_stiff / NF_nonstiff >100x.",
                                "Identificar eigenvalue dominante no problema teste.",
                                "Comparar com método implícito em termos de custo.",
                                "Prever comportamento para λ=10^6 sem simular."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da causa raiz (estabilidade, não precisão).",
                                "Uso correto de métricas de custo (evals de f, não só steps).",
                                "Gráficos claros mostrando h→0 e custo explosivo.",
                                "Análise quantitativa com pelo menos 3 valores de λ.",
                                "Conclusão conectando falha ao design de métodos explícitos.",
                                "Ausência de confusão com métodos implícitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos stiff em dinâmica molecular.",
                                "Computação: Otimização de solvers ODE em bibliotecas como SciPy/ODEPACK.",
                                "Engenharia: Modelagem de circuitos RC stiff em eletrônica.",
                                "Estatística: Análise de erros em MCMC com tempos stiff."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, métodos explícitos com controle adaptativo falham em componentes stiff (ex.: reações rápidas), exigindo solvers implícitos para viabilidade computacional em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Comparar com métodos implícitos",
                            "description": "Contrastar a perda de estabilidade explícita com a robustez de métodos implícitos (ex: Backward Euler), destacando regiões de estabilidade ilimitadas no semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar perda de estabilidade em métodos explícitos",
                                  "subSteps": [
                                    "Relembre o método de Euler explícito e sua região de estabilidade limitada (|1 + hλ| ≤ 1).",
                                    "Analise exemplos de problemas stiff onde h deve ser muito pequeno para estabilidade.",
                                    "Plote a região de estabilidade no plano complexo, destacando o semiplano esquerdo restrito.",
                                    "Discuta impactos computacionais: custo alto devido a passos pequenos.",
                                    "Identifique equações teste como y' = -λy com λ grande positivo."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama de estabilidade do Euler explícito e explique por que falha em stiff problems.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, software de plotagem como Desmos ou Python (Matplotlib).",
                                  "tips": "Use λ = 100 para visualizar dramaticamente a restrição em h.",
                                  "learningObjective": "Compreender limitações quantitativas da estabilidade explícita.",
                                  "commonMistakes": "Confundir região de estabilidade com precisão; ignorar o semiplano esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir método implícito Backward Euler",
                                  "subSteps": [
                                    "Escreva a fórmula do Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Explique a natureza implícita: requer solução de equação não linear por iteração (ex: Newton).",
                                    "Derive a condição de estabilidade linearizada: |1 / (1 - hλ)| ≤ 1.",
                                    "Mostre que para Re(λ) < 0, a região é o semiplano esquerdo inteiro.",
                                    "Compare custo por passo: mais caro, mas permite h maior."
                                  ],
                                  "verification": "Escreva a fórmula e prove que a amplificação é estável para qualquer h > 0 quando Re(λ) < 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno de anotações, calculadora simbólica ou SymPy.",
                                  "tips": "Comece com o caso linear para simplificar a análise.",
                                  "learningObjective": "Dominar a formulação e propriedade básica de robustez do Backward Euler.",
                                  "commonMistakes": "Esquecer o denominador na fator de amplificação; subestimar custo iterativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e plotar regiões de estabilidade",
                                  "subSteps": [
                                    "Calcule os limites da região de estabilidade para Backward Euler no plano hλ.",
                                    "Plote ambas regiões: disco unitário para explícito vs. semiplano esquerdo ilimitado para implícito.",
                                    "Verifique numericamente com hλ = -100i (parte imaginária grande): explícito oscila, implícito converge.",
                                    "Discuta A-stabilidade: Backward Euler é A-estável.",
                                    "Compare com outros implícitos como Trapezoidal."
                                  ],
                                  "verification": "Gere gráficos mostrando inclusão da região implícita na explícita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB para plotar regiões.",
                                  "tips": "Use contour plots para |R(hλ)| = 1 onde R é o fator de amplificação.",
                                  "learningObjective": "Visualizar graficamente a superioridade em estabilidade.",
                                  "commonMistakes": "Plotar errado o semiplano (confundir esquerdo/direito); ignorar parte imaginária."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e contrastar em problemas stiff",
                                  "subSteps": [
                                    "Resolva um EDO stiff y' = -100y + sin(t) com ambos métodos para h=0.1.",
                                    "Meça passos necessários para erro < 1e-3: explícito precisa h<<0.01.",
                                    "Calcule eficiência: tempo total vs. precisão.",
                                    "Discuta trade-offs: precisão vs. custo por passo.",
                                    "Conclua quando usar implícitos: rigidez alta (λ grande)."
                                  ],
                                  "verification": "Tabela comparativa de erros e tempos para o exemplo numérico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software numérico (SciPy odeint ou MATLAB ode45/ode15s).",
                                  "tips": "Escolha λ >>1 para stiff; compare soluções exatas.",
                                  "learningObjective": "Aplicar comparação quantitativa em cenários reais.",
                                  "commonMistakes": "Usar h inadequado sem testar instabilidade; ignorar overhead implícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar implicações e vantagens",
                                  "subSteps": [
                                    "Resuma: explícitos rápidos mas instáveis em stiff; implícitos robustos mas custosos.",
                                    "Discuta métodos implicitamente Runge-Kutta para equilíbrio.",
                                    "Relacione com conceitos: Dahlquist, ordem vs. estabilidade.",
                                    "Prepare argumentos para defesa: por que implícitos em simulações reais.",
                                    "Crie um fluxograma de escolha de método baseado em rigidez."
                                  ],
                                  "verification": "Escreva um parágrafo contrastando os métodos com evidências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documento ou slide para resumo.",
                                  "tips": "Use bullet points para clareza na síntese.",
                                  "learningObjective": "Integrar conhecimento para tomada de decisão informada.",
                                  "commonMistakes": "Super-generalizar: nem todo stiff precisa implícito."
                                }
                              ],
                              "practicalExample": "Resolva y' = -50(y - sin(t)) + cos(t), y(0)=0 (stiff oscillator) com h=0.05. Euler explícito diverge após poucos passos; Backward Euler converge suavemente para a solução exata y=sin(t). Compare plots e erros em t=1.",
                              "finalVerifications": [
                                "Pode derivar fator de amplificação para ambos métodos.",
                                "Desenha regiões de estabilidade corretas e compara visualmente.",
                                "Implementa simulação numérica mostrando falha explícita e sucesso implícito.",
                                "Explica A-estabilidade e seu benefício para semiplano esquerdo.",
                                "Identifica cenários onde implícitos são essenciais.",
                                "Calcula h máximo estável para λ dado em ambos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de condições de estabilidade (20%)",
                                "Qualidade dos gráficos comparativos (25%)",
                                "Análise numérica correta com exemplos stiff (25%)",
                                "Clareza na explicação de trade-offs (15%)",
                                "Síntese de implicações práticas (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica molecular rígida.",
                                "Engenharia: Modelagem de circuitos RC stiff em controle.",
                                "Computação: Otimização de solvers em bibliotecas como SciPy.",
                                "Química: Cinética de reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, onde equações stiff (fast/slow timescales) exigem métodos implícitos como Backward Euler para eficiência computacional em supercomputadores, evitando crash por instabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Resolver exercício de estabilidade stiff",
                            "description": "Resolver um sistema stiff linear com método explícito, plotando soluções para diferentes h e identificando o limiar de instabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema stiff linear e solução analítica",
                                  "subSteps": [
                                    "Escolha um sistema linear stiff: y' = A y, onde A = diag(-1, -1000), y(0) = [1, 1].",
                                    "Calcule a solução exata: y1(t) = e^{-t}, y2(t) = e^{-1000 t}.",
                                    "Defina o intervalo de tempo [0, T] com T=5 para observar o comportamento rápido de y2.",
                                    "Documente as características stiff: razão de autovalores |λ2/λ1| = 1000.",
                                    "Verifique linearidade e condições iniciais."
                                  ],
                                  "verification": "Sistema definido com matriz A, y0 e solução exata escrita corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (SymPy ou MATLAB Symbolic).",
                                  "tips": "Use autovalores negativos grandes para simular decaimento stiff típico.",
                                  "learningObjective": "Compreender as propriedades de um sistema ODE stiff linear.",
                                  "commonMistakes": "Confundir autovalores positivos com negativos, levando a crescimento exponencial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de Euler explícito",
                                  "subSteps": [
                                    "Escreva a função iterativa: y_{n+1} = y_n + h * A * y_n.",
                                    "Crie uma função em Python/MATLAB que recebe y0, A, h, T e retorna a solução numérica.",
                                    "Implemente vetorização para eficiência com NumPy.",
                                    "Teste com h pequeno (ex: 0.001) e compare com solução exata em poucos pontos.",
                                    "Adicione salvamento de trajetórias para plotting posterior."
                                  ],
                                  "verification": "Função roda sem erros e reproduz solução estável para h=0.001.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e Matplotlib, ou MATLAB.",
                                  "tips": "Use arrays para y ao longo do tempo para facilitar plotting.",
                                  "learningObjective": "Implementar corretamente o esquema explícito de Euler para sistemas lineares.",
                                  "commonMistakes": "Esquecer de multiplicar A por y dentro do loop, ou usar h incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações para diferentes valores de h",
                                  "subSteps": [
                                    "Selecione valores de h: 0.0005, 0.001, 0.002, 0.005, 0.01 (cobrindo regimes estável e instável).",
                                    "Rode a simulação para cada h e armazene as soluções numéricas.",
                                    "Monitore normas ||y|| para detectar divergência precoce.",
                                    "Registre tempos de computação para cada h.",
                                    "Compare visualmente com solução exata em pontos selecionados."
                                  ],
                                  "verification": "Soluções geradas para todos h sem crashes, com dados salvos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código do passo anterior, planilha para registrar resultados.",
                                  "tips": "Comece com h pequenos para validar antes de testar instáveis.",
                                  "learningObjective": "Explorar o impacto do passo h na solução numérica.",
                                  "commonMistakes": "Escolher h muito grande inicialmente, causando overflow numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar soluções e analisar comportamento",
                                  "subSteps": [
                                    "Gere plots de y1(t) e y2(t) numérico vs exato para cada h, em subplots.",
                                    "Identifique oscilações ou divergência em y2 para h grandes.",
                                    "Calcule erro L2 médio para cada h.",
                                    "Anote o h onde a solução começa a oscilar (limiar aproximado).",
                                    "Adicione legenda e labels claros nos gráficos."
                                  ],
                                  "verification": "Gráficos gerados mostrando estabilidade para h pequeno e instabilidade para h grande.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Matplotlib ou MATLAB plotting.",
                                  "tips": "Use logscale para y2 se necessário para visualizar decaimento rápido.",
                                  "learningObjective": "Visualizar numericamente a perda de estabilidade em métodos explícitos.",
                                  "commonMistakes": "Plots sobrepostos ilegíveis; escalas inadequadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar o limiar de estabilidade",
                                  "subSteps": [
                                    "Teoria: região de estabilidade de Euler é |1 + h λ| < 1 para λ reais negativos.",
                                    "Calcule limiar teórico: h < 2 / |λ_max| = 2/1000 = 0.002.",
                                    "Compare com simulações: h crítico onde oscilação inicia.",
                                    "Discuta razão computacional: h pequeno requer muitos passos.",
                                    "Escreva relatório com conclusão e limiar estimado."
                                  ],
                                  "verification": "Relatório com limiar identificado (ex: h ≈ 0.002) e justificativa teórica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Resultados anteriores, papel para cálculos teóricos.",
                                  "tips": "Confirme teoria com fórmula de estabilidade absoluta.",
                                  "learningObjective": "Conectar análise teórica de estabilidade com evidências numéricas.",
                                  "commonMistakes": "Ignorar autovalor dominante, calculando errado o limiar."
                                }
                              ],
                              "practicalExample": "Sistema y' = [[-1, 0], [0, -1000]] y, y(0)=[1,1], T=5. Para h=0.001, solução estável próxima da exata; para h=0.01, y2 oscila e diverge rapidamente.",
                              "finalVerifications": [
                                "Solução numérica converge para exata quando h→0.",
                                "Plots mostram perda de estabilidade para h > 0.002.",
                                "Limiar teórico calculado corretamente como h<2/1000.",
                                "Erros L2 quantificados e crescem com h.",
                                "Código reproduzível e comentado.",
                                "Relatório explica fenômeno stiff."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação de Euler (20%).",
                                "Qualidade dos plots e visualização (20%).",
                                "Precisão na identificação do limiar (25%).",
                                "Análise teórica vs numérica (20%).",
                                "Clareza do relatório e documentação (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de NumPy para álgebra linear e Matplotlib para visualização.",
                                "Física: Modelos de decaimento em circuitos RLC ou reações químicas multi-escala.",
                                "Engenharia Computacional: Otimização de solvers em simulações CFD.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), métodos explícitos com h pequeno são ineficientes; identificar limiares guia escolha de métodos implícitos como BDF, economizando tempo computacional em softwares como COMSOL ou OpenFOAM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Métodos Implícitos Estáveis",
                    "description": "Introdução a métodos implícitos, como fórmulas de diferenciação backward (BDF), adequados para problemas stiff.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Métodos Implícitos",
                        "description": "Conceitos fundamentais sobre métodos implícitos para solução de equações diferenciais ordinárias (EDOs), destacando sua natureza que requer solução de sistemas lineares ou não lineares em cada passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Diferenciar métodos explícitos de implícitos",
                            "description": "Explicar as diferenças entre métodos explícitos (como Runge-Kutta) e implícitos, incluindo a dependência da solução atual em si mesma nos implícitos, e identificar cenários onde implícitos são necessários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Métodos Explícitos",
                                  "subSteps": [
                                    "Estude a fórmula geral de métodos explícitos, como o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Analise exemplos de Runge-Kutta explícito (RK4), destacando que cada estágio usa valores conhecidos anteriores.",
                                    "Implemente um código simples em Python para resolver uma EDO não-stiff usando Euler explícito.",
                                    "Observe o comportamento em problemas lineares simples, plotando a solução numérica vs. exata.",
                                    "Registre as vantagens: simplicidade e custo computacional baixo."
                                  ],
                                  "verification": "Implemente e plote a solução de y' = -y com Euler explícito; a curva deve convergir suavemente sem oscilações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter",
                                    "Exemplos de EDOs lineares"
                                  ],
                                  "tips": "Comece com passos h pequenos para ver precisão; use gráficos para visualização intuitiva.",
                                  "learningObjective": "Compreender que métodos explícitos calculam y_{n+1} apenas com dados do passo atual, sem dependência em y_{n+1}.",
                                  "commonMistakes": [
                                    "Confundir com métodos implícitos ao ignorar a ausência de y_{n+1} na fórmula",
                                    "Usar h muito grande levando a instabilidade mesmo em não-stiff"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Métodos Implícitos",
                                  "subSteps": [
                                    "Estude a fórmula do Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Discuta a necessidade de resolver uma equação não-linear em y_{n+1}, tipicamente via método de Newton.",
                                    "Implemente um solver simples de Newton para Euler implícito em Python.",
                                    "Teste em uma EDO linear como y' = -10y, comparando estabilidade com explícito.",
                                    "Anote desvantagens: custo computacional alto devido a iterações."
                                  ],
                                  "verification": "Resolva y' = -10y com Euler implícito; a solução deve permanecer estável para h=0.2, enquanto explícito oscila.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com SciPy para fsolve",
                                    "Notebook Jupyter",
                                    "Documentação de métodos de Newton"
                                  ],
                                  "tips": "Use tolerância baixa no Newton (1e-6) para precisão; inicialize iterações com y_n.",
                                  "learningObjective": "Reconhecer que métodos implícitos definem y_{n+1} implicitamente, dependendo de si mesma.",
                                  "commonMistakes": [
                                    "Esquecer de iterar no Newton, usando aproximação direta",
                                    "Não convergência por chute inicial ruim"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave Entre Explícitos e Implícitos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: fórmula, dependência, estabilidade, custo computacional.",
                                    "Analise o diagrama de Butcher para ambos, focando em coeficientes implícitos.",
                                    "Simule o mesmo problema com ambos métodos, variando h.",
                                    "Discuta ordem de precisão e estabilidade A-estável para implícitos.",
                                    "Explique verbalmente as diferenças para um colega ou em voz alta."
                                  ],
                                  "verification": "Preencha tabela comparativa corretamente e explique em 2 minutos as diferenças principais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Gráficos de soluções lado a lado"
                                  ],
                                  "tips": "Use cores na tabela para destacar diferenças; foque em 'dependência em y_{n+1}' como chave.",
                                  "learningObjective": "Diferenciar explicitamente a auto-dependência nos implícitos vs. independência nos explícitos.",
                                  "commonMistakes": [
                                    "Ignorar impacto na estabilidade",
                                    "Confundir custo com precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários para Métodos Implícitos (Problemas Stiff)",
                                  "subSteps": [
                                    "Defina problemas stiff: autovalores com partes reais grandes negativas.",
                                    "Exemplo: y' = -100y + sin(t), teste com h=0.1 em explícito (instável) vs. implícito (estável).",
                                    "Implemente e compare soluções, medindo erro e tempo de CPU.",
                                    "Liste cenários: reações químicas, circuitos RC, difusão.",
                                    "Crie fluxograma para escolher método baseado em stiffness."
                                  ],
                                  "verification": "Para EDO stiff, implícito converge, explícito diverge; fluxograma cobre 3 cenários comuns.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "EDOs stiff de exemplo"
                                  ],
                                  "tips": "Meça eigenvalues da matriz jacobiana para confirmar stiffness; use odeint para baseline.",
                                  "learningObjective": "Identificar quando implícitos são necessários devido a instabilidade explícita em stiff problems.",
                                  "commonMistakes": [
                                    "Não testar h grande o suficiente para revelar instabilidade",
                                    "Confundir stiff com não-linear"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva a EDO stiff y' = -50(y - sin(t)) com y(0)=0, usando Euler explícito e implícito com h=0.1. O explícito oscilará e divergirirá, enquanto o implícito produzirá uma solução suave próxima à exata y=sin(t). Plote ambos para visualização.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença na fórmula de y_{n+1} para explícito vs. implícito.",
                                "Identificar corretamente um método como implícito dada sua fórmula.",
                                "Simular um problema stiff e concluir que explícito falha.",
                                "Preencher tabela comparativa sem erros.",
                                "Criar fluxograma de escolha de método.",
                                "Discutir trade-offs de custo vs. estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da dependência em y_{n+1} (implícito vs. não).",
                                "Correta identificação de instabilidade em stiff problems.",
                                "Implementação funcional de ambos métodos em código.",
                                "Análise qualitativa/quantitativa via gráficos e erros.",
                                "Compreensão de cenários reais de aplicação.",
                                "Clareza na tabela/fluxograma comparativo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/SciPy.",
                                "Física: Modelagem de circuitos elétricos e decaimento radioativo (stiff).",
                                "Engenharia Química: Simulação de reações em série paralela.",
                                "Computação Científica: Otimização de solvers em ODEPACK."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos em software como SPICE, métodos implícitos (ex: trapezoidal) são usados para estabilidade em redes stiff com capacitores e resistores, evitando oscilações numéricas em análises transitórias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Derivar a fórmula do Backward Euler",
                            "description": "Derivar o método Backward Euler (BDF1) a partir da aproximação backward da derivada, escrevendo a equação y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) e discutindo sua forma implícita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema de Valor Inicial e Aproximações de Diferenças Finitas",
                                  "subSteps": [
                                    "Lembre o problema de valor inicial (IVP): dy/dt = f(t, y), y(t_0) = y_0.",
                                    "Discuta métodos de Euler: forward (explícito) usa y'(t_n) ≈ (y_{n+1} - y_n)/h.",
                                    "Introduza a ideia de aproximação backward: y'(t_{n+1}) ≈ (y_{n+1} - y_n)/h.",
                                    "Compare estabilidade: forward instável para problemas stiff, backward potencialmente estável.",
                                    "Anote as fórmulas lado a lado para visualização."
                                  ],
                                  "verification": "Escreva as fórmulas de forward e backward Euler em um papel e confirme que a backward usa f no ponto futuro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (opcional, capítulo de EDOs)"
                                  ],
                                  "tips": "Desenhe a reta tangente no ponto futuro para visualizar a backward approximation.",
                                  "learningObjective": "Compreender a diferença fundamental entre aproximações forward e backward da derivada.",
                                  "commonMistakes": [
                                    "Confundir forward com backward",
                                    "Esquecer que h é o passo de tempo",
                                    "Ignorar o contexto de problemas stiff"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Aproximação Backward da Derivada",
                                  "subSteps": [
                                    "Comece com a definição: y'(t_{n+1}) ≈ [y(t_{n+1}) - y(t_n)] / h.",
                                    "Expanda y(t_{n+1}) e y(t_n) em série de Taylor ao redor de t_{n+1} para justificar a precisão O(h).",
                                    "Substitua y(t_n) = y(t_{n+1} - h) ≈ y_{n+1} - h y'(t_{n+1}) + (h^2/2) y''(ξ).",
                                    "Mostre que o erro local é O(h^2), similar ao forward Euler.",
                                    "Escreva a equação aproximada: y_{n+1} - y_n = h y'(t_{n+1})."
                                  ],
                                  "verification": "Derive a expansão de Taylor e confirme o erro de truncamento O(h^2).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para termos de Taylor opcionais"
                                  ],
                                  "tips": "Use notação subscrita consistente: y_n para y(t_n).",
                                  "learningObjective": "Derivar e justificar a aproximação backward da primeira derivada.",
                                  "commonMistakes": [
                                    "Erro no sinal da série de Taylor",
                                    "Confundir ordem de precisão com estabilidade",
                                    "Esquecer o ponto de expansão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar a Aproximação com a Equação Diferencial",
                                  "subSteps": [
                                    "Substitua y'(t_{n+1}) por f(t_{n+1}, y_{n+1}) na equação backward.",
                                    "Escreva: [y_{n+1} - y_n]/h = f(t_{n+1}, y_{n+1}).",
                                    "Multiplique ambos os lados por h: y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                                    "Reorganize: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique y_{n+1} em ambos os lados, destacando a natureza implícita."
                                  ],
                                  "verification": "Escreva a equação final y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) sem erros algébricos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": "Cubra o lado direito temporariamente para ver a dependência em y_{n+1}.",
                                  "learningObjective": "Obter a fórmula explícita do Backward Euler a partir da substituição.",
                                  "commonMistakes": [
                                    "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})",
                                    "Erro na multiplicação por h",
                                    "Não notar a circularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir a Forma Implícita e Implicações",
                                  "subSteps": [
                                    "Explique por que é implícito: y_{n+1} aparece nos dois lados, requer solução numérica.",
                                    "Compare com forward Euler: y_{n+1} = y_n + h f(t_n, y_n), explícito.",
                                    "Mencione resolução via método de Newton: F(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0.",
                                    "Discuta vantagens para problemas stiff: A-stabilidade.",
                                    "Teste com exemplo simples para validar."
                                  ],
                                  "verification": "Reescreva como F(y_{n+1}) = 0 e descreva uma iteração de Newton.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python/MATLAB para teste opcional"
                                  ],
                                  "tips": "Pense em circuitos: backward modela capacitores implicitamente.",
                                  "learningObjective": "Reconhecer e explicar as propriedades implícitas do método.",
                                  "commonMistakes": [
                                    "Chamar de explícito",
                                    "Ignorar necessidade de solver não-linear",
                                    "Confundir com trapezoidal rule"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -10y, y(0)=1, h=0.1: Resolva y1 = 1 + 0.1*(-10*y1), levando a y1 - y1 = 1 -1 → y1*(1+1)=1 → y1=0.5 (exato aproximado).",
                              "finalVerifications": [
                                "Escreve corretamente y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                "Explica a origem backward da derivada.",
                                "Identifica a forma implícita e sugere Newton para resolução.",
                                "Justifica precisão O(h) e potencial estabilidade.",
                                "Aplica a um exemplo numérico simples sem erros.",
                                "Compara com forward Euler."
                              ],
                              "assessmentCriteria": [
                                "Derivação algébrica precisa sem erros de sinal ou h.",
                                "Justificativa teórica da aproximação backward via Taylor.",
                                "Explicação clara da implicitidade e necessidade de iteração.",
                                "Análise correta de estabilidade qualitativa para stiff.",
                                "Exemplo prático resolvido corretamente.",
                                "Uso consistente de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dissipativos como circuitos RC.",
                                "Computação: Implementação em solvers como SciPy odeint.",
                                "Engenharia Química: Simulação de reações stiff com cinética rápida.",
                                "Programação: Código em Python para método de Newton no Backward Euler."
                              ],
                              "realWorldApplication": "Usado em simuladores de dinâmica molecular e reações químicas stiff (ex: MATLAB ode15s, COMSOL) para prever comportamentos em escalas rápidas sem oscilações numéricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Resolver sistemas implícitos simples",
                            "description": "Aplicar métodos numéricos como ponto fixo ou Newton para resolver o sistema não linear gerado pelo Backward Euler em problemas lineares e não lineares simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Backward Euler e a Geração de Sistemas Implícitos",
                                  "subSteps": [
                                    "Revise a fórmula do método Backward Euler para EDOs: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique que isso resulta em um sistema não linear F(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0.",
                                    "Discuta problemas stiff onde métodos explícitos falham e implícitos são necessários.",
                                    "Resolva analiticamente um exemplo linear simples para validar.",
                                    "Esboce o fluxograma da iteração implícita."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o Backward Euler gera um sistema não linear e dê um exemplo resolvido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Comece com EDOs lineares para intuitividade antes de não lineares.",
                                  "learningObjective": "Entender a origem matemática dos sistemas implícitos no Backward Euler.",
                                  "commonMistakes": "Confundir com Forward Euler; ignorar a dependência em y_{n+1} na função f."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método do Ponto Fixo para Sistemas Implícitos",
                                  "subSteps": [
                                    "Reformule o sistema como y_{n+1}^{(k+1)} = g(y_{n+1}^{(k)}), onde g(y) = y_n + h f(t_{n+1}, y).",
                                    "Verifique o teorema do ponto fixo: |g'(y)| < 1 no intervalo.",
                                    "Escolha chute inicial y^{(0)} = y_n.",
                                    "Itere até |y^{(k+1)} - y^{(k)}| < tol.",
                                    "Teste convergência com h pequeno para stiff."
                                  ],
                                  "verification": "Implemente em pseudocódigo e rode para um exemplo, mostrando iterações convergentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como Python/MATLAB, papel para iterações manuais.",
                                  "tips": "Use h adaptativo se ponto fixo divergir; plote resíduos por iteração.",
                                  "learningObjective": "Aplicar iteração de ponto fixo para resolver sistemas implícitos simples.",
                                  "commonMistakes": "Chute inicial ruim levando a divergência; não checar Lipschitz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Método de Newton-Raphson para Não Linearidades",
                                  "subSteps": [
                                    "Defina F(y) = 0 e compute Jacobiano J(y) = I - h f_y(t_{n+1}, y).",
                                    "Inicie com y^{(0)} = y_n e resolva J Δy = -F(y^{(k)}), y^{(k+1)} = y^{(k)} + Δy.",
                                    "Atualize até ||F(y^{(k)})|| < tol ou máximo de iterações.",
                                    "Para lineares, note que Newton converge em 1 passo.",
                                    "Compare velocidade com ponto fixo."
                                  ],
                                  "verification": "Resolva um sistema não linear manualmente para 3 iterações e verifique norma do resíduo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora matricial, Python com NumPy/SciPy para Jacobiano.",
                                  "tips": "Aproxime Jacobiano numericamente se analítico difícil; use LU para resolver lineares.",
                                  "learningObjective": "Dominar Newton para sistemas implícitos com garantias quadráticas de convergência.",
                                  "commonMistakes": "Erro na derivada parcial f_y; singularidade no Jacobiano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar em Problemas Lineares e Não Lineares Simples",
                                  "subSteps": [
                                    "Teste linear: y' = -10y, y(0)=1 (stiff), compare com solução exata e^{ -10t }.",
                                    "Teste não linear: y' = -y^2, y(0)=1, solução 1/(1+t).",
                                    "Implemente código completo integrando Backward Euler + solver.",
                                    "Analise erro global vs. h e número de iterações por passo.",
                                    "Plote solução numérica vs. exata."
                                  ],
                                  "verification": "Gere gráfico mostrando convergência e erro < 1e-4 em [0,1].",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (matplotlib, numpy), exemplos de código prontos.",
                                  "tips": "Use tol=1e-6 para iterações; monitore iterações para eficiência.",
                                  "learningObjective": "Aplicar solvers em contextos stiff reais com validação.",
                                  "commonMistakes": "Passo h grande causando instabilidade; tol muito frouxo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Convergência e Otimizar",
                                  "subSteps": [
                                    "Compare Newton vs. Ponto Fixo em taxa de convergência e custo computacional.",
                                    "Estude condições de parada e tratamento de falhas (divergência).",
                                    "Experimente modificações: Newton quasi ou ponto fixo acelerado.",
                                    "Documente trade-offs para problemas stiff.",
                                    "Resuma em relatório curto."
                                  ],
                                  "verification": "Tabela comparativa de iterações, tempo e erro para ambos métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Jupyter notebook para benchmarks.",
                                  "tips": "Para stiff extremo, prefira Newton; ponto fixo para lineares simples.",
                                  "learningObjective": "Avaliar e escolher solvers apropriados para implícitos.",
                                  "commonMistakes": "Ignorar custo de Jacobiano em Newton para sistemas grandes."
                                }
                              ],
                              "practicalExample": "Para y' = -10y, y(0)=1, h=0.1, t=0.1: Backward Euler dá y1 - y0 + h*10 y1 = 0 → y1 = y0 / (1 + 10h) = 1/2. Usando Newton: F(y1)= y1 -1 +1*y1=0 (linear, 1 passo). Para não linear y'=-y^2, itere Newton até convergência.",
                              "finalVerifications": [
                                "Resolva manualmente um sistema linear implícito em <3 iterações.",
                                "Implemente código que integra Backward Euler + Newton para [0,1] com erro <1e-5.",
                                "Compare soluções com método explícito (Runge-Kutta) mostrando superioridade em stiff.",
                                "Explique por que ponto fixo pode falhar em não lineares fortes.",
                                "Gere plot de solução vs. exata sem oscilações.",
                                "Calcule ordem de precisão (1 para Backward Euler)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global <1e-4 em problemas teste.",
                                "Eficiência: <10 iterações por passo em média.",
                                "Correção: Jacobiano e reformulação do ponto fixo sem erros.",
                                "Validação: Comparação com soluções exatas ou referências.",
                                "Código limpo: Comentado, modular e reproduzível.",
                                "Análise: Identificação correta de convergência/divergência."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC/RL stiff com EDOs implícitas.",
                                "Programação: Implementação numérica em SciPy (solve_ivp com method='BDF').",
                                "Engenharia: Simulações CFD/química reacional com stiff ODEs.",
                                "Estatística: Otimização não linear via Newton em regressão."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), dinâmica de circuitos elétricos, ou controle de sistemas (ex: robótica), onde Backward Euler + Newton resolve EDOs rígidas sem oscilações, permitindo passos h maiores e simulações em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Fórmulas de Diferenciação Backward (BDF)",
                        "description": "Estudo das fórmulas BDF de ordem variável, métodos multistep implícitos estáveis projetados especificamente para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Descrever as fórmulas BDF de ordem 1 a 3",
                            "description": "Escrever as expressões gerais das fórmulas BDFk para k=1,2,3, explicando os coeficientes geradores α e β, e calcular aproximações para y_{n+1} em termos de valores anteriores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral das fórmulas BDF e os coeficientes geradores α e β",
                                  "subSteps": [
                                    "Estude a motivação das BDF para problemas stiff: métodos implícitos unilaterais baseados em diferenças backward.",
                                    "Leia a forma geral: ∑_{j=0}^k α_j y_{n+1-j} = h β_k f(t_{n+1}, y_{n+1}), onde α_0 = 1.",
                                    "Entenda a geração dos coeficientes: ρ(ζ) = (1 - ζ)^k para os α_j (normalizado), e β_k derivado da integral σ(ζ) = ∫_0^1 ρ(ζ/μ)/μ dμ.",
                                    "Consulte tabela de coeficientes padrão para k=1,2,3.",
                                    "Anote as propriedades: ordem de precisão k, A-estável para k≤2."
                                  ],
                                  "verification": "Escreva corretamente a forma geral e liste os papéis de α_j e β_k.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos multistep",
                                    "Tabela de coeficientes BDF"
                                  ],
                                  "tips": "Sempre normalize com α_0 = 1 para facilitar comparações.",
                                  "learningObjective": "Dominar a estrutura matemática geral das BDF e origem dos coeficientes.",
                                  "commonMistakes": [
                                    "Confundir com métodos forward (explícitos)",
                                    "Esquecer que β_k varia com k",
                                    "Ignorar a normalização α_0=1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e escrever a fórmula BDF de ordem 1",
                                  "subSteps": [
                                    "Comece com a aproximação de primeira ordem: diferença backward simples ∇y_{n+1} = y_{n+1} - y_n ≈ h y'(t_{n+1}).",
                                    "Escreva: y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                                    "Identifique coeficientes: α_0=1, α_1=-1, β_1=1.",
                                    "Verifique precisão: erro local O(h^2), consistente com método de Euler implícito.",
                                    "Compare com Euler implícito: é equivalente."
                                  ],
                                  "verification": "Escreva a fórmula BDF1 e seus coeficientes sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para derivação",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Pense em termos de operador ∇ para generalização.",
                                  "learningObjective": "Escrever e explicar a BDF1 com seus coeficientes.",
                                  "commonMistakes": [
                                    "Escrever como explícito: y_{n+1} = y_n + h f(t_n, y_n)",
                                    "Erro no sinal dos α_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e descrever a fórmula BDF de ordem 2",
                                  "subSteps": [
                                    "Use polinômio ρ(ζ) = (1 - ζ)^2 = 1 - 2ζ + ζ^2, ajuste normalização: α_0=1, α_1=-4/3, α_2=1/3.",
                                    "Calcule β_2 = 2/3 via método dos momentos ou tabela.",
                                    "Escreva: y_{n+1} - (4/3) y_n + (1/3) y_{n-1} = (2/3) h f(t_{n+1}, y_{n+1}).",
                                    "Verifique ordem: truncamento O(h^3).",
                                    "Discuta estabilidade: A-estável."
                                  ],
                                  "verification": "Derive os coeficientes α e β para k=2 e escreva a fórmula completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software para resolver sistema de equações",
                                    "Referência com derivação BDF"
                                  ],
                                  "tips": "Resolva o sistema para α_j impondo condições de precisão até ordem 2.",
                                  "learningObjective": "Dominar a BDF2, seus coeficientes e derivação.",
                                  "commonMistakes": [
                                    "Coeficientes errados: comum confundir 4/3 com 2",
                                    "Esquecer y_{n-1} no escopo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a BDF de ordem 3 e calcular aproximações para y_{n+1}",
                                  "subSteps": [
                                    "Para k=3: ρ(ζ)=(1-ζ)^3 =1 -3ζ +3ζ^2 -ζ^3, normalizado α_0=1, α_1=-18/11, α_2=9/11, α_3=-2/11.",
                                    "β_3=6/11.",
                                    "Escreva: y_{n+1} - (18/11)y_n + (9/11)y_{n-1} - (2/11)y_{n-2} = (6/11) h f(t_{n+1}, y_{n+1}).",
                                    "Exemplo de cálculo: dado y_n, y_{n-1}, y_{n-2}, isole y_{n+1} = [ (18/11)y_n - (9/11)y_{n-1} + (2/11)y_{n-2} + (6/11) h f ] / 1.",
                                    "Note perda de A-estabilidade para k=3."
                                  ],
                                  "verification": "Calcule y_{n+1} numericamente para valores fictícios e escreva todos coeficientes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de coeficientes BDF",
                                    "Exercícios resolvidos"
                                  ],
                                  "tips": "Sempre isole y_{n+1} para ver a forma implícita.",
                                  "learningObjective": "Completar descrição das BDF1-3 e computar aproximações.",
                                  "commonMistakes": [
                                    "Frações incorretas como 18/10 ao invés de 18/11",
                                    "Confundir índices de y_{n-2}"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -50(y - sin(t)), y(0)=0, h=0.02. Suponha y_{n-2}=0.01, y_{n-1}=0.015, y_n=0.018. Para BDF3: resolva y_{n+1} -1.636 y_n +0.818 y_{n-1} -0.182 y_{n-2} = 0.545 h f(t_{n+1}, y_{n+1}) numericamente (ex: iteração de ponto fixo).",
                              "finalVerifications": [
                                "Escrever corretamente as três fórmulas BDF1, BDF2, BDF3.",
                                "Listar todos α_j e β_k para k=1,2,3.",
                                "Explicar origem dos coeficientes geradores.",
                                "Calcular y_{n+1} para BDF3 com valores dados.",
                                "Identificar diferenças entre ordens (escopo de passos atrás).",
                                "Discutir quando usar cada uma (stiff, estabilidade)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas e coeficientes (100% correto).",
                                "Explicação clara da geração de α e β.",
                                "Capacidade de isolar y_{n+1} e descrever resolução implícita.",
                                "Uso correto de notação matemática.",
                                "Compreensão de propriedades (ordem, estabilidade).",
                                "Aplicação em cálculo numérico simples."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com solve_ivp( method='BDF' ).",
                                "Engenharia Química: Simular reações stiff com cinética rápida.",
                                "Física Computacional: Dinâmica molecular com escalas múltiplas.",
                                "Ciência de Dados: Otimização em ML com gradientes stiff."
                              ],
                              "realWorldApplication": "As BDF são usadas em solvers como CVODE/SUNDIALS para simular sistemas stiff em farmacocinética (degradação de drogas), circuitos elétricos ( capacitores/diodos), e modelos climáticos (processos rápidos como convecção)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Implementar BDF2 numéricamente",
                            "description": "Implementar o método BDF2 em pseudocódigo ou código simples, resolvendo o sistema implícito resultante para um problema de EDO stiff modelo, como y' = -λy com λ grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Derivar a Fórmula BDF2",
                                  "subSteps": [
                                    "Revise a aproximação de backward difference para a derivada: ∇y_{n+1} = (y_{n+1} - y_n)/h ≈ y'(t_{n+1}).",
                                    "Estenda para ordem 2: ∇²y_{n+1} = (3/2 y_{n+1} - 2 y_n + 1/2 y_{n-1})/h ≈ y'(t_{n+1}).",
                                    "Escreva a fórmula implícita: (3/2) y_{n+1} - 2 y_n + (1/2) y_{n-1} = h f(t_{n+1}, y_{n+1}).",
                                    "Identifique o caráter implícito devido a f depender de y_{n+1}.",
                                    "Discuta por que BDF2 é A-estável para problemas stiff."
                                  ],
                                  "verification": "Escreva corretamente a fórmula BDF2 em um papel ou editor e compare com referência padrão.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e caneta ou Jupyter Notebook para anotações"
                                  ],
                                  "tips": "Lembre-se que BDF2 requer dois passos iniciais; use Euler ou outro método para y1.",
                                  "learningObjective": "Entender a base teórica do método BDF2 e sua adequação para EDOs stiff.",
                                  "commonMistakes": [
                                    "Confundir com fórmulas forward",
                                    "Esquecer o fator h no lado direito",
                                    "Ignorar a necessidade de y_{n-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Problema Modelo Stiff",
                                  "subSteps": [
                                    "Defina o problema: y' = -λ y, y(0) = 1, com λ = 1000 (grande para stiff).",
                                    "Calcule solução exata: y(t) = exp(-λ t).",
                                    "Escolha parâmetros: intervalo [0, 1], passo h = 0.01, N = 100 passos.",
                                    "Inicialize y0 = 1; compute y1 usando método explícito como Euler Forward para startup.",
                                    "Prepare arrays para armazenar solução numérica: t, y_num."
                                  ],
                                  "verification": "Verifique se y1 está próximo da exata e λ >> 1/h para testar stiffnes.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para solução exata inicial",
                                    "Editor de código"
                                  ],
                                  "tips": "Use λ = 1000 e h=0.01 para que 1/h = 100 << λ, garantindo stiff.",
                                  "learningObjective": "Configurar um problema stiff clássico para testar estabilidade de BDF2.",
                                  "commonMistakes": [
                                    "Escolher λ pequeno, perdendo o caráter stiff",
                                    "Erro no y1 inicial levando a propagação de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Resolver o Sistema Implícito",
                                  "subSteps": [
                                    "Reescreva BDF2 para o modelo: (3/2) y_{n+1} + λ h y_{n+1} = 2 y_n - (1/2) y_{n-1}.",
                                    "Defina g(y) = (2 y_n - 0.5 y_{n-1} - 1.5 y) / (λ h) para fixed-point: y_{n+1} = g(y_{n+1}).",
                                    "Implemente iteração de ponto fixo: y^k_{n+1} = g(y^{k-1}_{n+1}), até |y^k - y^{k-1}| < tol (tol=1e-6).",
                                    "Alternativa: Método de Newton simples para generalidade: y^{k+1} = y^k - g(y^k)/g'(y^k).",
                                    "Defina critério de parada: max 20 iterações ou convergência."
                                  ],
                                  "verification": "Teste manual para n=1: converge em <10 iterações para parâmetros dados.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Pseudocódigo em papel",
                                    "Biblioteca NumPy para protótipo rápido"
                                  ],
                                  "tips": "Para este linear, fixed-point converge se |1/(1 + 1.5 λ h)| <1, o que é verdadeiro para BDF2.",
                                  "learningObjective": "Dominar resolução de sistemas implícitos lineares via iterações.",
                                  "commonMistakes": [
                                    "Esquecer normalização por h λ",
                                    "Não checar convergência causando loop infinito",
                                    "Usar método explícito por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar em Pseudocódigo ou Código Simples",
                                  "subSteps": [
                                    "Escreva pseudocódigo: loop principal de n=1 a N, compute y_{n+1} via fixed-point.",
                                    "Inclua computação de y1 com Euler: y1 = y0 + h f(t1, y0).",
                                    "Armazene soluções em arrays t[] e y[].",
                                    "Adicione plot: compare y_num vs y_exata = exp(-λ t).",
                                    "Implemente em Python simples sem bibliotecas avançadas (use loops)."
                                  ],
                                  "verification": "Execute código: solução deve decair suavemente sem oscilações.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python ou MATLAB",
                                    "Bibliotecas: numpy, matplotlib para plot"
                                  ],
                                  "tips": "Copie código em Jupyter para debug passo a passo.",
                                  "learningObjective": "Traduzir teoria em implementação numérica funcional.",
                                  "commonMistakes": [
                                    "Índice errado em arrays (off-by-one)",
                                    "Não inicializar y1 corretamente",
                                    "Esquecer salvar y_{n-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Validar e Analisar Resultados",
                                  "subSteps": [
                                    "Compute erro global: max |y_num - y_exata|.",
                                    "Teste estabilidade: aumente λ para 10000, verifique sem blow-up.",
                                    "Plote y vs t para num e exata; verifique ordem 2 (erro O(h^2)).",
                                    "Varie h (0.01, 0.005) e confirme redução de erro ~4x.",
                                    "Documente tempo de CPU vs método explícito (RK4 falha em stiff)."
                                  ],
                                  "verification": "Erro <1e-3 e estável para λ h >>1.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Código do passo anterior",
                                    "Gráficos para visualização"
                                  ],
                                  "tips": "Use logscale no plot para ver decaimento rápido.",
                                  "learningObjective": "Avaliar performance de BDF2 em contexto stiff.",
                                  "commonMistakes": [
                                    "Comparar com solução errada",
                                    "Ignorar overhead de iterações implícitas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente BDF2 via fixed-point iteration para y' = -1000 y, y(0)=1, t em [0,4], h=0.02. Inicialize y1 com Euler. Espere ~5 iterações por passo, erro final <1e-4 vs exata exp(-1000t), estável enquanto RK4 explode.",
                              "finalVerifications": [
                                "Fórmula BDF2 implementada corretamente sem erros algébricos.",
                                "Iterações convergem em <10 passos para cada estágio.",
                                "Solução numérica segue decaimento exponencial sem oscilações.",
                                "Erro máximo <1e-3 comparado à solução exata.",
                                "Código executa em <1s para N=200 passos.",
                                "Estável para λ=10000 e h=0.02 (λh=200)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Ordem de convergência ~2 ao halvar h.",
                                "Estabilidade: Sem blow-up para λh >>1.",
                                "Eficiência: Iterações por passo <10 em média.",
                                "Correção: Fórmula e resolução implícita exatas.",
                                "Robustez: Funciona para diferentes λ stiff.",
                                "Clareza: Código comentado e legível."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Loops, arrays e iterações numéricas.",
                                "Física/Engenharia: Modelos stiff em dinâmica de fluidos e circuitos.",
                                "Otimização: Métodos iterativos como base para solvers não-lineares.",
                                "Estatística: Análise de erro e validação numérica."
                              ],
                              "realWorldApplication": "BDF2 é essencial em simuladores como COMSOL ou ODEPACK para reações químicas stiff (ex: combustão), dinâmica molecular, e controle de sistemas elétricos onde escalas rápidas/lentas demandam métodos L-estáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1",
                              "10.1.5.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Analisar ordem de consistência das BDF",
                            "description": "Demonstrar a ordem de truncamento local das fórmulas BDFk, calculando o erro de truncamento e verificando consistência usando expansão em série de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula geral BDFk e conceitos básicos",
                                  "subSteps": [
                                    "Estude a fórmula BDFk: ∑_{j=0}^k α_j y_{n+j} = h β_k f(t_{n+k}, y_{n+k}).",
                                    "Identifique os coeficientes α_j e β_k para k=1 a 4 (ex: BDF1 é método backward Euler).",
                                    "Lembre a definição de truncamento local τ_{n+1} = (1/h) [∑ α_j y(t_{n+j}) - h β_k y'(t_{n+k})].",
                                    "Revise expansão em série de Taylor para y(t) ao redor de t_n: y(t_n + mh) = ∑ (mh)^l / l! y^{(l)}(t_n).",
                                    "Anote as condições de consistência: lim_{h→0} τ = 0 e ordem p ≥1."
                                  ],
                                  "verification": "Liste corretamente os coeficientes α_j, β_k para BDF1-BDF3 e escreva a fórmula de τ_{n+1}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e caneta, tabela de coeficientes BDF.",
                                  "tips": "Use tabelas padrão de coeficientes BDF para evitar cálculos iniciais errados.",
                                  "learningObjective": "Compreender a estrutura algébrica das BDFk e preparar para análise de erro.",
                                  "commonMistakes": "Confundir índices (j=0 para y_{n+k}) ou normalizar incorretamente os coeficientes (∑ α_j =0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir y(t_{n+j}) em série de Taylor",
                                  "subSteps": [
                                    "Fixe ponto base t_n; expanda y(t_{n+j}) = ∑_{l=0}^∞ (jh)^l / l! y^{(l)}(t_n) para j=0..k.",
                                    "Compute a soma S(y) = ∑_{j=0}^k α_j y(t_{n+j}).",
                                    "Substitua as expansões: S(y) = ∑_{j=0}^k α_j ∑_{l=0}^∞ (jh)^l / l! y^{(l)}(t_n).",
                                    "Intercale somas: S(y) = ∑_{l=0}^∞ [h^l / l! ∑_{j=0}^k α_j j^l ] y^{(l)}(t_n).",
                                    "Defina γ_l = ∑_{j=0}^k α_j j^l para cada l."
                                  ],
                                  "verification": "Derive explicitamente γ_0=0, γ_1=k e γ_l para l=2,3 em BDF2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (Mathematica/MATLAB) ou papel para somas.",
                                  "tips": "Comece com k pequeno (BDF1) para validar: γ_0=0, γ_1=1.",
                                  "learningObjective": "Dominar a expansão de Taylor multivariada para análise de consistência.",
                                  "commonMistakes": "Esquecer fator 1/l! ou errar potência j^l (use j^l não (j h)^l prematuramente)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o erro de truncamento local τ_{n+1}",
                                  "subSteps": [
                                    "Expanda h β_k y'(t_{n+k}) = h β_k ∑_{l=1}^∞ (k h)^{l-1} / (l-1)! y^{(l)}(t_n).",
                                    "Simplifique: h β_k y'(t_{n+k}) = β_k ∑_{l=1}^∞ k^{l-1} h^l / (l-1)! y^{(l)}(t_n).",
                                    "Compute τ_{n+1} = (1/h) [S(y) - h β_k y'(t_{n+k}) ] = ∑_{l=1}^∞ c_l h^{l-1} y^{(l)}(t_n), onde c_l = γ_l / l! - β_k k^{l-1} / (l-1)! δ_{l≥1}.",
                                    "Verifique que c_1 =0 (consistência ordem 1) e ordem p tal que c_2=...=c_p=0.",
                                    "Calcule para BDFk: ordem de truncamento é k."
                                  ],
                                  "verification": "Mostre τ_{n+1} = O(h^k) para BDFk, com coeficientes explícitos para k=2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software para simplificação simbólica, notas anteriores.",
                                  "tips": "Normalize dividindo por α_k ≠0; teste numericamente γ_l para pequenos k.",
                                  "learningObjective": "Derivar analiticamente o erro de truncamento e sua ordem.",
                                  "commonMistakes": "Índices errados em y^{(l)} ou confundir (l-1)! com l! no termo de y'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência e analisar estabilidade básica",
                                  "subSteps": [
                                    "Confirme lim_{h→0} τ_{n+1}=0 para todos k (consistência).",
                                    "Calcule ordem exata: p=k para BDFk até k=6.",
                                    "Compare com métodos explícitos (ex: Runge-Kutta ordem 4).",
                                    "Discuta implicações para problemas stiff: alta ordem requer solve implícito.",
                                    "Teste numérico simples: implemente BDF1 vs exata em y'= -100y."
                                  ],
                                  "verification": "Escreva prova que γ_l = l β_k k^{l-1} para l=1..k, implicando c_l=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB para teste numérico, referências teóricas.",
                                  "tips": "Use propriedades geradoras de coeficientes BDF para generalizar.",
                                  "learningObjective": "Validar consistência teórica e prática das BDF.",
                                  "commonMistakes": "Ignorar que ordem máxima é 6 para A-stabilidade em BDF."
                                }
                              ],
                              "practicalExample": "Para BDF2 (k=2, α0=4/3, α1=-1, α2=-1/3, β2=2/3): expanda y(t_n), y(t_{n+1}), y(t_{n+2}); compute γ1=2, γ2=4; τ=O(h^2) com y''' coeficiente explícito. Teste em y'=-50y, h=0.01.",
                              "finalVerifications": [
                                "Coeficientes BDFk corretos e normalizados.",
                                "Expansões Taylor intercaladas corretamente (γ_l computados até l=k+1).",
                                "τ_{n+1} = O(h^k) demonstrado analiticamente.",
                                "Teste numérico confirma ordem k (erro ~ h^k).",
                                "Condições de consistência (γ1=k β_k k^0) verificadas.",
                                "Diferenças com métodos explícitos destacadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de γ_l e c_l (90% correto).",
                                "Número e detalhe das subexpansões Taylor (pelo menos até ordem k+1).",
                                "Correta identificação da ordem de truncamento p=k.",
                                "Inclusão de verificação numérica prática.",
                                "Clareza na explicação de consistência zero-order e first-order.",
                                "Ausência de erros algébricos em somas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDOs stiff em circuitos RLC ou reações químicas.",
                                "Computação: Implementação em solvers como CVODE (SUNDIALS).",
                                "Engenharia: Simulações dinâmicas em controle de processos industriais.",
                                "Estatística: Análise de erros em métodos Monte Carlo para stiff systems."
                              ],
                              "realWorldApplication": "Em simulações de combustão em motores (EDOs stiff), BDFk ordem alta permite passos h maiores sem perda de estabilidade, otimizando tempo computacional em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Estabilidade em Problemas Stiff",
                        "description": "Propriedades de estabilidade dos métodos implícitos, com ênfase em estabilidade A-L (Absolute Linear) para problemas stiff caracterizados por escalas temporais díspares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Definir problemas stiff e estabilidade A-L",
                            "description": "Definir problemas stiff usando o exemplo de equações lineares y' = λy com Re(λ)<0 e |λ|h >>1, e explicar a região de estabilidade A-L estável que inclui o semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Diferenciais Lineares Escalares",
                                  "subSteps": [
                                    "Estude a equação modelo y' = λy, onde λ é um complexo com Re(λ) < 0.",
                                    "Derive a solução exata: y(t) = y(0) * exp(λ t), que decai exponencialmente.",
                                    "Discuta o comportamento: para |λ| grande, decaimento rápido (componente 'rápido').",
                                    "Compare com componentes lentos onde |λ| é pequeno.",
                                    "Identifique por que isso modela sistemas com escalas múltiplas."
                                  ],
                                  "verification": "Escreva a solução exata e descreva o decaimento para λ = -100 vs λ = -1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), calculadora ou Python para plotar exp(λt).",
                                  "tips": "Visualize graficamente o decaimento para entender a rigidez intuitivamente.",
                                  "learningObjective": "Compreender a dinâmica da EDO linear escalar como base para stiff problems.",
                                  "commonMistakes": "Confundir Re(λ) < 0 com estabilidade numérica; sempre verificar parte real negativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Problemas Stiff",
                                  "subSteps": [
                                    "Defina problema stiff: EDOs com escalas de tempo muito diferentes, exigindo h << 1/|λ_max| para estabilidade.",
                                    "Use o exemplo: y' = λy com Re(λ) < 0 e |λ|h >> 1, onde h é o passo de tempo.",
                                    "Explique que métodos explícitos (ex: Euler forward) requerem h < 2/|λ| para estabilidade.",
                                    "Simule numericamente: aplique Euler explícito com h grande e observe oscilações ou divergência.",
                                    "Contraste com solução exata estável."
                                  ],
                                  "verification": "Implemente Euler explícito em Python/MATLAB e mostre instabilidade para |λ|h > 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB, código template para Euler method.",
                                  "tips": "Comece com λ = -100, h=0.01 (estável) vs h=0.1 (instável) para ver o efeito.",
                                  "learningObjective": "Identificar stiffness pela necessidade de h muito pequeno apesar de solução suave.",
                                  "commonMistakes": "Achar que stiff significa não-linear; foque no exemplo linear primeiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Estabilidade Numérica e Região de Estabilidade",
                                  "subSteps": [
                                    "Defina estabilidade numérica: solução numérica imita qualitativamente a exata no semiplano Re(λ)<0.",
                                    "Introduza o teste: aplicar método a y' = λy, analisar amplificação |R(z)| ≤1 onde z=λh.",
                                    "Descreva região de estabilidade S = {z ∈ ℂ : |R(z)| ≤1 }.",
                                    "Para Euler explícito: S é disco |z|≤2; pequeno para Re(z)<0.",
                                    "Compare com métodos implícitos: backward Euler tem S = semiplano esquerdo."
                                  ],
                                  "verification": "Plote a região de estabilidade para Euler forward e backward usando código.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software como MATLAB (odeplot) ou Python (contourf para |R(z)|), notas de aula.",
                                  "tips": "Use z = hλ, fixe h=1 e varie λ para ver z no plano complexo.",
                                  "learningObjective": "Mapear o problema stiff para restrições na região de estabilidade.",
                                  "commonMistakes": "Confundir estabilidade absoluta (A-stability) com estabilidade relativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Estabilidade A-L Estável",
                                  "subSteps": [
                                    "Defina A-estabilidade: região S contém todo semiplano esquerdo {z : Re(z)<0}.",
                                    "Introduza L-estabilidade: A-estável + |R(z)| →0 quando |z|→∞ no semiplano esquerdo.",
                                    "Explique A-L: combinação para métodos ideais em stiff problems (ex: trapezoidal, BDF).",
                                    "Verifique para backward Euler: R(z) = 1/(1-z), satisfaz A e L.",
                                    "Discuta implicações: permite h grande sem perda de estabilidade."
                                  ],
                                  "verification": "Prove que backward Euler é A-L estável calculando |R(z)| para Re(z)<0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel e lápis para derivações, software para verificar |R(z)| numericamente.",
                                  "tips": "Lembre: semiplano esquerdo garante damping de modos rápidos sem h restrito.",
                                  "learningObjective": "Explicar por que métodos A-L são essenciais para stiff ODEs.",
                                  "commonMistakes": "Pensar que todo método implícito é A-estável; nem DIRK são."
                                }
                              ],
                              "practicalExample": "Simule y' = -100y + sin(t), y(0)=1 com Euler explícito (h=0.01: ok; h=0.05: oscila) vs backward Euler (h=0.1: estável e precisa), plotando vs exata aproximada.",
                              "finalVerifications": [
                                "Defina corretamente problema stiff com o exemplo y'=λy, |λ|h>>1.",
                                "Descreva região de estabilidade explícita vs implícita.",
                                "Explique A-estabilidade como inclusão do semiplano esquerdo.",
                                "Diferencie A-estabilidade de L-estabilidade com exemplo.",
                                "Simule um caso stiff mostrando falha explícita e sucesso A-L.",
                                "Prove estabilidade para backward Euler."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiffness (exemplo correto usado).",
                                "Compreensão da restrição |λ|h >>1 para explícitos.",
                                "Descrição correta da região A-L estável (semiplano esquerdo).",
                                "Uso apropriado de R(z) na análise de estabilidade.",
                                "Exemplo prático simulado sem erros de implementação.",
                                "Explicação clara de implicações para métodos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de reações químicas rígidas (cinética rápida/lenta).",
                                "Engenharia: Simulação de circuitos RLC com parasitas stiff.",
                                "Computação: Implementação eficiente de solvers ODE em SciPy/ODEPACK.",
                                "Química: Equações de Lotka-Volterra stiff em ecologia.",
                                "Estatística: Inferência em modelos diferenciais stiff."
                              ],
                              "realWorldApplication": "Em simulações de circuitos integrados (SPICE), problemas stiff surgem de capacitores/parasitas; métodos A-L como TRAP ou GEAR permitem passos maiores, acelerando simulações de chips sem perda de precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Construir diagrama de estabilidade para BDF",
                            "description": "Calcular e plotar a região de estabilidade absoluta para Backward Euler e BDF2 no plano complexo z = hλ, demonstrando por que são adequados para stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmulas de BDF1 (Backward Euler) e BDF2",
                                  "subSteps": [
                                    "Escrever a fórmula geral do Backward Euler: y_{n+1} = y_n + h f(y_{n+1}).",
                                    "Escrever a fórmula do BDF2: y_{n+1} = (4/3)y_n - (1/3)y_{n-1} + (2/3)h f(y_{n+1}).",
                                    "Linearizar para o teste de estabilidade: considerar y' = λy, com z = hλ.",
                                    "Derivar o polinômio de amplificação ρ(z) e σ(z) para cada método.",
                                    "Verificar linearização: R(z) = ρ(z)/σ(z) para |R(z)| ≤ 1."
                                  ],
                                  "verification": "Fórmulas escritas corretamente e polinômios ρ(z), σ(z) derivados sem erros algébricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, caneta, livro de análise numérica ou notas de aula sobre métodos BDF.",
                                  "tips": "Use notação padrão: subscritos n para passos temporais.",
                                  "learningObjective": "Compreender as diferenças algébricas entre BDF1 e BDF2 para análise de estabilidade.",
                                  "commonMistakes": "Confundir BDF1 com Forward Euler; esquecer o termo implícito em f(y_{n+1})."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as regiões de estabilidade absoluta",
                                  "subSteps": [
                                    "Para BDF1: resolver |1/(1 - z)| ≤ 1, identificando o disco externo no semiplano esquerdo.",
                                    "Para BDF2: resolver |(4/3 - z/3)/(1 - (4/3)z + (1/3)z^2)| ≤ 1 numericamente ou analiticamente.",
                                    "Delimitar fronteiras: encontrar curvas onde |R(z)| = 1 no plano complexo z.",
                                    "Testar pontos no eixo real negativo: confirmar estabilidade A(α)-estável para α=90°.",
                                    "Comparar tamanhos das regiões: BDF2 tem região maior que BDF1."
                                  ],
                                  "verification": "Equações |R(z)| ≤ 1 resolvidas; fronteiras descritas corretamente (ex: BDF1 cobre todo semiplano esquerdo).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, software simbólico como Mathematica ou SymPy (Python).",
                                  "tips": "Parametrize z = x + iy e resolva |R(x+iy)| = 1 para y em função de x.",
                                  "learningObjective": "Calcular matematicamente as condições de estabilidade no plano z = hλ.",
                                  "commonMistakes": "Erro em simplificação algébrica de R(z); ignorar parte imaginária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar plotagem do diagrama de estabilidade",
                                  "subSteps": [
                                    "Configurar grade no plano complexo: Re(z) de -10 a 0, Im(z) de -5 a 5.",
                                    "Escrever código para avaliar |R(z)| em pontos da grade (Python com NumPy/Matplotlib ou MATLAB).",
                                    "Plotar regiões: preencher onde |R(z)| ≤ 1 com cor (ex: azul para estável).",
                                    "Adicionar curvas de fronteira |R(z)|=1 e eixo real negativo.",
                                    "Plotar ambos BDF1 e BDF2 no mesmo gráfico para comparação."
                                  ],
                                  "verification": "Gráficos gerados mostrando regiões corretas; BDF1 como disco, BDF2 mais ampla.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy, Matplotlib), Jupyter Notebook ou MATLAB.",
                                  "tips": "Use meshgrid para grade; contourf para regiões preenchidas.",
                                  "learningObjective": "Visualizar numericamente regiões de estabilidade usando programação.",
                                  "commonMistakes": "Escala inadequada no eixo real negativo; plotar |R(z)| >1 como estável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar adequação para problemas stiff",
                                  "subSteps": [
                                    "Explicar stiff: autovalores λ com Re(λ) << 0 e |Im(λ)| grande.",
                                    "Mostrar que regiões BDF cobrem eixo negativo longo (h|λ| grande).",
                                    "Comparar com métodos explícitos (ex: RK4, região pequena).",
                                    "Discutir A-estabilidade: BDF1 é A-estável, BDF2 A(α)-estável com α≈90°.",
                                    "Concluir: implícitos como BDF toleram h grande sem oscilações."
                                  ],
                                  "verification": "Análise escrita justificando uso em stiff; gráficos referenciados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos gerados, papel para anotações.",
                                  "tips": "Inclua legenda e labels claros nos plots para análise.",
                                  "learningObjective": "Interpretar diagramas quanto à robustez em problemas stiff.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; ignorar custo computacional implícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o diagrama",
                                  "subSteps": [
                                    "Testar numérico: aplicar BDF1/BDF2 a y' = -100y, h=0.1, verificar sem oscilações.",
                                    "Comparar plots com referências bibliográficas (ex: Hairer livro).",
                                    "Ajustar resolução da grade se necessário para precisão.",
                                    "Documentar código e resultados em relatório curto.",
                                    "Identificar limitações: BDF2 oscila para ordem alta."
                                  ],
                                  "verification": "Simulação numérica converge; plots coincidem com literatura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código de Step 3, solver numérico (SciPy odeint ou custom).",
                                  "tips": "Use h grande para stiff para demonstrar vantagem.",
                                  "learningObjective": "Validar teoria com experimentos numéricos.",
                                  "commonMistakes": "Não linearizar corretamente no teste numérico."
                                }
                              ],
                              "practicalExample": "Para y' = -50y + sin(t), com y(0)=1 (stiff devido a λ=-50), plote regiões BDF e simule com h=0.2: BDF1/BDF2 permanecem estáveis, enquanto Runge-Kutta4 oscila.",
                              "finalVerifications": [
                                "Região de BDF1 é o exterior do círculo |z+1|=1 no semiplano esquerdo.",
                                "Região BDF2 inclui eixo real negativo até ≈-3.5 e mais amplo imaginário.",
                                "Plots gerados corretamente com |R(z)|≤1 destacado.",
                                "Análise escrita explica cobertura de espectro stiff.",
                                "Simulação numérica confirma ausência de instabilidade.",
                                "Comparação com método explícito mostra superioridade."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de R(z) (sem erros >5%).",
                                "Qualidade visual dos plots: resolução fina, legendas claras.",
                                "Profundidade da análise para stiff: menção a A-estabilidade.",
                                "Correção na implementação numérica e validação.",
                                "Documentação completa: código comentado e relatório.",
                                "Criatividade em exemplo prático e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de EDPs stiff em fluidos.",
                                "Engenharia Química: reatores com cinéticas stiff.",
                                "Ciência da Computação: otimização de solvers numéricos.",
                                "Matemática Aplicada: análise de autovalores em sistemas lineares."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC stiff ou modelos climáticos com escalas múltiplas, BDF permite passos h grandes sem perda de estabilidade, reduzindo tempo computacional em software como COMSOL ou FEniCS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1",
                              "10.1.5.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Comparar estabilidade de métodos para stiff",
                            "description": "Comparar a estabilidade de métodos explícitos (ex: RK4) versus implícitos (BDF) em problemas stiff, quantificando o passo h máximo permitido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender problemas stiff e conceitos de estabilidade",
                                  "subSteps": [
                                    "Defina problemas stiff: EDOs com eigenvalues de magnitudes muito diferentes.",
                                    "Explique o conceito de estabilidade A-estável e L-estável.",
                                    "Discuta por que passos h pequenos são necessários em métodos explícitos.",
                                    "Revise a região de estabilidade no plano complexo hλ.",
                                    "Identifique exemplos clássicos de problemas stiff, como reações químicas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre stiff e não-stiff, com diagrama da região de estabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Software MATLAB ou Python (SciPy)",
                                    "Notas de aula sobre EDOs"
                                  ],
                                  "tips": "Use o teste de Dahlquist para classificar stiff problems.",
                                  "learningObjective": "Compreender as causas e impactos da rigidez em EDOs.",
                                  "commonMistakes": [
                                    "Confundir estabilidade numérica com convergência",
                                    "Ignorar o papel dos eigenvalues reais negativos grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar estabilidade de métodos explícitos (ex: RK4)",
                                  "subSteps": [
                                    "Derive ou revise a região de estabilidade do RK4.",
                                    "Calcule h_max para um problema modelo y' = λy com Re(λ) < 0 e |λ| grande.",
                                    "Implemente RK4 em código para um problema stiff simples.",
                                    "Observe oscilações ou instabilidade para h > h_max.",
                                    "Plote a solução numérica vs exata."
                                  ],
                                  "verification": "Gere gráfico mostrando instabilidade para h = 0.01 em λ = -1000.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "Código template para RK4",
                                    "Tabela de regiões de estabilidade"
                                  ],
                                  "tips": "Comece com λ pequeno e aumente gradualmente para visualizar o limite.",
                                  "learningObjective": "Quantificar limitações de passos h em métodos explícitos para stiff.",
                                  "commonMistakes": [
                                    "Usar h fixo sem testar limites",
                                    "Não normalizar pelo Lipschitz constante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar estabilidade de métodos implícitos (ex: BDF)",
                                  "subSteps": [
                                    "Descreva o método BDF1 (Backward Euler) e BDF2.",
                                    "Derive a região de estabilidade A-estável do BDF.",
                                    "Resolva o mesmo problema stiff com BDF via solve linear.",
                                    "Calcule h_max efetivo (muito maior que explícito).",
                                    "Compare precisão e custo computacional."
                                  ],
                                  "verification": "Implemente BDF e mostre solução estável para h 10x maior que RK4.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python SciPy solve_ivp com method='BDF'",
                                    "Documentação SciPy ODE solvers",
                                    "Papel e lápis para derivação"
                                  ],
                                  "tips": "Use fsolve ou linear solver para equações implícitas.",
                                  "learningObjective": "Demonstrar superioridade de estabilidade em métodos implícitos.",
                                  "commonMistakes": [
                                    "Esquecer iterações de Newton para BDF de ordem >1",
                                    "Comparar sem normalizar erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar quantitativamente e visualizar diferenças",
                                  "subSteps": [
                                    "Escolha problema stiff: y' = -1000(y - sin(t)) , y(0)=1.",
                                    "Compute h_max para RK4 e BDF via análise ou experimento.",
                                    "Gere tabelas: h, tempo CPU, erro L2 para ambos métodos.",
                                    "Plote regiões de estabilidade e trajetórias de hλ.",
                                    "Conclua com recomendação baseada em rigidez."
                                  ],
                                  "verification": "Tabela comparativa com h_max RK4 ≈0.002, BDF ≈0.1 e gráficos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python integrado",
                                    "Ferramenta de plotagem (Matplotlib)",
                                    "Referência: Hairer 'Solving ODEs II'"
                                  ],
                                  "tips": "Automatize varredura de h com loop para eficiência.",
                                  "learningObjective": "Quantificar vantagem de implícitos via h_max e eficiência.",
                                  "commonMistakes": [
                                    "Não considerar custo por passo dos implícitos",
                                    "Usar problema não-stiff para comparação"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000(y - sin(t)), y(0)=1 no intervalo [0,1]. Com RK4, h_max≈0.002 para estabilidade; com BDF2, h_max≈0.1 permite solução precisa e eficiente.",
                              "finalVerifications": [
                                "Calcule corretamente h_max para RK4 em λ=-1000.",
                                "Implemente BDF estável para h=0.05 no exemplo stiff.",
                                "Gere gráfico comparativo de soluções sem instabilidade.",
                                "Explique verbalmente A-estabilidade vs região finita.",
                                "Tabela de erros mostra BDF com h maior e erro similar.",
                                "Identifique quando usar explícito vs implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de regiões de estabilidade (80%).",
                                "Correção numérica: h_max quantificado com erro <10% (90%).",
                                "Visualizações claras e legendadas (100%).",
                                "Análise qualitativa e quantitativa equilibrada.",
                                "Recomendação contextualizada para problemas stiff.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de circuitos RC stiff em eletrônica.",
                                "Química: Cinemática de reações rápidas/lentas.",
                                "Computação: Otimização de solvers em bibliotecas como SciPy.",
                                "Engenharia: Modelos dinâmicos em controle de sistemas."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos (rigidez por escalas de reação), métodos implícitos como BDF permitem passos maiores, reduzindo tempo de computação em 100x para previsões industriais precisas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Aplicar BDF em problema stiff real",
                            "description": "Resolver numericamente um problema stiff clássico, como o modelo químico de Van der Pol com parâmetro μ grande, usando BDF e analisando eficiência computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema stiff de Van der Pol",
                                  "subSteps": [
                                    "Reescrever as equações diferenciais de Van der Pol em forma de primeira ordem: definir y1 = y, y2 = y', resultando em y1' = y2, y2' = μ(1 - y1²)y2 - y1.",
                                    "Explicar por que o problema é stiff para μ grande (ex.: μ = 1000), destacando escalas temporais múltiplas e rigidez.",
                                    "Definir condições iniciais: y(0) = 2, y'(0) = 0.",
                                    "Estabelecer o intervalo de integração: t de 0 a 20.",
                                    "Verificar a solução analítica aproximada ou referências para o ciclo limite esperado."
                                  ],
                                  "verification": "Confirme que as equações estão corretas e μ é suficientemente grande para stiff (escalas de tempo < 1/μ e ~1).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação sobre equações de Van der Pol",
                                    "Software de plotagem (Python/MATLAB)",
                                    "Referências de análise numérica (ex.: Hairer et al.)"
                                  ],
                                  "tips": "Comece com μ pequeno para visualizar o comportamento não-stiff antes de aumentar.",
                                  "learningObjective": "Compreender a estrutura e rigidez do problema Van der Pol.",
                                  "commonMistakes": [
                                    "Confundir ordem das equações",
                                    "Escolher μ muito pequeno, perdendo o caráter stiff",
                                    "Ignorar condições iniciais padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método BDF de ordem 2",
                                  "subSteps": [
                                    "Derivar a fórmula BDF2: yi+1 - (4/3)yi + (1/3)yi-1 = (2/3)h f(ti+1, yi+1).",
                                    "Reescrever em forma implícita para sistema: resolver J Δy = g(yi, h), onde J é a Jacobiana.",
                                    "Implementar solver implícito usando método de Newton (iterações até convergência ε=1e-6).",
                                    "Configurar tolerâncias adaptativas para passo h inicial pequeno (ex.: 0.01).",
                                    "Testar implementação com problema simples não-stiff para validar."
                                  ],
                                  "verification": "Execute um teste unitário com y' = -y; solução deve coincidir com exp(-t).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy (solve_ivp com method='BDF') ou código custom em MATLAB",
                                    "Notebook Jupyter",
                                    "Livro de métodos numéricos para fórmulas BDF"
                                  ],
                                  "tips": "Use Jacobiana analítica para aceleração; evite diferenciação numérica inicial.",
                                  "learningObjective": "Dominar a implementação numérica de BDF2 para ODEs implícitas.",
                                  "commonMistakes": [
                                    "Erro na fórmula BDF2 (coeficientes errados)",
                                    "Não convergir Newton (tolerância inadequada)",
                                    "Passo h fixo muito grande"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulação e visualizar resultados",
                                  "subSteps": [
                                    "Rodar o solver BDF no Van der Pol com μ=1000 até t=20.",
                                    "Plotar fase portrait (y vs y') e solução temporal y(t).",
                                    "Comparar visualmente com solução de referência (ex.: ciclo limite relaxado).",
                                    "Ajustar parâmetros se necessário (h min/max, ordens BDF 1-5).",
                                    "Salvar dados de passos dados, tempo CPU e erro estimado."
                                  ],
                                  "verification": "Plot mostra ciclo limite estável sem oscilações numéricas espúrias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib/Plotly para visualização",
                                    "SciPy integrate.solve_ivp",
                                    "Dados de referência de Van der Pol"
                                  ],
                                  "tips": "Use solve_ivp('BDF') no SciPy para protótipo rápido antes de custom.",
                                  "learningObjective": "Visualizar e validar soluções numéricas de problemas stiff.",
                                  "commonMistakes": [
                                    "Escala de eixos errada no plot",
                                    "Não plotar trajeto completo do ciclo",
                                    "Ignorar transients iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar eficiência computacional",
                                  "subSteps": [
                                    "Implementar comparativamente Runge-Kutta 4 (explícito) com h adaptativo.",
                                    "Medir tempo de CPU, número de passos e erro global (norma L2 vs referência).",
                                    "Calcular eficiência: custo por unidade de erro (ex.: log(tempo/erro)).",
                                    "Discutir A-stabilidade de BDF vs instabilidade explícita em stiff.",
                                    "Relatar conclusões em tabela: BDF vs RK4."
                                  ],
                                  "verification": "BDF usa menos passos e tempo menor que RK4 para mesma precisão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "timeit() em Python ou tic-toc em MATLAB",
                                    "Referência precisa (solução de alta ordem)",
                                    "Tabela LaTeX/Excel"
                                  ],
                                  "tips": "Fixe erro alvo (1e-3) e compare automaticamente.",
                                  "learningObjective": "Quantificar vantagens de métodos implícitos em problemas stiff.",
                                  "commonMistakes": [
                                    "Comparação injusta (h fixo)",
                                    "Erro medido sem referência",
                                    "Ignorar overhead de Jacobiana"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando SciPy: from scipy.integrate import solve_ivp; sol = solve_ivp(lambda t,y: [y[1], 1000*(1-y[0]**2)*y[1]-y[0]], [0,20], [2,0], method='BDF', rtol=1e-6); plot(sol.t, sol.y[0]). BDF converge rapidamente ao ciclo limite, enquanto 'RK45' falha ou é lento.",
                              "finalVerifications": [
                                "Solução BDF reproduz ciclo limite de Van der Pol com μ=1000.",
                                "Número de passos F evaluations < 1000 para erro <1e-3.",
                                "Tempo CPU < 1s em máquina padrão.",
                                "Fase portrait sem damping artificial ou explosão.",
                                "Eficiência BDF > RK4 em gráfico log-log.",
                                "Relatório inclui tabelas e plots legíveis."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da implementação BDF (fórmulas e Newton).",
                                "Precisão da solução (erro <1e-3 vs referência).",
                                "Análise quantitativa de eficiência (métricas claras).",
                                "Visualizações profissionais e interpretadas.",
                                "Código limpo, comentado e reproduzível.",
                                "Discussão de limitações (ex.: ordem máxima BDF)."
                              ],
                              "crossCurricularConnections": [
                                "Química: Cinética de reações oscilatórias (Belousov-Zhabotinsky).",
                                "Física: Osciladores não-lineares em eletrônica.",
                                "Computação: Otimização de solvers numéricos (SciPy/ODEPACK).",
                                "Engenharia: Simulação de circuitos RLC stiff."
                              ],
                              "realWorldApplication": "Simulação de reações químicas rápidas/lentas em farmacocinética ou combustão, onde BDF permite passos maiores em modelos stiff sem perda de estabilidade."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2",
                              "10.1.5.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Critérios de Estabilidade A e L",
                    "description": "Definição e importância da A-estabilidade e L-estabilidade para seleção de métodos numericamente estáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "A-estabilidade",
                        "description": "Definição formal da A-estabilidade como propriedade de métodos numéricos para EDOs onde a região de estabilidade absoluta inclui todo o semiplano complexo esquerdo (Re(z) ≤ 0), garantindo estabilidade incondicional para problemas com autovalores negativos reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Definir A-estabilidade",
                            "description": "Explicar a definição precisa de A-estabilidade usando a função de amplificação R(z) e demonstrar que |R(z)| ≤ 1 para todo z com Re(z) ≤ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Função de Amplificação R(z) em Métodos Numéricos para EDOs",
                                  "subSteps": [
                                    "Estude a solução exata de uma EDO linear teste y' = λy, onde λ é complexo.",
                                    "Derive a recursão numérica y_{n+1} = R(z) y_n, com z = hλ e h o passo de tempo.",
                                    "Analise o comportamento assintótico: se |R(z)| < 1, y_n → 0; se |R(z)| > 1, diverge.",
                                    "Pratique computando R(z) para métodos simples como Forward Euler (R(z) = 1 + z) e Backward Euler (R(z) = 1/(1 - z)).",
                                    "Desenhe graficamente |R(z)| para z no semiplano complexo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como R(z) determina a estabilidade e forneça exemplos para dois métodos.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis para derivações",
                                    "Software como MATLAB ou Python (SymPy para manipulação simbólica)"
                                  ],
                                  "tips": "Comece com o modelo teste linear; evite pular para EDOs não-lineares prematuramente.",
                                  "learningObjective": "Compreender o papel fundamental da função de amplificação na análise de estabilidade de métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir z = hλ com λ real apenas",
                                    "Ignorar que z é complexo",
                                    "Esquecer a dependência em h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Semiplano Esquerdo de Estabilidade (Re(z) ≤ 0)",
                                  "subSteps": [
                                    "Defina o semiplano esquerdo no plano complexo: {z ∈ ℂ | Re(z) ≤ 0}.",
                                    "Relacione com EDOs stiff: λ com partes reais negativas grandes em magnitude.",
                                    "Discuta por que a estabilidade absoluta requer |R(z)| ≤ 1 para todo h > 0, i.e., todo o semiplano.",
                                    "Plote o semiplano e regiões de estabilidade típicas de métodos explícitos (círculo unitário) vs. implícitos.",
                                    "Calcule Re(z) ≤ 0 para exemplos: z = -1 + i, z = -10, z = i."
                                  ],
                                  "verification": "Desenhe o semiplano e marque pontos de teste, confirmando Re(z) ≤ 0.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Plano complexo impresso ou software de plotagem (Desmos, GeoGebra)",
                                    "Notas de aula sobre stiff problems"
                                  ],
                                  "tips": "Visualize: semiplano esquerdo inclui eixo imaginário puro e metade esquerda.",
                                  "learningObjective": "Dominar a geometria do semiplano de estabilidade relevante para problemas stiff.",
                                  "commonMistakes": [
                                    "Confundir com |z| ≤ 1 (região de Forward Euler)",
                                    "Pensar que é apenas Re(λ) < 0 sem h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Definição Precisa de A-estabilidade",
                                  "subSteps": [
                                    "Enuncie: Um método é A-estável se |R(z)| ≤ 1 para todo z com Re(z) ≤ 0.",
                                    "Escreva formalmente: A ∈ {métodos numéricos} é A-estável ⇔ |R_A(z)| ≤ 1, ∀ z ∈ ℂ, Re(z) ≤ 0.",
                                    "Compare com estabilidade forte (S-stability): |R(z)| ≤ 1 e |dR/dz| ≤ 1 no semiplano.",
                                    "Discuta implicações: permite h livre de restrições para stiff systems.",
                                    "Memorize teorema de Dahquist: métodos explícitos de ordem >1 não são A-estáveis."
                                  ],
                                  "verification": "Escreva a definição em um papel e cite o teorema de Dahquist corretamente.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Referência: Hairer et al. 'Solving ODEs I'",
                                    "Flashcards para definições"
                                  ],
                                  "tips": "Use notação matemática precisa: |R(z)|_∞ ≤ 1 no semiplano esquerdo.",
                                  "learningObjective": "Articular a definição exata de A-estabilidade com precisão matemática.",
                                  "commonMistakes": [
                                    "Definir como região de estabilidade contendo o semiplano (correto, mas use R(z))",
                                    "Omitir 'para todo z'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a Propriedade |R(z)| ≤ 1 no Semiplano Esquerdo",
                                  "subSteps": [
                                    "Para Backward Euler: R(z) = 1/(1 - z), prove |R(z)| ≤ 1 quando Re(z) ≤ 0.",
                                    "Use desigualdade triangular ou mapeamento conforme: mostre que 1 - z está fora ou no círculo unitário.",
                                    "Verifique numericamente: compute |R(-1 + i)|, |R(-10)|, limite |z|→∞.",
                                    "Contraexemplo: Forward Euler R(z)=1+z, |R(-2)|=1, mas para z=-3+i√8 >1.",
                                    "Generalize para Trapezoidal Rule (A-estável) vs. métodos não-A-estáveis."
                                  ],
                                  "verification": "Forneça prova escrita para Backward Euler e compute 3 pontos numéricos.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para |R(z)|",
                                    "Papel para provas geométricas"
                                  ],
                                  "tips": "Use argumento complexo: arg(1 - z) para semiplano.",
                                  "learningObjective": "Demonstrar analítica e numericamente a condição de A-estabilidade.",
                                  "commonMistakes": [
                                    "Erro em cálculo de módulo complexo",
                                    "Confundir prova com plot"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -1000y + sin(t) (stiff), use Backward Euler: prove |R(z)| ≤ 1 para z = -1000h + i h (Re(z)<0), permitindo h=0.1 sem oscilações, enquanto Forward Euler diverge.",
                              "finalVerifications": [
                                "Defina A-estabilidade usando R(z) sem erros.",
                                "Identifique semiplano esquerdo corretamente em um diagrama.",
                                "Prove |R(z)| ≤ 1 para Backward Euler em 2 pontos z.",
                                "Cite teorema de Dahquist e dê contraexemplo explícito.",
                                "Explique por que A-estabilidade é crucial para stiff ODEs.",
                                "Compare região de estabilidade de Euler explícito vs. implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com R(z) e semiplano).",
                                "Correção matemática na demonstração/prova (sem erros algébricos).",
                                "Profundidade de substeps: pelo menos 80% completos com detalhes.",
                                "Uso correto de conceitos prévios (função de amplificação, stiff).",
                                "Criatividade em exemplos práticos e verificações.",
                                "Clareza na comunicação escrita/oral (sem ambiguidades)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica molecular (EDOs stiff).",
                                "Engenharia de Controle: Análise de sistemas lineares discretos.",
                                "Ciência da Computação: Otimização de solvers numéricos em SciPy/ODEPACK.",
                                "Química Computacional: Modelagem de reações stiff (ex: cinética enzimática)."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, onde EDOs stiff surgem de escalas temporais díspares, métodos A-estáveis como Backward Euler ou BDF permitem passos de tempo grandes sem instabilidade, acelerando computações em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Analisar região de estabilidade",
                            "description": "Construir e interpretar a região de estabilidade absoluta de métodos lineares multistep ou Runge-Kutta, verificando inclusão do semiplano esquerdo para A-estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Estabilidade em Métodos Numéricos para EDOs",
                                  "subSteps": [
                                    "Estude o teste de estabilidade para o método de Euler aplicado à equação teste y' = λy.",
                                    "Defina a região de estabilidade absoluta como o conjunto de z ∈ ℂ onde |R(z)| ≤ 1, com R(z) o polinômio de estabilidade.",
                                    "Identifique o semiplano esquerdo {z | Re(z) ≤ 0} e sua importância para problemas stiff.",
                                    "Revise diferenças entre estabilidade absoluta e relativa.",
                                    "Pratique com exemplos simples de métodos explícitos e implícitos."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe o semiplano esquerdo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre EDOs stiff",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Use diagramas no plano complexo para visualizar regiões; foque em λ com parte real negativa.",
                                  "learningObjective": "Compreender os conceitos fundamentais de região de estabilidade e A-estabilidade.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com condicional de Courant; ignorar o papel de problemas stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Região de Estabilidade para Métodos Runge-Kutta",
                                  "subSteps": [
                                    "Para um método RK de ordem s, escreva o polinômio de estabilidade R(z) usando coeficientes A e b.",
                                    "Calcule R(z) para métodos clássicos como RK2, RK4.",
                                    "Use software para plotar |R(z)| ≤ 1 no plano complexo (ex: contour plot).",
                                    "Teste pontos no semiplano esquerdo, como z = -1 + 0i, z = 0 - i.",
                                    "Compare regiões para métodos explícitos vs. implícitos."
                                  ],
                                  "verification": "Gere e salve um gráfico da região de estabilidade do RK4.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "MATLAB ou Octave",
                                    "Tabela de métodos RK padrão"
                                  ],
                                  "tips": "Implemente uma função para avaliar |R(z)| em uma grade de pontos complexos.",
                                  "learningObjective": "Construir graficamente a região de estabilidade para métodos RK.",
                                  "commonMistakes": [
                                    "Erros na derivação de R(z); plots com resolução baixa que distorcem a região."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Analisar Região para Métodos Lineares Multistep",
                                  "subSteps": [
                                    "Escreva os polinômios ρ(ζ) e σ(ζ) para métodos como Adams-Bashforth ou Trapezoidal.",
                                    "Derive R(z) = ρ(e^z)/σ(e^z) aproximando para multistep lineares.",
                                    "Plote a região |R(z)| ≤ 1 para métodos explícitos e implícitos.",
                                    "Identifique se a região inclui o semiplano esquerdo.",
                                    "Compare com métodos RK em termos de tamanho da região."
                                  ],
                                  "verification": "Crie gráficos comparativos para BDF2 e AB3, anotando inclusão do semiplano.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotting (Python/MATLAB)",
                                    "Referência: Hairer 'Solving ODEs' vol. I"
                                  ],
                                  "tips": "Comece com métodos de baixa ordem para validar cálculos analíticos.",
                                  "learningObjective": "Construir e comparar regiões de estabilidade para métodos multistep.",
                                  "commonMistakes": [
                                    "Aproximações incorretas em R(z); confundir ρ e σ."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Verificar A-Estabilidade",
                                  "subSteps": [
                                    "Defina formalmente A-estabilidade: região inclui todo semiplano esquerdo.",
                                    "Teste numericamente: para z com Re(z) ≤ 0 e |z| grande, verifique |R(z)| ≤ 1.",
                                    "Analise métodos conhecidos: RK4 não A-estável, Trapezoidal sim.",
                                    "Discuta implicações para problemas stiff (passos grandes permitidos).",
                                    "Resolva um EDO stiff usando método A-estável vs. não."
                                  ],
                                  "verification": "Classifique 3 métodos como A-estáveis ou não, com justificativa e gráfico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Solver numérico (SciPy odeint)",
                                    "Exemplos de EDOs stiff como y' = -1000y + sin(t)"
                                  ],
                                  "tips": "Use |z| → ∞ para métodos implícitos: R(z) → raiz de ρ/σ.",
                                  "learningObjective": "Verificar e interpretar A-estabilidade em contextos práticos.",
                                  "commonMistakes": [
                                    "Testar apenas pontos finitos; ignorar comportamento assintótico."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Trapezoidal (implícito RK2): R(z) = (1 + z/2)/(1 - z/2). Plote |R(z)| no plano complexo e confirme que inclui todo Re(z) ≤ 0 testando z = -10 + 5i, mostrando estabilidade para problemas stiff como reações químicas rápidas.",
                              "finalVerifications": [
                                "Construa corretamente R(z) para RK4 e BDF2.",
                                "Gere plots precisos das regiões de estabilidade.",
                                "Identifique corretamente métodos A-estáveis (ex: Trapezoidal sim, RK4 não).",
                                "Explique verbalmente por que A-estabilidade é crucial para stiff.",
                                "Resolva um EDO stiff com método A-estável sem oscilações.",
                                "Compare tamanhos de regiões entre explícito e implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de polinômios de estabilidade (90% correto).",
                                "Qualidade dos plots: resolução alta, legendas claras, semiplano destacado.",
                                "Correta classificação de A-estabilidade com evidências numéricas.",
                                "Análise qualitativa profunda das implicações para stiff problems.",
                                "Uso adequado de software sem erros de implementação.",
                                "Relatório claro com interpretações e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos stiff em dinâmica.",
                                "Engenharia Química: Modelagem de reatores com cinéticas rápidas.",
                                "Computação Científica: Otimização de solvers em bibliotecas como SciPy.",
                                "Matemática Aplicada: Análise de convergência em PDEs parabólicas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC com resistores altos (stiff), métodos A-estáveis como BDF permitem passos de tempo grandes sem instabilidade, acelerando simulações em software como SPICE para design de eletrônicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Identificar métodos A-estáveis",
                            "description": "Classificar métodos numéricos comuns (ex: Backward Euler, Trapezoidal) como A-estáveis ou não, com base em suas funções de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de A-estabilidade",
                                  "subSteps": [
                                    "Defina a região de estabilidade absoluta como o conjunto de hλ onde |R(hλ)| ≤ 1, com λ no semiplano complexo esquerdo.",
                                    "Explique que um método é A-estável se sua região de estabilidade absoluta contém todo o semiplano esquerdo (Re(z) ≤ 0).",
                                    "Discuta a importância para problemas stiff, onde eigenvalues têm partes reais negativas grandes.",
                                    "Estude o teste: verificar se |R(z)| ≤ 1 para todo z com Re(z) ≤ 0.",
                                    "Compare com estabilidade absoluta A(α)."
                                  ],
                                  "verification": "Escreva a definição de A-estabilidade e dê um exemplo de por que ela é crucial para ODEs stiff.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Notas de aula sobre estabilidade"
                                  ],
                                  "tips": "Desenhe o semiplano esquerdo no plano complexo para visualizar melhor.",
                                  "learningObjective": "Compreender conceitualmente o que torna um método A-estável e sua relevância para problemas stiff.",
                                  "commonMistakes": [
                                    "Confundir A-estabilidade com estabilidade incondicional para todos os z.",
                                    "Ignorar que A-estabilidade requer |R(z)| ≤ 1 estritamente no semiplano esquerdo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar funções de amplificação para métodos comuns",
                                  "subSteps": [
                                    "Para Backward Euler: resolva y_{n+1} = y_n + h f(y_{n+1}) para o teste do modelo y' = λy, obtendo R(z) = 1/(1 - z).",
                                    "Para Trapezoidal (ou Crank-Nicolson): derive R(z) = (1 + z/2)/(1 - z/2).",
                                    "Analise analiticamente |R(z)| para Backward Euler: mostre que |R(z)| < 1 para Re(z) < 0.",
                                    "Para Trapezoidal: verifique que |R(z)| ≤ 1 no semiplano esquerdo usando propriedades geométricas ou cálculo.",
                                    "Liste outros métodos: Forward Euler (não A-estável), Runge-Kutta 4 (não A-estável)."
                                  ],
                                  "verification": "Escreva explicitamente R(z) para Backward Euler e Trapezoidal e comprove |R(iy)| = 1 para y real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: Mathematica, SymPy)",
                                    "Folha de derivações",
                                    "Tabela de métodos numéricos"
                                  ],
                                  "tips": "Use z = x + iy e compute |R(z)|^2 = R(z) * conj(R(z)) para simplificar.",
                                  "learningObjective": "Calcular e interpretar funções de amplificação R(z) para métodos implícitos lineares.",
                                  "commonMistakes": [
                                    "Erro na derivação de R(z) para Backward Euler (lembre-se do termo implícito).",
                                    "Confundir Trapezoidal com método explícito."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar A-estabilidade graficamente e analiticamente",
                                  "subSteps": [
                                    "Plote a região de estabilidade |R(z)| ≤ 1 para Backward Euler: confirme que cobre o semiplano esquerdo.",
                                    "Para Trapezoidal: plote e observe que é o disco unitário mapeado, cobrindo o semiplano.",
                                    "Teste pontos críticos: z = -10 (grande negativo), z = -1 + 10i (imaginário grande).",
                                    "Compare com Forward Euler: mostre que sua região é um círculo pequeno no semiplano direito.",
                                    "Use teorema: método A-estável se R(z) analítica e |R(z)| ≤ 1 em Re(z) ≤ 0.",
                                    "Classifique: Backward Euler (sim), Trapezoidal (sim), Forward Euler (não)."
                                  ],
                                  "verification": "Crie um gráfico manual ou digital da região de estabilidade e rotule se A-estável.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python com Matplotlib)",
                                    "Papel quadriculado para esboço",
                                    "Referência de regiões de estabilidade"
                                  ],
                                  "tips": "Comece com z puramente imaginário (eixo jω) para ver oscilações.",
                                  "learningObjective": "Aplicar testes gráficos e analíticos para verificar A-estabilidade.",
                                  "commonMistakes": [
                                    "Plotar incorretamente o círculo de estabilidade para Euler forward.",
                                    "Esquecer de verificar o limite |z| → ∞."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação de métodos adicionais",
                                  "subSteps": [
                                    "Classifique Backward Differentiation Formula (BDF1 = Backward Euler: sim; BDF2: sim).",
                                    "Analise Runge-Kutta implícito de 2 estágios (SDIRK): confirme A-estável.",
                                    "Crie uma tabela: método, R(z), A-estável? (inclua Trapezoidal, Backward Euler, RK4).",
                                    "Resolva exercício: dado R(z), é A-estável? (ex: R(z) = 1/(1+z), sim).",
                                    "Discuta limitações: A-estabilidade não implica ordem alta.",
                                    "Teste com exemplo numérico simples de ODE stiff."
                                  ],
                                  "verification": "Preencha tabela com 5 métodos comuns e justifique cada classificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Lista de métodos numéricos de referência",
                                    "Solver numérico online para verificação"
                                  ],
                                  "tips": "Memorize: métodos implícitos de ordem 1-2 geralmente A-estáveis; explícitos não.",
                                  "learningObjective": "Classificar autonomamente métodos numéricos como A-estáveis baseados em R(z).",
                                  "commonMistakes": [
                                    "Classificar Trapezoidal como não A-estável por confundir com damping.",
                                    "Ignorar métodos multistep vs single-step."
                                  ]
                                }
                              ],
                              "practicalExample": "Classifique os métodos Backward Euler e Trapezoidal para o problema y' = -1000(y - sin(t)), y(0)=0 (stiff). Compute R(z) com z = hλ = -1000h, mostre |R(z)| <1 para h>0 arbitrário, confirmando A-estabilidade permite h grande sem instabilidade.",
                              "finalVerifications": [
                                "Corretamente derivar R(z) para Backward Euler e Trapezoidal.",
                                "Provar analiticamente |R(z)| ≤ 1 para Re(z) ≤ 0 em ambos os métodos.",
                                "Classificar 5 métodos comuns (ex: Forward Euler: não; BDF2: sim).",
                                "Plotar regiões de estabilidade e identificar cobertura do semiplano esquerdo.",
                                "Aplicar a um exemplo stiff e prever estabilidade.",
                                "Explicar por que A-estabilidade é vital para problemas stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de funções de amplificação (100% correto).",
                                "Correta identificação de A-estabilidade para métodos dados (sem erros).",
                                "Qualidade dos gráficos de regiões de estabilidade (clareza e precisão).",
                                "Profundidade na análise de exemplos práticos (conexão com stiff problems).",
                                "Compreensão conceitual demonstrada em verificações finais.",
                                "Identificação de erros comuns e dicas preventivas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais em mecânica (ex: amortecedores).",
                                "Engenharia Química: Modelagem de reações stiff em reatores.",
                                "Ciência da Computação: Algoritmos numéricos em bibliotecas como SciPy/ODEPACK.",
                                "Engenharia Elétrica: Análise de circuitos RLC com comportamentos stiff."
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff como reações químicas rápidas/lentas ou circuitos elétricos, métodos A-estáveis como Backward Euler permitem passos de tempo grandes, reduzindo custo computacional em software como COMSOL ou ANSYS, evitando instabilidade numérica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "L-estabilidade",
                        "description": "Definição da L-estabilidade como uma propriedade mais forte que a A-estabilidade, exigindo |R(z)| ≤ 1 para Re(z) ≤ 0 e lim_{z→-∞} R(z) = 0, essencial para amortecimento rápido de modos stiff em problemas com componentes transitórios rápidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Definir L-estabilidade",
                            "description": "Descrever a L-estabilidade como A-estabilidade com a condição adicional de damping em infinito negativo, ilustrando com exemplos como o método Backward Differentiation Formula (BDF).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de A-estabilidade",
                                  "subSteps": [
                                    "Recordar a definição formal de A-estabilidade: um método é A-estável se sua função de amplificação R(z) satisfaz |R(z)| ≤ 1 para todo z no semiplano esquerdo (Re(z) ≤ 0).",
                                    "Analisar a região de estabilidade absoluta no plano complexo.",
                                    "Discutir a importância para problemas stiff, onde eigenvalues têm partes reais negativas grandes.",
                                    "Visualizar exemplos gráficos da região de estabilidade para métodos como Trapezoidal e Backward Euler.",
                                    "Comparar com estabilidade relativa."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a definição de A-estabilidade e esboçar a região no plano z.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica",
                                    "Gráficos de regiões de estabilidade (Backward Euler, Trapezoidal)",
                                    "Software como MATLAB ou Python (Matplotlib para plotar regiões)"
                                  ],
                                  "tips": [
                                    "Foque no semiplano esquerdo: Re(z) ≤ 0.",
                                    "Use exemplos simples como y' = -λy com λ > 0 grande."
                                  ],
                                  "learningObjective": "Compreender a base de A-estabilidade como pré-requisito para L-estabilidade.",
                                  "commonMistakes": [
                                    "Confundir A-estabilidade com estabilidade incondicional em todo plano complexo.",
                                    "Ignorar que é |R(z)| ≤ 1, não <1.",
                                    "Esquecer o foco em problemas stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente L-estabilidade",
                                  "subSteps": [
                                    "Estender A-estabilidade: L-estável se A-estável E lim_{z→-∞} R(z)/z = 0.",
                                    "Explicar que a condição adicional garante 'damping' (amortecimento) para componentes de alta frequência negativa.",
                                    "Derivar intuitivamente: para z grande negativo, R(z) deve decair mais rápido que linearmente.",
                                    "Escrever a definição matemática precisa: método L-estável se |R(z)| ≤ 1 para Re(z) ≤ 0 e |R(z)| = o(|z|) como |z| → ∞ ao longo do eixo real negativo.",
                                    "Diferenciar de A-estabilidade pura."
                                  ],
                                  "verification": "Escrever a definição completa de L-estabilidade em um papel ou documento, incluindo a condição limite.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Hairer 'Solving ODEs II')",
                                    "Papel e caneta para anotações",
                                    "Ferramenta de LaTeX ou editor de equações"
                                  ],
                                  "tips": [
                                    "Lembre: a condição lim R(z)/z → 0 evita oscilações em problemas stiff severos.",
                                    "Pense em z = -∞ como escalas infinitamente rígidas."
                                  ],
                                  "learningObjective": "Dominar a definição exata de L-estabilidade como A-estabilidade + damping.",
                                  "commonMistakes": [
                                    "Omitir a condição limite lim R(z)/z = 0.",
                                    "Confundir com A(α)-estabilidade.",
                                    "Achar que é só para métodos implícitos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento de damping em infinito negativo",
                                  "subSteps": [
                                    "Interpretar a condição lim_{z→-∞} R(z)/z = 0: garante que amplificação decai sublinearmente.",
                                    "Explorar implicações para teste de estabilidade em ODEs y' = λy com λ → -∞.",
                                    "Comparar numericamente |R(z)| para métodos A-estáveis vs L-estáveis em z grande negativo.",
                                    "Discutir por que isso previne 'overshoot' ou oscilações em soluções stiff.",
                                    "Visualizar graficamente R(z) ao longo do eixo negativo."
                                  ],
                                  "verification": "Plotar ou descrever o comportamento de R(z)/z para z → -∞ e confirmar que tende a 0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para computar R(z)",
                                    "Gráficos pré-computados de R(z) para métodos comuns",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": [
                                    "Teste com z = -100, -1000: R(z) deve ser muito pequeno.",
                                    "Relacione com ordem do método: métodos de ordem alta podem falhar aqui."
                                  ],
                                  "learningObjective": "Entender o mecanismo de damping e sua necessidade em problemas stiff extremos.",
                                  "commonMistakes": [
                                    "Interpretar damping como |R(z)| <1 só, ignorando a taxa de decaimento.",
                                    "Confundir com dissipatividade.",
                                    "Não testar numericamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com o método Backward Differentiation Formula (BDF)",
                                  "subSteps": [
                                    "Recordar BDF1 (Backward Euler): R(z) = 1/(1 - z), verificar A-estável.",
                                    "Computar lim_{z→-∞} R(z)/z = lim 1/(z(1 - z)) = 0, confirmando L-estável.",
                                    "Analisar BDF2: R(z) = (1 + (5/12)z)/(1 - (2/3)z + (1/12)z²), verificar condições.",
                                    "Comparar com método Trapezoidal (A-estável mas não L-estável).",
                                    "Simular numericamente um problema stiff para demonstrar superioridade."
                                  ],
                                  "verification": "Calcular e mostrar que BDF1 satisfaz ambas condições, contrastando com Trapezoidal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para BDF",
                                    "Exemplo de ODE stiff: y' = -1000(y-1) + sin(t)",
                                    "Tabelas de estabilidade de métodos"
                                  ],
                                  "tips": [
                                    "Use expansão em série para lim: R(z) ~ 1/z para ordem 1.",
                                    "Simule sempre para validar teoria."
                                  ],
                                  "learningObjective": "Aplicar a definição a exemplos concretos como BDF.",
                                  "commonMistakes": [
                                    "Errar cálculo de R(z) para BDF.",
                                    "Achar Trapezoidal L-estável (não é, pois lim R(z)/z = 1/2 ≠0).",
                                    "Ignorar ordens superiores."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler aplicado a y' = λy com λ = -10000 (stiff extremo), compute R(-10000) ≈ 0.0001, e R(z)/z ≈ 10^{-8} → 0, mostrando damping efetivo sem oscilações, ao contrário de métodos explícitos.",
                              "finalVerifications": [
                                "Definir corretamente L-estabilidade incluindo a condição limite.",
                                "Explicar diferença chave entre A e L-estabilidade.",
                                "Identificar BDF como L-estável e Trapezoidal como não.",
                                "Desenhar região de estabilidade e assintótica de R(z).",
                                "Aplicar a um exemplo numérico simples.",
                                "Discutir relevância para solvers stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição matemática (30%).",
                                "Correção na análise da condição de damping (25%).",
                                "Qualidade dos exemplos e ilustrações (20%).",
                                "Compreensão conceitual via explicações (15%).",
                                "Uso adequado de gráficos/simulações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de dinâmica molecular stiff.",
                                "Engenharia de Controle: Estabilização de sistemas rígidos.",
                                "Ciência da Computação: Algoritmos em bibliotecas como SciPy ode.",
                                "Química Computacional: Modelos de reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "L-estabilidade é crucial em solvers de EDOs stiff como MATLAB ode15s ou SUNDIALS CVODE, usados em simulações de circuitos elétricos, reações químicas catalíticas e dinâmica de fluidos com múltiplas escalas, prevenindo instabilidades numéricas em aplicações industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Comparar A e L-estabilidade",
                            "description": "Comparar regiões de estabilidade e comportamento assintótico de métodos A-estáveis (ex: Trapezoidal) versus L-estáveis (ex: BDF2), destacando vantagens em problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de A-Estabilidade",
                                  "subSteps": [
                                    "Defina A-estabilidade: um método é A-estável se sua região de estabilidade inclui o semiplano esquerdo complexo (Re(z) ≤ 0).",
                                    "Estude o método Trapezoidal: derive sua função de amplificação R(z) = (1 + z/2)/(1 - z/2).",
                                    "Analise a região de estabilidade do Trapezoidal: verifique que |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Discuta limitações: oscilações em problemas com componentes rápidos dissipativos.",
                                    "Resolva um teste de Dahlquist com λ negativo grande."
                                  ],
                                  "verification": "Derive corretamente R(z) para Trapezoidal e plote a região de estabilidade confirmando inclusão do semiplano esquerdo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Software MATLAB ou Python (SciPy) para plotar regiões",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Use o teorema de Nyquist para visualizar |R(z)| no contorno do semiplano.",
                                  "learningObjective": "Compreender a definição e propriedades da A-estabilidade com foco no método Trapezoidal.",
                                  "commonMistakes": [
                                    "Confundir A-estabilidade com estabilidade absoluta",
                                    "Esquecer de verificar o módulo |R(z)| no semiplano",
                                    "Não derivar R(z) manualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Definição e Propriedades da L-Estabilidade",
                                  "subSteps": [
                                    "Defina L-estabilidade: A-estável + lim_{|z|→∞, Re(z)≤0} |R(z)| = 0 (propriedade de damping).",
                                    "Estude o método BDF2: derive R(z) = (1 + (4/3)z)/(1 - (2/3)z - (1/3)z²).",
                                    "Verifique A-estabilidade do BDF2 e calcule lim_{z→-∞} |R(z)| ≈ 0.",
                                    "Compare com métodos A-estáveis sem damping, como Trapezoidal.",
                                    "Implemente um teste numérico simples em Python."
                                  ],
                                  "verification": "Confirme que BDF2 é L-estável plotando |R(z)| para z real negativo grande e derivando o limite.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação SciPy odeint/solve_ivp",
                                    "Jupyter Notebook",
                                    "Artigos sobre BDF methods"
                                  ],
                                  "tips": "Foquem no comportamento assintótico: damping é crucial para eficiência em stiff problems.",
                                  "learningObjective": "Dominar a definição de L-estabilidade e suas vantagens via BDF2.",
                                  "commonMistakes": [
                                    "Ignorar a condição de damping no limite",
                                    "Confundir ordem do método com estabilidade",
                                    "Não normalizar polinômios adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Regiões de Estabilidade A vs L",
                                  "subSteps": [
                                    "Plote regiões de estabilidade de Trapezoidal e BDF2 no plano z.",
                                    "Identifique diferenças: Trapezoidal cobre semiplano esquerdo mas |R(z)|→1 em z→-∞; BDF2 tem damping.",
                                    "Calcule passos admissíveis h para λh em regiões críticas.",
                                    "Discuta implicações para problemas stiff: rigidez requer |λh| grande.",
                                    "Crie uma tabela comparativa de inclusão de regiões."
                                  ],
                                  "verification": "Gere plots comparativos mostrando que ambos são A-estáveis, mas BDF2 tem |R|→0.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Octave para contour plots de |R(z)|",
                                    "Python Matplotlib + NumPy",
                                    "Tabelas de referência de estabilidade"
                                  ],
                                  "tips": "Use grid fino para z no semiplano esquerdo; compare com Backward Euler (L-estável).",
                                  "learningObjective": "Visualizar e quantificar diferenças nas regiões de estabilidade.",
                                  "commonMistakes": [
                                    "Plots incorretos por escala errada",
                                    "Confundir Trapezoidal (não L-estável) com métodos L",
                                    "Não considerar direção de z"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Comportamento Assintótico e Vantagens em Problemas Stiff",
                                  "subSteps": [
                                    "Simule problema stiff modelo: y' = -1000(y - sin(t)) + cos(t), y(0)=0.",
                                    "Aplique Trapezoidal e BDF2 com h fixo grande; observe oscilações no Trapezoidal.",
                                    "Meça erro e número de passos efetivos; destaque damping do BDF2.",
                                    "Generalize vantagens: L-estável permite h maior sem oscilações.",
                                    "Discuta trade-offs: ordem, custo computacional."
                                  ],
                                  "verification": "Execute simulações mostrando Trapezoidal oscila enquanto BDF2 converge suavemente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código Python com solve_ivp(method='BDF')",
                                    "Solução exata para benchmark",
                                    "Gráficos de erro vs h"
                                  ],
                                  "tips": "Use problema de Dahlquist stiff para reproducibilidade; log-scale em erros.",
                                  "learningObjective": "Demonstrar superioridade de L-estabilidade em cenários stiff reais.",
                                  "commonMistakes": [
                                    "h muito pequeno mascarando diferenças",
                                    "Não plotar componente transitório",
                                    "Ignorar normalização de soluções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de reação química stiff (y' = -999y + sin(t)), aplique Trapezoidal (A-estável): oscilações persistem; BDF2 (L-estável): damping rápido, permitindo h=0.1 vs h=0.001 necessário para Trapezoidal.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre A e L-estabilidade.",
                                "Derivar R(z) para Trapezoidal e BDF2 corretamente.",
                                "Plotar e interpretar regiões de estabilidade comparativas.",
                                "Simular problema stiff mostrando vantagens do BDF2.",
                                "Listar 3 cenários onde L-estabilidade é preferível.",
                                "Calcular lim_{z→-∞} |R(z)| para ambos métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de funções de amplificação (90% correto).",
                                "Qualidade dos plots de estabilidade (clareza, escalas adequadas).",
                                "Análise quantitativa de erros em simulações stiff.",
                                "Identificação correta de vantagens/desvantagens.",
                                "Tabela comparativa completa e precisa.",
                                "Explicação clara do damping assintótico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica molecular stiff.",
                                "Engenharia Química: Modelos de reatores com escalas múltiplas.",
                                "Computação Científica: Otimização de solvers em bibliotecas como SciPy.",
                                "Matemática Aplicada: Análise de convergência em EDOs lineares."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos stiff (ex: capacitores/diodos em SPICE), L-estabilidade (BDF) permite passos maiores, reduzindo tempo computacional em designs de VLSI sem oscilações espúrias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Verificar L-estabilidade numericamente",
                            "description": "Aplicar teste numérico para checar se |R(z)| → 0 quando |z| → ∞ com arg(z) = π, usando software como MATLAB ou Python para métodos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos de L-estabilidade",
                                  "subSteps": [
                                    "Estude a definição de L-estabilidade: |R(z)| → 0 quando |z| → ∞ com arg(z) = π.",
                                    "Revise a função de estabilidade R(z) para o método numérico escolhido (ex: Backward Euler).",
                                    "Entenda problemas stiff e por que L-estabilidade é crucial para estabilidade em ODEs rígidas.",
                                    "Identifique um método candidato, como Backward Euler ou TR-BDF2.",
                                    "Anote fórmulas chave: R(z) = P(z)/Q(z) para métodos lineares multistep."
                                  ],
                                  "verification": "Resuma em um parágrafo a definição e importância da L-estabilidade, citando pelo menos duas referências teóricas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Hairer et al.), notas de aula sobre estabilidade A/L."
                                  ],
                                  "tips": "Use diagramas de estabilidade para visualizar o setor de estabilidade.",
                                  "learningObjective": "Compreender os fundamentos teóricos para contextualizar o teste numérico.",
                                  "commonMistakes": "Confundir L-estabilidade com A-estabilidade (L requer decaimento no eixo negativo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de software",
                                  "subSteps": [
                                    "Instale/inicie Python com bibliotecas numpy, scipy e matplotlib (ou MATLAB).",
                                    "Defina a função de estabilidade R(z) para o método escolhido, ex: R(z) = 1/(1 - z) para Backward Euler.",
                                    "Crie uma função para gerar z = r * exp(1j * π) com r variando de 1 a 10^6.",
                                    "Teste a função R(z) com valores pequenos para validar.",
                                    "Prepare script para computar |R(z)| em logscale."
                                  ],
                                  "verification": "Execute um teste unitário: para z = -10, |R(z)| deve ser próximo de 0 para métodos L-estáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB, bibliotecas numpy/matplotlib, editor de código (Jupyter Notebook recomendado)."
                                  ],
                                  "tips": "Use logspace para r para evitar overflow/underflow.",
                                  "learningObjective": "Configurar ferramentas computacionais para análise numérica de estabilidade.",
                                  "commonMistakes": "Esquecer o fator exp(1j * π) resultando em z positivo em vez de negativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar o teste numérico",
                                  "subSteps": [
                                    "Gere array de r: logspace(0, 6, 100).",
                                    "Compute z = r * exp(1j * π), então |R(z)| para cada.",
                                    "Plote log(|R(z)|) vs log(r) para verificar tendência para -∞.",
                                    "Teste com método não L-estável (ex: Forward Euler) para comparação.",
                                    "Salve plot e dados em arquivo CSV."
                                  ],
                                  "verification": "O gráfico deve mostrar |R(z)| decaindo para 0 (slope negativo) quando log(r) → ∞.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Script Python/MATLAB pronto, dados de teste."
                                  ],
                                  "tips": "Use abs(R(z)) e semilogy para visualização clara.",
                                  "learningObjective": "Aplicar computação numérica para verificar propriedade de L-estabilidade.",
                                  "commonMistakes": "Usar escala linear em vez de log, mascarando o comportamento assintótico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e concluir",
                                  "subSteps": [
                                    "Ajuste uma reta ao log(|R|) vs log(r) para estimar taxa de decaimento.",
                                    "Verifique se lim_{r→∞} |R| < 10^{-10} ou similar.",
                                    "Compare com literatura: confirme se método é conhecido como L-estável.",
                                    "Documente achados em relatório curto com plots e conclusões.",
                                    "Teste sensibilidade a precisão numérica (double vs long double)."
                                  ],
                                  "verification": "Conclusão explícita: 'Método é/ não é L-estável' com evidência gráfica/numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Plots gerados, software de plot (matplotlib)."
                                  ],
                                  "tips": "Use polyfit(1, logabsR) para slope; slope < 0 confirma decaimento.",
                                  "learningObjective": "Interpretar dados numéricos para validar propriedades matemáticas.",
                                  "commonMistakes": "Ignorar erros de arredondamento para r muito grande (>10^8)."
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler (R(z) = 1/(1-z)): Gere r = logspace(1,8,200), z = -r, compute |R(z)|. Plot semilogy(r, abs(R(z))) deve mostrar decaimento como 1/r, confirmando L-estabilidade. Compare com Trapezoidal Rule (não L-estável).",
                              "finalVerifications": [
                                "|R(z)| < 10^{-6} para |z| > 10^4 com arg(z)=π.",
                                "Gráfico log-log mostra slope negativo assintótico.",
                                "Comparação com método conhecido falha no teste.",
                                "Sem NaN ou Inf em computações para r até 10^6.",
                                "Relatório documenta código, plots e conclusão.",
                                "Teste reproduzível em máquina diferente."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação de R(z) (100% match com fórmula teórica).",
                                "Qualidade do plot e análise assintótica (clareza e precisão).",
                                "Profundidade da verificação (múltiplos r, comparações).",
                                "Documentação completa (código comentado, relatório).",
                                "Interpretação correta da L-estabilidade.",
                                "Eficiência computacional (sem loops desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Aplicação em simulações de ODEs stiff (ex: reações químicas).",
                                "Engenharia: Estabilidade em controle de sistemas dinâmicos.",
                                "Estatística: Análise de regressão linear para slope."
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff como modelagem de circuitos elétricos ou dinâmica molecular, verificar L-estabilidade numericamente garante que métodos numéricos permaneçam estáveis para passos de tempo grandes, reduzindo tempo computacional em software como COMSOL ou ODE solvers industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Importância para problemas stiff",
                        "description": "Aplicação dos critérios A e L-estabilidade na seleção de métodos numéricos estáveis para problemas stiff, onde autovalores com partes reais grandes negativas impõem restrições severas no passo de tempo para métodos explícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Reconhecer problemas stiff",
                            "description": "Identificar características de problemas stiff (ex: razão de magnitudes de autovalores) e explicar por que métodos explícitos falham sem passos minúsculos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de estabilidade em métodos numéricos para EDOs",
                                  "subSteps": [
                                    "Revise a forma geral de uma EDO inicial: y' = f(t,y), y(t0)=y0.",
                                    "Estude métodos de Runge-Kutta explícitos (ex: RK4) e sua condição de estabilidade CFL.",
                                    "Aprenda sobre a região de estabilidade no plano complexo hλ.",
                                    "Identifique que para métodos explícitos, |hλ| deve ser pequeno para estabilidade.",
                                    "Discuta o trade-off entre precisão e tamanho do passo de tempo."
                                  ],
                                  "verification": "Resuma em 3 frases os limites de estabilidade dos métodos explícitos e forneça um diagrama simples da região de estabilidade do RK4.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (cap. EDOs), software MATLAB/Octave para plotar regiões de estabilidade.",
                                  "tips": "Desenhe a região de estabilidade à mão para fixar visualmente.",
                                  "learningObjective": "Explicar por que o tamanho do passo h é limitado pela estabilidade em métodos explícitos.",
                                  "commonMistakes": "Confundir estabilidade numérica com precisão local/global; ignorar o eixo imaginário no plano hλ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar autovalores em sistemas lineares de EDOs",
                                  "subSteps": [
                                    "Considere o sistema linear y' = A y e sua solução exata via exponencial de matriz.",
                                    "Calcule autovalores e autovetores de A usando decomposição espectral.",
                                    "Examine a razão de magnitudes |λ_max / λ_min| onde λ são autovalores reais negativos.",
                                    "Simule numericamente com passos grandes e observe oscilações ou divergência.",
                                    "Compare com passos pequenos para confirmar estabilidade."
                                  ],
                                  "verification": "Para uma matriz A diagonal com λ1=-1, λ2=-1000, compute a razão de magnitudes e simule 10 passos com h=0.1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python (scipy.linalg.eig), exemplos de matrizes stiff pré-definidas.",
                                  "tips": "Use autovalores reais negativos para simplicidade inicial; evite complexos até dominar.",
                                  "learningObjective": "Identificar que grandes disparidades em |λ| causam componentes 'rápidas' e 'lentas'.",
                                  "commonMistakes": "Esquecer de normalizar autovetores; confundir autovalores com valores singulares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar características diagnósticas de problemas stiff",
                                  "subSteps": [
                                    "Defina problema stiff: razão |λ_max / λ_min| > 1000 tipicamente.",
                                    "Teste com exemplo: y' = [-1, 0; 0, -1000] y.",
                                    "Observe que h < 2/|λ_max| é necessário para estabilidade explícita.",
                                    "Explique por que passos minúsculos são ineficientes para capturar dinâmica lenta.",
                                    "Classifique exemplos não-stiff vs stiff baseados em autovalores."
                                  ],
                                  "verification": "Classifique 3 sistemas dados como stiff ou não, justificando com razão de autovalores.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha com matrizes de teste, calculadora simbólica (SymPy).",
                                  "tips": "Sempre compute todos autovalores, incluindo os de menor magnitude.",
                                  "learningObjective": "Reconhecer quantitativamente problemas stiff via análise espectral.",
                                  "commonMistakes": "Considerar apenas o maior |λ| sem razão; ignorar autovalores próximos de zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar falha de métodos explícitos e introduzir alternativas",
                                  "subSteps": [
                                    "Simule um problema stiff com RK4 e h inadequado: observe instabilidade.",
                                    "Ajuste h até estabilidade e note o custo computacional.",
                                    "Introduza métodos implícitos (ex: Backward Euler) e sua região de estabilidade ilimitada no semiplano negativo.",
                                    "Compare eficiência: implícitos permitem h maior guiado por precisão.",
                                    "Resuma: stiff requer implícitos para eficiência."
                                  ],
                                  "verification": "Gere gráficos comparativos de solução explícita vs implícita para um stiff problem.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código pronto em Python (odeint vs solve_ivp método='BDF'), exemplos de plots.",
                                  "tips": "Use log-scale no tempo para visualizar componentes rápidas.",
                                  "learningObjective": "Justificar por que explícitos falham em stiff sem h minúsculo.",
                                  "commonMistakes": "Atribuir falha à precisão em vez de estabilidade; não testar h variados."
                                }
                              ],
                              "practicalExample": "Considere o sistema y' = [[-1, 0], [0, -1000]] y, y(0)=[1,1]. A razão |λ_max/λ_min|=1000 indica stiff. RK4 com h=0.01 diverge rapidamente devido à componente rápida λ=-1000, exigindo h<0.002 para estabilidade, enquanto Backward Euler com h=0.1 converge eficientemente.",
                              "finalVerifications": [
                                "Defina corretamente problema stiff usando razão de autovalores.",
                                "Identifique stiff em um sistema dado com autovalores -10 e -10000.",
                                "Explique instabilidade em simulação explícita com h=0.05.",
                                "Compare regiões de estabilidade de RK4 vs Backward Euler.",
                                "Classifique 80% de 5 exemplos como stiff/não-stiff corretamente.",
                                "Descreva custo computacional de h pequeno em explícitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição quantitativa de stiff (>1000 em razão |λ|).",
                                "Correta análise espectral de matrizes 2x2.",
                                "Identificação visual de instabilidade em plots numéricos.",
                                "Explicação clara do mecanismo de falha (estabilidade vs precisão).",
                                "Uso apropriado de terminologia (região de estabilidade, componente rápida).",
                                "Eficiência em simulações comparativas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC com constantes de tempo díspares.",
                                "Química: Cinética de reações com escalas rápidas/lentas (rigidez química).",
                                "Engenharia: Simulações CFD com escalas múltiplas.",
                                "Computação: Otimização de solvers numéricos em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, problemas stiff surgem de reações rápidas de equilíbrio vs lentas de produto; métodos explícitos falham em previsões industriais, exigindo reconhecimento para escolher solvers implícitos como LSODA, economizando horas de computação em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Selecionar métodos baseados em A/L-estabilidade",
                            "description": "Escolher métodos adequados (ex: implícitos A/L-estáveis com controle de passo adaptativo) para EDOs stiff, justificando com análise de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de estabilidade A e L",
                                  "subSteps": [
                                    "Defina estabilidade A (Absolute Stability): região no plano complexo onde o método é estável para o teste de Dahlquist.",
                                    "Defina estabilidade L (Linear Stability): análise para problemas lineares com autovalores reais negativos.",
                                    "Compare A/L-estabilidade com estabilidade padrão de métodos explícitos como Euler forward.",
                                    "Estude o semi-círculo de estabilidade para métodos implícitos como Backward Euler.",
                                    "Revise exemplos de regiões de estabilidade para métodos Runge-Kutta implícitos."
                                  ],
                                  "verification": "Resuma as diferenças entre A-estabilidade e L-estabilidade em um parágrafo conciso e correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre estabilidade",
                                    "Gráficos de regiões de estabilidade"
                                  ],
                                  "tips": "Desenhe as regiões de estabilidade no plano complexo para visualizar melhor.",
                                  "learningObjective": "Dominar definições e implicações de A/L-estabilidade para EDOs stiff.",
                                  "commonMistakes": "Confundir A-estabilidade (semi-plano esquerdo) com estabilidade incondicional de métodos explícitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar problemas EDO stiff e suas características",
                                  "subSteps": [
                                    "Reconheça sinais de stiff: escalas de tempo muito diferentes (ex: autovalores com partes reais grandes negativas).",
                                    "Analise o espectro de autovalores da matriz Jacobiana para classificar rigidez.",
                                    "Classifique EDOs stiff como lineares ou não-lineares e seu impacto na escolha de métodos.",
                                    "Calcule o índice de rigidez (razão entre |λ_max| e |λ_min|).",
                                    "Examine exemplos clássicos como y' = -λ(y - sin(t)) com λ grande."
                                  ],
                                  "verification": "Classifique 3 EDOs dados como stiff ou não-stiff, justificando com análise espectral.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para autovalores (eig)",
                                    "Exemplos de EDOs stiff de referências"
                                  ],
                                  "tips": "Use eig() em Python/MATLAB para decomposição espectral rápida.",
                                  "learningObjective": "Diagnosticar rigidez em sistemas de EDOs para guiar seleção de métodos.",
                                  "commonMistakes": "Ignorar autovalores complexos ou superestimar rigidez em problemas moderados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar métodos A/L-estáveis adequados",
                                  "subSteps": [
                                    "Liste métodos implícitos A/L-estáveis: Backward Euler, Trapezoidal, Radau IIA, BDFs.",
                                    "Avalie necessidade de controle de passo adaptativo (ex: ODE15s no MATLAB).",
                                    "Compare eficiência: custo por passo vs. passos necessários para precisão.",
                                    "Escolha método baseado em ordem, linearidade e rigidez (ex: BDF para não-lineares stiff).",
                                    "Implemente um teste simples em código para validar escolha."
                                  ],
                                  "verification": "Para uma EDO stiff dada, selecione e justifique um método A/L-estável com controle adaptativo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Documentação ODE solvers (MATLAB ode23s, ode15s; SciPy solve_ivp)",
                                    "Código template para testes"
                                  ],
                                  "tips": "Priorize solvers com 'stiff' no nome para problemas identificados como rígidos.",
                                  "learningObjective": "Escolher métodos otimizados para estabilidade em EDOs stiff.",
                                  "commonMistakes": "Escolher métodos explícitos de alta ordem que falham em rigidez extrema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar seleção com análise de estabilidade",
                                  "subSteps": [
                                    "Calcule a função de amplificação R(z) para o método escolhido.",
                                    "Verifique se os autovalores do problema estão na região A/L-estável.",
                                    "Simule com passos fixos vs. adaptativos e compare estabilidade.",
                                    "Analise trade-offs: precisão, custo computacional e robustez.",
                                    "Documente justificativa em relatório curto com gráficos de solução."
                                  ],
                                  "verification": "Produza um relatório com análise R(z), gráfico de região e simulação confirmando estabilidade.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib/MATLAB)",
                                    "Tabelas de funções de amplificação de métodos"
                                  ],
                                  "tips": "Use z = h*λ para mapear autovalores ao plano de estabilidade.",
                                  "learningObjective": "Justificar rigorosamente escolhas de métodos via análise teórica e numérica.",
                                  "commonMistakes": "Não considerar h variável em controles adaptativos ou ignorar não-linearidades."
                                }
                              ],
                              "practicalExample": "Para a EDO stiff y' = -1000(y - t^2) + 2t, y(0)=0 (rigidez λ=-1000), selecione Backward Euler com passo adaptativo: implemente em Python com solve_ivp(method='BDF'), verifique estabilidade plotando solução vs. exata (t^2), confirmando ausência de oscilações.",
                              "finalVerifications": [
                                "Explicar A/L-estabilidade e regiões no plano complexo.",
                                "Classificar EDO como stiff via espectro de autovalores.",
                                "Selecionar método implícito A/L-estável com justificativa.",
                                "Implementar e simular corretamente sem instabilidades.",
                                "Analisar trade-offs de eficiência e precisão.",
                                "Documentar escolha com gráficos de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção de A/L-estabilidade (20%)",
                                "Correta identificação de rigidez e análise espectral (25%)",
                                "Seleção adequada de método com controle adaptativo (20%)",
                                "Justificativa teórica via R(z) e simulações (20%)",
                                "Eficiência computacional demonstrada (10%)",
                                "Clareza na documentação e gráficos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC stiff em eletrônica.",
                                "Computação: Otimização de solvers numéricos em SciPy/MATLAB.",
                                "Engenharia Química: Simulações de reatores com cinéticas rígidas.",
                                "Biologia Computacional: Dinâmicas populacionais com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), métodos A/L-estáveis como BDF evitam crashes numéricos, permitindo previsões precisas de concentrações em reatores industriais, otimizando processos e reduzindo custos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Avaliar estabilidade em exemplos",
                            "description": "Resolver numericamente um problema stiff modelo (ex: y' = -1000(y-1) + sin(t)) com métodos A-estável e não A-estável, comparando estabilidade e eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Problema Stiff Modelo",
                                  "subSteps": [
                                    "Defina a equação diferencial ordinária (EDO): y' = -1000(y - 1) + sin(t).",
                                    "Especifique condições iniciais: y(0) = 0, e intervalo de tempo t ∈ [0, 4].",
                                    "Calcule a solução de referência usando um solver stiff como ode45 no MATLAB ou solve_ivp('BDF') no Python.",
                                    "Analise o termo stiff: o fator -1000 indica rigidez devido à rápida dissipação.",
                                    "Prepare scripts para plotagem de soluções."
                                  ],
                                  "verification": "Solução de referência plotada sem erros e salva como baseline.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (NumPy, SciPy, Matplotlib) ou MATLAB",
                                  "tips": "Use h inicial pequeno (0.001) para referência para capturar dinâmica rápida.",
                                  "learningObjective": "Entender a natureza stiff do problema e preparar baseline para comparações.",
                                  "commonMistakes": "Ignorar o termo sin(t) ou definir condições iniciais incorretas; confundir y(0)=1 com y(0)=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Método Não A-Estável (Forward Euler)",
                                  "subSteps": [
                                    "Escreva o esquema: y_{n+1} = y_n + h * f(t_n, y_n), onde f(t,y) = -1000(y-1) + sin(t).",
                                    "Escolha h = 0.01 e implemente loop temporal até t=4.",
                                    "Registre tempos de computação com timeit ou tic-toc.",
                                    "Plote y vs t e compare com referência.",
                                    "Observe e anote comportamentos anômalos."
                                  ],
                                  "verification": "Código roda sem erros, gráfico mostra solução (possivelmente instável).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python ou MATLAB script do Step 1",
                                  "tips": "Vetorize computações para eficiência; salve arrays de t e y.",
                                  "learningObjective": "Aplicar método explícito e identificar limitações de estabilidade.",
                                  "commonMistakes": "Usar h muito grande (>0.01) causando divergência imediata; esquecendo sin(t)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método A-Estável (Backward Euler)",
                                  "subSteps": [
                                    "Escreva o esquema implícito: y_{n+1} = y_n + h * f(t_{n+1}, y_{n+1}).",
                                    "Resolva linearmente: y_{n+1} (1 + 1000h) = y_n + h(sin(t_{n+1}) + 1000), y_{n+1} = [y_n + h(sin(t_{n+1}) + 1000)] / (1 + 1000h).",
                                    "Use h = 0.1 (maior que no explícito) e execute loop.",
                                    "Meça tempo de computação e plote y vs t.",
                                    "Compare visualmente com referência."
                                  ],
                                  "verification": "Solução estável gerada, gráfico próximo à referência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Scripts anteriores; calculadora para verificar fórmula implícita",
                                  "tips": "Simplifique a equação linear para eficiência; teste com h=0.1 primeiro.",
                                  "learningObjective": "Dominar método implícito A-estável e resolver sistemas lineares por passo.",
                                  "commonMistakes": "Erro na algebra implícita (esquecer -1000 no denominador); usar h pequeno desnecessariamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulações e Visualizar Resultados",
                                  "subSteps": [
                                    "Rode ambos métodos com h variando: explícito h=0.001,0.01; implícito h=0.01,0.1.",
                                    "Gere gráficos sobrepostos: referência, explícito, implícito.",
                                    "Calcule erros L2: sqrt(mean((y - y_ref)^2)).",
                                    "Registre tempos CPU para cada.",
                                    "Salve figuras e tabela de resultados."
                                  ],
                                  "verification": "Gráficos e tabela mostram diferenças claras de estabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Todos scripts; Excel ou Pandas para tabela",
                                  "tips": "Use subplots para múltiplos h; normalize erros por comprimento.",
                                  "learningObjective": "Visualizar e quantificar diferenças numéricas.",
                                  "commonMistakes": "Escalas de eixo erradas ocultando oscilações; não plotar referência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Estabilidade e Eficiência",
                                  "subSteps": [
                                    "Identifique instabilidade no explícito: oscilações ou blow-up para h>0.002.",
                                    "Confirme estabilidade no implícito para h até 0.1.",
                                    "Compare eficiência: tempo/erro (implícito melhor).",
                                    "Discuta região de estabilidade A (meio-plano esquerdo).",
                                    "Escreva relatório resumido com conclusões."
                                  ],
                                  "verification": "Relatório explica por que A-estável é superior para stiff.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos e tabelas; papel para esboço de regiões",
                                  "tips": "Refira critério de A-stability: |R(iy)| <=1 para todo y real.",
                                  "learningObjective": "Avaliar criticamente estabilidade e eficiência em contextos stiff.",
                                  "commonMistakes": "Atribuir instabilidade a 'ruído' em vez de h; ignorar custo implícito por passo."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000(y - 1) + sin(t), y(0) = 0, t ∈ [0, 4]. Use Forward Euler (h=0.01, instável com oscilações) vs Backward Euler (h=0.1, estável e preciso). Plote e compare erros/tempos: explícito diverge após t=1, implícito segue referência com erro <1e-3.",
                              "finalVerifications": [
                                "Método explícito exibe instabilidade clara (oscilações ou divergência).",
                                "Método implícito mantém estabilidade para h maior.",
                                "Erros L2 calculados e gráficos sobrepostos salvos.",
                                "Tempos de CPU registrados e comparados.",
                                "Relatório identifica superioridade A-estável para stiff.",
                                "Região de estabilidade discutida corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação de ambos métodos (20%).",
                                "Identificação precisa de instabilidade no explícito (20%).",
                                "Análise quantitativa de erros e tempos (20%).",
                                "Visualizações claras e informativas (15%).",
                                "Conclusões sobre eficiência em stiff (15%).",
                                "Relatório bem estruturado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física/Química: Modelos de reações stiff com escalas rápidas/lentas.",
                                "Computação: Algoritmos numéricos e otimização de solvers.",
                                "Engenharia: Simulações em controle de processos industriais.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas (ex: combustão com espécies rápidas), circuitos RC stiff ou dinâmica populacional, onde métodos explícitos falham economicamente, mas A-estáveis como Backward Euler ou BDF permitem passos maiores e simulações viáveis em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1",
                              "10.1.5.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Métodos para Problema de Valor de Contorno",
                "description": "Métodos numéricos específicos para resolver equações diferenciais com condições de contorno.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Definição do Problema de Valor de Contorno",
                    "description": "Formulação matemática de equações diferenciais ordinárias com condições de contorno em pontos distintos do domínio.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Diferença entre Problema de Valor Inicial (PVI) e Problema de Valor de Contorno (PVC)",
                        "description": "Compreender a distinção fundamental entre PVIs, onde condições iniciais são especificadas em um único ponto, e PVCs, onde condições de contorno são dadas em pontos distintos do domínio.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Definir formalmente um Problema de Valor Inicial (PVI)",
                            "description": "Descrever a formulação matemática de um PVI para EDOs de primeira ordem: y' = f(x, y), com condição inicial y(x₀) = y₀, e para segunda ordem: y'' = f(x, y, y'), y(x₀) = α, y'(x₀) = β.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Equações Diferenciais Ordinárias (EDOs) e Condições Iniciais",
                                  "subSteps": [
                                    "Revise a definição de uma EDO: uma equação que relaciona uma função desconhecida y(x) com suas derivadas.",
                                    "Identifique ordens de EDOs: primeira ordem envolve y', segunda ordem envolve y''.",
                                    "Explique o papel das condições iniciais: valores de y e/ou derivadas em um ponto x₀ para unicidade da solução.",
                                    "Diferencie condições iniciais de condições de contorno (valores em pontos diferentes).",
                                    "Estude o Teorema de Existência e Unicidade de Picard-Lindelöf para PVIs.",
                                    "Anote exemplos simples de PVIs para fixar conceitos."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo EDO, ordem e condições iniciais, e cite o teorema de unicidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce & DiPrima)",
                                    "Notas de aula sobre Análise Numérica I",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Use diagramas para visualizar y(x) e condições iniciais em um plano x-y.",
                                  "learningObjective": "Dominar os fundamentos teóricos de EDOs e condições iniciais para formular PVIs.",
                                  "commonMistakes": [
                                    "Confundir ordem da EDO com número de condições iniciais",
                                    "Ignorar a necessidade de condições para unicidade da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular Formalmente um PVI de Primeira Ordem",
                                  "subSteps": [
                                    "Escreva a forma geral: y' = f(x, y), onde f é contínua e Lipschitz em y.",
                                    "Adicione a condição inicial: y(x₀) = y₀.",
                                    "Verifique se f satisfaz hipóteses do teorema de existência (continuidade e Lipschitz).",
                                    "Construa um exemplo: y' = -ky + g(x), y(0) = P₀ (modelo de crescimento populacional).",
                                    "Resolva analiticamente um caso simples para validar a formulação.",
                                    "Discuta o intervalo de existência da solução única."
                                  ],
                                  "verification": "Formule e verifique um PVI de 1ª ordem com suas condições, justificando unicidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Software como MATLAB ou Python (SymPy) para verificação simbólica"
                                  ],
                                  "tips": "Sempre especifique o domínio de x e y para maior precisão.",
                                  "learningObjective": "Capacitar a escrita precisa da notação matemática para PVIs de 1ª ordem.",
                                  "commonMistakes": [
                                    "Esquecer de especificar x₀ e y₀ explicitamente",
                                    "Não mencionar hipóteses para existência/unicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Formalmente um PVI de Segunda Ordem",
                                  "subSteps": [
                                    "Reduza a EDO de 2ª ordem a um sistema de 1ª ordem: introduza v = y', então v' = f(x, y, v).",
                                    "Escreva a forma geral: y'' = f(x, y, y'), com y(x₀) = α e y'(x₀) = β.",
                                    "Verifique condições de Lipschitz para o sistema equivalente.",
                                    "Crie um exemplo: y'' + p(x)y' + q(x)y = g(x), y(0)=α, y'(0)=β (oscilador harmônico).",
                                    "Compare com a formulação em sistema de duas equações de 1ª ordem.",
                                    "Analise estabilidade inicial via condições."
                                  ],
                                  "verification": "Escreva a formulação completa de um PVI de 2ª ordem e seu equivalente em 1ª ordem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folhas de exercícios de EDOs",
                                    "Ferramentas online como Desmos para plotar soluções"
                                  ],
                                  "tips": "Lembre-se: duas condições iniciais para 2ª ordem, uma para cada 'grau de liberdade'.",
                                  "learningObjective": "Habilitar a formulação rigorosa de PVIs de 2ª ordem e reduções equivalentes.",
                                  "commonMistakes": [
                                    "Confundir y'(x₀)=β com condição de contorno",
                                    "Omitir a derivada na notação geral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar PVI de Problema de Valor de Contorno (PVC) e Praticar Formulações",
                                  "subSteps": [
                                    "Defina PVC: condições em pontos distintos, ex: y(a)=α, y(b)=β para 2ª ordem.",
                                    "Compare: PVI usa condições no mesmo ponto x₀ (causalidade temporal); PVC em extremos (BVP).",
                                    "Formule 3 exemplos de PVIs e converta um para PVC hipotético.",
                                    "Discuta métodos numéricos: PVI usa métodos de passo (Runge-Kutta); PVC usa 'tiro' ou diferenças finitas.",
                                    "Teste compreensão resolvendo um PVI simples numericamente.",
                                    "Revise todas as formulações e anote diferenças chave."
                                  ],
                                  "verification": "Crie uma tabela comparativa PVI vs PVC com exemplos formais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para simulações numéricas simples",
                                    "Resumo de métodos numéricos"
                                  ],
                                  "tips": "Pense em aplicações físicas: PVI para trajetórias iniciais, PVC para vigas fixas.",
                                  "learningObjective": "Consolidar a distinção conceitual e prática entre PVI e PVC.",
                                  "commonMistakes": [
                                    "Achar que PVC é só para 2ª ordem",
                                    "Não reconhecer que PVIs garantem soluções locais únicas sob hipóteses"
                                  ]
                                }
                              ],
                              "practicalExample": "Para modelar o crescimento de uma população: y' = 0.1 y (1 - y/100), y(0) = 10. Esta é a formulação formal de um PVI de 1ª ordem, onde f(x,y) = 0.1 y (1 - y/100) é Lipschitz, garantindo solução única no intervalo inicial.",
                              "finalVerifications": [
                                "Escreva corretamente a notação geral de PVI de 1ª e 2ª ordem sem erros.",
                                "Identifique e corrija uma formulação incompleta de PVI fornecida.",
                                "Explique verbalmente as condições para existência e unicidade.",
                                "Diferencie PVI de PVC em um exemplo concreto.",
                                "Formule um PVI real de física (ex: queda livre).",
                                "Verifique Lipschitz em f(x,y) para um exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (fórmulas exatas).",
                                "Compreensão de hipóteses teóricas (continuidade/Lipschitz).",
                                "Capacidade de redução de ordem e exemplos relevantes.",
                                "Distinção clara entre PVI e PVC.",
                                "Aplicação a contextos numéricos reais.",
                                "Clareza e completude nas explicações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de movimento (leis de Newton como PVIs).",
                                "Engenharia: Simulações em circuitos RLC (sistemas de 2ª ordem).",
                                "Computação: Implementação de solvers numéricos (Runge-Kutta em Python).",
                                "Biologia: Dinâmica populacional e epidemias (modelos Lotka-Volterra).",
                                "Economia: Modelos de crescimento com condições iniciais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, PVIs modelam trajetórias de foguetes: y'' = -g + thrust/m, y(0)=0, y'(0)=v₀, permitindo simulações precisas de lançamento via métodos numéricos para prever órbitas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Definir formalmente um Problema de Valor de Contorno (PVC)",
                            "description": "Explicar a formulação matemática de um PVC para EDOs de segunda ordem: y'' = f(x, y, y'), com condições de contorno separadas y(a) = α e y(b) = β, onde a < b e a ≠ b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Problema de Valor Inicial (PVI) para EDOs de Segunda Ordem",
                                  "subSteps": [
                                    "Lembre-se da forma geral de uma EDO de segunda ordem: y'' = f(x, y, y').",
                                    "Identifique as condições iniciais típicas: y(x0) = y0 e y'(x0) = y'0, no mesmo ponto x0.",
                                    "Escreva um exemplo simples de PVI, como y'' + y = 0 com y(0)=1, y'(0)=0.",
                                    "Explique por que as condições são especificadas no ponto inicial x0.",
                                    "Discuta a unicidade da solução pelo Teorema de Picard-Lindelöf."
                                  ],
                                  "verification": "Escreva corretamente a definição de PVI e um exemplo resolvido manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de EDOs (capítulo sobre PVI)"
                                  ],
                                  "tips": "Use notação consistente para y, y', y'' para evitar confusão.",
                                  "learningObjective": "Compreender a estrutura de um PVI como base para contrastar com PVC.",
                                  "commonMistakes": "Confundir condições iniciais com condições de contorno separadas em pontos diferentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Condições de Contorno Separadas",
                                  "subSteps": [
                                    "Defina condições de contorno: valores de y especificados em pontos distintos a e b, onde a < b.",
                                    "Discuta por que em PVC as condições são y(a) = α e y(b) = β, não envolvendo derivadas necessariamente.",
                                    "Compare com condições iniciais: PVI usa y e y' no mesmo ponto; PVC usa y em pontos separados.",
                                    "Esboce graficamente uma curva y(x) satisfazendo y(a)=α e y(b)=β.",
                                    "Mencione aplicações físicas onde contornos são naturais, como extremidades fixas."
                                  ],
                                  "verification": "Desenhe um gráfico ilustrando y(a)=α e y(b)=β, diferenciando de PVI.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado para gráficos",
                                    "Software de plotagem como Desmos (opcional)"
                                  ],
                                  "tips": "Sempre especifique a < b para evitar ambiguidades.",
                                  "learningObjective": "Distinguir condições de contorno de condições iniciais.",
                                  "commonMistakes": "Assumir que PVC requer condições em y e y' como no PVI."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Formalmente o Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Escreva a equação diferencial: y''(x) = f(x, y(x), y'(x)) para x ∈ [a, b].",
                                    "Adicione as condições: y(a) = α e y(b) = β.",
                                    "Especifique o domínio: intervalo fechado [a, b] com a ≠ b.",
                                    "Declare suposições para existência/unicidade, como f contínua e Lipschitz.",
                                    "Escreva a definição completa em notação matemática formal."
                                  ],
                                  "verification": "Redija a definição formal completa em um parágrafo ou equações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Referência: livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Use parênteses para esclarecer dependências: f(x, y, y').",
                                  "learningObjective": "Dominar a notação e formulação exata de um PVC.",
                                  "commonMistakes": "Esquecer de especificar o intervalo [a, b] ou assumir a = b."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar PVC com PVI e Verificar Compreensão",
                                  "subSteps": [
                                    "Liste diferenças chave: pontos de condições (mesmo vs. separados), método de solução (direto vs. indireto).",
                                    "Discuta por que PVC requer métodos numéricos como tiro ou diferenças finitas.",
                                    "Crie uma tabela comparativa: colunas PVI vs. PVC.",
                                    "Resolva um PVC simples analiticamente se possível (ex: y''=0).",
                                    "Identifique quando um problema é PVC vs. PVI."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e classifique 3 exemplos como PVI ou PVC.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela impressa ou digital",
                                    "Exemplos de problemas de EDOs"
                                  ],
                                  "tips": "Lembre-se: PVC é 'contorno' porque condições são nas 'bordas' do intervalo.",
                                  "learningObjective": "Aplicar a definição para diferenciar e contextualizar PVC.",
                                  "commonMistakes": "Confundir PVC com problemas de contorno mistos (envolvendo y')."
                                }
                              ],
                              "practicalExample": "Considere a equação y''(x) = 0 com y(0) = 0 e y(1) = 1. A solução é y(x) = x, uma linha reta conectando os pontos de contorno (0,0) e (1,1), modelando uma viga reta sob carga uniforme.",
                              "finalVerifications": [
                                "Escreve corretamente a forma geral y'' = f(x,y,y') com y(a)=α, y(b)=β.",
                                "Explica a diferença principal entre PVI e PVC em uma frase.",
                                "Identifica um PVC em um problema dado.",
                                "Desenha o gráfico satisfazendo as condições de contorno.",
                                "Menciona pelo menos uma suposição para existência de solução.",
                                "Classifica corretamente 3 exemplos mistos como PVI ou PVC."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% correto).",
                                "Clareza na explicação da diferença PVI vs. PVC.",
                                "Capacidade de formular PVC formalmente sem erros.",
                                "Uso correto de termos como 'condições separadas' e 'intervalo [a,b]'.",
                                "Profundidade na comparação e exemplos fornecidos.",
                                "Completude da definição, incluindo domínio e suposições."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de deflexão de vigas (equações elásticas).",
                                "Engenharia: Análise estrutural com condições de apoio fixo.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Cálculo: Integração de EDOs com teoremas de existência."
                              ],
                              "realWorldApplication": "Em engenharia civil, PVCs modelam a deflexão de vigas com extremidades fixas em posições conhecidas (y(a)=0, y(b)=0), permitindo calcular tensões e dimensionar estruturas seguras contra colapso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Identificar as principais diferenças entre PVI e PVC",
                            "description": "Comparar aspectos como localização das condições (inicial vs. contorno), métodos de solução (marcha vs. métodos de tiro ou diferença finita) e desafios numéricos (existência única vs. condições de solvibilidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de PVI e PVC",
                                  "subSteps": [
                                    "Defina Problema de Valor Inicial (PVI): equação diferencial com condições especificadas no ponto inicial (t=0).",
                                    "Defina Problema de Valor de Contorno (PVC): equação diferencial com condições especificadas nos extremos do intervalo (x=a e x=b).",
                                    "Identifique o tipo de equação diferencial comum: EDOs lineares de segunda ordem.",
                                    "Escreva exemplos matemáticos simples para cada um.",
                                    "Compare a notação padrão: y'' + p(x)y' + q(x)y = g(x) com condições."
                                  ],
                                  "verification": "Escreva definições e exemplos em um papel ou documento e confirme que distinguem claramente PVI de PVC.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica ou notas de aula",
                                    "Papel e caneta ou editor de texto",
                                    "Acesso a exemplos online de EDOs"
                                  ],
                                  "tips": [
                                    "Use diagramas de linha do tempo para PVI (evolução temporal) vs. espaço para PVC.",
                                    "Memorize: PVI é 'início', PVC é 'fronteiras'.",
                                    "Pratique escrevendo a forma geral."
                                  ],
                                  "learningObjective": "Compreender as definições básicas e notações de PVI e PVC para estabelecer base comparativa.",
                                  "commonMistakes": [
                                    "Confundir PVI com condições em múltiplos pontos.",
                                    "Ignorar que PVC pode ser para EDOs ou EDPs.",
                                    "Esquecer que PVI é tipicamente temporal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar localização e natureza das condições",
                                  "subSteps": [
                                    "Liste condições de PVI: y(x0)=y0 e y'(x0)=y'0 no ponto inicial.",
                                    "Liste condições de PVC: y(a)=α e y(b)=β nos extremos do intervalo [a,b].",
                                    "Discuta implicações: PVI permite integração sequencial; PVC requer condições simultâneas.",
                                    "Classifique tipos de PVC: Dirichlet (valores), Neumann (derivadas), misto.",
                                    "Crie uma tabela comparativa visual das condições."
                                  ],
                                  "verification": "Construa uma tabela comparativa e explique verbalmente ou por escrito as diferenças para um colega ou gravador.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Excel/Google Sheets",
                                    "Notas de aula sobre condições de contorno",
                                    "Exemplos de problemas clássicos"
                                  ],
                                  "tips": [
                                    "Visualize PVI como 'flecha partindo de um ponto', PVC como 'barra com fixações nas pontas'.",
                                    "Sempre especifique o domínio: temporal vs. espacial.",
                                    "Inclua unidades físicas para intuitividade."
                                  ],
                                  "learningObjective": "Distinguir precisamente a localização e tipos de condições entre PVI e PVC.",
                                  "commonMistakes": [
                                    "Pensar que PVC só usa condições de valor (ignora Neumann).",
                                    "Confundir ordem das condições em PVI.",
                                    "Não notar que PVC pode ter condições não lineares."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar métodos de solução numérica",
                                  "subSteps": [
                                    "Para PVI: descreva método da marcha (Runge-Kutta, Euler) – avanço passo a passo do inicial.",
                                    "Para PVC: explique métodos de tiro (shooting), diferenças finitas ou relaxação – iterações globais.",
                                    "Compare eficiência: PVI causal (unidirecional), PVC acausal (bidirecional).",
                                    "Implemente pseudocódigo simples para cada método.",
                                    "Discuta convergência: PVI local, PVC global."
                                  ],
                                  "verification": "Escreva pseudocódigos e simule manualmente 2-3 passos para um exemplo simples de cada.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Software como MATLAB/Python (opcional para simulação)",
                                    "Papel para pseudocódigo",
                                    "Tutoriais online de Runge-Kutta e shooting method"
                                  ],
                                  "tips": [
                                    "Pense em PVI como 'previsão do futuro', PVC como 'ajuste de parâmetros para encaixar fronteiras'.",
                                    "Comece com problemas lineares para PVC.",
                                    "Use gráficos para visualizar iterações."
                                  ],
                                  "learningObjective": "Identificar e contrastar os algoritmos numéricos apropriados para PVI vs. PVC.",
                                  "commonMistakes": [
                                    "Aplicar marcha diretamente em PVC sem ajuste.",
                                    "Ignorar sensibilidade inicial no método de tiro.",
                                    "Confundir estabilidade em PVI com solvibilidade em PVC."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar desafios numéricos e teoremas de existência",
                                  "subSteps": [
                                    "Para PVI: teorema de Picard-Lindelöf garante existência/unicidade local sob Lipschitz.",
                                    "Para PVC: condições de solvibilidade (não singularidade da matriz em diferenças finitas), múltiplas soluções possíveis.",
                                    "Discuta instabilidades: PVI bem-posed, PVC ill-posed se condições inadequadas.",
                                    "Examine exemplos de falha: PVC com condições incompatíveis.",
                                    "Resuma em uma tabela: existência, unicidade, estabilidade."
                                  ],
                                  "verification": "Resolva um PVC simples analiticamente ou numericamente e verifique condições de solvibilidade.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (SymPy/Mathematica)",
                                    "Textos sobre teoria de EDOs",
                                    "Exemplos de problemas ill-posed"
                                  ],
                                  "tips": [
                                    "Verifique sempre o determinante da matriz BVP para lineares.",
                                    "Use teoremas qualitativos antes de numéricos.",
                                    "Considere aplicações físicas para motivação."
                                  ],
                                  "learningObjective": "Compreender as diferenças em teoria e desafios práticos de resolução numérica.",
                                  "commonMistakes": [
                                    "Assumir unicidade universal para PVC como em PVI.",
                                    "Ignorar não-linearidades que complicam PVC.",
                                    "Não diferenciar bem-posedness entre os dois."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO y'' + y = 0. Para PVI: y(0)=0, y'(0)=1 → solução y=sin(x) via Runge-Kutta marchando de x=0. Para PVC: y(0)=0, y(π)=0 → eigenvalue problem, use shooting ajustando y'(0) para acertar y(π)=0, revelando soluções y=sin(nx).",
                              "finalVerifications": [
                                "Liste corretamente 5 diferenças principais entre PVI e PVC.",
                                "Explique por que método de marcha falha em PVC sem modificação.",
                                "Identifique condições de existência para um PVC dado.",
                                "Crie uma tabela comparativa completa.",
                                "Simule numericamente um PVI e um PVC simples.",
                                "Discuta um exemplo real onde PVC é essencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de condições (inicial vs. contorno): 25%.",
                                "Compreensão de métodos numéricos e suas limitações: 25%.",
                                "Análise de existência/unicidade e desafios: 20%.",
                                "Uso de exemplos e tabelas visuais: 15%.",
                                "Clareza na explicação oral/escrita: 10%.",
                                "Conexão com aplicações práticas: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Física: PVI em dinâmica (leis de Newton), PVC em equilíbrio térmico (equação de Laplace).",
                                "Engenharia: PVC em estruturas (vigas com suportes), PVI em controle (sistemas dinâmicos).",
                                "Computação: Algoritmos iterativos em PVC ligam a programação numérica e otimização.",
                                "Matemática Aplicada: Teoria de BVP conecta a análise funcional e PDEs."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, PVC modela distribuição de temperatura em uma barra com temperaturas fixas nas extremidades (isolamento térmico); PVI modela resfriamento temporal de um objeto exposto ao ar frio a partir de temperatura inicial."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Formulação Matemática Geral do PVC",
                        "description": "Estabelecer a notação e a estrutura matemática padrão para problemas de valor de contorno em EDOs, incluindo casos lineares e não lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Escrever a forma geral de um PVC linear de segunda ordem",
                            "description": "Formular y'' + p(x)y' + q(x)y = g(x), sujeito a y(a) = α e y(b) = β, e discutir condições para existência e unicidade de solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes de uma EDO linear de segunda ordem",
                                  "subSteps": [
                                    "Defina uma equação diferencial ordinária (EDO) de segunda ordem como uma equação envolvendo y'', y' e y.",
                                    "Explique que 'linear' significa ausência de produtos não-lineares ou funções não-lineares de y, y', y''.",
                                    "Identifique a forma padrão: y'' + p(x)y' + q(x)y = g(x), destacando os papéis de p(x), q(x) e g(x).",
                                    "Distinga casos homogêneos (g(x)=0) de não-homogêneos (g(x)≠0).",
                                    "Discuta o intervalo típico de definição, como um intervalo fechado [a,b]."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito os quatro componentes principais (y'', p(x)y', q(x)y, g(x)) e classifique exemplos como homogêneos ou não.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro-texto de Equações Diferenciais (capítulo sobre EDOs lineares)",
                                    "Bloco de notas e caneta",
                                    "Acesso a definições online ou slides de aula"
                                  ],
                                  "tips": "Sempre normalize dividindo pela coeficiente principal de y'' para obter a forma padrão com coeficiente 1.",
                                  "learningObjective": "Identificar e descrever precisamente os elementos constitutivos de uma EDO linear de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir linearidade com constância dos coeficientes (eles podem depender de x)",
                                    "Esquecer que g(x) determina se é homogênea",
                                    "Ignorar o domínio de x"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação diferencial geral y'' + p(x)y' + q(x)y = g(x)",
                                  "subSteps": [
                                    "Escreva a equação na forma padrão assumindo o coeficiente de y'' igual a 1.",
                                    "Descreva p(x) como coeficiente do termo derivada primeira, q(x) do termo y, e g(x) do lado direito.",
                                    "Forneça um exemplo homogêneo: y'' + 2y' + y = 0.",
                                    "Forneça um exemplo não-homogêneo: y'' + y = sin(x).",
                                    "Verifique se a equação está na forma canônica comparando com definições padrão."
                                  ],
                                  "verification": "Escreva duas instâncias da equação geral (uma homogênea e uma não) e rotule p(x), q(x), g(x) em cada uma.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplos de livro-texto ou Wolfram Alpha para verificação rápida"
                                  ],
                                  "tips": "Use sublinhados ou setas para anotar cada coeficiente ao escrever a equação.",
                                  "learningObjective": "Construir e anotar corretamente a equação diferencial linear de segunda ordem em forma padrão.",
                                  "commonMistakes": [
                                    "Escrever y'' = ... em vez da forma padrão",
                                    "Confundir p(x) com q(x)",
                                    "Omitir dependência de x nos coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar as condições de contorno y(a) = α e y(b) = β",
                                  "subSteps": [
                                    "Defina Problema de Valor de Contorno (PVC) como condições de contorno especificadas em pontos distintos a < b.",
                                    "Escreva as condições: y(a) = α (valor inicial em x=a) e y(b) = β (valor final em x=b).",
                                    "Justifique a necessidade de exatamente duas condições para EDO de segunda ordem.",
                                    "Compare com Problema de Valor Inicial (PVI), onde condições são em um mesmo ponto.",
                                    "Escreva o PVC completo combinando equação diferencial e condições."
                                  ],
                                  "verification": "Formule um PVC completo para um exemplo dado, como y'' + y = 0 com y(0)=1, y(π)=0.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Folha de exercícios com exemplos de PVCs",
                                    "Calculadora gráfica para plotar soluções conhecidas"
                                  ],
                                  "tips": "Garanta que a < b e que α, β sejam números reais ou funções consistentes.",
                                  "learningObjective": "Integrar corretamente as condições de contorno à equação diferencial para definir um PVC completo.",
                                  "commonMistakes": [
                                    "Usar condições em um mesmo ponto (confundindo com PVI)",
                                    "Especificar condições para y' em vez de y",
                                    "Não especificar o intervalo [a,b]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir condições de existência e unicidade de solução",
                                  "subSteps": [
                                    "Enuncie o teorema: Se p(x), q(x), g(x) são contínuos em [a,b], existe uma única solução y(x) ∈ C²[a,b] satisfazendo o PVC.",
                                    "Explique que continuidade garante existência via Teorema de Green ou métodos de diferença finita.",
                                    "Discuta falhas: Se p ou q tem descontinuidade, pode não haver unicidade (ex: singularidades).",
                                    "Forneça contraexemplo: y'' + (1/x)y = 0 em [0,1] falha em x=0.",
                                    "Verifique condições para um exemplo dado."
                                  ],
                                  "verification": "Para uma equação dada, identifique se p,q,g são contínuos em [a,b] e conclua sobre existência/unicidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto (seção de Teoremas para PVCs)",
                                    "Notas sobre teoremas de Picard-Lindelöf adaptados para PVC"
                                  ],
                                  "tips": "Lembre-se: Para PVCs lineares, continuidade basta; não-linearidades exigem Lipschitz.",
                                  "learningObjective": "Aplicar e discutir teoremas de existência e unicidade para PVCs lineares de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir condições de PVI com PVC",
                                    "Afirmar unicidade sem continuidade",
                                    "Ignorar o espaço de soluções C²"
                                  ]
                                }
                              ],
                              "practicalExample": "Formule o PVC: y'' + 4y' + 4y = e^{-2x}, sujeito a y(0) = 1 e y(1) = 2. Aqui, p(x)=4, q(x)=4, g(x)=e^{-2x}, a=0, α=1, b=1, β=2. Como p,q,g são contínuos em [0,1], existe solução única.",
                              "finalVerifications": [
                                "Escreve corretamente y'' + p(x)y' + q(x)y = g(x)?",
                                "Inclui y(a)=α e y(b)=β com a < b?",
                                "Identifica p(x), q(x), g(x) em exemplos?",
                                "Enuncia condições de continuidade para existência/unicidade?",
                                "Fornece contraexemplo onde teorema falha?",
                                "Distingue PVC de PVI?"
                              ],
                              "assessmentCriteria": [
                                "Equação diferencial na forma padrão exata (coeficiente de y''=1).",
                                "Condições de contorno corretamente especificadas e consistentes.",
                                "Identificação precisa de p(x), q(x), g(x).",
                                "Enunciado correto do teorema de existência/unicidade.",
                                "Explicação clara de continuidade em [a,b].",
                                "Uso apropriado de exemplos e contraexemplos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem da equação do calor ou onda com condições de Dirichlet em extremidades.",
                                "Engenharia Mecânica: Análise de deflexão em vigas com apoios fixos.",
                                "Computação Científica: Implementação de métodos numéricos como diferenças finitas para PVCs.",
                                "Economia: Modelos dinâmicos com restrições de fronteira em otimização."
                              ],
                              "realWorldApplication": "Em engenharia civil, PVCs lineares de segunda ordem modelam a deflexão de vigas sob carga distribuída, com y(a)=0 e y(b)=0 representando apoios fixos, permitindo calcular tensões e dimensionar estruturas seguras."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Descrever PVCs não lineares e em sistemas",
                            "description": "Apresentar a generalização para y'' = f(x, y, y') não linear ou sistemas acoplados Y'' = F(x, Y, Y'), com condições de contorno em Y(a) e Y(b).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Problemas de Valor de Contorno (PVCs) Lineares Simples",
                                  "subSteps": [
                                    "Relembrar a forma padrão de um PVC linear de segunda ordem: y'' = f(x, y, y') onde f é linear em y e y'.",
                                    "Discutir condições de contorno separadas: y(a) = α e y(b) = β.",
                                    "Exemplificar com um caso linear simples, como y'' + y = 0 com y(0)=0, y(π)=0.",
                                    "Identificar por que a linearidade facilita soluções analíticas ou numéricas.",
                                    "Comparar com EDOs de valor inicial para destacar diferenças."
                                  ],
                                  "verification": "Escrever corretamente a forma linear geral e resolver um exemplo simples manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, software de álgebra simbólica como Mathematica ou Python com SymPy.",
                                  "tips": "Sempre normalize as condições de contorno para intervalos [0,1] para facilitar comparações.",
                                  "learningObjective": "Compreender a base linear para contrastar com casos não-lineares.",
                                  "commonMistakes": "Confundir condições de contorno com condições iniciais; ignorar dependência explícita em x."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Generalização para Equações Não-Lineares Escalares",
                                  "subSteps": [
                                    "Apresentar a forma geral não-linear: y'' = f(x, y, y'), onde f não é linear em y ou y'.",
                                    "Explicar que a não-linearidade surge de termos como y * y' ou sin(y).",
                                    "Discutir implicações: ausência de superposição e necessidade de métodos numéricos iterativos.",
                                    "Formular um exemplo concreto: y'' = y'^2 - y com y(0)=1, y(1)=2.",
                                    "Derivar verbalmente por que soluções analíticas são raras."
                                  ],
                                  "verification": "Escrever a equação não-linear geral e identificar termos não-lineares em um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Quadro branco ou papel, exemplos impressos de EDOs não-lineares.",
                                  "tips": "Use expansões em série ou aproximações lineares locais para ganhar intuição.",
                                  "learningObjective": "Dominar a notação e características de PVCs não-lineares escalares.",
                                  "commonMistakes": "Assumir linearidade em funções compostas; esquecer dependência em y'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Sistemas Acoplados de Equações",
                                  "subSteps": [
                                    "Definir notação vetorial: Y = (y1, y2, ..., yn), Y'' = F(x, Y, Y'), onde F é vetor de funções não-lineares.",
                                    "Explicar acoplamento: cada componente yi'' depende de todo o vetor Y e Y'.",
                                    "Apresentar exemplo de sistema 2D: y1'' = y1 * y2, y2'' = -y1 / y2 com condições em Y(0) e Y(1).",
                                    "Discutir dimensionalidade: n equações de 2ª ordem equivalem a 2n de 1ª ordem.",
                                    "Comparar com escalar: maior complexidade computacional."
                                  ],
                                  "verification": "Escrever a forma matricial geral para um sistema de 2 equações e identificar acoplamentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com MATLAB ou Python (NumPy/SciPy), notas de aula.",
                                  "tips": "Pense em Y como posição em espaço de fase multidimensional.",
                                  "learningObjective": "Formular PVCs em sistemas não-lineares acoplados.",
                                  "commonMistakes": "Confundir Y'' com derivadas escalares; omitir vetores nas condições de contorno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Especificar Condições de Contorno para Casos Gerais",
                                  "subSteps": [
                                    "Definir condições gerais: Y(a) = α (vetor), Y(b) = β (vetor).",
                                    "Discutir tipos: Dirichlet (valores), Neumann (derivadas), mistas ou não-lineares.",
                                    "Exemplificar para não-lineares: y(a)^2 + y'(a) = 0.",
                                    "Explicar unicidade e existência: teoremas como shooting method assumem Lipschitz.",
                                    "Resumir formulação completa: equação + condições em extremos."
                                  ],
                                  "verification": "Redigir um PVC completo não-linear em sistema com condições corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de análise numérica (ex: Burden & Faires), editor de texto.",
                                  "tips": "Sempre especifique o domínio [a,b] e verifique consistência das BCs.",
                                  "learningObjective": "Integrar equações e condições de contorno em formulações gerais.",
                                  "commonMistakes": "Aplicar condições iniciais em PVCs; ignorar não-linearidade nas BCs."
                                }
                              ],
                              "practicalExample": "Considere o sistema não-linear modelando uma viga elastica: y1'' = -k * y1 * (1 + y2'^2), y2'' = m * y1 * y2 com Y(0) = [0,1], Y(1) = [0,1.5], representando deflexão e rotação acopladas.",
                              "finalVerifications": [
                                "Escrever corretamente y'' = f(x,y,y') e Y'' = F(x,Y,Y').",
                                "Identificar não-linearidades em exemplos dados.",
                                "Formular condições de contorno vetoriais Y(a)=α, Y(b)=β.",
                                "Explicar diferenças entre linear, não-linear escalar e sistemas.",
                                "Desenhar diagrama conceitual da generalização.",
                                "Resolver trivialmente um caso linear para contraste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática geral (100% corretude).",
                                "Capacidade de identificar e exemplificar não-linearidades (exemplos relevantes).",
                                "Clareza na distinção entre casos escalar e vetorial.",
                                "Compreensão de implicações numéricas (mencionar iterações).",
                                "Correta formulação de condições de contorno.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores não-lineares e mecânica de sólidos.",
                                "Engenharia: Análise estrutural de vigas e cascas deformáveis.",
                                "Computação: Implementação de métodos de tiro (shooting) em Python/MATLAB.",
                                "Física Computacional: Simulações de sistemas dinâmicos acoplados."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, formulação de PVCs não-lineares descreve deformações de asas flexíveis sob carga aerodinâmica, permitindo simulações precisas para design de aeronaves estáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Classificar tipos de condições de contorno",
                            "description": "Diferenciar condições de Dirichlet (valores de y), Neumann (valores de y') e mistas (Robin: αy + βy' = γ), aplicadas em pontos distintos a e b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a formulação geral do Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Revise a equação diferencial de segunda ordem: y''(x) + p(x)y'(x) + q(x)y(x) = g(x), para x em [a, b].",
                                    "Identifique que as condições de contorno são restrições impostas nos extremos x=a e x=b para garantir unicidade da solução.",
                                    "Classifique condições como homogêneas (γ=0) ou não-homogêneas (γ≠0).",
                                    "Discuta a importância de condições em pontos distintos a e b para problemas de contorno.",
                                    "Esboce um gráfico ilustrando y(a), y'(a), y(b), y'(b)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a estrutura geral do PVC e aponte onde as condições de contorno são aplicadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Análise Numérica, papel e caneta para esboços.",
                                  "tips": "Sempre relacione a equação diferencial com as condições para visualizar o problema completo.",
                                  "learningObjective": "Compreender o contexto matemático das condições de contorno no PVC.",
                                  "commonMistakes": "Confundir PVC com PVI (problemas de valor inicial, que usam condições em t=0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e identificar condições de Dirichlet",
                                  "subSteps": [
                                    "Defina condição de Dirichlet: y(a) = α ou y(b) = β, onde se especifica o valor da função y.",
                                    "Escreva exemplos: y(0) = 1 (em x=a=0) e y(π) = 0 (em x=b=π).",
                                    "Diferencie de condições que envolvem derivadas.",
                                    "Resolva um PVC simples com Dirichlet para observar o comportamento.",
                                    "Classifique 3 exemplos dados como Dirichlet ou não."
                                  ],
                                  "verification": "Classifique corretamente 3 condições dadas como Dirichlet e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora gráfica ou software como MATLAB/Octave, exemplos impressos.",
                                  "tips": "Lembre-se: Dirichlet fixa o 'valor' da solução, não a 'inclinação'.",
                                  "learningObjective": "Reconhecer e formular condições de Dirichlet em PVCs.",
                                  "commonMistakes": "Confundir y(a)=α com y'(a)=α (que é Neumann)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e identificar condições de Neumann e Robin (mistas)",
                                  "subSteps": [
                                    "Defina Neumann: y'(a) = α ou y'(b) = β, especificando a derivada (fluxo ou inclinação).",
                                    "Defina Robin: α y(a) + β y'(a) = γ ou similar em b, combinação linear.",
                                    "Compare: Neumann é caso especial de Robin com α=0; Dirichlet com β=0.",
                                    "Escreva exemplos: y'(0)=0 (Neumann homogêneo) e y(π) + y'(π)=1 (Robin).",
                                    "Identifique em 4 problemas mistos quais pontos usam cada tipo."
                                  ],
                                  "verification": "Forneça definições precisas e classifique 4 condições como Neumann ou Robin.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folhas de exercícios com problemas variados, lápis para anotações.",
                                  "tips": "Use a forma geral αy + βy' = γ para unificar todas as classificações.",
                                  "learningObjective": "Diferenciar Neumann e Robin das demais condições.",
                                  "commonMistakes": "Ignorar coeficientes α, β em Robin, tratando como Dirichlet puro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação completa em PVCs reais",
                                  "subSteps": [
                                    "Analise PVCs completos: identifique condições em a e b separadamente.",
                                    "Classifique pares de condições: (Dirichlet-Dirichlet), (Neumann-Robin), etc.",
                                    "Crie seu próprio PVC com condições mistas e classifique.",
                                    "Discuta quando cada tipo é usado (ex: Dirichlet para temperaturas fixas).",
                                    "Resolva numericamente um exemplo para validar classificação."
                                  ],
                                  "verification": "Classifique corretamente 5 PVCs completos, especificando tipos em a e b.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software numérico (Python com SciPy ou Excel), lista de PVCs de exemplo.",
                                  "tips": "Sempre verifique se condições são aplicadas em pontos distintos a ≠ b.",
                                  "learningObjective": "Aplicar classificação em contextos reais de PVC.",
                                  "commonMistakes": "Classificar o par inteiro sem especificar por ponto (a vs b)."
                                }
                              ],
                              "practicalExample": "Considere o PVC: y'' + y = 0, x ∈ [0, π], com y(0) = 0 (Dirichlet em a=0) e y'(π) + y(π) = 1 (Robin em b=π). Classifique: Dirichlet em a, Robin em b.",
                              "finalVerifications": [
                                "Classifica corretamente 90% de 10 condições isoladas como Dirichlet, Neumann ou Robin.",
                                "Identifica tipos em pontos a e b para 5 PVCs completos sem erros.",
                                "Explica diferenças matemáticas e físicas entre os tipos.",
                                "Formula uma condição Robin genérica a partir de parâmetros α, β, γ.",
                                "Detecta condições mal postas (ex: duas Neumann sem compatibilidade)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: 30% (definições exatas sem ambiguidades).",
                                "Classificação correta: 40% (acertos em exemplos variados).",
                                "Justificativa clara: 15% (explicações lógicas e concisas).",
                                "Aplicação contextual: 10% (relaciona a usos reais).",
                                "Criatividade em exemplos: 5% (gera casos próprios válidos)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Condições de Dirichlet para temperaturas fixas em condução de calor.",
                                "Engenharia: Neumann para fluxo de calor zero (isolamento).",
                                "Computação: Implementação em métodos numéricos como diferenças finitas.",
                                "Física Computacional: Robin em problemas de difusão com convecção."
                              ],
                              "realWorldApplication": "Em simulações de transferência de calor em uma barra metálica, usa-se Dirichlet nas extremidades com temperatura fixa (ex: 100°C) e Neumann no meio para zero fluxo, permitindo modelar fornos industriais ou dissipadores de calor em eletrônicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Exemplos e Aplicações do PVC",
                        "description": "Reconhecer exemplos concretos de PVCs e sua relevância em modelagem física, ilustrando a formulação matemática.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Formular o problema da viga de Euler-Bernoulli como PVC",
                            "description": "Derivar EI y'''' = q(x), com condições de contorno em y e y' em x=0 e x=L, reduzindo a segunda ordem via substituição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o modelo físico da viga de Euler-Bernoulli",
                                  "subSteps": [
                                    "Revise os pressupostos do modelo: viga reta, seção transversal constante, material linear elástico, deformações pequenas.",
                                    "Identifique as variáveis principais: y(x) como deslocamento vertical, E módulo de elasticidade, I momento de inércia, q(x) carga distribuída.",
                                    "Desenhe um diagrama esquemático da viga com comprimento L, apoios em x=0 e x=L.",
                                    "Explique o equilíbrio de momentos e forças que leva à relação entre curvatura e momento fletor.",
                                    "Relacione a curvatura y''(x) ≈ M(x)/EI, onde M é o momento fletor."
                                  ],
                                  "verification": "Desenhe o diagrama da viga e liste corretamente os 4 pressupostos principais sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para diagrama, livro de mecânica dos materiais ou notas de aula.",
                                  "tips": "Comece pelo diagrama livre-corpo para visualizar forças e momentos.",
                                  "learningObjective": "Compreender os fundamentos físicos que justificam a equação diferencial da viga.",
                                  "commonMistakes": "Confundir deslocamento y com rotação y'; ignorar pressuposto de deformações pequenas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação diferencial de quarta ordem",
                                  "subSteps": [
                                    "Comece com a relação momento-curvatura: M(x) = -EI y''(x).",
                                    "Derive a relação cisalhante: V(x) = dM/dx = -EI y'''(x).",
                                    "Aplique equilíbrio de forças verticais: dV/dx = -q(x), levando a EI y''''(x) = q(x).",
                                    "Verifique a equação para uma carga pontual ou distribuída simples.",
                                    "Escreva a equação geral: EI y''''(x) = q(x), assumindo EI constante."
                                  ],
                                  "verification": "Derive a equação passo a passo e confirme EI y'''' = q(x) para q(x) constante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno para derivações, calculadora simbólica ou software como Mathematica (opcional).",
                                  "tips": "Use convenções de sinal consistentes: positivo para carga descendente e deslocamento descendente.",
                                  "learningObjective": "Derivar matematicamente a equação governante de quarta ordem a partir do equilíbrio.",
                                  "commonMistakes": "Erro no sinal do momento fletor; esquecer o negativo em M = -EI y''."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar as condições de contorno",
                                  "subSteps": [
                                    "Para viga engastada em ambas as extremidades: y(0) = 0, y'(0) = 0, y(L) = 0, y'(L) = 0.",
                                    "Explique o significado físico: y=0 (deslocamento nulo), y'=0 (rotação nula).",
                                    "Discuta outras condições comuns: viga biapoiada (y(0)=y(L)=0, y''(0)=y''(L)=0).",
                                    "Escreva as condições como PVC de quarta ordem com 4 condições.",
                                    "Verifique dimensionalidade: 4 condições para EDO de ordem 4."
                                  ],
                                  "verification": "Liste as 4 condições de contorno corretas para viga engastada e justifique fisicamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama da viga do Step 1, tabela de condições de contorno padrão.",
                                  "tips": "Lembre: condições de Dirichlet para deslocamento, Neumann para rotação.",
                                  "learningObjective": "Definir precisamente as condições de contorno para o PVC.",
                                  "commonMistakes": "Confundir y'' com momento em apoios simples; usar apenas 2 condições."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reduzir a equação de quarta ordem para sistema de segunda ordem via substituição",
                                  "subSteps": [
                                    "Introduza substituições: defina u(x) = y(x), v(x) = y'(x), w(x) = y''(x).",
                                    "Ou mais eficientemente: defina z1(x) = y(x), z2(x) = y''(x), levando a sistema z1'' = z2, z2'' = q(x)/EI.",
                                    "Escreva o sistema: z1'' = z2, EI z2'' = q(x), com condições z1(0)=0, z1'(0)=0, z1(L)=0, z1'(L)=0 implicando z2(0) e z2(L) via integração.",
                                    "Ajuste condições para z: tipicamente z1(0)=z1(L)=0, z2(0)=z2(L)=0 para aproximações.",
                                    "Verifique que o sistema é equivalente à EDO original de 4a ordem."
                                  ],
                                  "verification": "Escreva o sistema de 2 EDOs de 2a ordem com condições de contorno correspondentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno para sistema, software de álgebra computacional para verificação.",
                                  "tips": "Escolha substituição que preserve simetria; teste com q(x)=0 para solução trivial y=0.",
                                  "learningObjective": "Transformar PVC de 4a ordem em sistema de PVCs de 2a ordem para métodos numéricos.",
                                  "commonMistakes": "Perder condições de contorno na redução; não dividir por EI corretamente."
                                }
                              ],
                              "practicalExample": "Para uma viga engastada de L=1m, EI=1, q(x)=1 (carga uniforme), formule: EI y''''=1, y(0)=y'(0)=y(L)=y'(L)=0. Reduza para z1''=z2, z2''=1/EI, z1(0)=z1(L)=0, z1'(0)=z1'(L)=0.",
                              "finalVerifications": [
                                "Equação derivada corretamente como EI y''''(x) = q(x).",
                                "Quatro condições de contorno especificadas corretamente para viga engastada.",
                                "Sistema de segunda ordem escrito equivalentemente com substituições adequadas.",
                                "Solução trivial y=0 verificada para q(x)=0.",
                                "Dimensionalidade do PVC confirmada (4 condições para ordem 4).",
                                "Exemplo prático resolvido sem erros algébricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da EDO (sem erros de sinal ou diferenciação).",
                                "Correção das condições de contorno e interpretação física.",
                                "Validade da redução de ordem (sistema equivalente).",
                                "Clareza na documentação dos passos e subpassos.",
                                "Aplicação correta no exemplo prático com valores numéricos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica dos sólidos e equilíbrio de forças.",
                                "Engenharia Civil: Análise estrutural de vigas e lajes.",
                                "Computação: Preparação para métodos numéricos como diferenças finitas ou elementos finitos.",
                                "Matemática Aplicada: Teoria de EDOs e PVCs em contextos contínuos."
                              ],
                              "realWorldApplication": "Formulação essencial para simulações numéricas em softwares como ANSYS ou MATLAB para projetar vigas em pontes, edifícios e máquinas, prevendo deflexões sob cargas reais como peso próprio ou vento."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Identificar o problema de valor de contorno no fluxo de calor estacionário",
                            "description": "Modelar -k u'' = f(x) em [a,b], com u(a)=α, u(b)=β, e relacionar com equações diferenciais de segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto físico do fluxo de calor estacionário",
                                  "subSteps": [
                                    "Estudar a lei de Fourier para condução de calor: q = -k ∇u, onde u é a temperatura.",
                                    "Visualizar uma barra unidimensional [a,b] com fluxo axial estacionário (sem variação temporal).",
                                    "Identificar que em regime estacionário, o calor entrando em um ponto equals o saindo mais fontes internas.",
                                    "Analisar o balanço de energia em um elemento infinitesimal dx.",
                                    "Diferenciar fluxo estacionário de transitório."
                                  ],
                                  "verification": "Descrever em palavras o cenário físico e desenhar um diagrama da barra com temperaturas nas extremidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Física (ex: Halliday) ou notas de Análise Numérica",
                                    "Papel e lápis para diagrama"
                                  ],
                                  "tips": "Pense na barra como uma estrada reta onde o tráfego de calor é constante em cada ponto.",
                                  "learningObjective": "Entender os princípios físicos que levam à modelagem matemática do problema.",
                                  "commonMistakes": "Confundir regime estacionário com não-estacionário, incluindo derivada temporal ∂u/∂t."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação diferencial do problema",
                                  "subSteps": [
                                    "Aplicar balanço de calor: d/dx [-k du/dx] dx = f(x) dx, onde f(x) é fonte de calor por unidade de volume.",
                                    "Simplificar para k constante: -k u''(x) = f(x).",
                                    "Verificar unidades: u em °C, x em m, k em W/m°C, f em W/m³.",
                                    "Escrever a equação geral: -k u''(x) = f(x) para x ∈ [a,b].",
                                    "Comparar com equações de Poisson para validação."
                                  ],
                                  "verification": "Derivar a equação a partir do balanço e resolvê-la analiticamente para f(x)=0 (solução linear).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Calculadora para verificação numérica simples"
                                  ],
                                  "tips": "Use a regra da cadeia para fluxos: diferença finita em dx leva à segunda derivada.",
                                  "learningObjective": "Derivar a EDO de segunda ordem a partir do modelo físico.",
                                  "commonMistakes": "Esquecer o sinal negativo na lei de Fourier ou inverter o balanço de energia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e aplicar as condições de contorno",
                                  "subSteps": [
                                    "Reconhecer condições de Dirichlet: u(a) = α e u(b) = β (temperaturas fixas nas extremidades).",
                                    "Explicar por que são condições de valor de contorno (valores especificados nas fronteiras).",
                                    "Discutir alternativas como Neumann (fluxo especificado), mas focar em Dirichlet para este caso.",
                                    "Escrever o problema completo: -k u'' = f(x), u(a)=α, u(b)=β.",
                                    "Verificar unicidade da solução para problema elíptico."
                                  ],
                                  "verification": "Especificar α, β e f(x) para um exemplo e afirmar o problema BVP completo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha com exemplos de BVPs",
                                    "Software como GeoGebra para plotar soluções"
                                  ],
                                  "tips": "Lembre: contorno fecha o problema, garantindo solução única.",
                                  "learningObjective": "Distinguir condições de contorno e formular o BVP completo.",
                                  "commonMistakes": "Confundir com condições iniciais de problemas de valor inicial (IVP)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com equações diferenciais de segunda ordem gerais",
                                  "subSteps": [
                                    "Classificar como EDO linear de segunda ordem: Lu = f, onde L = -k d²/dx².",
                                    "Comparar com forma padrão: u'' + p(x)u' + q(x)u = g(x), aqui homogênea em coeficientes.",
                                    "Identificar como problema de valor de contorno (BVP) vs. valor inicial (IVP).",
                                    "Discutir existência e unicidade pelo teorema de Green ou energia.",
                                    "Aplicar a um exemplo numérico simples para confirmação."
                                  ],
                                  "verification": "Reescrever o problema na forma geral de BVP e citar teorema de existência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto de EDOs (ex: Boyce-DiPrima)",
                                    "Python/MATLAB para solução numérica básica"
                                  ],
                                  "tips": "Sempre normalize dividindo por -k para u'' = -f(x)/k.",
                                  "learningObjective": "Conectar o modelo físico à teoria de EDOs de segunda ordem.",
                                  "commonMistakes": "Ignorar que é linear e homogêneo em derivadas, ou confundir ordem da equação."
                                }
                              ],
                              "practicalExample": "Em uma barra de aço de 1m (k=50 W/m°C), extremidades a u(0)=0°C e u(1)=100°C, com fonte uniforme f(x)=100 W/m³. O BVP é -50 u''(x) = 100 em [0,1], u(0)=0, u(1)=100. Solução: u(x) = 2x² + 98x.",
                              "finalVerifications": [
                                "Derivação correta da equação -k u'' = f(x).",
                                "Identificação precisa das condições u(a)=α, u(b)=β.",
                                "Classificação como BVP linear de segunda ordem.",
                                "Solução analítica para caso f(x)=0 (perfil linear).",
                                "Explicação física do significado de cada termo.",
                                "Verificação numérica de um exemplo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação física-matemática (30%).",
                                "Correta formulação do BVP completo (25%).",
                                "Relacionamento claro com EDOs de 2ª ordem (20%).",
                                "Uso de exemplos concretos e verificações (15%).",
                                "Clareza na explicação e avoidance de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Lei de condução de calor de Fourier e balanço energético.",
                                "Engenharia Mecânica: Modelagem térmica em estruturas.",
                                "Computação Científica: Preparação para métodos numéricos como diferenças finitas.",
                                "Matemática Aplicada: Teoria de equações elípticas."
                              ],
                              "realWorldApplication": "Modelagem de perfis de temperatura em paredes isolantes de edifícios, dissipadores de calor em processadores de computadores ou tubos de calefação industrial, otimizando eficiência energética e prevenindo superaquecimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Analisar desafios numéricos iniciais em PVCs",
                            "description": "Discutir por que métodos de PVI (como Runge-Kutta) não se aplicam diretamente a PVCs e introduzir necessidade de métodos como tiro ou diferenças finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos numéricos para Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Definir PVI: condições iniciais fornecidas em um único ponto (ex: y(0) e y'(0)).",
                                    "Descrever métodos de marcha para frente, como Euler e Runge-Kutta de ordem 4.",
                                    "Resolver um exemplo simples: y' = -y, y(0)=1, aplicando Runge-Kutta manualmente para 2-3 passos.",
                                    "Analisar estabilidade e precisão desses métodos em PVIs.",
                                    "Visualizar graficamente a solução numérica vs. analítica."
                                  ],
                                  "verification": "Resolver um PVI simples com Runge-Kutta e comparar com solução exata, com erro < 1%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), Python ou MATLAB com bibliotecas scipy.integrate.",
                                  "tips": "Comece com passos pequenos (h=0.1) para visualizar a convergência.",
                                  "learningObjective": "Compreender como métodos de PVI propagam soluções a partir de condições iniciais.",
                                  "commonMistakes": "Confundir condições iniciais com condições de contorno; ignorar requisitos de valores iniciais para derivadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição e diferenças dos Problemas de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Definir PVC: condições especificadas em pontos distintos do domínio (ex: y(a) e y(b)).",
                                    "Classificar PVCs lineares e não-lineares, de segunda ordem.",
                                    "Apresentar exemplo clássico: y'' + y = 0, y(0)=0, y(π)=0.",
                                    "Comparar graficamente PVI vs. PVC: direção de integração vs. condições separadas.",
                                    "Discutir unicidade e existência de soluções via teorema de Sturm-Liouville."
                                  ],
                                  "verification": "Esboçar o domínio de um PVC e identificar onde as condições são aplicadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software GeoGebra ou Desmos para gráficos.",
                                  "tips": "Desenhe setas indicando direção de integração para destacar o problema das condições finais.",
                                  "learningObjective": "Identificar as características únicas dos PVCs em relação aos PVIs.",
                                  "commonMistakes": "Assumir que condições de contorno podem ser usadas como iniciais; ignorar não-linearidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar limitações dos métodos de PVI em PVCs",
                                  "subSteps": [
                                    "Tentar aplicar Runge-Kutta em um PVC: falta y'(a) para iniciar a integração.",
                                    "Explicar o problema do 'tiro cego': necessidade de adivinhar valor inicial para acertar condição final.",
                                    "Simular numericamente: integrar com suposições erradas e medir erro na condição final.",
                                    "Discutir sensibilidade: pequenas mudanças no chute inicial causam grandes desvios.",
                                    "Calcular erro para diferentes chutes iniciais em um exemplo simples."
                                  ],
                                  "verification": "Demonstrar falha prática: integração resulta em y(b) ≠ condição especificada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Script Python/MATLAB para simulação de Runge-Kutta em PVC exemplo.",
                                  "tips": "Use gráficos de y(b) vs. chute inicial para visualizar a necessidade de iteração.",
                                  "learningObjective": "Reconhecer por que métodos de PVI falham diretamente em PVCs.",
                                  "commonMistakes": "Aplicar método sem notar ausência de derivada inicial; subestimar sensibilidade numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir métodos adequados para PVCs: Tiro e Diferenças Finitas",
                                  "subSteps": [
                                    "Descrever método do tiro simples: iteração de chutes até y(b) satisfazer condição.",
                                    "Explicar método do tiro múltiplo para sistemas ou não-lineares.",
                                    "Introduzir diferenças finitas: discretizar equação diferencial em malha uniforme.",
                                    "Comparar convergência: ordem de precisão e custo computacional.",
                                    "Implementar esboço de diferenças finitas para y'' + p(x)y' + q(x)y = g(x)."
                                  ],
                                  "verification": "Esboçar algoritmo do método do tiro e resolver PVC toy com 2 iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código-fonte exemplo em Python (numpy para diferenças finitas), quadro branco.",
                                  "tips": "Comece com PVC linear para método do tiro; use relaxação para diferenças finitas.",
                                  "learningObjective": "Conhecer alternativas viáveis e suas motivações para PVCs.",
                                  "commonMistakes": "Confundir tiro simples com múltiplo; malha inadequada em diferenças finitas."
                                }
                              ],
                              "practicalExample": "Considere o PVC y'' + y = 0, y(0)=0, y(1)=sin(1). Tente Runge-Kutta com y'(0)=1 (chute errado): solução numérica dá y(1)≈0.84 ≠ sin(1)≈0.84 (ajuste necessário). Aplique método do tiro: itere y'(0) até convergência. Alternativa: discretize com diferenças finitas em 10 pontos e resolva sistema linear.",
                              "finalVerifications": [
                                "Explicar verbalmente por que Runge-Kutta requer condições iniciais completas.",
                                "Identificar em um exemplo dado se é PVI ou PVC.",
                                "Simular falha de PVI em PVC com código simples.",
                                "Descrever passos do método do tiro.",
                                "Esboçar malha de diferenças finitas para PVC de segunda ordem.",
                                "Comparar prós/contras de tiro vs. diferenças finitas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção PVI vs. PVC (90% correto).",
                                "Demonstração prática de falha numérica em PVI para PVC.",
                                "Descrição clara das limitações e soluções alternativas.",
                                "Uso correto de terminologia (tiro, diferenças finitas).",
                                "Análise qualitativa de sensibilidade e convergência.",
                                "Implementação básica de um método em código ou manual."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações diferenciais em mecânica quântica e ondas.",
                                "Engenharia: Análise de estruturas elásticas e perfis de tensão em vigas.",
                                "Computação: Desenvolvimento de solvers numéricos e otimização iterativa.",
                                "Física Computacional: Simulações em dinâmica de fluidos com condições de contorno."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, simular deformações em vigas com condições de apoio fixo (y(0)=0, y(L)=0); em transferência de calor, perfis de temperatura em placas com bordas fixas; em finanças, resolver equações diferenciais para precificação de opções com condições de contorno no tempo de expiração."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Método de Tiro Simples",
                    "description": "Transformação do problema de valor de contorno em um problema de valor inicial resolvido iterativamente para satisfazer as condições de contorno.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Transformação do Problema de Valor de Contorno em Problema de Valor Inicial",
                        "description": "Entender como converter um problema de valor de contorno (BVP) de segunda ordem em um sistema de equações diferenciais de primeira ordem com condições iniciais parametrizadas, permitindo a aplicação iterativa para satisfazer a condição final.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Formular o BVP como sistema de EDOs de primeira ordem",
                            "description": "Dado um BVP y'' = f(x, y, y'), y(a) = α, y(b) = β, transformar em sistema {u' = v, v' = f(x, u, v)}, com condições iniciais u(a) = α, v(a) = s (parâmetro a estimar).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar o Problema de Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Leia a equação diferencial dada: y'' = f(x, y, y') com condições y(a) = α e y(b) = β.",
                                    "Identifique a ordem da equação (segunda ordem) e as condições de contorno em pontos diferentes (a e b).",
                                    "Anote as variáveis dependentes (y), independentes (x) e derivadas envolvidas (y', y'').",
                                    "Verifique se f(x, y, y') é uma função conhecida e diferenciável.",
                                    "Esboce graficamente o problema para visualizar as condições de contorno."
                                  ],
                                  "verification": "Lista completa das componentes do BVP anotada corretamente, incluindo ordem e condições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de equações como MathType ou LaTeX editor"
                                  ],
                                  "tips": "Sempre comece pelo geral: ordem, condições e forma de f.",
                                  "learningObjective": "Compreender a estrutura padrão de um BVP de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com de contorno",
                                    "Ignorar dependências em f(x,y,y')"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir substituições para redução de ordem",
                                  "subSteps": [
                                    "Defina u(x) = y(x), de modo que u represente a função original.",
                                    "Defina v(x) = y'(x) = u'(x), introduzindo v como a derivada primeira.",
                                    "Observe que y'' = v' = u''.",
                                    "Substitua na equação original: v' = f(x, u, v).",
                                    "Confirme que agora temos equações de primeira ordem em u e v."
                                  ],
                                  "verification": "Substituições u=y e v=y' definidas explicitamente e y'' substituído por v'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de rascunho",
                                    "Calculadora simbólica como Wolfram Alpha para verificação opcional"
                                  ],
                                  "tips": "Pense em v como 'velocidade' se y for 'posição' para intuição física.",
                                  "learningObjective": "Dominar a técnica de redução de ordem via substituição de variáveis.",
                                  "commonMistakes": [
                                    "Esquecer que v = u'",
                                    "Não derivar v explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever o sistema de EDOs de primeira ordem",
                                  "subSteps": [
                                    "Escreva a primeira equação: u' = v.",
                                    "Escreva a segunda equação: v' = f(x, u, v).",
                                    "Forme o sistema vetorial: [u', v'] = [v, f(x,u,v)].",
                                    "Verifique a dimensionalidade: duas equações para duas incógnitas (u,v).",
                                    "Teste com a função f dada para garantir consistência."
                                  ],
                                  "verification": "Sistema escrito como {u' = v, v' = f(x,u,v)} sem erros de substituição.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Exemplos de livros de EDOs"
                                  ],
                                  "tips": "Use notação vetorial para clareza: U' = F(X,U) onde U=[u,v].",
                                  "learningObjective": "Construir corretamente o sistema equivalente de primeira ordem.",
                                  "commonMistakes": [
                                    "Invertar u e v",
                                    "Manter y'' em vez de v'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir as condições iniciais para o PVI equivalente",
                                  "subSteps": [
                                    "Estabeleça u(a) = y(a) = α (condição conhecida).",
                                    "Introduza v(a) = s, onde s é o parâmetro desconhecido a estimar (derivada inicial estimada).",
                                    "Note que y(b) = β será satisfeita ajustando s via método de tiro.",
                                    "Escreva as condições: u(a) = α, v(a) = s.",
                                    "Discuta o papel de s no método de tiro simples."
                                  ],
                                  "verification": "Condições iniciais corretas: u(a)=α, v(a)=s com s como parâmetro.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resumo do método de tiro",
                                    "Gráfico de solução aproximada"
                                  ],
                                  "tips": "Lembre-se: BVP vira PVI em x=a, mas com extra parâmetro s.",
                                  "learningObjective": "Transformar condições de contorno em iniciais parametrizadas.",
                                  "commonMistakes": [
                                    "Usar y(b)=β como inicial",
                                    "Esquecer s como estimável"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y'' = -y com y(0)=0, y(π)=0: defina u=y, v=y'; sistema {u'=v, v'=-u}, u(0)=0, v(0)=s. Solução verdadeira implica s=1 para y=sin(x).",
                              "finalVerifications": [
                                "Sistema tem exatamente duas EDOs de primeira ordem: u'=v e v'=f(x,u,v).",
                                "Substituições u=y e v=y' estão corretas e consistentes.",
                                "Condições iniciais: u(a)=α e v(a)=s (s parametrizado).",
                                "Dimensão do sistema bate com ordem original (2 eqs para ordem 2).",
                                "f é corretamente expressa em termos de x,u,v.",
                                "Preparado para integração numérica no método de tiro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na redução de ordem (u=y, v=y').",
                                "Correta formulação do sistema {u'=v, v'=f}.",
                                "Identificação adequada do parâmetro s em v(a)=s.",
                                "Consistência com condições de contorno originais.",
                                "Clareza na escrita matemática (notação limpa).",
                                "Capacidade de aplicar a um exemplo concreto."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores ou trajetórias com EDOs de segunda ordem.",
                                "Computação: Preparação para solvers numéricos como Runge-Kutta em Python/MATLAB.",
                                "Engenharia: Problemas de deflexão de vigas ou circuitos com contornos.",
                                "Estatística: Inferência paramétrica via estimação de s."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, formula BVP para perfis aerodinâmicos (y''=f(x,y,y') modela curvatura), transformando em sistema para simulações numéricas de fluxo, estimando inclinação inicial s para matching de condições finais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Identificar a condição de contorno residual",
                            "description": "Definir a função residual φ(s) = u(b; s) - β, onde u(b; s) é a solução do IVP com parâmetro inicial s, que deve ser zerada iterativamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema de Valor de Contorno e Transformação para IVP",
                                  "subSteps": [
                                    "Identifique o BVP geral: Lu = f em [a,b] com u(a) = α e u(b) = β.",
                                    "Explique por que usamos um parâmetro inicial s, tipicamente u'(a) = s para problemas de segunda ordem.",
                                    "Descreva como o IVP é: Lu = f com u(a) = α, u'(a) = s."
                                  ],
                                  "verification": "Escreva o IVP parametrizado para um BVP exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre método de tiro",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Sempre fixe a condição em x=a e parametrize a derivada inicial.",
                                  "learningObjective": "Compreender a motivação e setup inicial da transformação.",
                                  "commonMistakes": [
                                    "Esquecer de incluir todas as condições iniciais necessárias para o IVP.",
                                    "Confundir o parâmetro s com a condição u(b)=β."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o IVP para Obter u(b; s)",
                                  "subSteps": [
                                    "Escolha um método numérico para resolver o IVP (ex: Runge-Kutta).",
                                    "Implemente ou simule a solução u(x; s) até x=b.",
                                    "Registre u(b; s) como função do parâmetro s."
                                  ],
                                  "verification": "Para um s dado, compute numericamente u(b; s) e verifique contra solução analítica se possível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software numérico (Python/MATLAB com scipy.integrate)",
                                    "Exemplo de BVP simples"
                                  ],
                                  "tips": "Use passos pequenos no integrador para precisão em b.",
                                  "learningObjective": "Saber como obter a solução do IVP parametrizado no ponto final b.",
                                  "commonMistakes": [
                                    "Não propagar corretamente as condições iniciais.",
                                    "Ignorar dependência de s na solução."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Função Residual φ(s)",
                                  "subSteps": [
                                    "Expresse a condição de contorno em b: u(b) = β deve ser satisfeita.",
                                    "Defina φ(s) = u(b; s) - β.",
                                    "Verifique que φ(s*) = 0 onde s* é o valor correto para o BVP original."
                                  ],
                                  "verification": "Escreva a expressão explícita de φ(s) para o seu exemplo e teste com s conhecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico de φ(s) vs s",
                                    "Calculadora ou software para plotar"
                                  ],
                                  "tips": "φ(s) é monotônica em muitos casos lineares, facilitando raízes.",
                                  "learningObjective": "Formalizar a condição residual como função zerável.",
                                  "commonMistakes": [
                                    "Inverter o sinal: φ(s) = β - u(b; s) em vez de u(b;s)-β.",
                                    "Omitir a dependência ;s em u(b)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Preparar para Iteração",
                                  "subSteps": [
                                    "Analise o sinal de φ(s): se φ(s)>0, ajuste s para baixo, etc.",
                                    "Discuta como zerar φ(s) iterativamente (ex: método da bisseção).",
                                    "Confirme que s tal que φ(s)=0 resolve o BVP original."
                                  ],
                                  "verification": "Para um exemplo, encontre s aproximado tal que |φ(s)| < 0.01.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Solver de raízes (fsolve no Python)",
                                    "Exemplo numérico completo"
                                  ],
                                  "tips": "Teste φ em múltiplos s para ver monotonicidade.",
                                  "learningObjective": "Entender o papel do residual na convergência iterativa.",
                                  "commonMistakes": [
                                    "Assumir linearidade sem verificar.",
                                    "Parar iteração sem verificar precisão do residual."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP -u''(x) + u(x) = 0, u(0)=0, u(1)=1. IVP: u(0;s)=0, u'(0;s)=s → solução u(x;s)= sinh(x)/sinh(1) * s (analítica). φ(s)= u(1;s)-1 = s -1. Raiz exata s=1.",
                              "finalVerifications": [
                                "Pode escrever φ(s) corretamente para qualquer BVP dado?",
                                "Computa u(b;s) numericamente com erro <1%?",
                                "Identifica s* tal que |φ(s*)|<ε para ε pequeno?",
                                "Explica por que φ(s)=0 resolve o BVP?",
                                "Verifica monotonicidade de φ(s) em casos lineares?",
                                "Aplica em um exemplo não-trivial?"
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de φ(s) com notação correta (90% pontos).",
                                "Cálculo correto de u(b;s) com método numérico apropriado (20%).",
                                "Interpretação clara do residual e seu zero (20%).",
                                "Exemplo prático resolvido com passos (20%).",
                                "Análise de erros e precisão (20%).",
                                "Conexão com iteração do método de tiro (20%).",
                                "Clareza e organização da resposta (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações diferenciais em mecânica e calor.",
                                "Programação: Implementação de solvers ODE e funções de raiz.",
                                "Engenharia: Simulações de fluxo e estruturas com condições de contorno.",
                                "Estatística: Otimização e minimização de resíduos em regressão."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, usado para modelar perfis de temperatura em painéis com condições fixas nas bordas, ajustando gradientes iniciais via residuals para precisão em simulações CFD."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Escolher estimativa inicial para o parâmetro s",
                            "description": "Analisar linearizações ou estimativas analíticas simples para fornecer uma boa chute inicial s0, considerando o comportamento da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o comportamento qualitativo da solução do PVI",
                                  "subSteps": [
                                    "Identifique as condições de contorno do problema de valor de contorno (PVC).",
                                    "Transforme o PVC em problema de valor inicial (PVI) parametrizado por s, onde s é tipicamente a derivada inicial faltante.",
                                    "Estude o comportamento assintótico da solução perto das fronteiras (ex.: camadas de contorno).",
                                    "Desenhe um esboço qualitativo da solução considerando o sinal e magnitude das funções envolvidas.",
                                    "Considere o comportamento para valores extremos de s (muito grande ou pequeno)."
                                  ],
                                  "verification": "Verifique se o esboço qualitativo satisfaz ambas as condições de contorno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Equação diferencial do PVC"
                                  ],
                                  "tips": "Comece assumindo uma solução linear ou exponencial simples para guiar o esboço.",
                                  "learningObjective": "Compreender o comportamento global da solução para guiar a escolha de s0.",
                                  "commonMistakes": "Ignorar o efeito de termos não lineares ou camadas de contorno finas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar linearização simples da equação diferencial",
                                  "subSteps": [
                                    "Linearize a EDO não linear em torno de um ponto de equilíbrio ou solução trivial.",
                                    "Resolva a versão linearizada analiticamente para obter uma aproximação da solução.",
                                    "Extraia o valor aproximado de y'(a) da solução linearizada.",
                                    "Ajuste para os termos não lineares principais usando expansão em série.",
                                    "Compare com as condições de contorno para refinar a estimativa."
                                  ],
                                  "verification": "A solução linearizada deve aproximar razoavelmente as condições de contorno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/MATLAB",
                                    "Folha de derivação"
                                  ],
                                  "tips": "Use a linearização em torno de y=0 se aplicável, e inclua os primeiros termos perturbativos.",
                                  "learningObjective": "Aplicar linearização para obter uma estimativa analítica inicial de s.",
                                  "commonMistakes": "Linearizar em ponto errado, levando a instabilidade numérica posterior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar estimativas analíticas baseadas em métodos assintóticos",
                                  "subSteps": [
                                    "Identifique regimes assintóticos (ex.: ε pequeno em problemas singulares perturbados).",
                                    "Construa soluções externas e internas aproximadas.",
                                    "Aplique condição de matching para estimar s.",
                                    "Incorpore o comportamento da solução no matching das condições de contorno.",
                                    "Teste a estimativa com uma integração numérica grosseira."
                                  ],
                                  "verification": "A estimativa deve reduzir o número de iterações no método de tiro em pelo menos 50%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livro de análise assintótica",
                                    "Software numérico básico (ex.: Python com scipy)"
                                  ],
                                  "tips": "Para problemas com camada de contorno, foque na região interna perto da fronteira.",
                                  "learningObjective": "Dominar estimativas assintóticas para chutes iniciais precisos.",
                                  "commonMistakes": "Negligenciar o matching correto entre soluções interna e externa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a estimativa inicial s0",
                                  "subSteps": [
                                    "Integre numericamente o PVI com s0 proposto até a segunda fronteira.",
                                    "Meça o erro na condição de contorno final.",
                                    "Ajuste s0 baseado no sinal e magnitude do erro (ex.: método da secante informal).",
                                    "Documente a justificativa analítica para a escolha.",
                                    "Registre o s0 final e prepare para iterações do método de tiro."
                                  ],
                                  "verification": "Erro na condição de contorno < 10% do valor alvo com s0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de integração numérica (MATLAB, Python)",
                                    "Gráfico de erro vs. s"
                                  ],
                                  "tips": "Plote erro vs. s para visualizar a monotonicidade e escolher s0 no ponto médio.",
                                  "learningObjective": "Integrar análise teórica com verificação numérica para otimizar s0.",
                                  "commonMistakes": "Escolher s0 sem considerar a sensibilidade numérica do problema."
                                }
                              ],
                              "practicalExample": "Considere o PVC y'' + ε y' + y = 0, y(0)=0, y(1)=1 com ε pequeno. Linearize ignorando ε inicialmente: solução y ≈ x. Mas com camada de contorno em x=1, estimativa assintótica dá s0 ≈ 1 + ε/(1-exp(-1/ε)). Teste com ε=0.1: s0≈1.05, erro reduzido de 20% para 2%.",
                              "finalVerifications": [
                                "Explicar verbalmente o raciocínio para escolha de s0.",
                                "Demonstrar que s0 reduz iterações no método de tiro.",
                                "Apresentar gráfico de solução com s0 vs. solução exata.",
                                "Calcular erro residual na condição de contorno com s0.",
                                "Comparar s0 com valores de literatura ou soluções conhecidas.",
                                "Identificar limitações da estimativa para parâmetros variados."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa s0 (erro <5% ideal).",
                                "Justificativa analítica clara e correta.",
                                "Uso adequado de linearização ou assintóticas.",
                                "Verificação numérica incluída.",
                                "Consideração de comportamento da solução.",
                                "Documentação completa com gráficos e cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão de calor com condições de contorno mistas.",
                                "Programação: Implementação de solvers numéricos em Python (scipy.integrate).",
                                "Engenharia: Análise de vigas ou circuitos elétricos via EDOs.",
                                "Estatística: Sensibilidade de parâmetros em modelos estocásticos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, escolher s0 inicial para simular perfis de temperatura em painéis de reentrada atmosférica, reduzindo tempo de computação em simulações CFD de horas para minutos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Solução Numérica do Problema de Valor Inicial",
                        "description": "Aplicar métodos numéricos para resolver o IVP resultante, considerando métodos de passo simples e múltiplo, controle de erro e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Implementar métodos de passo simples (Euler, Runge-Kutta)",
                            "description": "Usar métodos explícitos como Euler forward ou RK4 para integrar o IVP de a até b com passo fixo h, avaliando φ(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Problema de Valor Inicial (IVP)",
                                  "subSteps": [
                                    "Defina a equação diferencial y' = f(t, y) e condições iniciais y(a) = y0.",
                                    "Especifique o intervalo [a, b] e o passo fixo h.",
                                    "Implemente a função f(t, y) em código (ex: Python com NumPy).",
                                    "Calcule o número de passos N = (b - a)/h.",
                                    "Teste a função f com valores iniciais para verificar correção."
                                  ],
                                  "verification": "Execute a função f com entradas de teste e compare saídas esperadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Biblioteca NumPy"
                                  ],
                                  "tips": "Use def f(t, y): return ... para clareza.",
                                  "learningObjective": "Compreender e codificar a representação computacional de um IVP.",
                                  "commonMistakes": [
                                    "Confundir variáveis independentes (t) e dependentes (y)",
                                    "Esquecer importações de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Euler Forward",
                                  "subSteps": [
                                    "Inicialize vetores para armazenar t e y (tamanhos N+1).",
                                    "Defina t[0] = a e y[0] = y0.",
                                    "Para i de 0 a N-1: t[i+1] = t[i] + h; y[i+1] = y[i] + h * f(t[i], y[i]).",
                                    "Execute a iteração completa e plote a solução aproximada.",
                                    "Calcule erro relativo comparando com solução exata se conhecida."
                                  ],
                                  "verification": "Verifique se y evolui monotonicamente para problemas lineares simples e sem overflow.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy para arrays",
                                    "Matplotlib para plotagem"
                                  ],
                                  "tips": "Use loops for eficientes; vetorize se possível para prática.",
                                  "learningObjective": "Codificar e aplicar o método de Euler para aproximação numérica de IVPs.",
                                  "commonMistakes": [
                                    "Erro no índice do loop (off-by-one)",
                                    "Usar h incorreto no update de y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método Runge-Kutta de Ordem 4 (RK4)",
                                  "subSteps": [
                                    "Inicialize vetores t e y como no Euler.",
                                    "Para cada passo i: compute k1 = h*f(t[i], y[i]), k2 = h*f(t[i]+h/2, y[i]+k1/2), k3 = h*f(t[i]+h/2, y[i]+k2/2), k4 = h*f(t[i]+h, y[i]+k3).",
                                    "Atualize y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4)/6.",
                                    "Atualize t[i+1] = t[i] + h.",
                                    "Plote e compare com Euler para observar maior precisão."
                                  ],
                                  "verification": "Compare soluções de Euler e RK4; RK4 deve ser mais precisa (erro menor).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Escreva uma função rk4_step para reutilização em loops.",
                                  "learningObjective": "Dominar a implementação precisa do RK4 para soluções mais acuradas.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes de k2/k3/k4",
                                    "Dividir incorretamente no update final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar φ(s) e Integrar até b",
                                  "subSteps": [
                                    "Defina φ(s) baseado no contexto do método de tiro (ex: φ(b) ≈ condição de contorno).",
                                    "Execute ambos métodos até b e compute φ(s) para s em malha.",
                                    "Analise convergência variando h (ex: h/2).",
                                    "Gere relatório com tabelas de erros e gráficos.",
                                    "Otimize código para eficiência (ex: vetores pré-alocados)."
                                  ],
                                  "verification": "φ(s) deve aproximar zero ou valor alvo; erros decrescem com h menor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy para análise de erro",
                                    "Matplotlib para visualizações"
                                  ],
                                  "tips": "Use np.linspace para malhas uniformes.",
                                  "learningObjective": "Integrar métodos numéricos em fluxos de avaliação para problemas de contorno.",
                                  "commonMistakes": [
                                    "Ignorar estabilidade para h grande",
                                    "Má interpretação de φ(s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 em [0,1] com h=0.1. Solução exata: y(t)=exp(-2t). Implemente Euler e RK4, compute erros em t=1 e plote trajetórias. φ(s) = y(1) - 0.1353 (aprox. exata).",
                              "finalVerifications": [
                                "Código executa sem erros para h=0.1 e h=0.05.",
                                "RK4 produz erro <1e-3 em t=b, Euler >1e-2.",
                                "Gráficos mostram convergência com h menor.",
                                "φ(s) avaliado corretamente para múltiplos s.",
                                "Tempo de execução <1s para N=100.",
                                "Solução respeita estabilidade (sem explosão numérica)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global O(h) para Euler, O(h^4) para RK4 demonstrado.",
                                "Clareza do código: Funções modulares, comentários adequados.",
                                "Análise: Comparação quantitativa com solução exata.",
                                "Eficiência: Uso correto de vetores e loops.",
                                "Visualização: Plots informativos de y(t) vs exata.",
                                "Generalidade: Código funciona para f(t,y) arbitrárias."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos em Python.",
                                "Física: Simulação de movimento (ex: osciladores).",
                                "Engenharia: Modelagem de circuitos RC.",
                                "Biologia: Dinâmica de populações (modelos Lotka-Volterra).",
                                "Ciência de Dados: Integração em machine learning para ODEs."
                              ],
                              "realWorldApplication": "Simulação de trajetórias de mísseis (RK4 em controle de voo), previsão de epidemias (Euler em SIR models), otimização de processos químicos em indústrias farmacêuticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Aplicar controle adaptativo de passo",
                            "description": "Implementar refinamento de passo baseado em estimativa de erro local (ex: embutido em RK), para melhorar precisão em soluções sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos teóricos do controle adaptativo de passo",
                                  "subSteps": [
                                    "Estudar a estimativa de erro local em métodos de Runge-Kutta (RK) usando soluções de ordens diferentes.",
                                    "Analisar o conceito de tolerância de erro absoluto e relativo para refinamento.",
                                    "Explorar a importância em problemas sensíveis, como stiff equations ou regiões de alta variação.",
                                    "Revisar fórmulas para cálculo do erro local: |e| ≈ |y_{n+1}^{(p+1)} - y_{n+1}^{(p)}| / (ordem).",
                                    "Discutir critérios de aceitação/rejeição de passos."
                                  ],
                                  "verification": "Explicar em um parágrafo o processo de estimativa de erro e como ele guia o refinamento do passo h.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre RK embutidos",
                                    "Artigos sobre DOPRI5 (Dormand-Prince)"
                                  ],
                                  "tips": [
                                    "Comece com exemplos simples de IVP para visualizar o erro local.",
                                    "Use gráficos para comparar soluções com passos fixos vs. adaptativos."
                                  ],
                                  "learningObjective": "Dominar a teoria da estimativa de erro local e seu papel no controle adaptativo.",
                                  "commonMistakes": [
                                    "Confundir erro local com erro global acumulado.",
                                    "Ignorar tolerâncias relativas em soluções com escalas variadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar e selecionar um método RK embutido",
                                  "subSteps": [
                                    "Analisar métodos RK embutidos como RK45 (Dormand-Prince) ou Fehlberg.",
                                    "Implementar manualmente os coeficientes Butcher para um par RK de ordens 4/5.",
                                    "Testar em um IVP simples: y' = -y, y(0)=1, comparando com solução exata.",
                                    "Verificar convergência de ordem em passos fixos.",
                                    "Configurar parâmetros iniciais: h0, tol_abs, tol_rel."
                                  ],
                                  "verification": "Resolver um IVP com RK45 manual e plotar erro vs. h.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código-fonte em Python/MATLAB para RK",
                                    "Tabelas de coeficientes Butcher online",
                                    "Software SciPy (ode45)"
                                  ],
                                  "tips": [
                                    "Use SciPy.integrate.solve_ivp como referência para validar sua implementação.",
                                    "Sempre normalize erros por escala da solução."
                                  ],
                                  "learningObjective": "Selecionar e compreender a implementação de um solver RK embutido.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes Butcher.",
                                    "Não escalar tolerâncias adequadamente para variáveis com magnitudes diferentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo de controle adaptativo de passo",
                                  "subSteps": [
                                    "Codificar o loop principal: tentar passo h, estimar erro, aceitar/rejeitar.",
                                    "Implementar ajuste de h: h_new = h * (tol / err)^{1/(p+1)} * fator_segurança (0.9).",
                                    "Adicionar limites: h_min, h_max para evitar loops infinitos.",
                                    "Tratar rejeições: reduzir h e reavaliar.",
                                    "Registrar estatísticas: número de passos aceitos/rejeitados, h final."
                                  ],
                                  "verification": "Executar em IVP com solução conhecida e verificar se erro global < tol.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de programação (Python com NumPy/MATLAB)",
                                    "Exemplos de código ODE adaptativo",
                                    "Debugger para rastrear rejeições"
                                  ],
                                  "tips": [
                                    "Inclua logging para monitorar erros e ajustes de h.",
                                    "Teste com tol variando de 1e-3 a 1e-12."
                                  ],
                                  "learningObjective": "Desenvolver o algoritmo completo de refinamento baseado em erro.",
                                  "commonMistakes": [
                                    "Fator de segurança muito agressivo causando muitas rejeições.",
                                    "Não tratar h_min levando a overflow/underflow."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar ao método de tiro simples e validar",
                                  "subSteps": [
                                    "Adaptar o solver para o IVP no método de tiro: disparar com phi(a, s) para estimar BVP.",
                                    "Iterar no parâmetro s até y(b) ≈ gamma, usando solver adaptativo em cada tiro.",
                                    "Comparar com passos fixos: eficiência (tempo/N passos) e precisão.",
                                    "Analisar sensibilidade em BVPs não-lineares.",
                                    "Otimizar para convergência do tiro (ex: secante)."
                                  ],
                                  "verification": "Resolver BVP exemplo e comparar solução com método exato ou de alta precisão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código do método de tiro simples",
                                    "BVPs de teste (ex: y'' + y = 0, y(0)=0, y(pi)=0)",
                                    "GNUPlot/Matplotlib para visualização"
                                  ],
                                  "tips": [
                                    "Use eventos para parar integração em singularidades.",
                                    "Monitore custo computacional."
                                  ],
                                  "learningObjective": "Aplicar controle adaptativo no contexto de problemas de valor de contorno via método de tiro.",
                                  "commonMistakes": [
                                    "Não resetar estado do solver entre tiros.",
                                    "Ignorar dependência de h em iterações de s."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP y'' + y = 0 com y(0) = 0, y(π) = 0 usando método de tiro simples. Integre o IVP y' = [z, -y] de 0 a π com y(0)=0, z(0)=s, ajustando s até z(π)≈0. Use RK45 adaptativo com tol=1e-6 e compare com solução exata y=sin(x).",
                              "finalVerifications": [
                                "O código resolve o BVP com erro global < 1e-5.",
                                "Número de passos adaptativos é significativamente menor que fixos para mesma precisão.",
                                "Gráficos mostram convergência suave sem oscilações anômalas.",
                                "Estatísticas logadas confirmam taxa de aceitação >70%.",
                                "Teste com tol variada mantém precisão escalável.",
                                "Integração no método de tiro converge em <10 iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro global alinhado com tolerância solicitada.",
                                "Eficiência: redução de pelo menos 50% no número de avaliações de f vs. h fixo.",
                                "Robustez: lida com rejeições sem crash ou loop infinito.",
                                "Clareza do código: modular, comentado e reproduzível.",
                                "Validação: comparação quantitativa com soluções conhecidas.",
                                "Análise: relatório de sensibilidade a parâmetros (tol, h0)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: implementação numérica em Python/MATLAB.",
                                "Física: simulações de osciladores e dinâmicas em mecânica.",
                                "Engenharia de Controle: solvers adaptativos em sistemas em tempo real.",
                                "Ciência de Dados: otimização de precisão vs. custo em ML numérico."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais para trajetórias de mísseis (onde regiões turbulentas demandam passos pequenos), modelagem climática para equações diferenciais sensíveis a erros locais, e controle adaptativo em robótica para navegação precisa em ambientes dinâmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Avaliar estabilidade e problemas stiff",
                            "description": "Identificar instabilidades em métodos explícitos para problemas stiff e considerar implicações no método de tiro, referenciando conceitos de estabilidade A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade em métodos numéricos para EDOs",
                                  "subSteps": [
                                    "Estudar a definição de estabilidade absoluta e condicional para métodos de Runge-Kutta explícitos.",
                                    "Analisar a região de estabilidade no plano complexo hλ.",
                                    "Explicar o conceito de A-estabilidade e sua importância para problemas stiff.",
                                    "Comparar estabilidade local e global em integrações numéricas.",
                                    "Resolver exercícios simples de estabilidade para o método de Euler explícito."
                                  ],
                                  "verification": "Plotar e interpretar a região de estabilidade do método de Euler explícito usando software numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Python com Matplotlib e SciPy",
                                    "Folhas de exercícios sobre regiões de estabilidade"
                                  ],
                                  "tips": "Visualize sempre as regiões de estabilidade graficamente para melhor compreensão intuitiva.",
                                  "learningObjective": "Compreender os tipos de estabilidade e suas regiões no plano complexo.",
                                  "commonMistakes": [
                                    "Confundir estabilidade condicional com A-estabilidade",
                                    "Ignorar o papel do passo h na região de estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar características de problemas stiff",
                                  "subSteps": [
                                    "Definir problemas stiff: escalas de tempo muito diferentes nos autovalores da matriz Jacobiana.",
                                    "Exemplificar com EDOs lineares y' = λy onde Re(λ) << 0 e |λ| grande.",
                                    "Testar numericamente um problema stiff simples com método explícito.",
                                    "Medir o índice de rigidez usando autovalores.",
                                    "Discutir componentes rápidas e lentas em sistemas stiff."
                                  ],
                                  "verification": "Classificar um dado sistema de EDOs como stiff ou não, calculando autovalores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software Python (NumPy, SciPy para autovalores)",
                                    "Exemplos de EDOs stiff do livro-texto",
                                    "Calculadora ou Jupyter Notebook"
                                  ],
                                  "tips": "Use o teste de Dahlquist para validar se o problema é stiff.",
                                  "learningObjective": "Reconhecer e quantificar rigidez em problemas de EDOs.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade",
                                    "Subestimar o impacto de autovalores com partes reais negativas grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar instabilidades em métodos explícitos para problemas stiff",
                                  "subSteps": [
                                    "Simular um problema stiff com Euler explícito e observar oscilações ou divergência.",
                                    "Explicar por que passos h pequenos são necessários (h < 2/|λ_max|).",
                                    "Comparar com métodos implícitos como Backward Euler.",
                                    "Quantificar o custo computacional devido a passos minúsculos.",
                                    "Implementar e testar em código um exemplo stiff."
                                  ],
                                  "verification": "Executar simulação que demonstre instabilidade explícita e resolva com implícito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/SciPy odeint ou solve_ivp",
                                    "Exemplo clássico: y' = -1000(y-1) + sin(t)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Aumente gradualmente o passo h para observar o ponto de instabilidade.",
                                  "learningObjective": "Demonstrar empiricamente as limitações de métodos explícitos em stiff problems.",
                                  "commonMistakes": [
                                    "Escolher h inadequado sem testar estabilidade",
                                    "Atribuir erro numérico à precisão em vez de instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar implicações no método de tiro simples para problemas de valor de contorno",
                                  "subSteps": [
                                    "Relembrar o método de tiro: converter BVP em IVP com parâmetro de contorno.",
                                    "Identificar quando o IVP resultante é stiff.",
                                    "Analisar impactos na convergência do método de tiro (ex: muitas iterações Newton).",
                                    "Propor soluções: usar métodos implícitos ou adaptativos no tiro.",
                                    "Testar numericamente um BVP que gera IVP stiff."
                                  ],
                                  "verification": "Resolver um BVP stiff via tiro simples e discutir falhas/ melhorias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python para método de tiro",
                                    "Exemplo BVP: y'' + 1000 y' + y = 0 com condições de contorno",
                                    "Documentação SciPy"
                                  ],
                                  "tips": "Monitore resíduos e passos h durante iterações do tiro.",
                                  "learningObjective": "Aplicar conceitos de estabilidade ao contexto do método de tiro.",
                                  "commonMistakes": [
                                    "Ignorar rigidez propagada do BVP para IVP",
                                    "Não ajustar solver para stiff no tiro"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o BVP y'' + 1000 y' + y = 0, y(0)=1, y(1)=2. No método de tiro simples, o IVP resultante é stiff devido ao termo 1000 y'. Use Euler explícito: observe instabilidade com h>0.001; mude para Backward Euler para convergência estável.",
                              "finalVerifications": [
                                "Classificar corretamente um sistema como stiff via autovalores.",
                                "Explicar por que métodos explícitos falham em stiff problems.",
                                "Plotar região de estabilidade e localizar hλ para um exemplo.",
                                "Identificar rigidez no IVP gerado pelo método de tiro.",
                                "Propor método implícito A-estável como solução.",
                                "Simular e comparar soluções explícita vs implícita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de rigidez (autovalores corretos).",
                                "Correta interpretação de regiões de estabilidade.",
                                "Análise qualitativa e quantitativa de instabilidades.",
                                "Aplicação correta ao método de tiro com exemplos numéricos.",
                                "Propostas de soluções viáveis e justificadas.",
                                "Clareza em relatórios/simulações com gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos com amortecimento forte (ex: circuitos RC).",
                                "Computação: Implementação eficiente de solvers ODE adaptativos (SciPy).",
                                "Engenharia Química: Simulação de reações em série com escalas rápidas/lentas.",
                                "Matemática Aplicada: Análise assintótica de EDOs stiff."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, onde reações rápidas (stiff) e lentas coexistem, métodos explícitos no método de tiro falham, exigindo solvers implícitos para precisão e eficiência em predições industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Algoritmo Iterativo do Método de Tiro Simples",
                        "description": "Executar iterações para resolver φ(s) = 0, utilizando métodos como secante ou Newton, até convergência.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Implementar iteração pela método da secante",
                            "description": "Atualizar s_{k+1} = s_k - φ(s_k) * (s_k - s_{k-1}) / (φ(s_k) - φ(s_{k-1})), resolvendo IVP a cada iteração até |φ(s)| < tol.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função φ(s) usando resolvedor de IVP",
                                  "subSteps": [
                                    "Implemente a equação diferencial do IVP: y'' = f(x, y, y') com condições y(a) = α, y'(a) = s.",
                                    "Use um resolvedor numérico como solve_ivp para integrar até x = b e obter y(b).",
                                    "Defina φ(s) = y(b) - β, onde β é a condição de contorno em b.",
                                    "Teste φ(s) com valores iniciais arbitrários para verificar implementação.",
                                    "Armazene a solução y(x) para o s final."
                                  ],
                                  "verification": "Execute φ(s_test) e confirme que retorna y(b) - β corretamente para s_test conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python, NumPy, SciPy (solve_ivp), editor de código",
                                  "tips": "Vectorize a função f para eficiência; use método RK45 para precisão.",
                                  "learningObjective": "Compreender como φ(s) captura o erro de contorno no método de tiro.",
                                  "commonMistakes": "Esquecer de converter y'' em sistema de primeira ordem; índices errados em solve_ivp."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar aproximações iniciais s_{k-1} e s_k",
                                  "subSteps": [
                                    "Escolha s0 e s1 próximos da solução esperada, preferencialmente com φ(s0) e φ(s1) de sinais opostos.",
                                    "Calcule φ(s0) e φ(s1) usando a função definida no step 1.",
                                    "Defina tolerância tol (ex: 1e-6) e máximo de iterações (ex: 100).",
                                    "Armazene histórico de s e φ para depuração.",
                                    "Verifique se |φ(s0)| e |φ(s1)| não são zero para evitar divisão por zero."
                                  ],
                                  "verification": "Confirme que φ(s0) * φ(s1) < 0 ou valores iniciais razoáveis; imprima valores.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código do step 1, valores de teste para BVP",
                                  "tips": "Use chute inicial via solução analítica aproximada ou método de Euler para estimar.",
                                  "learningObjective": "Selecionar chutes iniciais que garantam convergência da secante.",
                                  "commonMistakes": "Chutes ruins levando a não-convergência; tol muito pequena causando loop infinito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a iteração da secante",
                                  "subSteps": [
                                    "Inicie loop while |φ(s_k)| >= tol and k < max_iter.",
                                    "Calcule numerador: φ(s_k) * (s_k - s_{k-1})",
                                    "Calcule denominador: φ(s_k) - φ(s_{k-1})",
                                    "Atualize s_{k+1} = s_k - numerador / denominador",
                                    "Atualize s_{k-1} = s_k, s_k = s_{k+1}, calcule novo φ(s_k)"
                                  ],
                                  "verification": "Simule 2-3 iterações manualmente e compare com código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código dos steps anteriores, debugger",
                                  "tips": "Use loop while com break explícito; logue cada iteração para rastrear.",
                                  "learningObjective": "Aplicar corretamente a fórmula da secante para raízes de φ(s) = 0.",
                                  "commonMistakes": "Divisão por zero se φ(s_k) ≈ φ(s_{k-1}); inverter s_{k-1} e s_k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência e extrair solução final",
                                  "subSteps": [
                                    "Após loop, cheque se |φ(s_final)| < tol ou max_iter atingido.",
                                    "Resolva IVP final com s_final para obter y(x) completo.",
                                    "Calcule resíduos: verifique condições de contorno numericamente.",
                                    "Plote y(x), φ vs iterações para visualização.",
                                    "Retorne s_final, y(x), número de iterações."
                                  ],
                                  "verification": "Resíduo em b < tol * 10; plote confirma suavidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Matplotlib para plots, código completo",
                                  "tips": "Salve histórico para análise de convergência quadrática.",
                                  "learningObjective": "Validar implementação e interpretar resultados de convergência.",
                                  "commonMistakes": "Não resolver IVP final; ignorar falha de convergência."
                                }
                              ],
                              "practicalExample": "Resolva o BVP y'' + y = 0, y(0)=0, y(π/2)=1 no [0, π/2]. φ(s) = y(π/2; s) - 1. Iniciais s0=1, s1=2, tol=1e-6. Solução esperada s≈1.0, y(x)=sin(x).",
                              "finalVerifications": [
                                "|φ(s_final)| < tol",
                                "Condições de contorno satisfeitas com erro < 1e-5",
                                "Número de iterações ≤ 20",
                                "Convergência quadrática observada no histórico",
                                "Solução y(x) suave e fisicamente plausível",
                                "Código executa sem warnings ou erros numéricos"
                              ],
                              "assessmentCriteria": [
                                "Implementação da fórmula secante exata e eficiente",
                                "Função φ(s) resolve IVP corretamente a cada chamada",
                                "Gerenciamento robusto de loop (evita inf loop/zero div)",
                                "Validações finais implementadas e passing",
                                "Código limpo, comentado e reproduzível",
                                "Análise de erro/convergência incluída"
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica (NumPy/SciPy)",
                                "Física Computacional (equações diferenciais em modelagem)",
                                "Engenharia (simulações de estruturas/difusão)",
                                "Otimização Numérica (métodos sem derivadas)"
                              ],
                              "realWorldApplication": "Aplicado em simulações de elastica em engenharia mecânica, perfis de temperatura em difusão térmica com contornos mistos, e modelagem de ondas em óptica não-linear, onde BVPs surgem naturalmente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Usar método de Newton para iteração",
                            "description": "Calcular φ'(s) ≈ [φ(s_k) - φ(s_{k-1})] / (s_k - s_{k-1}) ou via sensibilidade, e iterar s_{k+1} = s_k - φ(s_k)/φ'(s_k).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a função φ(s) e o papel da iteração de Newton no método de tiro simples",
                                  "subSteps": [
                                    "Revise a definição de φ(s) = ψ(L; s) - b, onde ψ é a solução do problema de valor inicial com y'(0) = s e b é a condição de contorno em x=L.",
                                    "Entenda que o método de tiro busca s* tal que φ(s*) = 0.",
                                    "Aprenda a fórmula de Newton: s_{k+1} = s_k - φ(s_k) / φ'(s_k).",
                                    "Discuta por que φ'(s) é necessário e como ele representa a sensibilidade da solução final à condição inicial.",
                                    "Estude a convergência quadrática do método de Newton quando próximo da raiz."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que φ(s) representa e derive a fórmula de iteração de Newton.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Folha de papel e caneta",
                                    "Notebook com Python ou MATLAB para visualização"
                                  ],
                                  "tips": "Desenhe um diagrama do problema de valor de contorno e marque onde φ(s) entra.",
                                  "learningObjective": "Compreender conceitualmente o método de Newton aplicado à função φ(s) no método de tiro.",
                                  "commonMistakes": [
                                    "Confundir φ(s) com a solução ψ(x;s)",
                                    "Ignorar a necessidade de boa estimativa inicial s_0",
                                    "Esquecer que Newton requer derivada precisa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a derivada φ'(s) usando aproximação por diferenças finitas",
                                  "subSteps": [
                                    "Escolha um passo h pequeno (ex: h=10^{-4}) para a diferença finita.",
                                    "Calcule φ(s_k + h) e φ(s_k - h) resolvendo os respectivos problemas de valor inicial.",
                                    "Aproxime φ'(s_k) ≈ [φ(s_k + h) - φ(s_k - h)] / (2h) para maior precisão (diferença central).",
                                    "Alternativamente, resolva o problema linearizado para sensibilidade: derive ψ' wrt s.",
                                    "Teste a aproximação com valores conhecidos para validar."
                                  ],
                                  "verification": "Compare φ'(s) calculado com diferença finita vs. fórmula analítica se disponível; erro < 1%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico (Python com scipy.integrate.odeint ou MATLAB ode45)",
                                    "Exemplo de BVP resolvido analiticamente"
                                  ],
                                  "tips": "Use h adaptativo: comece com 10^{-3} e refine até convergência.",
                                  "learningObjective": "Dominar o cálculo numérico de φ'(s) via diferenças finitas ou sensibilidade.",
                                  "commonMistakes": [
                                    "h muito grande (baixa precisão) ou muito pequeno (erro numérico)",
                                    "Usar diferença progressiva em vez de central",
                                    "Não normalizar corretamente o denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a iteração de Newton para encontrar s*",
                                  "subSteps": [
                                    "Inicialize s_0 com estimativa razoável (ex: linear interpolation entre condições de contorno).",
                                    "Em loop: compute φ(s_k), φ'(s_k), então s_{k+1} = s_k - φ(s_k)/φ'(s_k).",
                                    "Monitore |φ(s_k)| e |s_{k+1} - s_k| para critério de parada (ex: < 10^{-6}).",
                                    "Registre histórico de iterações em tabela (k, s_k, φ(s_k), φ'(s_k)).",
                                    "Implemente safeguards: max 20 iterações, cheque se φ'(s_k) ≈ 0."
                                  ],
                                  "verification": "Execute 5 iterações e verifique se |s_{k+1} - s_k| diminui quadraticamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python/MATLAB template para método de tiro",
                                    "Computador com ambiente de programação"
                                  ],
                                  "tips": "Plote φ(s) vs s para visualizar a raiz e convergência.",
                                  "learningObjective": "Implementar corretamente o algoritmo iterativo de Newton para φ(s)=0.",
                                  "commonMistakes": [
                                    "Divisão por φ'(s_k) próximo de zero sem detecção",
                                    "Estimativa inicial ruim levando a divergência",
                                    "Critério de parada muito frouxo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência, erros e soluções finais",
                                  "subSteps": [
                                    "Compare s* encontrado com solução analítica se conhecida.",
                                    "Calcule o erro global na solução y(x) vs. condições de contorno.",
                                    "Analise ordem de convergência plotando log(|e_{k+1}|) vs log(|e_k|).",
                                    "Teste sensibilidade a h e s_0.",
                                    "Documente relatório com tabelas, gráficos e conclusões."
                                  ],
                                  "verification": "Solução y(L) satisfaz |y(L) - b| < 10^{-5} e convergência em <10 iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos gerados pelo código",
                                    "Ferramenta de plotagem (matplotlib)"
                                  ],
                                  "tips": "Salve histórico para análise pós-iteração.",
                                  "learningObjective": "Avaliar a eficácia e robustez da iteração de Newton no método de tiro.",
                                  "commonMistakes": [
                                    "Atribuir convergência sem checar φ'(s) estável",
                                    "Ignorar acumulação de erro de integração",
                                    "Não testar múltiplas s_0"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y'' + y = 0, y(0)=0, y(π)=1 usando método de tiro simples. Defina ψ(x;s) resolvendo y'' + y=0, y(0)=0, y'(0)=s. Então φ(s)=ψ(π;s)-1. Inicialize s_0=0.3. Use h=1e-4 para φ'(s). Itere até |φ(s_k)|<1e-6. Solução esperada: s* ≈ 0.3183 (relacionado a cot(π)).",
                              "finalVerifications": [
                                "φ(s*) ≈ 0 com precisão 1e-8.",
                                "Convergência em no máximo 8 iterações.",
                                "Erro em y(π) < 1e-6.",
                                "φ'(s*) ≠ 0 e estável.",
                                "|s_final - s_0| indica convergência razoável.",
                                "Histórico mostra redução quadrática de erro."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação da diferença finita para φ'(s) (precisão >90%).",
                                "Algoritmo de Newton sem bugs (converge em exemplo padrão).",
                                "Análise de convergência com evidências quantitativas.",
                                "Tratamento de casos edge (φ'≈0).",
                                "Relatório claro com tabelas/gráficos.",
                                "Tempo total <4 horas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação em equações diferenciais de ondas ou calor com condições de contorno.",
                                "Computação: Programação numérica com solvers ODE (SciPy, MATLAB).",
                                "Engenharia: Modelagem de perfis de temperatura em hastes.",
                                "Estatística: Análise de sensibilidade e propagação de erros."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, usado para otimizar trajetórias de mísseis resolvendo BVPs não lineares; em finanças, para precificação de opções com condições de contorno em PDEs de Black-Scholes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Definir critérios de convergência e parada",
                            "description": "Estabelecer tolerâncias para |φ(s)|, |s_{k+1} - s_k|, número máximo de iterações, e validar solução final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel dos critérios de convergência no algoritmo iterativo",
                                  "subSteps": [
                                    "Revise o algoritmo do Método de Tiro Simples: inicialize s_0, compute φ(s_k) resolvendo o PVI até x=b e avaliando o resíduo na condição de contorno.",
                                    "Identifique o loop iterativo: enquanto não convergir, atualize s_{k+1} = s_k - φ(s_k)/φ'(s_k).",
                                    "Explique por que critérios de parada são essenciais: evitar loops infinitos, divergência ou custo computacional excessivo.",
                                    "Discuta os tipos de critérios: baseados em resíduo, variação do parâmetro e limite de iterações.",
                                    "Esboce um fluxograma do algoritmo destacando pontos de verificação."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o loop iterativo e localize onde inserir os critérios de parada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Método de Tiro Simples",
                                    "Pseudocódigo do algoritmo",
                                    "Lápis e papel para fluxograma"
                                  ],
                                  "tips": [
                                    "Pense em termos de 'quando parar uma busca manual por uma raiz?' – similar ao método da secante."
                                  ],
                                  "learningObjective": "Entender a estrutura iterativa e a necessidade de critérios de convergência para eficiência e robustez.",
                                  "commonMistakes": [
                                    "Ignorar que φ(s) é o resíduo na condição final, não o erro global na solução y.",
                                    "Confundir convergência com exatidão absoluta."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir tolerância para o resíduo |φ(s)|",
                                  "subSteps": [
                                    "Defina φ(s) como o erro na condição de contorno final: φ(s) = y(b; s) - valor desejado.",
                                    "Escolha ε_φ baseado em precisão desejada: tipicamente 10^{-6} a 10^{-10}, considerando condicionamento do problema.",
                                    "Justifique: |φ(s)| < ε_φ implica que a solução y(x; s) satisfaz aproximadamente as condições de contorno.",
                                    "Teste com um exemplo numérico simples: compute φ para valores de s próximos à raiz.",
                                    "Registre como ε_φ afeta o número de iterações e precisão."
                                  ],
                                  "verification": "Para um problema dado, proponha ε_φ e compute |φ(s)| para verificar se < ε_φ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de PVI resolvido numericamente (e.g., via Runge-Kutta)",
                                    "Calculadora ou software como Python/MATLAB"
                                  ],
                                  "tips": [
                                    "Escolha ε_φ alinhado à precisão do solver de PVI para evitar erros propagados."
                                  ],
                                  "learningObjective": "Selecionar e justificar tolerância para o resíduo de contorno de forma apropriada ao problema.",
                                  "commonMistakes": [
                                    "Escolher ε_φ muito pequeno, levando a muitas iterações desnecessárias.",
                                    "Não considerar o scaling das variáveis (normalizar se necessário)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir tolerância para a variação |s_{k+1} - s_k| e número máximo de iterações",
                                  "subSteps": [
                                    "Defina o critério de variação: pare se |s_{k+1} - s_k| < ε_s, indicando estabilização do parâmetro inicial.",
                                    "Escolha ε_s menor que ε_φ (e.g., 10^{-8}), pois s converge quadraticamente.",
                                    "Estabeleça N_max (e.g., 50-200) para detectar não-convergência: se k > N_max, avise falha.",
                                    "Compare os critérios: use OR lógico (resíduo OU variação OU max_iter).",
                                    "Simule cenários: convergência rápida, lenta e falha."
                                  ],
                                  "verification": "Implemente pseudocódigo com esses critérios e teste com iterações manuais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo editável",
                                    "Tabela para simular 5-10 iterações"
                                  ],
                                  "tips": [
                                    "ε_s detecta platô na convergência; N_max previne travamentos em problemas il-condicionados."
                                  ],
                                  "learningObjective": "Estabelecer critérios complementares para detecção robusta de convergência ou falha.",
                                  "commonMistakes": [
                                    "Usar mesmo ε para φ e s, ignorando taxas de convergência diferentes.",
                                    "Esquecer N_max, arriscando loops infinitos em código."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a solução final e documentar os critérios",
                                  "subSteps": [
                                    "Após parada, verifique |φ(s_final)| < ε_φ e compute norma do erro em pontos conhecidos se disponível.",
                                    "Avalie sensibilidade: perturbe s_final e re-compute φ para confirmar estabilidade.",
                                    "Documente: liste ε_φ, ε_s, N_max, iterações reais e resíduo final.",
                                    "Discuta trade-offs: precisão vs. tempo computacional.",
                                    "Teste em um problema completo: ajuste critérios se necessário."
                                  ],
                                  "verification": "Produza um relatório curto com critérios definidos, resultados e validação para um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software numérico (Python/Octave)",
                                    "Problema de teste padrão"
                                  ],
                                  "tips": [
                                    "Sempre valide pós-convergência: convergência não garante acurácia global."
                                  ],
                                  "learningObjective": "Validar e documentar critérios para garantir confiabilidade da solução numérica.",
                                  "commonMistakes": [
                                    "Aceitar convergência sem checar resíduo final.",
                                    "Não documentar, dificultando reprodutibilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver -y'' + y = 0, y(0)=0, y(1)=1 via Tiro Simples: defina ε_φ=1e-6 para |y(1;s)-1|<ε_φ, ε_s=1e-8 para |s_{k+1}-s_k|<ε_s, N_max=100. Inicie s_0=1, itere até s≈1.1752 após 5 iterações, valide |φ(s_final)|≈3e-7.",
                              "finalVerifications": [
                                "Critérios ε_φ, ε_s e N_max corretamente definidos e justificados para um problema dado.",
                                "Pseudocódigo do loop iterativo inclui todas as condições de parada com lógica OR.",
                                "Simulação manual ou numérica demonstra parada correta em exemplo.",
                                "Validação pós-convergência confirma resíduo pequeno e estabilidade.",
                                "Relatório documenta trade-offs de precisão vs. eficiência.",
                                "Identifica cenários de falha (e.g., N_max atingido) e sugestões de ajuste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de φ(s) e seu papel no resíduo de contorno (peso: 25%).",
                                "Seleção adequada de tolerâncias ε_φ e ε_s, com justificativa quantitativa (peso: 25%).",
                                "Inclusão e justificativa de N_max e validação final (peso: 20%).",
                                "Clareza no pseudocódigo e fluxograma do algoritmo completo (peso: 15%).",
                                "Análise de trade-offs e erros comuns evitados (peso: 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops condicionais e controle de erros em Python/MATLAB.",
                                "Física/Engenharia: Critérios em solvers de EDOs para modelagem de difusão ou mecânica.",
                                "Estatística: Tolerâncias em métodos iterativos como EM ou otimização.",
                                "Ciência da Computação: Análise de complexidade e detecção de não-convergência."
                              ],
                              "realWorldApplication": "Em simulações de engenharia estrutural, define critérios para resolver BVPs em perfis de vigas ou aerodinâmica, garantindo soluções precisas em tempo real sem sobrecarga computacional em softwares como ANSYS ou COMSOL."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.4",
                            "name": "Analisar convergência quadrática local",
                            "description": "Verificar condições para convergência do método de Newton (φ'(s*) ≠ 0, chute próximo), e discutir limitações do método de tiro simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da convergência quadrática no método de Newton",
                                  "subSteps": [
                                    "Recordar a definição do método de Newton para encontrar raízes de f(x) = 0.",
                                    "Explicar a ordem de convergência quadrática quando as condições são satisfeitas.",
                                    "Derivar brevemente a taxa de convergência usando expansão de Taylor.",
                                    "Identificar φ(s) no contexto do método de tiro simples como φ(s) = y(b; s) - α.",
                                    "Estudar o teorema de convergência local do método de Newton."
                                  ],
                                  "verification": "Resumir em um parágrafo as condições para convergência quadrática e citar o teorema relevante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno de anotações, calculadora científica.",
                                  "tips": "Use diagramas de iterações para visualizar a aceleração quadrática.",
                                  "learningObjective": "Compreender a base teórica da convergência quadrática no método de Newton.",
                                  "commonMistakes": "Confundir convergência quadrática com linear; ignorar hipóteses do teorema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a condição φ'(s*) ≠ 0",
                                  "subSteps": [
                                    "Calcular φ'(s) explicitamente para o método de tiro simples.",
                                    "Interpretar φ'(s*) como a derivada da solução y(b; s) em relação a s no ponto s*.",
                                    "Verificar se φ'(s*) = 0 implica singularidade (problema mal posto).",
                                    "Discutir condições no problema de BVP que garantem φ'(s*) ≠ 0.",
                                    "Resolver um exemplo analítico simples onde φ'(s*) é computado."
                                  ],
                                  "verification": "Computar φ'(s*) para um BVP modelo e confirmar ≠ 0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra simbólica (ex: Mathematica ou SymPy), exemplos de BVPs lineares.",
                                  "tips": "Linearize o problema para BVPs não lineares para aproximar φ'(s*).",
                                  "learningObjective": "Dominar o cálculo e significado da condição diferenciabilidade não nula.",
                                  "commonMistakes": "Assumir φ'(s*) sempre existe sem verificar regularidade da solução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a necessidade de chute inicial próximo",
                                  "subSteps": [
                                    "Explicar o conceito de 'chute próximo' (s0 perto de s*).",
                                    "Estudar o raio de convergência local do método de Newton.",
                                    "Simular numericamente iterações com chutes bons vs. ruins.",
                                    "Quantificar 'próximo' usando normas ou distâncias relativas.",
                                    "Discutir estratégias para obter bons chutes iniciais (ex: solução linearizada)."
                                  ],
                                  "verification": "Executar simulação numérica mostrando convergência para chute próximo e falha para distante.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB/Python com solvers ODE (ex: ode45/scipy.integrate), gráficos de erro.",
                                  "tips": "Plote log do erro por iteração para observar ordem 2.",
                                  "learningObjective": "Entender o papel crítico do chute inicial na convergência local.",
                                  "commonMistakes": "Subestimar sensibilidade ao chute; não normalizar erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir limitações do método de tiro simples",
                                  "subSteps": [
                                    "Identificar sensibilidade a chutes iniciais ruins levando a divergência.",
                                    "Explicar problemas com BVPs rígidos ou oscilatórios.",
                                    "Comparar com métodos múltiplos tiros ou shooting com relaxação.",
                                    "Analisar custo computacional (múltiplas integrações ODE por iteração).",
                                    "Propor melhorias como método de Newton modificado ou arc-length continuation."
                                  ],
                                  "verification": "Listar 3 limitações principais com exemplos contrários onde falha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos sobre métodos de BVP, exemplos numéricos falhos.",
                                  "tips": "Use contraexemplos para ilustrar limitações vívidas.",
                                  "learningObjective": "Criticar o método de tiro simples e sugerir alternativas.",
                                  "commonMistakes": "Ignorar contextos onde método falha (ex: turning points)."
                                }
                              ],
                              "practicalExample": "Para o BVP y'' + y = 0, y(0)=0, y(π)=0, mas alterado para não linear: y'' + sin(y)=0, y(0)=0, y(π)=α. Use s=y'(0), φ(s)=y(π;s)-α. Verifique φ'(s*)=cos(s*) ≠0, inicie com s0=1 próximo de s*≈0.9, observe convergência quadrática em 3 iterações.",
                              "finalVerifications": [
                                "Conseguiu derivar φ'(s) corretamente para um BVP dado.",
                                "Simulação numérica confirma ordem de convergência ≈2.",
                                "Identificou corretamente quando φ'(s*)=0 causa falha.",
                                "Listou pelo menos 3 limitações do método de tiro simples.",
                                "Propôs estratégia para bom chute inicial.",
                                "Explicou impacto de chute ruim com gráfico de erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de condições de convergência (φ'(s*)≠0, s0 próximo).",
                                "Qualidade da análise numérica com evidência de ordem quadrática.",
                                "Profundidade na discussão de limitações e alternativas.",
                                "Clareza em exemplos práticos e verificações.",
                                "Uso correto de conceitos de análise numérica (Taylor, teoremas).",
                                "Capacidade de conectar teoria à implementação computacional."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação em equações diferenciais de mecânica (ex: pêndulo).",
                                "Programação: Implementação em Python/MATLAB de solvers ODE e Newton.",
                                "Engenharia: Modelagem de BVPs em estruturas ou fluidos.",
                                "Estatística: Análise de erros numéricos e convergência estocástica."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar perfis de temperatura em foguetes (BVPs térmicos) usando tiro simples com Newton para convergência rápida, evitando simulações caras em malhas finitas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Método de Tiro Múltiplo",
                    "description": "Extensão do método de tiro dividindo o intervalo em subintervalos para melhorar estabilidade e convergência em problemas não lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Princípios do Método de Tiro Simples como Base",
                        "description": "Revisão do método de tiro simples para problemas de valor de contorno, destacando suas limitações em problemas não lineares, como instabilidade e convergência lenta, motivando a extensão para o método de tiro múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Compreender o Método de Tiro Simples",
                            "description": "Explicar como transformar um problema de valor de contorno (BVP) em um problema de valor inicial (IVP) por meio de chute inicial para condições faltantes, resolvendo a EDO numericamente e ajustando via iteração de Newton-Raphson para satisfazer condições de contorno remotas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação do Problema de Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Identificar as condições de contorno em um BVP de segunda ordem: uma condição inicial conhecida e uma condição remota desconhecida.",
                                    "Reescrever o BVP de segunda ordem como um sistema de EDOs de primeira ordem.",
                                    "Explicar por que o BVP não pode ser resolvido diretamente como IVP.",
                                    "Discutir a necessidade de um 'chute' inicial para a condição faltante.",
                                    "Estudar exemplos clássicos de BVPs lineares e não-lineares."
                                  ],
                                  "verification": "Capacidade de reescrever um BVP dado como sistema de primeira ordem e identificar condições faltantes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre EDOs",
                                    "Software de cálculo simbólico como SymPy"
                                  ],
                                  "tips": "Sempre reduza a ordem da EDO para facilitar a compreensão do método.",
                                  "learningObjective": "Entender a estrutura matemática de um BVP e sua conversão preliminar para IVP.",
                                  "commonMistakes": [
                                    "Confundir condições de Dirichlet com Neumann",
                                    "Esquecer de transformar EDO de segunda ordem em sistema de primeira ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformar BVP em Problema de Valor Inicial (IVP) com chute inicial",
                                  "subSteps": [
                                    "Escolher um valor inicial arbitrário (chute) para a derivada y'(0) ou condição faltante.",
                                    "Formular o IVP completo: y'(x) = f(x, y, y'), y(a) = α, y'(a) = s₀ (chute).",
                                    "Integrar o IVP até o ponto b onde está a condição remota.",
                                    "Calcular o resíduo: r(s₀) = φ(b) - β, onde φ(b) é o valor obtido e β é a condição desejada.",
                                    "Analisar como r(s) varia com diferentes chutes s."
                                  ],
                                  "verification": "Implementar um chute inicial e calcular o resíduo manualmente para um exemplo simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para integração básica",
                                    "Exemplos resolvidos de BVPs"
                                  ],
                                  "tips": "Comece com chutes próximos ao valor esperado para convergência rápida.",
                                  "learningObjective": "Dominar a transformação de BVP em IVP parametrizado pelo chute inicial.",
                                  "commonMistakes": [
                                    "Escolher chute muito distante, causando divergência",
                                    "Confundir y(b) com y'(b) na condição remota"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver numericamente o IVP com métodos apropriados",
                                  "subSteps": [
                                    "Selecionar um método numérico para IVP, como Runge-Kutta de ordem 4.",
                                    "Implementar o resolvedor numérico para o sistema de EDOs.",
                                    "Avaliar a solução no ponto b para cada chute.",
                                    "Testar sensibilidade numérica: h-step size e tolerâncias.",
                                    "Visualizar soluções para diferentes chutes para entender o comportamento."
                                  ],
                                  "verification": "Gerar gráfico de soluções numéricas para 3 chutes diferentes e calcular resíduos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy (solve_ivp)",
                                    "MATLAB (ode45)",
                                    "Gráficos interativos com Matplotlib"
                                  ],
                                  "tips": "Use Runge-Kutta adaptativo para precisão automática.",
                                  "learningObjective": "Aplicar solvers numéricos para IVPs derivados de BVPs.",
                                  "commonMistakes": [
                                    "Passo h muito grande levando a erros de truncamento",
                                    "Não normalizar o sistema de EDOs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o chute via iteração de Newton-Raphson para satisfazer condições de contorno",
                                  "subSteps": [
                                    "Definir a função de erro: F(s) = φ(b; s) - β.",
                                    "Calcular a derivada F'(s) aproximando com diferenças finitas ou sensibilidade.",
                                    "Aplicar iteração de Newton: s_{k+1} = s_k - F(s_k)/F'(s_k).",
                                    "Verificar convergência: |F(s)| < ε e |s_{k+1} - s_k| < δ.",
                                    "Analisar condições de convergência e múltiplas soluções."
                                  ],
                                  "verification": "Executar 5 iterações de Newton e confirmar que resíduo < 10^{-6}.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para Newton-Raphson no tiro simples",
                                    "Exemplos numéricos"
                                  ],
                                  "tips": "Para F'(s), resolva dois IVPs próximos ou use método de sensibilidade.",
                                  "learningObjective": "Implementar o loop de correção Newton-Raphson para convergência do método de tiro.",
                                  "commonMistakes": [
                                    "Divisão por zero em F'(s)≈0",
                                    "Não checar convergência linear vs quadrática"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y'' + y = 0, y(0) = 0, y(π) = 1 usando Método de Tiro Simples. Chute inicial s₀=1 para y'(0). Use RK4 com h=0.1 e Newton-Raphson até resíduo <10^{-5}. Solução esperada: y(x) = sin(x).",
                              "finalVerifications": [
                                "Explicar verbalmente os 4 passos do método de tiro simples.",
                                "Resolver manualmente um BVP linear simples com chute e uma iteração Newton.",
                                "Implementar código completo em Python que converge para um exemplo dado.",
                                "Identificar quando o método falha (ex: BVP não-linear com múltiplas soluções).",
                                "Comparar solução numérica com analítica em gráfico.",
                                "Calcular ordem de convergência da iteração Newton."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução numérica (erro <10^{-4}).",
                                "Número de iterações Newton ≤10 para convergência.",
                                "Correta formulação da função F(s) e F'(s).",
                                "Uso adequado de método numérico para IVP (ex: RK4).",
                                "Análise de erros comuns e sensibilidade a chutes iniciais.",
                                "Clareza na explicação escrita ou código comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/SciPy.",
                                "Física: Modelagem de osciladores harmônicos e ondas.",
                                "Engenharia: Análise de estruturas (deflexão de vigas).",
                                "Estatística: Análise de erros numéricos e convergência.",
                                "Cálculo: Derivadas implícitas e métodos iterativos."
                              ],
                              "realWorldApplication": "O Método de Tiro Simples é usado em engenharia aeroespacial para trajetórias de mísseis (BVPs em dinâmica), em finanças para pricing de opções (EDOs de Black-Scholes), e em biologia para modelagem de difusão em membranas com condições de contorno."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Identificar Limitações em Problemas Não Lineares",
                            "description": "Analisar casos onde o método de tiro simples falha devido a instabilidade numérica, divergência em problemas stiff ou convergência lenta, relacionando com métodos de passo simples para IVPs (LeVeque, 2007).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios do Método de Tiro Simples para BVPs",
                                  "subSteps": [
                                    "Relembre a formulação de Problemas de Valor de Contorno (BVPs) como sistemas de EDOs com condições de contorno separadas.",
                                    "Descreva o método de tiro simples: chute inicial para IVP e ajuste iterativo para matching das condições de contorno.",
                                    "Implemente um exemplo linear simples em Python/MATLAB para observar convergência básica.",
                                    "Analise a dependência em solvers de IVP como Runge-Kutta.",
                                    "Discuta linearidade assumida e transição para não-lineares."
                                  ],
                                  "verification": "Implemente e resolva um BVP linear simples com convergência bem-sucedida; confirme matching de condições de contorno com erro < 1e-6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro LeVeque (2007) Capítulo 2; Python com SciPy (solve_bvp); MATLAB bvp4c.",
                                  "tips": "Use gráficos para visualizar trajetórias de soluções e matching de contorno.",
                                  "learningObjective": "Compreender a base do método de tiro simples e sua relação com solvers de IVP.",
                                  "commonMistakes": "Confundir condições de contorno iniciais com terminais; ignorar normalização de condições mistas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Características de Problemas Não-Lineares em BVPs",
                                  "subSteps": [
                                    "Identifique EDOs não-lineares comuns, como y'' = f(x,y,y') com termos quadráticos ou exponenciais.",
                                    "Formule um BVP não-linear exemplo: y'' + y^2 = 0 com y(0)=0, y(1)=1.",
                                    "Aplique método de tiro simples com chutes iniciais variados e observe padrões de falha.",
                                    "Registre métricas: número de iterações, resíduos de contorno e estabilidade da solução.",
                                    "Compare com casos lineares para destacar diferenças."
                                  ],
                                  "verification": "Gere tabela comparativa de chutes iniciais vs. resíduos; identifique pelo menos 3 padrões de comportamento não-linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook; SciPy odeint/solve_ivp; LeVeque (2007) Seção 10.1.",
                                  "tips": "Varie chutes em grade sistemática (e.g., [-2,-1,0,1,2]) para mapear basins de atração.",
                                  "learningObjective": "Reconhecer como não-linearidades introduzem sensibilidade a condições iniciais.",
                                  "commonMistakes": "Escolher chutes muito amplos levando a overflow; não escalar o problema adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar Limitações Específicas: Instabilidade, Divergência e Convergência Lenta",
                                  "subSteps": [
                                    "Analise instabilidade numérica: observe oscilações ou blow-up em trajetórias para problemas stiff.",
                                    "Teste divergência em stiff problems: use y'' = -1000 y' com contornos que exijam damping.",
                                    "Meça convergência lenta: conte iterações até tolerância em problemas com múltiplas soluções.",
                                    "Relacione com limitações de métodos de passo simples em IVPs (e.g., Euler explícito em stiff).",
                                    "Documente logs de solver para identificar warnings de step rejection."
                                  ],
                                  "verification": "Classifique 3 exemplos: um instável, um divergente, um de convergência lenta, com gráficos e métricas quantitativas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código fonte de solvers (SciPy docs); exemplos de LeVeque p. 567-570.",
                                  "tips": "Ative verbose logging nos solvers para rastrear falhas de passo.",
                                  "learningObjective": "Diagnosticar falhas específicas e ligá-las a propriedades do problema não-linear.",
                                  "commonMistakes": "Atribuir falhas ao solver em vez da não-linearidade; ignorar escalas de tempo stiff."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Análise e Relacionar com Alternativas",
                                  "subSteps": [
                                    "Resuma limitações: sensibilidade a chutes, falha em múltiplas soluções, ineficiência em stiff.",
                                    "Compare com método de tiro múltiplo: distribuição de chutes e interpolação.",
                                    "Discuta relaxação de Newton como alternativa para não-lineares.",
                                    "Teste um exemplo borderline onde tiro simples falha mas múltiplo succeeds.",
                                    "Proponha critérios para escolher método baseado em diagnóstico."
                                  ],
                                  "verification": "Crie relatório com tabela de limitações vs. soluções alternativas; valide com simulação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "LeVeque (2007) Capítulo 10; artigos sobre multiple shooting.",
                                  "tips": "Use fluxogramas para decisão: linear? Tiro simples; stiff/não-linear? Múltiplo/Newton.",
                                  "learningObjective": "Integrar diagnóstico para seleção informada de métodos avançados.",
                                  "commonMistakes": "Superestimar robustez do tiro simples; não considerar custo computacional."
                                }
                              ],
                              "practicalExample": "Considere o BVP não-linear y'' + 50 y y' = 0, y(0)=0, y(π)=0 (problema stiff de Bratu). Método de tiro simples diverge para chutes y'(0)>0.1 devido a instabilidade; convergência lenta (>100 iterações) para chutes precisos; resolva com multiple shooting para validação.",
                              "finalVerifications": [
                                "Corretamente identifica instabilidade em 80% dos testes stiff.",
                                "Detecta divergência via blow-up ou step rejection em logs.",
                                "Quantifica convergência lenta (>50 iterações para tol=1e-6).",
                                "Relaciona falhas a limitações de IVP solvers de passo simples.",
                                "Propõe alternativa viável (e.g., multiple shooting) com justificativa.",
                                "Valida com gráfico de resíduos vs. iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão no diagnóstico de limitações (instabilidade/divergência/lentidão): 30%.",
                                "Uso correto de métricas numéricas (resíduos, iterações): 25%.",
                                "Relacionamento explícito com métodos de IVP: 20%.",
                                "Exemplos práticos implementados e analisados: 15%.",
                                "Clareza na síntese e propostas de melhoria: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores não-lineares em mecânica (e.g., pêndulo duplo).",
                                "Computação: Otimização numérica e análise de algoritmos (root-finding em não-lineares).",
                                "Engenharia: Simulações CFD onde BVPs stiff surgem em fluxos viscosos.",
                                "Estatística: Inferência em modelos diferenciais com incertezas paramétricas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, identificar limitações do tiro simples em BVPs não-lineares para perfis de asas (equações de Prandtl-Glauert) evita simulações instáveis, permitindo transição para multiple shooting em softwares como ANSYS para designs confiáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Motivação para o Tiro Múltiplo",
                            "description": "Justificar a divisão do intervalo de integração em subintervalos para reduzir sensibilidade a erros iniciais e melhorar estabilidade em problemas não lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Tiro Simples e seus Problemas",
                                  "subSteps": [
                                    "Recordar a formulação de um problema de valor de contorno (PVC) de segunda ordem não linear: y'' = f(x, y, y') com condições y(a) = α e y(b) = β.",
                                    "Descrever o método de tiro simples: adivinhar y'(a) = s e integrar até x = b, ajustando s via método de busca (ex: secante).",
                                    "Simular um exemplo simples em software numérico para observar sensibilidade a pequenas variações em s.",
                                    "Analisar graficamente o 'tiro' que erra o alvo β devido a amplificação de erros.",
                                    "Discutir por que problemas não lineares amplificam erros iniciais ao longo do intervalo [a, b]."
                                  ],
                                  "verification": "Capacidade de reproduzir um exemplo numérico onde pequenas mudanças em y'(a) causam grandes desvios em y(b).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Software: Python com SciPy (odeint) ou MATLAB"
                                  ],
                                  "tips": "Use intervalos pequenos para integração inicialmente para visualizar erros claramente.",
                                  "learningObjective": "Compreender as limitações fundamentais do método de tiro simples em PVCs não lineares.",
                                  "commonMistakes": [
                                    "Confundir PVC inicial com problema de valor inicial (PVI).",
                                    "Ignorar não linearidades que causam bifurcações.",
                                    "Subestimar a propagação de erros em integrações longas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Sensibilidade a Erros Iniciais",
                                  "subSteps": [
                                    "Estudar a dependência de y(b) em relação a y'(a): calcular ∂y(b)/∂s via sensibilidade.",
                                    "Realizar testes numéricos variando s em ±1% e medir o erro em y(b).",
                                    "Explicar matematicamente usando teoria de estabilidade de EDOs: soluções sensíveis em problemas rígidos ou oscilatórios.",
                                    "Comparar com problemas lineares, onde o tiro simples converge monotonicamente.",
                                    "Documentar resultados em tabela: variação em s vs. erro em y(b)."
                                  ],
                                  "verification": "Tabela ou gráfico mostrando amplificação exponencial de erros iniciais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook ou MATLAB script",
                                    "Exemplo: y'' + y = 0 com y(0)=0, y(π)=0 (mas torná-lo não linear: y'' + y^3 = 0)"
                                  ],
                                  "tips": "Linearize localmente para estimar sensibilidade sem resolver múltiplas vezes.",
                                  "learningObjective": "Quantificar e visualizar a instabilidade do tiro simples devido a erros iniciais.",
                                  "commonMistakes": [
                                    "Usar passos de integração grosseiros que mascaram erros reais.",
                                    "Confundir erro numérico de integração com erro de chute inicial.",
                                    "Não normalizar erros para comparação justa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a Divisão do Intervalo em Subintervalos",
                                  "subSteps": [
                                    "Propor dividir [a, b] em N subintervalos: [a=x0, x1], [x1,x2], ..., [x_{N-1},b].",
                                    "Descrever o método de tiro múltiplo: resolver PVIs sequenciais, ajustando condições de contorno em cada nó xi.",
                                    "Definir condições: y(xi) e y'(xi) como 'chutes' para o próximo subintervalo, com matching em y(xi).",
                                    "Escolher N baseado em comprimento do intervalo e rigidez do problema (ex: N=3-5 inicialmente).",
                                    "Esboçar fluxograma do algoritmo iterativo para convergência global."
                                  ],
                                  "verification": "Diagrama ou fluxograma claro da estrutura multi-tiro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboço",
                                    "Referência: Atkinson 'Numerical Analysis' capítulo sobre BVP"
                                  ],
                                  "tips": "Comece com N=2 para simplicidade conceitual antes de generalizar.",
                                  "learningObjective": "Compreender a arquitetura do tiro múltiplo como solução para intervalos longos.",
                                  "commonMistakes": [
                                    "Confundir matching de y(xi) com y'(xi).",
                                    "Escolher subintervalos desiguais sem justificativa.",
                                    "Ignorar iterações globais entre subtiros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar Redução de Sensibilidade e Melhoria na Estabilidade",
                                  "subSteps": [
                                    "Explicar: erros iniciais confinados a subintervalos curtos, reduzindo amplificação.",
                                    "Comparar numericamente: resolver mesmo PVC com tiro simples vs. múltiplo (N=4), medindo iterações e precisão.",
                                    "Analisar estabilidade: cada subtiro tem 'horizonte' curto, menos sensível a não linearidades.",
                                    "Discutir convergência: sistema de N equações para N+1 condições (mas reduzido).",
                                    "Concluir com vantagens: robustez em problemas rígidos, oscilatórios ou com singularidades."
                                  ],
                                  "verification": "Relatório comparativo com métricas: tempo de CPU, precisão final, número de iterações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código implementado em Python/MATLAB para ambos métodos",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Use solver adaptativo (RK45) para subintegrações precisas.",
                                  "learningObjective": "Justificar matematicamente e empiricamente os benefícios do tiro múltiplo.",
                                  "commonMistakes": [
                                    "Atribuir melhorias apenas a mais computação, ignorando redução de sensibilidade.",
                                    "Não testar em problemas verdadeiramente não lineares.",
                                    "Superestimar N sem custo computacional."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o PVC não linear y'' = -y + (y')^2 com y(0)=1, y(5)=2. No tiro simples, variações de 0.01 em y'(0) causam erros >10 em y(5). Dividindo em 4 subintervalos [0,1.25],[1.25,2.5], etc., o erro é confinado, convergindo em <10 iterações vs. >50 no simples (implemente em SciPy).",
                              "finalVerifications": [
                                "Explicar verbalmente por que erros se amplificam no tiro simples mas não no múltiplo.",
                                "Reproduzir gráfico de sensibilidade para um PVC exemplo.",
                                "Implementar código simples comparando ambos métodos.",
                                "Identificar quando N=1 recupera o tiro simples.",
                                "Discutir trade-off: precisão vs. custo computacional.",
                                "Prever falhas potenciais em problemas com camadas de contorno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática da sensibilidade (∂y(b)/∂s).",
                                "Qualidade dos testes numéricos (gráficos e tabelas claras).",
                                "Correção conceitual da divisão em subintervalos e matching.",
                                "Justificativa quantitativa de estabilidade melhorada.",
                                "Capacidade de generalizar para problemas rígidos.",
                                "Clareza no fluxograma e código implementado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em EDOs de mecânica oscilatória (ex: pêndulo duplo).",
                                "Engenharia: Modelagem de difusão reativa em reatores químicos.",
                                "Computação: Otimização numérica e solvers de BVP em bibliotecas como GSL.",
                                "Física Computacional: Simulações de fluidos com condições de contorno."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, modelar perfis de temperatura em foguetes (EDOs não lineares em longos intervalos); divisão reduz sensibilidade a incertezas em condições iniciais, permitindo simulações estáveis para design otimizado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Divisão do Intervalo e Formulação",
                        "description": "Definição da divisão do intervalo [a, b] em N subintervalos [x_{i-1}, x_i], formulação das condições iniciais em cada subintervalo e condições de continuidade nas junções para garantir solução suave.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Definir Subintervalos e Pontos de Grade",
                            "description": "Estabelecer os pontos de divisão x_0 = a < x_1 < ... < x_N = b e parametrizar condições iniciais extras (parâmetros de tiro) para cada subintervalo, tipicamente y(x_{i-1}) e y'(x_{i-1}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema de Valor de Contorno e Escolher o Número de Subintervalos",
                                  "subSteps": [
                                    "Identifique o intervalo [a, b] do problema de valor de contorno (BVP).",
                                    "Avalie a complexidade da equação diferencial (EDO) e condições de contorno para determinar N (número de subintervalos), tipicamente 2-10 para convergência.",
                                    "Considere fatores como singularidades ou rigidez da EDO para escolher N adaptativamente.",
                                    "Documente a justificativa para N, visando equilíbrio entre precisão e custo computacional.",
                                    "Calcule o comprimento médio de subintervalo h = (b - a)/N."
                                  ],
                                  "verification": "Confirme que N é um inteiro positivo ≥1 e h >0; liste justificativa escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do BVP",
                                    "Papel e lápis ou software como MATLAB/Python para cálculos iniciais"
                                  ],
                                  "tips": "Comece com N pequeno e aumente iterativamente se necessário para testes preliminares.",
                                  "learningObjective": "Compreender como o número de subintervalos afeta a precisão e eficiência do método de tiro múltiplo.",
                                  "commonMistakes": [
                                    "Escolher N muito pequeno levando a baixa precisão",
                                    "Ignorar singularidades no intervalo resultando em falha de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os Pontos de Grade x_i",
                                  "subSteps": [
                                    "Estabeleça x_0 = a e x_N = b.",
                                    "Defina pontos intermediários uniformemente: x_i = a + i*h para i=1 a N-1, onde h=(b-a)/N.",
                                    "Para grades não-uniformes, use critérios como equidistribuição de erro ou refinamento adaptativo perto de singularidades.",
                                    "Liste todos os x_i em ordem crescente e verifique x_{i-1} < x_i para todo i.",
                                    "Plote os pontos para visualização (opcional, mas recomendado)."
                                  ],
                                  "verification": "Verifique se x_0 = a, x_N = b e a sequência é estritamente crescente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou script Python/MATLAB para gerar x_i",
                                    "Gráfico para plotagem"
                                  ],
                                  "tips": "Use grades uniformes inicialmente para simplicidade; refine depois com base em testes.",
                                  "learningObjective": "Dominar a geração de pontos de grade uniformes e não-uniformes para divisão do intervalo.",
                                  "commonMistakes": [
                                    "Pontos sobrepostos ou fora de [a,b]",
                                    "Cálculo incorreto de h levando a x_N ≠ b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Parametrizar Condições Iniciais e Parâmetros de Tiro para Cada Subintervalo",
                                  "subSteps": [
                                    "Para o primeiro subintervalo [x_0, x_1], defina condições conhecidas: y(x_0) da condição de contorno em a, e s_1 = y'(x_0) como primeiro parâmetro de tiro.",
                                    "Para subintervalos subsequentes [x_{i-1}, x_i], y(x_{i-1}) é a solução y(x_{i-1}) do subintervalo anterior, e s_i = y'(x_{i-1}) como parâmetro de tiro i.",
                                    "Formule o vetor de parâmetros de tiro S = [s_1, s_2, ..., s_N].",
                                    "Garanta continuidade: a solução no final de um subintervalo alimenta o início do próximo.",
                                    "Escreva as condições iniciais explicitamente para cada i=1 a N."
                                  ],
                                  "verification": "Confirme que há exatamente N parâmetros de tiro e condições y(x_{i-1}), y'(x_{i-1}) para cada subintervalo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas do BVP",
                                    "Folha de cálculo para listar condições"
                                  ],
                                  "tips": "Anote S como vetor coluna para clareza em otimizadores numéricos.",
                                  "learningObjective": "Aprender a formular condições iniciais extras necessárias para resolver EDOs em cada subintervalo.",
                                  "commonMistakes": [
                                    "Confundir y(x_{i-1}) com condição de contorno em vez de saída anterior",
                                    "Número incorreto de parâmetros (deve ser N para 2ª ordem)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Consistência e Preparar para Integração Numérica",
                                  "subSteps": [
                                    "Verifique se as condições de contorno em b são usadas para o sistema não-linear: y(x_N) = valor dado e possivelmente y'(x_N).",
                                    "Confirme continuidade de y e y' nos pontos x_i internos (exceto y' que é parametrizado).",
                                    "Esboce o esquema geral: integrar EDO em cada subintervalo com IVP usando S, e resolver para S que satisfaça contornos.",
                                    "Teste com um problema simples para validar setup.",
                                    "Documente a grade e parâmetros em formato pronto para código."
                                  ],
                                  "verification": "Simule um tiro simples e cheque se o framework está consistente com o BVP original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Solver numérico como ode45 (MATLAB) ou scipy.integrate (Python)",
                                    "Exemplo BVP simples"
                                  ],
                                  "tips": "Use matching conditions: y(x_i^-) = y(x_i^+), mas y' parametrizado garante flexibilidade.",
                                  "learningObjective": "Garantir que a divisão e parametrização formem um sistema fechado para o método de tiro múltiplo.",
                                  "commonMistakes": [
                                    "Esquecer matching de y nos pontos internos",
                                    "Não alinhar com condições de contorno finais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP y'' + y = 0 em [0, π] com y(0)=0, y(π)=0, use N=2: x_0=0, x_1=π/2, x_2=π. Condições: [0,x1]: y(0)=0, y'(0)=s1; [x1,x2]: y(π/2)=y(π/2^- de primeiro tiro), y'(π/2)=s2. Resolva para s1,s2 tal que y(π)=0.",
                              "finalVerifications": [
                                "Todos x_i estão em [a,b] com x_0=a, x_N=b e estritamente crescentes.",
                                "Existem exatamente N parâmetros de tiro s_i.",
                                "Condições iniciais para cada subintervalo usam saída do anterior para y(x_{i-1}).",
                                "Continuidade de y garantida nos pontos internos.",
                                "Condições de contorno em b usadas para fechar o sistema.",
                                "Documentação completa com lista de x_i e S."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha de N e justificativa (20%)",
                                "Correção na definição de pontos de grade (25%)",
                                "Formulação exata de condições iniciais e parâmetros (30%)",
                                "Verificação de consistência e continuidade (15%)",
                                "Clareza na documentação e preparação para implementação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação em problemas de contorno em mecânica (ex: cordas vibrantes).",
                                "Computação: Implementação em solvers numéricos como Runge-Kutta.",
                                "Engenharia: Modelagem de difusão ou fluxo em domínios divididos.",
                                "Estatística: Otimização não-linear para encontrar parâmetros S."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, dividir o domínio de voo de um foguete em subintervalos para simular trajetórias com EDOs de ordem alta, ajustando parâmetros de 'tiro' (velocidades iniciais) em cada fase para matching de condições finais como altitude alvo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Estabelecer Condições de Interface",
                            "description": "Impor condições de continuidade de ordem k (ex.: y e y' contínuos) nas junções x_i para problemas de segunda ordem, formulando resíduos que devem ser zerados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as condições de continuidade para EDOs de segunda ordem",
                                  "subSteps": [
                                    "Revise o problema de valor de contorno (PVC) de segunda ordem e o método de tiro múltiplo.",
                                    "Identifique que soluções devem ser contínuas em y e y' nas junções para manter a regularidade da solução global.",
                                    "Explique por que condições de ordem k (k=2 aqui) são necessárias: preservar derivadas até ordem k-1.",
                                    "Estude exemplos simples de PVC lineares para visualizar descontinuidades sem condições.",
                                    "Anote as condições gerais: y(x_i^-) = y(x_i^+), y'(x_i^-) = y'(x_i^+)"
                                  ],
                                  "verification": "Resuma em um parágrafo as razões para as condições de continuidade e liste-as explicitamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações",
                                    "Exemplos de PVC de segunda ordem"
                                  ],
                                  "tips": "Visualize graficamente: a solução deve ser C^1 contínua (contínua com derivada contínua).",
                                  "learningObjective": "Entender o papel das condições de interface na construção de soluções suaves em métodos de domínio múltiplo.",
                                  "commonMistakes": [
                                    "Confundir continuidade apenas em y, ignorando y'",
                                    "Aplicar condições de ordem superior desnecessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e dividir o intervalo em subdomínios com pontos de junção",
                                  "subSteps": [
                                    "Defina o intervalo global [a,b] e escolha N pontos de divisão x_0 = a < x_1 < ... < x_N = b.",
                                    "Justifique a escolha dos x_i (ex: equidistantes ou adaptativos).",
                                    "Para cada junção x_i (i=1 a N-1), liste as condições necessárias: 2 por junção para EDO de ordem 2.",
                                    "Desenhe um diagrama do intervalo dividido destacando as junções.",
                                    "Calcule o número total de condições: 2*(N-1) para N subintervalos."
                                  ],
                                  "verification": "Crie um diagrama com 3 subintervalos e rotule todas as condições de interface.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho (ex: GeoGebra ou papel)",
                                    "Calculadora para espaçamentos"
                                  ],
                                  "tips": "Comece com poucos subdomínios (N=2) para simplicidade antes de generalizar.",
                                  "learningObjective": "Saber dividir o domínio e quantificar condições de interface corretamente.",
                                  "commonMistakes": [
                                    "Pontos de junção coincidentes com contornos",
                                    "Esquecer condições nas extremidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular as condições de interface como equações",
                                  "subSteps": [
                                    "Para cada x_i, escreva y_left(x_i) = y_right(x_i) onde left é solução do subproblema i-1, right do i.",
                                    "Similarmente para derivadas: y'_left(x_i) = y'_right(x_i).",
                                    "Expresse em termos de parâmetros de tiro (ex: valores iniciais em cada subdomínio).",
                                    "Geralize para condições de ordem k: continuidade até derivada k-1.",
                                    "Verifique dimensionalidade: condições devem igualar o número de parâmetros extras."
                                  ],
                                  "verification": "Escreva as 4 equações para N=2 em um PVC exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de exercícios com PVC padrão",
                                    "Python/MATLAB para protótipo simbólico (opcional)"
                                  ],
                                  "tips": "Use notação consistente: subscritos L e R para left/right.",
                                  "learningObjective": "Formular matematicamente as condições de continuidade nas junções.",
                                  "commonMistakes": [
                                    "Inverter left/right",
                                    "Usar condições erradas para ordem da EDO"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir resíduos de interface e incorporá-los ao sistema",
                                  "subSteps": [
                                    "Defina resíduos R1_i = y_left(x_i) - y_right(x_i) = 0.",
                                    "R2_i = y'_left(x_i) - y'_right(x_i) = 0 para cada i.",
                                    "Inclua esses resíduos no vetor de condições não-lineares a ser resolvido numericamente.",
                                    "Discuta como resolver o sistema acoplado (ex: Newton-Raphson multi-tiro).",
                                    "Teste com um exemplo numérico simples para validar resíduos zerados."
                                  ],
                                  "verification": "Implemente resíduos em pseudocódigo e verifique se zeram em solução conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com SciPy para teste numérico",
                                    "Exemplo resolvido de livro-texto"
                                  ],
                                  "tips": "Resíduos devem ser funções diferenciáveis para métodos de Newton.",
                                  "learningObjective": "Construir o sistema completo de resíduos incluindo interfaces para otimização.",
                                  "commonMistakes": [
                                    "Resíduos com sinal errado",
                                    "Não acoplar corretamente com condições de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVC y'' + y = 0 em [0, π], y(0)=0, y(π)=0. Divida em [0, π/2] e [π/2, π]. Soluções locais: y1 = A sin(x) + B cos(x), y2 = C sin(x) + D cos(x). Condições em x=π/2: y1(π/2)=y2(π/2), y1'(π/2)=y2'(π/2). Resíduos: R1 = A sin(π/2) + B cos(π/2) - C sin(π/2) - D cos(π/2) = 0, etc. Resolva com contornos para sistema 4x4.",
                              "finalVerifications": [
                                "Liste corretamente as condições de continuidade para EDO de ordem 2 em qualquer junção.",
                                "Formule resíduos zeráveis para 2 subdomínios sem erros de sinal.",
                                "Verifique que o número de condições equals parâmetros de tiro.",
                                "Aplique em um exemplo e confirme solução global C^1.",
                                "Explique impacto de violar condições (ex: solução não-física)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de condições (y e y' contínuos).",
                                "Correção dos resíduos (zerados nas junções).",
                                "Consistência com ordem da EDO (k condições por junção).",
                                "Capacidade de generalizar para múltiplos subdomínios.",
                                "Clareza na explicação e diagramas.",
                                "Validação numérica ou analítica em exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Condições de interface em equações de onda ou calor com materiais compostos.",
                                "Programação: Implementação em solvers numéricos (SciPy ODEINT com condições).",
                                "Engenharia: Modelagem de vigas compostas ou circuitos com junções.",
                                "Análise Matemática: Teorema de existência para PVC com domínios múltiplos."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em paredes multicamadas (ex: isolamento térmico), condições de continuidade de temperatura (y) e fluxo de calor (-k y') nas interfaces garantem modelo físico realista, usado em engenharia civil e HVAC."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Formular o Sistema de Resíduos",
                            "description": "Construir o vetor de resíduos combinando condições de contorno em a e b com condições de interface nos pontos internos, resultando em um sistema não linear de dimensão proporcional a N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a malha de pontos e os parâmetros desconhecidos",
                                  "subSteps": [
                                    "Divida o intervalo [a, b] em N subintervalos iguais, definindo os pontos x_i = a + i*h para i=0 a N, onde h=(b-a)/N.",
                                    "Identifique os parâmetros desconhecidos: y_i^* e s_i^* = y'(x_i) para i=0 a N-1, totalizando 2N unknowns.",
                                    "Anote que y_0^* será ajustado pela condição em a, e os valores em b serão verificados indiretamente.",
                                    "Esboce um diagrama da malha com setas indicando os segmentos e os valores iniciais y_i^*, s_i^*."
                                  ],
                                  "verification": "Verifique se o número de unknowns é exatamente 2N e se a malha cobre [a,b] corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, notas do método de tiro múltiplo.",
                                  "tips": "Use h uniforme para simplificar inicialmente; generalize depois.",
                                  "learningObjective": "Compreender a discretização do domínio e a parametrização dos IVPs.",
                                  "commonMistakes": "Contar errado o número de unknowns (ex: esquecer s_{N-1}^*); confundir N subintervalos com N+1 pontos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular os resíduos das condições de contorno",
                                  "subSteps": [
                                    "Escreva o resíduo em a: R_1 = ψ_a(y_0^*, s_0^*), ex: para y(a)=α, R_1 = y_0^* - α.",
                                    "Escreva o resíduo em b: R_{2N} = ψ_b(y_N^-, s_N^-), onde y_N^-, s_N^- são obtidos integrando o último segmento de x_{N-1} a x_N com y_{N-1}^*, s_{N-1}^*; ex: y_N^- - β.",
                                    "Note que esses resíduos dependem apenas dos parâmetros locais ou da cadeia de integrações.",
                                    "Verifique dimensionalidade: 2 resíduos para as 2 condições de contorno."
                                  ],
                                  "verification": "Confirme que R_1=0 satisfaz a condição em a isoladamente e R_{2N}=0 em b após todas integrações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, exemplo de BVP de segundo ordem.",
                                  "tips": "Comece com condições de Dirichlet puras para simplicidade.",
                                  "learningObjective": "Dominar a incorporação das condições de contorno no vetor de resíduos.",
                                  "commonMistakes": "Incluir s_N^* como unknown (não existe); ignorar dependência não-linear em ψ_b."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular os resíduos das condições de interface",
                                  "subSteps": [
                                    "Para cada interface k=1 a N-1, integre o segmento k de x_{k-1} a x_k com iniciais y_{k-1}^*, s_{k-1}^*, obtendo y_k^- e y_k'^- (funções dos parâmetros até k).",
                                    "Defina R_{2k} = y_k^* - y_k^- (continuidade de y em x_k).",
                                    "Defina R_{2k+1} = s_k^* - y_k'^- (continuidade de y' em x_k).",
                                    "Observe que há 2(N-1) resíduos de interface, totalizando com contornos 2N."
                                  ],
                                  "verification": "Simule com valores fixos: se todos parâmetros corretos, todos R_{2k}=R_{2k+1}=0 nas interfaces.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software simbólico como SymPy ou papel para EDO linear simples.",
                                  "tips": "Pense nos resíduos como 'erros de matching' entre segmentos adjacentes.",
                                  "learningObjective": "Entender como garantir continuidade multi-segmento via resíduos.",
                                  "commonMistakes": "Confundir y_k^- com y_k^* no índice; esquecer propagação de erros de parâmetros anteriores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o vetor de resíduos completo e analisar propriedades",
                                  "subSteps": [
                                    "Compile o vetor R(Φ) = [R_1, R_2, ..., R_{2N}]^T onde Φ = [y_0^*, s_0^*, ..., y_{N-1}^*, s_{N-1}^*].",
                                    "Escreva explicitamente: R_1=ψ_a, R_{2k/2k+1}=matching em k, R_{2N}=ψ_b.",
                                    "Verifique que R: ℝ^{2N} → ℝ^{2N} é contínua e geralmente não-linear devido às integrações.",
                                    "Discuta resolução: buscar Φ tal que R(Φ)=0 via Newton-Raphson.",
                                    "Teste com N=1 (reduz a tiro simples)."
                                  ],
                                  "verification": "O vetor tem 2N componentes; cada uma corresponde a uma condição física.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto ou LaTeX para equações, exemplo numérico.",
                                  "tips": "Numerar índices pares/ímpares para clareza.",
                                  "learningObjective": "Construir e validar o sistema não-linear completo.",
                                  "commonMistakes": "Índices errados no vetor; afirmar linearidade quando não é."
                                }
                              ],
                              "practicalExample": "Para y'' + y = 0, y(0)=0, y(π)=0 em [0,π], N=2, h=π/2. Unknowns: y0*, s0*, y1*, s1*. R1 = y0* - 0. Integre seg1: y1^- = y0* cos(h) + s0* sin(h), y1'^- = -y0* sin(h) + s0* cos(h). R2 = y1* - y1^-, R3 = s1* - y1'-. Integre seg2: y2^- = y1* cos(h) + s1* sin(h), etc. R4 = y2^- - 0.",
                              "finalVerifications": [
                                "O sistema tem exatamente 2N equações e 2N unknowns.",
                                "Todos resíduos de contorno (a e b) estão incluídos.",
                                "Há 2(N-1) resíduos de continuidade (y e y') em cada interface.",
                                "O vetor R é função não-linear dos parâmetros Φ devido às soluções de IVP.",
                                "Para N=1, reduz corretamente ao método de tiro simples.",
                                "Dimensão cresce linearmente com N para estabilidade numérica."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e contagem dos 2N unknowns (y_i^*, s_i^* i=0..N-1).",
                                "Definição precisa dos resíduos de contorno ψ_a e ψ_b.",
                                "Formulação exata dos resíduos de interface (matching y_k^* = y_k^-, s_k^* = y_k'^-).",
                                "Montagem coerente do vetor R completo com índices corretos.",
                                "Reconhecimento da não-linearidade e sugestão de método de solução.",
                                "Validação via exemplo simples (N=2)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações diferenciais em dinâmica de partículas e ondas.",
                                "Computação: Implementação de solvers numéricos em Python (SciPy) ou MATLAB.",
                                "Engenharia: Análise de estruturas com condições de contorno mistas.",
                                "Otimização: Sistemas não-lineares resolvidos por métodos quasi-Newton."
                              ],
                              "realWorldApplication": "Na engenharia aeroespacial para resolver perfis de velocidade em escoamentos viscosos (equações de Navier-Stokes discretizadas), em finanças para precificação de derivativos via PDEs de Black-Scholes com barreiras, e em biomedicina para modelar difusão de fármacos com condições de contorno em tecidos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Implementação Iterativa e Análise",
                        "description": "Algoritmo iterativo para resolução sequencial de IVPs nos subintervalos, ajuste via método de Newton e análise de vantagens em estabilidade e convergência para problemas stiff e não lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Implementar Resolução Sequencial de IVPs",
                            "description": "Dado um conjunto de parâmetros iniciais, integrar numericamente cada IVP subjacente usando métodos de passo simples ou múltiplo com controle de passo (ex.: Runge-Kutta adaptativo), propagando soluções através dos subintervalos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema e Configurar Subintervalos",
                                  "subSteps": [
                                    "Identifique as condições de contorno u(a) = α e u(b) = β, e a equação diferencial y'' = f(x, y, y').",
                                    "Divida o intervalo [a, b] em N subintervalos [x_i, x_{i+1}] com x_0 = a e x_N = b.",
                                    "Estabeleça condições iniciais para o primeiro IVP: y(x_0) = α, y'(x_0) = s_0 (parâmetro de tiro inicial).",
                                    "Defina tolerâncias para controle de erro e critérios de parada.",
                                    "Crie estruturas de dados para armazenar soluções em cada subintervalo (arrays para y, y' em pontos de grade)."
                                  ],
                                  "verification": "Verifique se os subintervalos cobrem [a,b] sem sobreposição e se as condições iniciais estão corretamente atribuídas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do problema PVB",
                                    "Biblioteca numérica (ex: SciPy odeint ou implementações customizadas em Python/MATLAB)"
                                  ],
                                  "tips": "Use malha uniforme inicialmente para simplicidade; refine adaptativamente depois.",
                                  "learningObjective": "Compreender a decomposição de PVB em IVPs sequenciais.",
                                  "commonMistakes": [
                                    "Subintervalos sobrepostos ou gaps",
                                    "Confundir condições de contorno com iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Solucionador Numérico para IVPs",
                                  "subSteps": [
                                    "Converta o problema de segunda ordem em sistema de primeira ordem: z = [y, y'], z' = [y', f(x,y,y')].",
                                    "Implemente método Runge-Kutta adaptativo (ex: RK45) com controle de passo baseado em erro local.",
                                    "Defina função residual para erro: |z_{n+1} - z_n| < tol.",
                                    "Teste o solver em um IVP simples conhecido para validar precisão.",
                                    "Inclua salvamento de solução em grade fina nos endpoints de cada subintervalo."
                                  ],
                                  "verification": "Execute teste unitário com solução analítica conhecida; erro < 1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base para RK adaptativo",
                                    "Ferramentas de debugging (ex: Jupyter Notebook)"
                                  ],
                                  "tips": "Use eventos para detectar endpoints exatos sem extrapolação.",
                                  "learningObjective": "Dominar integração numérica adaptativa para IVPs.",
                                  "commonMistakes": [
                                    "Não converter para primeira ordem corretamente",
                                    "Passos fixos sem adaptação levando a erros altos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver e Propagar Soluções Sequencialmente",
                                  "subSteps": [
                                    "Inicie com IVP no primeiro subintervalo [x0,x1]; integre para obter y(x1), y'(x1).",
                                    "Para cada subintervalo i=1 to N-1: use y(x_i), y'(x_i) como condições iniciais para IVP em [x_i, x_{i+1}].",
                                    "Integre numericamente e armazene soluções parciais; garanta continuidade automática nas interfaces.",
                                    "Monitore resíduos de continuidade: |y(x_i+) - y(x_i-)| e |y'(x_i+) - y'(x_i-)| devem ser ~0.",
                                    "Salve solução global interpolada para pós-processamento."
                                  ],
                                  "verification": "Plotar solução global; verificar continuidade visual e numérica nos nós x_i.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Solver implementado do Step 2",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Implemente loop while com i < N para robustez.",
                                  "learningObjective": "Executar propagação sequencial mantendo precisão acumulada.",
                                  "commonMistakes": [
                                    "Perder continuidade ao passar condições iniciais",
                                    "Acúmulo de erros numéricos sem controle"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Solução Global e Integrar com Iteração de Tiro",
                                  "subSteps": [
                                    "Compare y(x_N) com β; compute resíduo r = y(x_N) - β.",
                                    "Se |r| > tol, ajuste s_0 via método de Newton ou bissecção para próxima iteração de tiro.",
                                    "Reexecute propagação sequencial com novo s_0 até convergência.",
                                    "Avalie estabilidade: monitore ||Δs|| entre iterações.",
                                    "Gere relatório: solução final, histórico de resíduos, tempo de CPU."
                                  ],
                                  "verification": "Resíduo final |y(b) - β| < 1e-8 e convergência em <10 iterações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código completo dos steps anteriores",
                                    "Otimizador simples para s_0"
                                  ],
                                  "tips": "Use extrapolação linear para chute inicial de s_0.",
                                  "learningObjective": "Integrar resolução sequencial no framework iterativo de tiro múltiplo.",
                                  "commonMistakes": [
                                    "Não fechar loop de iteração",
                                    "Ignorar divergência por passos grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Testar Implementação Completa",
                                  "subSteps": [
                                    "Profile código para gargalos (ex: overhead de adaptação).",
                                    "Teste com diferentes N subintervalos; verifique convergência O(1/N^2).",
                                    "Adicione tratamento de singularidades ou oscilações.",
                                    "Compare com solucionadores black-box (ex: bvp4c no MATLAB).",
                                    "Documente código com comentários e exemplos de uso."
                                  ],
                                  "verification": "Testes automatizados passam; precisão relativa <1e-6 vs. referência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Profiler (ex: cProfile)",
                                    "Casos teste variados"
                                  ],
                                  "tips": "Vectorize onde possível para eficiência.",
                                  "learningObjective": "Refinar implementação para uso prático e robusto.",
                                  "commonMistakes": [
                                    "Sobrecarga computacional por N muito grande",
                                    "Falta de testes de borda"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o PVB -u'' + u = 0 em [0,1] com u(0)=0, u(1)=1 usando 2 subintervalos. Inicie com s_0=1, propague com RK45 (tol=1e-6), ajuste s_0 até u(1)≈1. Solução esperada: u(x)=sinh(x)/sinh(1).",
                              "finalVerifications": [
                                "Solução satisfaz condições de contorno dentro de tolerância.",
                                "Continuidade C1 nas interfaces dos subintervalos.",
                                "Erro global <1e-6 comparado a solução de referência.",
                                "Convergência da iteração de tiro em poucas iterações.",
                                "Tempo de execução razoável (<1s para N=10).",
                                "Ausência de NaNs ou overflows na propagação."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução numérica (ordem de convergência).",
                                "Eficiência computacional (número de passos RK e iterações).",
                                "Robustez a diferentes problemas (linear/não-linear).",
                                "Clareza e modularidade do código.",
                                "Correta manipulação de erros e exceções.",
                                "Documentação e comentários adequados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações diferenciais em mecânica ondulatória.",
                                "Computação: Algoritmos numéricos e programação científica.",
                                "Engenharia: Simulações em controle de sistemas e aerodinâmica.",
                                "Estatística: Propagação de incertezas em métodos Monte Carlo.",
                                "Análise: Teoria de estabilidade de métodos numéricos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolve PVBs para perfis de temperatura em foguetes, propagando condições térmicas sequencialmente ao longo de estágios de voo para otimizar isolamento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Aplicar Iteração de Newton para Convergência",
                            "description": "Linearizar o sistema de resíduos via matriz Jacobiana (sensibilidades obtidas por variações ou IVPs adicionais) e resolver iterativamente Δα = -J^{-1} F(α) até convergência, como em Golub & Ortega (1992).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Sistema de Resíduos F(α)",
                                  "subSteps": [
                                    "Identifique as condições de contorno e o problema de valor inicial (IVP) parametrizado por α.",
                                    "Defina a função F(α) como o vetor de resíduos das condições de contorno não satisfeitas.",
                                    "Implemente numericamente a solução do IVP para um dado α usando um solver como Runge-Kutta.",
                                    "Teste F(α) com um α inicial para verificar resíduos iniciais.",
                                    "Documente a dimensão de F e α (ex: n condições de contorno implicam n parâmetros)."
                                  ],
                                  "verification": "Execute o código e confirme que F(α_inicial) ≠ 0 com resíduos mensuráveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de programação (Python com SciPy.integrate.solve_ivp ou MATLAB ode45)",
                                    "Referência: Golub & Ortega (1992), Capítulo 10"
                                  ],
                                  "tips": "Comece com um problema 1D simples para depuração antes de sistemas multi-D.",
                                  "learningObjective": "Entender como mapear BVP para um sistema não-linear F(α) = 0.",
                                  "commonMistakes": [
                                    "Esquecer normalização das condições de contorno",
                                    "Erro na parametrização do IVP",
                                    "Não escalar resíduos adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a Matriz Jacobiana J(α)",
                                  "subSteps": [
                                    "Escolha método: diferenças finitas (variações) ou IVPs adicionais para sensibilidades.",
                                    "Para diferenças finitas: perturbe cada componente de α por ε pequeno e compute (F(α + ε e_i) - F(α))/ε.",
                                    "Para IVPs adicionais: resolva sistemas lineares variacionais acoplados ao IVP original.",
                                    "Monte J como matriz n x n e verifique simetria/esparsidade se aplicável.",
                                    "Valide J computando ||J δ - (F(α+δ) - F(α))|| pequeno para δ aleatório."
                                  ],
                                  "verification": "Teste de consistência: norma do erro de linearização < 1e-6.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código base do Step 1",
                                    "Notebook Jupyter para visualização de J",
                                    "Livro: Ascher et al. Numerical Solution of BVP (1996)"
                                  ],
                                  "tips": "Use ε = 1e-8 para diferenças finitas; evite underflow com sqrt(eps).",
                                  "learningObjective": "Dominar computação numérica de sensibilidades para linearização.",
                                  "commonMistakes": [
                                    "ε muito grande/pequeno causando cancelamento numérico",
                                    "Índices errados em matrizes",
                                    "Não reutilizar solução IVP base"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Resolução do Sistema Linear Δα = -J^{-1} F(α)",
                                  "subSteps": [
                                    "Escolha solver linear: fatoração LU, GMRES para esparso, ou SciPy.linalg.solve.",
                                    "Compute rhs = -F(α) e resolva J Δα = rhs para Δα.",
                                    "Atualize α_new = α + Δα (ou com damping se necessário).",
                                    "Registre ||Δα|| e ||F(α_new)|| para monitoramento.",
                                    "Implemente pré-condicionador simples se J for mal-condicionada."
                                  ],
                                  "verification": "Para iteração única, confirme redução quadrática inicial em ||F||.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Bibliotecas lineares: SciPy.linalg ou MATLAB backslash",
                                    "Exemplo de código para solver esparso"
                                  ],
                                  "tips": "Monitore cond(J); se >1e12, considere regularização.",
                                  "learningObjective": "Aplicar solvers lineares eficientes em contexto não-linear.",
                                  "commonMistakes": [
                                    "Inverter J explicitamente (lento/numéricamente instável)",
                                    "Sinais errados em rhs",
                                    "Ignorar singularidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Loop de Iteração e Critério de Convergência",
                                  "subSteps": [
                                    "Defina tolerâncias: tol_res = 1e-10 para ||F||, tol_step = 1e-12 para ||Δα||.",
                                    "Implemente loop while ||F|| > tol_res and it < max_it (ex: 20).",
                                    "Atualize α, recompute F e J a cada iteração.",
                                    "Adicione line search ou damping se ||F(α_new)|| > ||F(α)||.",
                                    "Registre histórico de resíduos para plotar convergência."
                                  ],
                                  "verification": "Execute loop; confirme convergência em <10 iterações para problema teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código integrado dos steps anteriores",
                                    "Matplotlib para plots de convergência"
                                  ],
                                  "tips": "Plote log||F|| vs it; busque redução quadrática (declive -2).",
                                  "learningObjective": "Gerenciar iterações não-lineares com safeguards.",
                                  "commonMistakes": [
                                    "Critério muito frouxo levando a soluções imprecisas",
                                    "Loop infinito sem max_it",
                                    "Não detectar divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar a Solução Final",
                                  "subSteps": [
                                    "Verifique condições de contorno residuais ||F(α*)|| < tol.",
                                    "Integre IVP final e plote solução vs condições analíticas se disponíveis.",
                                    "Compute métricas: número de iterações, tempo total, cond(J_final).",
                                    "Teste sensibilidade a α_inicial variando-o.",
                                    "Documente relatório com plots e tabela de histórico."
                                  ],
                                  "verification": "Resíduos <1e-10 e solução satisfaz BVP dentro de tolerância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Referências teóricas para erro a posteriori"
                                  ],
                                  "tips": "Use múltiplos α_iniciais para basin of attraction.",
                                  "learningObjective": "Avaliar robustez e precisão do método de Newton.",
                                  "commonMistakes": [
                                    "Aceitar solução sem validação independente",
                                    "Ignorar oscilações em histórico"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP y'' + y = 0, y(0)=0, y'(1)=α com método de tiro simples (α como parâmetro). Defina F(α)=y(1;α)-0. Use Newton para encontrar α tal que y(1)=0. Solução analítica: α ≈ 1.175. Implemente em Python e confirme convergência em 4 iterações.",
                              "finalVerifications": [
                                "||F(α*)|| < 1e-12",
                                "Solução IVP satisfaz todas condições de contorno dentro de 1e-10",
                                "Convergência quadrática observada no histórico de resíduos",
                                "Múltiplos α_iniciais convergem para mesmo α*",
                                "Jacobiana final bem-condicionada (cond(J)<1e8)",
                                "Tempo de computação <1s para problema teste"
                              ],
                              "assessmentCriteria": [
                                "Correta formulação de F(α) e J(α) com precisão numérica",
                                "Implementação eficiente do loop Newton com convergência garantida",
                                "Tratamento de casos patológicos (divergência, damping)",
                                "Análise quantitativa de taxa de convergência",
                                "Código limpo, modular e documentado",
                                "Validação cruzada com soluções conhecidas"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Otimização numérica e solvers lineares (SciPy/NumPy)",
                                "Física: Modelagem de BVPs em mecânica/ondas (e.g., cordas vibrantes)",
                                "Engenharia: Simulações CFD/aerodinâmica com tiro múltiplo",
                                "Estatística: Sensibilidades em inferência bayesiana",
                                "Ciência de Dados: Otimizadores não-lineares em ML"
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, usado no método de tiro múltiplo para otimizar trajetórias de foguetes ou perfis aerodinâmicos, resolvendo BVPs não-lineares para equações de Navier-Stokes discretizadas, permitindo convergência rápida para designs iterativos em software como ANSYS ou SU2."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Analisar Estabilidade e Convergência",
                            "description": "Comparar com tiro simples, destacando melhorias em estabilidade para problemas stiff, redução de erros de propagação e convergência mais robusta em não lineares (Burden & Faires, 1997).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estabilidade e Convergência",
                                  "subSteps": [
                                    "Defina estabilidade em métodos numéricos para problemas de valor de contorno (BVPs), focando em estabilidade A e B.",
                                    "Explique convergência, incluindo condições de Lipschitz e teoremas relevantes (Burden & Faires, Seção 8.2).",
                                    "Discuta erros de propagação em soluções de EDOs e sua amplificação em problemas stiff.",
                                    "Identifique métricas chave: norma do erro global, ordem de convergência e raio espectral.",
                                    "Resuma diferenças entre estabilidade local e global."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras definindo e relacionando os conceitos, com exemplos matemáticos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Burden & Faires (1997), Capítulos 8 e 9",
                                    "Notas de aula sobre métodos de tiro",
                                    "Software MATLAB ou Python (SciPy) para visualizações"
                                  ],
                                  "tips": [
                                    "Use diagramas de fase para visualizar estabilidade.",
                                    "Compare com métodos explícitos vs implícitos.",
                                    "Anote fórmulas chave em um quadro de referência."
                                  ],
                                  "learningObjective": "Dominar definições teóricas de estabilidade e convergência aplicadas a BVPs.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência.",
                                    "Ignorar o impacto de problemas stiff na propagação de erros.",
                                    "Não diferenciar estabilidade A (zero-stability) de B (stability)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade e Convergência no Método de Tiro Simples",
                                  "subSteps": [
                                    "Implemente o método de tiro simples para um BVP modelo: y'' + p(x)y' + q(x)y = g(x).",
                                    "Calcule o Jacobiano e analise o raio espectral da matriz de propagação.",
                                    "Teste numericamente em um problema stiff (ex: y'' = -1000 y', y(0)=1, y(1)=2).",
                                    "Meça erros de propagação ao variar o passo h e plote curvas de erro.",
                                    "Avalie taxa de convergência via log-log plot."
                                  ],
                                  "verification": "Gere plots de erro mostrando divergência em problemas stiff; explique resultados em relatório curto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código MATLAB/Python para tiro simples",
                                    "Burden & Faires, Exemplo 8.4",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": [
                                    "Comece com h pequeno para evitar overflow.",
                                    "Use solvers adaptativos como ode45 inicialmente.",
                                    "Registre eigenvalues para análise espectral."
                                  ],
                                  "learningObjective": "Identificar limitações do tiro simples em estabilidade e convergência.",
                                  "commonMistakes": [
                                    "Escolha inadequada de condições iniciais de adivinhação.",
                                    "Não normalizar erros adequadamente.",
                                    "Ignorar sensibilidade a perturbações iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade e Convergência no Método de Tiro Múltiplo",
                                  "subSteps": [
                                    "Divida o intervalo [a,b] em N subintervalos e formule condições de continuidade nos nós.",
                                    "Derive o sistema não-linear para iteração de Newton-Raphson no vetor de condições iniciais.",
                                    "Analise estabilidade local em cada subintervalo, reduzindo propagação de erros.",
                                    "Implemente e teste em problema stiff, comparando matrizes Jacobianas.",
                                    "Verifique convergência quadrática e robustez em não-lineares."
                                  ],
                                  "verification": "Execute simulação com N=4 e confirme redução de erros em tabela comparativa.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código fonte para tiro múltiplo (adaptar de repositórios GitHub)",
                                    "Burden & Faires, Seção 9.3",
                                    "Solver não-linear fsolve (MATLAB) ou scipy.optimize"
                                  ],
                                  "tips": [
                                    "Escolha N baseado em comprimento de onda da solução.",
                                    "Monitore resíduo da iteração Newton.",
                                    "Use pré-condicionadores para Jacobiano grande."
                                  ],
                                  "learningObjective": "Compreender como o tiro múltiplo melhora estabilidade via decomposição do domínio.",
                                  "commonMistakes": [
                                    "Pontos de divisão mal escolhidos levando a ill-conditioning.",
                                    "Não verificar ortogonalidade das condições de contorno.",
                                    "Subestimar custo computacional para N grande."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Métodos e Sintetizar Melhorias",
                                  "subSteps": [
                                    "Compare erros globais, tempo de CPU e ordens de convergência entre tiro simples e múltiplo.",
                                    "Analise cenários: stiff vs não-stiff, lineares vs não-lineares.",
                                    "Discuta teoremas de convergência (ex: Dahlquist para multi-step).",
                                    "Crie tabela resumindo melhorias: estabilidade para stiff, redução de propagação, robustez.",
                                    "Proponha critérios para escolher método baseado no problema."
                                  ],
                                  "verification": "Produza relatório com tabelas, plots e conclusões validadas por referências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Resultados numéricos dos steps anteriores",
                                    "Burden & Faires (1997), p. 456-460",
                                    "LaTeX ou Markdown para relatório"
                                  ],
                                  "tips": [
                                    "Use métricas normalizadas (erro relativo máximo).",
                                    "Teste sensibilidade a ruído numérico.",
                                    "Referencie equações específicas."
                                  ],
                                  "learningObjective": "Sintetizar vantagens do tiro múltiplo sobre o simples.",
                                  "commonMistakes": [
                                    "Comparações enviesadas por implementações inconsistentes.",
                                    "Ignorar overhead computacional do múltiplo.",
                                    "Generalizações sem testes múltiplos."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP stiff y'' + 1000 y' + y = 0, y(0)=1, y(1)=0. Implemente tiro simples (divergente para h>0.01) vs tiro múltiplo com N=10 (convergente, erro <1e-6). Plote soluções e erros de propagação.",
                              "finalVerifications": [
                                "Explique matematicamente por que o tiro múltiplo reduz erros de propagação em stiff problems.",
                                "Implemente e rode código comparativo produzindo plots de convergência.",
                                "Identifique eigenvalues instáveis no tiro simples e como são mitigados no múltiplo.",
                                "Resuma teoremas de Burden & Faires aplicáveis à análise.",
                                "Proponha um BVP real onde tiro múltiplo é essencial.",
                                "Compare tempos de execução e precisão em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão teórica nas definições e derivações (30%)",
                                "Corretude da implementação numérica e plots (25%)",
                                "Profundidade da comparação quantitativa (20%)",
                                "Clareza no relatório e uso de referências (15%)",
                                "Identificação correta de melhorias para stiff/não-lineares (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Modelagem de ondas amortecidas em problemas stiff.",
                                "Engenharia: Simulações de estruturas (elástica, fluidos) com BVPs.",
                                "Ciência da Computação: Otimização não-linear e análise de estabilidade algorítmica.",
                                "Estatística: Análise de erros e validação numérica em dados simulados."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, o método de tiro múltiplo é usado para resolver BVPs stiff em simulações de fluxo viscoso (equações de Navier-Stokes discretizadas), garantindo estabilidade em domínios longos e evitando divergências numéricas em projetos de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Escolher Número de Subintervalos",
                            "description": "Determinar N ótimo equilibrando precisão, custo computacional e estabilidade, considerando controle de erro global e testes de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fatores que Influenciam a Escolha de N",
                                  "subSteps": [
                                    "Revise a teoria do Método de Tiro Múltiplo e como N afeta a discretização do intervalo.",
                                    "Identifique métricas chave: precisão (erro de aproximação), custo computacional (tempo de execução e memória) e estabilidade (sensibilidade a perturbações iniciais).",
                                    "Estude fórmulas aproximadas para erro global, como O(1/N^2) para métodos de segunda ordem.",
                                    "Analise gráficos de convergência teóricos para diferentes N.",
                                    "Documente trade-offs qualitativos em uma tabela."
                                  ],
                                  "verification": "Tabela completa de fatores com exemplos numéricos e referências à literatura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notebook Jupyter com código base do Método de Tiro Múltiplo.",
                                  "tips": "Comece com N pequenos (ex: 10, 20) para visualizar impactos rápidos.",
                                  "learningObjective": "Identificar e quantificar os trade-offs entre precisão, custo e estabilidade para diferentes valores de N.",
                                  "commonMistakes": "Ignorar estabilidade, focando apenas em precisão; confundir erro local com global."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Controle de Erro Global",
                                  "subSteps": [
                                    "Defina uma norma para erro global, como máximo ou L2 no intervalo.",
                                    "Integre solução exata conhecida (se disponível) ou referência de alta precisão no código.",
                                    "Modifique o código iterativo para computar erro global após convergência em cada subintervalo.",
                                    "Crie função para estimar erro a posteriori usando diferenças finitas ou extrapolação Richardson.",
                                    "Teste com N fixo e valide contra solução analítica."
                                  ],
                                  "verification": "Função de erro global implementada e testada com output numérico preciso (erro < 1e-6).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com SciPy/ODE solvers, código base do Método de Tiro Múltiplo.",
                                  "tips": "Use soluções exatas padrão como y'' + y = 0 para validação inicial.",
                                  "learningObjective": "Desenvolver e implementar métricas robustas para medir erro global no método.",
                                  "commonMistakes": "Usar erro local em vez de global; não normalizar o erro adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Testes de Convergência para Diferentes N",
                                  "subSteps": [
                                    "Selecione faixa de N: 10, 20, 50, 100, 200.",
                                    "Execute simulações para cada N, registrando tempo de CPU, erro global e iterações totais.",
                                    "Gere log-log plots de erro vs N e tempo vs N.",
                                    "Calcule ordem de convergência via log-log slope.",
                                    "Identifique platô de precisão ou instabilidade para N grandes."
                                  ],
                                  "verification": "Gráficos de convergência gerados com tabelas de dados resumidos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Notebook Jupyter, bibliotecas NumPy/Matplotlib, máquina com timer de performance.",
                                  "tips": "Paralelize execuções se possível para agilizar testes.",
                                  "learningObjective": "Realizar experimentos empíricos para observar comportamento de convergência.",
                                  "commonMistakes": "Escolher faixa de N muito estreita; ignorar overhead de iterações no custo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Equilibrar Trade-offs e Selecionar N Ótimo",
                                  "subSteps": [
                                    "Defina critérios: erro < 1e-5, tempo < 10s, estabilidade (variação < 5% em runs repetidos).",
                                    "Crie função de custo composta: custo = erro * tempo * fator_estabilidade.",
                                    "Otimize N minimizando custo via busca linear ou plot.",
                                    "Compare com heurísticas como N ~ 1/sqrt(epsilon_desejado).",
                                    "Documente escolha final com justificativa quantitativa."
                                  ],
                                  "verification": "Relatório com N ótimo selecionado, gráficos de custo e justificativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Dados dos testes anteriores, Excel ou Pandas para análise.",
                                  "tips": "Pondere fatores baseado no contexto (ex: mais peso em tempo para apps reais).",
                                  "learningObjective": "Aplicar otimização multiobjetivo para seleção prática de N.",
                                  "commonMistakes": "Escolher N pelo menor erro absoluto sem considerar custo; não testar estabilidade."
                                }
                              ],
                              "practicalExample": "Para o BVP y'' - y = 0 com y(0)=1, y(1)=2, teste N=10,50,100. Erro cai de 1e-3 para 1e-6, mas tempo sobe de 0.1s para 5s. N ótimo=50 (erro=1e-5, tempo=1s).",
                              "finalVerifications": [
                                "Erro global abaixo de threshold desejado (ex: 1e-5).",
                                "Tempo de execução dentro de limite prático (ex: <10s).",
                                "Ordem de convergência observada próxima da teórica (ex: ~2).",
                                "Estabilidade confirmada em 3 runs com sementes diferentes.",
                                "Gráficos de convergência mostram platô adequado.",
                                "Função de custo minimizada explicitamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de métricas de erro (90%+ acurácia).",
                                "Qualidade dos testes de convergência (faixa ampla de N, plots claros).",
                                "Justificativa quantitativa para N ótimo (trade-offs balanceados).",
                                "Código modular e comentado.",
                                "Análise de erros comuns evitados.",
                                "Relatório completo com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Otimização numérica e profiling de performance.",
                                "Física: Modelagem de BVPs em mecânica/ondas.",
                                "Estatística: Análise de convergência e testes de hipótese.",
                                "Engenharia de Software: Trade-offs em design de algoritmos."
                              ],
                              "realWorldApplication": "Em simulações CFD ou finanças, escolher N ótimo reduz tempo de computação em clusters, permitindo análises em tempo real sem sacrificar precisão em problemas de contorno como perfis de temperatura em reatores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Métodos de Diferenças Finitas para BVP",
                    "description": "Discretização da equação diferencial em uma grade uniforme e resolução de sistemas lineares ou não lineares resultantes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Discretização em Grade Uniforme",
                        "description": "Processo de divisão do intervalo de definição do problema de valor de contorno em uma grade uniforme para aproximar a equação diferencial por diferenças finitas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir uma grade uniforme",
                            "description": "Explicar como dividir o intervalo [a, b] em N subintervalos iguais com passo h = (b - a)/N, identificando os pontos nodais x_i = a + i*h para i = 0 a N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Grade Uniforme",
                                  "subSteps": [
                                    "Identifique o intervalo [a, b] como o domínio do problema.",
                                    "Defina N como o número de subintervalos desejados.",
                                    "Explique que uma grade uniforme divide o intervalo em partes iguais.",
                                    "Descreva o passo h como a largura de cada subintervalo.",
                                    "Liste os pontos nodais iniciais e finais: x_0 = a e x_N = b."
                                  ],
                                  "verification": "Escreva uma definição clara dos termos e desenhe um diagrama simples do intervalo dividido.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, caneta, calculadora",
                                  "tips": "Use um exemplo visual simples como uma régua para ilustrar a divisão uniforme.",
                                  "learningObjective": "Entender os componentes básicos de uma grade uniforme em análise numérica.",
                                  "commonMistakes": "Confundir N (subintervalos) com o número total de pontos (N+1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Tamanho do Passo h",
                                  "subSteps": [
                                    "Subtraia a do b para obter o comprimento total L = b - a.",
                                    "Divida L por N para calcular h = (b - a)/N.",
                                    "Verifique se h é um número positivo e consistente com o intervalo.",
                                    "Arredonde h se necessário, mas priorize precisão numérica.",
                                    "Registre o valor exato de h em fração ou decimal."
                                  ],
                                  "verification": "Confirme que h * N = b - a exatamente, com tolerância numérica mínima.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Calculadora ou software como Python/MATLAB",
                                  "tips": "Mantenha h como fração exata para evitar erros de arredondamento precoce.",
                                  "learningObjective": "Dominar o cálculo preciso do passo de discretização.",
                                  "commonMistakes": "Esquecer de subtrair a de b ou dividir por N incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar os Pontos Nodais x_i",
                                  "subSteps": [
                                    "Inicie com x_0 = a.",
                                    "Para cada i de 1 a N, calcule x_i = x_{i-1} + h ou diretamente x_i = a + i * h.",
                                    "Liste todos os pontos: x_i = a + i * h para i = 0, 1, ..., N.",
                                    "Confirme que x_N = b.",
                                    "Anote a sequência completa dos pontos."
                                  ],
                                  "verification": "Verifique se o último ponto x_N equals b e todos os intervalos são iguais a h.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, planilha Excel ou código simples em Python",
                                  "tips": "Use uma fórmula iterativa para automatizar em ferramentas computacionais.",
                                  "learningObjective": "Construir a sequência de pontos nodais de forma sistemática.",
                                  "commonMistakes": "Erro de off-by-one no índice i, parando em i = N-1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Validar a Grade Uniforme",
                                  "subSteps": [
                                    "Desenhe o eixo x de a a b e marque os pontos x_i.",
                                    "Meça distâncias entre pontos consecutivos para confirmar uniformidade.",
                                    "Calcule o número total de pontos (deve ser N+1).",
                                    "Teste com um N diferente para praticar.",
                                    "Discuta limitações, como precisão para N pequeno."
                                  ],
                                  "verification": "Crie um gráfico ou tabela mostrando pontos equidistantes e valide distâncias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico em papel, GeoGebra ou Matplotlib em Python",
                                  "tips": "Aumente N gradualmente para observar refinamento da grade.",
                                  "learningObjective": "Validar visual e numericamente a grade para aplicação em métodos numéricos.",
                                  "commonMistakes": "Ignorar erros de arredondamento em h que acumulam em x_i."
                                }
                              ],
                              "practicalExample": "Para o intervalo [0, 1] com N=4 subintervalos: h = (1-0)/4 = 0.25. Pontos nodais: x_0=0, x_1=0.25, x_2=0.5, x_3=0.75, x_4=1. Isso discretiza o domínio para resolver -u''(x)=f(x) com u(0)=u(1)=0 usando diferenças finitas.",
                              "finalVerifications": [
                                "h = (b - a)/N é calculado corretamente.",
                                "Todos os x_i são gerados com x_i = a + i*h para i=0 a N.",
                                "x_N = b exatamente.",
                                "Número de pontos é N+1.",
                                "Distâncias entre pontos consecutivos são iguais a h.",
                                "Grade é visualizada corretamente sem erros de escala."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de h (erro < 10^-10).",
                                "Correta geração de todos os N+1 pontos nodais.",
                                "Explicação clara da fórmula x_i = a + i*h.",
                                "Identificação de pelo menos dois erros comuns evitados.",
                                "Visualização ou tabela que demonstra uniformidade.",
                                "Aplicação correta em um exemplo numérico simples."
                              ],
                              "crossCurricularConnections": [
                                "Física: Discretização em simulações de equações diferenciais (e.g., onda ou calor).",
                                "Programação: Implementação de loops para gerar grades em Python ou MATLAB.",
                                "Engenharia: Modelagem de malhas em elementos finitos para estruturas.",
                                "Estatística: Divisão de dados em bins uniformes para histogramas."
                              ],
                              "realWorldApplication": "Em análise numérica para problemas de valor de contorno (BVP), como modelar difusão de calor em uma barra [a,b] ou fluxo em tubulações, onde a grade uniforme permite aproximar derivadas por diferenças finitas, essencial em engenharia, meteorologia e simulações CFD."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Aproximar derivadas por diferenças finitas",
                            "description": "Derivar as aproximações de primeira e segunda derivadas usando diferenças forward, backward e central, com erro de truncamento O(h^2) para esquemas centrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender diferenças forward e backward para primeira derivada",
                                  "subSteps": [
                                    "Revise a definição de derivada como limite de razão incremental.",
                                    "Derive a fórmula forward: f'(x) ≈ [f(x+h) - f(x)] / h.",
                                    "Derive a fórmula backward: f'(x) ≈ [f(x) - f(x-h)] / h.",
                                    "Calcule o erro de truncamento usando expansão de Taylor até O(h).",
                                    "Implemente em código simples para uma função teste como f(x) = x^2."
                                  ],
                                  "verification": "Derive corretamente as fórmulas e calcule erro para h=0.1 em f(x)=sin(x) com valor exato conhecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno ou software como Python/Jupyter",
                                    "Função teste: sin(x), exp(x)",
                                    "Expansão de Taylor básica"
                                  ],
                                  "tips": [
                                    "Use h pequeno para melhor aproximação, mas evite underflow numérico.",
                                    "Visualize graficamente os pontos usados."
                                  ],
                                  "learningObjective": "Derivar e aplicar diferenças forward/backward para primeira derivada com análise de erro O(h).",
                                  "commonMistakes": [
                                    "Confundir forward com backward.",
                                    "Esquecer o sinal no erro de truncamento.",
                                    "Usar h muito grande sem justificar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar diferença central para primeira derivada",
                                  "subSteps": [
                                    "Explique por que central é mais precisa: usa pontos simétricos.",
                                    "Derive f'(x) ≈ [f(x+h) - f(x-h)] / (2h) via Taylor.",
                                    "Mostre erro de truncamento O(h^2) cancelando termos ímpares.",
                                    "Compare numericamente com forward/backward para f(x)=cos(x).",
                                    "Discuta estabilidade e requisitos de grade uniforme."
                                  ],
                                  "verification": "Obtenha fórmula exata e erro O(h^2); teste numérico com erro < 10^-4 para h=0.01.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com numpy",
                                    "Gráficos de erro vs h (log-log)",
                                    "Tabela de Taylor para f(x+h) e f(x-h)"
                                  ],
                                  "tips": [
                                    "Central requer dois lados, verifique disponibilidade de pontos.",
                                    "Plote erro para confirmar ordem 2."
                                  ],
                                  "learningObjective": "Dominar diferença central de primeira derivada com precisão O(h^2).",
                                  "commonMistakes": [
                                    "Dividir por h em vez de 2h.",
                                    "Ignorar termo O(h^3) no erro.",
                                    "Aplicar em bordas sem ajuste."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximações para segunda derivada",
                                  "subSteps": [
                                    "Derive segunda derivada central: f''(x) ≈ [f(x+h) - 2f(x) + f(x-h)] / h^2.",
                                    "Use Taylor para provar erro O(h^2).",
                                    "Discuta forward/backward para segunda derivada (menos comuns).",
                                    "Implemente para f(x)=exp(x) e compare com derivada exata.",
                                    "Analise sensibilidade a ruído numérico."
                                  ],
                                  "verification": "Fórmula correta derivada; código roda com erro relativo < 1% para h=0.05.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python/MATLAB",
                                    "Funções suaves como exp(x), x^3",
                                    "Calculadora simbólica opcional (SymPy)"
                                  ],
                                  "tips": [
                                    "h^2 no denominador amplifica erros; use h otimizado.",
                                    "Teste com ruído para realismo."
                                  ],
                                  "learningObjective": "Derivar e implementar aproximações de segunda derivada com O(h^2).",
                                  "commonMistakes": [
                                    "Esquecer o -2f(x).",
                                    "Confundir com Laplace (similar mas normalizado).",
                                    "h incorreto na escala."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise comparativa e aplicação em grade uniforme",
                                  "subSteps": [
                                    "Compare precisão: forward O(h), central O(h^2) via tabela/erros.",
                                    "Aplique em grade uniforme para BVP: defina xi = x0 + i*h.",
                                    "Discuta truncamento vs arredondamento; escolha ótima h.",
                                    "Resolva exemplo: approx f'(1) para f(x)=sin(x) com h=0.1,0.01.",
                                    "Documente limitações em não-uniforme."
                                  ],
                                  "verification": "Tabela de erros mostra convergência O(h^2) para central; código reproduz.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python pandas para tabelas",
                                    "Gráficos de convergência",
                                    "Problema BVP simples"
                                  ],
                                  "tips": [
                                    "Log-log plot para ordem de convergência.",
                                    "h ~ sqrt(eps) para balancear erros."
                                  ],
                                  "learningObjective": "Comparar métodos e integrá-los em discretização de BVP.",
                                  "commonMistakes": [
                                    "Não logar erros para ver ordem.",
                                    "Ignorar efeitos de borda.",
                                    "Assumir O(h^2) sem derivar."
                                  ]
                                }
                              ],
                              "practicalExample": "Aproxime f'(π/4) e f''(π/4) para f(x) = sin(x) em grade h=0.1. Use forward, backward, central; compare com exatas cos(π/4)=√2/2 e -sin(π/4)=-√2/2. Código Python: def forward(f,x,h): return (f(x+h)-f(x))/h; etc. Erros: forward ~0.005, central ~10^-5.",
                              "finalVerifications": [
                                "Derivações corretas de todas fórmulas com Taylor até O(h^2).",
                                "Códigos implementados rodam sem erros para funções teste.",
                                "Tabelas de erro confirmam ordens: O(h) forward, O(h^2) central.",
                                "Aplicação em grade uniforme para 5 pontos gera aproximações consistentes.",
                                "Discussão de limitações (bordas, ruído) incluída.",
                                "Gráficos de convergência vs h plotados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivadas: fórmulas exatas e erros analisados corretamente (40%).",
                                "Implementação prática: código funcional e testes numéricos (30%).",
                                "Análise de erro: identificação de O(h) vs O(h^2) com provas (20%).",
                                "Clareza e completude: substeps seguidos, tips aplicados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Discretização em FDTD para equações de onda/ondas.",
                                "Engenharia: CFD para Navier-Stokes em malhas finitas.",
                                "Computação: Algoritmos numéricos em SciPy/NumPy.",
                                "Finanças: Modelos Black-Scholes via diferenças finitas."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como previsão de fluxo de calor (f'' em difusão) ou CFD para aerodinâmica, onde diferenças finitas aproximam derivadas em grades uniformes para resolver BVPs eficientemente em software como ANSYS ou OpenFOAM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Aplicar discretização à equação diferencial",
                            "description": "Transformar a equação diferencial y'' = f(x, y, y') em uma equação algébrica nas aproximações discretas nos pontos internos da grade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a grade uniforme no intervalo de interesse",
                                  "subSteps": [
                                    "Escolha o número de pontos internos N (ex: N=4 para simplicidade inicial).",
                                    "Calcule o passo h = (b - a) / (N + 1), onde [a, b] é o intervalo do BVP.",
                                    "Defina os pontos da grade: x_i = a + i * h para i = 0, 1, ..., N+1.",
                                    "Anote as condições de contorno: y_0 = α (em x_0 = a) e y_{N+1} = β (em x_{N+1} = b).",
                                    "Liste os pontos internos i = 1 a N onde a discretização será aplicada."
                                  ],
                                  "verification": "Verifique se h está correto somando (N+1)*h = b-a e se y_0, y_{N+1} atendem às condições de contorno.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis, calculadora para h.",
                                  "tips": "Comece com N pequeno (ex: 3) para cálculos manuais; aumente para precisão numérica posterior.",
                                  "learningObjective": "Compreender a discretização espacial uniforme para preparar aproximações diferenciais.",
                                  "commonMistakes": "Confundir número de intervalos (N+1) com pontos internos (N); errar x_i como i*h em vez de a + i*h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação de diferenças finitas centrais para y''(x_i)",
                                  "subSteps": [
                                    "Expanda y(x_i + h) e y(x_i - h) via série de Taylor até ordem h^2.",
                                    "Some as expansões: y(x_i + h) + y(x_i - h) = 2 y_i + h^2 y''_i + O(h^4).",
                                    "Subtraia 2 y_i e divida por h^2: [y_{i+1} - 2 y_i + y_{i-1}] / h^2 ≈ y''(x_i).",
                                    "Note o erro de truncamento O(h^2), confirmando consistência de segunda ordem.",
                                    "Escreva y_i ≈ y(x_i) para todos os termos."
                                  ],
                                  "verification": "A fórmula final deve ser [y_{i+1} - 2 y_i + y_{i-1}] / h^2 = y''_i + O(h^2); teste com função conhecida como y = x^2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para expansões de Taylor, tabela de derivadas.",
                                  "tips": "Lembre-se da simetria central para precisão; desenhe a grade para visualizar y_{i-1}, y_i, y_{i+1}.",
                                  "learningObjective": "Dominar a derivação da diferença finita central para segundas derivadas.",
                                  "commonMistakes": "Esquecer o fator 1/h^2; usar forward/backward em vez de central, reduzindo precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a aproximação de diferenças finitas centrais para y'(x_i)",
                                  "subSteps": [
                                    "Expanda y(x_i + h) = y_i + h y'_i + (h^2/2) y''_i + O(h^3).",
                                    "Expanda y(x_i - h) = y_i - h y'_i + (h^2/2) y''_i + O(h^3).",
                                    "Subtraia as expansões: [y(x_i + h) - y(x_i - h)] / (2h) ≈ y'(x_i).",
                                    "Confirme erro de truncamento O(h^2).",
                                    "Escreva [y_{i+1} - y_{i-1}] / (2h) ≈ y'(x_i)."
                                  ],
                                  "verification": "Teste com y = sin(x): a aproximação deve convergir para cos(x_i) ao refinar h.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, calculadora para testes numéricos simples.",
                                  "tips": "A diferença central cancela termos pares; ideal para equações com y' odd.",
                                  "learningObjective": "Aplicar diferenças finitas para primeiras derivadas em contexto de EDOs não-lineares.",
                                  "commonMistakes": "Dividir por h em vez de 2h; inverter y_{i+1} e y_{i-1} causando sinal errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Substituir as aproximações na equação diferencial para obter a forma algébrica",
                                  "subSteps": [
                                    "Substitua y''(x_i) ≈ [y_{i+1} - 2 y_i + y_{i-1}] / h^2 na EDO y'' = f(x, y, y').",
                                    "Substitua y'(x_i) ≈ [y_{i+1} - y_{i-1}] / (2h) em f(x_i, y_i, y'_i).",
                                    "Escreva a equação: [y_{i+1} - 2 y_i + y_{i-1}] / h^2 = f(x_i, y_i, [y_{i+1} - y_{i-1}] / (2h)).",
                                    "Multiplique ambos os lados por h^2 para limpar o denominador, obtendo equação algébrica em y_{i-1}, y_i, y_{i+1}.",
                                    "Confirme aplicação apenas para i = 1, ..., N (pontos internos)."
                                  ],
                                  "verification": "A equação final deve ser não-linear algébrica tridiagonal envolvendo exatamente y_{i-1}, y_i, y_{i+1}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, lápis para algebra; software como Python/MATLAB para validar.",
                                  "tips": "Mantenha notação consistente; isole termos para matriz futura.",
                                  "learningObjective": "Transformar EDO em sistema algébrico pronto para resolução numérica.",
                                  "commonMistakes": "Esquecer de substituir y' dentro de f; não multiplicar por h^2 deixando frações."
                                }
                              ],
                              "practicalExample": "Para y'' = y' - y em [0,1] com y(0)=0, y(1)=0, N=2, h=1/3. Para i=1 (x_1=1/3): [y_2 - 2 y_1 + y_0] / (1/9) = [y_2 - y_0]/(2/3) - y_1. Com y_0=0, y_3=0, simplifica para 9(y_2 - 2 y_1) = (3/2)(y_2 - y_0) - 9 y_1, formando sistema linear.",
                              "finalVerifications": [
                                "A equação discretizada é aplicada apenas em pontos internos i=1 a N.",
                                "Coeficientes de y_{i-1}, y_i, y_{i+1} refletem corretamente 1/h^2 e 1/(2h).",
                                "f(x_i, y_i, y'_i) é avaliada nas aproximações discretas exatas.",
                                "Erro de truncamento é O(h^2) para ambas as derivadas.",
                                "Condições de contorno y_0 e y_{N+1} não alteram a forma interna.",
                                "Equação é algébrica (não diferencial) em variáveis y_i."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das fórmulas de diferenças finitas (ordem correta).",
                                "Correta substituição e simplificação algébrica sem erros aritméticos.",
                                "Uso apropriado de notação de grade e índices.",
                                "Identificação de estrutura tridiagonal implícita.",
                                "Capacidade de aplicar a um exemplo concreto com valores numéricos.",
                                "Explicação do impacto de h na precisão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações de difusão ou onda via diferenças finitas.",
                                "Computação: Implementação em Python (NumPy/SciPy) para resolver o sistema resultante.",
                                "Engenharia: Simulações numéricas em estruturas (equilíbrios elásticos).",
                                "Estatística: Aproximações em processos estocásticos discretos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, discretizar EDOs de flexão de vigas para simulações FEM; em finanças, aproximar equações de Black-Scholes para precificação de opções via grids numéricos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Incorporação das Condições de Contorno",
                        "description": "Integração das condições de contorno de Dirichlet, Neumann ou mistas no sistema discreto gerado pela grade uniforme.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Tratar condições de Dirichlet",
                            "description": "Aplicar y(a) = α e y(b) = β diretamente nos pontos x_0 e x_N, eliminando as equações correspondentes e ajustando o vetor de incógnitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a grade numérica e identificar pontos de contorno",
                                  "subSteps": [
                                    "Defina o intervalo [a, b] e o número de pontos internos N-1.",
                                    "Calcule o passo h = (b - a)/N.",
                                    "Identifique x_0 = a e x_N = b como pontos de contorno Dirichlet.",
                                    "Liste os pontos internos x_1 a x_{N-1} como incógnitas.",
                                    "Anote as condições y(a) = α e y(b) = β."
                                  ],
                                  "verification": "Verifique se h está correto e x_0, x_N coincidem com a e b; liste os N+1 pontos.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Exemplo de BVP dado"
                                  ],
                                  "tips": "Escolha N par para simetria; desenhe a grade visualmente.",
                                  "learningObjective": "Entender a discretização do domínio para BVP.",
                                  "commonMistakes": [
                                    "Confundir N total com pontos internos",
                                    "Erro no cálculo de h",
                                    "Ignorar que x_0 e x_N são conhecidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar condições de Dirichlet diretamente nos pontos de contorno",
                                  "subSteps": [
                                    "Atribua y_0 = α diretamente (sem equação de diferença finita).",
                                    "Atribua y_N = β diretamente (sem equação de diferença finita).",
                                    "Confirme que y_0 e y_N não são incógnitas no sistema.",
                                    "Use essas valores em equações vizinhas (para x_1 e x_{N-1}).",
                                    "Documente y_0 e y_N em uma tabela de valores conhecidos."
                                  ],
                                  "verification": "y_0 == α e y_N == β na tabela; sem linhas para eles no sistema.",
                                  "estimatedTime": "15 min",
                                  "materials": [
                                    "Tabela de grade",
                                    "Condições do problema"
                                  ],
                                  "tips": "Pense em y_0 e y_N como 'fixos' na grade.",
                                  "learningObjective": "Incorporar condições essenciais sem resolver equações extras.",
                                  "commonMistakes": [
                                    "Tentar aplicar esquema de diferenças em x_0/x_N",
                                    "Esquecer de usar y_0 em eq. de x_1",
                                    "Trocar α e β"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Eliminar equações de contorno e ajustar o sistema linear",
                                  "subSteps": [
                                    "Escreva o sistema completo para i=0 a N (incluindo contornos fictícios).",
                                    "Remova as linhas i=0 e i=N do sistema Ax = b.",
                                    "Ajuste as equações de i=1 e i=N-1 incorporando y_0 e y_N nos termos b.",
                                    "Reduza a matriz A para (N-1) x (N-1), vetor x para y_1 a y_{N-1}.",
                                    "Verifique se o sistema tem dimensão correta (N-1 equações)."
                                  ],
                                  "verification": "Matriz A tem tamanho (N-1)x(N-1); b ajustado com α e β.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Matriz A inicial",
                                    "Software como MATLAB/Octave ou papel para N pequeno"
                                  ],
                                  "tips": "Para stencil padrão -y'' ≈ (y_{i-1} - 2y_i + y_{i+1})/h², substitua y_0=α em i=1.",
                                  "learningObjective": "Construir sistema reduzido tridiagonal simétrico.",
                                  "commonMistakes": [
                                    "Não remover linhas 1 e N",
                                    "Erro nos coeficientes de b para bordas",
                                    "Manter y_0/y_N como incógnitas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema e verificar consistência",
                                  "subSteps": [
                                    "Resolva Ax = b para x = [y_1, ..., y_{N-1}]^T.",
                                    "Preencha a solução completa: y_0=α, y_1 a y_{N-1}, y_N=β.",
                                    "Verifique resíduo: compute diferenças finitas e compare com f(x_i).",
                                    "Plote ou tabule y(x_i) vs solução exata se disponível.",
                                    "Confirme y(a)=α e y(b)=β na solução final."
                                  ],
                                  "verification": "Solução satisfaz condições de contorno; erro < 1% se exata disponível.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Solver linear (Python/NumPy, MATLAB)",
                                    "Gráfico de solução"
                                  ],
                                  "tips": "Use Thomas algorithm para tridiagonal; teste com N=10 primeiro.",
                                  "learningObjective": "Validar implementação de Dirichlet em diferenças finitas.",
                                  "commonMistakes": [
                                    "Erro de arredondamento em h pequeno",
                                    "Não verificar bordas pós-solução",
                                    "Resolver sistema full sem reduzir"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -y'' = 2 no [0,1] com y(0)=0, y(1)=0 usando N=4 (h=0.25). Grade: x=[0,0.25,0.5,0.75,1]. y0=0, y4=0. Sistema reduzido para y1,y2,y3: A = [[2,-1,0],[-1,2,-1],[0,-1,2]]/h², b=[1/h², 2/h² + y0/h², 2/h² + y4/h²]^T wait, adjust: actually b=[2/h² + y0/h², 2/h², 2/h² + y4/h²]. Solução: y=[0, 0.5*h², h², 0.5*h², 0] approx.",
                              "finalVerifications": [
                                "y_0 exatamente igual a α",
                                "y_N exatamente igual a β",
                                "Sistema linear tem dimensão (N-1) x (N-1)",
                                "Equações de borda incorporam corretamente α e β em b",
                                "Resíduo máximo |Lh y - f| < ε (ex: 1e-3)",
                                "Solução interpolada satisfaz condições nos extremos"
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e atribuição de y_0=α, y_N=β (20%)",
                                "Eliminação precisa das equações de contorno (25%)",
                                "Ajuste correto do vetor b nas equações adjacentes (25%)",
                                "Solução do sistema reduzido sem erros numéricos (20%)",
                                "Verificação de consistência e resíduos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações de Poisson em eletrostática (∇²φ=ρ)",
                                "Programação: Implementação em Python/NumPy para solvers numéricos",
                                "Engenharia: Simulação de perfis de temperatura em barras fixas",
                                "Estatística: Aproximação de processos estocásticos em limites"
                              ],
                              "realWorldApplication": "Em engenharia térmica, simular distribuição de temperatura em uma placa com temperaturas fixas nas bordas (condições Dirichlet), essencial para design de dissipadores de calor em eletrônicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Incorporar condições de Neumann",
                            "description": "Aproximar derivadas nas extremidades com diferenças forward ou backward, como y'(a) ≈ (y_1 - y_0)/h = α, e ajustar as equações de contorno no sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Condições de Neumann e Aproximações de Derivadas",
                                  "subSteps": [
                                    "Revise a definição de condição de Neumann: especifica a derivada da solução na fronteira, como y'(a) = α.",
                                    "Estude diferenças finitas forward para y'(a) ≈ (y_1 - y_0)/h e backward para y'(b) ≈ (y_n - y_{n-1})/h.",
                                    "Identifique o problema de valor de contorno (BVP) típico: -y'' = f(x) em [a,b] com condições de Neumann em uma ou ambas as extremidades.",
                                    "Discuta a perda de uma equação no sistema devido à condição de Neumann, resultando em n-1 equações para n pontos internos.",
                                    "Pratique com um exemplo simples: y'' = 0, y'(0)=1, y'(1)=2."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a condição de Neumann difere da Dirichlet e dê o stencil de diferença forward/backward.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de BVP)",
                                    "Folha de papel e calculadora",
                                    "Notas de aula sobre diferenças finitas"
                                  ],
                                  "tips": "Lembre-se: forward usa pontos à direita da fronteira; backward, à esquerda. Desenhe a grade para visualizar.",
                                  "learningObjective": "Compreender conceitualmente condições de Neumann e suas aproximações diferenciais finitas.",
                                  "commonMistakes": [
                                    "Confundir forward com backward",
                                    "Esquecer que Neumann envolve derivada, não valor da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Aproximação da Derivada na Fronteira",
                                  "subSteps": [
                                    "Para y'(a) = α, escreva y'(a) ≈ (y_1 - y_0)/h = α, onde y_0 é fantasma ou aproximado.",
                                    "Introduza y_0 = y_1 - α h da condição.",
                                    "Para a equação diferencial na fronteira, substitua: por exemplo, em -y''(a) ≈ -(y_{-1} - 2y_0 + y_1)/h², mas use stencil centrado em y_1.",
                                    "Calcule explicitamente para o ponto x_1: incorpore a condição para eliminar y_0.",
                                    "Repita para a fronteira direita com diferença backward."
                                  ],
                                  "verification": "Derive a equação modificada para o primeiro ponto interno e verifique se y_0 foi eliminado corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Software como MATLAB ou Python (opcional para plotar grade)",
                                    "Exemplo resolvido de BVP"
                                  ],
                                  "tips": "Use o desenvolvimento de Taylor para justificar a precisão O(h) da aproximação forward/backward.",
                                  "learningObjective": "Derivar com precisão as aproximações de derivadas de primeira ordem nas extremidades.",
                                  "commonMistakes": [
                                    "Usar diferença centrada na fronteira (inválida)",
                                    "Erro de sinal na eliminação do ponto fantasma"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o Sistema de Equações Lineares",
                                  "subSteps": [
                                    "Monte o sistema padrão para pontos internos: A y = b, onde A é tridiagonal.",
                                    "Modifique a primeira linha de A e b incorporando a condição de Neumann esquerda: por exemplo, a_{11} = 2, a_{12}=1, b_1 ajustado com α.",
                                    "Ajuste similarmente a última linha para Neumann direita.",
                                    "Verifique a dimensionalidade: para n+1 pontos (0 a n), sistema de tamanho (n-1) x (n-1) se ambas Neumann.",
                                    "Escreva o sistema matricial completo para um exemplo com h=0.1."
                                  ],
                                  "verification": "Escreva a matriz A e vetor b para um BVP simples e confirme que é simétrico e dominante diagonalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz em papel ou Excel",
                                    "Python/NumPy para montar A (opcional)",
                                    "Template de stencil de diferenças finitas"
                                  ],
                                  "tips": "Para Neumann em ambas extremidades, adicione uma condição de compatibilidade ∫f dx = α - β para solubilidade.",
                                  "learningObjective": "Incorporar corretamente condições de Neumann no sistema linear de diferenças finitas.",
                                  "commonMistakes": [
                                    "Manter n equações em vez de n-1",
                                    "Erros nos coeficientes da tridiagonal modificada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o Sistema e Validar a Solução",
                                  "subSteps": [
                                    "Resolva o sistema A y = b usando eliminação de Gauss ou método iterativo (ex: Thomas algorithm para tridiagonal).",
                                    "Calcule y_0 e y_n usando as condições de Neumann para completar a solução.",
                                    "Compare com solução exata ou analítica para verificar precisão.",
                                    "Analise o erro de truncamento O(h²) interno vs O(h) na fronteira.",
                                    "Teste com refinamento de malha (reduzir h) para observar convergência."
                                  ],
                                  "verification": "A solução satisfaz as condições de Neumann com tolerância <1e-3 e erro global < O(h).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial ou Python (SciPy solve)",
                                    "Gráfico de solução exata vs numérica"
                                  ],
                                  "tips": "Implemente em código para automação; plote y' nas bordas para visualização.",
                                  "learningObjective": "Resolver numericamente BVPs com Neumann e validar resultados.",
                                  "commonMistakes": [
                                    "Ignorar singularidade se condições incompatíveis",
                                    "Não extrapolar y_0/y_n"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -y'' + y = 0 em [0,1] com y'(0)=1, y'(1)=0. Solução exata: y(x) = sinh(1-x)/cosh(1). Use n=10 (h=0.1). Aproxime y'(0)≈(y1-y0)/0.1=1 → y0=y1-0.1. Modifique primeira equação em x1: (2y1 - y2)/h² + y1 = 0 + (y0)/h² → ajusta para incluir o termo de Neumann. Resolva sistema 9x9 e compare.",
                              "finalVerifications": [
                                "A matriz A é tridiagonal modificada corretamente nas bordas.",
                                "As condições y'(a)≈α e y'(b)≈β são satisfeitas numericamente.",
                                "O sistema é solucionável (determinante não zero, condições compatíveis).",
                                "Erro de solução < 1% comparado à exata com h=0.1.",
                                "Refinamento de malha mostra convergência O(h).",
                                "Solução é suave e física (sem oscilações anômalas)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da aproximação forward/backward (100% precisão).",
                                "Montagem precisa do sistema linear (verificação matricial).",
                                "Solução numérica acurada e validação com exata (erro <5%).",
                                "Explicação clara de ajustes nas equações de contorno.",
                                "Identificação de erros comuns e compatibilidade de condições.",
                                "Uso eficiente de tempo e recursos computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Condições de fluxo de calor/neutros em equações de difusão.",
                                "Engenharia: Modelagem de tensões em vigas com cargas known nas extremidades.",
                                "Computação: Implementação em bibliotecas numéricas como FEniCS ou SciPy.",
                                "Estatística: Aproximações em processos estocásticos de fronteira."
                              ],
                              "realWorldApplication": "Em simulações de transferência de calor, condições de Neumann representam fluxo de calor conhecido nas paredes (isoladas ou com convecção), usado em design de reatores nucleares, climatização de edifícios e previsão meteorológica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Lidar com condições mistas",
                            "description": "Combinar condições de Dirichlet em uma extremidade e Neumann na outra, garantindo a consistência do sistema discreto resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Condições de Contorno Dirichlet e Neumann",
                                  "subSteps": [
                                    "Defina formalmente a condição de Dirichlet: u(a) = α.",
                                    "Defina formalmente a condição de Neumann: u'(b) = β, usando aproximação de diferenças finitas centrais ou forward/backward.",
                                    "Explique a diferença entre condições de valor fixo e fluxo/derivada.",
                                    "Discuta implicações para problemas de BVP elípticos como -u'' = f.",
                                    "Resolva um exemplo simples analítico para cada tipo."
                                  ],
                                  "verification": "Escreva definições precisas e resolva um BVP analítico com cada condição separadamente, comparando soluções.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Caderno de anotações",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Use diagramas para visualizar as condições nas extremidades do intervalo.",
                                  "learningObjective": "Compreender as bases teóricas das condições mistas antes da discretização.",
                                  "commonMistakes": [
                                    "Confundir Dirichlet (valor) com Neumann (derivada)",
                                    "Ignorar a dimensionalidade do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar o Problema de Diferenças Finitas com Malha Uniforme",
                                  "subSteps": [
                                    "Divida o intervalo [a,b] em N pontos equidistantes com h = (b-a)/N.",
                                    "Aplique a diferença finita central para o operador Laplaciano: (u_{i+1} - 2u_i + u_{i-1})/h² ≈ u''(x_i).",
                                    "Formule a equação discreta para pontos internos: - (u_{i+1} - 2u_i + u_{i-1})/h² = f_i.",
                                    "Identifique os stencils nas extremidades para condições puras.",
                                    "Esboce a matriz tridiagonal A para o sistema Au = f."
                                  ],
                                  "verification": "Construa a matriz A e vetor f para um problema simples com condições homogêneas e verifique simetria.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy)",
                                    "Papel quadriculado para stencil",
                                    "Exemplos de código de diferenças finitas"
                                  ],
                                  "tips": "Sempre normalize por h² para manter consistência de ordem O(h²).",
                                  "learningObjective": "Dominar a discretização padrão antes de modificar para mistas.",
                                  "commonMistakes": [
                                    "Escolha errada de h levando a malhas instáveis",
                                    "Esquecimento do fator -1 no Laplaciano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Condições Mistas no Sistema Discreto",
                                  "subSteps": [
                                    "Para Dirichlet em x=0 (i=0): Fixe u_0 = α diretamente no sistema.",
                                    "Para Neumann em x=1 (i=N): Aproxime u'(1) ≈ (u_N - u_{N-1})/h = β, rearranjando para u_N = u_{N-1} + β h.",
                                    "Modifique o stencil no ponto i=1 (próximo a Dirichlet) e i=N-1 (próximo a Neumann).",
                                    "Incorpore as condições na matriz A, ajustando linhas de fronteira para eliminar ghost points.",
                                    "Verifique a consistência: ordem de precisão deve ser O(h) para Neumann forward, O(h²) com central se possível."
                                  ],
                                  "verification": "Monte o sistema Au = f para condições mistas e resolva numericamente, comparando com solução exata.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB template para BVP",
                                    "Solução analítica de um problema teste",
                                    "Gráficos para plotar erro"
                                  ],
                                  "tips": "Use eliminação de ghost points para Neumann para manter simetria da matriz.",
                                  "learningObjective": "Aplicar corretamente condições mistas preservando precisão e consistência.",
                                  "commonMistakes": [
                                    "Aproximação de baixa ordem em Neumann degradando precisão global",
                                    "Não ajustar o vetor f corretamente para condições não-homogêneas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver, Validar e Analisar Consistência do Sistema",
                                  "subSteps": [
                                    "Resolva o sistema tridiagonal usando Thomas algorithm ou solver genérico.",
                                    "Calcule erros de discretização e convergência com refinamento de malha (h halved).",
                                    "Analise estabilidade e condicionamento da matriz A.",
                                    "Teste com f variado e condições não-homogêneas.",
                                    "Documente o código e resultados em relatório curto."
                                  ],
                                  "verification": "Demonstre convergência O(h²) ou O(h) conforme esperado, com gráficos de erro vs. h.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Biblioteca SciPy para solve linear",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Sempre refine malha pelo menos 4 vezes para observar taxa de convergência.",
                                  "learningObjective": "Garantir que o sistema discreto seja consistente e confiável.",
                                  "commonMistakes": [
                                    "Resolver sistema sem verificar simetria/positivo-definido",
                                    "Ignorar perda de precisão em Neumann"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente -u'' + u = 0 em [0,1] com u(0)=0 (Dirichlet) e u'(1)=1 (Neumann). Solução exata: u(x) = sinh(x)/cosh(1). Discretize com N=10,20,40; plote solução e erro L2.",
                              "finalVerifications": [
                                "Construir corretamente matriz para condições mistas sem ghost points.",
                                "Obter convergência numérica consistente com ordem teórica.",
                                "Explicar impacto da condição Neumann na precisão global.",
                                "Implementar código funcional e reproduzível.",
                                "Identificar e corrigir erros comuns em stencil de fronteira.",
                                "Comparar solução numérica com analítica em pelo menos 3 malhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do stencil misto (90% correto).",
                                "Correta montagem e resolução do sistema (sem erros de indexação).",
                                "Demonstração de convergência via refinamento de malha.",
                                "Análise qualitativa de consistência e estabilidade.",
                                "Clareza no código e documentação.",
                                "Capacidade de generalizar para condições não-homogêneas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações de calor/difusão com isolamento (Neumann=0).",
                                "Computação: Implementação eficiente de solvers tridiagonais (algoritmos numéricos).",
                                "Engenharia: Simulações de fluxo em tubos com condições de contorno reais.",
                                "Estatística: Aproximações em processos estocásticos com fronteiras mistas."
                              ],
                              "realWorldApplication": "Em engenharia térmica, simular distribuição de temperatura em uma barra com extremidade fixa (Dirichlet) e isolada (Neumann=0), essencial para design de trocadores de calor e isolamento industrial."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Resolução de Sistemas Lineares e Não Lineares",
                        "description": "Geração e solução eficiente dos sistemas lineares tridiagonais para problemas lineares, e métodos iterativos para casos não lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Formar a matriz tridiagonal",
                            "description": "Construir a matriz A tridiagonal com subdiagonal, diagonal e superdiagonal derivadas do esquema de diferenças finitas para y'' + p(x)y' + q(x)y = g(x).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Discretizar o domínio do problema de valor de contorno",
                                  "subSteps": [
                                    "Defina o intervalo [a, b] e o número de pontos internos N (total de pontos M = N + 1).",
                                    "Calcule o passo h = (b - a)/N.",
                                    "Defina os pontos da grade x_i = a + i*h para i = 0 a N.",
                                    "Identifique os pontos internos i = 1 a N-1 onde aplicar a discretização.",
                                    "Anote as condições de contorno y(a) = α e y(b) = β."
                                  ],
                                  "verification": "Verifique se h está correto e x_i formam uma grade uniforme com M pontos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Escolha N par para facilitar simetrias; comece com N pequeno para testes.",
                                  "learningObjective": "Compreender a discretização uniforme do domínio para métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir N (intervalos) com M (pontos)",
                                    "Erro no cálculo de h, como usar N+1 no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as aproximações de diferenças finitas centradas",
                                  "subSteps": [
                                    "Para y''(x_i): use (y_{i-1} - 2y_i + y_{i+1})/h².",
                                    "Para y'(x_i): use (y_{i+1} - y_{i-1})/(2h).",
                                    "Para o termo q(x_i)y_i: simplesmente q(x_i) * y_i.",
                                    "Para p(x_i)y'(x_i): substitua a aproximação de y'.",
                                    "Escreva a aproximação completa para g(x_i).",
                                    "Confirme que todas as aproximações são de segunda ordem O(h²)."
                                  ],
                                  "verification": "Substitua em uma EDO simples como y''=0 e verifique consistência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de fórmulas de diferenças finitas"
                                  ],
                                  "tips": "Lembre-se: diferenças centradas para precisão; evite forward/backward nos internos.",
                                  "learningObjective": "Dominar as fórmulas padrão de diferenças finitas para derivadas até segunda ordem.",
                                  "commonMistakes": [
                                    "Usar diferença forward para y'' interna",
                                    "Esquecer o fator 1/h² em y''"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a equação discreta nos pontos internos",
                                  "subSteps": [
                                    "Substitua as aproximações na EDO: y'' + p y' + q y = g.",
                                    "Multiplique ambos os lados por h² para eliminar denominadores.",
                                    "Reescreva como: a_i y_{i-1} + b_i y_i + c_i y_{i+1} = d_i.",
                                    "Defina d_i = h² g(x_i) ajustado pelas condições de contorno se necessário.",
                                    "Verifique para i=1 e i=N-1 se condições de contorno afetam."
                                  ],
                                  "verification": "A equação deve envolver apenas y_{i-1}, y_i, y_{i+1} com coeficientes locais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de EDO resolvida analiticamente"
                                  ],
                                  "tips": "Multiplicar por h² primeiro simplifica; isole termos de y.",
                                  "learningObjective": "Transformar a EDO contínua em sistema linear tridiagonal discreto.",
                                  "commonMistakes": [
                                    "Não multiplicar por h², deixando frações",
                                    "Ignorar p(x) ou q(x) nas aproximações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair os coeficientes tridiagonais",
                                  "subSteps": [
                                    "Identifique subdiagonal a_i (coef. de y_{i-1}): tipicamente 1 - (h/2)p(x_i).",
                                    "Diagonal b_i (coef. de y_i): -2 + h² q(x_i).",
                                    "Superdiagonal c_i (coef. de y_{i+1}): 1 + (h/2)p(x_i).",
                                    "Ajuste para i=1 e i=N-1 incorporando condições de contorno em d_1 e d_{N-1}.",
                                    "Liste todos a_i, b_i, c_i para i=1 a N-1."
                                  ],
                                  "verification": "Some a_i + b_i + c_i ≈ 0 para casos sem q, verificando consistência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python para calcular numérico"
                                  ],
                                  "tips": "Use notação vetorial: a = [a1,...,a_{N-1}], etc.",
                                  "learningObjective": "Reconhecer a estrutura tridiagonal emergente dos coeficientes locais.",
                                  "commonMistakes": [
                                    "Inverter sinal em p para super/sub",
                                    "Esquecer h² em q"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir e validar a matriz tridiagonal A",
                                  "subSteps": [
                                    "Crie matriz A de tamanho (N-1) x (N-1) com subdiagonal a_i, diagonal b_i, superdiagonal c_i.",
                                    "Posicione: A_{i,i-1} = a_i, A_{i,i} = b_i, A_{i,i+1} = c_i.",
                                    "Escreva o vetor d de lado direito.",
                                    "Verifique simetria se p=0.",
                                    "Teste com N=3: matriz 2x2 deve ser correta manualmente."
                                  ],
                                  "verification": "Multiplique A por vetor y aproximado e compare com g discretizado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "MATLAB/Python para matriz"
                                  ],
                                  "tips": "Use diag(a[2:end],-1) + diag(b) + diag(c[:-1],1) em código.",
                                  "learningObjective": "Montar explicitamente a matriz A para resolução por Thomas.",
                                  "commonMistakes": [
                                    "Tamanho errado: deve ser (N-1)x(N-1)",
                                    "Índices off-by-one na sub/super"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y'' + y = 0 em [0,1], y(0)=y(1)=0, N=3, h=0.5. Aproximações levam a a1=a2=1, b1=b2=-2, c1=c2=1 + h²/2*0=1. Matriz A = [[-2,1],[1,-2]].",
                              "finalVerifications": [
                                "Matriz A tem dimensões (N-1) x (N-1) com apenas sub, diag e superdiagonal não-nulas.",
                                "Coeficientes a_i, b_i, c_i coincidem com fórmulas derivadas para cada i.",
                                "Para p=0 e q=0, A é simétrica e b_i = -2, a_i=c_i=1.",
                                "Sistema A y = d reproduz g(x_i) para solução conhecida.",
                                "Condições de contorno estão corretamente incorporadas em d_1 e d_{N-1}.",
                                "Ordem de precisão O(h²) confirmada por truncagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das diferenças finitas (ausência de erros em fórmulas).",
                                "Correção dos coeficientes tridiagonais a_i, b_i, c_i para casos gerais.",
                                "Montagem correta da matriz A sem elementos extras.",
                                "Tratamento adequado de condições de contorno em d.",
                                "Validação numérica com exemplo simples (erro <1%).",
                                "Clareza na documentação dos passos e fórmulas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações diferenciais em mecânica (vibrações, calor).",
                                "Programação: Implementação em Python/MATLAB para solver tridiagonal (algoritmo Thomas).",
                                "Engenharia: Simulações numéricas em estruturas e fluidos.",
                                "Estatística: Aproximações discretas em processos estocásticos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, formar matrizes tridiagonais para simular perfis de temperatura em painéis sob condução de calor, permitindo otimizações rápidas via solvers eficientes como Thomas algorithm."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Aplicar o algoritmo de Thomas",
                            "description": "Implementar a eliminação progressiva e retroativa (algoritmo TDMA) para resolver eficientemente o sistema tridiagonal Ax = b em O(N) operações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e representar o sistema tridiagonal",
                                  "subSteps": [
                                    "Identifique os coeficientes da matriz tridiagonal: subdiagonal (a_i), diagonal principal (b_i) e superdiagonal (c_i), além do vetor b.",
                                    "Escreva a matriz A no formato tridiagonal explícito para um sistema de tamanho N.",
                                    "Verifique se o sistema satisfaz as condições de estabilidade (diagonal dominante ou similar).",
                                    "Anote os arrays a[1..N], b[1..N], c[1..N-1], d[1..N] para facilitar a implementação.",
                                    "Crie um exemplo pequeno (N=3 ou 4) para testar manualmente."
                                  ],
                                  "verification": "Confirme que todos os coeficientes estão corretamente indexados e o sistema está diagonal dominante (sum |off-diag| < |diag| para cada linha).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora ou editor de código (Python/MATLAB).",
                                  "tips": "Use índices de 1 a N para consistência com a literatura numérica.",
                                  "learningObjective": "Representar precisamente um sistema tridiagonal Ax=b nos formatos vetoriais necessários para TDMA.",
                                  "commonMistakes": "Confundir índices (começar do 0 em vez de 1); ignorar verificação de diagonal dominância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a eliminação progressiva (forward sweep)",
                                  "subSteps": [
                                    "Inicialize arrays auxiliares: cp[1] = c1 / b1; dp[1] = d1 / b1.",
                                    "Para i=2 a N: cp[i] = c_i / (b_i - a_i * cp[i-1]).",
                                    "Atualize dp[i] = (d_i - a_i * dp[i-1]) / (b_i - a_i * cp[i-1]).",
                                    "Registre os valores de cp e dp após cada iteração para depuração.",
                                    "Verifique numericamente se não há divisões por zero ou overflow."
                                  ],
                                  "verification": "Todos os cp[i] e dp[i] foram computados sem erros numéricos e denominadores ≠0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, planilha Excel ou código Python com print de intermediários.",
                                  "tips": "Implemente em loop for para praticar; use double precision para evitar erros de arredondamento.",
                                  "learningObjective": "Transformar o sistema original em upper triangular via eliminação progressiva em O(N).",
                                  "commonMistakes": "Erro no denominador: esquecer de subtrair a_i * cp[i-1]; índices off-by-one."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a substituição retroativa (back substitution)",
                                  "subSteps": [
                                    "Inicialize x[N] = dp[N].",
                                    "Para i=N-1 downto 1: x[i] = dp[i] - cp[i] * x[i+1].",
                                    "Calcule cada x[i] sequencialmente da direita para a esquerda.",
                                    "Arredonde resultados se necessário e armazene em vetor x.",
                                    "Compare com solução conhecida se disponível."
                                  ],
                                  "verification": "A solução x satisfaz Ax ≈ b (resíduo ||Ax - b|| < 1e-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código ou calculadora para multiplicação matricial de verificação.",
                                  "tips": "Comece com N pequeno para validar manualmente antes de grandes N.",
                                  "learningObjective": "Recuperar a solução x do sistema upper triangular em O(N) operações.",
                                  "commonMistakes": "Inverter o loop (progressivo em vez de retroativo); esquecer o sinal negativo em x[i]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar o algoritmo completo",
                                  "subSteps": [
                                    "Escreva uma função TDMA(a, b, c, d) que retorne x.",
                                    "Teste com sistema conhecido: ex. N=3, a=[0,2,2], b=[4,4,4], c=[1,1], d=[6,10,10], x=[1,2,3].",
                                    "Meça tempo de execução para N=1000 vs Gauss naive.",
                                    "Analise complexidade: confirme O(N) operações.",
                                    "Gere gráfico de resíduo vs N para validar precisão."
                                  ],
                                  "verification": "Testes passam (erro <1e-12) e tempo O(N) escalável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (numpy para verificação), MATLAB ou Jupyter Notebook.",
                                  "tips": "Use %timeit no Python para medir performance.",
                                  "learningObjective": "Codificar TDMA funcional e eficiente para problemas reais.",
                                  "commonMistakes": "Não vetorizar código; falhar em testar com solução exata."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar estabilidade e aplicações",
                                  "subSteps": [
                                    "Teste casos não-diagonal-dominantes e observe instabilidade.",
                                    "Aplique a um BVP simples: -u'' + u = f, discritizado.",
                                    "Compare com solver genérico (numpy.linalg.solve).",
                                    "Documente condições de convergência.",
                                    "Explore pivoteamento parcial se necessário."
                                  ],
                                  "verification": "Relatório com análise de estabilidade e comparação de performance.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notebook com plots (matplotlib).",
                                  "tips": "Sempre normalize resíduo relativo para comparação justa.",
                                  "learningObjective": "Entender limitações e aplicações do TDMA em análise numérica.",
                                  "commonMistakes": "Assumir estabilidade universal; ignorar erros de propagação."
                                }
                              ],
                              "practicalExample": "Resolva o sistema tridiagonal para BVP -u''(x) = x em [0,1], u(0)=u(1)=0, com h=0.1 (N=9): a_i=1 (exceto bordas), b_i=2, c_i=1, d_i = -h^2 * (ih), usando TDMA para obter u aproximada.",
                              "finalVerifications": [
                                "Implementação resolve corretamente sistema teste com erro <1e-10.",
                                "Complexidade temporal confirmada O(N) via timing para N=10^3-10^5.",
                                "Resíduo ||Ax-b||/||b|| diminui com h, convergência O(h^2).",
                                "Código lida com N variável sem crashes.",
                                "Análise de estabilidade documentada para casos diagonal-dominantes.",
                                "Comparação com solver denso mostra speedup >100x para N grande."
                              ],
                              "assessmentCriteria": [
                                "Precisão: solução exata para testes unitários.",
                                "Eficiência: O(N) demonstrado empiricamente.",
                                "Robustez: Trata edge cases (N=2, diagonal dominante).",
                                "Clareza: Código comentado com fórmulas matemáticas.",
                                "Análise: Relatório de erros e estabilidade.",
                                "Aplicação: Integração em BVP de diferenças finitas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação eficiente de algoritmos numéricos (Python/NumPy).",
                                "Física: Solução de EDOs em mecânica quântica e difusão.",
                                "Engenharia: CFD (equações de Navier-Stokes discritas).",
                                "Computação Científica: Otimização de solvers lineares."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), TDMA resolve sistemas tridiagonais oriundos de diferenças finitas em grades 1D/2D, permitindo simulações em tempo real de perfis de temperatura ou fluxo em tubos industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Resolver sistemas não lineares",
                            "description": "Usar o método de Newton-Raphson para iterar sobre o sistema F(y) = 0, linearizando com a Jacobiana diagonal dominante e aplicando Thomas em cada iteração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o sistema não linear F(y) = 0 a partir do problema de valor de contorno",
                                  "subSteps": [
                                    "Identifique as equações diferenciais discretizadas pelo método de diferenças finitas resultando em um sistema não linear.",
                                    "Defina o vetor y de incógnitas nos pontos da grade.",
                                    "Escreva explicitamente F(y) = 0, onde cada componente corresponde a uma equação na grade.",
                                    "Especifique as condições de contorno e incorpore-as no sistema.",
                                    "Verifique se o sistema está corretamente indexado para a malha."
                                  ],
                                  "verification": "Confirme que F(y) tem o número correto de equações igual ao número de incógnitas e que as condições de contorno estão aplicadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, software de álgebra simbólica como SymPy ou MATLAB.",
                                  "tips": "Comece com um problema simples de segunda ordem para praticar a formulação.",
                                  "learningObjective": "Compreender como discretizar BVPs leva a sistemas não lineares.",
                                  "commonMistakes": "Esquecer de aplicar condições de contorno ou indexar incorretamente os pontos da grade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e verificar a Jacobiana diagonal dominante",
                                  "subSteps": [
                                    "Compute a matriz Jacobiana J(y) = ∂F/∂y analiticamente ou numericamente.",
                                    "Confirme que J é diagonal dominante: |J_ii| ≥ Σ_{j≠i} |J_ij| para todo i.",
                                    "Aplique aproximações se necessário para garantir dominância diagonal (ex: negligenciar termos off-diagonal pequenos).",
                                    "Teste com um y inicial para validar as propriedades.",
                                    "Armazene J em formato tridiagonal para eficiência."
                                  ],
                                  "verification": "Verifique numericamente a dominância diagonal somando as normas das linhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica, Python com NumPy ou MATLAB.",
                                  "tips": "Use diferenças finitas para aproximar J se a derivada analítica for complexa.",
                                  "learningObjective": "Dominar o cálculo da Jacobiana e suas propriedades para estabilidade.",
                                  "commonMistakes": "Calcular derivadas incorretas ou não verificar dominância, levando a instabilidade no solver Thomas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar iterações do método Newton-Raphson com solver Thomas",
                                  "subSteps": [
                                    "Escolha um y^0 inicial razoável (ex: solução linearizada).",
                                    "Em cada iteração: compute F(y^k) e J(y^k).",
                                    "Resolva J(y^k) δ^k = -F(y^k) usando o algoritmo Thomas para tridiagonal.",
                                    "Atualize y^{k+1} = y^k + δ^k.",
                                    "Registre resíduos ||F(y^{k+1})|| para monitoramento."
                                  ],
                                  "verification": "Execute pelo menos 3 iterações e confira que o resíduo diminui.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código em Python/MATLAB com função Thomas implementada, planilha para tracking.",
                                  "tips": "Implemente Thomas em loop para eficiência; use fatoração LU se J mudar pouco.",
                                  "learningObjective": "Aplicar Newton-Raphson combinado com Thomas para sistemas tridiagonais.",
                                  "commonMistakes": "Erro na implementação de Thomas (divisão por zero) ou passo δ muito grande sem damping."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir critérios de parada e analisar convergência",
                                  "subSteps": [
                                    "Defina tolerância ε (ex: 1e-6) para ||F(y)|| < ε ou ||δ|| < ε.",
                                    "Monitore número máximo de iterações (ex: 50).",
                                    "Verifique convergência quadrática plotando log(resíduo) vs iteração.",
                                    "Aplique damping se oscilar (y^{k+1} = y^k + α δ^k, α<1).",
                                    "Compare solução final com solução exata se disponível."
                                  ],
                                  "verification": "Resíduo final abaixo de ε e gráfico de convergência linear/quadrática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos em Python/MATLAB, tabela de resíduos.",
                                  "tips": "Sempre plote resíduos para diagnosticar problemas.",
                                  "learningObjective": "Avaliar robustez e convergência do método.",
                                  "commonMistakes": "Parada prematura sem verificar resíduo ou ignorar divergência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar a solução no contexto do BVP",
                                  "subSteps": [
                                    "Reconstrua a solução contínua interpolando y nos pontos da grade.",
                                    "Verifique satisfação das condições de contorno.",
                                    "Calcule erros relativos se solução analítica conhecida.",
                                    "Analise sensibilidade a malha (refine h e reexecute).",
                                    "Documente parâmetros finais (iterações, tempo CPU)."
                                  ],
                                  "verification": "Solução satisfaz F(y) ≈ 0 e condições de contorno dentro de tolerância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de plotagem como Matplotlib ou MATLAB.",
                                  "tips": "Refine a malha para confirmar precisão de segunda ordem.",
                                  "learningObjective": "Interpretar resultados numéricos no contexto físico/matemático.",
                                  "commonMistakes": "Não validar condições de contorno ou ignorar erros de discretização."
                                }
                              ],
                              "practicalExample": "Resolva o BVP não linear -u'' + u^2 = 0, u(0)=0, u(1)=1 com h=0.1. Formule F(y), compute J diagonal dominante, itere Newton-Raphson com Thomas até resíduo <1e-6, e plote u(x) aproximada vs exata.",
                              "finalVerifications": [
                                "Resíduo final ||F(y)|| < 1e-6.",
                                "Número de iterações ≤ 20.",
                                "Solução satisfaz condições de contorno exatamente.",
                                "Convergência quadrática observada no log-resíduo.",
                                "Erro relativo < 1% comparado a solução fina.",
                                "Jacobiana confirmada diagonal dominante em todas iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de F(y) e J(y) (20%).",
                                "Implementação correta de Thomas e Newton-Raphson (30%).",
                                "Análise de convergência e parada adequada (20%).",
                                "Validação e interpretação dos resultados (20%).",
                                "Eficiência computacional e código limpo (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações diferenciais não lineares em mecânica e fluidos.",
                                "Programação: Implementação numérica em Python/MATLAB para análise científica.",
                                "Engenharia: Solução de BVPs em estruturas e calor com não linearidades.",
                                "Estatística: Análise de sensibilidade e erros de truncamento."
                              ],
                              "realWorldApplication": "Em engenharia química, resolve balanços de massa não lineares em reatores; em finanças, otimiza portfólios com restrições não lineares; em aerodinâmica, simula fluxos compressíveis discretizados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Analisar convergência e estabilidade",
                            "description": "Verificar a consistência (ordem de precisão), estabilidade (condição da matriz) e convergência do método, relacionando com h pequeno e problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Consistência do Método (Ordem de Precisão)",
                                  "subSteps": [
                                    "Defina o erro de truncagem local (LTE) para o esquema de diferenças finitas.",
                                    "Expanda a solução exata em série de Taylor e compare com a aproximação discreta.",
                                    "Calcule a ordem de precisão p tal que LTE = O(h^p), onde h é o passo de malha.",
                                    "Verifique se o método é consistente, i.e., LTE → 0 quando h → 0.",
                                    "Teste numericamente reduzindo h e observando a redução do erro."
                                  ],
                                  "verification": "O erro de truncagem calculado tende a zero com h → 0 e ordem p identificada corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), Python com NumPy/SciPy, caderno para cálculos.",
                                  "tips": "Sempre use expansão de Taylor centrada no ponto médio para esquemas centrados.",
                                  "learningObjective": "Identificar e calcular a ordem de precisão de um esquema de diferenças finitas.",
                                  "commonMistakes": "Esquecer termos de ordem superior na expansão de Taylor; confundir LTE com erro global."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estabilidade via Condição da Matriz",
                                  "subSteps": [
                                    "Forme a matriz tridiagonal A do sistema linear Au = f proveniente da discretização.",
                                    "Calcule os autovalores de A ou estime a norma ||A|| e ||A^{-1}||.",
                                    "Compute o número de condição κ(A) = ||A|| * ||A^{-1}||.",
                                    "Verifique se κ(A) permanece bounded independentemente de h (estável) ou cresce como 1/h^2 (instável).",
                                    "Analise o espectro de autovalores para rigidez."
                                  ],
                                  "verification": "Número de condição κ(A) calculado e interpretado corretamente para diferentes h.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Python (SciPy.linalg.eigvals, cond), exemplos de BVP como -u'' + u = 0.",
                                  "tips": "Use decomposição SVD para matrizes grandes em vez de inversão direta.",
                                  "learningObjective": "Avaliar a estabilidade de métodos de diferenças finitas através da condição da matriz.",
                                  "commonMistakes": "Confundir norma espectral com norma euclidiana; ignorar o impacto de fronteiras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Convergência do Método",
                                  "subSteps": [
                                    "Lembre o Teorema de Lax: consistência + estabilidade ⇒ convergência.",
                                    "Combine resultados de consistência (O(h^p)) e estabilidade para estimar erro global O(h^p).",
                                    "Implemente numericamente e plote log(|erro|) vs log(h) para confirmar ordem p.",
                                    "Compare solução numérica com solução exata conhecida.",
                                    "Discuta taxa de convergência assintótica."
                                  ],
                                  "verification": "Gráfico log-log mostra inclinação p, confirmando convergência de ordem p.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB para simulação, solução exata de BVP teste (ex: u'' + u = 0).",
                                  "tips": "Use malhas uniformes e refine h por fator 2 para eficiência no teste de ordem.",
                                  "learningObjective": "Aplicar teorema de convergência e validar numericamente.",
                                  "commonMistakes": "Erro de arredondamento domina para h muito pequeno; não usar solução exata precisa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com h Pequeno e Problemas Stiff",
                                  "subSteps": [
                                    "Analise como κ(A) ~ 1/h^2 cresce com h → 0, amplificando erros de arredondamento.",
                                    "Identifique problemas stiff: razão de autovalores grandes (ex: Reação-difusão).",
                                    "Simule BVP stiff e observe perda de precisão para h pequeno.",
                                    "Discuta mitigações: malhas adaptativas, métodos implícitos ou preconditioners.",
                                    "Compare com métodos explícitos vs implícitos."
                                  ],
                                  "verification": "Identificação correta de degradação em h pequeno e sugestões de soluções para stiff.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de BVP stiff em Python (ex: u'' - 1000u = -f), documentação SciPy.",
                                  "tips": "Para stiff, prefira solvers como solve_bvp em SciPy.",
                                  "learningObjective": "Entender limitações práticas em h pequeno e stiff, propondo soluções.",
                                  "commonMistakes": "Ignorar erros de máquina que mascaram convergência teórica."
                                }
                              ],
                              "practicalExample": "Para o BVP -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0 (exata: u=sin(πx)), discretize com diferenças centrais de 2ª ordem. Calcule LTE=O(h²), κ(A)≈1/h², plote erro vs h confirmando convergência O(h²) até h≈10^{-6} onde cond deteriora.",
                              "finalVerifications": [
                                "Ordem de precisão calculada e confirmada numericamente.",
                                "Número de condição da matriz estimado para múltiplos h.",
                                "Gráfico de convergência mostra taxa correta até limitação numérica.",
                                "Identificação de problemas stiff com razões de autovalores >10^6.",
                                "Sugestões válidas para melhorar estabilidade em h pequeno.",
                                "Aplicação correta do Teorema de Lax."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de LTE e ordem p (80% acerto em cálculos).",
                                "Correta interpretação de κ(A) e seu impacto na estabilidade.",
                                "Validação numérica com gráficos log-log precisos.",
                                "Compreensão de limitações em problemas stiff e h pequeno.",
                                "Uso adequado de teoremas teóricos.",
                                "Clareza na discussão de mitigações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDOs elípticas em mecânica/ondas.",
                                "Computação: Análise de complexidade e condicionamento em álgebra linear numérica.",
                                "Engenharia: Simulações em CFD e transferência de calor.",
                                "Estatística: Análise de erros numéricos e incertezas."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como fluxo de calor em placas (PDEs elípticas), análise garante precisão em malhas finas sem amplificação de erros, essencial para design de reatores nucleares ou aerodinâmica onde stiff surge de multi-escalas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Introdução aos Métodos Pseudoespectrais",
                    "description": "Aproximações polinomiais globais e uso de transformadas rápidas de Fourier para resolver problemas de valor de contorno com alta precisão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Aproximações Polinomiais Globais",
                        "description": "Conceitos fundamentais sobre aproximações polinomiais que utilizam bases globais, como polinômios de Chebyshev ou Legendre, para representar soluções de problemas diferenciais em todo o domínio, contrastando com métodos locais como diferenças finitas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Diferenciar aproximações globais de locais",
                            "description": "Identificar e explicar as diferenças entre métodos de aproximação global (polinômios em todo o domínio) e local (elementos finitos ou diferenças finitas), destacando vantagens em precisão exponencial para soluções suaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Aproximações Globais",
                                  "subSteps": [
                                    "Defina aproximação global como o uso de polinômios ou funções que se estendem por todo o domínio do problema.",
                                    "Estude bases como polinômios de Chebyshev ou Legendre, que são otimizados para intervalos finitos.",
                                    "Analise como a solução é representada por uma soma de termos globais com coeficientes determinados globalmente.",
                                    "Examine o processo de projeção, como método dos resíduos ponderados ou colocation.",
                                    "Discuta a suavidade requerida: soluções C^∞ para convergência espectral."
                                  ],
                                  "verification": "Resuma em um parágrafo as características principais das aproximações globais e forneça um exemplo de base polinomial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Trefethen 'Spectral Methods'), software MATLAB ou Python com NumPy/SciPy.",
                                  "tips": "Visualize funções globais plotando polinômios de alto grau para ver sua oscilação mínima nos nós de Chebyshev.",
                                  "learningObjective": "Identificar as bases e métodos de representação em aproximações globais.",
                                  "commonMistakes": "Confundir com séries de Fourier locais; lembre-se que globais usam todo o domínio sem partição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Aproximações Locais",
                                  "subSteps": [
                                    "Defina aproximações locais como métodos que dividem o domínio em elementos pequenos (ex: malha em elementos finitos).",
                                    "Estude diferenças finitas: aproximação de derivadas por diferenças em pontos vizinhos.",
                                    "Analise elementos finitos: funções de forma polinomiais locais por elemento, continuidade C^0.",
                                    "Discuta montagem da matriz global a partir de contribuições locais.",
                                    "Examine ordem de precisão: tipicamente algebraica (h^p), não exponencial."
                                  ],
                                  "verification": "Desenhe uma malha simples e explique como calcular uma derivada por diferenças finitas em um ponto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tutorial de FEniCS ou MATLAB PDE Toolbox, papel e lápis para esboços de malha.",
                                  "tips": "Comece com malhas uniformes para simplicidade antes de refinar.",
                                  "commonMistakes": "Ignorar acoplamento entre elementos; verifique continuidade nas interfaces."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Fundamentais",
                                  "subSteps": [
                                    "Compare suporte das funções base: global (todo domínio) vs. local (um elemento).",
                                    "Analise rigidez da matriz: globais levam a matrizes densas; locais a esparsas.",
                                    "Discuta tratamento de singularidades: globais sensíveis a não-suavidades; locais robustas.",
                                    "Examine custo computacional: globais eficientes para N baixo, mas O(N^2); locais O(N).",
                                    "Resuma em tabela: precisão, suavidade requerida, tipo de matriz."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 5 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook para tabela.",
                                  "tips": "Use analogia: global como orquestra sinfônica (coerente mas frágil), local como coral em seções (robusto mas menos harmonioso).",
                                  "learningObjective": "Listar e explicar diferenças em suporte, precisão e custo.",
                                  "commonMistakes": "Subestimar impacto da densidade de matriz em problemas 2D/3D."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Vantagens em Precisão Exponencial para Soluções Suaves",
                                  "subSteps": [
                                    "Explique convergência espectral: erro ~ e^{-N} para soluções analíticas suaves em globais.",
                                    "Compare com convergência algebraica em locais: erro ~ h^p, polinomial em 1/N.",
                                    "Teste numericamente: resolva -u'' + u = f em [0,1] com u suave.",
                                    "Analise erro vs. graus de liberdade para ambos métodos.",
                                    "Discuta quando usar cada: globais para problemas elípticos suaves periódicos."
                                  ],
                                  "verification": "Implemente um exemplo numérico simples e plote log(erro) vs. N, mostrando exponencial vs. linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB pronto (ex: spectral toolbox), gráfico de erro.",
                                  "tips": "Use solução exata conhecida como sin(pi x) para validar.",
                                  "learningObjective": "Demonstrar matematicamente e numericamente a superioridade em precisão para suaves.",
                                  "commonMistakes": "Aplicar globais a soluções não-suaves, levando a Gibbs phenomenon."
                                }
                              ],
                              "practicalExample": "Resolva o problema de valor de contorno -u''(x) + u(x) = pi^2 sin(pi x), u(0)=u(1)=0. Use polinômios de Chebyshev globais (N=16) vs. diferenças finitas centrais locais (h=1/32). Compare erros L2: global ~1e-10, local ~1e-3, ilustrando precisão exponencial.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças chave sem consultar notas.",
                                "Crie tabela comparativa precisa.",
                                "Implemente código numérico mostrando curvas de convergência.",
                                "Identifique cenário onde local é preferível (ex: domínio complexo).",
                                "Resuma vantagens globais para solução suave em 1 frase.",
                                "Descreva Gibbs phenomenon em globais para não-suave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de global vs. local (90% correto).",
                                "Correta identificação de convergência espectral vs. algebraica.",
                                "Tabela comparativa completa com pelo menos 5 itens.",
                                "Exemplo numérico funcional com plots de erro.",
                                "Explicação clara de quando usar cada método.",
                                "Ausência de confusões comuns como suporte das bases."
                              ],
                              "crossCurricularConnections": [
                                "Física: Métodos espectrais em mecânica quântica (equação de Schrödinger).",
                                "Computação: Algoritmos paralelos para matrizes densas/esparsas (MPI/OpenMP).",
                                "Engenharia: Simulações CFD com pseudoespectrais em turbulência suave.",
                                "Estatística: Aproximação de funções de densidade suave."
                              ],
                              "realWorldApplication": "Em modelagem climática, métodos pseudoespectrais globais (ex: modelo GFDL) resolvem equações de Navier-Stokes em esferas com precisão exponencial para fluxos suaves, reduzindo graus de liberdade de milhões para milhares comparado a FEM."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Entender bases polinomiais ortogonais",
                            "description": "Descrever polinômios de Chebyshev e Legendre, suas propriedades ortogonais e como são usados para expandir funções em séries para alta precisão em problemas de valor de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução aos Polinômios Ortogonais e suas Propriedades Fundamentais",
                                  "subSteps": [
                                    "Defina polinômios ortogonais como uma família de polinômios satisfazendo ∫ p_m(x) p_n(x) w(x) dx = 0 para m ≠ n, onde w(x) é o peso.",
                                    "Explique a ortogonalidade em espaços L2 com peso e sua importância para bases em expansões de funções.",
                                    "Discuta vantagens sobre bases monomiais: estabilidade numérica e convergência espectral.",
                                    "Revise integrais internas e normas em espaços ponderados.",
                                    "Calcule exemplos simples de ortogonalidade para polinômios de grau baixo."
                                  ],
                                  "verification": "Resolva exercícios comprovando ortogonalidade para polinômios de Legendre de graus 0 e 1 em [-1,1].",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Trefethen 'Spectral Methods'), Wolfram Alpha ou MATLAB para verificações",
                                    "Folha de papel e calculadora"
                                  ],
                                  "tips": "Comece com pesos unitários para intuitar; visualize graficamente os polinômios.",
                                  "learningObjective": "Compreender o conceito de ortogonalidade ponderada e sua relevância em aproximações.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com normalização; esquecer o peso w(x) nas integrais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Polinômios de Chebyshev: Definição, Geração e Propriedades",
                                  "subSteps": [
                                    "Defina T_n(x) = cos(n arccos(x)) para x em [-1,1], peso w(x) = 1/sqrt(1-x^2).",
                                    "Gere os primeiros T_0 até T_5 recursivamente: T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x).",
                                    "Prove propriedades: raízes em cos((2k-1)π/(2n)), extremos equidistantes, convergência rápida em contínuo.",
                                    "Calcule coeficientes de expansão f(x) ≈ ∑ c_k T_k(x) via integrais discretas (quadratura de Chebyshev).",
                                    "Implemente graficamente os primeiros polinômios."
                                  ],
                                  "verification": "Gere T_3(x) e verifique ortogonalidade com T_0 via integral numérica.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy), Spectral Methods in MATLAB (Trefethen)",
                                    "Gráficos interativos online (Desmos)"
                                  ],
                                  "tips": "Use a relação trigonométrica para memorizar oscilações; discretize para computação.",
                                  "learningObjective": "Dominar geração e propriedades específicas dos polinômios de Chebyshev.",
                                  "commonMistakes": [
                                    "Erro na recursão inicial (T_0=1, T_1=x); ignorar o peso na norma."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Polinômios de Legendre: Definição, Propriedades e Comparação",
                                  "subSteps": [
                                    "Defina P_n(x) via Rodrigues: P_n(x) = 1/(2^n n!) d^n/dx^n (x^2-1)^n, peso w(x)=1 em [-1,1].",
                                    "Gere recursivamente: (n+1) P_{n+1} = (2n+1) x P_n - n P_{n-1}.",
                                    "Liste propriedades: P_n(1)=1, raízes de Gauss-Legendre, ortogonalidade ∫ P_m P_n dx = 2/(2n+1) δ_{mn}.",
                                    "Compare com Chebyshev: Legendre para integrais exatas, Chebyshev para minimax.",
                                    "Calcule expansão de uma função teste como f(x)=x^2."
                                  ],
                                  "verification": "Compute coeficientes de Legendre para f(x)=sin(πx/2) e plote aproximação parcial.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para fórmulas simbólicas",
                                    "Tabela de polinômios ortogonais (Wikipedia ou handbook)"
                                  ],
                                  "tips": "Use Gauss quadrature para coeficientes eficientemente; foque em simetria par/impar.",
                                  "learningObjective": "Entender diferenças e aplicações complementares entre Chebyshev e Legendre.",
                                  "commonMistakes": [
                                    "Fórmula de Rodrigues errada; confundir normas entre as bases."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação em Expansões de Séries para Problemas de Valor de Contorno",
                                  "subSteps": [
                                    "Apresente expansão espectral: u(x) ≈ ∑ u_k φ_k(x), com φ_k base ortogonal.",
                                    "Para BVP -u'' + λu = f, projete em base: sistema matricial via mass/stiffness (Galerkin).",
                                    "Discuta precisão exponencial para soluções suaves devido a analiticidade.",
                                    "Implemente numérico: escolha N=16, resolva u''=π^2 sin(πx) em [0,1] com BCs Dirichlet.",
                                    "Analise erro vs N e compare com FD/FV."
                                  ],
                                  "verification": "Resolva BVP exemplo com N=8,10,12; erro L2 <1e-6 para N=12.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Código MATLAB/Python (chebfun ou spectral toolbox)",
                                    "Exemplos de Trefethen Capítulo 5"
                                  ],
                                  "tips": "Normalizar base para condicionamento; use FFT para Chebyshev pseudospectral.",
                                  "learningObjective": "Aplicar bases ortogonais em métodos pseudoespectrais para BVPs.",
                                  "commonMistakes": [
                                    "Aliasing em derivadas; BCs não impostas corretamente (collocation)."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP u'' + u = 0 em [-1,1] com u(-1)=u(1)=0 usando expansão em Chebyshev de ordem 10: projete, resolva sistema 2x2 tridiagonal via tau method, plote solução vs exata cos(πx/2).",
                              "finalVerifications": [
                                "Descreva verbalmente a diferença entre pesos de Chebyshev e Legendre.",
                                "Gere e plote T_4(x) e P_4(x), identificando raízes/extremos.",
                                "Compute 3 coeficientes de expansão de f(x)=e^x em Legendre.",
                                "Explique por que convergência é espectral em pseudoespectrais.",
                                "Resolva um BVP simples numericamente e reporte erro.",
                                "Compare precisão de Chebyshev vs monomiais para mesma N."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e geração de polinômios (80% correto).",
                                "Compreensão de ortogonalidade comprovada por cálculos (integral <1e-3 erro).",
                                "Implementação numérica funcional sem erros de BCs.",
                                "Análise qualitativa de convergência e estabilidade.",
                                "Explicação clara de aplicações em BVPs.",
                                "Identificação correta de erros comuns em expansões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações diferenciais em mecânica quântica (oscilador harmônico).",
                                "Engenharia: Simulações CFD com métodos espectrais (NASA aerodinâmica).",
                                "Computação: Algoritmos de FFT para transformadas rápidas.",
                                "Estatística: Regressão ortogonal e análise de componentes principais."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), bases Chebyshev/Legendre expandem campos de temperatura/vento para simular atmosfera com precisão espectral; em aeroespacial, otimizam perfis de asas minimizando erro em equações de Navier-Stokes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Aplicar interpolação espectral",
                            "description": "Calcular interpolação de uma função em pontos de Chebyshev-Gauss-Lobatto e avaliar a convergência espectral para aproximações polinomiais globais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e gerar os pontos de Chebyshev-Gauss-Lobatto",
                                  "subSteps": [
                                    "Defina o intervalo de interpolação, tipicamente [-1, 1].",
                                    "Recupere a fórmula para os pontos: x_k = cos(π k / N) para k = 0 a N.",
                                    "Implemente a geração dos pontos em software numérico (ex: NumPy ou MATLAB).",
                                    "Visualize os pontos em um gráfico para observar aglomeração nos extremos.",
                                    "Compare com pontos equidistantes para destacar a vantagem espectral."
                                  ],
                                  "verification": "Verifique se os pontos para N=6 coincidem com valores conhecidos (ex: x0=1, x3≈0, x6=-1).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/MATLAB",
                                    "Documentação de métodos espectrais (Trefethen Spectral Methods)"
                                  ],
                                  "tips": "Use arange para k e np.cos para eficiência; normalize se o intervalo não for [-1,1].",
                                  "learningObjective": "Compreender a distribuição não-uniforme dos pontos para minimizar o fenômeno de Runge.",
                                  "commonMistakes": [
                                    "Usar pontos Gauss-Legendre em vez de Lobatto",
                                    "Esquecer de incluir os extremos x=±1",
                                    "Intervalo incorreto sem mapeamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a função nos pontos de interpolação",
                                  "subSteps": [
                                    "Escolha uma função suave teste, como f(x) = exp(x) ou sin(πx).",
                                    "Calcule f(x_k) para todos os k=0 a N.",
                                    "Armazene os valores em um vetor y de tamanho N+1.",
                                    "Verifique a precisão numérica dos valores computados.",
                                    "Plote f(x_k) vs x_k para inspeção visual."
                                  ],
                                  "verification": "Compare y com valores analíticos conhecidos em pontos selecionados (erro < 1e-12).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software numérico (Python/MATLAB)",
                                    "Funções teste padrão"
                                  ],
                                  "tips": "Evite funções com singularidades no intervalo para demonstrar convergência espectral.",
                                  "learningObjective": "Preparar dados de interpolação para construção do polinômio.",
                                  "commonMistakes": [
                                    "Avaliar em pontos errados",
                                    "Usar precisão baixa em funções oscilantes",
                                    "Não armazenar em vetor ordenado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o polinômio interpolante espectral",
                                  "subSteps": [
                                    "Implemente a interpolação de Lagrange: P(x) = sum y_k * l_k(x), onde l_k são base de Lagrange.",
                                    "Use formulação barycêntrica para estabilidade numérica: P(x) = [sum (w_k y_k / (x - x_k))] / [sum (w_k / (x - x_k))].",
                                    "Gere pesos barycêntricos w_k = 1/prod_{j≠k} (x_k - x_j) (-1)^{k} δ_k.",
                                    "Avalie P(x) em uma grade fina de pontos para plotar.",
                                    "Compare P(x) com f(x) visualmente."
                                  ],
                                  "verification": "P(x_k) = y_k exatamente para todos k (erro máquina).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código para interpolação barycêntrica",
                                    "Livro 'Spectral Methods in MATLAB' de Trefethen"
                                  ],
                                  "tips": "Prefira barycêntrica para N>20; evite Lagrange direta por instabilidade.",
                                  "learningObjective": "Dominar a construção eficiente de aproximações polinomiais globais.",
                                  "commonMistakes": [
                                    "Instabilidade em Lagrange direta para altos N",
                                    "Pesos barycêntricos errados",
                                    "Avaliação fora da grade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a convergência espectral",
                                  "subSteps": [
                                    "Aumente N (ex: 4,8,16,32) e repita interpolação para cada N.",
                                    "Calcule o erro máximo: max |f(x) - P_N(x)| em uma grade fina.",
                                    "Plote log(erros) vs N ou grau polinomial para observar decaimento exponencial.",
                                    "Calcule taxa de convergência: log2(erro_N / erro_{2N}).",
                                    "Interprete: convergência espectral se taxa ≈ constante >1."
                                  ],
                                  "verification": "Erro diminui exponencialmente (ex: para f suave, erro ~ 10^{-N/2}).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Scripts de interpolação reutilizáveis",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use grade de 1000 pontos para erro max; teste funções analíticas.",
                                  "learningObjective": "Reconhecer e quantificar a convergência espectral vs convergência algébrica.",
                                  "commonMistakes": [
                                    "Função não suave levando a Gibbs",
                                    "Grade grosseira subestimando erro",
                                    "Log plot errado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e otimizar a interpolação espectral",
                                  "subSteps": [
                                    "Teste com função menos suave (ex: |x|) e observe perda de convergência espectral.",
                                    "Implemente mapeamento para intervalos arbitrários.",
                                    "Compare custo computacional (O(N^2) vs FFT para Chebyshev).",
                                    "Discuta aliasing e filtros espectrais.",
                                    "Documente relatório com plots e conclusões."
                                  ],
                                  "verification": "Relatório mostra convergência exponencial para funções suaves e análise de limitações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Códigos anteriores",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use log-log para taxas; mencione aplicações em PDEs.",
                                  "learningObjective": "Aplicar criticamente métodos espectrais em contextos reais.",
                                  "commonMistakes": [
                                    "Ignorar custo O(N^2)",
                                    "Não testar funções não-suaves",
                                    "Conclusões sem evidência numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Interpole f(x) = exp(x) em [-1,1] usando N=8,16,32 pontos Chebyshev-Gauss-Lobatto. Plote f(x), P_N(x) e erro max em grade de 1000 pontos. Observe erro caindo de 1e-3 para 1e-10 ao dobrar N, confirmando convergência espectral.",
                              "finalVerifications": [
                                "Geração correta de pontos Lobatto para múltiplos N.",
                                "Construção estável do interpolante (erro máquina nos nós).",
                                "Cálculo preciso do erro máximo em grade fina.",
                                "Gráfico de log(erros) vs N exponencial.",
                                "Taxa de convergência > 2 para funções analíticas suaves.",
                                "Análise qualitativa de vantagens sobre métodos finitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da interpolação (erro < 1e-10 para N=16).",
                                "Eficiência e estabilidade da implementação (barycêntrica usada).",
                                "Correta quantificação da convergência espectral (decaimento exponencial).",
                                "Qualidade dos plots e visualizações.",
                                "Interpretação física/matemática dos resultados.",
                                "Código limpo, comentado e reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução espectral de equações de onda e difusão.",
                                "Computação Científica: Implementação em FFT para métodos pseudospectrais.",
                                "Engenharia: Simulações CFD e aeroacústica.",
                                "Análise de Dados: Aproximação de séries temporais suaves."
                              ],
                              "realWorldApplication": "Métodos espectrais com interpolação Chebyshev são usados em simulações numéricas de alta precisão, como previsão meteorológica (modelos globais), dinâmica de fluidos computacional (NASA), propagação de ondas em telecomunicações e otimização em machine learning para aproximações de funções de ativação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Expansão Espectral e Métodos Pseudoespectrais",
                        "description": "Princípios da expansão de soluções em séries de Fourier ou polinomiais, e introdução aos métodos pseudoespectrais que usam diferenciação pseudoespectral para resolver equações diferenciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Explicar diferença entre métodos espectrais e pseudoespectrais",
                            "description": "Comparar métodos espectrais (projeção em espaço de coeficientes) com pseudoespectrais (diferenciação em espaço físico via interpolação), enfatizando simplicidade computacional dos pseudoespectrais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos dos Métodos Espectrais",
                                  "subSteps": [
                                    "Revise a expansão em séries de Fourier ou polinômios como base para projeção.",
                                    "Explique a projeção de uma função no espaço de coeficientes espectrais.",
                                    "Descreva como derivadas e integrais são computadas multiplicando coeficientes por fatores analíticos (ex: ik para derivada).",
                                    "Discuta a suavidade requerida das soluções para convergência exponencial.",
                                    "Implemente um exemplo simples de projeção em Python ou MATLAB."
                                  ],
                                  "verification": "Construa e plote a aproximação espectral de uma função suave e verifique a precisão dos coeficientes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de FFT (Numpy/Scipy)",
                                    "Notebook Jupyter",
                                    "Função teste suave como sen(x)"
                                  ],
                                  "tips": "Comece com funções periódicas para evitar Gibbs phenomenon.",
                                  "learningObjective": "Compreender como os métodos espectrais operam no espaço de coeficientes para operações diferenciais exatas.",
                                  "commonMistakes": "Confundir espaço físico com espaço espectral; aplicar FFT em funções não-periódicas sem padding."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Métodos Pseudoespectrais",
                                  "subSteps": [
                                    "Descreva a representação da solução via interpolação em pontos de Gauss-Lobatto ou colocation points.",
                                    "Explique o cálculo de derivadas no espaço físico usando matrizes de diferenciação pré-computadas.",
                                    "Mostre como aplicar FFT para transformação para o espaço espectral apenas para derivadas, retornando ao físico.",
                                    "Implemente diferenciação pseudoespectral para uma função teste.",
                                    "Compare visualmente a precisão com métodos finitos de diferenças."
                                  ],
                                  "verification": "Calcule a derivada pseudoespectral de sin(x) e compare com a analítica em pontos de grade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código de exemplo para pseudospectral differentiation (Chebfun ou Dedalus)",
                                    "Gráficos de erro"
                                  ],
                                  "tips": "Use pontos Chebyshev para domínios não-periódicos para melhor precisão.",
                                  "learningObjective": "Dominar o fluxo de trabalho pseudoespectral: interpolação → FFT → multiplicação → IFFT.",
                                  "commonMistakes": "Esquecer de lidar com aliasing via dealiasing (2/3 rule); usar grades irregulares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diretamente os Dois Métodos",
                                  "subSteps": [
                                    "Liste diferenças chave: espectrais (tudo em coeficientes) vs pseudoespectrais (derivadas no físico via spectral).",
                                    "Crie uma tabela comparativa: precisão, custo computacional, tratamento de não-linearidades.",
                                    "Simule um problema simples (ex: onda linear) com ambos e compare tempos de execução.",
                                    "Discuta quando espectrais são preferíveis (soluções analiticamente suaves) vs pseudoespectrais (geral).",
                                    "Analise o runge phenomenon em aproximações espectrais puras."
                                  ],
                                  "verification": "Gere uma tabela ou diagrama Venn destacando sobreposições e diferenças únicas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramentas de timing (timeit em Python)",
                                    "Problema teste: u_t = u_xx"
                                  ],
                                  "tips": "Meça FLOPs ou tempo de CPU para quantificar diferenças.",
                                  "learningObjective": "Identificar e articular diferenças fundamentais em termos de espaços de operação e implementação.",
                                  "commonMistakes": "Ignorar que pseudoespectrais são uma aproximação espectral com colocation; superestimar precisão espectral em soluções não-suas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enfatizar Vantagens Computacionais dos Pseudoespectrais",
                                  "subSteps": [
                                    "Calcule complexidade: O(N log N) via FFT vs O(N^2) para matrizes densas em espectrais puros.",
                                    "Explique simplicidade: evita manipulação explícita de coeficientes para não-linearidades.",
                                    "Implemente um solver pseudoespectral para Navier-Stokes 1D e compare performance.",
                                    "Discuta filtros e dealiasing como truques práticos.",
                                    "Resuma trade-offs: precisão ligeiramente inferior mas escalabilidade superior."
                                  ],
                                  "verification": "Execute benchmarks mostrando speedup pseudoespectral em N=1024 pontos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca Spectral (Dedalus ou PySpectral)",
                                    "Hardware com FFT otimizado"
                                  ],
                                  "tips": "Use multi-threaded FFT para realçar ganhos.",
                                  "learningObjective": "Avaliar por que pseudoespectrais são mais simples e eficientes computacionalmente.",
                                  "commonMistakes": "Confundir custo de FFT com custo total; negligenciar overhead de transformações."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de Burgers 1D (u_t + u u_x = nu u_xx) com condições periódicas. Implemente ambos métodos: espectral (projeção Galerkin) e pseudoespectral (colocation com FFT). Compare precisão, tempo de execução e estabilidade para nu=0.01, mostrando como pseudoespectral captura choques com menos esforço computacional.",
                              "finalVerifications": [
                                "Explicar verbalmente onde ocorrem as operações de diferenciação em cada método.",
                                "Implementar diferenciação básica para ambos e validar contra soluções analíticas.",
                                "Identificar cenários onde um método falha e o outro succeeds.",
                                "Criar tabela de prós/contras com pelo menos 5 itens cada.",
                                "Benchmark simples mostrando speedup pseudoespectral.",
                                "Discutir impacto na simulação de turbulência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre espaços de coeficientes vs físicos (80% peso).",
                                "Correta ênfase na simplicidade computacional dos pseudoespectrais (via FFT).",
                                "Uso de exemplos numéricos ou códigos para ilustração.",
                                "Compreensão de trade-offs: precisão vs eficiência.",
                                "Capacidade de aplicar a problemas reais como PDEs não-lineares.",
                                "Clareza na comunicação de diferenças chave."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de fluidos em CFD (Navier-Stokes).",
                                "Ciência da Computação: Algoritmos de FFT e paralelização (GPU).",
                                "Engenharia: Otimização numérica em controle e aerodinâmica.",
                                "Física: Modelagem de ondas e plasma (equações de Vlasov).",
                                "Estatística: Análise espectral de séries temporais."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCMs) e previsão de tempo, métodos pseudoespectrais são usados no modelo MPAS para resolver equações primitivas com alta resolução global, aproveitando eficiência computacional para grids com bilhões de pontos em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Calcular coeficientes espectrais",
                            "description": "Computar coeficientes de uma expansão espectral usando transformadas discretas e reconstruir a função aproximada para problemas de valor de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos de expansão espectral e transformadas discretas",
                                  "subSteps": [
                                    "Estude a definição de expansão espectral usando bases ortogonais como Fourier ou Chebyshev.",
                                    "Revise a transformada de Fourier discreta (DFT) e sua relação com séries de Fourier.",
                                    "Entenda a diferença entre transformada contínua e discreta, focando em amostragem.",
                                    "Aprenda sobre a Fast Fourier Transform (FFT) para eficiência computacional.",
                                    "Identifique condições de periodicidade ou domínio para problemas de valor de contorno (PVC)."
                                  ],
                                  "verification": "Explique em suas palavras como a DFT computa coeficientes espectrais e forneça um exemplo simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre análise numérica",
                                    "Documentação NumPy/SciPy para FFT",
                                    "Vídeo tutorial sobre DFT"
                                  ],
                                  "tips": [
                                    "Visualize a decomposição espectral com gráficos de funções seno/cosseno.",
                                    "Comece com casos periódicos para simplicidade."
                                  ],
                                  "learningObjective": "Dominar os conceitos teóricos de expansões espectrais e transformadas discretas.",
                                  "commonMistakes": [
                                    "Confundir DFT com DWT (Wavelet).",
                                    "Ignorar aliasing devido a amostragem insuficiente.",
                                    "Esquecer normalização nos coeficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar o domínio e a função para PVC",
                                  "subSteps": [
                                    "Defina o domínio do PVC (ex: [a,b]) e escolha N pontos equidistantes ou Chebyshev.",
                                    "Implemente a função f(x) no domínio discreto, respeitando condições de contorno.",
                                    "Aplique condições de contorno (Dirichlet/Neumann) aos pontos de grade.",
                                    "Crie um vetor de pontos x e valores f(x) em código.",
                                    "Verifique a grade com plotagem para uniformidade."
                                  ],
                                  "verification": "Gere e plote a grade discreta; confirme que condições de contorno são satisfeitas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Exemplos de PVC de análise numérica"
                                  ],
                                  "tips": [
                                    "Use np.linspace para grade uniforme; np.cos para Chebyshev extrema.",
                                    "Salve dados em arrays para reutilização."
                                  ],
                                  "learningObjective": "Preparar dados discretos adequados para métodos espectrais em PVC.",
                                  "commonMistakes": [
                                    "Pontos insuficientes levando a baixa resolução.",
                                    "Não mapear corretamente condições de contorno para periodicidade artificial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular coeficientes espectrais via transformada discreta",
                                  "subSteps": [
                                    "Implemente a DFT manualmente: c_k = sum f_j * exp(-2πi j k / N).",
                                    "Use FFT built-in (np.fft.fft) para eficiência e compare resultados.",
                                    "Aplique truncamento de modos altos se necessário para suavização.",
                                    "Armazene coeficientes em array complexo.",
                                    "Normalize conforme convenção (1/N ou não)."
                                  ],
                                  "verification": "Compare coeficientes computados manualmente e via FFT; erro < 1e-10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB",
                                    "Referência: Numerical Recipes ou SciPy docs"
                                  ],
                                  "tips": [
                                    "Teste com N=8 primeiro para depuração.",
                                    "Use abs() e angle() para visualizar magnitudes/fases."
                                  ],
                                  "learningObjective": "Computar com precisão coeficientes espectrais de funções discretas.",
                                  "commonMistakes": [
                                    "Erro de índice em loops DFT.",
                                    "Esquecer fator i imaginário ou sinal negativo.",
                                    "Não lidar com coeficientes complexos corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconstruir a função aproximada dos coeficientes",
                                  "subSteps": [
                                    "Implemente a transformada inversa: f_j ≈ sum c_k * exp(2πi j k / N).",
                                    "Use np.fft.ifft para reconstrução rápida.",
                                    "Aplique truncamento modal (ex: primeiros M < N/2 modos).",
                                    "Plote original vs. aproximada no domínio.",
                                    "Calcule erro de reconstrução (L2 norm)."
                                  ],
                                  "verification": "Erro L2 entre original e reconstruída < 1e-8 para N=64.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Funções de erro NumPy (np.linalg.norm)"
                                  ],
                                  "tips": [
                                    "Trunque modos altos para funções suaves.",
                                    "Use logscale para erros pequenos."
                                  ],
                                  "learningObjective": "Reconstruir funções aproximadas fiéis usando coeficientes espectrais.",
                                  "commonMistakes": [
                                    "Inverter sinal na exponencial inversa.",
                                    "Não truncar levando a Gibbs phenomenon.",
                                    "Erro de escala na normalização inversa."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar para PVC espectral",
                                  "subSteps": [
                                    "Teste convergência variando N e M.",
                                    "Incorpore condições de contorno na reconstrução.",
                                    "Compare com solução exata do PVC se disponível.",
                                    "Analise custo computacional (O(N log N) via FFT).",
                                    "Documente pipeline completo em script."
                                  ],
                                  "verification": "Convergência exponencial confirmada; erro cai com N.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Scripts anteriores",
                                    "Benchmark timer (timeit)"
                                  ],
                                  "tips": [
                                    "Use grids maiores (N=256+) com FFT.",
                                    "Registre erros em tabela."
                                  ],
                                  "learningObjective": "Avaliar e refinar aproximações espectrais para PVC.",
                                  "commonMistakes": [
                                    "Sobrestimar precisão sem erro quantitativo.",
                                    "Ignorar custo para N grande sem FFT."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = sin(π x) em [0,1] com PVC Dirichlet f(0)=f(1)=0, discretize com N=32 pontos Chebyshev, compute coeficientes via DCT (discreta Chebyshev), reconstrua truncando 16 modos, plote e compute erro L∞ < 1e-5.",
                              "finalVerifications": [
                                "Coeficientes corretos para exemplo padrão (erro < 1e-12).",
                                "Reconstrução visualmente indistinguível da original.",
                                "Erro L2 < 1e-6 para N=64 em PVC teste.",
                                "Código roda em <1s para N=1024 via FFT.",
                                "Condições de contorno preservadas na aproximação.",
                                "Convergência demonstrada em gráfico log-log."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos coeficientes e reconstrução.",
                                "Correta implementação de DFT/FFT e inversa.",
                                "Tratamento adequado de condições de contorno.",
                                "Eficiência computacional e escalabilidade.",
                                "Análise de erros e convergência.",
                                "Clareza e documentação do código."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de sinais e ondas em mecânica quântica.",
                                "Computação: Algoritmos paralelizáveis para big data (ex: clima).",
                                "Engenharia: Simulações CFD e aeroacústica.",
                                "Estatística: Análise espectral de séries temporais."
                              ],
                              "realWorldApplication": "Métodos espectrais são essenciais em simulações de dinâmica de fluidos (CFD), previsão meteorológica e modelagem molecular, onde alta precisão e eficiência em grids não-estruturados resolvem PDEs complexos rapidamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Implementar diferenciação pseudoespectral",
                            "description": "Derivar a matriz de diferenciação pseudoespectral para bases de Chebyshev e aplicá-la a uma função teste, verificando precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Polinômios de Chebyshev e Pontos de Colocação",
                                  "subSteps": [
                                    "Estude a definição recursiva dos polinômios de Chebyshev Tn(x) para n=0 a 5.",
                                    "Implemente o mapeamento de pontos de Gauss-Lobatto-Chebyshev no intervalo [-1,1]: x_j = cos(π j / N), j=0..N.",
                                    "Visualize graficamente os pontos de colocação para N=8 e compare com grade uniforme.",
                                    "Entenda a interpolação espectral: f(x) ≈ ∑ f_j φ_j(x), onde φ_j são base de Lagrange.",
                                    "Calcule manualmente os coeficientes de Lagrange para N=3."
                                  ],
                                  "verification": "Liste corretamente os 5 primeiros Tn(x) e os pontos x_j para N=4; plote-os em software.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notebook Jupyter ou MATLAB",
                                    "Documentação de Chebyshev (Trefethen 'Spectral Methods')",
                                    "Biblioteca NumPy/SciPy"
                                  ],
                                  "tips": "Sempre normalize o domínio para [-1,1] para evitar instabilidades numéricas.",
                                  "learningObjective": "Dominar a base ortogonal de Chebyshev e pontos de colocação para métodos espectrais.",
                                  "commonMistakes": [
                                    "Usar pontos equidistantes em vez de Chebyshev (piora convergência)",
                                    "Esquecer o fator de mapeamento para domínios físicos",
                                    "Confundir Tn(x) com polinômios de Legendre"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Analiticamente a Matriz de Diferenciação Pseudoespectral",
                                  "subSteps": [
                                    "Derive a base de Lagrange: l_j(x) = ∏_{k≠j} (x - x_k)/(x_j - x_k).",
                                    "Obtenha a derivada: l_j'(x_m) = δ_{jm} / c_j + termo de soma, onde c_0 = c_N=2, else 1.",
                                    "Construa a matriz D com D_{mj} = l_j'(x_m); verifique propriedades (D skew-simétrica exceto bordas).",
                                    "Calcule manualmente D para N=4 e verifique D * [1, x, x^2, x^3]^T = derivadas exatas.",
                                    "Analise o erro de truncamento: ordem espectral exponencial."
                                  ],
                                  "verification": "Matriz D para N=3 coincide com fórmula padrão; teste em polinômio de grau <N dá derivada exata.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "SymPy para verificação simbólica",
                                    "Referência: Canuto et al. 'Spectral Methods'"
                                  ],
                                  "tips": "Use a fórmula fechada de Trefethen para eficiência: colunas 1 e N têm expressões especiais.",
                                  "learningObjective": "Derivar e compreender a estrutura da matriz D pseudoespectral.",
                                  "commonMistakes": [
                                    "Índices errados em somas de Lagrange",
                                    "Ignorar fatores c_j nas bordas levando a erros O(1)",
                                    "Não verificar exatidão para polinômios baixos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Matriz D em Código Numérico",
                                  "subSteps": [
                                    "Escreva função para gerar pontos x e pesos Chebyshev em Python/MATLAB.",
                                    "Implemente construção de D usando loop para l_j'(x_m), otimize com vetores.",
                                    "Teste unicidade: D * ones(N+1,1) ≈ 0 exceto bordas.",
                                    "Adicione tratamento de domínio físico via mapeamento afim.",
                                    "Profile o código para N até 100; verifique estabilidade."
                                  ],
                                  "verification": "Código reproduz D exata para N=6 comparada a analítica; tempo <1s para N=256.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "Ou MATLAB",
                                    "GitHub repo de spectral methods"
                                  ],
                                  "tips": "Evite loops desnecessários; use broadcasting NumPy para velocidade.",
                                  "learningObjective": "Implementar eficientemente a diferenciação pseudoespectral em software.",
                                  "commonMistakes": [
                                    "Overflow numérico em N grande sem double precision",
                                    "Erros de indexação 0 vs 1-based",
                                    "Não mapear corretamente para [a,b]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Função Teste e Verificar Precisão Espectral",
                                  "subSteps": [
                                    "Escolha f(x)=sin(π x) em [-1,1]; compute valores nodais f_j.",
                                    "Aplique D f para obter aproximação de f'; compare com analítica π cos(π x) nos nós.",
                                    "Calcule erros L2 e L∞ para N=8,16,32; plote log-log convergência.",
                                    "Teste com f suave vs não-suave (ex: |x|) para demonstrar ordem espectral.",
                                    "Analise resíduos e refine para observar exponencial."
                                  ],
                                  "verification": "Erro L∞ <1e-10 para N=16 em f suave; gráfico mostra slope >10 em log-log.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 3",
                                    "Funções teste em SciPy",
                                    "Plots de erro"
                                  ],
                                  "tips": "Use norma discreta L2 = sqrt(∑ w_j err_j^2) com pesos Chebyshev para precisão.",
                                  "learningObjective": "Validar implementação via testes de convergência espectral.",
                                  "commonMistakes": [
                                    "Comparar em pontos errados (runge phenomenon)",
                                    "Não log-plotar para ver ordem",
                                    "Escala errada em erros absolutos vs relativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=6 pontos Chebyshev em [-1,1], construa D e aplique a f(x)=sin(π x). A derivada nos nós deve coincidir com π cos(π x) até ~1e-12; erro cai de 1e-4 (N=6) para 1e-12 (N=20).",
                              "finalVerifications": [
                                "Matriz D para N≤10 bate com valores analíticos conhecidos.",
                                "Diferenciação exata para polinômios de grau ≤N.",
                                "Convergência espectral: erro ~ exp(-N) para funções analíticas.",
                                "Estabilidade: ||D|| ~ O(N^2/4) mas controlada em prática.",
                                "Mapeamento afim preserva precisão em domínios físicos.",
                                "Código vetorizado roda para N=1024 sem crash."
                              ],
                              "assessmentCriteria": [
                                "Correção da derivação de D (fórmulas exatas).",
                                "Implementação numérica eficiente e estável (tempo e precisão).",
                                "Análise de erros quantitativa com plots log-log.",
                                "Tratamento de bordas e mapeamentos corretos.",
                                "Relatório com verificações e insights sobre convergência.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Solução de PDEs elípticos (Poisson) via spectral.",
                                "Engenharia: Simulações CFD e aeroacústica.",
                                "Ciência da Computação: Algoritmos de alta ordem e FFT.",
                                "Matemática Pura: Teoria de aproximação e resíduos.",
                                "Machine Learning: Bases ortogonais em redes neurais espectrais."
                              ],
                              "realWorldApplication": "Métodos pseudoespectrais são essenciais em simulações de Direct Numerical Simulation (DNS) de turbulência, previsão numérica do tempo, modelagem de ondas oceânicas e controle ótimo em engenharia aeroespacial, onde alta precisão com poucos pontos é crítica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Transformadas Rápidas de Fourier e Aplicação a BVPs",
                        "description": "Uso da FFT para eficiência computacional em métodos pseudoespectrais, com foco em resolver problemas de valor de contorno (BVP) de alta precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Compreender o papel da FFT em métodos espectrais",
                            "description": "Explicar como a Transformada Rápida de Fourier (FFT) acelera o cálculo de derivadas e convoluções em bases trigonométricas para problemas periódicos ou mapeados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos da Transformada Discreta de Fourier (DFT) e introdução à FFT",
                                  "subSteps": [
                                    "Revisar a definição da Transformada de Fourier contínua (FT) para funções periódicas.",
                                    "Explicar a DFT como soma discreta: DFT(u) = sum_{k=0}^{N-1} u_j exp(-2π i j k / N).",
                                    "Identificar a complexidade computacional da DFT direta: O(N²).",
                                    "Introduzir a FFT como algoritmo que reduz para O(N log N) usando divide-and-conquer.",
                                    "Discutir suposições: N potência de 2, função periódica ou mapeada."
                                  ],
                                  "verification": "Resumir em 3 frases a diferença entre DFT e FFT, citando complexidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre FT/DFT",
                                    "Gráfico comparativo de complexidade O(N²) vs O(N log N)",
                                    "Software como MATLAB ou Python (NumPy/FFT)"
                                  ],
                                  "tips": "Visualize com plots de funções senoidais para intuitar a decomposição em frequências.",
                                  "learningObjective": "Compreender a DFT como base discreta para métodos espectrais e o ganho de eficiência da FFT.",
                                  "commonMistakes": [
                                    "Confundir FT contínua com DFT discreta",
                                    "Ignorar requisito de N=2^m para FFT padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicação da FFT no cálculo acelerado de derivadas em bases trigonométricas",
                                  "subSteps": [
                                    "Explicar representação espectral: u(x) = sum_{k=-N/2}^{N/2-1} û_k exp(2π i k x / L).",
                                    "Derivar no domínio de Fourier: derivada de u → (2π i k / L) * û_k.",
                                    "Aplicar FFT para ir ao domínio freq.: FFT(u), multiplicar por ik, IFFT de volta.",
                                    "Comparar tempo: sem FFT (O(N²)), com FFT (O(N log N)).",
                                    "Verificar com exemplo: derivada de cos(2π x / L) deve dar - (2π / L) sin(2π x / L)."
                                  ],
                                  "verification": "Calcular manualmente derivada espectral para N=4 e comparar com fórmula analítica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Fórmulas de derivadas espectrais",
                                    "Código Python simples com numpy.fft",
                                    "Papel e lápis para N pequeno"
                                  ],
                                  "tips": "Sempre normalize o intervalo [0,L] para evitar fatores errados em k.",
                                  "learningObjective": "Dominar como FFT permite derivadas globais eficientes via multiplicação pontual.",
                                  "commonMistakes": [
                                    "Esquecer fator i em derivadas",
                                    "Não tratar aliasing de Nyquist (k=N/2)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Uso da FFT para acelerar convoluções em métodos espectrais",
                                  "subSteps": [
                                    "Recordar teorema da convolução: convolução no espaço → produto no domínio Fourier.",
                                    "Passos: FFT(u), FFT(v), multiplicar ponto a ponto, IFFT(resultado).",
                                    "Complexidade: O(N log N) vs O(N²) para convolução direta.",
                                    "Exemplo: convolução periódica para operadores diferenciais não-lineares.",
                                    "Discutir truncamento de produto para manter precisão espectral."
                                  ],
                                  "verification": "Implementar convolução de duas senoides via FFT e validar contra soma direta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Teorema convolução-Fourier",
                                    "Exemplo numérico em Jupyter Notebook",
                                    "Tabela de tempos para N=1024"
                                  ],
                                  "tips": "Use padding para convoluções lineares simulando periódicas.",
                                  "learningObjective": "Entender aceleração de convoluções via domínio freq., essencial para não-linearidades.",
                                  "commonMistakes": [
                                    "Confundir convolução circular com linear",
                                    "Ignorar normalização da IFFT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração da FFT em métodos pseudoespectrais para problemas periódicos ou mapeados",
                                  "subSteps": [
                                    "Descrever fluxo de método espectral para BVP periódico: FFT → resolver algebricamente → IFFT.",
                                    "Exemplo BVP: -u'' + u = f, periódico: multiplicar por -k² +1 no freq. domínio.",
                                    "Tratamento de condições de contorno: mapeamento para [0,2π] ou domínio duplo.",
                                    "Vantagens: alta precisão exponencial para soluções suaves.",
                                    "Limitações: apenas para periódicos; dealiasing para não-lineares."
                                  ],
                                  "verification": "Esboçar pseudocódigo para solver espectral de Poisson periódico usando FFT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo introdutório pseudoespectral",
                                    "Código template em Python",
                                    "Exemplo BVP resolvido analiticamente"
                                  ],
                                  "tips": "Teste com f=0 para verificar homogeneidade e condições periódicas.",
                                  "learningObjective": "Conectar FFT a resolução completa de BVPs via métodos espectrais eficientes.",
                                  "commonMistakes": [
                                    "Não impor u(0)=u(L), u'(0)=u'(L)",
                                    "Subestimar custo para N grande sem FFT"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente o BVP periódico -u'' + u = cos(2πx) em [0,1] com u(0)=u(1), u'(0)=u'(1). Use FFT para ir ao domínio freq., resolver (-(2πk)^2 +1) û_k = DFT(cos), IFFT para u. Compare com solução exata u= cos(2πx)/(1+4π²). Tempo com FFT: segundos; sem: horas para N=2^12.",
                              "finalVerifications": [
                                "Explicar em palavras próprias por que FFT é crucial para N>100 em métodos espectrais.",
                                "Calcular complexidade de um passo de derivada/convolução com/sem FFT.",
                                "Identificar quando FFT falha (ex: não-periódico) e soluções (mapeamento).",
                                "Validar exemplo prático: erro <1e-10 para solução suave.",
                                "Desenhar diagrama FFT → mult → IFFT para derivada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de complexidades O(N log N) vs O(N²).",
                                "Clareza na derivação de derivadas/convoluções no domínio Fourier.",
                                "Correta aplicação a BVPs periódicos com exemplos numéricos.",
                                "Identificação de suposições (periocidade, N=2^m) e limitações.",
                                "Uso de verificações práticas e comparações com soluções exatas.",
                                "Conexão explícita entre FFT e eficiência em métodos espectrais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações periódicas (equações de onda).",
                                "Engenharia: Processamento de sinais digitais e filtros FFT.",
                                "Computação: Algoritmos de divide-and-conquer e paralelização GPU.",
                                "Análise Numérica: Comparação com métodos finitos diferenças/elementos."
                              ],
                              "realWorldApplication": "Simulações de dinâmica de fluidos (equações de Navier-Stokes periódicas em canais), processamento de áudio/imagens (filtros convolucionais rápidos), previsão meteorológica (modelos espectrais globais) e criptografia quântica (transformadas rápidas em qubits)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Aplicar FFT a derivação espectral",
                            "description": "Usar FFT para computar derivadas de uma função periódica e comparar com derivação analítica, demonstrando precisão espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a função periódica e discretizá-la",
                                  "subSteps": [
                                    "Escolha uma função periódica suave, como f(x) = sin(2πx), no intervalo [0,1].",
                                    "Defina um número par de pontos N (ex: N=256) para o grid uniforme x = linspace(0,1,N, endpoint=False).",
                                    "Compute os valores da função no grid: f = sin(2*pi*x).",
                                    "Verifique a periodicidade: f[0] deve ser igual a f[-1].",
                                    "Plote a função para visualização inicial."
                                  ],
                                  "verification": "Grid discretizado gerado corretamente, com f[0] == f[-1] e gráfico suave exibido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib"
                                  ],
                                  "tips": "Use N potência de 2 para eficiência da FFT.",
                                  "learningObjective": "Entender como discretizar funções periódicas para métodos espectrais.",
                                  "commonMistakes": [
                                    "Incluir endpoint=True, quebrando periodicidade.",
                                    "Escolher N ímpar.",
                                    "Função não suave, causando aliasing."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a Transformada Rápida de Fourier (FFT)",
                                  "subSteps": [
                                    "Importe fft de scipy.fft e compute hat_f = fft(f).",
                                    "Gere os frequências wavenumbers k = 2*pi*fftfreq(N, 1/N).",
                                    "Identifique modos positivos e negativos: k_pos = k[0:N//2], k_neg = k[N//2:].",
                                    "Plote o espectro |hat_f| vs k para visualizar energia espectral.",
                                    "Verifique Parseval: soma(|f|^2) ≈ (1/N) soma(|hat_f|^2)."
                                  ],
                                  "verification": "Espectro computado e Parseval satisfeito com erro <1e-12.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy, SciPy (fft), Matplotlib"
                                  ],
                                  "tips": "Use fftfreq para k corretos; normalize adequadamente.",
                                  "learningObjective": "Dominar computação e interpretação do espectro Fourier discreto.",
                                  "commonMistakes": [
                                    "Erro no sinal de k negativos.",
                                    "Não normalizar fftfreq.",
                                    "Plotar sem shift para visualização simétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o operador de derivação espectral",
                                  "subSteps": [
                                    "Compute hat_df = 1j * k * hat_f (multiplicação pontual).",
                                    "Cuide da simetria: para k=0, derivada=0; modos altos podem precisar de dealiasing.",
                                    "Aplique filtro exponencial para dealiasing: multiplique hat_df[k > N/3] por 0.",
                                    "Plote espectro de hat_df vs k.",
                                    "Verifique que energia em alta frequência foi atenuada."
                                  ],
                                  "verification": "hat_df gerado com dealiasing aplicado e gráfico mostrando decaimento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy, SciPy"
                                  ],
                                  "tips": "Use 1j para imaginário; corte em 2/3 N para dealiasing quadrático.",
                                  "learningObjective": "Compreender multiplicação espectral para diferenciação exata em espaço de Fourier.",
                                  "commonMistakes": [
                                    "Esquecer 1j ou sinal errado em k.",
                                    "Não dealiasar, causando oscilações.",
                                    "Aplicar filtro muito agressivo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inverter para espaço físico e comparar com analítica",
                                  "subSteps": [
                                    "Compute df_num = ifft(hat_df).real (parte real devido a simetria).",
                                    "Compute derivada analítica: df_anal = 2*pi*cos(2*pi*x).",
                                    "Calcule erro: err = np.abs(df_num - df_anal); max(err) e RMS.",
                                    "Plote df_num, df_anal e erro vs x.",
                                    "Analise convergência variando N e reportando erros."
                                  ],
                                  "verification": "Erros <1e-10 para N=256; gráficos sobrepostos exceto ruído numérico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy, SciPy (ifft), Matplotlib"
                                  ],
                                  "tips": "Use .real para evitar imaginário numérico; teste com N maiores.",
                                  "learningObjective": "Avaliar precisão espectral e demonstrar convergência exponencial.",
                                  "commonMistakes": [
                                    "Esquecer .real após ifft.",
                                    "Comparar sem alinhar fases.",
                                    "Ignorar periodicidade no erro."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = sin(2πx) em [0,1] com N=256, FFT dá picos em k=±1. Derivada espectral: multiplicar por ±2πi, iFFT recupera 2π cos(2πx) com erro ~1e-13, demonstrando precisão machine epsilon.",
                              "finalVerifications": [
                                "Espectro FFT correto com Parseval satisfeito.",
                                "Derivada numérica sobreposta à analítica em plot.",
                                "Erro máximo <1e-10 e RMS <1e-12.",
                                "Dealiasing aplicado reduzindo alta frequência.",
                                "Convergência exponencial ao aumentar N.",
                                "Código reproduzível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação FFT/iFFT e operador diferencial.",
                                "Precisão numérica demonstrada quantitativamente.",
                                "Visualizações claras e análise de erros.",
                                "Tratamento adequado de periodicidade e dealiasing.",
                                "Relatório com interpretação física/matemática.",
                                "Eficiência computacional (tempo O(N log N))."
                              ],
                              "crossCurricularConnections": [
                                "Física: Derivação em equações de onda e Schrödinger.",
                                "Engenharia: Processamento de sinais e filtros digitais.",
                                "Computação: Algoritmos paralelizáveis e GPU-FFT.",
                                "Análise Numérica: Comparação com diferenças finitas."
                              ],
                              "realWorldApplication": "Métodos espectrais em simulações de turbulência (Navier-Stokes), previsão meteorológica e processamento de imagens médicas, onde precisão exponencial permite grids grossos e simulações em larga escala."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Resolver BVP simples com método pseudoespectral",
                            "description": "Formular e resolver numericamente um problema de valor de contorno de segunda ordem usando expansão em Fourier via FFT, impondo condições de contorno e avaliando erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o BVP periódico e discretizar o domínio",
                                  "subSteps": [
                                    "Selecione um BVP linear de segunda ordem com condições periódicas, como u''(x) = f(x) em [0, L] com u(0)=u(L) e u'(0)=u'(L).",
                                    "Defina f(x) e a solução exata u_exact(x) para validação, ex: f(x) = -(2π/L)^2 sin(2π x / L), u_exact(x) = sin(2π x / L).",
                                    "Escolha L=1 e N=512 (potência de 2) pontos de colocation equispaced: x_j = j * L / N para j=0 a N-1.",
                                    "Implemente o grid em código usando NumPy."
                                  ],
                                  "verification": "Verifique que x[0] == 0, x[-1] == 1 - eps (periódico), e len(x) == N.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Prefira N potência de 2 para otimizar FFT; evite N par se houver issues com Nyquist.",
                                  "learningObjective": "Compreender a discretização periódica essencial para bases de Fourier.",
                                  "commonMistakes": [
                                    "Usar condições Dirichlet em vez de periódicas",
                                    "Escolher N não potência de 2",
                                    "Definir grid incluindo ambos endpoints sem ajuste periódico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar f nos pontos e computar coeficientes Fourier via FFT",
                                  "subSteps": [
                                    "Calcule f_j = f(x_j) para todos j.",
                                    "Aplique FFT: hat_f = np.fft.fft(f_j) para obter coeficientes complexos hat_f_k.",
                                    "Identifique frequências k = np.fft.fftfreq(N, d=L/N).",
                                    "Verifique o modo zero: hat_f[0] deve ser a média de f."
                                  ],
                                  "verification": "Plote f_j vs x_j e confira hat_f[0] == np.mean(f_j).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy (fft module)",
                                    "Matplotlib para plot"
                                  ],
                                  "tips": "Use np.fft.fft para sinal real; normalize se necessário com 1/N na IFFT.",
                                  "learningObjective": "Dominar o uso da FFT para projeção no espaço de frequências.",
                                  "commonMistakes": [
                                    "Confundir fft com rfft",
                                    "Não associar corretamente k às posições do array",
                                    "Ignorar fator de escala na FFT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar operador diferencial espectral para obter hat_u_k",
                                  "subSteps": [
                                    "Para cada k ≠ 0, calcule hat_u_k = hat_f_k / (- (2π k / L)^2 ).",
                                    "Trate o modo k=0 separadamente: hat_u_0 = hat_f_0 / 0 é indefinido; assuma u média=0 se compatível.",
                                    "Copie hat_u_k para k negativos (hermitiano para real).",
                                    "Implemente loop ou vetorizado sobre frequências."
                                  ],
                                  "verification": "Confira que |hat_u_k| decai com |k|^2 no denominador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy arrays",
                                    "Conhecimento de frequências fftfreq"
                                  ],
                                  "tips": "Evite divisão por zero com if k != 0; para k=0 e Nyquist, defina hat_u=0 se f médio=0.",
                                  "learningObjective": "Aplicar multiplicação pontual no espaço espectral para resolver ODE.",
                                  "commonMistakes": [
                                    "Dividir por k^2 em vez de (2π k /L)^2",
                                    "Não tratar simetria hermitiana",
                                    "Esquecer modos negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconstruir solução via IFFT, verificar BCs e avaliar erro",
                                  "subSteps": [
                                    "Calcule u_j = np.real(np.fft.ifft(hat_u)) para obter solução numérica.",
                                    "Verifique condições periódicas: abs(u[0] - u[-1]) < 1e-10 e diff similar para derivada numérica.",
                                    "Compute erro: L2 = sqrt(mean((u_j - u_exact(x_j))^2 )).",
                                    "Plote u_num vs u_exact e erro vs N (teste múltiplos N)."
                                  ],
                                  "verification": "Erro L2 < 1e-6 para N=512 e converge com N.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy fft/ifft",
                                    "Matplotlib",
                                    "SciPy para u_exact"
                                  ],
                                  "tips": "Use np.real() pois IFFT tem pequena imag parte numérica.",
                                  "learningObjective": "Avaliar precisão espectral e convergência exponencial.",
                                  "commonMistakes": [
                                    "Esquecer np.real na IFFT",
                                    "Não verificar periodicidade",
                                    "Erro L2 sem normalizar por L"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva u''(x) = -(2π)^2 sin(2π x) em [0,1] com condições periódicas u(0)=u(1), u'(0)=u'(1). Solução exata: u(x)=sin(2π x). Use N=512, FFT para hat_f_k, hat_u_k = hat_f_k / (-(2π k)^2), IFFT para u_j. Erro esperado ~1e-10.",
                              "finalVerifications": [
                                "Solução periódica: |u[0] - u[-1]| < 1e-12 e |Du[0] - Du[-1]| < 1e-10 (Du derivada finita).",
                                "Norma L2 do erro < 1e-8 para N=512.",
                                "Convergência: erro reduz ~exponencialmente ao dobrar N.",
                                "Coeficientes hat_u_k decaem como 1/k^2.",
                                "Plot da solução sobrepõe perfeitamente à exata."
                              ],
                              "assessmentCriteria": [
                                "Correta discretização e uso de fftfreq/fftfreq.",
                                "Tratamento preciso do operador diferencial espectral sem divisão por zero.",
                                "Implementação correta de IFFT com extração da parte real.",
                                "Avaliação quantitativa de erro e verificação de BCs periódicas.",
                                "Código limpo, vetorizado e comentado.",
                                "Análise de convergência com múltiplos N."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução espectral de equações de onda e Helmholtz periódicas.",
                                "Ciência da Computação: Algoritmos FFT eficientes O(N log N).",
                                "Engenharia: Modelagem de fluxos em domínios periódicos (e.g., turbulência).",
                                "Processamento de Sinais: Análise harmônica de sinais periódicos."
                              ],
                              "realWorldApplication": "Simulações numéricas em dinâmica de fluidos (domínios periódicos como canais), mecânica quântica (partículas em caixa periódica), previsão de ondas em telecomunicações e processamento de imagens/sinais via spectral methods."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Métodos Pseudoespectrais",
                "description": "Introdução aos métodos pseudoespectrais para aproximação de soluções de equações diferenciais.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Bases Espectrais: Séries de Fourier e Polinômios de Chebyshev",
                    "description": "Introdução às bases ortogonais utilizadas nos métodos pseudoespectrais para expansão de funções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1.1",
                        "name": "Bases Ortogonais",
                        "description": "Conceito fundamental de bases ortogonais, que são conjuntos de funções mutuamente ortogonais com respeito a um produto interno, permitindo a expansão de funções em séries convergentes de forma eficiente nos métodos pseudoespectrais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1.1",
                            "name": "Definir produto interno e ortogonalidade",
                            "description": "Explicar o produto interno para funções contínuas e discretas, e demonstrar como duas funções são ortogonais quando seu produto interno é zero, com exemplos em espaços L2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Compreender o Produto Interno para Funções Contínuas em Espaços L2",
                                  "subSteps": [
                                    "Revise a definição formal do produto interno em L2[a,b]: <f,g> = ∫_a^b f(x)g(x) dx.",
                                    "Entenda a norma induzida: ||f|| = sqrt(<f,f>).",
                                    "Discuta propriedades: simetria, linearidade e positividade definida.",
                                    "Calcule exemplos simples, como <1, x> em [-1,1].",
                                    "Explore normalização para bases ortonormais."
                                  ],
                                  "verification": "Calcule corretamente o produto interno de duas funções polinomiais em um intervalo dado e verifique se é zero para funções pares/ímpares apropriadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Funcional ou notas de aula",
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy)",
                                    "Papel e lápis para integrais manuais"
                                  ],
                                  "tips": "Sempre especifique o intervalo de integração para evitar ambiguidades em L2.",
                                  "learningObjective": "Dominar a definição e cálculo do produto interno contínuo em espaços L2.",
                                  "commonMistakes": [
                                    "Esquecer o fator de normalização (ex: 1/sqrt(2π))",
                                    "Confundir com produto ponto vetorial sem integral",
                                    "Ignorar condições de convergência para funções não quadrado-integráveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Aplicar o Produto Interno para Funções Discretas",
                                  "subSteps": [
                                    "Defina o produto interno discreto: <f,g>_N = (1/N) ∑_{k=0}^{N-1} f_k g_k, para vetores discretos.",
                                    "Relacione com a versão contínua via amostragem (quadratura ou DFT).",
                                    "Calcule para sequências finitas, como vetores unitários.",
                                    "Compare com o contínuo usando aproximação de Riemann.",
                                    "Implemente em código simples para validação numérica."
                                  ],
                                  "verification": "Implemente e compute o produto interno discreto de dois vetores de 8 pontos e compare com o integral aproximado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Notas sobre DFT/FFT",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Use fator 1/N para convergência à medida que N→∞.",
                                  "learningObjective": "Entender e calcular produto interno discreto como aproximação do contínuo.",
                                  "commonMistakes": [
                                    "Omitir o fator 1/N levando a escalas erradas",
                                    "Confundir índices em somas",
                                    "Não alinhar pontos de amostragem corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender e Demonstrar Ortogonalidade via Produto Interno",
                                  "subSteps": [
                                    "Defina ortogonalidade: f ⊥ g iff <f,g> = 0.",
                                    "Explique ortonormalidade: ortogonais e ||f||=1 para todas.",
                                    "Discuta bases ortogonais: completude em L2 (ex: Fourier).",
                                    "Prove que funções ortogonais são linearmente independentes.",
                                    "Verifique propriedade em exemplos clássicos."
                                  ],
                                  "verification": "Mostre analiticamente que sin(nx) e cos(mx) são ortogonais em [-π,π] para n≠m.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabelas de integrais ortogonais",
                                    "Software Mathematica/MATLAB para verificação simbólica"
                                  ],
                                  "tips": "Lembre-se: zero produto interno implica 'ângulo 90 graus' no espaço funcional.",
                                  "learningObjective": "Definir ortogonalidade e provar via produto interno nulo.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com independência linear sem prova",
                                    "Usar intervalos errados alterando o resultado",
                                    "Ignorar constantes de normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos com Exemplos em Bases Espectrais (Fourier e Chebyshev)",
                                  "subSteps": [
                                    "Exemplo Fourier: Compute <sin(x), cos(2x)> em [-π,π].",
                                    "Exemplo Chebyshev: <T0(x), T1(x)> em [-1,1] com peso 1/sqrt(1-x^2).",
                                    "Demonstre expansão: coeficientes via produto interno.",
                                    "Numérico: Aproxime uma função com 4 termos e verifique erro L2.",
                                    "Discuta convergência espectral."
                                  ],
                                  "verification": "Expanda f(x)=x^2 em série de Chebyshev até T2 e compute resíduos ortogonais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Chebfun toolbox ou Python SciPy",
                                    "Tabelas de polinômios ortogonais",
                                    "Gráficos para visualização"
                                  ],
                                  "tips": "Use pesos adequados para Chebyshev (jacobiano).",
                                  "learningObjective": "Aplicar produto interno e ortogonalidade em bases espectrais reais.",
                                  "commonMistakes": [
                                    "Peso errado em integrais Chebyshev",
                                    "Intervalo inadequado para Fourier",
                                    "Arredondamento numérico em somas discretas"
                                  ]
                                }
                              ],
                              "practicalExample": "No método pseudoespectral, para resolver u'' + u = f em [-1,1], expanda u em base Chebyshev ortonormal: u_N = ∑ c_k T_k, onde c_k = <u_N, T_k> / ||T_k||^2. Ortogonalidade garante decoupling dos modos.",
                              "finalVerifications": [
                                "Defina precisamente produto interno contínuo e discreto.",
                                "Calcule <sin(πx), cos(πx)> em [0,1] e prove =0.",
                                "Explique por que bases Fourier são ortogonais em L2[-π,π].",
                                "Implemente discretamente e verifique erro <10^-6.",
                                "Discuta papel em projeções L2.",
                                "Forneça contraexemplo de funções não-ortogonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de produto interno (contínuo/discreto).",
                                "Correção em cálculos analíticos e numéricos de exemplos.",
                                "Clareza na explicação de ortogonalidade e suas implicações.",
                                "Uso apropriado de pesos e intervalos em bases específicas.",
                                "Capacidade de relacionar a métodos espectrais.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Física: Autofunções em mecânica quântica (ortogonalidade de estados).",
                                "Engenharia: Processamento de sinais digitais via DFT (produto interno discreto).",
                                "Computação Científica: Otimização em espaços de Hilbert.",
                                "Estatística: Coeficientes de correlação em funções aleatórias."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), bases ortogonais como Fourier/Chebyshev aceleram soluções PDEs via produto interno para coeficientes espectrais, reduzindo tempo computacional em ordens de magnitude."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.1.2",
                            "name": "Calcular normas e coeficientes de projeção",
                            "description": "Computar a norma de uma função em uma base ortogonal e derivar a fórmula para os coeficientes de expansão de uma função f em uma base {φ_k}, como c_k = <f, φ_k> / ||φ_k||^2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Bases Ortogonais e Produto Interno",
                                  "subSteps": [
                                    "Defina o produto interno <f, g> para funções em um intervalo dado, como ∫ f(x)g(x) w(x) dx.",
                                    "Explique o que significa uma base {φ_k} ser ortogonal: <φ_j, φ_k> = 0 para j ≠ k.",
                                    "Discuta a normalização: base ortonormal se <φ_k, φ_k> = 1.",
                                    "Identifique o peso w(x) comum em bases como Fourier (w=1) ou Chebyshev (w=1/√(1-x²)).",
                                    "Esboce exemplos simples de bases ortogonais, como senos e cossenos em Fourier."
                                  ],
                                  "verification": "Resuma em suas palavras a definição de ortogonalidade e dê um exemplo numérico simples de produto interno zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora, tabela de bases ortogonais (Fourier/Chebyshev).",
                                  "tips": "Use intervalos finitos como [-π, π] para Fourier para facilitar cálculos iniciais.",
                                  "learningObjective": "Compreender os fundamentos teóricos de ortogonalidade e produto interno em espaços funcionais.",
                                  "commonMistakes": "Confundir produto interno com integral simples sem peso; esquecer limites de integração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma de uma Função da Base φ_k",
                                  "subSteps": [
                                    "Lembre que a norma ||φ_k|| = √<φ_k, φ_k>.",
                                    "Compute <φ_k, φ_k> = ∫ φ_k(x)^2 w(x) dx sobre o intervalo apropriado.",
                                    "Resolva a integral analiticamente para bases conhecidas (ex: ||cos(kx)|| em Fourier).",
                                    "Calcule numericamente se necessário, usando quadratura ou software.",
                                    "Registre ||φ_k||^2 diretamente, pois é usado nos coeficientes."
                                  ],
                                  "verification": "Para φ_k(x) = cos(kx) em [-π, π], verifique se ||φ_k||^2 = π para k≥1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica ou software como Mathematica/MATLAB para integrais.",
                                  "tips": "Memorize normas padrão: Fourier cos(kx) tem || ||^2 = π; Chebyshev T_k tem fórmulas específicas.",
                                  "learningObjective": "Dominar o cálculo da norma L2 de funções base em contextos espectrais.",
                                  "commonMistakes": "Esquecer o fator √ no cálculo da norma; usar intervalos errados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Fórmula dos Coeficientes de Projeção c_k",
                                  "subSteps": [
                                    "Assuma expansão f(x) ≈ Σ c_k φ_k(x).",
                                    "Projete f sobre φ_j: <f, φ_j> = Σ c_k <φ_k, φ_j> = c_j <φ_j, φ_j> pela ortogonalidade.",
                                    "Derive c_j = <f, φ_j> / ||φ_j||^2.",
                                    "Prove por indução ou minimização de erro L2 que isso é o melhor coeficiente.",
                                    "Escreva a fórmula geral para qualquer base ortogonal {φ_k}."
                                  ],
                                  "verification": "Derive a fórmula passo a passo e aplique a um caso trivial f=φ_0 para obter c_0=1, outros zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e lápis para derivação algébrica.",
                                  "tips": "Pense geometricamente: c_k é a projeção escalar na direção φ_k.",
                                  "learningObjective": "Derivar analiticamente os coeficientes de Fourier/Chebyshev a partir de princípios ortogonais.",
                                  "commonMistakes": "Inverter a divisão (usar ||φ_k|| ao invés de ^2); ignorar ortogonalidade na soma."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Cálculo a uma Função f em Base Ortogonal",
                                  "subSteps": [
                                    "Escolha f(x) = x em [-1,1] com base Chebyshev T_k.",
                                    "Compute <f, T_k> = ∫_{-1}^1 x T_k(x) / √(1-x²) dx.",
                                    "Calcule ||T_k||^2 (π/2 para k≥1, π para k=0).",
                                    "Obtenha c_k = <f, T_k> / ||T_k||^2 para k=0 a 5.",
                                    "Reconstrua aproximação parcial Σ c_k T_k(x) e plote para visualização."
                                  ],
                                  "verification": "Verifique que os primeiros c_k coincidem com valores tabelados ou computados numericamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico (Python/NumPy, MATLAB) para integrais e plotting.",
                                  "tips": "Use simetria: funções pares/impares simplificam integrais em bases pares/impares.",
                                  "learningObjective": "Executar computação completa de normas e coeficientes para uma função real.",
                                  "commonMistakes": "Erro numérico em integrais oscilatórias; não normalizar corretamente."
                                }
                              ],
                              "practicalExample": "Para f(x) = sin(x) em [0, 2π] com base Fourier {1, cos(kx), sin(kx)}, compute ||sin(kx)||^2 = π, <f, sin(kx)> = ∫ sin(x) sin(kx) dx = π δ_{1k}, assim c_1 = 1 para sin(x), outros zero.",
                              "finalVerifications": [
                                "Calcula corretamente ||φ_k||^2 para 3 bases diferentes (Fourier, Chebyshev, Legendre).",
                                "Deriva c_k = <f, φ_k>/||φ_k||^2 sem erros algébricos.",
                                "Aplica a fórmula a f(x)=x^2 em [-1,1] com Chebyshev e obtém c_0, c_2 corretos.",
                                "Reconstrói f aproximada e verifica erro L2 < 1%.",
                                "Explica verbalmente o papel da ortogonalidade na derivação.",
                                "Identifica quando usar normalização vs. não-normalizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: integrais e normas exatas ou numéricas com erro <10^{-4}.",
                                "Completude da derivação: todos passos lógicos presentes.",
                                "Aplicação prática: código ou cálculos manuais funcionais.",
                                "Compreensão conceitual: explica projeção como minimizador de erro.",
                                "Eficiência: escolhe métodos adequados (analítico vs. numérico).",
                                "Visualização: gráficos de aproximação mostram convergência."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decomposição em modos normais de vibrações (equações de onda).",
                                "Engenharia: Análise de sinais em processamento digital (FFT).",
                                "Ciência da Computação: Algoritmos FFT para simulações numéricas rápidas.",
                                "Física Computacional: Solução de PDEs via métodos espectrais."
                              ],
                              "realWorldApplication": "Em simulações climáticas e fluidodinâmica, métodos pseudoespectrais usam coeficientes de Fourier/Chebyshev para resolver equações diferenciais parciais com alta precisão e eficiência computacional, como no modelo GFDL para previsão do tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.1.3",
                            "name": "Reconstruir funções via expansão ortogonal",
                            "description": "Dado uma função e seus coeficientes em uma base ortogonal, aproximar a função truncando a série infinita e analisar o erro de truncamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Expansão Ortogonal da Função",
                                  "subSteps": [
                                    "Identifique a base ortogonal específica (ex.: Fourier, Chebyshev) e o intervalo de definição da função.",
                                    "Escreva a fórmula da expansão infinita: f(x) = ∑_{k=0}^∞ c_k φ_k(x), onde φ_k são as funções base e c_k os coeficientes fornecidos.",
                                    "Verifique as propriedades ortogonais: ∫ φ_m(x) φ_n(x) w(x) dx = δ_{mn} para base ortonormal.",
                                    "Liste os primeiros coeficientes dados e associe-os às funções base correspondentes.",
                                    "Discuta a convergência da série sob as condições da função (suavidade, periodicidade)."
                                  ],
                                  "verification": "Escreva corretamente a expansão infinita com os coeficientes dados e justifique a ortogonalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Tabela de bases ortogonais (Fourier/Chebyshev)",
                                    "Software de plotagem como Desmos ou Python (opcional)"
                                  ],
                                  "tips": "Sempre normalize a base se necessário; use pesos w(x) para Chebyshev.",
                                  "learningObjective": "Dominar a representação teórica da função via série ortogonal infinita.",
                                  "commonMistakes": [
                                    "Ignorar o peso w(x) na integral de ortogonalidade",
                                    "Confundir coeficientes com funções base",
                                    "Assumir convergência sem verificar suavidade da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Aproximação Truncada",
                                  "subSteps": [
                                    "Escolha o grau de truncamento N (ex.: N=5, baseado em tolerância de erro desejada).",
                                    "Escreva a soma parcial: S_N(x) = ∑_{k=0}^N c_k φ_k(x).",
                                    "Expanda explicitamente os termos para os primeiros k, substituindo as funções φ_k(x).",
                                    "Simplifique a expressão algébrica de S_N(x) se possível.",
                                    "Avalie S_N(x) em pontos amostra (ex.: x=0, x=π/2) para verificação inicial."
                                  ],
                                  "verification": "Calcule S_N(x) em 3 pontos distintos e compare manualmente com valores esperados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy/Mathematica",
                                    "Lista de funções base explícitas",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Comece com N pequeno para visualizar; aumente gradualmente para observar convergência.",
                                  "learningObjective": "Construir e simplificar a aproximação finita da série ortogonal.",
                                  "commonMistakes": [
                                    "Erro de sinal nos coeficientes ao truncar",
                                    "Esquecer termos pares/impares simétricos",
                                    "Não truncar corretamente o índice superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Visualizar a Reconstrução Numérica",
                                  "subSteps": [
                                    "Gere uma grade de pontos x no intervalo (ex.: 100 pontos uniformes).",
                                    "Compute numericamente S_N(x) e f(x) em cada ponto usando código ou tabela.",
                                    "Plote f(x) vs S_N(x) para inspeção visual da aproximação.",
                                    "Calcule resíduos pontuais: e(x) = |f(x) - S_N(x)| em pontos críticos.",
                                    "Aumente N e replote para comparar aproximações de diferentes ordens."
                                  ],
                                  "verification": "Gere gráfico mostrando convergência visual e tabela de resíduos < 10^{-3} em 80% dos pontos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Função f(x) e coeficientes tabulados",
                                    "Grade de pontos pré-definida"
                                  ],
                                  "tips": "Use vetores para eficiência computacional; log-scale para erros pequenos.",
                                  "learningObjective": "Implementar computacionalmente a reconstrução e visualizar a qualidade da aproximação.",
                                  "commonMistakes": [
                                    "Overflow numérico em altas ordens",
                                    "Escala inadequada no plot",
                                    "Grid insuficiente perto de singularidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Erro de Truncamento",
                                  "subSteps": [
                                    "Defina métricas de erro: norma L^∞ (máximo), L^2 (∫ e(x)^2 dx).",
                                    "Compute erro para S_N e S_{N+1}; estime ||f - S_N|| via resíduo da série.",
                                    "Analise taxa de convergência (ex.: exponencial para funções analíticas).",
                                    "Discuta fontes de erro (truncamento vs arredondamento numérico).",
                                    "Recomende N ótimo baseado em tolerância (ex.: erro < 10^{-6})."
                                  ],
                                  "verification": "Relatório com erros quantificados e gráfico log-log de erro vs N mostrando convergência.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software numérico para integrais (quad em SciPy)",
                                    "Tabelas de erros para múltiplos N"
                                  ],
                                  "tips": "Use Parseval para erro L2: ||f - S_N||_2^2 = ∑_{k=N+1}^∞ |c_k|^2.",
                                  "learningObjective": "Quantificar e interpretar o erro de truncamento em expansões ortogonais.",
                                  "commonMistakes": [
                                    "Confundir erro absoluto com relativo",
                                    "Ignorar contribuição de cauda da série",
                                    "Não considerar Gibbs phenomenon em Fourier"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = cos(πx) em [-1,1] com base Chebyshev T_k(x): coeficientes dados c0=1.127, c1=0, c2=-0.18, c3=0, c4=0.016. Trunque em N=4: S4(x) = 1.127 T0 -0.18 T2 +0.016 T4. Plote e compute erro L∞ ≈ 0.005, analisando redução ao N=8.",
                              "finalVerifications": [
                                "S_N(x) reproduz f(x) com erro < 1% em norma L2.",
                                "Gráficos mostram convergência visual uniforme.",
                                "Erro de truncamento diminui monotonicamente com N.",
                                "Cálculo de Parseval confirma energia residual na cauda.",
                                "N ótimo identificado para precisão alvo.",
                                "Discussão de limitações (ex.: não-analyticidade) incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica e numérica dos cálculos (sem erros >10^{-4}).",
                                "Correta implementação de truncamento e avaliação em múltiplos N.",
                                "Análise quantitativa completa de erros com métricas apropriadas.",
                                "Visualizações claras e interpretativas.",
                                "Interpretação física/matemática da convergência.",
                                "Recomendações práticas para N baseadas em análise."
                              ],
                              "crossCurricularConnections": [
                                "Física: Expansões em autovalores para equações diferenciais (ex.: vibrações).",
                                "Engenharia: Processamento de sinais digitais via DFT/FFT.",
                                "Computação Científica: Métodos espectrais para PDEs.",
                                "Estatística: Análise de componentes principais (PCA) como ortogonalização."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluidodinâmica (CFD), reconstruir campos de velocidade/temperatura via séries de Chebyshev truncadas para resolver Navier-Stokes eficientemente, minimizando erro de truncamento em grids espectrais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.1.2",
                        "name": "Séries de Fourier",
                        "description": "Expansão de funções periódicas em séries trigonométricas usando cossenos e senos como base ortogonal no intervalo [0, 2π] ou [-π, π], fundamental para problemas periódicos em métodos pseudoespectrais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.2.1",
                            "name": "Derivar coeficientes de Fourier",
                            "description": "Calcular os coeficientes a_0, a_n e b_n para uma função periódica f(x) = a_0/2 + Σ (a_n cos(nx) + b_n sin(nx)), usando integrais de produto interno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o período e preparar a função periódica",
                                  "subSteps": [
                                    "Escreva explicitamente a função f(x) e seu domínio.",
                                    "Determine o período T = 2π (padrão para séries de Fourier com nx).",
                                    "Defina os limites de integração como [-π, π].",
                                    "Verifique a paridade da função (par, ímpar ou nem uma nem outra).",
                                    "Esboce graficamente f(x) no intervalo para visualização intuitiva."
                                  ],
                                  "verification": "Lista confirmada com período, limites, paridade e esboço anotados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Regra ou software de plotagem como Desmos ou GeoGebra"
                                  ],
                                  "tips": "Padronize sempre para período 2π ajustando a escala se necessário.",
                                  "learningObjective": "Preparar todos os parâmetros essenciais para os cálculos de integrais.",
                                  "commonMistakes": [
                                    "Usar limites errados como [0, 2π] sem ajuste",
                                    "Ignorar simetria par/ímpar que simplifica integrais",
                                    "Não esboçar a função levando a erros conceituais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o coeficiente a_0",
                                  "subSteps": [
                                    "Lembre a fórmula: a_0 = (1/π) ∫_{-π}^{π} f(x) dx.",
                                    "Compute a integral indefinida de f(x) ou use propriedades conhecidas.",
                                    "Avalie a integral nos limites [-π, π].",
                                    "Multiplique pelo fator 1/π e simplifique o resultado algébrico.",
                                    "Registre a_0/2 como o termo constante na série."
                                  ],
                                  "verification": "Valor numérico ou simbólico de a_0 calculado e verificado por substituição simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de integrais",
                                    "Calculadora simbólica como Wolfram Alpha opcional"
                                  ],
                                  "tips": "Para funções pares, integre 2 ∫_0^π f(x) dx; para ímpares, a_0 = 0.",
                                  "learningObjective": "Dominar o cálculo do termo médio da função periódica.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/π",
                                    "Erros nos limites de integração simétrica",
                                    "Não simplificar frações ou potências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os coeficientes a_n (n ≥ 1)",
                                  "subSteps": [
                                    "Lembre a fórmula: a_n = (1/π) ∫_{-π}^{π} f(x) cos(nx) dx para n = 1,2,...",
                                    "Escolha valores específicos de n (ex: 1,2,3) e compute a integral.",
                                    "Use simetria: zero para funções ímpares; 2/π ∫_0^π para pares.",
                                    "Resolva integrais por partes ou fórmulas conhecidas.",
                                    "Gere uma fórmula geral para a_n se possível e verifique para n pequeno."
                                  ],
                                  "verification": "a_1, a_2 e a_3 calculados corretamente e comparados com fórmula geral.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabelas de integrais trigonométricas",
                                    "Software como Mathematica para verificação"
                                  ],
                                  "tips": "Ortogonalidade garante a_n → 0 quando n grande; foque em simplificação.",
                                  "learningObjective": "Calcular componentes cosseno da decomposição harmônica.",
                                  "commonMistakes": [
                                    "Confundir cos(nx) com sin(nx)",
                                    "Erros em integração por partes (u,v errados)",
                                    "Ignorar fator 1/π"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os coeficientes b_n (n ≥ 1) e verificar",
                                  "subSteps": [
                                    "Lembre a fórmula: b_n = (1/π) ∫_{-π}^{π} f(x) sin(nx) dx para n = 1,2,...",
                                    "Compute para os mesmos n de a_n, usando simetria (zero para pares).",
                                    "Resolva integrais e simplifique.",
                                    "Compare todos os coeficientes com a função original plotando série parcial.",
                                    "Verifique se soma aproxima f(x) em pontos chave."
                                  ],
                                  "verification": "b_1, b_2 calculados; série parcial S_2(x) = a_0/2 + a_1 cos x + b_1 sin x + ... plota próxima a f(x).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfica ou Python/MATLAB para plotar série parcial"
                                  ],
                                  "tips": "Use expansão em série para prever comportamento assintótico.",
                                  "learningObjective": "Completar a série de Fourier e validar a representação.",
                                  "commonMistakes": [
                                    "Inverter fórmulas de a_n e b_n",
                                    "Não usar simetria para funções ímpares",
                                    "Erros de sinal em sin(nx)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x em [-π, π] (função ímpar): a_0 = 0, a_n = 0, b_n = 2 (-1)^{n+1} / n. Compute explicitamente para n=1: b_1 = (1/π) ∫_{-π}^π x sin(x) dx = 2.",
                              "finalVerifications": [
                                "a_0 calculado corretamente com fator 1/π.",
                                "a_n para n=1,2 corretos, considerando paridade.",
                                "b_n para n=1,2 corretos, considerando paridade.",
                                "Série parcial converge para f(x) em x=0 e x=π/2.",
                                "Fórmula geral identificada se aplicável.",
                                "Todos integrais resolvidos sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de produto interno (ortogonalidade).",
                                "Correto uso de propriedades de paridade para simplificação.",
                                "Resolução exata de integrais (por partes ou tabelas).",
                                "Simplificação algébrica completa dos coeficientes.",
                                "Validação gráfica ou numérica da série parcial.",
                                "Interpretação qualitativa da magnitude dos coeficientes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de vibrações e ondas harmônicas.",
                                "Engenharia: Processamento de sinais digitais (DSP).",
                                "Ciência da Computação: Implementação de FFT para dados rápidos.",
                                "Processamento de Imagens: Compressão via DCT (similar a Fourier)."
                              ],
                              "realWorldApplication": "Derivar coeficientes de Fourier permite decompor sinais periódicos complexos (como áudio, ECG ou vibrações mecânicas) em componentes simples, essencial para filtragem de ruído em telecomunicações, compressão de dados em MP3/JPEG e simulações numéricas em CFD (dinâmica de fluidos computacional)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2.2",
                            "name": "Aplicar teorema de convergência de Fourier",
                            "description": "Descrever as condições de Dirichlet para convergência pontual da série de Fourier e ilustrar com exemplos de funções com descontinuidades, como a função dente de serra.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Enunciar e compreender as condições de Dirichlet",
                                  "subSteps": [
                                    "Estude a definição formal das condições de Dirichlet (D1: função limitada; D2: número finito de máximos e mínimos; D3: número finito de descontinuidades em um período).",
                                    "Leia exemplos de funções que satisfazem e não satisfazem essas condições.",
                                    "Anote as condições em suas próprias palavras, destacando implicações para convergência pontual.",
                                    "Compare com teorema de convergência uniforme para séries de Fourier.",
                                    "Resolva exercícios simples de identificação de funções que atendem D1-D3."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando cada condição e forneça um exemplo para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Harmônica (ex: Folland ou Stein), caderno de anotações, calculadora.",
                                  "tips": "Use mnemônicos como 'DLM' (Dirichlet: Limitada, Máximos/Mínimos finitos, Descontinuidades finitas) para memorizar.",
                                  "learningObjective": "Dominar o enunciado preciso das condições de Dirichlet e sua relação com convergência pontual.",
                                  "commonMistakes": "Confundir descontinuidades finitas com infinitas (ex: funções patológicas como Weierstrass); ignorar periodicidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar convergência pontual para funções contínuas",
                                  "subSteps": [
                                    "Escolha uma função contínua periódica, como f(x) = cos(x) + sin(2x), e calcule seus coeficientes de Fourier.",
                                    "Demonstre que ela satisfaz todas as condições de Dirichlet.",
                                    "Mostre analiticamente que a soma da série converge para f(x) em todo ponto.",
                                    "Plote a soma parcial N=10 e N=50 para visualizar convergência rápida.",
                                    "Discuta o teorema: se Dirichlet satisfeita, então S_N(x) → f(x) para x não descontinuidade."
                                  ],
                                  "verification": "Produza um gráfico comparando f(x) e somas parciais, com erro máximo < 0.01 para N=20.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy e Matplotlib, ou MATLAB; tabela de integrais Fourier.",
                                  "tips": "Comece com funções trigonométricas conhecidas para validar cálculos manualmente.",
                                  "learningObjective": "Aplicar o teorema a funções suaves, confirmando convergência pontual.",
                                  "commonMistakes": "Erro no cálculo de coeficientes a_n/b_n; esquecer fator 1/π em integrais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar funções com descontinuidades e fenômeno de Gibbs",
                                  "subSteps": [
                                    "Estude funções piecewise contínuas que violam D2 ou D3 minimamente.",
                                    "Explique o overshoot de Gibbs próximo a descontinuidades (cerca de 9% do salto).",
                                    "Calcule numericamente somas parciais para uma função de salto, como f(x) = -1 para -π<x<0, +1 para 0<x<π.",
                                    "Compare convergência em pontos contínuos vs. descontinuos (média das laterais).",
                                    "Discuta limitações: convergência pontual, mas não uniforme perto de saltos."
                                  ],
                                  "verification": "Gere plots mostrando overshoot de Gibbs e confirme que erro diminui longe da descontinuidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB), referências sobre Gibbs (Wikipedia ou livro).",
                                  "tips": "Use N ímpares para simetria em funções pares/ímpares.",
                                  "learningObjective": "Compreender falhas na convergência perto de descontinuidades sob condições de Dirichlet.",
                                  "commonMistakes": "Acreditar em convergência uniforme global; confundir pontual com L2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com a função dente de serra",
                                  "subSteps": [
                                    "Defina f(x) = x para -π < x < π, estendida periodicamente.",
                                    "Calcule coeficientes: a_0=0, a_n=0, b_n = 2(-1)^{n+1}/n.",
                                    "Verifique condições de Dirichlet: satisfeitas (uma descontinuidade por período).",
                                    "Plote somas parciais S_N(x) para N=5,20,100, observando Gibbs no x=±π.",
                                    "Conclua: converge pontualmente para x em (-π,π), e para (f(π-)+f(-π+))/2 = 0 em x=π."
                                  ],
                                  "verification": "Submeta relatório com fórmulas, plots e análise de convergência em 3 pontos específicos.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Python (SymPy para coeficientes simbólicos, Matplotlib para plots), papel para esboços.",
                                  "tips": "Implemente função genérica para somar séries de Fourier para reutilizar.",
                                  "learningObjective": "Aplicar teorema completo à função dente de serra, ilustrando todos aspectos.",
                                  "commonMistakes": "Índice errado em b_n (esquecer (-1)^{n+1}); plotar sem normalizar período."
                                }
                              ],
                              "practicalExample": "Para a função dente de serra f(x) = x em (-π, π), calcule b_n = (2/π) ∫_0^π x sin(nx) dx = 2(-1)^{n+1}/n. Plote S_20(x) e observe convergência lenta perto de x=π, com overshoot de Gibbs, confirmando convergência pontual para f(x) interiormente.",
                              "finalVerifications": [
                                "Enunciar corretamente as três condições de Dirichlet sem erros.",
                                "Identificar se uma dada função periódica satisfaz Dirichlet.",
                                "Explicar o valor limite da série em pontos de descontinuidade finita.",
                                "Produzir plot de soma parcial para dente de serra mostrando Gibbs.",
                                "Calcular manualmente 5 coeficientes de uma função teste.",
                                "Discutir por que convergência é pontual, não uniforme."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no enunciado do teorema e condições (30%).",
                                "Qualidade de exemplos e ilustrações gráficas (25%).",
                                "Análise correta de convergência e limitações (20%).",
                                "Uso adequado de ferramentas computacionais (15%).",
                                "Clareza na explicação escrita (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decomposição de ondas periódicas em harmônicos sonoros.",
                                "Engenharia de Sinais: Análise espectral e filtros em processamento digital.",
                                "Computação: Implementação eficiente via FFT para dados reais.",
                                "Análise Numérica: Estudo de erros de truncamento em métodos espectrais."
                              ],
                              "realWorldApplication": "No processamento de sinais de áudio e imagens, as séries de Fourier são usadas para compressão (JPEG/MP3), mas o teorema de convergência guia o tratamento de descontinuidades em bordas de imagens ou transientes acústicos, evitando artefatos como ringing via filtros adequados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2.3",
                            "name": "Implementar aproximação espectral via FFT",
                            "description": "Usar a Transformada Rápida de Fourier (FFT) para computar coeficientes e reconstruir funções periódicas discretizadas em N pontos uniformes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e discretizar a função periódica",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: numpy e matplotlib via pip.",
                                    "Defina N pontos uniformes no intervalo [0, 2π).",
                                    "Escolha e implemente uma função periódica de teste, como f(x) = cos(x) + 0.5*sin(3x).",
                                    "Gere o array de valores y = f(x) discretizados.",
                                    "Visualize o sinal original com plot."
                                  ],
                                  "verification": "Array y tem shape (N,) e plot mostra a função corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use np.linspace(0, 2*np.pi, N, endpoint=False) para pontos periódicos.",
                                  "learningObjective": "Entender discretização uniforme e preparação de dados para FFT.",
                                  "commonMistakes": [
                                    "Incluir endpoint=True causando duplicação",
                                    "Escolher N não potência de 2 (embora FFT funcione)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar coeficientes espectrais via FFT",
                                  "subSteps": [
                                    "Importe np.fft.fft e aplique aos dados y: coeffs = np.fft.fft(y).",
                                    "Normalize os coeficientes: coeffs /= N.",
                                    "Extraia magnitudes e fases: mag = np.abs(coeffs), phase = np.angle(coeffs).",
                                    "Plote o espectro de frequências (magnitude vs. k).",
                                    "Identifique os modos dominantes (picos no espectro)."
                                  ],
                                  "verification": "Coeficientes têm shape (N,) e espectro mostra picos esperados para a função.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy FFT module"
                                  ],
                                  "tips": "Use np.fft.fftfreq(N, d=2*np.pi/N) para eixos de frequência corretos.",
                                  "learningObjective": "Dominar o uso da FFT para obter coeficientes de Fourier discretos.",
                                  "commonMistakes": [
                                    "Esquecer normalização por N",
                                    "Interpretar coeffs reais/imaginários sem fase"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir a função usando coeficientes espectrais",
                                  "subSteps": [
                                    "Aplique IFFT: y_recon = np.fft.ifft(coeffs).real.",
                                    "Alternativamente, implemente soma manual: soma c_k * exp(2πi k n / N).",
                                    "Trunque coeficientes de alta frequência (ex: zero além de K max).",
                                    "Plote y original vs. y_recon.",
                                    "Calcule erro: np.linalg.norm(y - y_recon)/np.linalg.norm(y)."
                                  ],
                                  "verification": "Erro de reconstrução < 1e-10 para N=256 sem truncamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy FFT e linalg"
                                  ],
                                  "tips": "Use .real para remover ruído numérico imaginário mínimo.",
                                  "learningObjective": "Implementar reconstrução espectral e demonstrar precisão da FFT.",
                                  "commonMistakes": [
                                    "Não truncar para aliasing",
                                    "Ignorar parte imaginária residual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e otimizar a aproximação espectral",
                                  "subSteps": [
                                    "Teste com diferentes N (64, 128, 512) e compare erros.",
                                    "Aplique filtro low-pass truncando coeffs altos.",
                                    "Analise fenômeno de Gibbs com função descontínua (ex: square wave).",
                                    "Meça taxa de convergência (erro vs. log N).",
                                    "Documente observações em relatório curto."
                                  ],
                                  "verification": "Gráficos mostram convergência e relatório explica resultados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matplotlib para múltiplos plots"
                                  ],
                                  "tips": "Para square wave: use scipy.signal.square para teste.",
                                  "learningObjective": "Avaliar limitações e otimização de métodos espectrais.",
                                  "commonMistakes": [
                                    "N muito pequeno mascarando erros",
                                    "Não normalizar erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Discretize f(x) = exp(sin(x)) em N=256 pontos, compute FFT para obter ~10 coeficientes dominantes, reconstrua truncando o resto e verifique erro L2 < 1e-3, simulando compressão espectral.",
                              "finalVerifications": [
                                "Código completo roda sem erros para N=512.",
                                "Reconstrução visualmente indistinguível do original.",
                                "Erro relativo L2 < 1e-12 sem truncamento.",
                                "Espectro identifica corretamente frequências dominantes.",
                                "Teste com função descontínua mostra overshoot de Gibbs.",
                                "Convergência exponencial confirmada variando N."
                              ],
                              "assessmentCriteria": [
                                "Correta discretização periódica e normalização FFT.",
                                "Implementação precisa de forward/inverse FFT.",
                                "Análise quantitativa de erros e convergência.",
                                "Visualizações claras comparando original e aproximada.",
                                "Tratamento de truncamento e filtros espectrais.",
                                "Explicação de artefatos numéricos como Gibbs."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais em Engenharia Elétrica.",
                                "Simulações Numéricas em Física Computacional.",
                                "Análise de Dados em Ciência de Dados (feature extraction).",
                                "Compressão de Sinais em Telecomunicações."
                              ],
                              "realWorldApplication": "Usado em modelagem de ondas oceânicas para previsão climática, análise de espectros em MRI médica, compressão de áudio em streaming, e simulações turbulentas em aerodinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.1.3",
                        "name": "Polinômios de Chebyshev",
                        "description": "Polinômios ortogonais T_n(x) no intervalo [-1,1] com peso (1-x^2)^{-1/2}, ideais para aproximações espectrais de funções não-periódicas em domínios finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.3.1",
                            "name": "Definir e gerar polinômios de Chebyshev",
                            "description": "Apresentar a definição T_0(x)=1, T_1(x)=x, T_{n+1}(x)=2x T_n(x) - T_{n-1}(x) e gerar os primeiros polinômios explicitamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar as Definições Iniciais dos Polinômios de Chebyshev",
                                  "subSteps": [
                                    "Leia e copie a definição T_0(x) = 1 cinco vezes em um papel.",
                                    "Leia e copie a definição T_1(x) = x cinco vezes ao lado da T_0.",
                                    "Explique em suas próprias palavras o que essas funções representam como base para a sequência.",
                                    "Desenhe um gráfico simples de T_0(x) e T_1(x) no intervalo [-1,1].",
                                    "Recite as definições de memória sem olhar para o papel."
                                  ],
                                  "verification": "Recitar corretamente T_0 e T_1 três vezes seguidas sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica opcional"
                                  ],
                                  "tips": "Associe T_0 a uma constante plana e T_1 à identidade linear para fixar na memória.",
                                  "learningObjective": "Dominar as condições iniciais da recursão de Chebyshev.",
                                  "commonMistakes": [
                                    "Confundir T_0 com 0",
                                    "Esquecer que T_1 é simplesmente x"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender e Aplicar a Relação Recursiva",
                                  "subSteps": [
                                    "Escreva a fórmula recursiva T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x) três vezes.",
                                    "Explique verbalmente ou por escrito o que cada termo representa na recursão.",
                                    "Substitua n=1 na fórmula usando T_0 e T_1 para derivar T_2(x) manualmente.",
                                    "Verifique o cálculo de T_2(x) = 2x^2 - 1 comparando com fontes confiáveis.",
                                    "Repita o processo para confirmar T_2 com um valor numérico, ex: x=0."
                                  ],
                                  "verification": "Derivar T_2(x) corretamente em menos de 2 minutos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de referência em análise numérica"
                                  ],
                                  "tips": "Pense na recursão como uma 'regra de três termos' similar à recursão de Fibonacci.",
                                  "learningObjective": "Entender mecanicamente a geração recursiva de polinômios.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 em 2x",
                                    "Inverter T_n e T_{n-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar os Próximos Polinômios: T_3(x) e T_4(x)",
                                  "subSteps": [
                                    "Use T_1 e T_2 para calcular T_3(x) = 2x T_2(x) - T_1(x).",
                                    "Expanda e simplifique T_3(x) = 4x^3 - 3x.",
                                    "Use T_2 e T_3 para calcular T_4(x) = 2x T_3(x) - T_2(x).",
                                    "Expanda e simplifique T_4(x) = 8x^4 - 8x^2 + 1.",
                                    "Tabule todos os polinômios de T_0 a T_4 em uma tabela organizada."
                                  ],
                                  "verification": "Listar explicitamente T_0 a T_4 sem consultar anotações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para expansão polinomial"
                                  ],
                                  "tips": "Mantenha os polinômios na forma monomial padrão (coeficientes crescentes).",
                                  "learningObjective": "Gerar polinômios de Chebyshev até grau 4 com precisão.",
                                  "commonMistakes": [
                                    "Erros de sinal nos coeficientes",
                                    "Não simplificar termos semelhantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Estender a Geração para T_5(x)",
                                  "subSteps": [
                                    "Calcule T_5(x) = 2x T_4(x) - T_3(x) e simplifique para 16x^5 - 20x^3 + 5x.",
                                    "Avalie todos os polinômios em x=1 e x=0 para verificar consistência (T_n(1)=1).",
                                    "Compare sua tabela com uma implementação simples em Python ou tabela padrão.",
                                    "Escreva um resumo das expressões explícitas de T_0 a T_5.",
                                    "Desafie-se gerando T_6(x) independentemente."
                                  ],
                                  "verification": "Gerar T_5(x) e verificar T_n(1)=1 para n=0 a 5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel",
                                    "Editor de texto ou Python IDE opcional"
                                  ],
                                  "tips": "Propriedade chave: T_n(1) = 1 para todos n; use para validação rápida.",
                                  "learningObjective": "Consolidar a geração recursiva e validação.",
                                  "commonMistakes": [
                                    "Perder track dos graus",
                                    "Erros aritméticos em expansões altas"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule os polinômios de Chebyshev até T_4(x) e use T_2(x) = 2x^2 - 1 para aproximar cos(2θ) onde x = cos(θ), verificando numericamente para θ = π/4.",
                              "finalVerifications": [
                                "Recitar definições de T_0, T_1 e recursão sem hesitação.",
                                "Gerar T_2 a T_5 explicitamente em menos de 5 minutos.",
                                "Avaliar corretamente T_n(1) = 1 e T_n(0) alternando ±1 para n par/ímpar.",
                                "Explicar a recursão para um colega ou gravar áudio.",
                                "Listar os cinco primeiros polinômios sem erros de coeficiente."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos coeficientes dos polinômios gerados.",
                                "Tempo de geração de T_3 a T_5 inferior a 3 minutos.",
                                "Correta simplificação e forma padrão dos polinômios.",
                                "Validação numérica em pelo menos dois pontos por polinômio.",
                                "Clareza na tabela ou lista final de polinômios."
                              ],
                              "crossCurricularConnections": [
                                "Física: Relação com funções cos(nθ) em oscilações harmônicas.",
                                "Programação: Implementação recursiva ou iterativa em Python/MATLAB.",
                                "Engenharia: Bases para métodos de elementos finitos e aproximações.",
                                "Análise: Conexão com séries de Fourier em intervalos [-1,1]."
                              ],
                              "realWorldApplication": "Polinômios de Chebyshev são fundamentais em métodos pseudoespectrais para resolver equações diferenciais parciais em simulações de dinâmica de fluidos computacional (CFD), otimização e aproximação de funções com convergência rápida."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3.2",
                            "name": "Computar coeficientes Chebyshev",
                            "description": "Calcular coeficientes c_n = (2/π) ∫_{-1}^1 f(x) T_n(x) / sqrt(1-x^2) dx para expansão f(x) ≈ Σ c_n T_n(x), e usar quadratura de Gauss-Lobatto para aproximação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os polinômios de Chebyshev e a fórmula dos coeficientes",
                                  "subSteps": [
                                    "Estudar a definição recursiva dos polinômios de Chebyshev Tn(x): T0=1, T1=x, Tn+1 = 2x Tn - Tn-1",
                                    "Analisar a ortogonalidade com peso 1/sqrt(1-x²) no intervalo [-1,1]",
                                    "Derivar a fórmula do coeficiente cn = (2/π) ∫_{-1}^1 f(x) Tn(x) / sqrt(1-x²) dx",
                                    "Verificar para funções simples como f(x)=1 (c0=1, cn=0 para n>0)",
                                    "Explorar propriedades de convergência da série f(x) ≈ Σ cn Tn(x)"
                                  ],
                                  "verification": "Explicar a derivação da fórmula e calcular c0 para f(x)=1 manualmente",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre métodos pseudoespectrais",
                                    "Tabela de polinômios Chebyshev até T5",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Desenhe os primeiros Tn(x) para visualizar oscilações mínimas",
                                  "learningObjective": "Dominar a base teórica para computação de coeficientes",
                                  "commonMistakes": [
                                    "Confundir Tn(x) com polinômios de Legendre",
                                    "Esquecer o fator 2/π",
                                    "Ignorar o peso 1/sqrt(1-x²)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular coeficientes analiticamente para funções simples",
                                  "subSteps": [
                                    "Escolher f(x) = x² e expandir Tn(x) para n=0,1,2",
                                    "Computar integrais exatas usando propriedades conhecidas ou integração por partes",
                                    "Verificar que a soma Σ cn Tn(x) reconstrói f(x) em pontos de Lobatto",
                                    "Testar f(x) = sin(πx/2) e comparar com série conhecida",
                                    "Documentar os cn obtidos em uma tabela"
                                  ],
                                  "verification": "Reconstruir f(x) em 5 pontos e comparar com valor exato (erro < 10^{-6})",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para cálculos",
                                    "Software Mathematica ou SymPy para integrais simbólicas",
                                    "Planilha para tabulação"
                                  ],
                                  "tips": "Use recursão para gerar Tn(x) evitando expansão manual longa",
                                  "learningObjective": "Aplicar a fórmula teórica em casos analíticos",
                                  "commonMistakes": [
                                    "Erro em limites de integração",
                                    "Confundir índices n",
                                    "Não normalizar corretamente c0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a quadratura de Gauss-Lobatto para aproximação numérica",
                                  "subSteps": [
                                    "Estudar nós de Lobatto: xk = cos(π k / N), k=0..N, com pesos wk proporcionais",
                                    "Derivar a aproximação ∫ g(x) dx ≈ Σ wk g(xk)",
                                    "Implementar geração de nós e pesos para N=8,16",
                                    "Testar precisão em integrais conhecidas como ∫_{-1}^1 1/sqrt(1-x²) dx = π",
                                    "Analisar convergência com N crescente"
                                  ],
                                  "verification": "Aproximar π com erro < 10^{-10} para N=20",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB para nós Lobatto",
                                    "Documentação NumPy/Scipy quadrature",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Use fórmula fechada para pesos: w0 = wN = 2/(N(N-1)), wk=4/(N(N-1)) sen²(πk/N) para k=1..N-1",
                                  "learningObjective": "Entender por que Gauss-Lobatto é ideal para pesos Chebyshev",
                                  "commonMistakes": [
                                    "Nós errados (use cos em vez de linspace)",
                                    "Pesos uniformes",
                                    "Esquecer sqrt no peso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar computação numérica dos coeficientes Chebyshev",
                                  "subSteps": [
                                    "Definir f(x) numéricamente (ex: f(x)=exp(x)) em nós Lobatto",
                                    "Calcular cn ≈ (2/π) Σ wk f(xk) Tn(xk) / sqrt(1-xk²) para n=0..N",
                                    "Codificar função recursiva para Tn(xk)",
                                    "Plotar coeficientes cn vs n para observar decaimento",
                                    "Reconstruir aproximação Σ cn Tn(x) em malha fina e calcular erro L2"
                                  ],
                                  "verification": "Erro de reconstrução < 10^{-8} para N=32 em f suave",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Jupyter Notebook",
                                    "Funções teste: exp(x), sin(3x)"
                                  ],
                                  "tips": "Vetorize computações com arrays para eficiência; limite n até N/2 para precisão",
                                  "learningObjective": "Desenvolver algoritmo numérico completo e eficiente",
                                  "commonMistakes": [
                                    "Divisão por zero em sqrt(1-x²) nos nós (mas Lobatto evita)",
                                    "Índices off-by-one em soma",
                                    "Não truncar série além de N"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e otimizar a aproximação espectral",
                                  "subSteps": [
                                    "Calcular erro em norma L∞ e L2 entre f e aproximação",
                                    "Analisar aliasing e truncamento para funções não suaves",
                                    "Otimizar código para N grande (até 256)",
                                    "Comparar com FFT para série de Fourier em círculo",
                                    "Documentar relatório com gráficos de erro vs N"
                                  ],
                                  "verification": "Relatório com plots mostrando convergência exponencial para f suave",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código do passo 4 estendido",
                                    "Ferramentas de profiling (timeit)",
                                    "Referências sobre erro espectral"
                                  ],
                                  "tips": "Use log-log plot para erro vs N para ver taxa espectral",
                                  "learningObjective": "Avaliar qualidade da expansão e diagnosticar problemas",
                                  "commonMistakes": [
                                    "Métrica de erro errada",
                                    "Não normalizar Tn corretamente",
                                    "Ignorar Gibbs para descontinuidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = e^x no [-1,1], compute cn até n=20 usando N=32 nós Lobatto. Reconstrua fapprox(x) = Σ cn Tn(x) e plote f(x) vs fapprox(x), observando erro máximo < 10^{-12}.",
                              "finalVerifications": [
                                "Cálculo exato de c0=1 para f(x)=1",
                                "Decaimento rápido de |cn| para f suave (exponencial)",
                                "Reconstrução exata nos nós Lobatto",
                                "Erro L2 < 10^{-10} para N=64 em f(x)=sin(πx)",
                                "Código roda em <1s para N=128",
                                "Comparação com biblioteca Scipy.special.cheb-fit"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 10^{-10} em testes padrão",
                                "Eficiência: tempo O(N^2) otimizado para vetorização",
                                "Correção teórica: fórmula e pesos Lobatto implementados corretamente",
                                "Robustez: funciona para N par/impar e funções variadas",
                                "Documentação: código comentado com exemplos",
                                "Análise: gráficos de convergência incluídos"
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de PDEs elípticas via métodos espectrais (ex: Navier-Stokes)",
                                "Computação: Algoritmos numéricos e fast Chebyshev transforms (FFCT)",
                                "Engenharia: Aproximação de funções em controle e processamento de sinais",
                                "Estatística: Regressão não linear via bases ortogonais"
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), coeficientes Chebyshev aceleram solução de equações diferenciais com precisão espectral; em machine learning, para aproximação de funções de ativação em redes neurais profundas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3.3",
                            "name": "Usar pontos de Chebyshev-Lobatto",
                            "description": "Definir pontos x_k = cos(π k / N) para k=0..N e explicar sua aplicação na interpolação espectral e na discretização pseudoespectral para derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Definir os Pontos de Chebyshev-Lobatto",
                                  "subSteps": [
                                    "Revise os polinômios de Chebyshev de segunda espécie ou os nós de Gauss-Lobatto associados.",
                                    "Memorize a fórmula x_k = cos(π k / N) para k = 0, 1, ..., N.",
                                    "Compute manualmente os pontos para N pequeno, como N=2 e N=4.",
                                    "Plote os pontos no intervalo [-1,1] para visualizar sua distribuição (mais densos nas extremidades).",
                                    "Compare com pontos equidistantes para notar as diferenças."
                                  ],
                                  "verification": "Liste corretamente os pontos para N=4 e descreva sua distribuição em uma frase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis; software de plotagem como Python (matplotlib) ou MATLAB.",
                                  "tips": "Sempre normalize para o intervalo [-1,1]; use ângulos para facilitar cálculos trigonométricos.",
                                  "learningObjective": "Definir precisamente os pontos de Chebyshev-Lobatto e computá-los.",
                                  "commonMistakes": "Confundir com pontos de Chebyshev-Gauss (sem extremidades); errar o índice k de 0 a N."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades e Justificativa Matemática",
                                  "subSteps": [
                                    "Estude as propriedades: incluem ±1, ideais para condições de contorno Dirichlet.",
                                    "Derive brevemente por que eles minimizam o erro de interpolação (nós de Lebesgue).",
                                    "Discuta a ortogonalidade com pesos δ_k (1 para internos, 2 para extremidades).",
                                    "Calcule pesos de quadratura associados: w_k = (π/N) * (1 - δ_{k0} δ_{kN}/2).",
                                    "Compare estabilidade numérica com outros nós em Runge's phenomenon."
                                  ],
                                  "verification": "Explique em 2-3 frases por que esses pontos são preferidos em métodos espectrais.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de análise numérica (ex: Trefethen 'Spectral Methods'); calculadora ou Python.",
                                  "tips": "Lembre-se: densidade maior nas bordas reduz oscilações de Gibbs.",
                                  "learningObjective": "Compreender as propriedades matemáticas que justificam seu uso.",
                                  "commonMistakes": "Ignorar os pesos de quadratura; achar que são apenas 'pontos equidistantes em cos(θ)' sem contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em Interpolação Espectral",
                                  "subSteps": [
                                    "Construa o polinômio interpolante P_N(f) = ∑ f(x_k) l_k(x), onde l_k são base de Lagrange.",
                                    "Implemente em código a avaliação em pontos de Chebyshev-Lobatto.",
                                    "Teste interpolação de funções suaves como sin(x) ou exp(x) no [-1,1].",
                                    "Meça o erro de interpolação ||f - P_N|| para N crescente.",
                                    "Visualize o polinômio interpolante vs. função original."
                                  ],
                                  "verification": "Gere código que interpola uma função com erro <1e-10 para N=16.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy/SciPy ou MATLAB; Jupyter notebook.",
                                  "tips": "Use FFT para avaliação rápida em pontos espectrais; evite loops para eficiência.",
                                  "learningObjective": "Implementar interpolação espectral usando esses pontos.",
                                  "commonMistakes": "Usar base errada (não Lagrange); não mapear para domínio físico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discretização Pseudoespectral para Derivadas",
                                  "subSteps": [
                                    "Construa a matriz de diferenciação D: D_{jk} = l_k'(x_j).",
                                    "Compute analiticamente D para N baixo (ex: N=3) e verifique.",
                                    "Implemente D via diferenciação de Lagrange ou FFT (para Chebyshev).",
                                    "Aplique a u' ≈ D u para u nos pontos x_k; teste com u(x)=sin(πx).",
                                    "Analise precisão espectral (erro O(1/N^p) para suaves)."
                                  ],
                                  "verification": "Derive a derivada de uma função conhecida com erro relativo <1e-8.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código Python/MATLAB; referências como Canuto 'Spectral Methods'.",
                                  "tips": "Para derivadas altas, use relações de recorrência de Chebyshev.",
                                  "learningObjective": "Usar pontos para aproximar derivadas em métodos pseudoespectrais.",
                                  "commonMistakes": "Esquecer condições de contorno; instabilidade para N grande sem preconditioning."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração e Exemplo Completo",
                                  "subSteps": [
                                    "Resolva um problema modelo: ED2 u'' + u = f com BCs Dirichlet usando pseudoespectral.",
                                    "Monte o sistema (D^2 + I) u = f; resolva linearmente.",
                                    "Valide solução contra analítica.",
                                    "Estenda para 2D ou tempo-dependente brevemente.",
                                    "Documente o workflow completo."
                                  ],
                                  "verification": "Resolva um BVP com erro L2 <1e-6.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código anterior; solver linear (numpy.linalg.solve).",
                                  "tips": "Sempre cheque simetria/anti-simétrica de D para pares ímpares/par.",
                                  "learningObjective": "Aplicar integralmente em um problema de valor de contorno.",
                                  "commonMistakes": "Não impor BCs corretamente; overflow numérico em N>100."
                                }
                              ],
                              "practicalExample": "Para N=4, pontos x = [1, cos(π/4)=0.707, cos(2π/4)=0, cos(3π/4)=-0.707, -1]. Interpole f(x)=exp(x): avalie em x_k, construa P_4, derive P_4' via D, compare com f'(x_k). Erro deve ser ~1e-12.",
                              "finalVerifications": [
                                "Computa corretamente x_k para N=6 e plota.",
                                "Explica aplicação em interpolação e derivadas em <100 palavras.",
                                "Implementa código funcional para interpolação e D com teste passado.",
                                "Identifica 3 vantagens sobre FD/FV.",
                                "Resolve BVP simples com precisão espectral.",
                                "Discute limitações (apenas funções suaves)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmula (100%).",
                                "Correção matemática das propriedades e derivações (90%).",
                                "Funcionalidade e eficiência do código (85%).",
                                "Profundidade na explicação de aplicações (80%).",
                                "Criatividade no exemplo prático e verificações (75%).",
                                "Clareza na documentação e visualizações (70%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de PDEs em fluidos (Navier-Stokes).",
                                "Engenharia: Otimização aeroespacial (perfis de asas).",
                                "Ciência de Dados: Aproximação de séries temporais suaves.",
                                "Processamento de Sinais: Filtros espectrais em áudio/imagem."
                              ],
                              "realWorldApplication": "Usados em solvers CFD como Nekton/Spectral Element Method para previsão climática, turbulência e simulações acústicas de alta precisão em aviões e turbinas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3.4",
                            "name": "Comparar convergência Fourier vs Chebyshev",
                            "description": "Analisar exponencialmente rápida convergência para funções analíticas e comparar o fenômeno de Gibbs em Fourier com aliasing em Chebyshev para funções suaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Séries de Fourier e Expansões em Chebyshev",
                                  "subSteps": [
                                    "Estude a definição de coeficientes de Fourier para uma função periódica em [-π, π].",
                                    "Revise a expansão em série de Fourier e sua forma truncada com N termos.",
                                    "Aprenda os polinômios de Chebyshev Tn(x) definidos em [-1,1] e sua representação via projeção L2.",
                                    "Entenda a discretização pseudoespectral usando pontos de Gauss-Lobatto para Chebyshev.",
                                    "Compare os intervalos de definição: periódico para Fourier vs apériódico para Chebyshev."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças fundamentais entre as bases Fourier e Chebyshev.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro 'Spectral Methods in MATLAB' de Trefethen; notebook Jupyter com NumPy/SciPy.",
                                  "tips": "Use visualizações de plots para os primeiros polinômios de cada base.",
                                  "learningObjective": "Compreender as bases matemáticas e domínios de aplicação de cada método.",
                                  "commonMistakes": "Confundir o intervalo [-π,π] de Fourier com [-1,1] de Chebyshev sem mapeamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Convergência Exponencialmente Rápida para Funções Analíticas",
                                  "subSteps": [
                                    "Defina função analítica e prove que coeficientes de Fourier decaem como O(e^{-k}) para k→∞.",
                                    "Mostre que para Chebyshev, os coeficientes decaem similarmente para funções analíticas em um disco/eliptico.",
                                    "Implemente numéricamente a aproximação de e^x em [-π,π] com ambos os métodos.",
                                    "Plote o erro L∞ vs número de modos N para N=8,16,32,64.",
                                    "Observe a taxa exponencial: log(erros) linear em log(N)."
                                  ],
                                  "verification": "Gere plots mostrando convergência exponencial similar para ambos em função analítica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com Matplotlib/NumPy; código exemplo de spectral methods.",
                                  "tips": "Use transformação afim para mapear intervalos se necessário.",
                                  "learningObjective": "Identificar e quantificar a convergência exponencial comum a ambas as bases.",
                                  "commonMistakes": "Ignorar normalização dos coeficientes, levando a erros de escala."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o Fenômeno de Gibbs em Séries de Fourier",
                                  "subSteps": [
                                    "Escolha uma função descontínua como sign(x) em [-π,π] e compute série de Fourier truncada.",
                                    "Observe overshoots perto das descontinuidades (∼9% do salto).",
                                    "Plote para N=32,64,128 e note que overshoots persistem independentemente de N.",
                                    "Explique matematicamente via somas de Dirichlet.",
                                    "Compare com funções suaves mas não analíticas, como |x|."
                                  ],
                                  "verification": "Identifique e meça o overshoot de Gibbs em plot para função com jump.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Jupyter notebook; função teste f(x) = sign(sin(x)).",
                                  "tips": "Aumente N gradualmente para ver persistência do fenômeno.",
                                  "learningObjective": "Reconhecer o ringing de Gibbs como limitação de Fourier para não-smooth functions.",
                                  "commonMistakes": "Atribuir Gibbs a truncamento finito em vez de propriedade assintótica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Aliasing em Expansões de Chebyshev para Funções Suaves",
                                  "subSteps": [
                                    "Aplique expansão Chebyshev a uma função suave mas com gradiente acentuado, como tanh(20x) em [-1,1].",
                                    "Use interpolação em pontos Chebyshev-Lobatto e plote aproximação truncada.",
                                    "Observe oscilações de alta frequência (aliasing) perto de regiões de alta curvatura.",
                                    "Compare Runge phenomenon em extremos vs aliasing interno.",
                                    "Analise Runge test function 1/(1+25x²) para ver ambos os efeitos."
                                  ],
                                  "verification": "Produza plots destacando aliasing em Chebyshev para tanh(20x).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Chebfun toolbox ou SciPy cheb-fit; plots de erro.",
                                  "tips": "Filtre modos altos para mitigar aliasing e observe melhora.",
                                  "learningObjective": "Diferenciar aliasing de Chebyshev de Gibbs de Fourier.",
                                  "commonMistakes": "Confundir aliasing com Gibbs; ambos são overshoots mas em contextos diferentes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Sintetizar Convergência Fourier vs Chebyshev",
                                  "subSteps": [
                                    "Selecione funções teste: analítica (e^x), suave não-analítica (sech(x)), descontínua.",
                                    "Compute tabelas de erros L2 e L∞ para ambos métodos com N fixo.",
                                    "Discuta quando Fourier falha (não-periódicas) e Chebyshev brilha (apériodicas).",
                                    "Analise Gibbs vs aliasing: ambos para não-smooth, mas mecanismos distintos.",
                                    "Conclua com tabela comparativa de prós/contras."
                                  ],
                                  "verification": "Crie relatório com tabelas/plots comparativos e conclusões.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Excel ou Pandas para tabelas; todos códigos anteriores.",
                                  "tips": "Padronize N e normas de erro para comparação justa.",
                                  "learningObjective": "Sintetizar diferenças qualitativas e quantitativas nas convergências.",
                                  "commonMistakes": "Comparar sem normalizar domínios ou funções."
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = exp(-1/(1-x²)) (função suave teste) em [-1,1] com N=20 modos Fourier (mapeado periodicamente) e Chebyshev. Plote erros: exponencial rápida em ambos, mas aliasing mais pronunciado em Chebyshev perto de x=±1 devido a curvatura.",
                              "finalVerifications": [
                                "Explicar por que convergência é exponencial para analíticas em ambas bases.",
                                "Identificar Gibbs em plot Fourier de função com descontinuidade.",
                                "Demonstrar aliasing em Chebyshev para tanh(20x).",
                                "Comparar erros L∞ para e^x: ambos <10^{-10} com N=32.",
                                "Listar 3 cenários onde Chebyshev supera Fourier.",
                                "Discutir mitigação: filtros para aliasing, extensão periódica para Fourier."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de decaimento exponencial (equações corretas).",
                                "Plots corretos mostrando Gibbs e aliasing distintos.",
                                "Tabelas comparativas quantitativas com erros <5% discrepância.",
                                "Análise qualitativa clara de fenômenos para funções suaves vs não-smooth.",
                                "Conclusões interdisciplinares válidas.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas (Fourier) vs soluções de PDE elípticas (Chebyshev em CFD).",
                                "Computação: Algoritmos FFT vs FCT (Fast Chebyshev Transform) em processamento de sinais.",
                                "Engenharia: Simulações aeroacústicas (periódicas: Fourier) vs aerodinâmica (apériodicas: Chebyshev).",
                                "Estatística: Análise espectral de séries temporais vs aproximação de densidades."
                              ],
                              "realWorldApplication": "Em simulações numéricas de escoamentos turbulentos (CFD), use Fourier para domínios periódicos (canais) evitando Gibbs com filtros, e Chebyshev para geometrias irregulares minimizando aliasing via dealiasing 3/2-rule, acelerando convergência em solvers espectrais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Interpolação Espectral",
                    "description": "Aproximação de funções por interpolação em pontos específicos, como Gauss-Lobatto, para representar soluções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Pontos de Colocação Gauss-Lobatto",
                        "description": "Definição e propriedades dos pontos de Gauss-Lobatto, utilizados como nós de interpolação em métodos espectrais para alta precisão na aproximação de funções suaves.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Definir pontos Gauss-Lobatto",
                            "description": "Explicar a construção dos pontos de Gauss-Lobatto como raízes dos polinômios de Legendre derivados, incluindo os pontos extremos do intervalo [-1,1].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Polinômios de Legendre",
                                  "subSteps": [
                                    "Estudar a fórmula de Rodrigues para P_n(x): P_n(x) = 1/(2^n n!) d^n/dx^n [(x^2-1)^n]",
                                    "Aprender propriedades de ortogonalidade: ∫_{-1}^1 P_m(x) P_n(x) dx = 2/(2n+1) δ_{mn}",
                                    "Calcular manualmente P_0(x), P_1(x), P_2(x) e P_3(x)",
                                    "Explorar a relação recursiva: (n+1) P_{n+1}(x) = (2n+1) x P_n(x) - n P_{n-1}(x)",
                                    "Plotar os primeiros polinômios para visualizar oscilações em [-1,1]"
                                  ],
                                  "verification": "Capaz de derivar P_3(x) corretamente e explicar sua ortogonalidade com P_2(x).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software SymPy ou MATLAB para verificação",
                                    "Referência: Livro de Análise Numérica (ex: Trefethen)"
                                  ],
                                  "tips": "Use a recursão para computar polinômios altos; evite expansão direta para economizar tempo.",
                                  "learningObjective": "Compreender a construção e propriedades ortogonais dos polinômios de Legendre como base para pontos espectrais.",
                                  "commonMistakes": [
                                    "Esquecer o fator de normalização 1/(2^n n!)",
                                    "Confundir Legendre com Chebyshev",
                                    "Ignorar o peso 1 em [-1,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Analisar Polinômios de Legendre",
                                  "subSteps": [
                                    "Derivar a fórmula para a derivada: P_n'(x) = n / (x^2 - 1) [x P_n(x) - P_{n-1}(x)]",
                                    "Calcular explicitamente P_2'(x) e P_3'(x)",
                                    "Resolver numericamente as raízes de P_n'(x) = 0 para n=2 e n=3",
                                    "Verificar que as raízes estão no intervalo (-1,1) e são simétricas",
                                    "Comparar o número de raízes: n-1 raízes para P_n'(x)"
                                  ],
                                  "verification": "Computar e listar as raízes exatas de P_3'(x)=0: ±√(1/5).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "SymPy para resolver equações polinomiais",
                                    "Folha de fórmulas de Legendre"
                                  ],
                                  "tips": "Fatore P_n'(x) para encontrar raízes analiticamente em casos baixos; use fsolve em software para altos n.",
                                  "learningObjective": "Dominar o cálculo das derivadas de Legendre e identificação de suas raízes internas.",
                                  "commonMistakes": [
                                    "Erro no sinal da recursão para derivadas",
                                    "Incluir endpoints como raízes da derivada",
                                    "Raízes fora de (-1,1) por erro numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir os Pontos Gauss-Lobatto",
                                  "subSteps": [
                                    "Definir formalmente: Para N+1 pontos, ξ_0 = -1, ξ_{N} = 1, e ξ_k (k=1..N-1) raízes de P_N'(ξ_k)=0",
                                    "Listar pontos para N=2: -1, 0, 1",
                                    "Listar pontos para N=3: -1, -√(1/5), √(1/5), 1",
                                    "Explicar a inclusão dos extremos para precisão em condições de contorno",
                                    "Comparar com pontos Gauss-Legendre (raízes de P_N(x)=0, sem endpoints)"
                                  ],
                                  "verification": "Escrever a definição precisa e listar 5 pontos corretos para N=4.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de raízes de Legendre (opcional)",
                                    "Python/Octave script para computar raízes",
                                    "Gráfico comparativo Gauss vs Lobatto"
                                  ],
                                  "tips": "Ordene os pontos em ordem crescente: ξ_0 < ξ_1 < ... < ξ_N para uso em interpolação.",
                                  "learningObjective": "Definir precisamente os pontos Gauss-Lobatto e diferenciá-los de variantes.",
                                  "commonMistakes": [
                                    "Confundir N (grau) com número de pontos (N+1)",
                                    "Esquecer simetria ξ_k = -ξ_{N-k}",
                                    "Usar raízes de P_N em vez de P_N'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades e Aplicar Conceito",
                                  "subSteps": [
                                    "Calcular pesos de quadratura Lobatto: w_k = 2/(N(N-1) [P_N(ξ_k)]^2) para k=1..N-1; w_0=w_N=2/(N(N-1))",
                                    "Testar integral ∫_{-1}^1 f(x) dx ≈ ∑ w_k f(ξ_k) para f(x)=1, x^2",
                                    "Implementar código simples para gerar pontos Lobatto até N=5",
                                    "Discutir convergência espectral devido à inclusão de endpoints",
                                    "Analisar estabilidade em métodos pseudoespectrais"
                                  ],
                                  "verification": "Quadratura exata para polinômios até grau 2N-2 e código rodando sem erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy (legendre)",
                                    "Exemplos de código de Trefethen 'Spectral Methods'"
                                  ],
                                  "tips": "Valide pesos somando ∑ w_k = 2; ajuste precisão numérica para raízes.",
                                  "learningObjective": "Validar a construção através de propriedades de quadratura e implementação prática.",
                                  "commonMistakes": [
                                    "Pesos errados nos endpoints",
                                    "Índices off-by-one em arrays",
                                    "Não normalizar para ∫=2"
                                  ]
                                }
                              ],
                              "practicalExample": "Para 4 pontos (N=3): Compute P_3(x) = (5x^3 - 3x)/2, P_3'(x) = (15x^2 - 3)/2 = 0 ⇒ x = ±√(3/15) = ±√(1/5) ≈ ±0.4472. Pontos: [-1, -0.4472, 0.4472, 1]. Verifique ∑ w_k = 2 com pesos w_0=w_3=1/3, w_1=w_2=5/6.",
                              "finalVerifications": [
                                "Explicar verbalmente a construção incluindo raízes de P_N' e endpoints.",
                                "Listar corretamente pontos e pesos para N=2,3,4.",
                                "Diferenciar pontos Lobatto de Gauss-Legendre e Gauss-Chebyshev.",
                                "Implementar função que gera pontos Lobatto para dado N.",
                                "Validar quadratura exata para ∫_{-1}^1 x^2 dx = 2/3.",
                                "Identificar papel em condições de Dirichlet (fixas nos limites)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com literatura).",
                                "Correção matemática em cálculos de raízes e pesos (erro <1e-10).",
                                "Clareza na distinção de variantes de pontos espectrais.",
                                "Profundidade em propriedades (ortogonalidade, convergência).",
                                "Capacidade de implementação computacional funcional.",
                                "Compreensão de vantagens em problemas com BCs nos limites."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Discretização em métodos espectrais para EDOs/PDEs quânticas.",
                                "Engenharia: Simulações CFD com pseudoespectrais (Navier-Stokes).",
                                "Ciência da Computação: Algoritmos numéricos para integração de alta ordem.",
                                "Matemática Aplicada: Teoria da aproximação polinomial e erros de Runge."
                              ],
                              "realWorldApplication": "Em dinâmica de fluidos computacional (CFD), pontos Gauss-Lobatto são usados em métodos pseudoespectrais para resolver equações de Navier-Stokes em domínios com condições de contorno rígidas, como paredes, oferecendo alta precisão e eficiência em simulações de turbulência e aerodinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Calcular pontos Gauss-Lobatto para N dado",
                            "description": "Implementar algoritmo numérico para computar os pontos e pesos de Gauss-Lobatto para um grau polinomial N específico, usando métodos como Newton-Raphson para raízes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a teoria dos pontos e pesos Gauss-Lobatto",
                                  "subSteps": [
                                    "Estude a definição: Para grau N, há N+1 pontos incluindo -1 e 1; pontos internos são raízes de P_N'(x) = 0, onde P_N é o polinômio de Legendre de grau N.",
                                    "Revise propriedades: Soma dos pesos = 2; precisão exata para polinômios até grau 2N-3.",
                                    "Analise a fórmula dos pesos: w_0 = w_N = 2 / (N(N-1)); w_i = 2 / (N(N-1) [P_{N-1}(ξ_i)]^2) para i=1..N-1.",
                                    "Leia sobre aplicações em métodos espectrais.",
                                    "Anote diferenças com Gauss-Legendre."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades chave e fórmulas; confira com referência bibliográfica.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Documentação sobre polinômios de Legendre (Wikipedia ou livro de análise numérica)",
                                    "Notas pessoais ou caderno"
                                  ],
                                  "tips": "Use visualizações de P_N(x) para entender as raízes da derivada.",
                                  "learningObjective": "Dominar os fundamentos teóricos para implementação precisa.",
                                  "commonMistakes": [
                                    "Confundir grau N com número de pontos (é N+1)",
                                    "Ignorar que derivada é de P_N, não P_{N-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar funções para polinômios de Legendre e derivadas",
                                  "subSteps": [
                                    "Implemente a recursão de Bonnet para P_n(x): P_0=1, P_1=x, P_{n} = ((2n-1)x P_{n-1} - (n-1)P_{n-2})/n.",
                                    "Crie função para derivada analítica: P_n'(x) = n/(x^2-1) * (x P_n(x) - P_{n-1}(x)).",
                                    "Teste para N=2,3: Verifique P_2(x)=(3x^2-1)/2, P_2'(x)=3x.",
                                    "Otimize para avaliação em múltiplos pontos usando cache ou vetorização.",
                                    "Adicione função para P_{N-1}(x)."
                                  ],
                                  "verification": "Execute e plote P_N(x) e P_N'(x); confirme raízes conhecidas para N baixo.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Linguagem de programação (Python com NumPy/SciPy recomendado)",
                                    "Editor de código (Jupyter Notebook)"
                                  ],
                                  "tips": "Use recursão com memoização para evitar recomputações.",
                                  "learningObjective": "Desenvolver código eficiente para base teórica.",
                                  "commonMistakes": [
                                    "Erro de índice na recursão (off-by-one)",
                                    "Não normalizar corretamente P_n(-1)=(-1)^n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método Newton-Raphson para raízes de P_N'(x)",
                                  "subSteps": [
                                    "Defina o solver Newton: x_{k+1} = x_k - f(x_k)/f'(x_k), com f = P_N'.",
                                    "Compute f' = segunda derivada ou aproximação finita.",
                                    "Inicialize guesses: para i=1..N-1, x0 = cos(π (i-0.25)/(N-0.5)).",
                                    "Itere até |Δx| < 1e-12 ou max 100 iterações; ordene raízes.",
                                    "Adicione -1 e 1 aos pontos."
                                  ],
                                  "verification": "Para N=4, compare com valores tabelados (ex: ≈ -0.861, -0.339).",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Código do Step 2",
                                    "Valores de referência de tabelas numéricas"
                                  ],
                                  "tips": "Use tolerância adaptativa; monitore convergência.",
                                  "learningObjective": "Aplicar otimizador não-linear para raízes precisas.",
                                  "commonMistakes": [
                                    "Guesses ruins levando a divergência",
                                    "Não ordenar pontos crescentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os pesos de integração",
                                  "subSteps": [
                                    "Para endpoints: w[0] = w[N] = 2 / (N*(N-1)).",
                                    "Para internos: w[i] = 2 / (N*(N-1) * P_{N-1}(xi)^2 ).",
                                    "Verifique soma(w) ≈ 2.",
                                    "Implemente como vetor para eficiência.",
                                    "Salve pontos e pesos em arrays."
                                  ],
                                  "verification": "Soma dos pesos deve ser exatamente 2 (até precisão máquina).",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Evite divisão por zero checando P_{N-1}(±1) ≠ 0.",
                                  "learningObjective": "Computar pesos corretamente para quadratura.",
                                  "commonMistakes": [
                                    "Usar P_N em vez de P_{N-1} para pesos",
                                    "Erro na fórmula do denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a implementação",
                                  "subSteps": [
                                    "Teste quadratura: ∫_{-1}^1 1 dx = soma(w_i * 1) = 2.",
                                    "Teste polinômio de grau 2N-3: erro < 1e-10.",
                                    "Compare com biblioteca (ex: numpy.polynomial.legendre.leggauss).",
                                    "Meça tempo de execução para N=100.",
                                    "Documente código com comentários."
                                  ],
                                  "verification": "Todos testes passam com precisão alta.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Biblioteca de referência (SciPy)",
                                    "Funções de teste unitário"
                                  ],
                                  "tips": "Use asserts para automação.",
                                  "learningObjective": "Garantir robustez e precisão do algoritmo.",
                                  "commonMistakes": [
                                    "Não testar alto N (instabilidade numérica)",
                                    "Ignorar erros de arredondamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=3: Pontos ≈ [-1, -0.339981, 0.339981, 1]; Pesos ≈ [0.1667, 0.8333, 0.8333, 0.1667]. Implemente e compute ∫ x^4 dx (erro deve ser pequeno pois grau 4 < 2*3-3=3? Espera, teste grau 2).",
                              "finalVerifications": [
                                "Pontos incluem exatamente -1 e 1, ordenados crescentemente.",
                                "Soma dos pesos = 2 (tolerância 1e-14).",
                                "Quadratura exata para polinômios até grau 2N-3.",
                                "Raízes convergem em <50 iterações por Newton.",
                                "Coincide com valores de SciPy em 12 dígitos.",
                                "Função roda em <1s para N=100."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1e-12 em pontos/pesos.",
                                "Eficiência: O(N log N) ou melhor tempo.",
                                "Robustez: Funciona para 2 ≤ N ≤ 1000 sem crash.",
                                "Clareza do código: Comentado e modular.",
                                "Validação completa: Testes incluídos.",
                                "Correção teórica: Fórmulas implementadas exatamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Métodos espectrais para equações diferenciais (ex: Navier-Stokes).",
                                "Engenharia: Simulações CFD e elementos finitos.",
                                "Ciência da Computação: Algoritmos numéricos e otimizadores.",
                                "Matemática Aplicada: Teoria de aproximação e quadratura."
                              ],
                              "realWorldApplication": "Usado em métodos pseudoespectrais para resolver PDEs em simulações climáticas, aerodinâmica e análise de estruturas, onde alta precisão com poucos pontos é crucial para eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Propriedades de precisão exponencial",
                            "description": "Demonstrar como os pontos Gauss-Lobatto permitem precisão espectral (exponencial) para funções analíticas, comparando com interpolação equiespaçada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Interpolação Equiespaçada e Suas Limitações",
                                  "subSteps": [
                                    "Defina interpolação polinomial equiespaçada em [-1,1] com N+1 pontos.",
                                    "Implemente interpolação de Lagrange para uma função suave como sin(πx) ou exp(x).",
                                    "Plote o interpolante e observe o fenômeno de Runge para funções com singularidades próximas.",
                                    "Calcule o erro máximo ||f - P||_∞ para diferentes N.",
                                    "Discuta a convergência polinomial O(1/N^k) para k fixo."
                                  ],
                                  "verification": "Gráficos mostram oscilações (Runge) e erro decaindo lentamente com N.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB com NumPy/MATLAB toolbox",
                                    "Função teste: exp(x) ou 1/(1+25x²)"
                                  ],
                                  "tips": "Use log-log plot para erro vs N para visualizar ordem de convergência.",
                                  "learningObjective": "Compreender por que interpolação equiespaçada falha para alta precisão em funções analíticas.",
                                  "commonMistakes": [
                                    "Ignorar normalização do intervalo [-1,1]",
                                    "Usar poucos pontos N<20",
                                    "Confundir erro L2 com L∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Pontos de Colocação Gauss-Lobatto",
                                  "subSteps": [
                                    "Revise polinômios de Legendre e quadratura Gauss-Lobatto (zeros + endpoints).",
                                    "Gere pontos Lobatto ξ_i para grau N via roots de P_N'(x) e ±1.",
                                    "Implemente pesos de quadratura associados w_i = 2/(N(N-1) P_N(ξ_i)^2).",
                                    "Formule base nodal l_j(x) = produto (x - ξ_k)/(ξ_j - ξ_k) para k≠j.",
                                    "Verifique ortogonalidade aproximada das funções base."
                                  ],
                                  "verification": "Pontos gerados coincidem com tabelas conhecidas para N=4,6; soma w_i ≈ 2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código para roots de Legendre (scipy.special.roots_legendre)",
                                    "Documentação de pseudoespectrais"
                                  ],
                                  "tips": "Use legendre(N) no SciPy para eficiência; normalize para [-1,1].",
                                  "learningObjective": "Dominar geração e propriedades dos pontos Gauss-Lobatto.",
                                  "commonMistakes": [
                                    "Esquecer endpoints ±1",
                                    "Não usar derivada P_N' para zeros internos",
                                    "Confundir com Gauss-Legendre sem endpoints"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Precisão Espectral para Funções Analíticas",
                                  "subSteps": [
                                    "Analise erro de interpolação |f(ξ) - P(ξ)| = O(ρ^{-N}) para funções analíticas em disco de raio ρ.",
                                    "Teorema: Para f holomorfa, erro exponencial em N via contorno de Legendre.",
                                    "Implemente interpolação espectral em Lobatto para f analítica (e.g., exp(x), cos(πx/2)).",
                                    "Calcule erro em pontos Lobatto e pontos intermediários.",
                                    "Compare log|erro| vs N: reta descendente (exponencial) vs lenta (equiespaçada)."
                                  ],
                                  "verification": "Log-erro linear descendente com slope ≈ -log(ρ) >1 para Lobatto.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Funções analíticas suaves",
                                    "Plots semilogarítmicos"
                                  ],
                                  "tips": "Escolha ρ pelo raio de analyticidade; teste f(x)=exp(-1/(1-x²)) para singularidades.",
                                  "learningObjective": "Explicar matematicamente a precisão exponencial via análise complexa.",
                                  "commonMistakes": [
                                    "Usar funções não-analíticas como |x|",
                                    "Plotar erro sem log",
                                    "N pequeno <10"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparação Numérica e Conclusão",
                                  "subSteps": [
                                    "Implemente ambos métodos para mesma f e N=10,20,40.",
                                    "Tabele erros L∞, L2 para equiespaçada vs Lobatto.",
                                    "Plote interpolantes sobrepostos e resíduos.",
                                    "Discuta aliasing e estabilidade espectral.",
                                    "Resuma: Lobatto permite precisão máquina com N~log(1/ε)."
                                  ],
                                  "verification": "Tabela mostra erro Lobatto << equiespaçada por fatores 10^4+ para N=30.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Códigos unificados",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use condnumber da Vandermonde para Lobatto ~1 vs exp(N) equiespaçada.",
                                  "learningObjective": "Demonstrar superioridade prática dos pontos Lobatto.",
                                  "commonMistakes": [
                                    "Escala diferente nos plots",
                                    "Ignorar custo computacional O(N^2)",
                                    "Não normalizar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = exp(x) em [-1,1] com N=16. Equiespaçada: erro ~10^{-3}; Lobatto: erro ~10^{-10}, permitindo precisão espectral para simulações precisas.",
                              "finalVerifications": [
                                "O aluno gera corretamente pontos Lobatto para N=8.",
                                "Plots mostram convergência exponencial log|erro| ∝ -N.",
                                "Explicação verbal da análise complexa para ρ>1.",
                                "Código reproduz erro 10^6x menor que equiespaçada.",
                                "Identifica Runge em equiespaçada mas não em Lobatto.",
                                "Discute aplicação em derivadas espectrais."
                              ],
                              "assessmentCriteria": [
                                "Clareza na distinção precisão polinomial vs exponencial (40%)",
                                "Implementação numérica correta e plots informativos (30%)",
                                "Compreensão teórica via teorema de Bernstein/analítica (20%)",
                                "Análise de erros quantitativa com tabelas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Quadratura em equações diferenciais PDEs espectrais.",
                                "Engenharia: Simulações CFD com precisão alta em malhas não-estruturadas.",
                                "Ciência da Computação: Algoritmos FFT para transformadas espectrais.",
                                "Análise Complexa: Contornos de integração para estimativas de erro."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluidos (Navier-Stokes espectral), pontos Gauss-Lobatto permitem resolver EDPs com precisão máquina usando poucos modos N~100, reduzindo tempo computacional em turbulência DNS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Interpolação Polinomial de Lagrange Espectral",
                        "description": "Construção do operador de interpolação usando bases de Lagrange nos pontos espectrais para aproximar funções contínuas por polinômios de alto grau.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Formular polinômios de Lagrange espectrais",
                            "description": "Derivar a fórmula do interpolante de Lagrange ∑ f(x_j) l_j(x), onde l_j são baseados em pontos Gauss-Lobatto, e expressar em forma de Vandermonde.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Interpolação Polinomial de Lagrange",
                                  "subSteps": [
                                    "Lembre-se da definição geral do interpolante de Lagrange: P(x) = ∑_{j=0}^N f(x_j) l_j(x), onde l_j(x) = ∏_{k≠j} (x - x_k)/(x_j - x_k).",
                                    "Estude as propriedades: P(x_i) = f(x_i) para i=0 a N, e grau no máximo N.",
                                    "Pratique com um exemplo simples de 3 pontos para fixar a fórmula.",
                                    "Identifique limitações como o fenômeno de Runge em pontos equidistantes.",
                                    "Anote a importância de nós otimizados para métodos espectrais."
                                  ],
                                  "verification": "Resolva um problema de interpolação com 3 pontos arbitrários e verifique se P(x_i) = f(x_i) em cada nó.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Comece com funções lineares para ganhar confiança antes de polinômios.",
                                  "learningObjective": "Compreender a estrutura básica do interpolante de Lagrange e suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir l_j(x) com o polinômio monomial x^j",
                                    "Esquecer o denominador normalizado em l_j(x)",
                                    "Não verificar interpolação exata nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Pontos de Gauss-Lobatto e sua Geração",
                                  "subSteps": [
                                    "Defina pontos Gauss-Lobatto: x_j = cos(π j / N) para j=0 a N no intervalo [-1,1].",
                                    "Explique por quê: Integram exatamente polinômios até grau 2N-1 e incluem endpoints.",
                                    "Gere manualmente para N=2,3 e plote para visualizar distribuição.",
                                    "Compare com pontos Gauss-Legendre (sem endpoints) e Chebyshev equidistantes.",
                                    "Calcule pesos de quadratura associados se aplicável para contexto espectral."
                                  ],
                                  "verification": "Liste os pontos para N=4 e confirme que x_0=-1, x_N=1; plote e descreva a clusterização nas extremidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/MATLAB com numpy/scatter)",
                                    "Tabela de referência de polinômios ortogonais"
                                  ],
                                  "tips": "Use a identidade trigonométrica para memorizar a fórmula dos pontos.",
                                  "learningObjective": "Dominar a geração e propriedades dos nós Gauss-Lobatto para interpolação espectral.",
                                  "commonMistakes": [
                                    "Usar π j / N em vez de π j / N para Gauss-Lobatto",
                                    "Confundir com pontos Chebyshev-Lobatto sem os fatores corretos",
                                    "Ignorar o mapeamento para intervalos gerais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar os Polinômios Base de Lagrange l_j(x) nos Pontos Gauss-Lobatto",
                                  "subSteps": [
                                    "Escreva l_j(x) = ∏_{k=0, k≠j}^N (x - x_k)/(x_j - x_k) com x_k de Gauss-Lobatto.",
                                    "Simplifique usando propriedades espectrais: l_j(x) ≈ [1 - P_N(x)^2] / [N^2 (x - x_j) (1 - x_j^2)] para grandes N (forma barycêntrica aproximada).",
                                    "Derive explicitamente para N pequeno (ex: N=2) e generalize.",
                                    "Implemente numericamente em código para avaliar l_j em pontos de teste.",
                                    "Verifique ortogonalidade aproximada e δ_{ij} = l_j(x_i)."
                                  ],
                                  "verification": "Compute l_j(x_i) para i,j=0 a N=3 e confirme matriz identidade; avalie em x fora dos nós.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código (Python com NumPy/SciPy)",
                                    "Documentação SciPy para lobatto_points"
                                  ],
                                  "tips": "Use loops vetorizados para eficiência computacional.",
                                  "learningObjective": "Derivar e computar os polinômios base l_j(x) específicos para nós espectrais Gauss-Lobatto.",
                                  "commonMistakes": [
                                    "Não normalizar corretamente o denominador",
                                    "Esquecer fatores de escala nos nós clusterizados",
                                    "Implementar recursivamente sem vetorização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o Interpolante e Expressar em Forma de Vandermonde Espectral",
                                  "subSteps": [
                                    "Monte P(x) = ∑ f(x_j) l_j(x) e avalie em pontos de colocation.",
                                    "Introduza a base de Vandermonde: defina Φ(x) = [1, x, ..., x^N], V_{kj} = φ_j(x_k).",
                                    "Mostre P(x) = Φ(x) V^{-1} f, onde f = [f(x_0), ..., f(x_N)], destacando estabilidade espectral.",
                                    "Implemente transformação para coeficientes modais via inversa de Vandermonde.",
                                    "Teste com função suave (ex: exp(x)) e compare com solução exata.",
                                    "Discuta eficiência: O(N^2) mas otimizável com FFT para Chebyshev."
                                  ],
                                  "verification": "Para N=4, construa V, inverta, interpole f(x)=sin(πx/2), e plote erro vs. exato.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python/MATLAB com np.linalg.inv",
                                    "Função teste suave como sin ou exp"
                                  ],
                                  "tips": "Condicione V com np.linalg.cond para verificar estabilidade.",
                                  "learningObjective": "Formular o interpolante completo e representá-lo na base de Vandermonde para métodos espectrais.",
                                  "commonMistakes": [
                                    "Índices errados em V (linhas pontos, colunas bases)",
                                    "Não usar nós precisos levando a ill-conditioning",
                                    "Confundir interpolação nodal com expansão modal"
                                  ]
                                }
                              ],
                              "practicalExample": "Interpole f(x) = exp(x) em [-1,1] usando N=5 pontos Gauss-Lobatto. Compute coeficientes via V^{-1} f, reconstrua P(x) em 100 pontos equidistantes, plote P(x) vs f(x) e calcule erro máximo <10^{-10}.",
                              "finalVerifications": [
                                "Derivar corretamente l_j(x) para N=3 e verificar l_j(x_k)=δ_{jk}.",
                                "Gerar pontos Gauss-Lobatto para N=6 e plotar distribuição.",
                                "Implementar interpolante e obter erro <10^{-12} para função analítica suave.",
                                "Construir matriz Vandermonde V e confirmar ||V^{-1} V - I|| < 10^{-10}.",
                                "Explicar verbalmente por que Gauss-Lobatto é preferido em métodos espectrais.",
                                "Aplicar a uma função não-suave e discutir oscilações de Gibbs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de l_j(x) e P(x) (90% correto).",
                                "Correta geração e uso de pontos Gauss-Lobatto (sem erros numéricos).",
                                "Implementação funcional de Vandermonde com estabilidade demonstrada.",
                                "Análise de erro quantitativa e qualitativa.",
                                "Clareza na explicação de conexões espectrais.",
                                "Eficiência computacional (tempo O(N^2) aceitável para N<20)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de equações diferenciais em métodos pseudoespectrais (ex: Navier-Stokes).",
                                "Computação: Otimização com FFT para transformadas discretas rápidas em bibliotecas como Dedalus/ Nekton.",
                                "Engenharia: Análise de elementos finitos espectrais em aeroacústica.",
                                "Estatística: Aproximação de densidades em métodos de partículas espectrais."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), formulação de polinômios de Lagrange espectrais permite resolver PDEs com alta precisão em grades não-estruturadas, usado em previsão de tempo (modelos ECMWF) e design aerodinâmico (NASA)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Avaliar interpolante em pontos espectrais",
                            "description": "Calcular o valor da aproximação espectral I_N f(x) em nós de colocação e pontos arbitrários usando pré-computação de matrizes de Lagrange.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os nós espectrais e a função a ser interpolada",
                                  "subSteps": [
                                    "Escolher o tipo de nós espectrais adequados, como Chebyshev-Gauss-Lobatto para intervalos finitos.",
                                    "Determinar o grau polinomial N (exemplo: N=8 ou N=16).",
                                    "Calcular as coordenadas dos nós x_k para k=0 até N usando fórmulas analíticas.",
                                    "Definir a função f(x) suave no intervalo de interesse (ex: [-1,1] ou [-π,π]).",
                                    "Computar os valores iniciais f_k = f(x_k) nos nós."
                                  ],
                                  "verification": "Lista de nós x_k gerada corretamente e valores f_k computados sem erros numéricos evidentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matlab ou Octave",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Use nós Chebyshev para minimizar o fenômeno de Runge e melhorar a estabilidade.",
                                  "learningObjective": "Compreender a escolha e geração de nós espectrais otimizados para interpolação.",
                                  "commonMistakes": "Confundir nós espectrais com nós equidistantes, levando a oscilações espúrias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pré-computar a matriz de avaliação de Lagrange",
                                  "subSteps": [
                                    "Definir os pontos de avaliação: nós de colocação e um conjunto de pontos arbitrários x_j.",
                                    "Para cada x_j, calcular os polinômios de Lagrange l_k(x_j) = ∏_{m≠k} (x_j - x_m)/(x_k - x_m).",
                                    "Montar a matriz L onde L[j,k] = l_k(x_j) para todos j e k.",
                                    "Verificar propriedades: soma sobre k de L[j,k] = 1 para cada j.",
                                    "Otimizar com fórmula barycêntrica: w_k / ∑ w_m * (x_j - x_m) para eficiência."
                                  ],
                                  "verification": "Propriedade de partição da unidade: ∑_k L[j,k] = 1 para todos os pontos j, com precisão máquina.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/NumPy ou Matlab",
                                    "Editor de código (Jupyter Notebook)"
                                  ],
                                  "tips": "Implemente pesos barycêntricos pré-computados para evitar recomputação custosa em avaliações múltiplas.",
                                  "learningObjective": "Dominar a construção eficiente da matriz de Lagrange para avaliações espectrais.",
                                  "commonMistakes": "Erro de indexação na matriz (confundir j e k) ou overflow em produtos para altos N."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o interpolante nos nós de colocação",
                                  "subSteps": [
                                    "Coletar o vetor de valores nos nós f_vec = [f(x_0), ..., f(x_N)].",
                                    "Computar I_N f(x_j) = ∑_k L[j,k] * f(x_k) para j nos nós de colocação.",
                                    "Verificar exatidão: I_N f(x_j) deve igualar f(x_j) por interpolação.",
                                    "Comparar com avaliação direta da função.",
                                    "Registrar resíduos numéricos devido a precisão finita."
                                  ],
                                  "verification": "Resíduos |I_N f(x_j) - f(x_j)| < 1e-12 para todos os nós j.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código dos passos anteriores",
                                    "NumPy array operations"
                                  ],
                                  "tips": "Este passo valida a matriz L; use multiplicação matricial vetor para eficiência.",
                                  "learningObjective": "Reconhecer e verificar a exatidão da interpolação nos nós próprios.",
                                  "commonMistakes": "Não perceber que é trivial por definição, mas testar numericamente é essencial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o interpolante em pontos arbitrários e analisar",
                                  "subSteps": [
                                    "Selecionar pontos arbitrários x_test (ex: grade equidistante).",
                                    "Estender ou usar linhas da matriz L para x_test: I_N f(x_test) = L_test * f_vec.",
                                    "Comparar com valores exatos f(x_test).",
                                    "Calcular erros L^∞ e L^2 da aproximação.",
                                    "Visualizar gráfico de f vs I_N f."
                                  ],
                                  "verification": "Erros de interpolação pequenos (ex: <1e-6) para funções suaves e N adequado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código prévio",
                                    "Matplotlib ou similar para plotagem"
                                  ],
                                  "tips": "A pré-computação permite avaliações O(N) rápidas; ideal para milhares de pontos.",
                                  "learningObjective": "Aplicar a matriz pré-computada para avaliações eficientes em qualquer ponto.",
                                  "commonMistakes": "Pontos de teste muito próximos aos nós sem considerar precisão condicional."
                                }
                              ],
                              "practicalExample": "Interpole f(x) = sin(π x) no intervalo [-1,1] com N=10 usando nós Chebyshev-Gauss-Lobatto. Pré-compute L para 50 pontos equidistantes incluindo x=0.5. Calcule I_N f(0.5) ≈ 0.7071 e verifique erro <1e-8. Plote a aproximação sobre f(x).",
                              "finalVerifications": [
                                "∑_k L[j,k] = 1 para todos pontos de avaliação j.",
                                "I_N f(x_k) = f(x_k) exatamente nos nós de colocação.",
                                "Avaliações em pontos arbitrários coincidem com Lagrange direto dentro de precisão máquina.",
                                "Erro máximo de interpolação decresce exponencialmente com N para funções analíticas.",
                                "Tempo de múltiplas avaliações é linear em número de pontos após pré-computação.",
                                "Visualização mostra convergência espectral (alta precisão com baixo N)."
                              ],
                              "assessmentCriteria": [
                                "Correção na geração de nós e matriz L.",
                                "Precisão numérica das avaliações (resíduos <1e-12).",
                                "Eficiência: pré-computação O(N^2), avaliação O(N).",
                                "Análise de erros e interpretação dos resultados.",
                                "Código limpo, comentado e reproduzível.",
                                "Visualizações claras demonstrando a aproximação."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Derivadas espectrais em simulações de ondas e fluidos.",
                                "Engenharia Aeronáutica: Modelagem de escoamentos em CFD pseudoespectral.",
                                "Ciência da Computação: Otimização de algoritmos numéricos e HPC.",
                                "Processamento de Sinais: Análise espectral em Fourier-Lagrange."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), a avaliação rápida de interpolantes espectrais permite calcular derivadas e projeções eficientes em métodos pseudoespectrais para modelar turbulência, ondas e plasmas com alta precisão e baixo custo computacional."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Implementar interpolação em código",
                            "description": "Codificar em Python/MATLAB a interpolação espectral para uma função teste, verificando convergência com aumento de N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e definir função teste",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: NumPy e Matplotlib via pip.",
                                    "Defina o domínio de interpolação, como o intervalo [-1, 1].",
                                    "Escolha e implemente uma função teste suave, por exemplo, f(x) = exp(sin(πx)).",
                                    "Crie uma grade fina para avaliação posterior (ex: 1000 pontos).",
                                    "Plote a função teste para visualização inicial."
                                  ],
                                  "verification": "O código executa sem erros e o gráfico da função teste é exibido corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Prefira funções analíticas suaves e periódicas para demonstrar a rápida convergência espectral.",
                                  "learningObjective": "Preparar um ambiente de programação estável e uma função teste adequada para análise numérica.",
                                  "commonMistakes": "Escolher funções com descontinuidades ou não suaves, o que impede convergência espectral rápida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar nós de interpolação espectrais (Chebyshev-Gauss-Lobatto)",
                                  "subSteps": [
                                    "Defina o número inicial de pontos N (ex: 16).",
                                    "Implemente os nós ξ_k = cos(π k / (N-1)) para k = 0 a N-1.",
                                    "Calcule os valores da função nos nós: y_k = f(ξ_k).",
                                    "Plote os nós e os valores y_k no gráfico da função teste.",
                                    "Verifique se os nós estão distribuídos corretamente nos extremos."
                                  ],
                                  "verification": "Array de nós ξ e y gerados corretamente e plotados sobre a função original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NumPy para cálculos trigonométricos",
                                    "Matplotlib para plotagem"
                                  ],
                                  "tips": "Use np.linspace e np.cos para precisão numérica alta.",
                                  "learningObjective": "Compreender e implementar nós espectrais que agrupam pontos nas regiões de alta curvatura.",
                                  "commonMistakes": "Confundir nós Chebyshev com equispaced, levando a Runge phenomenon."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a interpolação polinomial de Lagrange",
                                  "subSteps": [
                                    "Defina a função base de Lagrange l_j(x) = ∏_{m≠j} (x - ξ_m)/(ξ_j - ξ_m).",
                                    "Implemente o interpolante P(x) = ∑ y_j * l_j(x) em uma grade fina.",
                                    "Otimize com pesos barycêntricos para eficiência: w_j = 1/∏_{m≠j} (ξ_j - ξ_m).",
                                    "Avalie P(x) na grade fina e calcule o erro |f(x) - P(x)|.",
                                    "Plote f(x), P(x) e o erro absoluto."
                                  ],
                                  "verification": "Gráficos mostram P(x) sobrepondo f(x) com erro pequeno (<1e-5 max).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy para vetores e produtos",
                                    "Funções vetorizadas"
                                  ],
                                  "tips": "Use pesos barycêntricos para evitar instabilidade numérica em altos N.",
                                  "learningObjective": "Codificar a fórmula de Lagrange de forma eficiente e estável para métodos espectrais.",
                                  "commonMistakes": "Implementação ingênua sem barycentric, causando overflow/underflow em N>20."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência espectral variando N",
                                  "subSteps": [
                                    "Crie um loop para N = [8, 16, 32, 64, 128].",
                                    "Para cada N, gere nós, interpole e calcule erro máximo ou norma L∞.",
                                    "Registre erros em uma lista e plote log(erro) vs log(N).",
                                    "Analise a inclinação: deve ser ~ -N (convergência exponencial).",
                                    "Compare com interpolação equiespaçada para contraste (lento).",
                                    "Adicione comentários explicando os resultados."
                                  ],
                                  "verification": "Gráfico de convergência mostra declínio exponencial do erro com N.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy para loops vetorizados",
                                    "Matplotlib para log-log plot"
                                  ],
                                  "tips": "Use np.logspace para N e semilogx/semilogy para visualização clara.",
                                  "learningObjective": "Demonstrar empiricamente a superioridade espectral sobre métodos polinomiais clássicos.",
                                  "commonMistakes": "Não normalizar erros ou usar N muito pequeno, mascarando a convergência."
                                }
                              ],
                              "practicalExample": "Para f(x) = sin(3πx) em [-1,1], com N=32 nós Chebyshev-Lobatto, implemente P(x) via barycentric Lagrange, plote f, P e erro (max ~1e-10), então varie N até 128 mostrando erro caindo de 1e-3 para 1e-15.",
                              "finalVerifications": [
                                "Código completo executa sem erros numéricos ou crashes.",
                                "Plots para cada N mostram sobreposição visual perfeita de f e P.",
                                "Erro máximo diminui exponencialmente com N (fator >10 por duplicação).",
                                "Gráfico log-log confirma taxa espectral (não algébrica).",
                                "Código comentado e reutilizável para outras funções.",
                                "Teste com MATLAB equivalente via vectorize(@(x) ...)."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de nós Chebyshev-Lobatto (distribuição sinusoidal).",
                                "Estabilidade numérica da interpolação Lagrange (uso de barycentric).",
                                "Análise quantitativa de convergência (erros tabulados e plotados).",
                                "Visualizações claras e informativas (múltiplos subplots).",
                                "Eficiência: tempo de execução <1s para N=128.",
                                "Generalidade: código funciona para qualquer f suave."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Vetorização e otimização NumPy.",
                                "Física Computacional: Base para solvers PDE pseudoespectrais.",
                                "Engenharia Numérica: Aproximações em simulações CFD/Aerodinâmica.",
                                "Processamento de Sinais: Interpolação em séries de Fourier.",
                                "Matemática Aplicada: Análise de erro em métodos de alta ordem."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) via métodos pseudoespectrais, como em previsão meteorológica ou aerodinâmica, onde a interpolação espectral permite alta precisão com poucos pontos (N~100), reduzindo custo computacional em PDEs elípticas/parabólicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.4",
                            "name": "Diferenciação espectral via interpolação",
                            "description": "Derivar o operador de derivada espectral D_N = L'_N(x_k), onde L_N é o interpolante, para aproximação de derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão da Interpolação Polinomial de Lagrange",
                                  "subSteps": [
                                    "Estude a fórmula geral da interpolação de Lagrange: L_N(x) = ∑_{j=0}^N y_j ℓ_j(x), onde ℓ_j(x) = ∏_{k≠j} (x - x_k)/(x_j - x_k).",
                                    "Identifique os nós de interpolação x_k, especialmente em contextos espectrais como pontos de Chebyshev-Gauss-Lobatto.",
                                    "Implemente numericamente a avaliação de L_N(x) para uma função teste simples, como f(x) = x^2.",
                                    "Analise o fenômeno de Runge para nós equidistantes e justifique o uso de nós espectrais.",
                                    "Verifique a exatidão para polinômios de grau ≤ N."
                                  ],
                                  "verification": "A interpolação reproduz exatamente polinômios de grau até N; erro numérico < 1e-12 para f(x)=x^3 com N=3.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Python com NumPy/SciPy ou MATLAB"
                                  ],
                                  "tips": "Sempre normalize os nós para o intervalo [-1,1] para estabilidade espectral.",
                                  "learningObjective": "Dominar a construção e propriedades do interpolante de Lagrange como base para diferenciação.",
                                  "commonMistakes": [
                                    "Índices incorretos nos produtos de Lagrange",
                                    "Não mapear para nós clustered nos extremos",
                                    "Ignorar conditioning numérico para altos N"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição de Nós e Interpolante Espectral",
                                  "subSteps": [
                                    "Defina nós espectrais: x_k = cos(π k / N) para k=0..N (Chebyshev-Gauss-Lobatto).",
                                    "Construa a matriz de Vandermonde ou avalie diretamente os basis ℓ_j(x_m) para todos m,j.",
                                    "Implemente a matriz de interpolação I onde I_{mj} = ℓ_j(x_m).",
                                    "Teste interpolação de funções suaves como exp(x) e observe convergência exponencial.",
                                    "Compare com nós equidistantes para destacar vantagens espectrais."
                                  ],
                                  "verification": "Matriz I satisfaz I y = valores interpolados exatos em nós para polinômios baixos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para nós Chebyshev",
                                    "Referência: Trefethen 'Spectral Methods in MATLAB'"
                                  ],
                                  "tips": "Use funções prontas como chebpts() no Chebfun para validação.",
                                  "learningObjective": "Entender nós espectrais e sua role na alta precisão da interpolação.",
                                  "commonMistakes": [
                                    "Confundir nós Chebyshev com Legendre",
                                    "Nós não simétricos levando a instabilidade",
                                    "Alta condição da matriz para N grande sem nós clustered"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação Analítica da Derivada do Interpolante",
                                  "subSteps": [
                                    "Derive ℓ_j'(x) = ℓ_j(x) ∑_{k≠j} 1/(x - x_k) usando regra do produto/logarítmica.",
                                    "Mostre que a derivada em nós: D_N]_{mj} = ℓ_j'(x_m) = δ_{mj} ∑_{k≠j} 1/(x_m - x_k) + termo para m=j.",
                                    "Para m=j: ℓ_j'(x_j) = - ∑_{k≠j} 1/(x_j - x_k).",
                                    "Escreva a fórmula fechada para D_N em pontos Chebyshev: use identidades trigonométricas.",
                                    "Verifique para N=2: matriz D_2 explícita."
                                  ],
                                  "verification": "Cálculo analítico de D_N para N=3 coincide com diferenciação numérica finita de alta ordem.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "SymPy para simplificação simbólica"
                                  ],
                                  "tips": "Use log-derivada: d/dx log ℓ_j = ∑ 1/(x-x_k), multiplique por ℓ_j.",
                                  "learningObjective": "Derivar explicitamente o operador diferencial espectral D_N = L_N'(x_k).",
                                  "commonMistakes": [
                                    "Sinal errado no termo diagonal",
                                    "Esquecer o fator ℓ_j no off-diagonal",
                                    "Não usar simetria dos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construção e Implementação da Matriz D_N",
                                  "subSteps": [
                                    "Implemente código para computar D_N usando a fórmula derivada: loop sobre m,j.",
                                    "Otimize para eficiência O(N^2) com pré-computação de 1/(x_m - x_k).",
                                    "Teste em função conhecida: aplique D_N u onde u_k = f(x_k), compare com f'(x_k).",
                                    "Analise erro de truncamento: exponencial para funções analíticas.",
                                    "Estenda para derivadas de ordem superior via D_N^k."
                                  ],
                                  "verification": "||D_N u - f'||_∞ < 1e-10 para f(x)=sin(πx), N=16.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/NumPy ou MATLAB",
                                    "Funções teste: sin, exp, 1/(1+25x^2)"
                                  ],
                                  "tips": "Vetorize computação para evitar loops lentos em Python.",
                                  "learningObjective": "Construir e codificar o operador de diferenciação espectral completo.",
                                  "commonMistakes": [
                                    "Divisão por zero em m=k (tratar separadamente)",
                                    "Escala errada sem normalização",
                                    "Não checar simetria anti-simétrica para problemas pares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação Numérica e Análise de Precisão",
                                  "subSteps": [
                                    "Compare D_N com diferenças finitas de ordem alta (ex: 6th order).",
                                    "Estude convergência: plote log erro vs N para funções com singularidades próximas.",
                                    "Analise estabilidade: cond(D_N) ~ O(N^2) mas precisão mantém alta.",
                                    "Aplique a solução de y' = λ y: verifique preservação de exponencial.",
                                    "Discuta limitações: Gibbs para funções descontínuas."
                                  ],
                                  "verification": "Curva de convergência exponencial confirmada para N=4 a 32.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Gráficos em Matplotlib",
                                    "Benchmark functions de Trefethen"
                                  ],
                                  "tips": "Use loglog plot para erro vs N.",
                                  "learningObjective": "Validar precisão e entender limites do método espectral.",
                                  "commonMistakes": [
                                    "Escolha de funções não suaves mascarando benefícios",
                                    "Nós inadequados",
                                    "Ignorar round-off para N>100"
                                  ]
                                }
                              ],
                              "practicalExample": "Aproxime f'(x) para f(x) = exp(x) sin(x)^2 em [-1,1] com N=12 pontos Chebyshev. Compute u_k = f(x_k), v = D_N u, compare v com f'(x_k) analítica: erro deve ser <1e-12.",
                              "finalVerifications": [
                                "Derivação simbólica de D_N para N≤4 é correta e coincide com código.",
                                "Implementação numérica passa testes unitários para 5 funções teste.",
                                "Convergência exponencial observada: erro cai como e^{-cN}.",
                                "Matriz D_N é anti-simétrica para intervalos simétricos em funções pares.",
                                "Aplicação iterada D_N^2 aproxima segundas derivadas com precisão espectral.",
                                "Tempo de computação O(N^2) é eficiente para N<1000."
                              ],
                              "assessmentCriteria": [
                                "Exatidão da fórmula derivada de ℓ_j'(x_m) (peso 25%).",
                                "Código implementa D_N sem erros numéricos (peso 25%).",
                                "Análise de erro e convergência documentada (peso 20%).",
                                "Exemplo prático resolvido com gráficos (peso 15%).",
                                "Discussão de limitações e melhorias (peso 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Integração em métodos espectrais para PDEs (equação de onda, Navier-Stokes).",
                                "Engenharia Aeronáutica: Simulações de escoamentos turbulentos com alta precisão.",
                                "Ciência de Dados: Aproximações eficientes em machine learning para funções de alta dimensão.",
                                "Processamento de Sinais: Filtragem espectral e diferenciação de sinais.",
                                "Otimização: Gradientes precisos em métodos quasi-Newton espectrais."
                              ],
                              "realWorldApplication": "Usado em simulações numéricas de dinâmica de fluidos (CFD espectral pela NASA), previsão climática (modelos GCM), e controle de sistemas (aeroespaciais), onde convergência exponencial permite precisão máquina com poucos graus de liberdade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Erro e Convergência na Interpolação Espectral",
                        "description": "Análise teórica e numérica do erro de interpolação espectral, destacando convergência rápida para funções suaves e aliasing.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Teorema de erro de interpolação espectral",
                            "description": "Estabelecer o erro |f(x) - I_N f(x)| ≤ C / ρ^N para funções analíticas com raio de analiticidade ρ, usando resíduos de Lagrange.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Interpolação de Lagrange e Resíduos",
                                  "subSteps": [
                                    "Recordar a fórmula da base de Lagrange: l_k(x) = ∏_{j≠k} (x - x_j)/(x_k - x_j)",
                                    "Derivar o polinômio interpolador I_N f(x) = ∑ f(x_k) l_k(x)",
                                    "Definir o residuo de Lagrange: ω_N(x) = ∏_{k=0}^N (x - x_k)",
                                    "Estabelecer a fórmula de erro clássica: f(x) - I_N f(x) = [f^{(N+1)}(ξ)] / (N+1)! * ω_N(x)",
                                    "Discutir limitações para alta ordem N em métodos espectrais"
                                  ],
                                  "verification": "Derivar corretamente a fórmula de erro de Lagrange para uma função teste quadrática",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden & Faires",
                                    "Notas de aula sobre interpolação",
                                    "Software MATLAB ou Python (NumPy) para testes"
                                  ],
                                  "tips": "Visualize os resíduos plotando l_k(x) em intervalos equidistantes vs. Chebyshev",
                                  "learningObjective": "Compreender os resíduos de Lagrange como fundação para análise de erro espectral",
                                  "commonMistakes": [
                                    "Confundir resíduos com pesos de quadratura",
                                    "Ignorar o comportamento oscilatório de Runge para pontos equidistantes",
                                    "Esquecer o fator (N+1)! no erro clássico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Funções Analíticas e Raio de Analiticidade",
                                  "subSteps": [
                                    "Definir função analítica em um disco complexo |z - z0| < ρ",
                                    "Explicar o raio de analiticidade ρ como distância para a singularidade mais próxima",
                                    "Representar f(z) pela fórmula de Cauchy: f(z) = (1/(2πi)) ∫_Γ f(ζ)/(ζ - z) dζ",
                                    "Discutir expansão em série de Laurent ao redor de singularidades",
                                    "Relacionar ρ com a taxa de convergência de séries de Fourier/Chebyshev"
                                  ],
                                  "verification": "Identificar o raio ρ para f(z) = 1/(1 - z) e esboçar o disco de convergência",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Análise Complexa' de Ahlfors",
                                    "Software SymPy para manipulação simbólica",
                                    "Gráficos de domínio complexo"
                                  ],
                                  "tips": "Use o lema de Schwarz para estimar bounds em discos menores",
                                  "learningObjective": "Dominar conceitos de analiticidade para justificar convergência exponencial espectral",
                                  "commonMistakes": [
                                    "Confundir raio de convergência com raio espectral",
                                    "Subestimar impacto de singularidades próximas",
                                    "Aplicar fórmulas reais a contextos complexos sem cuidado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação do Erro Espectral com Pontos Chebyshev/Gauss-Lobatto",
                                  "subSteps": [
                                    "Definir pontos espectrais: x_k = cos(π k / N) para Chebyshev extremais",
                                    "Estender resíduos para contorno complexo: ω_N(z) = (z^2 - 1)^{N+1} / 2^N ou similar",
                                    "Aplicar fórmula de Cauchy ao erro: f(z) - I_N f(z) = (1/(2πi)) ∫_Γ f(ζ) ω_N(z) / [ω_N(ζ) (ζ - z)] dζ",
                                    "Escolher contorno Γ como elipse de Bernstein com parâmetro ρ > 1",
                                    "Estimar |ω_N(z)/ω_N(ζ)| ≤ (ρ_elipse)^{-N} geometricamente",
                                    "Derivar bound inicial |erro| ≤ C / ρ^N"
                                  ],
                                  "verification": "Calcular numericamente ω_N em pontos Chebyshev e verificar minimax",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python com SciPy para pontos Chebyshev",
                                    "Papel 'Spectral Methods' de Trefethen",
                                    "Ferramenta de plotagem complexa (Matplotlib)"
                                  ],
                                  "tips": "Escolha elipses de foco (-1,1) para otimizar o bound exponencial",
                                  "learningObjective": "Construir a estimativa geométrica do erro usando contornos complexos",
                                  "commonMistakes": [
                                    "Usar pontos equidistantes em vez de espectrais",
                                    "Escolher contorno Γ fora do raio ρ",
                                    "Negligenciar o fator de crescimento de Lebesgue constante"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prova Completa e Verificação do Teorema",
                                  "subSteps": [
                                    "Combinar integral de Cauchy com estimativa de elipse: |∫| ≤ Length(Γ) * max|f| * max|ω_N(z)/ω_N(ζ)(ζ-z)|",
                                    "Provar |ω_N(z)| ≤ 2 ρ^{N+1} e |ω_N(ζ)| ≥ 2 σ^N para σ > ρ",
                                    "Estabelecer |f(x) - I_N f(x)| ≤ C / ρ^N com C independente de N",
                                    "Generalizar para base espectral (Fourier/Chebyshev) via DFT",
                                    "Testar numericamente convergência para f analítica vs. não-analítica"
                                  ],
                                  "verification": "Provar o teorema para f(z) = exp(z) e plotar log|erro| vs. N linear",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código Jupyter com implementação espectral",
                                    "Referência 'Spectral Methods in MATLAB' de Trefethen",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Para ρ próximo de 1, use elipses achatadas para tight bounds",
                                  "learningObjective": "Derivar e validar o teorema de erro exponencial para interpolação espectral",
                                  "commonMistakes": [
                                    "Esquecer normalização de ω_N",
                                    "Aplicar bound sem verificar analiticidade",
                                    "Confundir ρ com taxa de crescimento de Λ_N (constante de Lebesgue)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(z) = exp(z) com ρ ≈ 1.5 (singularidade em ∞, mas limite prático), usando N=16 pontos Gauss-Lobatto Chebyshev em [-1,1], compute I_N f(x), erro máximo ≈ 10^{-10}, confirmando |erro| ≤ 10 / 1.5^{16} ≈ 10^{-8}, e plote log|erro| vs. N mostrando inclinação -log(ρ).",
                              "finalVerifications": [
                                "Derivar integral de Cauchy para erro espectral corretamente",
                                "Estimar bound C/ρ^N para função dada com ρ especificado",
                                "Implementar código numérico mostrando convergência exponencial",
                                "Identificar falha de convergência para f(z) = log(1+z) (ρ=1)",
                                "Plotar elipse de Bernstein e verificar |ω_N| geometricamente",
                                "Generalizar prova para Fourier periódico"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da integral de erro (90% correto)",
                                "Correta escolha e justificativa do contorno Γ (raio >ρ)",
                                "Qualidade do bound exponencial (incluindo dependência em ρ)",
                                "Validação numérica com erro <10^{-6} para N=20",
                                "Clareza na distinção entre erro clássico e espectral",
                                "Compreensão de limitações para funções com ρ≤1"
                              ],
                              "crossCurricularConnections": [
                                "Análise Complexa: Fórmulas de Cauchy e contornos elípticos",
                                "Computação Científica: Implementação em FFT para métodos espectrais",
                                "Física Computacional: Solução de PDEs (equação de Navier-Stokes) via pseudoespectrais",
                                "Engenharia: Análise de sinais e processamento de imagens com bases ortogonais",
                                "Estatística: Aproximação de densidades em métodos MCMC espectrais"
                              ],
                              "realWorldApplication": "Em simulações numéricas de turbulência (CFD), métodos espectrais usam esse teorema para justificar alta precisão com poucos graus de liberdade N, permitindo resoluções de 10^6 pontos em supercomputadores para modelar clima ou aerodinâmica supersônica."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Comparar com interpolação clássica",
                            "description": "Analisar numericamente a taxa de convergência espectral vs. ordem finita em Runge phenomenon para funções como 1/(1+25x²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função Runge e preparar o domínio de interpolação",
                                  "subSteps": [
                                    "Defina a função Runge: f(x) = 1 / (1 + 25x²) no intervalo [-1, 1].",
                                    "Gere uma malha fina de pontos de avaliação (ex: 1000 pontos equidistantes) para calcular o erro de interpolação.",
                                    "Implemente uma função para avaliar f(x) exata nesses pontos.",
                                    "Plote a função exata para visualização inicial.",
                                    "Salve os dados em arrays NumPy para reutilização."
                                  ],
                                  "verification": "Função exata plotada corretamente sem erros numéricos ou overflows.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3, NumPy, Matplotlib",
                                  "tips": "Use np.linspace(-1, 1, 1000) para malha fina e evite divisões por zero.",
                                  "learningObjective": "Compreender o comportamento da função Runge que exibe o fenômeno de Runge.",
                                  "commonMistakes": "Escolher malha grosseira (menos de 500 pontos) ou intervalo errado (ex: além de [-1,1])."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar interpolação clássica com pontos equidistantes",
                                  "subSteps": [
                                    "Gere pontos equidistantes xi = np.linspace(-1, 1, N+1) para ordens N de 4 a 20.",
                                    "Calcule os valores fi = f(xi) nos pontos nodais.",
                                    "Implemente a interpolação de Lagrange para interpolar em pontos de avaliação.",
                                    "Avalie o interpolante P_N(x) na malha fina e compute o erro ||f - P_N||_∞.",
                                    "Plote o interpolante e o erro para N=10 e N=20, observando oscilações."
                                  ],
                                  "verification": "Plots mostram oscilações crescentes nas extremidades (fenômeno de Runge).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python 3, NumPy, Matplotlib, função de Lagrange (implementar ou usar scipy.interpolate)",
                                  "tips": "Implemente Lagrange manualmente para compreensão; vetorize com np.outer para eficiência.",
                                  "learningObjective": "Dominar a interpolação polinomial clássica e identificar divergência espectral.",
                                  "commonMistakes": "Usar pontos não-equidistantes ou ordem N muito baixa sem oscilações visíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar interpolação espectral com pontos Chebyshev",
                                  "subSteps": [
                                    "Gere pontos de Chebyshev-Gauss-Lobatto: xi = cos(π * k / N) para k=0 a N.",
                                    "Calcule fi = f(xi) nos pontos nodais espectrais.",
                                    "Use interpolação espectral via DFT (FFT) ou Lagrange em pontos Chebyshev.",
                                    "Avalie o interpolante espectral na malha fina via barycentric weights para eficiência.",
                                    "Plote o interpolante para N=10 e N=20, verificando ausência de oscilações."
                                  ],
                                  "verification": "Interpolante espectral converge suavemente sem Runge phenomenon.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python 3, NumPy, SciPy (fft), Matplotlib",
                                  "tips": "Use pesos barycêntricos para avaliação rápida; np.cos(np.pi * np.arange(N+1)/N).",
                                  "learningObjective": "Entender como pontos não-equidistantes evitam o fenômeno de Runge.",
                                  "commonMistakes": "Confundir pontos Chebyshev com equidistantes ou errar a transformação cos(πk/N)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular erros e taxas de convergência para várias ordens",
                                  "subSteps": [
                                    "Loop sobre N=4,8,12,...,32: compute erro clássico e espectral em cada N.",
                                    "Calcule taxa de convergência: log2(erro_{N}/erro_{2N}) para clássica (ordem finita ~2) e espectral (alta).",
                                    "Armazene erros em arrays e gere tabelas de erros.",
                                    "Crie plots log-log: log(erro) vs log(N) para ambas as métodos.",
                                    "Observe inclinação: ~2 para clássica, exponencial (empinada) para espectral."
                                  ],
                                  "verification": "Tabela e plots mostram erro clássico estagnando ou crescendo, espectral decaindo rapidamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python 3, NumPy, Matplotlib, Pandas (opcional para tabelas)",
                                  "tips": "Use np.log10 para escalas log; inclua legenda clara nos plots.",
                                  "learningObjective": "Quantificar numericamente a superioridade espectral na convergência.",
                                  "commonMistakes": "Não normalizar erros ou usar norma errada (use máximo para Runge)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e comparar as taxas de convergência",
                                  "subSteps": [
                                    "Compare numericamente: ajuste linhas nos plots log-log para taxas.",
                                    "Discuta: clássica O(N^{-k}) para k baixo, espectral exponencial O(e^{-cN}).",
                                    "Gere relatório com tabelas, plots e conclusões sobre Runge phenomenon.",
                                    "Teste função alternativa suave para validar convergência em ambos.",
                                    "Documente insights em um Jupyter notebook."
                                  ],
                                  "verification": "Relatório explica por que espectral > clássica para funções analíticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook, Python 3",
                                  "tips": "Inclua equações matemáticas nos comentários: erro espectral ~ ρ^{-N}.",
                                  "learningObjective": "Sintetizar análise numérica comparativa e conclusões.",
                                  "commonMistakes": "Ignorar efeitos de precisão máquina em N alto; use double precision."
                                }
                              ],
                              "practicalExample": "Em Python: def runge(x): return 1/(1+25*x**2)\nxi_classic = np.linspace(-1,1,11)\nP_classic = lagrange_interp(xi_classic, runge(xi_classic), x_fine)\nPlot mostra oscilações em ±0.9; para Chebyshev: xi_spec = np.cos(np.pi*np.arange(11)/10), sem oscilações.",
                              "finalVerifications": [
                                "Plots de interpolantes mostram Runge phenomenon apenas na clássica.",
                                "Erro máximo clássico > 0.1 para N=20; espectral < 10^{-4}.",
                                "Plot log-log confirma taxa ~2 para clássica e >10 para espectral em N baixo.",
                                "Tabela de erros decrescente exponencialmente na espectral.",
                                "Conclusão escrita diferencia convergência espectral vs. finita.",
                                "Código roda sem erros e reproduz resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos erros (erro < 1e-10 na exata).",
                                "Clareza e legibilidade dos plots (eixos log, legendas).",
                                "Correta implementação de ambos interpoladores.",
                                "Análise quantitativa das taxas via slopes ou ratios.",
                                "Relatório com interpretações matemáticas corretas.",
                                "Eficiência computacional (tempo <1s por N=32).",
                                "Testes com N variados e funções extras."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Métodos espectrais em simulações de ondas/PDEs.",
                                "Ciência da Computação: Algoritmos FFT para interpolação rápida.",
                                "Engenharia: Análise de sinais e processamento digital.",
                                "Estatística: Aproximação de funções em regressão não-linear."
                              ],
                              "realWorldApplication": "Em Dinâmica de Fluidos Computacional (CFD), métodos espectrais resolvem equações de Navier-Stokes com alta precisão em poucos pontos nodais, evitando Runge em simulações de turbulência ou aerodinâmica, economizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Identificar fenômenos de aliasing",
                            "description": "Explicar e mitigar aliasing em expansões espectrais, usando filtros de suavização ou dealiasing 3/2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de aliasing em expansões espectrais",
                                  "subSteps": [
                                    "Estudar a representação de funções por séries de Fourier truncadas e o teorema de Nyquist-Shannon.",
                                    "Analisar como produtos não-lineares geram harmônicos acima da frequência de corte, causando aliasing.",
                                    "Examinar o fenômeno de 'wrap-around' onde energia de alta frequência é projetada em baixa frequência.",
                                    "Revisar equações de interpolação espectral e truncamento de coeficientes.",
                                    "Discutir o impacto no erro de convergência em métodos pseudoespectrais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é aliasing com um diagrama simples de espectro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Canuto et al.), slides sobre séries de Fourier, calculadora simbólica (SymPy ou MATLAB).",
                                  "tips": "Use analogia com amostragem de áudio para visualizar o wrap-around.",
                                  "learningObjective": "Definir aliasing e sua origem em expansões espectrais truncadas.",
                                  "commonMistakes": "Confundir aliasing com ringing (fenômeno de Gibbs); aliasing é específico de discretização não-linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar sinais de aliasing em dados espectrais",
                                  "subSteps": [
                                    "Implementar uma expansão espectral de uma função suave (ex: seno) e uma não-suave (ex: degrau).",
                                    "Calcular e plotar espectros de energia antes e após operação não-linear (multiplicação ponto a ponto).",
                                    "Observar picos espúrios em modos de baixa onda devido a aliasing.",
                                    "Comparar resíduos de interpolação com e sem aliasing.",
                                    "Usar diagnóstico: integral de energia em modos altos vs. esperada."
                                  ],
                                  "verification": "Gerar gráfico mostrando picos aliasados e anotar modos afetados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy/ Matplotlib, ou MATLAB, função teste (ex: sawtooth wave).",
                                  "tips": "Comece com N=32 pontos para aliasing visível; aumente para confirmar.",
                                  "learningObjective": "Reconhecer padrões visuais e quantitativos de aliasing em espectros.",
                                  "commonMistakes": "Ignorar normalização de energia; sempre plote log-escala para espectros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar filtros de suavização para mitigar aliasing",
                                  "subSteps": [
                                    "Implementar filtro low-pass exponencial: multiplicar coeficientes por exp(-k^2 / k_max^2).",
                                    "Escolher parâmetro de suavização baseado em análise de erro.",
                                    "Aplicar filtro pré e pós-operação não-linear.",
                                    "Comparar espectros filtrados vs. não-filtrados.",
                                    "Ajustar hiperparâmetros para equilíbrio entre precisão e dissipação."
                                  ],
                                  "verification": "Redução de pelo menos 50% na energia aliasada em gráfico comparativo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python/MATLAB com FFT/ifft, funções de filtro personalizadas.",
                                  "tips": "Teste com filtro de Orszag para referência padrão.",
                                  "learningObjective": "Implementar e calibrar filtros de suavização eficazes.",
                                  "commonMistakes": "Filtro muito agressivo causa dissipação excessiva; monitore erro L2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar técnica de dealiasing 3/2 rule",
                                  "subSteps": [
                                    "Aumentar grade para 3/2 N pontos, computar produto não-linear na grade estendida.",
                                    "Projetar resultado de volta para N pontos via truncamento ou filtro.",
                                    "Comparar com método sem dealiasing em termos de energia e precisão.",
                                    "Analisar custo computacional (O((3/2 N) log N) vs. O(N log N)).",
                                    "Verificar conservação de energia quadrática."
                                  ],
                                  "verification": "Espectro sem picos aliasados e erro de energia <1%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código otimizado com padding zero para FFT estendida, benchmark de tempo.",
                                  "tips": "Use npad = N//2 * 3 para precisão cúbica; evite arredondamentos.",
                                  "learningObjective": "Aplicar dealiasing 3/2 para eliminar aliasing em produtos não-lineares.",
                                  "commonMistakes": "Padding incorreto leva a vazamento; sempre teste com função conhecida."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e comparar estratégias de mitigação",
                                  "subSteps": [
                                    "Executar simulação completa de equação (ex: Burgers) com e sem mitigação.",
                                    "Quantificar erro de truncamento e aliasing via normas L2/Linf.",
                                    "Plotar convergência em função de N para cada método.",
                                    "Discutir trade-offs: precisão vs. custo.",
                                    "Documentar relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório mostrando superioridade de pelo menos um método em métricas chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código integrado das steps anteriores, solver simples de PDE espectral.",
                                  "tips": "Use tabela comparativa para clareza.",
                                  "learningObjective": "Avaliar e selecionar método de mitigação apropriado.",
                                  "commonMistakes": "Não considerar custo; dealiasing é caro para N grande."
                                }
                              ],
                              "practicalExample": "Em uma simulação da equação de Burgers 1D, u_t + u u_x = nu u_xx, com u0(x) = sin(pi x), observe aliasing no termo u u_x para N=64 sem mitigação (picos em k=2,4). Aplique filtro exponencial (reduz 70% energia aliasada) ou 3/2 rule (elimina completamente), plotando u(t=1) vs. solução exata.",
                              "finalVerifications": [
                                "Explicar mecanismo de aliasing em expansões espectrais truncadas.",
                                "Identificar aliasing em espectro plotado de produto não-linear.",
                                "Implementar filtro de suavização e mostrar redução de energia alta.",
                                "Aplicar dealiasing 3/2 e verificar conservação de energia.",
                                "Comparar erros L2 entre métodos em simulação numérica.",
                                "Discutir limitações de cada técnica."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de aliasing (20%)",
                                "Identificação visual/quantitativa em gráficos (25%)",
                                "Implementação correta de filtros/dealiasing sem erros de código (25%)",
                                "Análise comparativa com métricas quantitativas (20%)",
                                "Relatório claro com trade-offs e conclusões (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de sinais em ondas e processamento de imagens (FFT).",
                                "Computação: Algoritmos de FFT e otimização numérica.",
                                "Engenharia: Simulações CFD onde aliasing afeta precisão em turbulência.",
                                "Estatística: Análise espectral de séries temporais."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), dealiasing 3/2 previne erros em interações não-lineares de ondas atmosféricas; em processamento de imagens médicas, filtros suavizam aliasing em reconstruções tomográficas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Operadores Diferenciais Pseudoespectrais",
                    "description": "Construção de operadores de derivação exata no espaço espectral via transformadas rápidas de Fourier ou matrizes de diferenciação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Espaço Espectral e Transformadas de Fourier",
                        "description": "Representação de funções periódicas no domínio espectral utilizando séries de Fourier discretas e transformadas rápidas de Fourier (FFT) para passagem entre espaços físico e espectral.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Calcular coeficientes de Fourier discretos",
                            "description": "Dado um vetor de valores de uma função periódica em N pontos equidistantes, computar os coeficientes de Fourier complexos utilizando a soma discreta ou FFT, interpretando os modos espectrais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Matemática da DFT",
                                  "subSteps": [
                                    "Estudar a fórmula da DFT: c_k = (1/N) ∑_{n=0}^{N-1} f_n exp(-2πi k n / N) para k=0 a N-1",
                                    "Explicar o papel do fator exponencial como base ortogonal complexa",
                                    "Discutir amostragem equidistante e periodicidade implícita do sinal",
                                    "Identificar c_0 como componente média e c_{N/2} como Nyquist (se N par)",
                                    "Derivar intuitivamente por que a DFT decompõe em modos espectrais"
                                  ],
                                  "verification": "Reescrever a fórmula corretamente e computar c_0 e c_1 manualmente para um vetor simples como [1,1,1,1].",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Referência: Notas de Análise Numérica"
                                  ],
                                  "tips": "Visualize a exponencial como rotação no plano complexo; use ângulos em radianos.",
                                  "learningObjective": "Dominar a fórmula da DFT e interpretar seus componentes espectrais.",
                                  "commonMistakes": [
                                    "Esquecer o 1/N normalizador",
                                    "Confundir o sinal do expoente (- vs +)",
                                    "Índices começando em 1 ao invés de 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular DFT por Soma Direta Manualmente",
                                  "subSteps": [
                                    "Escolher N pequeno (ex: N=4) e vetor f = [1, 0, -1, 0]",
                                    "Computar cada c_k para k=0,1,2,3 usando fórmula explícita",
                                    "Calcular partes real e imaginária separadamente",
                                    "Verificar simetria: c_{N-k} = conj(c_k) para sinais reais",
                                    "Plotar manualmente os coeficientes no plano complexo"
                                  ],
                                  "verification": "Resultados coincidem com valores esperados: c0=0, c1=-0.5i, c2=0, c3=0.5i (até precisão manual).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora com funções complexas"
                                  ],
                                  "tips": "Use tabela para organizar somas; comece com k=0 que é sempre real.",
                                  "learningObjective": "Executar cálculo manual da DFT para entender o processo computacional.",
                                  "commonMistakes": [
                                    "Erros aritméticos em expoentes complexos",
                                    "Não normalizar por 1/N",
                                    "Ignorar conjugação para simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Soma Direta da DFT em Código",
                                  "subSteps": [
                                    "Configurar ambiente Python com NumPy para vetores complexos",
                                    "Escrever função def dft(f): que implementa a soma dupla for n in range(N): for k in range(N):",
                                    "Testar com vetor do Step 2 e comparar com cálculo manual",
                                    "Medir tempo de execução para N=64 e discutir complexidade O(N²)",
                                    "Adicionar plot do espectro de magnitude |c_k|"
                                  ],
                                  "verification": "Código produz coeficientes idênticos ao manual dentro de 1e-12 e plota corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.exp(1j * theta) para complexos; vetorize onde possível mas mantenha loops para clareza.",
                                  "learningObjective": "Programar a DFT direta, expondo limitações computacionais.",
                                  "commonMistakes": [
                                    "Índices off-by-one em loops",
                                    "Não usar np.array para f",
                                    "Confundir range(N) com N pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Comparar com FFT Eficiente",
                                  "subSteps": [
                                    "Importar np.fft.fft e computar para mesmo vetor",
                                    "Comparar resultados e tempos com implementação direta para N=1024",
                                    "Explicar algoritmo Cooley-Tukey (dividir-em-conquistar recursivo)",
                                    "Verificar normalização: fft() usa 1/N implícito em ifft",
                                    "Analisar speedup: O(N log N) vs O(N²)"
                                  ],
                                  "verification": "fft() matches dft() numericamente e é 100x mais rápido para N=1024.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy/FFT",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use %timeit para benchmarks; N potência de 2 otimiza FFT.",
                                  "learningObjective": "Usar FFT prática e quantificar ganhos de eficiência.",
                                  "commonMistakes": [
                                    "Confundir fft vs ifft",
                                    "Esquecer shift fft.fftshift para ordenação frequências",
                                    "N não potência de 2 sem padding"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Modos Espectrais e Visualizar",
                                  "subSteps": [
                                    "Plotar magnitude e fase de |c_k| e arg(c_k)",
                                    "Identificar picos: baixa freq (suavidade), alta freq (oscilações)",
                                    "Reconstruir sinal via IDFT: f_n ≈ ∑ c_k exp(2πi k n / N)",
                                    "Testar aliasing com N insuficiente para sinal de alta freq",
                                    "Discutir modos físicos: c_k como amplitude da onda e^{i 2π k t / T}"
                                  ],
                                  "verification": "Reconstrução via ifft() recupera sinal original dentro de 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/Matplotlib/NumPy"
                                  ],
                                  "tips": "Use fftfreq() para eixos de frequência; log-scale para magnitude.",
                                  "learningObjective": "Interpretar espectro como decomposição em modos e validar inversibilidade.",
                                  "commonMistakes": [
                                    "Interpretar magnitude sem fase",
                                    "Não plotar frequência física f_k = k/(N Δt)",
                                    "Ignorar aliasing"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado vetor f = [1, 0.5, 0, -0.5, -1, -0.5, 0, 0.5] representando amostras de uma onda senoidal com harmônicos, compute DFT/FFT, identifique pico em k=1 (frequência fundamental) e k=3 (terceiro harmônico), e reconstrua o sinal para validar.",
                              "finalVerifications": [
                                "Cálculos manuais, diretos e FFT coincidem numericamente (erro <1e-10)",
                                "Tempo de FFT é significativamente menor que O(N²) para N>512",
                                "Reconstrução via iFFT recupera sinal exato",
                                "Interpretação correta: picos em |c_k| correspondem a frequências dominantes",
                                "Simetria conjugada preservada para sinais reais",
                                "Gráficos de espectro mostram modos espectrais claros"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todos métodos (tol=1e-12)",
                                "Código limpo, comentado e reproduzível",
                                "Compreensão demonstrada em interpretação de espectro (explicação escrita)",
                                "Benchmark correto com speedup quantificado",
                                "Visualizações profissionais (plots rotulados)",
                                "Tratamento de casos edge: N=1, sinal real/DC"
                              ],
                              "crossCurricularConnections": [
                                "Física: Decomposição de ondas em mecânica quântica e clássica",
                                "Engenharia Elétrica: Processamento de sinais digitais (filtros, modulação)",
                                "Ciência da Computação: Algoritmos divide-and-conquer e complexidade",
                                "Processamento de Imagens: Transformadas 2D para compressão JPEG",
                                "Estatística: Análise espectral de séries temporais"
                              ],
                              "realWorldApplication": "Essencial em processamento de áudio (MP3), imagens médicas (MRI/CT), telecomunicações (modems OFDM 5G), análise vibracional (detecção de falhas em máquinas) e simulações numéricas (métodos espectrais em CFD)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Aplicar FFT para ida ao espaço espectral",
                            "description": "Implementar a transformada rápida de Fourier (FFT) em uma função periódica amostrada, verificando a representação exata no domínio das frequências e lidando com aliasing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a função periódica e gerar amostras",
                                  "subSteps": [
                                    "Defina uma função periódica simples, como f(x) = sin(2πx) + 0.5*sin(6πx), com período T=1.",
                                    "Escolha o número de pontos N (potência de 2, ex: 256 ou 512) para amostragem uniforme no intervalo [0, T).",
                                    "Gere o vetor de amostras x = linspace(0, 1, N, endpoint=False) e y = f(x).",
                                    "Calcule o espaçamento Δx = T/N e as frequências associadas k = 0 a N/2.",
                                    "Plote a função no domínio temporal para visualização inicial."
                                  ],
                                  "verification": "Verifique se o array y tem comprimento N e plote mostra a forma periódica correta sem distorções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matplotlib para plotagem",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": [
                                    "Use N potência de 2 para eficiência da FFT.",
                                    "Evite endpoint=True para periodicidade exata."
                                  ],
                                  "learningObjective": "Entender a importância da amostragem uniforme e periódica para FFT precisa.",
                                  "commonMistakes": [
                                    "Usar N não potência de 2, causando ineficiência.",
                                    "Incluir endpoint, gerando descontinuidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a transformada rápida de Fourier (FFT)",
                                  "subSteps": [
                                    "Importe fft de numpy.fft.",
                                    "Aplique Y = fft(y) para obter os coeficientes espectrais.",
                                    "Calcule as frequências físicas ω_k = 2π k / T para k = 0 a N-1.",
                                    "Normalize se necessário: Y_normalized = Y / N.",
                                    "Plote o módulo |Y[k]| para k = 0 a N/2 (parte positiva)."
                                  ],
                                  "verification": "O espectro deve mostrar picos em k=1 e k=3 correspondendo às frequências da função.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy (numpy.fft)",
                                    "Matplotlib"
                                  ],
                                  "tips": [
                                    "Use fftshift se quiser espectro centrado em zero.",
                                    "Sempre divida por N para energia conservada."
                                  ],
                                  "learningObjective": "Dominar a aplicação prática da FFT em dados amostrados.",
                                  "commonMistakes": [
                                    "Esquecer normalização, inflando amplitudes.",
                                    "Plotar todo o espectro sem simetria (apenas até N/2)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a representação exata no domínio das frequências",
                                  "subSteps": [
                                    "Identifique os modos dominantes no espectro |Y[k]|.",
                                    "Compare amplitudes teóricas: para sin(2πkx), |c_k| = 1/2.",
                                    "Reconstrua a função via IFFT: y_rec = ifft(Y).real e compare com y original (erro < 1e-10).",
                                    "Analise a simetria: Y[N-k] = conj(Y[k]) para função real.",
                                    "Plote espectro e sinal reconstruído lado a lado."
                                  ],
                                  "verification": "Erro de reconstrução L2 < 1e-12 e simetria confirmada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy (ifft)",
                                    "Matplotlib"
                                  ],
                                  "tips": [
                                    "Use np.allclose(y, y_rec) para verificação numérica.",
                                    "Ignore parte imaginária pequena por erros de arredondamento."
                                  ],
                                  "learningObjective": "Validar a exatidão da representação espectral via reconstrução.",
                                  "commonMistakes": [
                                    "Não verificar simetria, aceitando espectros assimétricos.",
                                    "Ignorar erros de fase na reconstrução."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com aliasing e validar resultados",
                                  "subSteps": [
                                    "Introduza aliasing adicionando alta frequência: f_alias(x) = sin(2π*10x) com N insuficiente.",
                                    "Aplique FFT e observe vazamento para modos baixos (k< N/2).",
                                    "Aumente N ou use windowing (ex: Hann) para mitigar: y_win = y * hann(N).",
                                    "Compare espectros com e sem aliasing, medindo energia espalhada.",
                                    "Documente condições Nyquist: f_max < N/(2T) para evitar aliasing."
                                  ],
                                  "verification": "Espectro sem aliasing mostra modos limpos; com aliasing, energia espalhada corretamente identificada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NumPy (hann de scipy.signal)",
                                    "Matplotlib"
                                  ],
                                  "tips": [
                                    "Teorema de Nyquist-Shannon: amostragem > 2 f_max.",
                                    "Windowing reduz vazamento mas atenua amplitudes."
                                  ],
                                  "learningObjective": "Compreender e mitigar aliasing na ida ao espaço espectral.",
                                  "commonMistakes": [
                                    "Confundir vazamento com aliasing.",
                                    "Não normalizar após windowing."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere f(x) = sin(2πx) + 0.5*sin(6πx) amostrada em N=256 pontos no [0,1). Após FFT, observe picos em k=1 (amp=0.5) e k=3 (amp=0.25). Adicione sin(20πx) para demonstrar aliasing em k=4.",
                              "finalVerifications": [
                                "Espectro exibe amplitudes e fases corretas para componentes conhecidos.",
                                "Reconstrução via IFFT recupera sinal original com erro numérico mínimo.",
                                "Aliasing é identificado e mitigado por aumento de N ou windowing.",
                                "Simetria conjugada do espectro para sinais reais é confirmada.",
                                "Frequências físicas são corretamente mapeadas aos índices k.",
                                "Plota comparativos mostram ausência de artefatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação FFT (erro reconstrução <1e-10).",
                                "Correta identificação e plotagem do espectro positivo.",
                                "Análise qualitativa e quantitativa de aliasing.",
                                "Uso apropriado de normalização e verificações numéricas.",
                                "Clareza nos plots e documentação de resultados.",
                                "Eficiência computacional com N potência de 2."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e decomposição em Fourier.",
                                "Engenharia Elétrica: Processamento de sinais digitais (DSP).",
                                "Ciência da Computação: Algoritmos de transformada rápida O(N log N).",
                                "Mecânica dos Fluidos: Métodos espectrais em simulações numéricas.",
                                "Processamento de Imagens: Filtros no domínio da frequência."
                              ],
                              "realWorldApplication": "Em simulações de turbulência (CFD espectral), análise de vibrações em engenharia aeroespacial, compressão de áudio (MP3 via MDCT similar a FFT), detecção de falhas em sinais elétricos e processamento de imagens médicas (MRI espectral)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Realizar iFFT para retorno ao espaço físico",
                            "description": "Aplicar a transformada inversa rápida de Fourier (iFFT) aos coeficientes espectrais para recuperar os valores no domínio físico, garantindo normalização correta e precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os coeficientes espectrais",
                                  "subSteps": [
                                    "Identificar os coeficientes espectrais obtidos da FFT forward, garantindo que estejam no formato complexo (real e imaginário).",
                                    "Verificar o tamanho do array: deve ser potência de 2 para eficiência da FFT.",
                                    "Tratar coeficientes simétricos: para dados reais, garantir hermitiana simetria (coeficientes negativos são conjugados dos positivos).",
                                    "Armazenar em estrutura de dados apropriada, como array NumPy."
                                  ],
                                  "verification": "Coeficientes estão em array complexo com simetria hermitiana verificada por comparação manual de pares conjugados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy instalados",
                                    "Notebook Jupyter para testes"
                                  ],
                                  "tips": "Use np.conj() para verificar simetria; visualize com plt.plot() para inspeção.",
                                  "learningObjective": "Compreender a preparação correta dos dados para iFFT, evitando erros de simetria.",
                                  "commonMistakes": [
                                    "Ignorar simetria hermitiana levando a resultados imaginários não nulos",
                                    "Usar array de tamanho não potência de 2",
                                    "Misturar real e imaginário em arrays separados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a função de iFFT",
                                  "subSteps": [
                                    "Importar biblioteca: np.fft.ifft() ou scipy.fft.ifftn() para multi-dimensional.",
                                    "Definir parâmetros: eixos de transformação (axis=-1 para 1D), norma='ortho' ou manual.",
                                    "Preparar grid físico: definir N pontos e dx para reconstrução espacial.",
                                    "Testar com sinal conhecido simples para calibração."
                                  ],
                                  "verification": "Função iFFT configurada retorna sinal senoidal puro quando aplicada a picos Dirac espectrais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação NumPy/FFTW",
                                    "Exemplos de código de FFT básica"
                                  ],
                                  "tips": "Sempre especifique norma='ortho' para consistência com FFT forward; teste com sinal unitário.",
                                  "learningObjective": "Selecionar e configurar corretamente a iFFT para domínio físico.",
                                  "commonMistakes": [
                                    "Esquecer de especificar eixo de transformação em dados multi-D",
                                    "Usar fft() em vez de ifft()",
                                    "Ignorar convenções de normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a iFFT",
                                  "subSteps": [
                                    "Chamar ifft(coeficientes, n=N, axis=-1, norm=None).",
                                    "Capturar resultado complexo e separar real/imaginário com np.real().",
                                    "Aplicar shift periódico se necessário: np.fft.ifftshift() para centralizar.",
                                    "Armazenar valores físicos em grid espacial x = np.arange(N) * dx."
                                  ],
                                  "verification": "Parte imaginária do resultado é próxima de zero (erro < 1e-10).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python pronto",
                                    "Timer para medir performance"
                                  ],
                                  "tips": "Para grandes N, use FFTW via pyFFTW para velocidade; monitore uso de memória.",
                                  "learningObjective": "Executar iFFT de forma eficiente e precisa numericamente.",
                                  "commonMistakes": [
                                    "Não aplicar real() resultando em artefatos imaginários",
                                    "Esquecer fftshift levando a fase errada",
                                    "Sobrecarga de memória em N grande sem chunking"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar e validar precisão",
                                  "subSteps": [
                                    "Calcular fator de normalização: 1/N ou sqrt(1/N) dependendo da convenção usada na FFT.",
                                    "Multiplicar resultado por fator: campo_fisico = np.real(ifft_result) * norm_factor.",
                                    "Comparar com sinal original: calcular erro L2 = np.linalg.norm(original - reconstruido).",
                                    "Verificar conservação de energia: integral do espectro vs domínio físico."
                                  ],
                                  "verification": "Erro L2 < 1e-12 e conservação de energia com tolerância 1e-10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Funções de norma NumPy",
                                    "Gráficos Matplotlib para visualização"
                                  ],
                                  "tips": "Use norma='ortho' para evitar fator manual; plote espectro e físico lado a lado.",
                                  "learningObjective": "Garantir precisão numérica e normalização correta no retorno ao espaço físico.",
                                  "commonMistakes": [
                                    "Fator de normalização invertido (N ao invés de 1/N)",
                                    "Comparação sem shift periódico",
                                    "Tolerar erros altos por aliasing numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma onda senoidal u(x) = sin(2πx/L) em grid de 1024 pontos. Aplique FFT para obter coeficientes, modifique um coeficiente (ex: amplifique modo k=5), execute iFFT com normalização para recuperar u_fisico. Plote original vs reconstruído; erro deve ser <1e-12.",
                              "finalVerifications": [
                                "Parte imaginária do campo físico é zero dentro de precisão máquina.",
                                "Erro L2 entre original e reconstruído < 1e-12.",
                                "Conservação de Parseval: soma |u_fisico|^2 == soma |coef|^2 / N.",
                                "Visualização gráfica mostra sobreposição perfeita.",
                                "Teste com sinal multi-modo recupera todos os componentes.",
                                "Performance: tempo de execução < 1ms para N=2^20."
                              ],
                              "assessmentCriteria": [
                                "Correta preparação e simetria dos coeficientes (20%)",
                                "Configuração precisa da iFFT e execução sem erros (25%)",
                                "Normalização exata e verificação de precisão numérica (25%)",
                                "Validação completa com métricas L2 e Parseval (20%)",
                                "Código limpo, comentado e reproduzível (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e decomposição em modos (Mecânica Quântica, Ondas)",
                                "Computação: Algoritmos numéricos e otimização de performance (Ciência da Computação)",
                                "Engenharia: Simulações CFD e processamento de sinais (Engenharia Mecânica)",
                                "Estatística: Análise espectral de séries temporais"
                              ],
                              "realWorldApplication": "Em simulações pseudoespectrais de equações de Navier-Stokes para dinâmica de fluidos, a iFFT é usada a cada passo temporal para derivar no espaço físico após multiplicação espectral, permitindo simulações precisas de turbulência em aviação e meteorologia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Derivação Exata via Multiplicação Espectral",
                        "description": "Construção de operadores diferenciais no espaço espectral por multiplicação pontual pelos fatores ik, permitindo derivação espectral exata para funções trigonométricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Construir vetor de multiplicadores ik",
                            "description": "Para N pontos e frequências k = -N/2 ... N/2-1, gerar o vetor de multiplicadores ik para a primeira derivada, considerando periodicidade e tratamento do modo zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros e gerar vetor de frequências k",
                                  "subSteps": [
                                    "Escolha o número de pontos N (ex: N par para simplicidade).",
                                    "Determine o range de k: de 0 até N/2 - 1, seguido de -N/2 até -1.",
                                    "Crie um array k de tamanho N com esses valores sequencialmente.",
                                    "Use fórmula padrão: k[j] = j para j=0 a N/2-1, k[j] = j - N para j=N/2 a N-1.",
                                    "Verifique se k[0]=0 e simetria (k[-m] = -k[m] para m>0)."
                                  ],
                                  "verification": "Liste k para N=8 e confirme: [0,1,2,3,-4,-3,-2,-1].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Python com NumPy (np.fft.fftfreq(N)*N)"
                                  ],
                                  "tips": "Use np.fft.fftfreq(N) * N para gerar k automaticamente e evitar erros manuais.",
                                  "learningObjective": "Compreender e gerar corretamente o vetor de frequências discretas k para FFT com N pontos.",
                                  "commonMistakes": "Esquecer o wrap-around negativo ou incluir k=N/2 incorretamente como positivo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar vetor de multiplicadores como complexos",
                                  "subSteps": [
                                    "Crie um array m de tamanho N com dtype=complex128.",
                                    "Inicialize todos elementos como 0j.",
                                    "Confirme que o array suporta números imaginários (use 1j em Python).",
                                    "Associe índices de m aos de k.",
                                    "Planeje multiplicação elemento a elemento."
                                  ],
                                  "verification": "Imprima m inicial e confirme todos zeros complexos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Calculadora para testes manuais"
                                  ],
                                  "tips": "Sempre use dtype=complex para evitar erros de tipo em multiplicações imaginárias.",
                                  "learningObjective": "Preparar estrutura de dados adequada para multiplicadores espectrais complexos.",
                                  "commonMistakes": "Usar arrays reais em vez de complexos, causando perda da parte imaginária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular multiplicadores ik para cada frequência",
                                  "subSteps": [
                                    "Para cada índice j, defina m[j] = 1j * k[j].",
                                    "Aplique multiplicação escalar elemento a elemento (m = 1j * k).",
                                    "Verifique que para k>0, Im(m)>0; para k<0, Im(m)<0.",
                                    "Confirme periodicidade implícita pelo wrap-around de k.",
                                    "Salve ou imprima o vetor m completo."
                                  ],
                                  "verification": "Para N=6, m deve ser [0j, 1j, 2j, -3j, -2j, -1j].",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Editor de código"
                                  ],
                                  "tips": "Vectorize com NumPy: m = 1j * k para eficiência e precisão.",
                                  "learningObjective": "Implementar a multiplicação espectral ik para derivação primeira.",
                                  "commonMistakes": "Usar i real em vez de 1j, ou inverter sinal para k negativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar modo zero e validar propriedades do vetor",
                                  "subSteps": [
                                    "Explicitamente defina m[0] = 0j (derivada de constante é zero).",
                                    "Verifique anti-simétria: m[N//2 + j] ≈ -m[j] para j pequeno.",
                                    "Confirme que todos elementos são puramente imaginários (parte real zero).",
                                    "Teste com FFT de uma função conhecida (ex: seno) e derivada analítica.",
                                    "Documente o vetor para uso em operador diferencial."
                                  ],
                                  "verification": "Parte real de todos m == 0 e m[0] == 0j.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy e FFT",
                                    "Gráfico para visualização"
                                  ],
                                  "tips": "Plote Im(m) vs k para visualizar a rampa linear anti-simétrica.",
                                  "learningObjective": "Garantir tratamento correto do modo DC e propriedades espectrais.",
                                  "commonMistakes": "Não zerar k=0 ou ignorar Nyquist (k=±N/2) em N par."
                                }
                              ],
                              "practicalExample": "Para N=8: k = [0, 1, 2, 3, -4, -3, -2, -1]; ik = [0j, 1j, 2j, 3j, -4j, -3j, -2j, -1j]. Em Python: import numpy as np; k = np.fft.fftfreq(8)*8; ik = 1j * k.",
                              "finalVerifications": [
                                "Vetor k possui exatamente N elementos com range correto de -N/2 a N/2-1.",
                                "ik[0] == 0j e todos elementos são puramente imaginários.",
                                "Para k[m] = p >0, ik[índice de -p] = -ik[índice de p].",
                                "Multiplicação por coeficientes Fourier de sin(2π x) reproduz derivada cos(2π x).",
                                "Implementação vectorizada executa sem erros numéricos.",
                                "Propriedade de periodicidade mantida (wrap-around correto)."
                              ],
                              "assessmentCriteria": [
                                "Correção do vetor k (100% match com fftfreq padrão).",
                                "Precisão dos multiplicadores ik (erro <1e-10).",
                                "Tratamento explícito do modo zero (k=0).",
                                "Eficiência da implementação (vectorizada, não loop lento).",
                                "Validação com teste unitário (derivada de função conhecida).",
                                "Documentação clara do código ou passos manuais."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais: Filtros diferenciais em domínio frequência.",
                                "Física Computacional: Simulações de ondas e PDEs periódicas.",
                                "Engenharia de Computação: Otimização de algoritmos FFT.",
                                "Análise de Dados: Derivação numérica em séries temporais."
                              ],
                              "realWorldApplication": "Esse vetor é essencial em solvers pseudoespectrais para simular equações diferenciais parciais (PDEs) em domínios periódicos, como equações de Navier-Stokes em turbulência, modelos climáticos globais e propagação de ondas em aerodinâmica computacional, permitindo derivadas exatas e eficientes via FFT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Aplicar operador de derivação espectral",
                            "description": "Transformar função via FFT, multiplicar coeficientes por ik, e aplicar iFFT para obter a derivada exata no espaço físico, comparando com derivadas finitas para validar precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e discretizar a função teste no domínio espacial",
                                  "subSteps": [
                                    "Escolha uma função suave de teste, como f(x) = sin(2πx) ou exp(-x²), conhecida para validação.",
                                    "Defina o domínio espacial, ex: x ∈ [0, 2π] ou [-π, π], e o número de pontos N (potência de 2, ≥256 para precisão).",
                                    "Crie o grid espacial uniforme: dx = L/N, x = linspace(0, L, N, endpoint=False).",
                                    "Avalie f(x) nos pontos do grid para obter o vetor f.",
                                    "Visualize f(x) com plot para confirmar a discretização."
                                  ],
                                  "verification": "Grid x tem N pontos uniformes e f(x) é plotado corretamente sem artefatos de amostragem.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use N=512 ou maior para minimizar aliasing; evite funções com descontinuidades.",
                                  "learningObjective": "Entender a discretização pseudoespectral e importância de grids uniformes.",
                                  "commonMistakes": [
                                    "Usar endpoint=True causando duplicação de pontos",
                                    "Escolher N não potência de 2 degradando FFT",
                                    "Funções não-periódicas causando Gibbs phenomenon"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a Transformada de Fourier Rápida (FFT) da função",
                                  "subSteps": [
                                    "Importe numpy.fft e compute f_hat = fft(f).",
                                    "Verifique que f_hat tem shape (N,) e é complexa.",
                                    "Plote Re(f_hat) e Im(f_hat) vs. frequências para inspeção.",
                                    "Confirme simetria hermitiana para funções reais: f_hat[N//2+1:] é conjugado de f_hat[1:N//2][::-1].",
                                    "Teste reconstrução: ifft(f_hat).real deve igualar f dentro de 1e-12."
                                  ],
                                  "verification": "Reconstrução via iFFT recupera f original com erro <1e-10.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "NumPy.fft"
                                  ],
                                  "tips": "Use fft.fftfreq(N, dx) para obter frequências k físicas.",
                                  "learningObjective": "Dominar aplicação da FFT e interpretação dos coeficientes espectrais.",
                                  "commonMistakes": [
                                    "Esquecer de usar .real na reconstrução",
                                    "Não normalizar dx corretamente nas frequências",
                                    "Ignorar que FFT é não-normalizada em NumPy"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o operador de derivação espectral (multiplicadores ik)",
                                  "subSteps": [
                                    "Compute wavenumbers k = 2π * fftfreq(N, dx), com k[0]=0 e k[N//2]= -k[1] para periódica.",
                                    "Crie o multiplicador deriv = 1j * k (use 1j para imaginária positiva).",
                                    "Verifique: para k=0, deriv=0; para modos altos, |deriv| cresce linearmente.",
                                    "Plote |deriv| vs k para visualizar o filtro de derivação.",
                                    "Ajuste convenção de sinal se necessário (testar com função conhecida)."
                                  ],
                                  "verification": "Multiplicador é puro imaginário, zero em DC, e anti-simétrico em k positivos/negativos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy arrays para k e deriv"
                                  ],
                                  "tips": "Para derivada segunda, use -k²; generalize para ordens superiores.",
                                  "learningObjective": "Compreender representação algébrica exata da derivada no espaço de Fourier.",
                                  "commonMistakes": [
                                    "Usar k = fftfreq sem 2π/dx",
                                    "Confundir sinal de 1j vs -1j",
                                    "Não tratar k[N//2] corretamente (aliasing)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o operador e computar a derivada via iFFT",
                                  "subSteps": [
                                    "Multiplique df_hat = deriv * f_hat.",
                                    "Compute df = ifft(df_hat).real (descartar parte imaginária pequena).",
                                    "Plote df vs x para inspeção visual.",
                                    "Verifique norma L2: ||df|| deve ser consistente com amplificação espectral.",
                                    "Compare ponto-a-ponto com derivada analítica conhecida."
                                  ],
                                  "verification": "Erro máximo com analítica <1e-8 e imaginário <1e-12.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "NumPy fft.ifft"
                                  ],
                                  "tips": "Shifte fftshift se plotando para centralizar zero-frequency.",
                                  "learningObjective": "Executar derivação espectral completa e validar numericamente.",
                                  "commonMistakes": [
                                    "Esquecer .real no resultado iFFT",
                                    "Não multiplicar por dx na norma",
                                    "Perder precisão em modos altos por N pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar precisão comparando com derivadas finitas",
                                  "subSteps": [
                                    "Implemente derivada finita central: df_fd[i] = (f[i+1]-f[i-1])/(2*dx), com padding periódico.",
                                    "Compute erro espectral: max(|df - df_anal|), erro finito: max(|df - df_fd|).",
                                    "Plote erros vs N ou vs modo para convergência espectral (exponencial).",
                                    "Calcule ordem de precisão: log(erros) deve ser linear em log(N).",
                                    "Documente: espectral >> finita para funções suaves."
                                  ],
                                  "verification": "Erro espectral << erro finita (ordens de magnitude), convergência confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código custom para finite difference"
                                  ],
                                  "tips": "Use periodic BC: f[0] com f[-1], f[N] com f[1].",
                                  "learningObjective": "Demonstrar superioridade pseudoespectral sobre métodos locais.",
                                  "commonMistakes": [
                                    "Não usar diferenças centrais de 2a ordem",
                                    "Ignorar erros de fronteira em finita",
                                    "Comparar sem normalizar por dx"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = sin(2πx) em [0,1) com N=512, dx=1/512. Derivada analítica: df=2π cos(2πx). Após FFT, multiplique por 1j*k (k=2π n), iFFT dá df exata (erro~1e-12). Derivada finita: erro~1e-3.",
                              "finalVerifications": [
                                "Derivada espectral reconstrói analítica com erro <1e-10 em todos pontos.",
                                "Reconstrução iFFT de f_hat recupera f original com precisão máquina.",
                                "Multiplicador ik é corretamente anti-simétrico e zero em k=0.",
                                "Erro espectral é exponencialmente menor que finita ao dobrar N.",
                                "Plots mostram ausência de oscilações de Gibbs ou aliasing.",
                                "Norma L2 de df bate com expectativa teórica."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de FFT/iFFT com validação de reconstrução (peso 20%).",
                                "Construção precisa de k e ik, com plot de verificação (peso 25%).",
                                "Cálculo de df com erro numérico mínimo vs analítica (peso 20%).",
                                "Implementação e comparação robusta com derivada finita (peso 20%).",
                                "Análise de convergência e documentação de erros (peso 10%).",
                                "Código limpo, comentado e reproduzível (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Derivação em solvers de PDEs (ex: equação de onda).",
                                "Processamento de Sinais: Filtros diferenciais em áudio/imagens.",
                                "Engenharia: Simulações CFD (Navier-Stokes pseudoespectral).",
                                "Ciência de Dados: Análise espectral em séries temporais.",
                                "Matemática Pura: Teoria de Fourier e álgebra de operadores."
                              ],
                              "realWorldApplication": "Em simulações numéricas de turbulência (DNS de Navier-Stokes), onde derivações exatas espectrais permitem resoluções altas sem dissipação numérica artificial, usadas em previsão climática, aerodinâmica e modelagem de plasmas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.3",
                              "10.1.7.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Estender para derivadas de ordem superior",
                            "description": "Generalizar o operador para derivadas de segunda e terceira ordens usando (ik)^m, aplicando em funções suaves e analisando convergência espectral exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Derivada de Primeira Ordem e Introduzir Generalização",
                                  "subSteps": [
                                    "Revise a transformação de Fourier rápida (FFT) para derivada de primeira ordem: multiplicar coeficientes espectrais por ik.",
                                    "Derive a fórmula geral para a m-ésima derivada: multiplicar por (ik)^m, onde k é a frequência espacial.",
                                    "Explique por que isso funciona para funções suaves: propriedades da transformada de Fourier.",
                                    "Implemente um exemplo simples em código para m=1 e valide contra derivada analítica.",
                                    "Discuta limitações iniciais, como aliasing para funções não-suaves."
                                  ],
                                  "verification": "Compare a derivada numérica com a analítica para uma função teste (ex: sin(x)) com erro < 1e-6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter com NumPy/FFT, documentação SciPy FFT, calculadora simbólica (SymPy).",
                                  "tips": "Use funções periódicas para evitar problemas de fronteira.",
                                  "learningObjective": "Compreender a extensão algébrica de ik para (ik)^m.",
                                  "commonMistakes": "Confundir i^k com (ik)^m; esquecer normalização da FFT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Operador para Derivada de Segunda Ordem",
                                  "subSteps": [
                                    "Escolha uma função suave teste, como exp(-x^2), e compute FFT.",
                                    "Multiplique coeficientes por (ik)^2 = -k^2 e aplique iFFT para obter segunda derivada.",
                                    "Valide numericamente: compare com d^2/dx^2 exp(-x^2) = (4x^2 - 2)exp(-x^2).",
                                    "Teste convergência variando N (número de pontos): plote erro vs N.",
                                    "Ajuste para dealiasing usando padding de zeros."
                                  ],
                                  "verification": "Erro L2 da segunda derivada < 1e-8 para N=256.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python (NumPy, Matplotlib), grade uniforme com 2π periodicidade.",
                                  "tips": "Padronize k como fftfreq(N, dx) para precisão.",
                                  "learningObjective": "Aplicar operador para m=2 em funções suaves.",
                                  "commonMistakes": "Não tratar k=0 corretamente (derivada zero); ignorar fator 2π na discretização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Terceira Ordem e Funções Complexas",
                                  "subSteps": [
                                    "Generalize código para m=3: (ik)^3 = -i k^3.",
                                    "Teste com função suave não-analítica, como solução de EDO periódica.",
                                    "Implemente função genérica def spectral_deriv(u, m, dx): para qualquer m.",
                                    "Aplique em múltiplas derivadas sequencialmente e compare com aplicação única.",
                                    "Analise estabilidade: rode para m até 5 e observe amplificação espectral."
                                  ],
                                  "verification": "Derivada terceira matches analítica ou finita-diferenças de alta ordem com erro relativo < 1e-7.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "SymPy para validação simbólica, SciPy para diferenças finitas de referência.",
                                  "tips": "Use rfft para funções reais e eficiência.",
                                  "learningObjective": "Criar operador genérico para ordens superiores.",
                                  "commonMistakes": "Fases erradas em (ik)^m para m ímpar; overflow em k altos sem truncamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Convergência Espectral Exponencial",
                                  "subSteps": [
                                    "Teoria: lembre que para funções suaves, coeficientes de Fourier decaem exponencialmente ~ exp(-c |k|).",
                                    "Compute erro de derivada m-ésima vs N, plote log-log para expoente.",
                                    "Demonstre amplificação: | (ik)^m | ~ |k|^m, mas decaimento domina para suaves.",
                                    "Compare com diferenças finitas: pseudoespectral converge mais rápido.",
                                    "Conclua com condições para convergência: suavidade C^∞ e periodicidade."
                                  ],
                                  "verification": "Gráfico mostra convergência exponencial (slope >1 em log-erro vs log-N).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Matplotlib para plots de convergência, funções teste como sech(x).",
                                  "tips": "Use logscale para visualizar expoentes.",
                                  "learningObjective": "Interpretar e validar convergência espectral.",
                                  "commonMistakes": "Testar funções não-suaves (ex: step), levando a aliasing; confundir taxa com ordem."
                                }
                              ],
                              "practicalExample": "Implemente o operador em Python para computar a terceira derivada de u(x) = sin(2x) + 0.1*exp(sin(3x)) em [0,2π] com N=512. Valide contra SymPy: erro deve ser <1e-10. Plote u, u''', espectro amplificado.",
                              "finalVerifications": [
                                "Código genérico computa derivadas até ordem 5 com erro <1e-8.",
                                "Plots de convergência confirmam decaimento exponencial para funções suaves.",
                                "Comparação com diferenças finitas mostra superioridade espectral.",
                                "Dealiasing via padding reduz erro em 2 ordens de magnitude.",
                                "Aplicação sequencial matches aplicação única para ordens compostas.",
                                "Análise espectral mostra |ĉ_k| ~ exp(-|k|) para teste suave."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro L∞ <1e-8 para N=512.",
                                "Generalidade: código funciona para qualquer m≤10.",
                                "Eficiência: tempo O(N log N) via FFT.",
                                "Validação teórica: explicação correta de (ik)^m e suavidade.",
                                "Visualizações: plots claros de erro e espectro.",
                                "Tratamento de edge cases: k=0, funções reais/imag.",
                                "Documentação: comentários explicando cada multiplicação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de EDOs não-lineares como KdV via pseudoespectral.",
                                "Engenharia: Simulações de ondas em acústica/fluidos.",
                                "Computação Científica: Otimização em ML para funções ativas suaves.",
                                "Análise: Teoria de Fourier e séries trigonométricas.",
                                "Processamento de Sinais: Filtros diferenciais em imagens/sons."
                              ],
                              "realWorldApplication": "Em simulações de turbulência DNS (Direct Numerical Simulation), operadores pseudoespectrais com derivadas de alta ordem resolvem equações de Navier-Stokes com precisão exponencial, essenciais para previsão climática, aerodinâmica e design de turbinas eólicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Matrizes de Diferenciação Pseudoespectrais",
                        "description": "Construção de matrizes densas D que representam operadores de derivação exata em bases de polinômios (ex: Chebyshev ou Legendre) nos pontos de Gauss-Lobatto.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Construir matriz de diferenciação para base de Fourier",
                            "description": "Derivar a matriz D_N cujos elementos são baseados em somas de Fourier, tal que D_N u = derivada de u em N pontos equidistantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a grade equidistante e a Transformada Discreta de Fourier (DFT)",
                                  "subSteps": [
                                    "Escolha N par, defina pontos x_j = 2π j / N para j = 0, 1, ..., N-1 no intervalo [0, 2π).",
                                    "Escreva a DFT: \\hat{u}_k = (1/N) ∑_{j=0}^{N-1} u(x_j) e^{-i k x_j} para k = 0, ..., N-1, onde modos negativos são k = N/2 +1 a N-1 mapeados como k - N.",
                                    "Escreva a IDFT: u(x_j) = ∑_{k=0}^{N-1} \\hat{u}_k e^{i k x_j}.",
                                    "Implemente a matriz F cujos elementos F_{j k} = (1/√N) e^{i k x_j} (normalizada unitary).",
                                    "Verifique a unitariedade: F^{-1} = F^H (conjugada transposta)."
                                  ],
                                  "verification": "Confirme que F F^H = I aplicando numericamente para N=8.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Spectral Methods in MATLAB' de Trefethen",
                                    "Python com NumPy e SciPy",
                                    "Papel e caneta para derivações"
                                  ],
                                  "tips": "Use convenções consistentes para índices de k (0 a N-1 com wrap-around para negativos).",
                                  "learningObjective": "Compreender a representação discreta da base de Fourier em grade equidistante.",
                                  "commonMistakes": [
                                    "Confundir fatores de normalização 1/N vs 1/√N",
                                    "Índices errados para modos negativos",
                                    "Esquecer o intervalo [0, 2π)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a ação da derivada na base espectral de Fourier",
                                  "subSteps": [
                                    "Considere u(x) = ∑_{k=-M}^M \\hat{u}_k e^{i k x}, onde M = (N/2)-1.",
                                    "Derive u'(x) = ∑_{k=-M}^M (i k) \\hat{u}_k e^{i k x}.",
                                    "No espaço discreto, o vetor de derivadas u' em x_j é F^{-1} Λ F u, onde Λ = diag(i k) com k de -M a M mapeados em 0 a N-1.",
                                    "Defina explicitamente k: k = [0,1,...,N/2-1, -N/2, ..., -1] para índices 0 a N-1.",
                                    "Confirme que para funções analíticas, isso é exato para polinômios trigonométricos até grau N/2."
                                  ],
                                  "verification": "Aplique a uma função conhecida como u(x) = sin(x); verifique se coefs de derivada são i k vezes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Trefethen Capítulo 2-3",
                                    "SymPy para derivações simbólicas",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Mantenha a base não-normalizada inicialmente para simplicidade, normalize depois.",
                                  "learningObjective": "Dominar como a diferenciação é diagonal na base de Fourier.",
                                  "commonMistakes": [
                                    "Erros no sinal de i k para modos negativos",
                                    "Não mapear corretamente k negativos",
                                    "Ignorar fator i vs apenas k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir explicitamente a matriz de diferenciação D_N",
                                  "subSteps": [
                                    "Escreva D_N = F^{-1} Λ F, onde Λ_{kk} = i k.",
                                    "Derive fórmula fechada para elementos: D_{m n} = (1/N) ∑_{k=0}^{N-1} (i k) e^{i k (x_m - x_n)}.",
                                    "Implemente numericamente: crie F, Λ, compute D_N = F.conj().T @ Λ @ F / N (ajustar normalização).",
                                    "Para N pequeno (ex: N=6), compute manualmente alguns elementos e verifique.",
                                    "Otimize usando FFT: D_N u = ifft( i k .* fft(u) )."
                                  ],
                                  "verification": "Para N=4, compare elementos computados com fórmula analítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy/SciPy para matmul e fft",
                                    "MATLAB ou Octave",
                                    "Artigo de Weideman sobre fórmulas exatas"
                                  ],
                                  "tips": "Use fft/ifft built-in para eficiência; evite loops para grandes N.",
                                  "learningObjective": "Construir e computar a matriz D_N de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Normalização errada em F (use fftnorm='ortho')",
                                    "Índices off-by-one em k",
                                    "Não tratar k=0 e k=N/2 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades e testar a matriz D_N",
                                  "subSteps": [
                                    "Verifique que D_N é anti-hermitiana: D_N^H = -D_N (para derivada real).",
                                    "Teste em funções suaves: u(x)=cos(x), compute ||D_N u - u'_num|| pequeno.",
                                    "Confirme exatidão espectral: para polinômios de grau < N/2, erro zero.",
                                    "Analise estabilidade: eigenvalues de D_N devem ser i k reais imaginários.",
                                    "Compare com diferenças finitas de ordem alta para validar."
                                  ],
                                  "verification": "Erro relativo < 1e-12 para teste sin(x) em N=16.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python/MATLAB de testes",
                                    "Funções de plotagem para visualizar u vs u'"
                                  ],
                                  "tips": "Use grids finas para referência; plote para inspeção visual.",
                                  "learningObjective": "Validar a corretude e propriedades da matriz construída.",
                                  "commonMistakes": [
                                    "Não checar periodicidade nas funções teste",
                                    "Usar N ímpar (prefira par)",
                                    "Ignorar erros de arredondamento em FFT"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=8, construa D_8. Tome u_j = sin(x_j). Compute v = D_8 @ u, compare com cos(x_j) (erro deve ser ~1e-15). Implemente em Python: use np.fft.fft e diag(1j * k_arr).",
                              "finalVerifications": [
                                "D_N satisfaz D_N u ≈ u' para funções suaves periódicas.",
                                "Elementos D_{m n} corretos via soma explícita para N≤16.",
                                "Matriz é skew-hermitiana: im(D_N) simétrica, re(D_N) anti-simétrica.",
                                "Exatidão para interpolantes trigonométricos de grau ≤ N/2 -1.",
                                "Eficiência: tempo de aplicação via FFT é O(N log N).",
                                "Estabilidade numérica: cond(D_N) razoável para N moderado."
                              ],
                              "assessmentCriteria": [
                                "Derivação correta da fórmula D_{m n}.",
                                "Implementação numérica precisa (erro <1e-12).",
                                "Compreensão de normalização e mapeamento de k.",
                                "Verificações completas incluindo propriedades espectrais.",
                                "Eficiência: uso de FFT ao invés de matmul direta.",
                                "Explicação clara de limitações (Runge phenomenon para não-periódicas)."
                              ],
                              "crossCurrularConnections": [
                                "Física: Operadores diferenciais em equações de onda e Schrödinger via pseudoespectrais.",
                                "Ciência da Computação: Algoritmos FFT rápidos (Cooley-Tukey).",
                                "Engenharia: Simulações CFD (dinâmica de fluidos computacional).",
                                "Processamento de Sinais: Filtros diferenciais em domínio frequência."
                              ],
                              "realWorldApplication": "Usado em solvers pseudoespectrais para PDEs não-lineares como Navier-Stokes em turbulência, modelagem climática global e simulações de fusão nuclear, onde alta precisão e eficiência são cruciais para resoluções altas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Implementar matriz para pontos de Gauss-Lobatto",
                            "description": "Calcular elementos da matriz de diferenciação D em nós de Chebyshev-Lobatto usando fórmulas explícitas envolvendo csc ou derivadas de Lagrange, para funções não-periódicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar os pontos Chebyshev-Gauss-Lobatto e vetor de fatores c",
                                  "subSteps": [
                                    "Defina o número de pontos N (ex: N=10 para testes iniciais).",
                                    "Gere os pontos x_j = cos(π * j / N) para j = 0 a N, mapeando o intervalo [-1, 1].",
                                    "Crie o vetor c onde c_0 = 2, c_N = 2, e c_j = 1 para 0 < j < N.",
                                    "Visualize os pontos plotando x_j para confirmar distribuição (mais densos nas extremidades).",
                                    "Salve x e c em arrays NumPy para uso posterior."
                                  ],
                                  "verification": "Execute print(x) e print(c); confirme que x[0]=-1, x[N]=1 (aprox.), c[0]=2, c[1]=1, c[N]=2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook ou script Python",
                                    "Documentação de métodos espectrais (Trefethen Spectral Methods)"
                                  ],
                                  "tips": "Use np.linspace(0, np.pi, N+1)[::-1] para gerar x de forma eficiente e precisa.",
                                  "learningObjective": "Compreender a distribuição não-uniforme dos pontos Lobatto e seu papel na estabilidade espectral.",
                                  "commonMistakes": [
                                    "Confundir Gauss-Legendre com Gauss-Lobatto (Lobatto inclui extremidades)",
                                    "Esquecer de inverter a ordem para x decrescente",
                                    "Usar c_j=1 para todos os pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar elementos off-diagonal da matriz D usando fórmula de Lagrange diferenciada",
                                  "subSteps": [
                                    "Inicialize uma matriz D de tamanho (N+1) x (N+1) com zeros usando np.zeros((N+1, N+1)).",
                                    "Para cada j de 0 a N: para cada k de 0 a N, se j != k: D[j,k] = (-1)**(j+k) * c[j] / c[k] / (x[j] - x[k]).",
                                    "Trate potências com np.power(-1, j+k) ou (-1)**(j+k) para evitar warnings.",
                                    "Evite divisão por zero verificando j != k explicitamente.",
                                    "Imprima alguns elementos, como D[0,1] e D[N,N-1], para inspeção inicial."
                                  ],
                                  "verification": "Cheque que D[0,1] ≈ - (N**2 + 0.5) ou valor esperado para N pequeno; sem NaNs ou infs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy para operações vetoriais",
                                    "Função np.outer ou loops duplos otimizados"
                                  ],
                                  "tips": "Vetorize o loop interno usando broadcasting para acelerar: D[j, np.arange(N+1)!=j] = ...",
                                  "learningObjective": "Dominar a fórmula explícita D_{jk} = (-1)^{j+k} c_j / (c_k (x_j - x_k)) para j≠k.",
                                  "commonMistakes": [
                                    "Inverter c_j e c_k",
                                    "Esquecer o fator (-1)^{j+k}",
                                    "Não tratar precisão numérica perto das extremidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular elementos da diagonal e finalizar a matriz D",
                                  "subSteps": [
                                    "Para cada j de 0 a N: D[j,j] = -np.sum(D[j, np.arange(N+1)!=j]).",
                                    "Use a fórmula especial para precisão nas bordas: D[0,0] = (2*N**2 + 1)/6; D[N,N] = -(2*N**2 + 1)/6.",
                                    "Ajuste D[0,N] e D[N,0] se necessário para consistência.",
                                    "Salve a matriz D em um arquivo .npy ou visualize com plt.imshow(D).",
                                    "Confirme propriedades: soma das linhas internas ≈0, bordas específicas."
                                  ],
                                  "verification": "Verifique D[0,0] == (2*N**2 +1)/6; soma de cada linha j=1..N-1 ≈0 (erro <1e-12).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy sum e indexing booleano",
                                    "Matplotlib para visualização"
                                  ],
                                  "tips": "Sempre sobreponha as fórmulas especiais nas bordas após o sum para precisão máquina.",
                                  "learningObjective": "Entender que a diagonal garante exatidão para polinômios de grau <=N.",
                                  "commonMistakes": [
                                    "Não usar fórmulas especiais para D_{00} e D_{NN}",
                                    "Erros de acumulação numérica em sums grandes para N alto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a matriz D com funções de teste e validar precisão",
                                  "subSteps": [
                                    "Defina uma função suave u(x) = sin(π x) ou exp(x), avalie u em x_j.",
                                    "Compute u_x aproximada: D @ u.",
                                    "Calcule derivada analítica u'(x_j) e compare erro ||u_x - u' || / ||u'|| < 1e-10.",
                                    "Teste com N=8,16; plote erros vs N para ver convergência espectral.",
                                    "Implemente uma função de verificação reutilizável."
                                  ],
                                  "verification": "Erro de derivação < 1e-12 para polinômios exatos; convergência exponencial para N crescente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy para multiplicação matricial",
                                    "SciPy para funções teste",
                                    "Matplotlib para plots de erro"
                                  ],
                                  "tips": "Use funções analiticamente diferenciáveis; teste também com runge現象 functions.",
                                  "learningObjective": "Validar implementação através de convergência espectral em funções não-periódicas.",
                                  "commonMistakes": [
                                    "Mapear incorretamente para [-1,1]",
                                    "Comparar sem normalizar erros",
                                    "Ignorar conditioning da matriz para N grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=6, gere x = cos(π*[0:6]/6), c=[2,1,1,1,1,1,2]. Compute D (ex: D[0,0]≈70.111). Aplique a u(x)=sin(π x /2), u'=(π/2)cos(π x /2); erro máx <1e-13.",
                              "finalVerifications": [
                                "Matriz D satisfaz fórmulas especiais nas bordas (D00=(2N²+1)/6).",
                                "Soma de linhas internas =0 (erro <1e-14).",
                                "Derivada de polinômio de grau N exata (erro máquina).",
                                "Convergência espectral: erro O(e^{-N}) para funções analíticas.",
                                "Sem NaNs/infs para N até 100.",
                                "Simetria aproximada D ≈ -D^T para interior."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro de teste <1e-12.",
                                "Eficiência: tempo O(N²) aceitável para N<1000.",
                                "Robustez: funciona para múltiplos N sem crashes.",
                                "Código limpo: vetorizado, comentado, modular.",
                                "Validação completa: pelo menos 3 funções teste.",
                                "Documentação: explica fórmulas e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: operadores diferenciais em simulações de PDEs (equação de calor).",
                                "Programação Científica: otimização de loops em NumPy/SciPy.",
                                "Engenharia: métodos espectrais em controle e aerodinâmica.",
                                "Análise Matemática: aproximação de Lagrange e estabilidade numérica."
                              ],
                              "realWorldApplication": "Implementação de solvers pseudoespectrais para equações diferenciais em domínios [-1,1], como modelagem de ondas acústicas, fluxos viscosos (Navier-Stokes truncado) ou otimização em finanças quantitativas, onde alta precisão com poucos pontos é crucial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Aplicar matriz D em aproximações espectrais",
                            "description": "Multiplicar vetor de coeficientes ou valores nodais pela matriz D para obter derivadas, avaliando estabilidade e precisão em problemas de valor inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Matriz de Diferenciação D para Pontos Pseudoespectrais",
                                  "subSteps": [
                                    "Escolha o tipo de pontos nodais (ex: Chebyshev-Gauss-Lobatto) e defina o número de pontos N.",
                                    "Calcule os pontos nodais x_k e pesos associados usando fórmulas padrão ou bibliotecas como Chebfun.",
                                    "Construa a matriz D computando as derivadas de Lagrange nos pontos nodais: D_{kj} = l_j'(x_k).",
                                    "Verifique a propriedade de soma das linhas para pontos de Chebyshev (suma zero exceto primeira linha).",
                                    "Implemente em código (Python/NumPy ou MATLAB) para automação."
                                  ],
                                  "verification": "Matriz D simétrica para N par em Chebyshev e primeira linha soma a 0; teste com derivada conhecida de polinômio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lápis, papel, computador com Python/NumPy ou MATLAB; referência: Trefethen 'Spectral Methods in MATLAB'.",
                                  "tips": "Use funções prontas como chebdiff(N) em MATLAB para validar sua implementação manual.",
                                  "learningObjective": "Compreender a formação da matriz D e sua representação do operador diferencial.",
                                  "commonMistakes": "Confundir pontos nodais com raízes; ignorar fator de escala no domínio [-1,1]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a Função Aproximada em Valores Nodais ou Coeficientes",
                                  "subSteps": [
                                    "Defina a função inicial u(x) em N pontos nodais: u = [u(x_0), ..., u(x_{N-1})].",
                                    "Se usando coeficientes espectrais, transforme via DFT ou QFT para base de Fourier/Chebyshev.",
                                    "Aplique condições de contorno (ex: Dirichlet) ajustando u(0) e u(1).",
                                    "Converta entre valores nodais e coeficientes se necessário usando matriz de interpolação.",
                                    "Visualize a aproximação com plot(u vs x) para validar fidelidade."
                                  ],
                                  "verification": "Erro de interpolação < 1e-10 comparando com avaliação direta da função exata nos pontos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com NumPy/MATLAB; gráficos via Matplotlib.",
                                  "tips": "Para alta precisão, use N=16-32 inicialmente; evite Runge phenomenon com Chebyshev.",
                                  "learningObjective": "Representar funções suaves via expansões espectrais para aplicação de D.",
                                  "commonMistakes": "Não mapear corretamente o domínio físico para [-1,1]; usar N ímpar sem ajuste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Matriz D para Computar Derivadas Espectrais",
                                  "subSteps": [
                                    "Compute o vetor de derivadas: u' = D @ u (multiplicação matricial).",
                                    "Ajuste para domínio físico multiplicando por fator de escala (2/L se [0,L]).",
                                    "Verifique precisão comparando u' com derivada analítica nos pontos nodais.",
                                    "Repita para segundas derivadas: u'' = D @ (D @ u), monitorando crescimento de erro.",
                                    "Analise o espectro de autovalores de D para insights sobre alta frequência."
                                  ],
                                  "verification": "Norma do erro ||u' - u'_exata||_2 < 1e-8; plot de u' vs analítica sobreposto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python/MATLAB; funções eig() para autovalores.",
                                  "tips": "Use precisão dupla (float64); cond(D) alto indica rigidez, prepare para IVPs.",
                                  "learningObjective": "Executar multiplicação espectral para aproximação de derivadas com exponencialidade.",
                                  "commonMistakes": "Esquecer escala de domínio; acumular erros em derivadas altas sem aliasing controlado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em Problemas de Valor Inicial e Avaliar Estabilidade/Precisão",
                                  "subSteps": [
                                    "Configure IVP: du/dt = L(u) onde L usa D (ex: advecção ou difusão).",
                                    "Implemente integração temporal (Runge-Kutta ou tau-method) com passos Δt pequenos.",
                                    "Simule trajetória temporal e compare com solução exata ou referência fina.",
                                    "Calcule métricas: erro L2, ordem de convergência vs N, CFL para estabilidade.",
                                    "Teste estabilidade varrendo Δt/N; identifique modos espúrios."
                                  ],
                                  "verification": "Erro global < 1e-6 após t=1; convergência espectral (erro ~ exp(-N)).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código completo; solver ODE como scipy.integrate.odeint.",
                                  "tips": "Inicie com y' = -ky linear; filtre modos altos para estabilidade em não-lineares.",
                                  "learningObjective": "Avaliar performance de D em IVPs reais, quantificando trade-offs.",
                                  "commonMistakes": "Passos Δt grandes causando instabilidade; ignorar condições de contorno periódicas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Generalizar para Aplicações Complexas",
                                  "subSteps": [
                                    "Otimize D com pré-condicionadores ou filtros de dealiasing (2/3 rule).",
                                    "Estenda para 2D/3D tensorizando D (kronecker product).",
                                    "Compare com FD/FV: plote erro vs custo computacional.",
                                    "Documente limitações (runge, rigidez) e mitigações (domínio adaptativo).",
                                    "Crie função reutilizável para novos IVPs."
                                  ],
                                  "verification": "Simulação 2D converge; speedup vs métodos low-order >10x.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código avançado; referências como Canuto 'Spectral Methods'.",
                                  "tips": "Use GPU para N>100; valide com benchmarks de Trefethen.",
                                  "learningObjective": "Generalizar método para problemas práticos com otimizações.",
                                  "commonMistakes": "Não tratar não-linearidades (quadrature projection); overflow em derivadas altas."
                                }
                              ],
                              "practicalExample": "Resolva o IVP y' = -y, y(0)=1 em t∈[0,5], x∈[-1,1] com N=16 pontos Chebyshev. Construa D, set u0=exp(x), integre com RK4 Δt=0.01. Compare ||y(t)-exp(-t)||<1e-10, demonstre estabilidade para Δt até 0.1.",
                              "finalVerifications": [
                                "Matriz D corretamente construída e verificada com polinômio teste.",
                                "Derivadas espectrais coincidem com analíticas nos nodais.",
                                "Simulação IVP converge espectralmente com N.",
                                "Estabilidade mantida para CFL razoável.",
                                "Erro quantificado e plotado vs N/Δt.",
                                "Código modular e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão espectral: erro L∞ < 1e-8 para N=16.",
                                "Eficiência: tempo <1s por simulação t=1.",
                                "Correta avaliação de cond(D) e impacto na rigidez.",
                                "Tratamento de contornos e escalas.",
                                "Análise qualitativa de estabilidade (plots de espectro).",
                                "Generalização demonstrada em IVP não-linear simples."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de equações de onda/difusão.",
                                "Programação Científica: NumPy/SciPy para métodos numéricos.",
                                "Engenharia Mecânica: modelagem de vibrações modais.",
                                "Ciência de Dados: análise espectral de séries temporais."
                              ],
                              "realWorldApplication": "Em simulações CFD para aerodinâmica (NASA), previsão numérica do tempo (modelos ECMWF) e controle de sistemas dinâmicos em robótica, onde precisão exponencial permite malhas grosseiras e simulações em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Aplicação a Equações Diferenciais Ordinárias",
                    "description": "Integração dos métodos pseudoespectrais para resolver problemas de valor inicial em EDOs.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Formulação de Problemas de Valor Inicial em EDOs com Métodos Pseudoespectrais",
                        "description": "Apresenta a formulação matemática de problemas de valor inicial (PVI) para equações diferenciais ordinárias (EDOs) utilizando expansões em bases espectrais, como séries de Fourier ou polinômios de Chebyshev, para aproximar a solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar a estrutura de um PVI em EDOs",
                            "description": "Reconhecer e descrever o problema padrão y' = f(t,y), y(t0)=y0, e explicar como métodos pseudoespectrais discretizam o intervalo temporal em N pontos de collocation para expansão espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reconhecer a forma padrão de um Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Ler e memorizar a definição formal de um PVI de primeira ordem: y' = f(t, y), com condição inicial y(t₀) = y₀.",
                                    "Identificar o domínio do problema, geralmente um intervalo [t₀, T].",
                                    "Diferenciar PVI de Problemas de Contorno (BVP) ou de Valor em Fronteira.",
                                    "Escrever exemplos simples de PVIs em forma padrão.",
                                    "Explicar o papel da derivada y' e da função f(t,y)."
                                  ],
                                  "verification": "Escrever corretamente a forma geral de um PVI e fornecer um exemplo próprio.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Equações Diferenciais Ordinárias (capítulo de PVIs)",
                                    "Folha de anotações",
                                    "Acesso a slides de Análise Numérica"
                                  ],
                                  "tips": "Sempre verifique se a equação está na forma y' = f(t,y); reformule se necessário.",
                                  "learningObjective": "Compreender e reproduzir a estrutura canônica de um PVI em EDOs.",
                                  "commonMistakes": [
                                    "Confundir com equações de segunda ordem sem redução",
                                    "Omitir a condição inicial y(t₀)=y₀",
                                    "Ignorar dependência explícita em t ou y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever os componentes essenciais do PVI",
                                  "subSteps": [
                                    "Analisar a função f(t,y): identificar variáveis independentes (t) e dependentes (y).",
                                    "Explicar o significado físico/matemático da condição inicial y(t₀)=y₀.",
                                    "Discutir unicidade e existência de soluções (teorema de Picard-Lindelöf, se aplicável).",
                                    "Reescrever PVIs não padrão para a forma y' = f(t,y).",
                                    "Verificar Lipschitzianidade de f para garantir solução única."
                                  ],
                                  "verification": "Decompor um PVI dado em seus componentes e justificar a forma padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de PVIs de aulas anteriores",
                                    "Software como MATLAB ou Python (SymPy) para verificação simbólica",
                                    "Quadro branco ou papel"
                                  ],
                                  "tips": "Use diagramas para visualizar t como tempo e y como estado.",
                                  "learningObjective": "Dominar a identificação precisa dos elementos constitutivos de um PVI.",
                                  "commonMistakes": [
                                    "Tratar f(t,y) como constante",
                                    "Confundir y₀ com valor em outro ponto",
                                    "Não verificar se f é contínua e Lipschitz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a discretização temporal nos métodos pseudoespectrais",
                                  "subSteps": [
                                    "Estudar como métodos pseudoespectrais dividem o intervalo [t₀, T] em N pontos de collocation equidistantes ou de Gauss-Lobatto.",
                                    "Explicar a transformação para o intervalo padrão [-1,1] via mapeamento afim.",
                                    "Discutir a escolha de N: equilíbrio entre precisão e custo computacional.",
                                    "Visualizar a grade temporal com pontos de collocation.",
                                    "Comparar brevemente com métodos finitos diferenciais."
                                  ],
                                  "verification": "Desenhar a discretização de um intervalo [0,1] com N=5 pontos e mapear para [-1,1].",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação de métodos espectrais (ex: Trefethen 'Spectral Methods')",
                                    "Python com NumPy/SciPy para plotar pontos",
                                    "Gráficos de collocation points"
                                  ],
                                  "tips": "Comece com N pequeno (ex: 3) para visualizar antes de generalizar.",
                                  "learningObjective": "Explicar o processo de discretização específica dos métodos pseudoespectrais.",
                                  "commonMistakes": [
                                    "Usar pontos equidistantes sem collocation",
                                    "Esquecer mapeamento afim para [-1,1]",
                                    "Confundir com métodos espectrais globais vs. locais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a expansão espectral via pontos de collocation",
                                  "subSteps": [
                                    "Introduzir aproximação y(t) ≈ ∑ c_k φ_k(τ), onde φ_k são bases polinomiais (Chebyshev/Legendre) e τ em [-1,1].",
                                    "Descrever imposição das condições nos N pontos: y'(τ_i) = f(τ_i, y(τ_i)) e y(t₀)=y₀.",
                                    "Explicar resolução do sistema não-linear via Newton-Raphson nos coeficientes.",
                                    "Discutir convergência exponencial para soluções suaves.",
                                    "Implementar um exemplo numérico simples."
                                  ],
                                  "verification": "Formular o sistema de collocation para um PVI toy e resolver para coeficientes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python/MATLAB de exemplo pseudoespectral",
                                    "Tabela de raízes de Chebyshev",
                                    "Calculadora ou software simbólico"
                                  ],
                                  "tips": "Foquem em bases ortogonais para aliasing mínimo.",
                                  "learningObjective": "Integrar discretização e expansão para formulação pseudoespectral de PVIs.",
                                  "commonMistakes": [
                                    "Ignorar derivadas na base φ_k",
                                    "Não impor condição inicial corretamente",
                                    "Assumir linearidade desnecessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o PVI y' = -2y, y(0)=1 no intervalo [0,5]. Usando método pseudoespectral com N=6 pontos de Chebyshev-Gauss-Lobatto, mapeie t ∈ [0,5] para τ ∈ [-1,1] via τ = 2(t-2.5)/5. Aproxime y(τ) = ∑_{k=0}^5 c_k T_k(τ), imponha y'(-1)= -2y(-1) nos pontos internos e y(-1)=1, resolvendo o sistema para os coeficientes c_k, obtendo solução aproximada com erro exponencialmente pequeno.",
                              "finalVerifications": [
                                "Escrever e justificar a forma padrão y' = f(t,y), y(t₀)=y₀ para um PVI dado.",
                                "Desenhar corretamente N pontos de collocation em [t₀,T] e seu mapeamento.",
                                "Explicar verbalmente como a expansão espectral impõe as equações nos pontos.",
                                "Identificar diferenças entre pseudoespectral e Runge-Kutta.",
                                "Resolver um PVI simples com N=3 pontos manualmente.",
                                "Verificar convergência qualitativa aumentando N."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da forma padrão (100% dos componentes corretos).",
                                "Clareza na descrição da discretização e mapeamento afim.",
                                "Correção na formulação da expansão espectral e condições de collocation.",
                                "Profundidade nas explicações de convergência e unicidade.",
                                "Capacidade de aplicar a um exemplo concreto sem erros.",
                                "Uso apropriado de terminologia técnica (ex: collocation, bases ortogonais)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos como osciladores harmônicos.",
                                "Computação: Implementação de solvers numéricos em Python/SciPy.",
                                "Engenharia: Simulações em controle de processos e aerodinâmica.",
                                "Física Computacional: Integração com métodos Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica orbital na astronáutica (NASA usa métodos espectrais para trajetórias precisas), previsão climática (modelos de fluidos com alta resolução temporal) e controle de robótica, onde a convergência rápida permite simulações em tempo real de EDOs rígidas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Escolher bases espectrais adequadas",
                            "description": "Selecionar entre bases de Fourier (periódicas) ou Chebyshev (não-periódicas) com base nas condições de contorno e propriedades da solução esperada, justificando a escolha pela precisão exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as características fundamentais das bases espectrais Fourier e Chebyshev",
                                  "subSteps": [
                                    "Estudar a base de Fourier: funções seno e cosseno para funções periódicas.",
                                    "Estudar a base de Chebyshev: polinômios para funções não-periódicas em intervalos finitos.",
                                    "Comparar convergência: exponencial para soluções suaves em ambas, mas Fourier falha em não-periódicas.",
                                    "Revisar condições de contorno: periódicas para Fourier, Dirichlet/Neumann para Chebyshev.",
                                    "Exemplificar com gráficos simples de aproximação."
                                  ],
                                  "verification": "Resumir em um parágrafo as diferenças principais e listar 3 vantagens de cada base.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos espectrais (ex: Trefethen 'Spectral Methods'), notebook com plots em Python/MATLAB.",
                                  "tips": "Use visualizações gráficas para fixar conceitos; foque em periodicidade como critério chave.",
                                  "learningObjective": "Identificar quando usar Fourier (periódico) vs Chebyshev (não-periódico).",
                                  "commonMistakes": "Confundir periodicidade da base com a da solução; ignorar Gibbs phenomenon em Fourier para descontinuidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as propriedades do problema de EDO: periodicidade e condições de contorno",
                                  "subSteps": [
                                    "Identificar o intervalo de definição da solução (ex: [0, 2π] periódico vs [-1,1] finito).",
                                    "Verificar condições de contorno: u(0)=u(2π) para periódico; u(-1), u'(1) para não-periódico.",
                                    "Avaliar suavidade esperada da solução: analítica para convergência exponencial.",
                                    "Mapear o problema para o domínio padrão: periódico para Fourier, [-1,1] para Chebyshev.",
                                    "Documentar características em uma tabela comparativa."
                                  ],
                                  "verification": "Criar uma tabela com colunas: 'Característica do Problema', 'Implicação para Fourier', 'Implicação para Chebyshev'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Enunciado do problema de EDO, papel ou software de tabela (Excel/Google Sheets).",
                                  "tips": "Sempre pergunte: 'A solução é naturalmente periódica?' como primeiro filtro.",
                                  "learningObjective": "Extrair e classificar propriedades relevantes do problema para escolha de base.",
                                  "commonMistakes": "Assumir periodicidade sem verificar condições de contorno; ignorar suavidade da solução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar bases e selecionar a mais adequada",
                                  "subSteps": [
                                    "Listar prós e contras: Fourier (rápida para periódico, aliasing em não-periódico); Chebyshev (flexível para não-periódico, custo computacional similar).",
                                    "Aplicar critérios: se periódico e suave → Fourier; senão → Chebyshev.",
                                    "Simular escolha em um problema toy: calcular coeficientes para ambas.",
                                    "Decidir e registrar a base escolhida.",
                                    "Testar com N=16 modos para ver erro inicial."
                                  ],
                                  "verification": "Implementar aproximação trivial e comparar erros L2 para ambas bases.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (Python com NumPy/SciPy ou MATLAB), código base para spectral methods.",
                                  "tips": "Comece com baixa resolução (N=8-16) para testes rápidos; priorize estabilidade numérica.",
                                  "learningObjective": "Selecionar base com base em matching entre problema e propriedades da base.",
                                  "commonMistakes": "Escolher Fourier por 'familiaridade' em problemas não-periódicos; subestimar aliasing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a escolha pela precisão exponencial e validar",
                                  "subSteps": [
                                    "Explicar convergência exponencial: erro ~ exp(-N) para soluções suaves na base correta.",
                                    "Quantificar: plotar log(erros) vs N para confirmar exponencial.",
                                    "Discutir impacto em EDOs: precisão em derivadas diferenciais.",
                                    "Redigir justificativa formal: 3-5 frases ligando problema à base.",
                                    "Comparar com base errada para evidenciar perda de precisão."
                                  ],
                                  "verification": "Escrever relatório curto (200 palavras) com justificativa e gráfico de convergência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código do step 3, ferramenta de plotagem (Matplotlib).",
                                  "tips": "Use semi-log plot para visualizar exponencial claramente; cite literatura (ex: Canuto et al.).",
                                  "learningObjective": "Argumentar rigorosamente a superioridade da escolha pela taxa de convergência.",
                                  "commonMistakes": "Justificativa vaga sem evidência numérica; confundir precisão algébrica com exponencial."
                                }
                              ],
                              "practicalExample": "Para a EDO u'' + u = 0 com u(0)=u(2π)=1, u'(0)=u'(2π)=0 (periódica), escolha Fourier: solução u=1 converge exponencialmente. Para u'' + u = sin(x) em [-1,1] com u(-1)=u(1)=0 (não-periódica), use Chebyshev para evitar Gibbs e precisão exp(-N). Implemente em Python e compare erros.",
                              "finalVerifications": [
                                "Explica corretamente diferenças entre Fourier e Chebyshev em termos de periodicidade.",
                                "Identifica condições de contorno do problema e as mapeia para bases adequadas.",
                                "Justifica escolha com evidência de convergência exponencial (gráfico ou cálculo).",
                                "Compara erro com base inadequada, mostrando perda de precisão.",
                                "Aplica escolha a um EDO real e obtém solução precisa com N<32.",
                                "Redige justificativa clara e concisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de periodicidade/contorno (30%)",
                                "Correção da seleção de base (25%)",
                                "Qualidade da justificativa com análise de convergência (20%)",
                                "Uso de evidências numéricas/simulações (15%)",
                                "Clareza e estrutura da documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas e vibrações periódicas (Fourier em mecânica quântica).",
                                "Engenharia: Simulações CFD (Chebyshev em escoamentos confinados).",
                                "Computação: Algoritmos FFT vs DCT para processamento de sinais.",
                                "Física Computacional: Métodos espectrais em DNS de turbulência."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (Navier-Stokes), escolher Fourier para domínios periódicos (canais infinitos) acelera simulações precisas; Chebyshev para geometrias finitas como aerofólios, essencial em design aeronáutico pela convergência rápida e baixo custo computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Formular a expansão espectral da solução",
                            "description": "Escrever a solução aproximada como soma de coeficientes espectrais multiplicados pela base escolhida, y_N(t) = sum_{k=0}^N â_k φ_k(t), e definir os pontos de collocation.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar a base espectral apropriada",
                                  "subSteps": [
                                    "Revise as bases comuns usadas em métodos pseudoespectrais, como polinômios de Chebyshev, Legendre ou Fourier.",
                                    "Analise o intervalo do problema (ex: [-1,1] para Chebyshev) e as propriedades da EDO (periódica ou não).",
                                    "Escolha a base φ_k(t) baseada no contexto: Chebyshev para problemas em intervalos finitos não periódicos.",
                                    "Defina o grau N da aproximação, considerando precisão vs custo computacional.",
                                    "Anote a forma geral das funções base: φ_k(t) para k=0 a N."
                                  ],
                                  "verification": "Confirme que a base escolhida é adequada ao intervalo e tipo de EDO, listando pelo menos 3 razões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de análise numérica, tabela de bases espectrais, papel e lápis",
                                  "tips": "Prefira Chebyshev para EDOs em intervalos finitos; verifique ortogonalidade da base.",
                                  "learningObjective": "Compreender como selecionar uma base espectral otimizada para o problema específico.",
                                  "commonMistakes": "Escolher base periódica (Fourier) para problemas não periódicos, levando a Gibbs phenomenon."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a expansão espectral da solução aproximada",
                                  "subSteps": [
                                    "Escreva a forma y_N(t) = ∑_{k=0}^N â_k φ_k(t), onde â_k são os coeficientes espectrais desconhecidos.",
                                    "Identifique o domínio t ∈ [a,b] e normalize se necessário (ex: mapear para [-1,1]).",
                                    "Expresse a derivada y_N'(t) = ∑_{k=0}^N â_k φ_k'(t), usando propriedades da base.",
                                    "Inclua condições de contorno iniciais na formulação, como y_N(a) = y(a).",
                                    "Verifique dimensionalidade: N+1 termos para grau N."
                                  ],
                                  "verification": "A expansão deve coincidir exatamente com y_N(t) = sum â_k φ_k(t), com derivadas corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software simbólico como Mathematica ou SymPy, quadro branco",
                                  "tips": "Use notação LaTeX para clareza; memorize diferenciação espectral para eficiência.",
                                  "learningObjective": "Formular matematicamente a aproximação espectral da solução da EDO.",
                                  "commonMistakes": "Esquecer o índice de soma ou confundir coeficientes â_k com c_k (notação inconsistente)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os pontos de collocation",
                                  "subSteps": [
                                    "Escolha N+1 pontos de collocation baseados na base: ex: Chebyshev-Gauss-Lobatto points ξ_j = cos(π j / N), j=0..N.",
                                    "Mapeie os pontos do intervalo padrão para [a,b]: t_j = ((b-a)/2) ξ_j + ((b+a)/2).",
                                    "Inclua endpoints para condições de contorno: t_0 = a, t_N = b se aplicável.",
                                    "Liste os pontos explicitamente para N pequeno (ex: N=4).",
                                    "Explique que nas condições de collocation, a EDO é satisfeita exatamente nesses pontos."
                                  ],
                                  "verification": "Pontos devem ser N+1 distintos no intervalo, incluindo condições de contorno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, planilha Excel para gerar pontos, documentação de quadratura.",
                                  "tips": "Use pontos Lobatto para precisão em derivadas; plote os pontos para visualização.",
                                  "learningObjective": "Definir pontos de collocation que garantam interpolação espectral exata.",
                                  "commonMistakes": "Usar pontos uniformes (Runge phenomenon) em vez de espectrais clustered nos endpoints."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar a formulação completa e validar",
                                  "subSteps": [
                                    "Combine expansão e pontos: y_N(t_j) ≈ y(t_j) e y_N'(t_j) = f(t_j, y_N(t_j)) para j=1..N-1.",
                                    "Incorpore condições iniciais: y_N(t_0) = y_0.",
                                    "Formule o sistema não linear para â_k via collocation.",
                                    "Teste com N baixo para verificar consistência.",
                                    "Documente a formulação final em um quadro resumo."
                                  ],
                                  "verification": "Sistema de equações deve ter N+1 incógnitas (â_k) e N+1 equações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel milimetrado, software MATLAB para protótipo",
                                  "tips": "Mantenha linearidade se possível; prepare para resolução via Newton.",
                                  "learningObjective": "Validar a formulação integrada da expansão espectral para EDOs.",
                                  "commonMistakes": "Ignorar condições de contorno nos pontos, resultando em sistema subdeterminado."
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -y, t ∈ [0,1], y(0)=1, usando base Chebyshev de grau N=4: y_4(t) = ∑_{k=0}^4 â_k T_k(2t-1), pontos t_j = (1/2)(1 + cos(π j /4)), j=0..4. Condições: y_4(0)=1, e y_4'(t_j) + y_4(t_j)=0 para j=1..4.",
                              "finalVerifications": [
                                "A expansão y_N(t) está corretamente escrita como soma de â_k φ_k(t)?",
                                "Os pontos de collocation são N+1 e incluem endpoints?",
                                "As derivadas são expressas em termos da base?",
                                "Condições iniciais estão incorporadas?",
                                "O número de equações equals número de desconhecidos?",
                                "Notação consistente com o contexto do problema?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha da base (adequação ao problema: 20%)",
                                "Correção da forma da expansão e derivadas (30%)",
                                "Definição exata dos pontos de collocation (25%)",
                                "Integração coerente de condições de contorno (15%)",
                                "Clareza e documentação da formulação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores harmônicos via EDOs espectrais.",
                                "Engenharia Computacional: Implementação em CFD (fluidodinâmica computacional).",
                                "Ciência de Dados: Aproximação de séries temporais em machine learning.",
                                "Física Computacional: Simulações de ondas não lineares."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de atmosfera), previsão de ondas em oceanos e controle de sistemas dinâmicos em engenharia aeroespacial, onde métodos pseudoespectrais aceleram soluções de EDOs com alta precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Diferenciação e Integração Pseudoespectral",
                        "description": "Descreve os operadores de diferenciação e integração no espaço espectral, transformando derivadas diferenciais em sistemas algébricos lineares ou não-lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Construir a matriz de diferenciação pseudoespectral",
                            "description": "Calcular a matriz de derivação D para bases de Fourier ou Chebyshev, onde y' ≈ D y, com entradas derivadas analíticas exatas dos modos espectrais nos pontos de collocation.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Escolher e Configurar a Base Espectral",
                                  "subSteps": [
                                    "Selecione a base: Fourier para problemas periódicos ou Chebyshev para não-periódicos.",
                                    "Defina o número de pontos N (ex: N=8 para teste inicial).",
                                    "Implemente os modos de base φ_k(x) para k=0 a N-1.",
                                    "Gere os pontos de collocation ξ_j para j=0 a N-1 (ex: ξ_j = cos(π j /(N-1)) para Chebyshev).",
                                    "Escreva a expansão espectral y(ξ) ≈ ∑_{k=0}^{N-1} ŷ_k φ_k(ξ)."
                                  ],
                                  "verification": "Confirme que os modos φ_k(ξ_j) formam uma matriz de Vandermonde V com det(V) ≠ 0 e interpolação exata de polinômios de grau <N.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (Trefethen 'Spectral Methods'), Python/MATLAB com NumPy/SciPy",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Comece com Chebyshev para simplicidade em domínios [-1,1]; use sympy para derivações simbólicas.",
                                  "learningObjective": "Compreender a representação espectral e pontos de collocation para diferenciação precisa.",
                                  "commonMistakes": [
                                    "Confundir bases periódicas/não-periódicas",
                                    "Índices errados em k e j",
                                    "Pontos de collocation fora do domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Analiticamente os Modos de Base",
                                  "subSteps": [
                                    "Calcule as derivadas exatas φ_k'(ξ) para cada modo k.",
                                    "Para Chebyshev: use recursão T_k'(ξ) = k U_{k-1}(ξ), onde U são polinômios de Chebyshev de segunda espécie.",
                                    "Para Fourier: φ_k(ξ) = exp(i k π ξ), φ_k'(ξ) = i k π φ_k(ξ).",
                                    "Avalie φ_k'(ξ_j) em todos os pontos de collocation para formar a matriz L'_{j,k}.",
                                    "Verifique simetria ou propriedades (ex: anti-simétrica para Chebyshev em certos casos)."
                                  ],
                                  "verification": "Aplique a derivada a um polinômio conhecido de grau baixo e confirme exatidão analítica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para derivações simbólicas",
                                    "Código template para avaliação matricial"
                                  ],
                                  "tips": "Use identidades trigonométricas para Fourier; memorize recursões Chebyshev para eficiência.",
                                  "learningObjective": "Dominar derivações exatas que garantem precisão espectral (erro exponencial).",
                                  "commonMistakes": [
                                    "Erros em fatores de normalização",
                                    "Confundir T_k e U_k",
                                    "Avaliação numérica imprecisa perto das extremidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Matriz de Diferenciação D",
                                  "subSteps": [
                                    "Forme a matriz de Lagrange ou diretamente D_{j,k} = φ_k'(ξ_j) / ∑_m l_m(ξ_j) se necessário, mas para pseudoespectral padrão: D = V' * V^{-1}.",
                                    "Para Chebyshev: use algoritmo eficiente de Trefethen (D_{0,0}=-2(N-1)^2, etc.).",
                                    "Para Fourier: D diagonal no espaço de Fourier, transforme via FFT.",
                                    "Implemente em código: monte D explicitamente e teste com y = [ξ_j].",
                                    "Ajuste para condições de contorno (ex: Dirichlet: modifique linhas 0 e N-1)."
                                  ],
                                  "verification": "Verifique D * ones(N,1) ≈ 0 (derivada de constante é zero) e propriedades de precisão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Chebfun toolbox ou código Spectral Methods in MATLAB",
                                    "Jupyter notebook para prototipagem"
                                  ],
                                  "tips": "Implemente a fórmula fechada de Trefethen para Chebyshev para evitar inversões numéricas instáveis.",
                                  "learningObjective": "Construir D tal que ||y' - D y|| < 1e-10 para funções suaves.",
                                  "commonMistakes": [
                                    "Inversão de V mal-condicionada sem pré-condicionamento",
                                    "Índices 0 vs 1-based",
                                    "Ignorar fatores c_j em pesos Chebyshev"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Testar a Matriz D",
                                  "subSteps": [
                                    "Teste com funções analíticas: y=sin(π ξ), compute y' exata vs D y.",
                                    "Meça erro em norma L2 e max para diferentes N.",
                                    "Aplique a EDO y' = λ y, resolva via exp(D t) y0 e compare com exata.",
                                    "Visualize: plote y, y_num = D y vs y_analítica.",
                                    "Otimize: compare com diferenças finitas de alta ordem."
                                  ],
                                  "verification": "Erro espectral < 1e-12 para N=16 em funções polinomiais; convergência exponencial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos em Matplotlib/Plotly",
                                    "Funções teste pré-definidas"
                                  ],
                                  "tips": "Use loglog plot para erro vs N para demonstrar precisão espectral.",
                                  "learningObjective": "Validar que D captura derivadas exatas nos pontos de collocation.",
                                  "commonMistakes": [
                                    "Testes só em baixos N",
                                    "Normas erradas (use pesos quadratura)",
                                    "Não checar estabilidade para Runge-Kutta"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=4 pontos Chebyshev em [-1,1]: ξ = [-1, -0.5, 0.5, 1]. Modos T0=1, T1=ξ, T2=2ξ²-1, T3=4ξ³-3ξ. Compute D com fórmula: D_{j,k} = c_k (-1)^{j+k} / (c_j (ξ_j - ξ_k)) para j≠k, diagonais específicas. Aplique D a y=[ξ_j²], deve dar 2 ξ_j com erro máquina.",
                              "finalVerifications": [
                                "D * φ(:,k) = φ'(:,k) exatamente nos pontos ξ.",
                                "Erro em derivada de teste suave < 1e-10.",
                                "Propriedades: soma linhas internas ≈0 para derivada nula.",
                                "Convergência exponencial: erro ~ exp(-N).",
                                "Estabilidade: ||D|| razoável (O(N^2) para Chebyshev).",
                                "Funciona com FFT para Fourier (diagonal)."
                              ],
                              "assessmentCriteria": [
                                "Correção analítica das derivadas φ_k' (100% match simbólico).",
                                "Precisão numérica: erro L∞ < 1e-12 para N≤32.",
                                "Eficiência: tempo O(N^2) ou melhor com FFT.",
                                "Implementação robusta: lida com N até 100 sem overflow.",
                                "Documentação: código comentado com fórmulas.",
                                "Generalidade: funciona para Fourier e Chebyshev."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de ondas/PDES via métodos espectrais (equação de onda).",
                                "Engenharia: CFD (Navier-Stokes em domínios irregulares).",
                                "Ciência da Computação: Algoritmos paralelizáveis com FFT (GPU).",
                                "Matemática Aplicada: Teoria de aproximação polinomial/quadraturas.",
                                "Engenharia Elétrica: Análise de sinais periódicos."
                              ],
                              "realWorldApplication": "Em simulações numéricas de turbulência (DNS em CFD), onde D é usada em esquemas tempo-marcha para EDOs/PDEs, alcançando precisão máquina com poucos pontos vs milhões em FD/FV."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Aplicar diferenciação a EDOs não-lineares",
                            "description": "Converter y' = f(t,y) em um sistema não-linear F(â) = 0 via transformação espectral, explicando o método de collocation para resolver via Newton-Raphson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Diferenciação Pseudoespectral",
                                  "subSteps": [
                                    "Estude a base de polinômios de Chebyshev ou Legendre para aproximação espectral.",
                                    "Aprenda a derivada espectral: Dâ = D * â, onde D é a matriz de diferenciação.",
                                    "Entenda a discretização temporal em N pontos de collocation no intervalo [-1,1] ou [0,T].",
                                    "Pratique mapeamento de t para o domínio espectral via transformação afim.",
                                    "Implemente uma diferenciação simples em código para uma função teste."
                                  ],
                                  "verification": "Implemente e plote a derivada espectral de sin(x); compare com derivada analítica (erro < 1e-10).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação NumPy/SciPy, MATLAB ou Python com Chebfun, notas de aula sobre pseudoespectrais.",
                                  "tips": "Use pontos de Chebyshev-Gauss-Lobatto para estabilidade.",
                                  "learningObjective": "Compreender como a diferenciação espectral aproxima derivadas com alta precisão.",
                                  "commonMistakes": "Esquecer de mapear o domínio temporal corretamente; usar pontos equidistantes (baixa precisão)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter EDO Não-Linear y' = f(t,y) em Sistema F(â) = 0",
                                  "subSteps": [
                                    "Aproxime y(t) ≈ ∑ â_k φ_k(t), onde φ_k são bases espectrais.",
                                    "Compute y'(t) ≈ D â, com D matriz de diferenciação.",
                                    "Formule o resíduo: F(â) = D â - f(t, P â) = 0 em pontos de collocation.",
                                    "Inclua condições de contorno: â_0 = y(0), â_N = y(T) ou periódicas.",
                                    "Escreva explicitamente F_i(â) = (D â)_i - f(t_i, ∑ â_k φ_k(t_i)) para i=1..N-1."
                                  ],
                                  "verification": "Derive manualmente F(â) para y' = y com y(0)=1, y(1)=e; verifique dimensionalidade N x 1.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Papel e lápis para derivação, Python/Jupyter para protótipo simbólico com SymPy.",
                                  "tips": "Use interpolação em pontos de collocation para f(t,y).",
                                  "learningObjective": "Transformar EDO não-linear em sistema algébrico não-linear via expansão espectral.",
                                  "commonMistakes": "Ignorar condições de contorno no sistema F; confundir y' com integração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Método de Collocation em Pontos Espectrais",
                                  "subSteps": [
                                    "Escolha N+1 pontos de collocation (ex: Chebyshev extrema).",
                                    "Construa matrizes de interpolação P e diferenciação D pré-computadas.",
                                    "Avalie f(t_i, y_i) numericamente nos pontos.",
                                    "Monte o vetor F(â) completo com resíduos e contornos.",
                                    "Teste com EDO linear simples para validar setup."
                                  ],
                                  "verification": "Para y' = -y, y(0)=1, resolva com N=10; erro em y(1) < 1e-8 vs. e^{-1}.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código Python com numpy.fft ou spectral libraries como Dedalus/PySpectral.",
                                  "tips": "Pré-condicione D para simetria.",
                                  "learningObjective": "Implementar collocation espectral para discretização precisa de EDOs.",
                                  "commonMistakes": "Pontos errados (use Lobatto, não Gauss); N muito pequeno para não-lineares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Sistema Não-Linear com Newton-Raphson",
                                  "subSteps": [
                                    "Inicialize â^{(0)} com solução de EDO linearizada ou extrapolação.",
                                    "Compute Jacobiana J = ∂F/∂â ≈ D - ∂f/∂y * P nos pontos.",
                                    "Itere: â^{k+1} = â^k - J^{-1} F(â^k) até ||F|| < tol.",
                                    "Use solver robusto (ex: fsolve em SciPy) com callback para monitorar.",
                                    "Reconstrua y(t) via avaliação espectral e plote."
                                  ],
                                  "verification": "Convergência em <20 iterações; resíduo max < 1e-12.",
                                  "estimatedTime": "4 horas",
                                  "materials": "SciPy.optimize.fsolve, MATLAB fsolve; debugger para Jacobiana.",
                                  "tips": "Line search ou damping se não convergir.",
                                  "learningObjective": "Aplicar iterativo Newton-Raphson para solução de sistemas não-lineares espectrais.",
                                  "commonMistakes": "Jacobiana incorreta (esquecer chain rule em ∂f/∂â); inicial ruim causando divergência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Validar a Solução",
                                  "subSteps": [
                                    "Compute erro vs. solução exata ou referência de alta resolução.",
                                    "Analise convergência espectral (ordem ~N).",
                                    "Estude estabilidade para parâmetros variados.",
                                    "Compare com métodos finitos (ex: RK4).",
                                    "Documente limitações (ex: não-periódico)."
                                  ],
                                  "verification": "Erro L2 < 1e-10 para N=32; plot de resíduo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Matplotlib para plots, referência de soluções analíticas.",
                                  "tips": "Use log-log para ordem de convergência.",
                                  "learningObjective": "Avaliar precisão e robustez da solução pseudoespectral.",
                                  "commonMistakes": "Atribuir precisão alta sem validação; ignorar aliasing em não-lineares."
                                }
                              ],
                              "practicalExample": "Resolva y' = y^2 - t, y(0)=1 em [0,1] usando N=16 pontos Chebyshev. Inicial: â^0 linear. Espere convergência rápida a solução Riccati aproximada, validada vs. Runge-Kutta adaptativo.",
                              "finalVerifications": [
                                "Sistema F(â) corretamente montado e Jacobiana derivada.",
                                "Convergência Newton-Raphson com resíduo <1e-12 em <30 iterações.",
                                "Erro global L^∞ <1e-10 vs. referência.",
                                "Ordem espectral confirmada (reduzindo h~1/N).",
                                "Código reproduzível e comentado.",
                                "Plots de y(t), resíduo e convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão da discretização espectral (erro exponencial).",
                                "Correção da formulação não-linear F(â)=0.",
                                "Eficiência e robustez do solver Newton-Raphson.",
                                "Validação com múltiplos N e exemplos.",
                                "Clareza na explicação de collocation e transformação.",
                                "Análise de erros e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores não-lineares (ex: pêndulo).",
                                "Computação: Otimização numérica e álgebra linear esparsa.",
                                "Engenharia: Simulações CFD ou controle não-linear.",
                                "Estatística: Inferência em processos estocásticos discretizados."
                              ],
                              "realWorldApplication": "Simulações de dinâmica de fluidos não-lineares (Navier-Stokes espectral em previsão meteorológica), modelagem financeira de opções exóticas, ou controle de robótica onde alta precisão em poucos DOFs é crítica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Implementar integração temporal básica",
                            "description": "Usar o método pseudoespectral para um passo de integração, comparando com métodos de passo simples como Runge-Kutta, destacando a alta ordem de precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de métodos pseudoespectrais para EDOs",
                                  "subSteps": [
                                    "Estude a representação espectral usando polinômios de Chebyshev ou Fourier para soluções de EDOs.",
                                    "Revise a transformação para o espaço espectral e como derivadas são computadas exatamente no domínio espectral.",
                                    "Entenda a integração temporal em pseudoespectral como um passo que usa a precisão espectral para alta ordem.",
                                    "Compare conceitualmente com métodos de diferenças finitas como Runge-Kutta (ordem fixa vs. ordem espectral).",
                                    "Anote as vantagens: precisão exponencial para soluções suaves."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças chave entre pseudoespectral e RK, confirmando compreensão conceitual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de métodos espectrais (e.g., Trefethen 'Spectral Methods in MATLAB'), notebook Jupyter"
                                  ],
                                  "tips": "Use visualizações de modos espectrais para intuição; foque em soluções analíticas suaves.",
                                  "learningObjective": "Compreender por que métodos pseudoespectrais oferecem alta ordem de precisão em um passo.",
                                  "commonMistakes": [
                                    "Confundir domínio físico com espectral; ignorar aliasing em funções não-suaves."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente e EDO de teste simples",
                                  "subSteps": [
                                    "Instale bibliotecas: NumPy, SciPy, Matplotlib em Python.",
                                    "Escolha EDO y' = λy, y(0)=1 (e.g., λ=-1 para decaimento exponencial).",
                                    "Defina grade de pontos collocation (N=16 pontos Chebyshev).",
                                    "Implemente funções auxiliares: pontos/nós Chebyshev, matriz de diferenciação D.",
                                    "Teste transformação FFT/Chebyshev para uma função conhecida."
                                  ],
                                  "verification": "Plote a grade de pontos e verifique se D aplicada a uma função polinomial dá derivada exata.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3+, Jupyter Notebook, ChebPy ou código custom para nós Chebyshev"
                                  ],
                                  "tips": "Use nós Chebyshev extremos para estabilidade; normalize o domínio [-1,1] inicialmente.",
                                  "learningObjective": "Preparar infraestrutura numérica para integração pseudoespectral.",
                                  "commonMistakes": [
                                    "Pontos de grade inadequados levando a Runge phenomenon; escala de tempo errada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um passo de integração temporal pseudoespectral",
                                  "subSteps": [
                                    "Projete y(t) no espaço espectral: coeficientes via interpolação nos nós.",
                                    "Compute y' espectral = D * y_físico, então integre implicitamente ou explicitamente para Δt.",
                                    "Atualize y^{n+1} = y^n + Δt * (f(y^n))_espectral projetado de volta.",
                                    "Implemente projeção para o domínio físico após integração.",
                                    "Teste com Δt=0.1 para um passo, comparando com solução exata e^{λΔt}."
                                  ],
                                  "verification": "Erro após um passo < 1e-10 para N=16, plotando y numérico vs. exato.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com funções cheb_differentiation_matrix() e fft.ifft()"
                                  ],
                                  "tips": "Para explicit: integre no espectral truncando modos altos; evite stiff problems inicialmente.",
                                  "learningObjective": "Executar um passo de tempo com precisão espectral alta.",
                                  "commonMistakes": [
                                    "Não truncar modos para evitar instabilidade; confundir integração com diferenciação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Runge-Kutta e comparar precisão",
                                  "subSteps": [
                                    "Implemente RK4 para o mesmo EDO e Δt, múltiplos passos para t_final equivalente.",
                                    "Execute ambos métodos para vários N e Δt, medindo erro global L2.",
                                    "Gere gráficos: erro vs. N (espectral exponencial) vs. Δt (RK fixo ordem 4).",
                                    "Analise: destaque como pseudoespectral precisa de menos passos para mesma precisão.",
                                    "Documente tabela de erros e conclusões."
                                  ],
                                  "verification": "Gráficos mostram convergência espectral (erro ~ e^{-N}) vs. RK ordem 4.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy.integrate para RK benchmark, Matplotlib para plots log-log"
                                  ],
                                  "tips": "Use logscale para erros; teste com λ complexo para oscilações.",
                                  "learningObjective": "Demonstrar superioridade em precisão de um passo pseudoespectral sobre RK.",
                                  "commonMistakes": [
                                    "Passos múltiplos desnecessários no espectral; métricas de erro inconsistentes."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -y, y(0)=1 até t=1 com Δt=0.25 (4 passos RK4 vs. 4 passos espectrais). Pseudoespectral com N=8 atinge erro 1e-12; RK4 erro 1e-5. Plote soluções e erros.",
                              "finalVerifications": [
                                "Código executa sem erros para EDO de teste.",
                                "Erro pseudoespectral após um passo << erro RK4 equivalente.",
                                "Plots mostram convergência espectral em log(N).",
                                "Tabela compara ordens de precisão.",
                                "Comentários no código explicam transformações espectrais.",
                                "Teste com EDO diferente (e.g., y'' + y=0) confirma generalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro espectral <1e-10 para N>=16.",
                                "Eficiência: Tempo de um passo pseudoespectral similar a RK mas com precisão superior.",
                                "Correção conceitual: Uso correto de D matrix e projeções.",
                                "Visualizações: Plots claros de comparação erro vs. parâmetros.",
                                "Robustez: Funciona para pelo menos duas EDOs diferentes.",
                                "Documentação: Código comentado e relatório de 200 palavras."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores harmônicos ou decaimento radioativo.",
                                "Computação: Otimização numérica e programação científica (NumPy/FFT).",
                                "Engenharia: Modelagem de sistemas dinâmicos em controle/aerodinâmica.",
                                "Estatística: Análise de erros e convergência numérica."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), métodos pseudoespectrais integram tempo com precisão alta em poucos passos para turbulência; NASA usa para aerodinâmica; finanças para pricing de opções com EDOs estocásticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Análise de Estabilidade, Precisão e Implementação",
                        "description": "Analisa propriedades numéricas como estabilidade, tratamento de problemas stiff e controle de erro, além de aspectos práticos de implementação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Avaliar estabilidade e precisão espectral",
                            "description": "Explicar a estabilidade neutra em Fourier e a precisão exponencial em Chebyshev, calculando o erro de truncamento O(e^{-N}) para soluções suaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos Pseudoespectrais e Estabilidade em Fourier",
                                  "subSteps": [
                                    "Estude a representação de funções via séries de Fourier e truncamento em N modos.",
                                    "Analise a amplificação de modos altos em esquemas de tempo explícitos para EDOs.",
                                    "Derive a condição de estabilidade neutra: amplificação unitária para todos os modais.",
                                    "Compare com métodos finitos diferenciais, destacando ausência de dissipação artificial.",
                                    "Implemente um exemplo simples de integração temporal em código para visualização."
                                  ],
                                  "verification": "Derive corretamente a matriz de amplificação unitária para Fourier e simule sem instabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (e.g., Trefethen 'Spectral Methods'), MATLAB/Python com FFT, notas de aula sobre pseudoespectrais.",
                                  "tips": "Use plots de espectro para visualizar modos neutros; evite N muito pequeno para ver efeitos.",
                                  "learningObjective": "Compreender por que Fourier é estável neutro para problemas lineares suaves.",
                                  "commonMistakes": "Confundir neutralidade com instabilidade; ignorar dependência em esquemas de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Precisão Exponencial em Bases de Chebyshev",
                                  "subSteps": [
                                    "Revise polinômios de Chebyshev e sua ortogonalidade em [-1,1].",
                                    "Analise aliasing geométrico: convergência espectral para funções analíticas.",
                                    "Derive taxa de erro exponencial: ||f - P_N f|| ~ O(e^{-q N}) para raios analíticos q.",
                                    "Compare coeficientes de Fourier (algebraico) vs. Chebyshev (exponencial) para funções suaves.",
                                    "Teste numericamente com função runge ou gaussiana mapeada."
                                  ],
                                  "verification": "Calcule coeficientes de Chebyshev para f(x)=e^x e mostre decaimento exponencial nos coeficientes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software Chebfun ou SciPy, gráficos semi-log dos coeficientes, referências como Weideman notes.",
                                  "tips": "Mapeie periodicidade para Chebyshev via transformação; foque em funções analíticas.",
                                  "learningObjective": "Explicar superioridade de Chebyshev para precisão em domínios não-periódicos.",
                                  "commonMistakes": "Aplicar Fourier a funções não-periódicas (Gibbs); subestimar raio analítico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Erro de Truncamento O(e^{-N}) para Soluções Suaves",
                                  "subSteps": [
                                    "Defina soluções suaves: analíticas com raio de convergência positivo.",
                                    "Estime erro de truncamento via resíduo da série: integral de Cauchy ou bounding.",
                                    "Derive explicitamente O(e^{-q N}) para Chebyshev em EDOs lineares.",
                                    "Aplique a uma EDO modelo: y' = -y, solução y=exp(-t), truncada em N.",
                                    "Quantifique erro L2 e L∞ vs. N em simulação numérica."
                                  ],
                                  "verification": "Compute erro para N=10,20,40 e confirme decaimento log-linear em log(N).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código Python/MATLAB para resolver EDO espectral, tabelas de erro, teorema de Bernstein.",
                                  "tips": "Use log-plot para visualizar exponencial; normalize erro por norma da solução.",
                                  "learningObjective": "Calcular quantitativamente erro de truncamento e sua dependência em suavidade.",
                                  "commonMistakes": "Confundir erro de truncamento com erro de tempo; usar funções não-suaves."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Estabilidade e Precisão em Aplicação a EDOs",
                                  "subSteps": [
                                    "Implemente solver pseudoespectral para EDO y'=λy em Fourier e Chebyshev.",
                                    "Meça estabilidade: CFL para Fourier neutro vs. restrições em Chebyshev.",
                                    "Avalie precisão: erro vs. N para λ complexo (oscilatório).",
                                    "Discuta trade-offs: Fourier para periódico, Chebyshev para suave não-periódico.",
                                    "Otimize N mínimo para erro <1e-10."
                                  ],
                                  "verification": "Gere relatório com tabelas/plots comparativos mostrando O(e^{-N}) em Chebyshev.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Jupyter notebook template, FFT/chebpy libraries, exemplos de Canuto & Hussaini.",
                                  "tips": "Escolha λ=-1+i para testar ambos aspectos; valide com solução exata.",
                                  "learningObjective": "Integrar conceitos para avaliar métodos em contextos reais.",
                                  "commonMistakes": "Ignorar mapeamento de domínio; não escalar tempo adequadamente."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a EDO y'' + y = 0 (oscilador harmônico) em [0,2π] com y(0)=1, y'(0)=0 usando Fourier (periódico) e Chebyshev (mapeado). Compare estabilidade para passos de tempo Δt=0.1 (Fourier neutro sem blow-up) e erro de truncamento para N=32: Fourier ~1/N^2, Chebyshev ~e^{-N/2}, confirmando precisão exponencial.",
                              "finalVerifications": [
                                "Explicar verbalmente estabilidade neutra em Fourier sem hesitação.",
                                "Derivar fórmula de erro O(e^{-q N}) para função analítica dada.",
                                "Implementar código que plota erro vs. log(N) mostrando decaimento exponencial.",
                                "Comparar corretamente Fourier vs. Chebyshev para EDO oscilatória.",
                                "Identificar quando usar cada método baseado em periodicidade/suavidade.",
                                "Calcular N mínimo para erro alvo de 1e-12 em solução suave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de estabilidade neutra (amplificação |G(k)|=1 para todos k).",
                                "Correção na análise de precisão exponencial (decaimento coeficientes ~ρ^{-n}).",
                                "Exatidão no cálculo de erro O(e^{-N}), com q ligado a raio analítico.",
                                "Qualidade de simulações numéricas (plots, tabelas com convergência).",
                                "Profundidade na comparação e trade-offs entre bases.",
                                "Clareza em explicações e identificação de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações de onda/periódicas (mecânica quântica).",
                                "Computação Científica: Implementação eficiente de FFT/Chebyshev em HPC.",
                                "Engenharia: Simulações CFD onde precisão espectral acelera convergência.",
                                "Estatística: Análise espectral de séries temporais não-estacionárias."
                              ],
                              "realWorldApplication": "Em modelagem climática (previsão do tempo), métodos Fourier são usados para estabilidade em domínios periódicos globais, enquanto Chebyshev aplica-se a perfis verticais suaves com precisão exponencial, permitindo simulações de alta resolução com N baixo e reduzindo custo computacional em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Tratar problemas stiff com métodos espectrais",
                            "description": "Discutir limitações em EDOs stiff e estratégias como bases racionais ou combinação com métodos implicitos, referenciando controle de passo adaptativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas stiff em EDOs e limitações dos métodos espectrais explícitos",
                                  "subSteps": [
                                    "Definir problemas stiff: escalas temporais díspares levando a rigidez (ex: autovalores com partes reais negativas grandes).",
                                    "Analisar exemplos clássicos como y' = λ(y - f(t)) com |λ| grande.",
                                    "Explicar por que métodos espectrais pseudoespectrais explícitos (ex: collocation com polinômios de Chebyshev) falham devido a restrições de estabilidade severas.",
                                    "Discutir impacto na precisão e eficiência computacional.",
                                    "Comparar com métodos de diferenças finitas explícitas."
                                  ],
                                  "verification": "Resolver numericamente um EDO stiff simples com método espectral explícito e observar oscilações ou divergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Spectral Methods in MATLAB' de Trefethen",
                                    "Python com NumPy/SciPy e Chebfun",
                                    "Exemplos de EDOs stiff online"
                                  ],
                                  "tips": "Comece com λ pequeno e aumente gradualmente para visualizar o breakdown.",
                                  "learningObjective": "Identificar e quantificar limitações de estabilidade em métodos espectrais para EDOs stiff.",
                                  "commonMistakes": [
                                    "Confundir stiff com nonlinearidade",
                                    "Ignorar análise espectral dos autovalores da Jacobiana"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar bases racionais em métodos espectrais para tratar rigidez",
                                  "subSteps": [
                                    "Introduzir bases racionais: funções racionais com polos otimizados para aproximar exponenciais de autovalores stiff.",
                                    "Estudar métodos como Rational Chebyshev Tau ou filters espectrais (ex: exponential integrators).",
                                    "Derivar aproximações racionais para o resolvedor exato e'^{tA} usando LEARNED ou Zolotarev.",
                                    "Implementar uma base racional simples em código para um operador linear stiff.",
                                    "Analisar estabilidade e precisão via erro de truncamento."
                                  ],
                                  "verification": "Implementar e testar um filtro racional em um problema linear stiff, verificando convergência exponencial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Paper 'Spectral deferred corrections' de Dutt et al.",
                                    "MATLAB Chebfun toolbox",
                                    "Código fonte de exponential integrators no GitHub"
                                  ],
                                  "tips": "Escolha polos próximos aos autovalores stiff para otimização.",
                                  "learningObjective": "Aplicar bases racionais para estabilizar métodos espectrais em regimes stiff.",
                                  "commonMistakes": [
                                    "Polos mal posicionados levando a ill-conditioning",
                                    "Não normalizar a base adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar métodos espectrais com esquemas implícitos",
                                  "subSteps": [
                                    "Revisar métodos implícitos padrão (Backward Euler, BDF, DIRK) para stiff ODEs.",
                                    "Desenvolver hibridos: collocation espectral implícito ou spectral viscosity com Runge-Kutta implícito.",
                                    "Implementar um solver como implicit-explicit (IMEX) onde partes stiff são implícitas e não-stiff espectrais.",
                                    "Analisar ordem de precisão e custo computacional (iterações de Newton).",
                                    "Testar em EDOs semilinear stiff."
                                  ],
                                  "verification": "Comparar solução IMEX-espectral com solução de referência (ex: ODE45 com tolerâncias apertadas).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Livro 'Solving Ordinary Differential Equations II' de Hairer",
                                    "Python SciPy solve_ivp com method='BDF'",
                                    "Jupyter notebook para prototipagem"
                                  ],
                                  "tips": "Use preconditioning espectral para acelerar solves lineares implícitos.",
                                  "learningObjective": "Integrar componentes implícitos para superar limitações espectrais puras.",
                                  "commonMistakes": [
                                    "Não tratar adequadamente o acoplamento explícito-implícito",
                                    "Subestimar overhead de iterações não-lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar controle de passo adaptativo em métodos espectrais para stiff problems",
                                  "subSteps": [
                                    "Explicar necessidade de adaptação: passos pequenos para stiff transients, grandes para smooth phases.",
                                    "Desenvolver estimadores de erro locais baseados em resíduos espectrais ou embedded Runge-Kutta.",
                                    "Implementar algoritmo de passo adaptativo: PID-like controller ou Bogacki-Shampine para espectrais.",
                                    "Integrar com bases racionais/IMEX para eficiência.",
                                    "Otimizar hiperparâmetros via testes em benchmarks stiff."
                                  ],
                                  "verification": "Executar simulação adaptativa em EDO stiff e plotar histórico de passos/erros, confirmando eficiência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código de referência do FEniCS ou Dedalus para spectral adaptivo",
                                    "Benchmark suite CANTOR para stiff ODEs"
                                  ],
                                  "tips": "Monitore norma espectral do erro para triggers de refinamento.",
                                  "learningObjective": "Criar solvers robustos e eficientes com adaptação automática para problemas stiff.",
                                  "commonMistakes": [
                                    "Oscilações no tamanho de passo devido a overshooting",
                                    "Ignorar overhead inicial de setup espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e validar o método em um problema stiff real",
                                  "subSteps": [
                                    "Selecionar problema teste: ex: stiff van der Pol μ=1000 ou reação química de Robertson.",
                                    "Implementar solver completo (racional/IMEX + adaptativo).",
                                    "Comparar com solvers black-box (CVODE, RADAU).",
                                    "Analisar estabilidade (espectro de Lyapunov), precisão e custo.",
                                    "Documentar trade-offs e recomendações."
                                  ],
                                  "verification": "Solução converge à referência com erro <1e-6 e speedup >2x vs explícito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Suite de testes stiff ODEs (SUITE_SHOK",
                                    "Python/MATLAB para plotting"
                                  ],
                                  "tips": "Vectorize operações espectrais para performance.",
                                  "learningObjective": "Validar abordagem integrada em contexto prático.",
                                  "commonMistakes": [
                                    "Benchmark inadequado mascarando falhas",
                                    "Não reportar flops por solução"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um solver espectral racional-IMEX adaptativo para o problema stiff y' = -1001*y + 1000*cos(t), y(0)=1, no intervalo [0,10]. Compare com SciPy's solve_ivp('BDF') e demonstre estabilidade sem restrições de timestep explícito.",
                              "finalVerifications": [
                                "Explicar limitações de métodos espectrais explícitos em stiff ODEs com exemplo numérico.",
                                "Derivar e codificar uma base racional simples para filtro stiff.",
                                "Implementar e testar esquema IMEX-espectral com convergência de ordem 2+.",
                                "Demonstrar controle adaptativo reduzindo passos em 50% vs fixo.",
                                "Analisar estabilidade via eigenvalues e erro global <1e-5 em benchmark.",
                                "Documentar código funcional e relatório de performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de stiff e estratégias (90%+).",
                                "Qualidade da implementação: código roda sem erros, convergência verificada.",
                                "Eficiência: speedup mensurável vs baselines.",
                                "Análise profunda: discussão de trade-offs estabilidade/precisão/custo.",
                                "Criatividade: extensões como paralelização ou nonlinear stiff.",
                                "Clareza: documentação e visualizações de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de plasmas ou fluidos com multi-escalas.",
                                "Química Computacional: cinética de reações stiff em modelagem molecular.",
                                "Engenharia de Controle: estabilização de sistemas dinâmicos rígidos.",
                                "Ciência da Computação: algoritmos numéricos paralelizáveis em HPC."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas em reatores industriais (ex: petroquímica), onde escalas rápidas de espécies intermediárias exigem solvers stiff-efficientes para otimizar yields sem crashes numéricos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Implementar algoritmo completo em software",
                            "description": "Codificar em Python/MATLAB um solver pseudoespectral para PVI simples, como y'' + y = 0, validando contra soluções exatas e analisando convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de programação e definir o problema",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: NumPy, SciPy e Matplotlib para Python (ou equivalente em MATLAB).",
                                    "Definir o problema PVI: y'' + y = 0 com condições iniciais y(0) = 1, y'(0) = 0, no intervalo [0, π].",
                                    "Calcular e armazenar a solução exata: y_exact = cos(x).",
                                    "Definir parâmetros: número de pontos N (ex: 16, 32 para convergência), pontos de Chebyshev-Gauss-Lobatto.",
                                    "Criar função para gerar pontos e pesos de Chebyshev."
                                  ],
                                  "verification": "Verificar se o ambiente roda sem erros e y_exact(0) == 1 e y_exact'(0) == 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/MATLAB instalado, bibliotecas NumPy/SciPy/Matplotlib.",
                                  "tips": "Use scripts Jupyter Notebook para interatividade e visualizações rápidas.",
                                  "learningObjective": "Entender e configurar o problema matemático e computacional para método pseudoespectral.",
                                  "commonMistakes": "Esquecer de importar bibliotecas ou definir condições iniciais incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar operadores diferenciais espectrais",
                                  "subSteps": [
                                    "Gerar malha de pontos x em [-1,1] via Chebyshev (mapear para [0,π]).",
                                    "Construir matriz de diferenciação primeira (D1) e segunda (D2) ordem usando polinômios de Chebyshev.",
                                    "Implementar multiplicação por matriz de diferenciação: Dy = D @ y para derivadas.",
                                    "Testar operador em função conhecida, como sin(x), verificando derivada cos(x).",
                                    "Ajustar para condições de contorno iniciais incorporando em D."
                                  ],
                                  "verification": "Aplicar D2 em y = cos(x) e checar se resulta em -cos(x) nos pontos internos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do Step 1, funções prontas de spectral methods (ex: cheb.py ou funções MATLAB).",
                                  "tips": "Use funções vetorizadas para eficiência; debugue com N pequeno (8 pontos).",
                                  "learningObjective": "Dominar discretização espectral via diferenciação matricial.",
                                  "commonMistakes": "Índices errados nas matrizes D (pontos fantasmas) ou mapeamento de domínio incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e resolver o sistema de equações",
                                  "subSteps": [
                                    "Formular sistema: D2 y + y = 0 para pontos internos, aplicando y(0)=1, y'(0)=0.",
                                    "Construir matriz A e vetor b do sistema linear A y = b.",
                                    "Resolver usando solver linear (np.linalg.solve ou MATLAB backslash).",
                                    "Extrapoler solução para pontos de Chebyshev e mapear de volta ao domínio físico.",
                                    "Implementar para múltiplos N e armazenar soluções."
                                  ],
                                  "verification": "Checar se norma residual ||D2 y + y|| < 1e-10 nos pontos internos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código dos Steps 1-2, solver linear.",
                                  "tips": "Imponha condições iniciais removendo linhas/colunas correspondentes em A.",
                                  "learningObjective": "Aplicar método de collocation espectral para resolver PVI.",
                                  "commonMistakes": "Não tratar corretamente condições de contorno, levando a singularidade em A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar solução contra exata e visualizar",
                                  "subSteps": [
                                    "Calcular erro: max |y_num - y_exact| e L2 norm.",
                                    "Plotar y_num vs y_exact em malha uniforme (interpole se necessário).",
                                    "Implementar análise de convergência: log-log plot de erro vs N.",
                                    "Verificar ordem de convergência espectral (esperado ~N^2 ou melhor).",
                                    "Salvar figuras e dados para relatório."
                                  ],
                                  "verification": "Erro máximo < 1e-6 para N=32 e slope ~2 no log-log.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código anterior, Matplotlib para plots.",
                                  "tips": "Use interp1d para interpolação suave em plots.",
                                  "learningObjective": "Avaliar precisão e propriedades de convergência do método.",
                                  "commonMistakes": "Comparar em pontos espectrais sem interpolação, ou escalas erradas em plots."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar estabilidade e refinar implementação",
                                  "subSteps": [
                                    "Testar estabilidade variando condições iniciais ou equações similares (ex: y'' + k^2 y=0).",
                                    "Analisar custo computacional: tempo vs N.",
                                    "Otimizar código (vetorização, pré-computar D).",
                                    "Documentar código com comentários e funções modulares.",
                                    "Preparar relatório com resultados e discussões."
                                  ],
                                  "verification": "Código roda para N=128 sem crash e mantém precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código completo, timer (timeit).",
                                  "tips": "Profile o código para bottlenecks em solve linear.",
                                  "learningObjective": "Entender limitações e otimizações em implementações espectrais.",
                                  "commonMistakes": "Ignorar ill-conditioning para N grande sem refinamentos."
                                }
                              ],
                              "practicalExample": "Implemente o solver para y'' + y = 0, y(0)=1, y'(0)=0 em [0, π]. Para N=32, obtenha erro máximo ~1e-8, plotando y_num sobrepondo cos(x) perfeitamente, com convergência exponencial em log-log.",
                              "finalVerifications": [
                                "Solução numérica reproduz cos(x) com erro <1e-6 para N>=16.",
                                "Análise de convergência mostra ordem espectral (erro ~ exp(-N)).",
                                "Código roda em <1s para N=64 e é modular/reutilizável.",
                                "Plots mostram sobreposição perfeita e residual nulo.",
                                "Testes com variações (ex: y(0)=0, y'(0)=1) funcionam corretamente.",
                                "Documentação inclui equação, método e resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L-infty <1e-6 e convergência demonstrada.",
                                "Correção teórica: Operadores D1/D2 implementados precisamente.",
                                "Eficiência: Tempo de execução escalável com N.",
                                "Visualização: Plots claros de solução, erro e convergência.",
                                "Robustez: Funciona para parâmetros variados sem crashes.",
                                "Código: Limpo, comentado, com funções separadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos e linear algebra em Python/MATLAB.",
                                "Física: Modelagem de oscilador harmônico em mecânica.",
                                "Engenharia: Simulações em controle e dinâmica de sistemas.",
                                "Estatística: Análise de erros e validação numérica."
                              ],
                              "realWorldApplication": "Desenvolvimento de solvers para simulações em engenharia aeroespacial (fluxos instáveis), previsão climática (modelos ODE/PDE espectrais) e finanças (equações diferenciais estocásticas), onde alta precisão com poucos pontos é crucial."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Precisão e Estabilidade",
                    "description": "Análise da convergência espectral exponencial e condições de estabilidade nos métodos pseudoespectrais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Convergência Espectral Exponencial",
                        "description": "Análise da precisão nos métodos pseudoespectrais, caracterizada por uma convergência exponencial do erro de truncamento com o aumento do número de modos espectrais, diferenciando-se da convergência polinomial dos métodos de diferenças finitas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Identificar bases espectrais para convergência",
                            "description": "Reconhecer e descrever as bases espectrais (Fourier para domínios periódicos e Chebyshev/Legendre para não-periódicos) usadas nos métodos pseudoespectrais e sua relação com a suavidade da solução para garantir convergência exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de bases espectrais em métodos pseudoespectrais",
                                  "subSteps": [
                                    "Defina métodos pseudoespectrais como aproximações globais usando expansões em séries ortogonais.",
                                    "Explique o papel das bases espectrais na representação de funções suaves.",
                                    "Discuta a importância da ortogonalidade para minimizar erros de projeção.",
                                    "Compare brevemente com métodos de diferenças finitas para destacar vantagens em suavidade.",
                                    "Revise a convergência espectral exponencial para funções analíticas."
                                  ],
                                  "verification": "Liste e explique três propriedades chave das bases espectrais usadas em pseudoespectrais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: Trefethen 'Spectral Methods'), notas de aula sobre pseudoespectrais",
                                    "Software MATLAB/Python com bibliotecas Chebfun ou Dedalus"
                                  ],
                                  "tips": "Foquem na intuição geométrica: bases espectrais 'veem' a função globalmente.",
                                  "learningObjective": "Entender o que são bases espectrais e seu uso em métodos pseudoespectrais para soluções suaves.",
                                  "commonMistakes": [
                                    "Confundir bases espectrais com bases locais (ex: finitas)",
                                    "Ignorar a exigência de suavidade para convergência rápida",
                                    "Pensar que todas as bases funcionam igualmente para qualquer domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar bases de Fourier para domínios periódicos",
                                  "subSteps": [
                                    "Descreva a base de Fourier: séries de senos e cossenos para intervalos [0, 2π] ou periódicos.",
                                    "Explique por que funções periódicas e suaves garantem aliasing mínimo e convergência exponencial.",
                                    "Implemente uma expansão de Fourier simples para uma função seno periódica.",
                                    "Analise o espectro de coeficientes decaindo exponencialmente para funções analíticas.",
                                    "Teste numericamente a taxa de convergência com N modos crescentes."
                                  ],
                                  "verification": "Expanda uma função periódica suave em Fourier e mostre decaimento exponencial dos coeficientes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB para FFT",
                                    "Gráficos de espectros de Fourier",
                                    "Exemplos de ondas periódicas"
                                  ],
                                  "tips": "Use FFT para visualização rápida; verifique periodicidade estrita nas condições de contorno.",
                                  "learningObjective": "Reconhecer quando e por quê usar Fourier em problemas periódicos para convergência ótima.",
                                  "commonMistakes": [
                                    "Aplicar Fourier a funções não-periódicas (causa Gibbs phenomenon)",
                                    "Esquecer de mapear domínios para [0, 2π]",
                                    "Interpretar mal o decaimento polinomial vs exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar bases polinomiais Chebyshev e Legendre para domínios não-periódicos",
                                  "subSteps": [
                                    "Defina polinômios Chebyshev (no [-1,1], peso 1/sqrt(1-x²)) e Legendre (peso 1).",
                                    "Explique adaptação para domínios não-periódicos via mapeamento.",
                                    "Compare pesos e nodos: Chebyshev minimiza Runge phenomenon em aproximações.",
                                    "Expanda uma função suave não-periódica (ex: exp(-1/(1-x²))) em cada base.",
                                    "Verifique convergência exponencial para soluções analíticas."
                                  ],
                                  "verification": "Aplique expansão Chebyshev a uma função não-periódica e compare erro com Legendre.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca Chebfun (MATLAB) ou ApproxFun (Julia)",
                                    "Tabelas de polinômios ortogonais",
                                    "Código para quadratura Gauss-Lobatto"
                                  ],
                                  "tips": "Prefira Chebyshev para problemas práticos devido a nodos clustered nas extremidades.",
                                  "learningObjective": "Identificar e descrever bases adequadas para funções não-periódicas.",
                                  "commonMistakes": [
                                    "Usar Fourier em não-periódicos (instabilidade)",
                                    "Confundir pesos de Chebyshev com uniforme",
                                    "Subestimar necessidade de suavidade global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar escolha da base com suavidade da solução e convergência exponencial",
                                  "subSteps": [
                                    "Discuta como suavidade (analiticidade) determina decaimento de coeficientes.",
                                    "Compare taxas: exponencial para analíticas vs algebraica para C^k.",
                                    "Avalie critérios de escolha: periodicidade vs suavidade nas fronteiras.",
                                    "Simule um problema onde mismatch causa convergência lenta.",
                                    "Resuma regras: Fourier (periódico/suave), Chebyshev/Legendre (não-periódico/suave)."
                                  ],
                                  "verification": "Para um problema dado, justifique a base ótima e preveja taxa de convergência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos numéricos de convergência (gráficos log-log)",
                                    "Artigos sobre teoria de erro espectral"
                                  ],
                                  "tips": "Sempre cheque suavidade nas condições de contorno primeiro.",
                                  "learningObjective": "Explicar a relação entre base espectral, suavidade e garantia de convergência exponencial.",
                                  "commonMistakes": [
                                    "Atribuir convergência lenta só a N baixo, ignorando mismatch de base",
                                    "Achar que Legendre é sempre melhor que Chebyshev",
                                    "Negligenciar impacto de singularidades próximas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de ecuación de onda periódica em um anel (domínio periódico), use base Fourier para capturar modos com poucos coeficientes, alcançando erro 10^-10 com N=32. Para a equação de calor em [-1,1] com condições Dirichlet suaves (não-periódicas), base Chebyshev converge exponencialmente, evitando oscilações de Gibbs vistas com Fourier.",
                              "finalVerifications": [
                                "Identificar corretamente Fourier para problemas periódicos e explicar por quê.",
                                "Descrever diferenças entre Chebyshev e Legendre para não-periódicos.",
                                "Explicar como suavidade afeta decaimento de coeficientes.",
                                "Justificar escolha de base para um problema dado visando convergência exponencial.",
                                "Analisar numericamente um espectro e prever taxa de convergência.",
                                "Comparar erros de aproximação para funções suaves vs não-suaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre domínios periódicos e não-periódicos.",
                                "Correta associação de bases (Fourier, Chebyshev, Legendre) com contextos.",
                                "Explicação clara da dependência em suavidade para convergência exponencial.",
                                "Uso de exemplos numéricos ou gráficos para suporte.",
                                "Identificação de erros comuns como Gibbs ou Runge.",
                                "Capacidade de aplicar em problemas reais de pseudoespectrais."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Ondas e FFT em mecânica quântica.",
                                "Engenharia: Simulações CFD com spectral methods em fluidos.",
                                "Processamento de Sinais: Análise Fourier para dados periódicos.",
                                "Física Matemática: Expansões ortogonais em EDOs/PDEs."
                              ],
                              "realWorldApplication": "Em modelagem climática, bases Fourier são usadas para dinâmicas periódicas em longitude, enquanto Chebyshev modela perfis verticais não-periódicos em atmosferas, garantindo simulações precisas de alta resolução com convergência rápida para previsões confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Calcular erro de truncamento espectral",
                            "description": "Calcular analiticamente e numericamente o erro de truncamento espectral para uma função suave projetada em uma base espectral finita, demonstrando a dependência exponencial em termos do número de modos N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de métodos espectrais e truncamento",
                                  "subSteps": [
                                    "Estude a expansão de uma função suave f(x) em uma base espectral, como séries de Fourier ou polinômios de Chebyshev.",
                                    "Identifique os coeficientes espectrais ĉ_k e o operador de truncamento P_N que retém apenas modos |k| ≤ N.",
                                    "Analise o resíduo e_N(x) = f(x) - P_N f(x) para funções analíticas.",
                                    "Revise teoremas de convergência exponencial para funções suaves.",
                                    "Pratique com exemplos simples, como f(x) = cos(x) em Fourier."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e dê um exemplo manual de truncamento para N=2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (e.g., Trefethen 'Spectral Methods'), notebook Jupyter"
                                  ],
                                  "tips": "Comece com bases periódicas (Fourier) para simplicidade antes de não-periódicas.",
                                  "learningObjective": "Compreender o truncamento espectral e sua relação com funções suaves.",
                                  "commonMistakes": [
                                    "Confundir truncamento com projeção aliasing",
                                    "Ignorar periodicidade da base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar analiticamente o erro de truncamento",
                                  "subSteps": [
                                    "Expresse o erro e_N(x) = ∑_{|k|>N} ĉ_k φ_k(x), onde φ_k são funções base.",
                                    "Estime |ĉ_k| ≤ C ρ^{-|k|} para funções analíticas com raio de analiticidade ρ.",
                                    "Derive a bound exponencial ||e_N|| ≤ K exp(-c N) para norma L^∞ ou L^2.",
                                    "Calcule explicitamente para f(x) = exp(sin(π x)) em [-1,1] com Chebyshev.",
                                    "Generalize para diferentes bases e normas."
                                  ],
                                  "verification": "Escreva a derivação passo a passo e compute a bound para N=10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis ou LaTeX para derivações",
                                    "Referências: Canuto et al. 'Spectral Methods']",
                                    "tips: "
                                  ],
                                  "learningObjective": "Derivar bounds analíticos para erro de truncamento exponencial.",
                                  "commonMistakes": [
                                    "Erros em estimativas de coeficientes de decaimento",
                                    "Confundir normas L2 e L∞"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo numérico do erro",
                                  "subSteps": [
                                    "Implemente computação de coeficientes espectrais via FFT para base Fourier.",
                                    "Aplique truncamento P_N reconstruindo a soma parcial.",
                                    "Calcule erros numéricos em normas L2 e L∞ para uma grelha de pontos.",
                                    "Teste com f(x) = exp(-1/(1-x^2)) (função suave de Runge).",
                                    "Varie N de 8 a 256 e plote log(erros) vs N."
                                  ],
                                  "verification": "Gere plots mostrando erros decaindo exponencialmente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy (FFT), Matplotlib"
                                  ],
                                  "tips": "Use grelhas uniformes com 2N+1 pontos para evitar aliasing.",
                                  "learningObjective": "Implementar numericamente projeção e truncamento espectral.",
                                  "commonMistakes": [
                                    "Poucos pontos de grelha levando a erros de amostragem",
                                    "Não normalizar FFT corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e demonstrar dependência exponencial",
                                  "subSteps": [
                                    "Compare erros analíticos e numéricos para múltiplos N.",
                                    "Ajuste curvas log(erros) vs N para extrair taxa exponencial c.",
                                    "Teste sensibilidade a suavidade variando parâmetros da função.",
                                    "Discuta discrepâncias e melhore precisão numérica.",
                                    "Conclua com relatório resumindo dependência em N."
                                  ],
                                  "verification": "Produza tabela e gráfico comparando analítico vs numérico, com taxa c estimada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do step 3, SciPy para curve_fit"
                                  ],
                                  "tips": "Log-plot para visualizar exponencialidade claramente.",
                                  "learningObjective": "Demonstrar numericamente convergência exponencial e validar teoria.",
                                  "commonMistakes": [
                                    "Escala log vs linear nos plots",
                                    "Sobreajuste de curvas sem bounds físicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = exp(sin(2π x)) em [0,1] com base Fourier, compute coeficientes via FFT, trunque em N=16, reconstrua e meça ||f - P_{16}f||_∞ ≈ 10^{-5}, confirmando decaimento exp(-π N / ρ).",
                              "finalVerifications": [
                                "Erro numérico coincide com bound analítico dentro de fator 2.",
                                "Log-plot de erro vs N é linear com inclinação negativa.",
                                "Taxa exponencial c > 0.5 para funções analíticas.",
                                "Código roda sem erros para N até 512.",
                                "Relatório explica dependência em suavidade da função.",
                                "Testes com diferentes funções confirmam generalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação analítica (equações corretas e bounds).",
                                "Correção do código numérico (FFT e normas exatas).",
                                "Qualidade dos plots e análise quantitativa de c.",
                                "Compreensão demonstrada em relatório (conexão teoria-prática).",
                                "Tratamento de erros comuns e sensibilidade.",
                                "Eficiência computacional para grandes N."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de PDEs via pseudoespectrais (e.g., Navier-Stokes).",
                                "Engenharia: Otimização de precisão em CFD e acústica.",
                                "Ciência da Computação: Algoritmos FFT rápidos e análise de complexidade.",
                                "Estatística: Análise de séries temporais espectrais."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), onde métodos espectrais truncam modos altos para resolver equações atmosféricas com precisão exponencial, permitindo simulações eficientes em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Comparar convergência com métodos finitos",
                            "description": "Comparar graficamente e quantitativamente a ordem de convergência exponencial dos métodos pseudoespectrais versus a convergência de segunda ordem dos métodos de diferenças finitas centradas para a solução de EDOs ou EDPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos dos métodos de diferenças finitas centradas e pseudoespectrais",
                                  "subSteps": [
                                    "Estude a formulação das diferenças finitas centradas para EDOs/EDPs, focando na aproximação de segunda ordem: u''(x) ≈ [u(x+h) - 2u(x) + u(x-h)] / h².",
                                    "Revise os métodos pseudoespectrais, como FFT para derivadas, e a propriedade de convergência exponencial O(e^{-N}) para funções suaves.",
                                    "Escolha um problema teste simples, como a EDO u'' + u = 0 com condições de contorno periódicas, solução exata u(x) = sin(2πx).",
                                    "Calcule manualmente o erro para N=4 e N=8 em diferenças finitas para entender a ordem 2.",
                                    "Compare com pseudoespectral: transforme via FFT, derive no espaço de Fourier e transforme de volta."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças chave em precisão e forneça cálculos manuais de erro para N=4.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (Trefethen ou Canuto)",
                                    "Notebook Jupyter",
                                    "Documentação NumPy/FFT"
                                  ],
                                  "tips": "Use soluções analíticas suaves para destacar a convergência exponencial; evite singularidades.",
                                  "learningObjective": "Compreender teoricamente as taxas de convergência: O(h²) vs O(e^{-kN}).",
                                  "commonMistakes": [
                                    "Confundir ordem de precisão local com global",
                                    "Ignorar condições periódicas para pseudoespectrais",
                                    "Usar funções não suaves no teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de diferenças finitas centradas numericamente",
                                  "subSteps": [
                                    "Configure o grid com N pontos uniformes em [0,1] periódicos.",
                                    "Monte a matriz tridiagonal para o operador Laplaciano de segunda ordem.",
                                    "Resolva o sistema linear Au = f usando solver direto (ex: numpy.linalg.solve).",
                                    "Varie N de 16 a 1024, compute erro L2: ||u_num - u_exata||_2.",
                                    "Calcule ordem de convergência: log2(erro_N / erro_{2N})."
                                  ],
                                  "verification": "Gere tabela com erros e ordens para 5 valores de N; ordem deve aproximar 2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "SciPy (linalg)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use malha periódica para simplicidade; vetorize computações para eficiência.",
                                  "learningObjective": "Implementar e quantificar convergência quadrática em código.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz (não periódica)",
                                    "Norma errada (use L2 integrada)",
                                    "Não dobrar N corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método pseudoespectral e computar erros",
                                  "subSteps": [
                                    "Gere pontos de Gauss-Lobatto ou Chebyshev para N pontos.",
                                    "Implemente derivada segunda via FFT: ifft( -k² * fft(u) ) para modo periódico.",
                                    "Resolva iterativamente ou diretamente no espaço espectral: filtre modos altos.",
                                    "Compute erros L2 para mesmos N de 16 a 1024.",
                                    "Calcule taxas de convergência log-log(erro vs N)."
                                  ],
                                  "verification": "Tabela de erros mostrando queda exponencial (ex: erro < 1e-10 para N=64).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python",
                                    "NumPy.fft",
                                    "Matplotlib para plots preliminares",
                                    "SciPy.interpolate"
                                  ],
                                  "tips": "Pad com zeros no FFT para derivadas precisas; teste com senos conhecidos.",
                                  "learningObjective": "Dominar implementação espectral e observar convergência exponencial.",
                                  "commonMistakes": [
                                    "Aliasing em FFT sem padding",
                                    "Não tratar condições de contorno corretamente",
                                    "Confundir grid físico/espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar graficamente e quantitativamente as convergências",
                                  "subSteps": [
                                    "Plote log(erro) vs log(N) para ambos métodos (reta slope=2 para finitos).",
                                    "Plote log(erro) vs N para pseudoespectral (linha reta descendente).",
                                    "Compute razões de erro: erro_finitos / erro_pseudo para N fixo.",
                                    "Analise numericamente: fit exponencial e^{ -c N } vs polinomial.",
                                    "Discuta limites: quando pseudoespectral falha (não-suave)."
                                  ],
                                  "verification": "Gráficos com legendas, tabelas comparativas e conclusão escrita.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib",
                                    "NumPy.polyfit para slopes",
                                    "Jupyter"
                                  ],
                                  "tips": "Use loglog para finitos, semilogx para espectral; inclua barras de erro.",
                                  "learningObjective": "Visualizar e quantificar superioridade exponencial do pseudoespectral.",
                                  "commonMistakes": [
                                    "Escalas erradas nos plots",
                                    "Não normalizar erros adequadamente",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente u''(x) = -π² sin(π x) em [0,2] periódico, u_exata = sin(π x). Implemente ambos métodos, plote erros: finitos caem como N^{-2}, pseudoespectral como e^{-N/2} (erro ~1e-12 em N=32 vs 1e-3 finitos).",
                              "finalVerifications": [
                                "Tabelas de erro mostram ordem ~2 para finitos e <1e-10 rápido para pseudoespectral.",
                                "Plots log-log confirmam slope=2 vs queda exponencial linear em semilog.",
                                "Razões erro_finitos/erros_pseudo >1000 para N>64.",
                                "Código roda sem erros e reproduz resultados em máquina padrão.",
                                "Relatório resume vantagens: precisão para N baixo em pseudoespectral.",
                                "Teste com função não-suave mostra perda de exponencialidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação: erros coincidem com teoria (±10%).",
                                "Qualidade dos plots: eixos log corretos, legendas, múltiplos N.",
                                "Análise quantitativa: cálculo correto de ordens via log ratios.",
                                "Profundidade da discussão: menciona suavidade, custo O(N log N) vs O(N³).",
                                "Clareza do código: comentado, modular, reutilizável.",
                                "Conclusão fundamentada: quando usar cada método."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de ondas/PDES em CFD.",
                                "Programação Científica: otimização NumPy/FFT para HPC.",
                                "Estatística: análise de erros e ajuste de curvas de convergência.",
                                "Engenharia: precisão em modelagem aeroespacial (turbulência).",
                                "Visualização de Dados: plots log para análise científica."
                              ],
                              "realWorldApplication": "Em previsão numérica do tempo (modelos espectrais como ECMWF usam FFT para convergência rápida em grids globais) ou simulações CFD (DNS de turbulência), onde precisão exponencial permite resoluções altas com N moderado, reduzindo custo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Condições de Estabilidade",
                        "description": "Estudo das condições necessárias para a estabilidade numérica nos métodos pseudoespectrais, incluindo restrições no passo de tempo Δt baseadas em análises espectrais e normas de energia, especialmente para problemas de valor inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Analisar amplificação espectral",
                            "description": "Derivar o símbolo de amplificação para operadores diferenciais espectrais (ex.: derivada espectral em base Fourier) e analisar sua magnitude para garantir |G(k)| ≤ 1 em todos os modos k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar representação espectral em base Fourier",
                                  "subSteps": [
                                    "Lembre-se da expansão de Fourier para uma função periódica u(x) = ∑ û_k e^{i k x}.",
                                    "Identifique os coeficientes espectrais û_k como os modos k.",
                                    "Entenda como operadores diferenciais atuam multiplicativamente no espaço espectral.",
                                    "Escreva a derivada espacial d/dx u(x) no espaço espectral: multiplicação por i k.",
                                    "Verifique com um exemplo simples: seno(x) tem derivada cosseno(x), e seus coeficientes confirmam i k."
                                  ],
                                  "verification": "Escreva a transformação espectral de uma função teste e confirme os coeficientes manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis; Python com NumPy e FFT para verificação numérica.",
                                  "tips": "Use a convenção de Fourier com 2π normalizado para simplificar ik.",
                                  "learningObjective": "Compreender como os modos espectrais representam operadores diferenciais.",
                                  "commonMistakes": "Confundir base real vs. complexa; esquecer normalização da FFT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o símbolo de amplificação G(k) para derivada espectral",
                                  "subSteps": [
                                    "Para um esquema temporal explícito como u^{n+1} = u^n + Δt D u^n, onde D é derivada espectral.",
                                    "No espaço espectral: û_k^{n+1} = û_k^n (1 + Δt i k).",
                                    "Identifique G(k) = 1 + Δt i k como o símbolo de amplificação por modo k.",
                                    "Generalize para operadores diferenciais lineares: G(k) = 1 + Δt p(i k), onde p é o polinômio simbólico.",
                                    "Escreva explicitamente para segunda derivada: p(ξ) = -ξ², com ξ = k."
                                  ],
                                  "verification": "Derive G(k) para o esquema forward Euler em derivada primeira e confirme |G(k)|.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno de anotações; SymPy ou MATLAB para simplificação simbólica.",
                                  "tips": "Sempre especifique o esquema temporal (Euler, Runge-Kutta) para definir G(k).",
                                  "learningObjective": "Derivar símbolos de amplificação para operadores diferenciais espectrais.",
                                  "commonMistakes": "Esquecer o fator i em derivadas ímpares; confundir k físico vs. discreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e plotar a magnitude |G(k)|",
                                  "subSteps": [
                                    "Compute |G(k)| = |1 + Δt i k| = sqrt(1 + (Δt k)^2) para Euler forward em primeira derivada.",
                                    "Gere vetor de k de -K_max a K_max (modos resolvidos).",
                                    "Plote |G(k)| vs. k usando Python/MATLAB.",
                                    "Identifique o comportamento: cresce com |k| para esquemas não dissipativos.",
                                    "Compare com |G(k)| para esquemas implícitos ou upwind."
                                  ],
                                  "verification": "Gere gráfico onde |G(k)| >1 para altos k confirma instabilidade potencial.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (NumPy, Matplotlib); Jupyter notebook.",
                                  "tips": "Use k discretos: k = 2π n / N para grid de N pontos.",
                                  "learningObjective": "Visualizar o fator de amplificação espectral.",
                                  "commonMistakes": "Plotar apenas k>0 (simétrico); ignorar aliasing em k altos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade: verificar |G(k)| ≤ 1 para todos k",
                                  "subSteps": [
                                    "Estabeleça critério de Von Neumann: max_k |G(k)| ≤ 1.",
                                    "Para Euler forward: derive Δt ≤ 1 / max|k| para |G|≤1, mas note crescimento quadrático.",
                                    "Teste numericamente: encontre max |G(k)| e ajuste Δt até ≤1.",
                                    "Discuta limitações: condição necessária mas não suficiente para não-lineares.",
                                    "Conclua com CFL espectral: Δt ≤ C / K_max."
                                  ],
                                  "verification": "Ajuste Δt até max|G(k)|=1 e documente o valor limite.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código Python do passo anterior; calculadora.",
                                  "tips": "Analise assintótica para k grande: Re(G) para dissipação, Im para dispersão.",
                                  "learningObjective": "Aplicar análise de estabilidade espectral para condições CFL.",
                                  "commonMistakes": "Achar estabilidade se |G(0)|=1 mas ignorar altos k; confundir com análise matricial."
                                }
                              ],
                              "practicalExample": "Em simulação pseudoespectral da equação de Burgers u_t + u u_x = ν u_xx, derive G(k) para o termo linear ν u_xx como G(k)=1 + Δt ν (-k²), e verifique |G(k)|≤1 impondo Δt ≤ 2/(ν K_max²) para evitar amplificação de modos altos.",
                              "finalVerifications": [
                                "Derive corretamente G(k) para derivada espectral em Euler forward.",
                                "Plote |G(k)| e identifique max >1 para Δt grande.",
                                "Calcule Δt_max tal que max|G(k)|=1.",
                                "Explique por que |G(k)|>1 leva a instabilidade.",
                                "Aplique a um operador de segunda ordem e compare.",
                                "Verifique com FFT numérica em uma solução teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação simbólica de G(k) (100% correto).",
                                "Gráfico de |G(k)| claro, com rótulos e faixa de k completa.",
                                "Cálculo exato de condição de estabilidade Δt ≤ ...",
                                "Interpretação física: ligação com dissipação/dispersão.",
                                "Generalização para outros operadores sem erros.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações de ondas e difusão.",
                                "Engenharia Computacional: Otimização de timestep em CFD espectral.",
                                "Processamento de Sinais: Filtros FFT e estabilidade numérica.",
                                "Física Computacional: Simulações de turbulência (DNS).",
                                "Matemática Aplicada: Análise de Fourier em PDEs."
                              ],
                              "realWorldApplication": "Em modelagem climática e previsão numérica do tempo, análise de amplificação espectral garante estabilidade em simulações pseudoespectrais de equações Navier-Stokes, evitando blow-up numérico em escalas de onda altas e permitindo timesteps eficientes em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Derivar condições CFL espectrais",
                            "description": "Estabelecer condições de Courant-Friedrichs-Lewy (CFL) adaptadas aos métodos pseudoespectrais para equações de advecção e onda, relacionando Δt máximo com o número de pontos N e velocidade característica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da condição CFL em métodos de diferenças finitas e análise de Von Neumann",
                                  "subSteps": [
                                    "Estude a equação de advecção linear u_t + c u_x = 0 e seu esquema explícito upwind.",
                                    "Derive a condição CFL clássica: Δt ≤ Δx / |c|, usando análise de Von Neumann no espaço de Fourier.",
                                    "Analise o fator de amplificação g(k Δx) = 1 - i c Δt k sen(k Δx/2) ou similar, identificando |g| ≤ 1.",
                                    "Discuta limitações para alta resolução (pequeno Δx) e introduza métodos espectrais como alternativa.",
                                    "Compare estabilidade: CFL finita vs. dependência global em espectrais."
                                  ],
                                  "verification": "Escreva e justifique a fórmula CFL clássica e um gráfico de |g(k)| estável/instável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de Análise Numérica I",
                                    "Livro 'Numerical Recipes' capítulo de PDEs",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Use k = π/Δx para modo Nyquist, onde instabilidade é crítica.",
                                  "learningObjective": "Compreender a origem da CFL via amplificação de modos de Fourier.",
                                  "commonMistakes": [
                                    "Confundir CFL com precisão de truncamento",
                                    "Ignorar sinal de c (direção de advecção)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o operador de derivada no método pseudoespectral",
                                  "subSteps": [
                                    "Revise a discretização pseudoespectral: u(x_j) em N pontos equidistantes, transformada via FFT.",
                                    "Explique a derivada espectral: multiplicar coeficientes de Fourier por i k_m, onde k_m = m para m=-N/2+1 a N/2.",
                                    "Identifique o wavenumber máximo k_max ≈ π N / L (Nyquist frequency).",
                                    "Implemente numéricamente uma derivada espectral simples em Python/MATLAB para validar.",
                                    "Discuta propriedades: precisão espectral (erro exponencial) mas aliasing e Runge."
                                  ],
                                  "verification": "Compute derivada espectral de sin(x) e verifique erro < 1e-10 para N=64.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com numpy.fft",
                                    "Livro 'Spectral Methods in Fluid Dynamics' de Canuto",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use periodicidade: domínio [0, L=2π], dealiasing se necessário.",
                                  "learningObjective": "Dominar representação espectral da derivada espacial.",
                                  "commonMistakes": [
                                    "Esquecer normalização FFT (2π/L)",
                                    "Confundir índices de k (negativos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o fator de amplificação para equação de advecção no espaço espectral",
                                  "subSteps": [
                                    "No espaço de Fourier, equação torna-se ∂_t û_k = - i c k û_k para modo k.",
                                    "Para timestep Δt (método de Euler explícito): g(k) = 1 - i c k Δt.",
                                    "Calcule |g(k)|^2 = 1 + (c k Δt)^2 >1 para qualquer Δt>0? Não: para espectral é instável sem filtro!",
                                    "Corrija: em pseudoespectral, o operador é exato no espaço espectral, mas instabilidade vem de |exp(-i c k Δt)|=1, mas Euler dá |g|=sqrt(1+(c k Δt)^2).",
                                    "Derive condição |g(k)| ≤1 para todo k: requer Δt ≤ 1 / (|c| k_max)."
                                  ],
                                  "verification": "Escreva g(k) e prove Δt_max = 1 / (|c| k_max) com k_max = π (N-1)/L ≈ π N / L.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de derivações",
                                    "Software simbólico como SymPy",
                                    "Referência: Trefethen 'Spectral Methods'"
                                  ],
                                  "tips": "Linearize em torno de Euler forward; considere Runge-Kutta para melhor.",
                                  "learningObjective": "Obter fórmula CFL espectral: Δt ≤ C / (N |c| / L), C≈2π.",
                                  "commonMistakes": [
                                    "Usar k_max = 2π N / L ao invés de π N / L",
                                    "Ignorar fator 2π na FFT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para equação de onda e generalizações",
                                  "subSteps": [
                                    "Para onda 1D u_tt = c^2 u_xx: no espectral, ∂_t² û_k = - c^2 k^2 û_k.",
                                    "Use esquema de Leapfrog ou Newmark: derive g(k) ≈ exp(± i c k Δt) ideal, mas explícito dá condição similar.",
                                    "Mostre CFL: Δt ≤ 2 / (c k_max) para onda (fator 2 vs. advecção).",
                                    "Discuta dependência com N: rigidez crescente com resolução.",
                                    "Teste numericamente: rode simulação instável/estável variando Δt."
                                  ],
                                  "verification": "Derive e implemente código que falha se Δt > limiar espectral.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código MATLAB/Python para onda espectral",
                                    "Artigo sobre estabilidade espectral"
                                  ],
                                  "tips": "Para onda, modo k_max tem frequência ω_max = c k_max.",
                                  "learningObjective": "Generalizar CFL para sistemas hiperbólicos espectrais.",
                                  "commonMistakes": [
                                    "Confundir advecção (primeira ordem) com onda (segunda)",
                                    "Esquecer normalização de domínio L"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e sintetizar condições CFL espectrais",
                                  "subSteps": [
                                    "Resuma fórmulas: advecção Δt < 2π / (c N), onda similar ajustada.",
                                    "Compare com CFL finita: espectral permite Δt ~1/N vs. 1/N em finita.",
                                    "Discuta filtros espectrais (dealising) e esquemas implícitos para relaxar CFL.",
                                    "Resolva exercício: dado N=128, L=2π, c=1, calcule Δt_max.",
                                    "Documente em relatório com gráficos de estabilidade."
                                  ],
                                  "verification": "Produza tabela comparativa CFL finita/espectral para N=16,32,64.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel para plots",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Sempre inclua fator π: k_max = π N / L.",
                                  "learningObjective": "Aplicar e verificar derivação completa.",
                                  "commonMistakes": [
                                    "Subestimar k_max por fator 2",
                                    "Não considerar periodicidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para equação de advecção u_t + u_x = 0 em [0, 2π] com N=64 pontos (Δx=2π/64), c=1, derive e verifique: k_max ≈ 32, Δt_max ≈ 2π/(1*64) ≈ 0.1. Implemente Euler espectral em Python: se Δt=0.15, explode; Δt=0.08, estável por t=10.",
                              "finalVerifications": [
                                "Fórmula correta: Δt ≤ 2π / (c N) para advecção periódica.",
                                "Gráfico de |g(k)| ≤1 para k até k_max.",
                                "Código numérico roda estável com Δt ótimo.",
                                "Extensão para onda: Δt ≤ π / (c N/2).",
                                "Identificação precisa de k_max = π (N-1)/L.",
                                "Comparação quantitativa com método FD."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de g(k) (peso 30%).",
                                "Clareza na explicação de k_max e dependência em N (20%).",
                                "Validação numérica com código funcional (25%).",
                                "Generalização para onda e limitações (15%).",
                                "Síntese em fórmula explícita e exemplo prático (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de ondas e fluidos.",
                                "Processamento de Sinais: análise FFT e frequências Nyquist.",
                                "Programação Científica: implementação em NumPy/SciPy.",
                                "Otimização: escolha de Δt para eficiência computacional."
                              ],
                              "realWorldApplication": "Em simulações DNS de turbulência (ex: previsão meteorológica ou aerodinâmica), métodos espectrais exigem CFL rigorosa para estabilidade em grades finas (N>1024), otimizando tempo de CPU em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Verificar estabilidade em problemas stiff",
                            "description": "Aplicar métodos pseudoespectrais a problemas stiff iniciais e analisar numericamente a estabilidade sob integração temporal explícita versus implícita, identificando regiões instáveis no plano (Δt, N).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas stiff e métodos pseudoespectrais",
                                  "subSteps": [
                                    "Estude a definição de problemas stiff em EDOs, focando em escalas de tempo díspares (ex.: autovalores com partes reais muito negativas).",
                                    "Revise métodos pseudoespectrais: expansão em séries de Fourier/Chebyshev para discretização espacial e operadores de diferenciação espectrais.",
                                    "Analise a matriz de amplificação para integração temporal explícita (ex.: Euler forward) vs. implícita (ex.: Euler backward).",
                                    "Identifique por que métodos explícitos falham em stiff problems devido a restrições CFL severas.",
                                    "Estude o plano de estabilidade (Δt vs. N) para pseudoespectrais em stiff ODEs."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças chave entre explícito/implícito e desenhe um esboço do plano (Δt, N).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de análise numérica (ex.: Trefethen 'Spectral Methods'), notebook Jupyter",
                                    "Artigos sobre pseudoespectrais em stiff problems"
                                  ],
                                  "tips": "Use visualizações de autovalores para intuitivamente entender stiffness.",
                                  "learningObjective": "Dominar conceitos teóricos de stiffness e estabilidade em métodos espectrais.",
                                  "commonMistakes": [
                                    "Confundir stiffness com não-linearidade",
                                    "Ignorar o papel de N na resolução espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método pseudoespectral com integração explícita",
                                  "subSteps": [
                                    "Escolha um problema stiff modelo, como y' = -1000(y - sin(t)) + noise.",
                                    "Discretize espacialmente com FFT para derivadas (ex.: equação de difusão reacional).",
                                    "Implemente integração temporal explícita (Runge-Kutta 4 ou Euler forward).",
                                    "Execute simulações variando Δt e N, registrando blow-up ou oscilações.",
                                    "Colete dados de falhas de estabilidade para plotagem preliminar."
                                  ],
                                  "verification": "Execute código e confirme instabilidade para Δt grandes (plots de solução explodindo).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy, Matplotlib",
                                    "Código base de spectral methods de SpectralDNS ou Dedalus"
                                  ],
                                  "tips": "Use aliasing control com orhtogonalidade para precisão espectral.",
                                  "learningObjective": "Implementar e observar falhas explícitas em stiff problems.",
                                  "commonMistakes": [
                                    "Não tratar condições de contorno periodicamente",
                                    "Escolha inadequada de N levando a aliasing"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método pseudoespectral com integração implícita",
                                  "subSteps": [
                                    "Modifique o código para Euler backward ou Crank-Nicolson implícito, resolvendo sistemas lineares via solve espectral.",
                                    "Use operadores espectrais para inverter a matriz de amplificação implícita eficientemente.",
                                    "Simule o mesmo problema stiff, variando Δt e N amplamente.",
                                    "Compare soluções com explícita: note estabilidade incondicional para implícito.",
                                    "Registre regiões estáveis/instáveis."
                                  ],
                                  "verification": "Confirme que soluções implícitas permanecem estáveis para Δt > restrições explícitas (plots suaves).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com SciPy.sparse.linalg para solves implícitos",
                                    "Códigos anteriores"
                                  ],
                                  "tips": "Aproveite diagonalidade no espaço espectral para solves rápidos.",
                                  "learningObjective": "Demonstrar superioridade implícita em estabilidade para stiff systems.",
                                  "commonMistakes": [
                                    "Implementar solve implícito iterativamente sem convergência",
                                    "Esquecer pré-condicionadores para N grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e visualizar regiões instáveis no plano (Δt, N)",
                                  "subSteps": [
                                    "Compile dados de simulações: marque pontos (Δt, N) como estável/instável baseado em norma L2 < threshold.",
                                    "Gere heatmaps/contours no plano paramétrico usando Matplotlib/Seaborn.",
                                    "Compare curvas teóricas de estabilidade (ex.: |1 + λ Δt| <1 para explícito).",
                                    "Quantifique regiões: área instável explícita vs. implícita (quase nula).",
                                    "Documente insights em relatório com plots."
                                  ],
                                  "verification": "Produza plots finais mostrando regiões instáveis claramente delimitadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib, Seaborn para visualizações",
                                    "Dados de simulações anteriores"
                                  ],
                                  "tips": "Use log-scale para Δt em stiff regimes.",
                                  "learningObjective": "Identificar e visualizar quantitativamente regiões de instabilidade.",
                                  "commonMistakes": [
                                    "Threshold inadequado para 'instável'",
                                    "Plots sem legendas ou escalas claras"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de difusão reacional stiff: ∂u/∂t = Δu - 1000 u(1-u), com u inicial em pack de sinos. Use pseudoespectral em [0,2π] com N=128-512 pontos, Δt de 10^-4 a 10^-1. Observe blow-up explícito vs. convergência implícita, plotando regiões instáveis.",
                              "finalVerifications": [
                                "Plots do plano (Δt, N) mostram regiões instáveis para explícito e estável para implícito.",
                                "Soluções numéricas coincidem com analíticas em regimes estáveis.",
                                "Análise de erro L2 < 10^-6 para implícito em Δt grandes.",
                                "Relatório explica mecanismos de instabilidade espectral.",
                                "Código reproduzível gera resultados consistentes.",
                                "Comparação quantitativa: fator de estabilidade implícito >100x explícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação correta de stiffness e estabilidade espectral (30%).",
                                "Implementação funcional: códigos explícito/implícito corretos e eficientes (25%).",
                                "Análise visual: plots claros e informativos do plano paramétrico (20%).",
                                "Insights quantitativos: métricas de estabilidade e erros (15%).",
                                "Documentação: relatório completo com verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de fluidos turbulentos stiff (Navier-Stokes).",
                                "Engenharia Química: modelagem de reatores com cinéticas rápidas.",
                                "Ciência da Computação: otimização de solvers paralelos para N grande.",
                                "Física: ondas não-lineares e solitons em meios dispersivos."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM com stiff chemistry), onde métodos implícitos pseudoespectrais permitem Δt maiores, reduzindo custo computacional em supercomputadores para previsões precisas de longo prazo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.4",
                            "name": "Avaliar estabilidade via norma de energia",
                            "description": "Utilizar métodos de estimativa de energia espectral para provar estabilidade incondicional em esquemas pseudoespectrais para equações parabólicas, como a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de norma de energia e métodos pseudoespectrais",
                                  "subSteps": [
                                    "Estude a norma de energia contínua para a equação do calor: E(t) = ∫ |u(x,t)|^2 dx.",
                                    "Revise a expansão de Fourier e como os métodos pseudoespectrais aproximam derivadas via FFT.",
                                    "Entenda a discretização espacial periódica em uma grade uniforme com N pontos.",
                                    "Identifique por que a norma L2 discreta preserva propriedades espectrais.",
                                    "Pratique computando a norma L2 para uma função teste via soma discreta."
                                  ],
                                  "verification": "Construa um exemplo simples onde calcula a norma L2 de uma função senoidal discretizada e verifica preservação após transformação de Fourier.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Trefethen 'Spectral Methods'), Python/MATLAB com numpy.fft ou chebfun toolbox.",
                                  "tips": "Use condições periódicas para simplificar; visualize o espectro de energia com plots.",
                                  "learningObjective": "Compreender a conexão entre norma contínua e discreta em espaços espectrais.",
                                  "commonMistakes": "Confundir norma L2 com L-infinito; ignorar normalização da FFT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o esquema pseudoespectral para a equação do calor",
                                  "subSteps": [
                                    "Escreva a equação do calor: ∂u/∂t = ν ∂²u/∂x², com condições periódicas.",
                                    "Discretize espacialmente: transforme u_n para coeficientes espectrais û_k via FFT.",
                                    "Aproxime a derivada segunda: multiplicar por -k² (modos de Fourier).",
                                    "Escolha um esquema temporal implícito, como Crank-Nicolson: (u^{n+1} - u^n)/Δt = (L u^{n+1} + L u^n)/2, onde L é o operador Laplaciano espectral.",
                                    "Implemente uma iteração simples para um passo de tempo."
                                  ],
                                  "verification": "Codifique o esquema em Python e verifique que a solução numérica satisfaz a equação em um caso teste conhecido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook, bibliotecas NumPy/SciPy para FFT, referência: Canuto et al. 'Spectral Methods'.",
                                  "tips": "Dealise após cada passo espacial para evitar aliasing; teste com ν=1, domínio [0,2π].",
                                  "learningObjective": "Formular o esquema numérico híbrido pseudoespectral-temporal.",
                                  "commonMistakes": "Esquecer o fator i para derivadas pares; usar FFT sem padding."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e computar a norma de energia discreta",
                                  "subSteps": [
                                    "Defina a norma discreta: ||u^n||^2 = Δx ∑ |u_j^n|^2 = ∑ |û_k^n|^2 (Parseval).",
                                    "Prove Parseval para FFT discreta: energia física = energia espectral.",
                                    "Calcule a evolução da norma: derive ||u^{n+1}||^2 em termos de u^n.",
                                    "Introduza a estimativa espectral: |û_k| ≤ ||u|| para todos k.",
                                    "Verifique numericamente Parseval para uma solução inicial gaussiana."
                                  ],
                                  "verification": "Mostre que ||u||_físico ≈ ||û||_espectral com erro <1e-12.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código do Step 2 estendido, plotador de energia (matplotlib).",
                                  "tips": "Use np.sum(np.abs(hat_u)**2) para norma espectral; normalize pela raiz(N).",
                                  "learningObjective": "Dominar a conservação de energia via teorema de Parseval discreto.",
                                  "commonMistakes": "Não dividir por N na norma discreta; confundir soma com integral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a estimativa de energia espectral para estabilidade",
                                  "subSteps": [
                                    "Escreva o esquema em espaço espectral: d û_k / dt = -ν k² û_k.",
                                    "Para Crank-Nicolson: û_k^{n+1} = [1 - (Δt ν k²)/2]^{-1} [1 + (Δt ν k²)/2] û_k^n.",
                                    "Mostre |û_k^{n+1}| ≤ |û_k^n| para todo k, Δt >0 (módulo ≤1).",
                                    "Some sobre k: ||u^{n+1}|| ≤ ||u^n|| via Parseval.",
                                    "Generalize para esquemas A-estáveis."
                                  ],
                                  "verification": "Derive analiticamente o fator de amplificação e prove |g(k)| ≤1 ∀k,Δt.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel e lápis para derivação, SymPy para simplificação simbólica.",
                                  "tips": "Fatore como g(θ) com θ=Δt ν k²; plot |g(θ)| vs θ para visualização.",
                                  "learningObjective": "Provar dissipatividade espectral modo a modo.",
                                  "commonMistakes": "Ignorar o denominador implícito; assumir estabilidade condicional como em explícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar estabilidade incondicional numericamente e teoricamente",
                                  "subSteps": [
                                    "Simule longo tempo com Δt grande (ex: Δt=10, CFL>>1).",
                                    "Monitore ||u^n|| ao longo do tempo e confirme não-crescimento.",
                                    "Compare com esquema explícito instável para contraste.",
                                    "Estenda para equações parabólicas gerais: u_t = L u com L negativo semi-definido.",
                                    "Documente a prova completa: energia não aumenta."
                                  ],
                                  "verification": "Plot de log(||u^n||) plano ou decrescente para t>0, independentemente de Δt.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código integrado dos steps anteriores, solver de longo prazo.",
                                  "tips": "Use logscale para energia; teste N=128, 256 para convergência.",
                                  "learningObjective": "Concluir a prova de estabilidade incondicional via norma de energia.",
                                  "commonMistakes": "Poluição numérica em altos k; não checar aliasing."
                                }
                              ],
                              "practicalExample": "Considere a equação do calor 1D: u_t = u_xx em [0,2π] periódica, u(x,0)=sin(x). Use N=128, ν=1, Δt=5 (CFL≈100). Implemente pseudospectral Crank-Nicolson, compute ||u^n|| a cada 100 passos; observe dissipação estável sem oscilações, contrastando com Euler explícito que explode.",
                              "finalVerifications": [
                                "Derivação analítica mostra |g_k(Δt)| ≤1 para todo k e Δt>0.",
                                "Simulação numérica com Δt grande mantém ||u^n|| estável por t=100.",
                                "Parseval holds com erro <1e-14 em todos passos.",
                                "Energia total decresce monotonicamente como esperado.",
                                "Prova generaliza para qualquer operador Laplaciano espectral negativo.",
                                "Comparação com solução exata: erro L2 <1e-6 após muitos passos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação do fator de amplificação espectral (correto módulo e fase).",
                                "Correta implementação de FFT/iFFT com dealiasing se necessário.",
                                "Monitoramento quantitativo da norma de energia (plots e valores).",
                                "Identificação de independência de Δt na estabilidade.",
                                "Generalização lógica para outras equações parabólicas.",
                                "Clareza na explicação da conexão Parseval-energia."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e conservação de energia.",
                                "Engenharia Computacional: Simulações CFD estáveis em alto Reynolds.",
                                "Processamento de Sinais: Análise espectral e filtros estáveis.",
                                "Física Computacional: Dinâmica molecular com operadores espectrais."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (difusão de umidade), engenharia aeroespacial (fluxo viscoso em painéis solares) e processamento de imagens (suavização gaussiana estável), onde passos de tempo grandes aceleram computações sem instabilidade, permitindo simulações em tempo real de fenômenos difusivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 325
          }
        ],
        "totalSkills": 325
      }
    ]
  }
}